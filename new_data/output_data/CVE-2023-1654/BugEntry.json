{"buggy_code": ["\t/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / filters sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terfsess of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"filter_session.h\"\n#include <gpac/constants.h>\n#include <gpac/bitstream.h>\n\nstatic void free_evt(GF_FilterEvent *evt);\n\nstatic void pcki_del(GF_FilterPacketInstance *pcki)\n{\n\tassert(pcki->pck->reference_count);\n\tif (safe_int_dec(&pcki->pck->reference_count) == 0) {\n\t\tgf_filter_packet_destroy(pcki->pck);\n\t}\n\tgf_free(pcki);\n}\n\nvoid gf_filter_pid_inst_reset(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\twhile (gf_fq_count(pidinst->packets)) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_pop(pidinst->packets);\n\t\tpcki_del(pcki);\n\t}\n\n\twhile (gf_list_count(pidinst->pck_reassembly)) {\n\t\tGF_FilterPacketInstance *pcki = gf_list_pop_back(pidinst->pck_reassembly);\n\t\tpcki_del(pcki);\n\t}\n}\n\nvoid gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}\n\nstatic GF_FilterPidInst *gf_filter_pid_inst_new(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tGF_FilterPidInst *pidinst;\n\tGF_SAFEALLOC(pidinst, GF_FilterPidInst);\n\tif (!pidinst) return NULL;\n\tpidinst->pid = pid;\n\tpidinst->filter = filter;\n\n\tif (filter->session->use_locks) {\n\t\tchar szName[200];\n\t\tu32 pid_idx = 1 + gf_list_find(pid->filter->output_pids, pid);\n\t\tu32 dst_idx = 1 + pid->num_destinations;\n\t\tsnprintf(szName, 200, \"F%sPid%dDest%dPackets\", filter->name, pid_idx, dst_idx);\n\t\tpidinst->pck_mx = gf_mx_new(szName);\n\t}\n\n\tpidinst->packets = gf_fq_new(pidinst->pck_mx);\n\n\tpidinst->pck_reassembly = gf_list_new();\n\tpidinst->last_block_ended = GF_TRUE;\n\treturn pidinst;\n}\n\nstatic void gf_filter_pid_check_unblock(GF_FilterPid *pid)\n{\n\tBool unblock;\n\n\tif (pid->ignore_blocking) {\n\t\treturn;\n\t}\n\t//if we are in end of stream state and done with all packets, stay blocked\n\tif (pid->has_seen_eos && !pid->nb_buffer_unit) {\n\t\tif (!pid->would_block) {\n\t\t\tsafe_int_inc(&pid->would_block);\n\t\t\tsafe_int_inc(&pid->filter->would_block);\n\t\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\t\t}\n\t\treturn;\n\t}\n\n\tunblock=GF_FALSE;\n\n\tassert(pid->playback_speed_scaler);\n\n\t//we block according to the number of dispatched units (decoder output) or to the requested buffer duration\n\t//for other streams - unblock accordingly\n\tif (pid->max_buffer_unit) {\n\t\tif (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER < pid->max_buffer_unit * pid->playback_speed_scaler) {\n\t\t\tunblock=GF_TRUE;\n\t\t}\n\t} else if (pid->buffer_duration * GF_FILTER_SPEED_SCALER < pid->max_buffer_time * pid->playback_speed_scaler) {\n\t\tunblock=GF_TRUE;\n\t}\n\n\tif (!unblock) {\n\t\treturn;\n\t}\n\tgf_mx_p(pid->filter->tasks_mx);\n\tunblock = GF_FALSE;\n\n\t//unblock pid\n\tif (pid->would_block) {\n\t\tsafe_int_dec(&pid->would_block);\n\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t\tassert((s32)pid->filter->would_block>=0);\n\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s unblocked (filter has %d blocking pids)\\n\", pid->pid->filter->name, pid->pid->name, pid->pid->filter->would_block));\n\n\t\t//check filter unblock\n\t\tunblock = GF_TRUE;\n\t}\n\t//pid was not blocking but filter is no longer scheduled (might happen in multi-threaded modes), check filter unblock\n\telse if (!pid->filter->process_task_queued) {\n\t\tunblock = GF_TRUE;\n\t}\n\n\tif (unblock && (pid->filter->would_block + pid->filter->num_out_pids_not_connected < pid->filter->num_output_pids)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has only %d / %d blocked pids, requesting process task (%d queued)\\n\", pid->filter->name, pid->filter->would_block + pid->filter->num_out_pids_not_connected, pid->filter->num_output_pids, pid->filter->process_task_queued));\n\n\t\t//post a process task\n\t\tgf_filter_post_process_task(pid->filter);\n\t}\n\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\nstatic void gf_filter_pid_inst_check_dependencies(GF_FilterPidInst *pidi)\n{\n\tconst GF_PropertyValue *p;\n\tu32 i, dep_id = 0;\n\tGF_FilterPid *pid = pidi->pid;\n\tGF_Filter *filter = pid->filter;\n\n\t//check pid dependency\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) dep_id = p->value.uint;\n\n\tif (!dep_id) return;\n\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *a_pid = gf_list_get(filter->output_pids, i);\n\t\tif (a_pid==pid) continue;\n\t\tp = gf_filter_pid_get_property_first(a_pid, GF_PROP_PID_ID);\n\t\tif (!p) p = gf_filter_pid_get_property_first(a_pid, GF_PROP_PID_ESID);\n\t\tif (!p || (p->value.uint != dep_id)) continue;\n\n\t\tfor (j=0; j<a_pid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(a_pid->destinations, j);\n\t\t\tif (a_pidi == pidi) continue;\n\t\t\tif (! a_pidi->is_decoder_input) continue;\n\n\t\t\tif (a_pidi->filter == pidi->filter) continue;\n\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Filter %s PID %s connected to decoder %s, but dependent stream %s connected to %s - switching pid destination\\n\", a_pid->filter->name, a_pid->name, a_pidi->filter->name, pidi->pid->name, pidi->filter->name));\n\n\t\t\t//disconnect this pid instance from its current decoder\n\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_disconnect_task, a_pidi->filter, a_pid, \"pidinst_disconnect\", NULL);\n\n\t\t\t//reconnect this pid instance to the new decoder\n\t\t\tsafe_int_inc(&pid->filter->out_pid_connection_pending);\n\t\t\tgf_filter_pid_post_connect_task(pidi->filter, a_pid);\n\n\t\t}\n\t}\n}\n\nstatic void gf_filter_pid_update_caps(GF_FilterPid *pid)\n{\n\tu32 mtype=0, codecid=0;\n\tu32 i;\n\tconst GF_PropertyValue *p;\n\n\tpid->raw_media = GF_FALSE;\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_CODECID);\n\tif (p) codecid = p->value.uint;\n\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) mtype = p->value.uint;\n\n\tBool was_sparse = pid->is_sparse;\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_SPARSE);\n\tif (p) {\n\t\tpid->is_sparse = p->value.boolean;\n\t} else {\n\t\tu32 otype = mtype;\n\t\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\tif (p) otype = p->value.uint;\n\t\tswitch (otype) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_FILE:\n\t\t\tpid->is_sparse = GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpid->is_sparse = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (was_sparse && !pid->is_sparse)\n\t\tsafe_int_dec(&pid->filter->nb_sparse_pids);\n\telse if (!was_sparse && pid->is_sparse)\n\t\tsafe_int_inc(&pid->filter->nb_sparse_pids);\n\n\n\tpid->stream_type = mtype;\n\tpid->codecid = codecid;\n\n\tu32 buffer_us = pid->filter->pid_buffer_max_us ? pid->filter->pid_buffer_max_us : pid->filter->session->default_pid_buffer_max_us;\n\tif (pid->user_max_buffer_time) {\n\t\tpid->max_buffer_time = MAX(pid->user_max_buffer_time, buffer_us);\n\t\tpid->max_buffer_unit = 0;\n\t} else {\n\t\tpid->max_buffer_time = buffer_us;\n\t\tpid->max_buffer_unit = pid->filter->pid_buffer_max_units ? pid->filter->pid_buffer_max_units : pid->filter->session->default_pid_buffer_max_units;\n\t}\n\tpid->raw_media = GF_FALSE;\n\n\tif (codecid!=GF_CODECID_RAW) {\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\t\tu32 i_codecid=0, i_type=0;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\t\tif (!pidi->pid) continue;\n\t\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (p) i_type = p->value.uint;\n\n\t\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) i_codecid = p->value.uint;\n\t\t\t//same stream type but changing from raw to not raw: this is an encoder input pid\n\t\t\tif ((mtype==i_type) && (i_codecid==GF_CODECID_RAW)) {\n\t\t\t\tpidi->is_encoder_input = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn;\n\t}\n\n\t//output is a decoded raw stream: if some input has same type but different codecid this is a decoder\n\t//set input buffer size\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tu32 i_codecid=0, i_type=0;\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (!pidi->pid) continue;\n\n\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (p) i_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);\n\t\tif (p) i_codecid = p->value.uint;\n\n\t\t//same stream type but changing format type: this is a decoder input pid, set buffer req\n\t\tif ((mtype==i_type) && (codecid != i_codecid)) {\n\n\t\t\tbuffer_us = pid->filter->pid_decode_buffer_max_us ? pid->filter->pid_decode_buffer_max_us : pid->filter->session->decoder_pid_buffer_max_us;\n\t\t\t//default decoder buffer\n\t\t\tpidi->pid->max_buffer_time = MAX(pidi->pid->user_max_buffer_time, buffer_us);\n\t\t\tpidi->pid->max_buffer_unit = 0;\n\n\t\t\t//composition buffer\n\t\t\tif (pid->filter->pid_buffer_max_units) {\n\t\t\t\tpid->max_buffer_unit = pid->filter->pid_buffer_max_units;\n\t\t\t} else if (mtype==GF_STREAM_VISUAL) {\n\t\t\t\tpid->max_buffer_unit = 4;\n\t\t\t} else if (mtype==GF_STREAM_AUDIO) {\n\t\t\t\tpid->max_buffer_unit = 20;\n\t\t\t}\n\n\t\t\tif (!pidi->is_decoder_input) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s pid instance %s marked as decoder input\\n\",  pidi->pid->filter->name, pidi->pid->name));\n\t\t\t\tpidi->is_decoder_input = GF_TRUE;\n\t\t\t\tsafe_int_inc(&pidi->pid->nb_decoder_inputs);\n\n\t\t\t\tif ((i_type == GF_STREAM_AUDIO) || (i_type == GF_STREAM_VISUAL))\n\t\t\t\t\tgf_filter_pid_inst_check_dependencies(pidi);\n\t\t\t}\n\t\t}\n\t\t//same media type, same codec: raw stream\n\t\telse if (mtype==i_type) {\n\t\t\tpid->raw_media = GF_TRUE;\n\t\t\t//special case if single input pid filter, copy buffer props from input\n\t\t\tif (pid->filter->num_input_pids==1) {\n\t\t\t\tGF_FilterPidInst *pid_in = gf_list_get(pid->filter->input_pids, i);\n\t\t\t\tif ((pid_in->pid->max_buffer_unit>1) || pid_in->pid->max_buffer_time) {\n\t\t\t\t\tpid->max_buffer_unit = pid_in->pid->max_buffer_unit;\n\t\t\t\t\tpid->filter->pid_buffer_max_units = pid_in->pid->max_buffer_unit;\n\t\t\t\t\tpid->max_buffer_time = pid_in->pid->max_buffer_time;\n\t\t\t\t\tpid->filter->pid_buffer_max_us = (u32) pid_in->pid->max_buffer_time;\n\t\t\t\t}\n\t\t\t\t//if input has a single destination, reset buffer props to default\n\t\t\t\tif (pid_in->pid->num_destinations==1) {\n\t\t\t\t\tpid_in->pid->max_buffer_unit = 1;\n\t\t\t\t\tpid_in->pid->max_buffer_time = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//input is file, output is not and codec ID is raw, this is a raw media pid\n\t\telse if ((i_type==GF_STREAM_FILE) && (mtype!=GF_STREAM_FILE) && (codecid==GF_CODECID_RAW) ) {\n\t\t\tpid->raw_media = GF_TRUE;\n\t\t}\n\t}\n\t//source pid, mark raw media\n\tif (!pid->filter->num_input_pids && pid->num_destinations) {\n\t\tpid->raw_media = GF_TRUE;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\n#define TASK_REQUEUE(_t) \\\n\t_t->requeue_request = GF_TRUE; \\\n\t_t->schedule_next_time = gf_sys_clock_high_res() + 50; \\\n\nvoid gf_filter_pid_inst_delete_task(GF_FSTask *task)\n{\n\tGF_FilterPid *pid = task->pid;\n\tGF_FilterPidInst *pidinst = task->udta;\n\tGF_Filter *filter = pid->filter;\n\tBool pid_still_alive = GF_FALSE;\n\n\tassert(filter);\n\t//reset in process\n\tif ((pidinst->filter && pidinst->discard_packets) || filter->stream_reset_pending || filter->abort_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\t//reset PID instance buffers before checking number of output shared packets\n\t//otherwise we may block because some of the shared packets are in the\n\t//pid instance buffer (not consumed)\n\tgf_filter_pid_inst_reset(pidinst);\n\n\t//we still have packets out there!\n\tif (pidinst->pid->nb_shared_packets_out) {\n\t\t//special case for disconnect of fanouts, destroy even if shared packets out\n\t\tif (!pid->num_destinations || ((pid->num_destinations>=1) && (gf_list_find(pid->destinations, pidinst)>=0))) {\n\t\t\tTASK_REQUEUE(task)\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//WARNING at this point pidinst->filter may be destroyed\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid instance %s destruction (%d fan-out)\\n\",  filter->name, pid->name, pid->num_destinations));\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tif (pidinst->pid->num_pidinst_del_pending) {\n\t\tpidinst->pid->num_pidinst_del_pending--;\n\t\tif (pidinst->pid->num_pidinst_del_pending)\n\t\t\tpid_still_alive = GF_TRUE;\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\n\tif (pidinst->is_decoder_input) {\n\t\tassert(pid->nb_decoder_inputs);\n\t\tsafe_int_dec(&pid->nb_decoder_inputs);\n\t}\n\tgf_filter_pid_inst_del(pidinst);\n\t//recompute max buf dur and nb units to update blocking state\n\tif (pid->num_destinations) {\n\t\tu32 i;\n\t\tu32 nb_pck = 0;\n\t\ts64 buf_dur = 0;\n\t\tfor (i = 0; i < pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(pid->destinations, i);\n\t\t\tu32 npck = gf_fq_count(apidi->packets);\n\t\t\tif (npck > nb_pck) nb_pck = npck;\n\t\t\tif (apidi->buffer_duration > buf_dur) buf_dur = apidi->buffer_duration;\n\t\t}\n\t\tpid->nb_buffer_unit = nb_pck;\n\t\tpid->buffer_duration = buf_dur;\n\t} else {\n\t\tpid->nb_buffer_unit = 0;\n\t\tpid->buffer_duration = 0;\n\t}\n\n\tassert(pid->filter == filter);\n\n\tif (pid_still_alive)\n\t\treturn;\n\n\t//some more destinations on pid, update blocking state\n\tif (pid->num_destinations || pid->init_task_pending) {\n\t\tif (pid->would_block)\n\t\t\tgf_filter_pid_check_unblock(pid);\n\t\telse\n\t\t\tgf_filter_pid_would_block(pid);\n\n\t\treturn;\n\t}\n\tgf_mx_p(filter->tasks_mx);\n\t//still some input to the filter, cannot destroy the output pid\n\tif (gf_list_count(filter->input_pids)) {\n\t\tgf_mx_v(filter->tasks_mx);\n\t\treturn;\n\t}\n\t//no more destinations on pid, unblock if blocking\n\tif (pid->would_block) {\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t}\n\n\t//we cannot remove an output pid since the filter may still check status on that pid or try to dispatch packets\n\t//removal/destruction must come from the filter\n\t//we only count the number of output pids that have been internally discarded by this function, and trigger filter removal if last\n\tpid->removed = GF_TRUE;\n\n\t//filter still active and has no input, check if there are no more output pids valid. If so, remove filter\n\tif (!gf_list_count(filter->input_pids) && !filter->finalized) {\n\t\tu32 i, nb_opid_rem=0;\n\t\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(filter->output_pids, i);\n\t\t\tif (apid->removed) nb_opid_rem++;\n\t\t}\n\t\tif (gf_list_count(filter->output_pids)==nb_opid_rem) {\n\t\t\tgf_filter_post_remove(filter);\n\t\t}\n\t}\n\n\tgf_mx_v(filter->tasks_mx);\n}\n\nstatic void gf_filter_pid_inst_swap_delete(GF_Filter *filter, GF_FilterPid *pid, GF_FilterPidInst *pidinst, GF_FilterPidInst *dst_swapinst)\n{\n\tu32 i, j;\n\n\t//reset PID instance buffers before checking number of output shared packets\n\t//otherwise we may block because some of the shared packets are in the\n\t//pid instance buffer (not consumed)\n\tgf_filter_pid_inst_reset(pidinst);\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid instance %s swap destruction\\n\",  filter->name, pidinst->pid ? pidinst->pid->name : pid->name));\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_del_item(filter->input_pids, pidinst);\n\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\tif (!filter->num_input_pids)\n\t\tfilter->single_source = NULL;\n\tgf_mx_v(filter->tasks_mx);\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\n\tif (pidinst->is_decoder_input) {\n\t\tassert(pid->nb_decoder_inputs);\n\t\tsafe_int_dec(&pid->nb_decoder_inputs);\n\t}\n\t//this pid instance is registered to destination filter for chain reconfigure, don't discard it\n\tif (filter->detached_pid_inst && (gf_list_find(filter->detached_pid_inst, pidinst)>=0) )\n\t\treturn;\n\n\tgf_filter_pid_inst_del(pidinst);\n\n\tif (filter->num_input_pids) return;\n\t//we still have other pid instances registered for chain reconfigure, don't discard the filter\n\tif (filter->detached_pid_inst) return;\n\n\t//filter no longer used, disconnect chain\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *a_pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<a_pid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(a_pid->destinations, j);\n\t\t\tif (a_pidi == dst_swapinst) continue;\n\n\t\t\tgf_filter_pid_inst_swap_delete(a_pidi->filter, a_pid, a_pidi, dst_swapinst);\n\t\t}\n\t}\n\tfilter->swap_pidinst_dst = NULL;\n\tfilter->swap_pidinst_src = NULL;\n\tgf_filter_post_remove(filter);\n}\n\nstatic void gf_filter_pid_inst_swap_delete_task(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidinst = task->udta;\n\tGF_Filter *filter = pidinst->filter;\n\tGF_FilterPid *pid = task->pid ? task->pid : pidinst->pid;\n\tGF_FilterPidInst *dst_swapinst = pidinst->filter->swap_pidinst_dst;\n\n\t//reset in process\n\tif ((pidinst->filter && pidinst->discard_packets)\n\t\t|| filter->stream_reset_pending\n\t\t|| filter->nb_shared_packets_out\n\t) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\tif (pidinst->filter)\n\t\tpidinst->filter->swap_pidinst_dst = NULL;\n\n\tgf_filter_pid_inst_swap_delete(filter, pid, pidinst, dst_swapinst);\n}\n\nstatic void gf_filter_pid_inst_swap(GF_Filter *filter, GF_FilterPidInst *dst)\n{\n\tGF_PropertyMap *prev_dst_props;\n\tu32 nb_pck_transfer=0;\n\tGF_FilterPidInst *src = filter->swap_pidinst_src;\n\tif (!src) src = filter->swap_pidinst_dst;\n\t\n\tif (src) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s swaping PID %s to PID %s\\n\", filter->name, src->pid->name, dst->pid->name));\n\t}\n\n\t\n\tif (filter->swap_needs_init) {\n\t\t//we are in detach state, the packet queue of the old PID is never read\n\t\tassert(filter->swap_pidinst_dst && filter->swap_pidinst_dst->detach_pending);\n\t\t//we are in pending state, the origin of the old PID is never dispatching\n//\t\tassert(dst->pid && dst->pid->filter && dst->pid->filter->out_pid_connection_pending);\n\t\t//we can therefore swap the packet queues safely and other important info\n\t}\n\t//otherwise we actually swap the pid instance on the same PID\n\telse {\n\t\tgf_mx_p(dst->pid->filter->tasks_mx);\n\t\tif (src)\n\t\t\tgf_list_del_item(dst->pid->destinations, src);\n\t\tif (gf_list_find(dst->pid->destinations, dst)<0)\n\t\t\tgf_list_add(dst->pid->destinations, dst);\n\t\tdst->pid->num_destinations = gf_list_count(dst->pid->destinations);\n\t\tif (gf_list_find(dst->filter->input_pids, dst)<0) {\n\t\t\tgf_list_add(dst->filter->input_pids, dst);\n\t\t\tdst->filter->num_input_pids = gf_list_count(dst->filter->input_pids);\n\n\t\t\tif (dst->filter->num_input_pids==1) {\n\t\t\t\tdst->filter->single_source = dst->pid->filter;\n\t\t\t} else if (dst->filter->single_source != dst->pid->filter) {\n\t\t\t\tdst->filter->single_source = NULL;\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(dst->pid->filter->tasks_mx);\n\t}\n\n\tif (src) {\n\t\tGF_FilterPacketInstance *pcki;\n\t\twhile (1) {\n\t\t\tpcki = gf_fq_pop(src->packets);\n\t\t\tif (!pcki) break;\n\t\t\tassert(src->filter->pending_packets);\n\t\t\tsafe_int_dec(&src->filter->pending_packets);\n\n\t\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\t\tassert(src->filter->nb_main_thread_forced);\n\t\t\t\tsafe_int_dec(&src->filter->nb_main_thread_forced);\n\t\t\t\tsafe_int_inc(&dst->filter->nb_main_thread_forced);\n\t\t\t}\n\t\t\tpcki->pid = dst;\n\t\t\tgf_fq_add(dst->packets, pcki);\n\t\t\tsafe_int_inc(&dst->filter->pending_packets);\n\t\t\tnb_pck_transfer++;\n\t\t}\n\t\tif (src->requires_full_data_block && gf_list_count(src->pck_reassembly)) {\n\t\t\tdst->requires_full_data_block = src->requires_full_data_block;\n\t\t\tdst->last_block_ended = src->last_block_ended;\n\t\t\tdst->first_block_started = src->first_block_started;\n\t\t\tif (!dst->pck_reassembly) dst->pck_reassembly = gf_list_new();\n\t\t\twhile (gf_list_count(src->pck_reassembly)) {\n\t\t\t\tpcki = gf_list_pop_front(src->pck_reassembly);\n\t\t\t\tpcki->pid = dst;\n\t\t\t\tgf_list_add(dst->pck_reassembly, pcki);\n\t\t\t}\n\t\t}\n\t\t//copy over state\n\t\tdst->is_end_of_stream = src->is_end_of_stream;\n\t\tdst->nb_eos_signaled = src->nb_eos_signaled;\n\t\tdst->buffer_duration = src->buffer_duration;\n\t\tdst->nb_clocks_signaled = src->nb_clocks_signaled;\n\n\t\t//switch previous src property map to this new pid (this avoids rewriting props of already dispatched packets)\n\t\t//it may happen that we already have props on dest, due to configure of the pid\n\t\t//use the old props as new ones and merge the previous props of dst in the new props\n\t\tprev_dst_props = dst->props;\n\t\tdst->props = src->props;\n\t\tdst->force_reconfig = GF_TRUE;\n\t\tsrc->force_reconfig = GF_TRUE;\n\t\tsrc->props = NULL;\n\t\tif (prev_dst_props) {\n\t\t\tif (dst->props) {\n\t\t\t\tgf_props_merge_property(dst->props, prev_dst_props, NULL, NULL);\n\t\t\t\tassert(prev_dst_props->reference_count);\n\t\t\t\tif (safe_int_dec(&prev_dst_props->reference_count) == 0) {\n\t\t\t\t\tgf_props_del(prev_dst_props);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->props = prev_dst_props;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_pck_transfer && !dst->filter->process_task_queued) {\n\t\t\tgf_filter_post_process_task(dst->filter);\n\t\t}\n\t}\n\n\n\tsrc = filter->swap_pidinst_dst;\n\tif (src) {\n\t\tif (filter->swap_needs_init) {\n\t\t\t//exit out special handling of the pid since we are ready to detach\n\t\t\tassert(src->filter->stream_reset_pending);\n\t\t\tsafe_int_dec(&src->filter->stream_reset_pending);\n\n\t\t\t//post detach task, we will reset the swap_pidinst only once truly deconnected from filter\n\t\t\tsafe_int_inc(&src->pid->filter->detach_pid_tasks_pending);\n\t\t\tsafe_int_inc(&filter->detach_pid_tasks_pending);\n\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_detach_task, src->filter, src->pid, \"pidinst_detach\", filter);\n\t\t} else {\n\t\t\tGF_Filter *src_filter = src->filter;\n\t\t\tassert(!src->filter->sticky);\n\t\t\tassert(src->filter->num_input_pids==1);\n\n\t\t\tgf_mx_p(src_filter->tasks_mx);\n\t\t\tgf_list_del_item(src_filter->input_pids, src);\n\t\t\tsrc_filter->num_input_pids = gf_list_count(src_filter->input_pids);\n\t\t\tif (!src_filter->num_input_pids)\n\t\t\t\tsrc_filter->single_source = NULL;\n\t\t\tgf_mx_v(src_filter->tasks_mx);\n\n\t\t\tgf_list_del_item(src->pid->destinations, src);\n\t\t\tsrc->pid->num_destinations = gf_list_count(src->pid->destinations);\n\t\t\tgf_filter_pid_inst_del(src);\n\n\t\t\tfilter->swap_pidinst_dst = NULL;\n\t\t\tfilter->swap_pidinst_src = NULL;\n\t\t\tgf_filter_post_remove(src_filter);\n\t\t}\n\t}\n\t\n\tif (filter->swap_pidinst_src) {\n\t\tsrc = filter->swap_pidinst_src;\n\t\tassert(!src->filter->swap_pidinst_dst);\n\t\tsrc->filter->swap_pidinst_dst = filter->swap_pidinst_dst;\n\t\tsrc->filter->swap_pending = GF_TRUE;\n\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_swap_delete_task, src->filter, src->pid, \"pid_inst_delete\", src);\n\t}\n}\n\n//check all packets scheduled on main thread, unflag dest filter nb_main_thread_forced and set dest to NULL\n//we must do that because the packets may be destroyed after the pid instance is detached\n//so the destination filter would be NULL by then\nvoid gf_filter_instance_detach_pid(GF_FilterPidInst *pidinst)\n{\n\tu32 i, count;\n\tif (!pidinst->filter) return;\n\n\tcount = gf_fq_count(pidinst->packets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_get(pidinst->packets, i);\n\t\tif (!pcki) break;\n\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t\t}\n\t}\n\tcount = gf_list_count(pidinst->pck_reassembly);\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterPacketInstance *pcki = gf_list_get(pidinst->pck_reassembly, i);\n\t\tif (!pcki) break;\n\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t\t}\n\t}\n\tpidinst->filter = NULL;\n}\n\nvoid task_canceled(GF_FSTask *task)\n{\n\tif (task->class_type==TASK_TYPE_EVENT) {\n\t\tGF_FilterEvent *evt = task->udta;\n\t\tfree_evt(evt);\n\t}\n\telse if (task->class_type==TASK_TYPE_SETUP) {\n\t\tgf_free(task->udta);\n\t}\n\telse if (task->class_type==TASK_TYPE_USER) {\n\t\tgf_free(task->udta);\n\t\tgf_free((char *)task->log_name);\n\t\ttask->log_name = NULL;\n\t}\n}\n\n\ntypedef enum {\n\tGF_PID_CONF_CONNECT,\n\tGF_PID_CONF_RECONFIG,\n\tGF_PID_CONF_REMOVE,\n} GF_PidConnectType;\n\nstatic GF_Err gf_filter_pid_configure(GF_Filter *filter, GF_FilterPid *pid, GF_PidConnectType ctype)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tBool refire_events=GF_FALSE;\n\tBool new_pid_inst=GF_FALSE;\n\tBool remove_filter=GF_FALSE;\n\tGF_FilterPidInst *pidinst=NULL;\n\tGF_Filter *alias_orig = NULL;\n\n\tif (filter->multi_sink_target) {\n\t\talias_orig = filter;\n\t\tfilter = filter->multi_sink_target;\n\t}\n\n\tassert(filter->freg->configure_pid);\n\tif (filter->finalized) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to configure PID %s in finalized filter %s\\n\",  pid->name, filter->name));\n\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\tassert(pid->filter->out_pid_connection_pending);\n\t\t\tsafe_int_dec(&pid->filter->out_pid_connection_pending);\n\t\t}\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\n\tif (filter->detached_pid_inst) {\n\t\tcount = gf_list_count(filter->detached_pid_inst);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tpidinst = gf_list_get(filter->detached_pid_inst, i);\n\t\t\tif (pidinst->filter==filter) {\n\t\t\t\tgf_list_rem(filter->detached_pid_inst, i);\n\t\t\t\t//reattach new filter and pid\n\t\t\t\tpidinst->filter = filter;\n\t\t\t\tpidinst->pid = pid;\n\n\t\t\t\tassert(!pidinst->props);\n\n\t\t\t\t//and treat as new pid inst\n\t\t\t\tif (ctype == GF_PID_CONF_CONNECT) {\n\t\t\t\t\tnew_pid_inst=GF_TRUE;\n\t\t\t\t\tif (!pid->filter->nb_pids_playing && (pidinst->is_playing || pidinst->is_paused))\n\t\t\t\t\t\trefire_events = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tassert(pidinst->detach_pending);\n\t\t\t\tsafe_int_dec(&pidinst->detach_pending);\n\t\t\t\t//revert temp sticky flag\n\t\t\t\tif (filter->sticky == 2)\n\t\t\t\t\tfilter->sticky = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpidinst=NULL;\n\t\t}\n\t\tif (! gf_list_count(filter->detached_pid_inst)) {\n\t\t\tgf_list_del(filter->detached_pid_inst);\n\t\t\tfilter->detached_pid_inst = NULL;\n\t\t}\n\t}\n\tif (!pidinst) {\n\t\tcount = pid->num_destinations;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tpidinst = gf_list_get(pid->destinations, i);\n\t\t\tif (pidinst->filter==filter) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpidinst=NULL;\n\t\t}\n\t}\n\n\t//first connection of this PID to this filter\n\tif (!pidinst) {\n\t\tif (ctype != GF_PID_CONF_CONNECT) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to disconnect PID %s not present in filter %s inputs\\n\",  pid->name, filter->name));\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tpidinst = gf_filter_pid_inst_new(filter, pid);\n\t\tnew_pid_inst=GF_TRUE;\n\t}\n\tif (!pidinst->alias_orig)\n\t\tpidinst->alias_orig = alias_orig;\n\n\t//if new, add the PID to input/output before calling configure\n\tif (new_pid_inst) {\n\t\tassert(pidinst);\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Registering %s:%s as destination for %s:%s\\n\", pid->filter->name, pid->name, pidinst->filter->name, pidinst->pid->name));\n\t\tgf_list_add(pid->destinations, pidinst);\n\t\tpid->num_destinations = gf_list_count(pid->destinations);\n\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tif (!filter->input_pids) filter->input_pids = gf_list_new();\n\t\tgf_list_add(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (filter->num_input_pids==1) {\n\t\t\tfilter->single_source = pidinst->pid->filter;\n\t\t} else if (filter->single_source != pidinst->pid->filter) {\n\t\t\tfilter->single_source = NULL;\n\t\t}\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t//new connection, update caps in case we have events using caps (buffer req) being sent\n\t\t//while processing the configure (they would be dispatched on the source filter, not the dest one being\n\t\t//processed here)\n\t\tgf_filter_pid_update_caps(pid);\n\t}\n\n\t//we are swaping a PID instance (dyn insert of a filter), do it before reconnecting\n\t//in order to have properties in place\n\t//TODO: handle error case, we might need to re-switch the pid inst!\n\tif (filter->swap_pending) {\n\t\tgf_filter_pid_inst_swap(filter, pidinst);\n\t\tfilter->swap_pending = GF_FALSE;\n\t}\n\n\tfilter->in_connect_err = GF_EOS;\n\t//commented out: audio thread may be pulling packets out of the pid but not in the compositor:process, which\n\t//could be called for video at the same time...\n#if 0\n\tFSESS_CHECK_THREAD(filter)\n#endif\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s reconfigure\\n\", pidinst->filter->name, pidinst->pid->name));\n\te = filter->freg->configure_pid(filter, (GF_FilterPid*) pidinst, (ctype==GF_PID_CONF_REMOVE) ? GF_TRUE : GF_FALSE);\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (filter->session->check_allocs) {\n\t\tif (filter->nb_consecutive_process >= filter->max_nb_consecutive_process) {\n\t\t\tfilter->max_nb_consecutive_process = filter->nb_consecutive_process;\n\t\t\tfilter->max_nb_process = filter->nb_process_since_reset;\n\t\t\tfilter->max_stats_nb_alloc = filter->stats_nb_alloc;\n\t\t\tfilter->max_stats_nb_calloc = filter->stats_nb_calloc;\n\t\t\tfilter->max_stats_nb_realloc = filter->stats_nb_realloc;\n\t\t\tfilter->max_stats_nb_free = filter->stats_nb_free;\n\t\t}\n\t\tfilter->stats_mem_allocated = 0;\n\t\tfilter->stats_nb_alloc = filter->stats_nb_realloc = filter->stats_nb_free = 0;\n\t\tfilter->nb_process_since_reset = filter->nb_consecutive_process = 0;\n\t}\n#endif\n\tif ((e==GF_OK) && (filter->in_connect_err<GF_OK))\n\t\te = filter->in_connect_err;\n\n\tfilter->in_connect_err = GF_OK;\n\t\n\tif (e==GF_OK) {\n\t\t//if new, register the new pid instance, and the source pid as input to this filter\n\t\tif (new_pid_inst) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s (%p) PID %s (%p) (%d fan-out) connected to filter %s (%p)\\n\", pid->filter->name, pid->filter, pid->name, pid, pid->num_destinations, filter->name, filter));\n\t\t}\n\t\t//reset blacklist on source if connect OK - this is required when reconfiguring multiple times to the same filter, eg\n\t\t//jpeg->raw->jpeg, the first jpeg->raw would blacklist jpeg dec from source, preventing resolution to work at raw->jpeg switch\n\t\tgf_list_reset(pidinst->pid->filter->blacklisted);\n\t}\n\t//failure on reconfigure, try reloading a filter chain\n\telse if ((ctype==GF_PID_CONF_RECONFIG) && (e != GF_FILTER_NOT_SUPPORTED)) {\n\t\t//mark pid as end of stream to let filter flush\n\t\tpidinst->is_end_of_stream = GF_TRUE;\n\t\tif (e==GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to reconfigure PID %s:%s in filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\n\t\t\tfilter->session->last_connect_error = e;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Failed to reconfigure PID %s:%s in filter %s: %s, reloading filter graph\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t\tgf_list_add(pid->filter->blacklisted, (void *) filter->freg);\n\t\t\tgf_filter_relink_dst(pidinst, e);\n\t\t}\n\t} else {\n\n\t\t//error, remove from input and output\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (!filter->num_input_pids)\n\t\t\tfilter->single_source = NULL;\n\t\tfilter->freg->configure_pid(filter, (GF_FilterPid *) pidinst, GF_TRUE);\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\tgf_list_del_item(pidinst->pid->destinations, pidinst);\n\t\tpidinst->pid->num_destinations = gf_list_count(pidinst->pid->destinations);\n\t\t//detach filter from pid instance\n\t\tgf_filter_instance_detach_pid(pidinst);\n\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\n\t\t//if connect and error, direct delete of pid\n\t\tif (new_pid_inst) {\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pid->destinations, pidinst);\n\t\t\tpid->num_destinations = gf_list_count(pid->destinations);\n\n\t\t\t//cancel all tasks targeting this pid\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tcount = gf_fq_count(pid->filter->tasks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FSTask *t = gf_fq_get(pid->filter->tasks, i);\n\t\t\t\tif (t->pid == (GF_FilterPid *) pidinst) {\n\t\t\t\t\tt->run_task = task_canceled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\t\t//destroy pid instance\n\t\t\tgf_filter_pid_inst_del(pidinst);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t}\n\n\n\t\tif (e==GF_REQUIRES_NEW_INSTANCE) {\n\t\t\t//TODO: copy over args from current filter\n\t\t\tGF_Filter *new_filter = gf_filter_clone(filter, pid->filter);\n\t\t\tif (new_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Clone filter %s, new instance for pid %s\\n\", filter->name, pid->name));\n\t\t\t\tgf_filter_pid_post_connect_task(new_filter, pid);\n\t\t\t\treturn GF_OK;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to clone filter %s\\n\", filter->name));\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (e && (ctype==GF_PID_CONF_REMOVE)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to disconnect filter %s PID %s from filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t}\n\t\telse if (e) {\n\t\t\tif (e!= GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to connect filter %s PID %s to filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t\t}\n\n\t\t\tif ((e==GF_BAD_PARAM)\n\t\t\t\t|| (e==GF_SERVICE_ERROR)\n\t\t\t\t|| (e==GF_REMOTE_SERVICE_ERROR)\n\t\t\t\t|| (e==GF_FILTER_NOT_SUPPORTED)\n\t\t\t\t|| (e==GF_EOS)\n\t\t\t\t|| (filter->session->flags & GF_FS_FLAG_NO_REASSIGN)\n\t\t\t) {\n\t\t\t\tif (filter->session->flags & GF_FS_FLAG_NO_REASSIGN) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter reassignment disabled, skippping chain reload for filter %s PID %s\\n\", pid->filter->name, pid->name ));\n\t\t\t\t}\n\t\t\t\tif (e!= GF_EOS) {\n\t\t\t\t\tfilter->session->last_connect_error = e;\n\t\t\t\t}\n\n\t\t\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\t\t\t\t\tgf_filter_pid_set_eos(pid);\n\n\t\t\t\t\tif (pid->filter->freg->process_event) {\n\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (!filter->num_input_pids && !filter->num_output_pids) {\n\t\t\t\t\t\tremove_filter = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (filter->has_out_caps) {\n\t\t\t\tBool unload_filter = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Blacklisting %s as output from %s and retrying connections\\n\", filter->name, pid->filter->name));\n\t\t\t\t//try to load another filter to handle that connection\n\t\t\t\t//1-blacklist this filter\n\t\t\t\tgf_list_add(pid->filter->blacklisted, (void *) filter->freg);\n\t\t\t\t//2-disconnect all other inputs, and post a re-init\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\twhile (gf_list_count(filter->input_pids)) {\n\t\t\t\t\tGF_FilterPidInst *a_pidinst = gf_list_pop_back(filter->input_pids);\n\t\t\t\t\tFSESS_CHECK_THREAD(filter)\n\t\t\t\t\tfilter->num_input_pids--;\n\t\t\t\t\tfilter->freg->configure_pid(filter, (GF_FilterPid *) a_pidinst, GF_TRUE);\n\n\t\t\t\t\tgf_filter_pid_post_init_task(a_pidinst->pid->filter, a_pidinst->pid);\n\t\t\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_delete_task, a_pidinst->pid->filter, a_pidinst->pid, \"pid_inst_delete\", a_pidinst);\n\n\t\t\t\t\tunload_filter = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfilter->num_input_pids = 0;\n\t\t\t\tfilter->single_source = NULL;\n\t\t\t\tfilter->removed = 1;\n\t\t\t\tfilter->has_pending_pids = GF_FALSE;\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t\t\t//do not assign session->last_connect_error since we are retrying a connection\n\n\t\t\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\t\t\tassert(pid->filter->out_pid_connection_pending);\n\t\t\t\t\tsafe_int_dec(&pid->filter->out_pid_connection_pending);\n\t\t\t\t}\n\t\t\t\t//3- post a re-init on this pid\n\t\t\t\tgf_filter_pid_post_init_task(pid->filter, pid);\n\n\t\t\t\tif (unload_filter) {\n\t\t\t\t\tassert(!gf_list_count(filter->input_pids));\n\n\t\t\t\t\tif (filter->num_output_pids) {\n\t\t\t\t\t\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\t\tGF_FilterPid *opid = gf_list_get(filter->output_pids, i);\n\t\t\t\t\t\t\tfor (j=0; j< opid->num_destinations; j++) {\n\t\t\t\t\t\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(opid->destinations, j);\n\t\t\t\t\t\t\t\ta_pidi->pid = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_list_reset(opid->destinations);\n\t\t\t\t\t\t\topid->num_destinations = 0;\n\t\t\t\t\t\t\tgf_filter_pid_remove(opid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilter->swap_pidinst_src = NULL;\n\t\t\t\t\tif (filter->swap_pidinst_dst) {\n\t\t\t\t\t\tGF_Filter *target = filter->swap_pidinst_dst->filter;\n\t\t\t\t\t\tassert(target);\n\t\t\t\t\t\tif (!target->detached_pid_inst) {\n\t\t\t\t\t\t\ttarget->detached_pid_inst = gf_list_new();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//detach props but don't delete them\n\t\t\t\t\t\tif (filter->swap_pidinst_dst->props) {\n\t\t\t\t\t\t\tfilter->swap_pidinst_dst->props = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfilter->swap_pidinst_dst->pid = NULL;\n\t\t\t\t\t\tif (gf_list_find(target->detached_pid_inst, filter->swap_pidinst_dst)<0)\n\t\t\t\t\t\t\tgf_list_add(target->detached_pid_inst, filter->swap_pidinst_dst);\n\t\t\t\t\t}\n\t\t\t\t\tfilter->swap_pidinst_dst = NULL;\n\t\t\t\t\tif (filter->on_setup_error) {\n\t\t\t\t\t\tgf_filter_notification_failure(filter, e, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_post_remove(filter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to reconfigure input of sink %s, cannot rebuild graph\\n\", filter->name));\n\t\t\t\tif (pid->filter->freg->process_event) {\n\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\t\t\tpid->filter->freg->process_event(pid->filter, &evt);\n\t\t\t\t}\n\t\t\t\tfilter->session->last_connect_error = e;\n\t\t\t}\n\t\t} else {\n\t\t\tfilter->session->last_connect_error = GF_OK;\n\t\t}\n\n\t\t//try to run filter no matter what\n\t\tif (filter->session->requires_solved_graph)\n\t\t\treturn e;\n\t}\n\n\t//flush all pending pid init requests following the call to init\n\tif (filter->has_pending_pids) {\n\t\tfilter->has_pending_pids = GF_FALSE;\n\t\twhile (gf_fq_count(filter->pending_pids)) {\n\t\t\tGF_FilterPid *a_pid=gf_fq_pop(filter->pending_pids);\n\t\t\t//filter is a pid adaptation filter (dynamically loaded to solve prop negociation)\n\t\t\t//copy over play state if the input PID was already playing\n\t\t\tif (pid->is_playing && filter->is_pid_adaptation_filter)\n\t\t\t\ta_pid->is_playing = GF_TRUE;\n\n\t\t\tgf_filter_pid_post_init_task(filter, a_pid);\n\t\t}\n\t}\n\n\tif (ctype==GF_PID_CONF_REMOVE) {\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (!filter->num_input_pids)\n\t\t\tfilter->single_source = NULL;\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t//PID instance is no longer in graph, we must remove it from pid destination to avoid propagating events\n\t\t//on to-be freed pid instance.\n\t\t//however we must have fan-outs (N>1 pid instance per PID), and removing the pid inst would trigger a pid destruction\n\t\t//on the first gf_filter_pid_inst_delete_task executed.\n\t\t//we therefore track at the PID level the number of gf_filter_pid_inst_delete_task tasks pending and\n\t\t//won't destroy the PID until that number is O\n\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\tpidinst->pid->num_pidinst_del_pending ++;\n\t\tgf_list_del_item(pidinst->pid->destinations, pidinst);\n\t\tpidinst->pid->num_destinations = gf_list_count(pidinst->pid->destinations);\n\t\tgf_filter_instance_detach_pid(pidinst);\n\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\n\t\t//disconnected the last input, flag as removed\n\t\tif (!filter->num_input_pids && !filter->sticky) {\n\t\t\tgf_filter_reset_pending_packets(filter);\n\t\t\tfilter->removed = 1;\n\t\t}\n\t\t//post a pid_delete task to also trigger removal of the filter if needed\n\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_delete_task, pid->filter, pid, \"pid_inst_delete\", pidinst);\n\n\t\treturn e;\n\t}\n\n\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\tassert(pid->filter->out_pid_connection_pending);\n\t\tif (safe_int_dec(&pid->filter->out_pid_connection_pending) == 0) {\n\n\t\t\t//we must resent play/pause events when a new pid is reattached to an old pid instance\n\t\t\t//in case one of the injected filter(s) monitors play state of the pids (eg reframers)\n\t\t\tif (refire_events) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tif (pidinst->is_playing) {\n\t\t\t\t\tpidinst->is_playing = GF_FALSE;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, (GF_FilterPid*)pidinst);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *)pidinst, &evt);\n\t\t\t\t}\n\t\t\t\tif (pidinst->is_paused) {\n\t\t\t\t\tpidinst->is_paused = GF_FALSE;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PAUSE, (GF_FilterPid*)pidinst);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *)pidinst, &evt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\t//postponed packets dispatched by source while setting up PID, flush through process()\n\t\t\t\t//pending packets (not yet consumed but in PID buffer), start processing\n\t\t\t\tif (pid->filter->postponed_packets || pid->filter->pending_packets || pid->filter->nb_caps_renegociate) {\n\t\t\t\t\tgf_filter_post_process_task(pid->filter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (remove_filter && !filter->sticky)\n\t\t\tgf_filter_post_remove(filter);\n\t}\n\t//once all pid have been (re)connected, update any internal caps\n\tgf_filter_pid_update_caps(pid);\n\treturn e;\n}\n\nstatic void gf_filter_pid_connect_task(GF_FSTask *task)\n{\n\tGF_Filter *filter = task->filter;\n\tGF_FilterSession *fsess = filter->session;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s pid %s connecting to %s (%p)\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name, filter));\n\n\t//filter will require a new instance, clone it\n\tif (filter->num_input_pids && (filter->max_extra_pids <= filter->num_input_pids - 1)) {\n\t\tGF_Filter *new_filter = gf_filter_clone(filter, task->pid->pid->filter);\n\t\tif (new_filter) {\n\t\t\tfilter = new_filter;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to clone filter %s\\n\", filter->name));\n\t\t\tassert(filter->in_pid_connection_pending);\n\t\t\tsafe_int_dec(&filter->in_pid_connection_pending);\n\t\t\tif (task->pid->pid) {\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\tgf_list_del_item(filter->temp_input_pids, task->pid->pid);\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (task->pid->pid) {\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->temp_input_pids, task->pid->pid);\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tgf_filter_pid_configure(filter, task->pid->pid, GF_PID_CONF_CONNECT);\n\t\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\t\tif (!task->pid->pid->nb_pck_sent) {\n\t\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t\t}\n\t}\n\t\n\t//filter may now be the clone, decrement on original filter\n\tassert(task->filter->in_pid_connection_pending);\n\tsafe_int_dec(&task->filter->in_pid_connection_pending);\n\n\tgf_fs_cleanup_filters(fsess);\n\n}\n\nvoid gf_filter_pid_reconfigure_task(GF_FSTask *task)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s reconfigure to %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\n\tif (task->pid->pid) {\n\t\tgf_filter_pid_configure(task->filter, task->pid->pid, GF_PID_CONF_RECONFIG);\n\t\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\t\tif (!task->pid->pid->nb_pck_sent) {\n\t\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t\t}\n\t}\n}\n\nvoid gf_filter_pid_reconfigure_task_discard(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) task->pid;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s reconfigure to %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\n\tif (!pidi->pid) return;\n\tgf_filter_pid_configure(task->filter, pidi->pid, GF_PID_CONF_RECONFIG);\n\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\tif (!task->pid->pid->nb_pck_sent) {\n\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t}\n\n\tif (pidi->discard_inputs==2) {\n\t\tgf_filter_aggregate_packets(pidi);\n\t\twhile (gf_filter_pid_get_packet((GF_FilterPid *) pidi)) {\n\t\t\tgf_filter_pid_drop_packet((GF_FilterPid *) pidi);\n\t\t}\n\t\t//move back to regular discard\n\t\tpidi->discard_inputs = 1;\n\t}\n}\nvoid gf_filter_pid_disconnect_task(GF_FSTask *task)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s disconnect from %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\tgf_filter_pid_configure(task->filter, task->pid->pid, GF_PID_CONF_REMOVE);\n\n\tgf_mx_p(task->filter->tasks_mx);\n\t//if the filter has no more connected ins and outs, remove it\n\tif (task->filter->removed && !gf_list_count(task->filter->output_pids) && !gf_list_count(task->filter->input_pids)) {\n\t\tBool direct_mode = task->filter->session->direct_mode;\n\t\tgf_filter_post_remove(task->filter);\n\t\tif (direct_mode) {\n\t\t\tgf_mx_v(task->filter->tasks_mx);\n\t\t\ttask->filter = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_mx_v(task->filter->tasks_mx);\n}\n\nvoid gf_filter_pid_detach_task(GF_FSTask *task)\n{\n\tu32 i, count;\n\tGF_Filter *filter = task->filter;\n\tGF_FilterPid *pid = task->pid->pid;\n\tGF_FilterPidInst *pidinst=NULL;\n\tGF_Filter *new_chain_input = task->udta;\n\n\t//we may have concurrent reset (due to play/stop/seek) and caps renegotiation\n\t//wait for the pid to be reset before detaching\n\tif (pid->filter->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\tif (new_chain_input->in_pid_connection_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tcount = pid->num_destinations;\n\tfor (i=0; i<count; i++) {\n\t\tpidinst = gf_list_get(pid->destinations, i);\n\t\tif (pidinst->filter==filter) {\n\t\t\tbreak;\n\t\t}\n\t\tpidinst=NULL;\n\t}\n\t//flush any packets dispatched before detaching\n\tif (pidinst && gf_fq_count(pidinst->packets)) {\n\t\tBool in_process = filter->in_process;\n\t\tfilter->in_process = GF_FALSE;\n\t\t//prevent pid_would_block calls\n\t\tfilter->in_force_flush = GF_TRUE;\n\t\tpidinst->force_flush = GF_TRUE;\n\t\tgf_filter_process_inline(filter);\n\t\tpidinst->force_flush = GF_FALSE;\n\t\tfilter->in_force_flush = GF_FALSE;\n\t\tfilter->in_process = in_process;\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tassert(filter->freg->configure_pid);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s detach from %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\tassert(pid->filter->detach_pid_tasks_pending);\n\tsafe_int_dec(&pid->filter->detach_pid_tasks_pending);\n\n\t//first connection of this PID to this filter\n\tif (!pidinst) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to detach PID %s not present in filter %s inputs\\n\",  pid->name, filter->name));\n\t\t//assert(!new_chain_input->swap_pidinst_dst);\n\t\tassert(!new_chain_input->swap_pidinst_src);\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t\treturn;\n\t}\n\n\t//detach props\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(& pidinst->props->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tpidinst->props = NULL;\n\n\tgf_mx_p(filter->tasks_mx);\n\t//detach pid - remove all packets in our pid instance and also update filter pending_packets\n\tcount = gf_fq_count(pidinst->packets);\n\tassert(count <= filter->pending_packets);\n\tsafe_int_sub(&filter->pending_packets, (s32) count);\n\tgf_filter_pid_inst_reset(pidinst);\n\tpidinst->pid = NULL;\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tgf_list_del_item(filter->input_pids, pidinst);\n\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\tif (!filter->num_input_pids)\n\t\tfilter->single_source = NULL;\n\tgf_mx_v(filter->tasks_mx);\n\n\tif (!filter->detached_pid_inst) {\n\t\tfilter->detached_pid_inst = gf_list_new();\n\t}\n\tif (gf_list_find(filter->detached_pid_inst, pidinst)<0)\n\t\tgf_list_add(filter->detached_pid_inst, pidinst);\n\n\t//we are done, reset filter swap instance so that connection can take place\n\tif (new_chain_input->swap_needs_init) {\n\t\tnew_chain_input->swap_pidinst_dst = NULL;\n\t\tnew_chain_input->swap_pidinst_src = NULL;\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t}\n\tassert(new_chain_input->detach_pid_tasks_pending);\n\tsafe_int_dec(&new_chain_input->detach_pid_tasks_pending);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_name(GF_FilterPid *pid, const char *name)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to assign name %s to input PID %s in filter %s - ignoring\\n\", name, pid->pid->name, pid->pid->filter->name));\n\t} else if (name) {\n\t\tif (pid->name && !strcmp(pid->name, name)) return;\n\t\tif (pid->name) gf_free(pid->name);\n\t\tpid->name = gf_strdup(name);\n\t}\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_name(GF_FilterPid *pid)\n{\n\treturn pid->pid->name;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_filter_name(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\treturn pid->pid->filter->name;\n\t}\n\treturn pid->filter->name;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_orig_src_args(GF_FilterPid *pid, Bool for_unicity)\n{\n\tu32 i;\n\tconst char *args;\n\t//move to true source pid\n\tpid = pid->pid;\n\targs = pid->filter->src_args;\n\tif (args && strstr(args, \"src\")) return args;\n\tgf_mx_p(pid->filter->tasks_mx);\n\tif (!pid->filter->num_input_pids) {\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn args;\n\t}\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (for_unicity && (pidi->pid->num_destinations>1)) {\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn \"__GPAC_SRC_FANOUT__\";\n\t\t}\n\t\tconst char *arg_src = gf_filter_pid_orig_src_args(pidi->pid, for_unicity);\n\t\tif (arg_src) {\n\t\t\tif (for_unicity && !strcmp(arg_src, \"__GPAC_SRC_FANOUT__\"))\n\t\t\t\targ_src = pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args;\n\t\t\tif (arg_src) {\n\t\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\t\treturn arg_src;\n\t\t\t}\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn args;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_source_filter_name(GF_FilterPid *pid)\n{\n\tGF_Filter *filter  = pid->pid->filter;\n\twhile (1) {\n\t\tGF_Filter *f;\n\t\tif (!filter) break;\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tif (!filter->num_input_pids) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tbreak;\n\t\t}\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, 0);\n\t\tf = pidi->pid->filter;\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tfilter = f;\n\t}\n\tif (!filter) return NULL;\n\treturn filter->name ? filter->name : filter->freg->name;\n}\n\nGF_EXPORT\nBool gf_filter_pid_get_buffer_occupancy(GF_FilterPid *pid, u32 *max_slots, u32 *nb_pck, u32 *max_duration, u32 *duration)\n{\n\tif (max_slots) *max_slots = pid->pid->max_buffer_unit;\n\tif (max_duration) *max_duration = (u32) pid->pid->max_buffer_time;\n\n\tif (pid->filter->session->in_final_flush) {\n\t\tif (duration) *duration =  (u32) pid->pid->max_buffer_time;\n\t\tif (nb_pck) *nb_pck = pid->pid->nb_buffer_unit;\n\t\treturn GF_FALSE;\n\t}\n\tif (nb_pck) *nb_pck = pid->pid->nb_buffer_unit;\n\tif (duration) *duration = (u32) pid->pid->buffer_duration;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_udta(GF_FilterPid *pid, void *udta)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\t((GF_FilterPidInst *)pid)->udta = udta;\n\t} else {\n\t\tpid->udta = udta;\n\t}\n}\n\nGF_EXPORT\nvoid *gf_filter_pid_get_udta(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\treturn ((GF_FilterPidInst *)pid)->udta;\n\t} else {\n\t\treturn pid->udta;\n\t}\n}\n\nstatic Bool filter_pid_check_fragment(GF_FilterPid *src_pid, char *frag_name, Bool *pid_excluded, Bool *needs_resolve, Bool *prop_not_found, char prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE])\n{\n\tchar *psep;\n\tu32 comp_type=0;\n\tBool is_neg = GF_FALSE;\n\tconst GF_PropertyEntry *pent;\n\tconst GF_PropertyEntry *pent_val=NULL;\n\t*needs_resolve = GF_FALSE;\n\t*prop_not_found = GF_FALSE;\n\n\tif (frag_name[0] == src_pid->filter->session->sep_neg) {\n\t\tfrag_name++;\n\t\tis_neg = GF_TRUE;\n\t}\n\t//special case for stream types filters\n\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_STREAM_TYPE);\n\tif (pent) {\n\t\tu32 matched=0;\n\t\tu32 type=0;\n\t\tu32 ptype = pent->prop.value.uint;\n\n\t\tif (!strnicmp(frag_name, \"audio\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_AUDIO;\n\t\t} else if (!strnicmp(frag_name, \"video\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_VISUAL;\n\t\t} else if (!strnicmp(frag_name, \"scene\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_SCENE;\n\t\t} else if (!strnicmp(frag_name, \"font\", 4)) {\n\t\t\tmatched=4;\n\t\t\ttype=GF_STREAM_FONT;\n\t\t} else if (!strnicmp(frag_name, \"text\", 4)) {\n\t\t\tmatched=4;\n\t\t\ttype=GF_STREAM_TEXT;\n\t\t} else {\n\t\t\t//frag name is a 4CC, check if we have an isom handler set\n\t\t\t//if same 4CC consider we have a match\n\t\t\tif (strlen(frag_name)==4) {\n\t\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_ISOM_HANDLER);\n\t\t\t\tif (pent && (pent->prop.value.uint == gf_4cc_parse(frag_name)) ) {\n\t\t\t\t\tmatched=4;\n\t\t\t\t\ttype = ptype;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//stream is encrypted and desired type is not, get original stream type\n\t\tif ((ptype == GF_STREAM_ENCRYPTED) && type && (type != GF_STREAM_ENCRYPTED) ) {\n\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\t\tif (pent) ptype = pent->prop.value.uint;\n\t\t}\n\n\t\tif (matched &&\n\t\t\t( (!is_neg && (type != ptype)) || (is_neg && (type == ptype)) )\n\t\t) {\n\t\t\t//special case: if we request a non-file stream but the pid is a file, we will need a demux to\n\t\t\t//move from file to A/V/... streams, so we accept any #MEDIA from file streams\n\t\t\tif (ptype == GF_STREAM_FILE) {\n\t\t\t\t*prop_not_found = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\tif (matched) {\n\t\t\tu32 idx=0;\n\t\t\tu32 k, count_pid;\n\t\t\tif (strlen(frag_name)==matched) return GF_TRUE;\n\t\t\tidx = atoi(frag_name+matched);\n\t\t\tcount_pid = src_pid->filter->num_output_pids;\n\t\t\tfor (k=0; k<count_pid; k++) {\n\t\t\t\tGF_FilterPid *p = gf_list_get(src_pid->filter->output_pids, k);\n\t\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\t\tif (pent && pent->prop.value.uint==type) {\n\t\t\t\t\tidx--;\n\t\t\t\t\tif (!idx\n\t\t\t\t\t\t//special case if single output of source, consider it a match\n\t\t\t\t\t\t//this is needed for cases where intermediate filters are single-pid:\n\t\t\t\t\t\t//mp4dmx @#video1 @ f1 @ f2 @ f3 @@0#video2 @f4 @f5 @f6\n\t\t\t\t\t\t//filters f2 and f5 will only output a single pid\n\t\t\t\t\t\t|| ((count_pid==1) && !src_pid->filter->max_extra_pids)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (p==src_pid) return GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\t//special case for codec type filters\n\tif (!strcmp(frag_name, \"raw\")) {\n\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_CODECID);\n\t\tif (pent) {\n\t\t\tBool is_eq = (pent->prop.value.uint==GF_CODECID_RAW) ? GF_TRUE : GF_FALSE;\n\t\t\tif (is_neg) is_eq = !is_eq;\n\t\t\tif (is_eq) return GF_TRUE;\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\t//not codec ID set for pid, assume match\n\t\treturn GF_TRUE;\n\t}\n\n\t//generic property addressing code(or builtin name)=val\n\tpsep = strchr(frag_name, src_pid->filter->session->sep_name);\n\tif (!psep) {\n\t\tpsep = strchr(frag_name, '-');\n\t\tif (psep) comp_type = 1;\n\t\telse {\n\t\t\tpsep = strchr(frag_name, '+');\n\t\t\tif (psep) comp_type = 2;\n\t\t}\n\t}\n\n\tif (!psep) {\n\t\t*prop_not_found = GF_TRUE;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID addressing %s not recognized, ignoring and assuming match\\n\", frag_name ));\n\t\treturn GF_TRUE;\n\t}\n\n\tBool is_equal = GF_FALSE;\n\tBool use_not_equal = GF_FALSE;\n\tGF_PropertyValue prop_val;\n\tu32 p4cc = 0;\n\tchar c=psep[0];\n\tpsep[0] = 0;\n\tpent=NULL;\n\n\t//special case for tag\n\tif (!strcmp(frag_name, \"TAG\") || !strcmp(frag_name, \"ITAG\")) {\n\t\tpsep[0] = c;\n\t\tif (src_pid->filter->tag) {\n\t\t\tBool is_eq;\n\t\t\t//check for negation\n\t\t\tif ( (psep[0]==src_pid->filter->session->sep_name) && (psep[1]==src_pid->filter->session->sep_neg) ) {\n\t\t\t\tpsep++;\n\t\t\t\tuse_not_equal = GF_TRUE;\n\t\t\t}\n\n\t\t\tis_eq = !strcmp(psep+1, src_pid->filter->tag);\n\t\t\tif (use_not_equal) is_eq = !is_eq;\n\t\t\tif (is_eq) return GF_TRUE;\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\t//not tag set for pid's filter, assume match\n\t\treturn GF_TRUE;\n\t}\n\n\n\t//check for built-in property\n\tp4cc = gf_props_get_id(frag_name);\n\tif (!p4cc && !strcmp(frag_name, \"PID\") )\n\t\tp4cc = GF_PROP_PID_ID;\n\n\tif (!p4cc && (strlen(frag_name)==4))\n\t\tp4cc = GF_4CC(frag_name[0], frag_name[1], frag_name[2], frag_name[3]);\n\n\tif (p4cc) pent = gf_filter_pid_get_property_entry(src_pid, p4cc);\n\t//not a built-in property, find prop by name\n\tif (!pent) {\n\t\tpent = gf_filter_pid_get_property_entry_str(src_pid, frag_name);\n\t}\n\n\tpsep[0] = c;\n\n\t//if the property is not found, we accept the connection\n\tif (!pent) {\n\t\t*prop_not_found = GF_TRUE;\n\t\treturn GF_TRUE;\n\t}\n\t//check for dynamic assignment\n\tif ( (psep[0]==src_pid->filter->session->sep_name) && ((psep[1]=='*') || (psep[1]=='\\0') ) ) {\n\t\t*needs_resolve = GF_TRUE;\n\t\tgf_props_dump_val(&pent->prop, prop_dump_buffer, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\treturn GF_FALSE;\n\t}\n\n\t//check for negation\n\tif ( (psep[0]==src_pid->filter->session->sep_name) && (psep[1]==src_pid->filter->session->sep_neg) ) {\n\t\tpsep++;\n\t\tuse_not_equal = GF_TRUE;\n\t}\n\n\t//parse the property, based on its property type\n\tif (pent->p4cc==GF_PROP_PID_CODECID) {\n\t\tprop_val.type = GF_PROP_UINT;\n\t\tprop_val.value.uint = gf_codecid_parse(psep+1);\n\t}\n\t//parse the property, based on its property type\n\telse if (pent->p4cc==GF_PROP_PID_STREAM_TYPE) {\n\t\tprop_val.type = GF_PROP_UINT;\n\t\tprop_val.value.uint = gf_stream_type_by_name(psep+1);\n\t} else {\n\t\tu32 val_is_prop = gf_props_get_id(psep+1);\n\t\tif (val_is_prop) {\n\t\t\tpent_val = gf_filter_pid_get_property_entry(src_pid, val_is_prop);\n\t\t\tif (pent_val) {\n\t\t\t\tprop_val = pent_val->prop;\n\t\t\t} else {\n\t\t\t\t*pid_excluded = GF_TRUE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tprop_val = gf_props_parse_value(pent->prop.type, frag_name, psep+1, NULL, src_pid->filter->session->sep_list);\n\t\t}\n\t}\n\tif (!comp_type) {\n\t\tis_equal = gf_props_equal(&pent->prop, &prop_val);\n\t\tif (use_not_equal) is_equal = !is_equal;\n\t} else {\n\t\tswitch (prop_val.type) {\n\t\tcase GF_PROP_SINT:\n\t\t\tif (pent->prop.value.sint<prop_val.value.sint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\tif (pent->prop.value.uint<prop_val.value.uint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_LSINT:\n\t\t\tif (pent->prop.value.longsint<prop_val.value.longsint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\tif (pent->prop.value.longuint<prop_val.value.longuint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FLOAT:\n\t\t\tif (pent->prop.value.fnumber<prop_val.value.fnumber) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_DOUBLE:\n\t\t\tif (pent->prop.value.number<prop_val.value.number) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\tif (pent->prop.value.frac.num * prop_val.value.frac.den < pent->prop.value.frac.den * prop_val.value.frac.num) is_equal = GF_TRUE;\n\t\t\tif (comp_type == 2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION64:\n\t\t\tif (pent->prop.value.lfrac.num * prop_val.value.lfrac.den < pent->prop.value.lfrac.den * prop_val.value.lfrac.num) is_equal = GF_TRUE;\n\t\t\tif (comp_type == 2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID addressing uses \\'%s\\' comparison on property %s which is not a number, defaulting to equal=true\\n\", (comp_type==1) ? \"less than\" : \"more than\", gf_props_4cc_get_name(p4cc) ));\n\t\t\tis_equal = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!pent_val)\n\t\tgf_props_reset_single(&prop_val);\n\n\tif (!is_equal) *pid_excluded = GF_TRUE;\n\n\treturn is_equal;\n}\n\nstatic Bool filter_source_id_match(GF_FilterPid *src_pid, const char *id, GF_Filter *dst_filter, Bool *pid_excluded, Bool *needs_clone)\n{\n\tconst char *source_ids;\n\tchar *resolved_source_ids = NULL;\n\tBool result = GF_FALSE;\n\tBool first_pass = GF_TRUE;\n\tBool has_default_match;\n\tBool is_pid_excluded;\n\t*pid_excluded = GF_FALSE;\n\tif (!dst_filter->source_ids)\n\t\treturn GF_TRUE;\n\tif (!id)\n\t\treturn GF_FALSE;\n\nsourceid_reassign:\n\tsource_ids = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;\n\tif (!first_pass) {\n\t\tassert(dst_filter->dynamic_source_ids);\n\t\tsource_ids = dst_filter->dynamic_source_ids;\n\t}\n\thas_default_match = GF_FALSE;\n\tis_pid_excluded = GF_FALSE;\n\n\twhile (source_ids) {\n\t\tBool all_matched = GF_TRUE;\n\t\tBool all_frags_not_found = GF_TRUE;\n\t\tu32 len, sublen;\n\t\tBool last=GF_FALSE;\n\t\tchar *frag_name, *frag_clone;\n\t\tchar *sep;\n\t\tBool use_neg = GF_FALSE;\n\t\tif (source_ids[0] == src_pid->filter->session->sep_neg) {\n\t\t\tsource_ids++;\n\t\t\tuse_neg = GF_TRUE;\n\t\t}\n\n\t\tsep = strchr(source_ids, src_pid->filter->session->sep_list);\n\t\tif (sep) {\n\t\t\tlen = (u32) (sep - source_ids);\n\t\t} else {\n\t\t\tlen = (u32) strlen(source_ids);\n\t\t\tlast=GF_TRUE;\n\t\t}\n\n\t\tfrag_name = strchr(source_ids, src_pid->filter->session->sep_frag);\n\t\tif (frag_name > source_ids + len) frag_name = NULL;\n\t\tsublen = frag_name ? (u32) (frag_name - source_ids) : len;\n\t\t//skip frag char\n\t\tif (frag_name) frag_name++;\n\n\t\t//any ID, always match\n\t\tif (source_ids[0]=='*') { }\n\t\t// id does not match\n\t\telse {\n\t\t\tBool res = strncmp(id, source_ids, sublen) ? GF_FALSE : GF_TRUE;\n\t\t\tif (use_neg) res = !res;\n\t\t\tif (!res) {\n\t\t\t\tsource_ids += len+1;\n\t\t\t\tif (last) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//no fragment or fragment match pid name, OK\n\t\tif (!frag_name || !strcmp(src_pid->name, frag_name)) {\n\t\t\tresult = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tfrag_clone = NULL;\n\t\tif (!last) {\n\t\t\tfrag_clone = gf_strdup(frag_name);\n\t\t\tchar *nsep = strchr(frag_clone, src_pid->filter->session->sep_list);\n\t\t\tassert(nsep);\n\t\t\tnsep[0] = 0;\n\t\t\tfrag_name = frag_clone;\n\t\t}\n\n\t\t//for all listed fragment extensions\n\t\twhile (frag_name && all_matched) {\n\t\t\tchar prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];\n\t\t\tBool needs_resolve = GF_FALSE;\n\t\t\tBool prop_not_found = GF_FALSE;\n\t\t\tBool local_pid_excluded = GF_FALSE;\n\t\t\tchar *next_frag = strchr(frag_name, src_pid->filter->session->sep_frag);\n\t\t\tif (next_frag) next_frag[0] = 0;\n\n\t\t\tif (! filter_pid_check_fragment(src_pid, frag_name, &local_pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer)) {\n\t\t\t\tif (needs_resolve) {\n\t\t\t\t\tif (first_pass) {\n\t\t\t\t\t\tchar *sid = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;\n\t\t\t\t\t\tchar *frag_sep = strchr(frag_name, dst_filter->session->sep_name);\n\t\t\t\t\t\tassert(frag_sep);\n\t\t\t\t\t\tif (next_frag) next_frag[0] = src_pid->filter->session->sep_frag;\n\n\t\t\t\t\t\tchar *new_source_ids = gf_malloc(sizeof(char) * (strlen(sid) + strlen(prop_dump_buffer)+1));\n\t\t\t\t\t\tu32 clen = (u32) (1+frag_sep - sid);\n\t\t\t\t\t\tstrncpy(new_source_ids, sid, clen);\n\t\t\t\t\t\tnew_source_ids[clen]=0;\n\t\t\t\t\t\tstrcat(new_source_ids, prop_dump_buffer);\n\t\t\t\t\t\tif (next_frag) strcat(new_source_ids, next_frag);\n\n\t\t\t\t\t\tif (resolved_source_ids) gf_free(resolved_source_ids);\n\t\t\t\t\t\tresolved_source_ids = new_source_ids;\n\t\t\t\t\t\tif (frag_clone) gf_free(frag_clone);\n\t\t\t\t\t\tgoto sourceid_reassign;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tall_matched = GF_FALSE;\n\t\t\t\t\t//remember we failed because PID was excluded by sourceID\n\t\t\t\t\tif (local_pid_excluded)\n\t\t\t\t\t\tis_pid_excluded = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//remember we succeed because PID has no matching property\n\t\t\t\tif (!prop_not_found)\n\t\t\t\t\tall_frags_not_found = GF_FALSE;\n\t\t\t}\n\n\t\t\tif (!next_frag) break;\n\n\t\t\tnext_frag[0] = src_pid->filter->session->sep_frag;\n\t\t\tfrag_name = next_frag+1;\n\t\t}\n\t\tif (frag_clone) gf_free(frag_clone);\n\t\tif (all_matched) {\n\t\t\t//exact match on one or more properties, don't look any further\n\t\t\tif (!all_frags_not_found) {\n\t\t\t\tresult = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//remember we had a default match, but don't set result yet and parse other SIDs\n\t\t\thas_default_match = GF_TRUE;\n\t\t}\n\t\t*needs_clone = GF_FALSE;\n\t\tif (!sep) break;\n\t\tsource_ids = sep+1;\n\t}\n\n\tif (!result) {\n\t\t//we had a default match and pid was not excluded by any SIDs, consider we pass\n\t\tif (has_default_match && !is_pid_excluded)\n\t\t\tresult = GF_TRUE;\n\t}\n\n\tif (!result) {\n\t\tif (resolved_source_ids) gf_free(resolved_source_ids);\n\t\tif (dst_filter->dynamic_source_ids && first_pass) {\n\t\t\tfirst_pass = GF_FALSE;\n\t\t\tgoto sourceid_reassign;\n\t\t}\n\t\t*pid_excluded = is_pid_excluded;\n\t\treturn GF_FALSE;\n\t}\n\tif (resolved_source_ids) {\n\t\tif (!dst_filter->dynamic_source_ids) {\n\t\t\tdst_filter->dynamic_source_ids = dst_filter->source_ids;\n\t\t\tdst_filter->source_ids = resolved_source_ids;\n\t\t} else {\n\t\t\tgf_free(dst_filter->source_ids);\n\t\t\tdst_filter->source_ids = resolved_source_ids;\n\t\t}\n\t}\n\tif (!first_pass) {\n\t\t*needs_clone = GF_TRUE;\n\t}\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_in_parent_chain(GF_Filter *parent, GF_Filter *filter)\n{\n\tu32 i;\n\tif (parent == filter) return GF_TRUE;\n\n\t//browse all parent PIDs - we must lock the parent filter\n\t//as some pid init tasks may be in process in other threads\n\tgf_mx_p(parent->tasks_mx);\n\tif (!parent->num_input_pids) {\n\t\tgf_mx_v(parent->tasks_mx);\n\t\treturn GF_FALSE;\n\t}\n\t//single source filter, do not browse pids\n\tif (parent->single_source) {\n\t\tBool res = gf_filter_in_parent_chain(parent->single_source, filter);\n\t\tgf_mx_v(parent->tasks_mx);\n\t\treturn res;\n\t}\n\tfor (i=0; i<parent->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(parent->input_pids, i);\n\t\tif (gf_filter_in_parent_chain(pidi->pid->filter, filter)) {\n\t\t\tgf_mx_v(parent->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tfor (i=0; i<gf_list_count(parent->temp_input_pids); i++) {\n\t\tGF_FilterPid *a_src_pid = gf_list_get(parent->temp_input_pids, i);\n\t\tif (gf_filter_in_parent_chain(a_src_pid->filter, filter)) {\n\t\t\tgf_mx_v(parent->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(parent->tasks_mx);\n\treturn GF_FALSE;\n}\n\n\nstatic Bool cap_code_match(u32 c1, u32 c2)\n{\n\tif (c1==c2) return GF_TRUE;\n\t/*we consider GF_PROP_PID_FILE_EXT and GF_PROP_PID_MIME are the same so that we check\n\tif we have at least one match of file ext or mime in a given bundle*/\n\tif ((c1==GF_PROP_PID_FILE_EXT) && (c2==GF_PROP_PID_MIME)) return GF_TRUE;\n\tif ((c1==GF_PROP_PID_MIME) && (c2==GF_PROP_PID_FILE_EXT)) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nBool gf_filter_pid_caps_match(GF_FilterPid *src_pid_or_ipid, const GF_FilterRegister *freg, GF_Filter *filter_inst, u8 *priority, u32 *dst_bundle_idx, GF_Filter *dst_filter, s32 for_bundle_idx)\n{\n\tu32 i=0;\n\tu32 cur_bundle_start = 0;\n\tu32 cap_bundle_idx = 0;\n\tu32 nb_subcaps=0;\n\tBool skip_explicit_load = GF_FALSE;\n\tBool all_caps_matched = GF_TRUE;\n\tBool mime_matched = GF_FALSE;\n\tBool has_file_ext_cap = GF_FALSE;\n\tBool ext_not_trusted;\n\tGF_FilterPid *src_pid = src_pid_or_ipid->pid;\n\tconst GF_FilterCapability *in_caps;\n\tu32 nb_in_caps;\n\n\tif (!freg) {\n\t\tassert(dst_filter);\n\t\tfreg = dst_filter->freg;\n\t\tskip_explicit_load = GF_TRUE;\n\t}\n\n\tin_caps = freg->caps;\n\tnb_in_caps = freg->nb_caps;\n\tif (filter_inst && (filter_inst->freg==freg)) {\n\t\tskip_explicit_load = GF_TRUE;\n\t\tif (filter_inst->forced_caps) {\n\t\t\tin_caps = filter_inst->forced_caps;\n\t\t\tnb_in_caps = filter_inst->nb_forced_caps;\n\t\t}\n\t}\n\text_not_trusted = src_pid->ext_not_trusted;\n\tif (ext_not_trusted) {\n\t\tBool has_mime_cap = GF_FALSE;\n\n\t\tfor (i=0; i<nb_in_caps; i++) {\n\t\t\tconst GF_FilterCapability *cap = &in_caps[i];\n\t\t\tif (! (cap->flags & GF_CAPFLAG_INPUT) ) continue;\n\t\t\tif (cap->code == GF_PROP_PID_MIME) {\n\t\t\t\thas_mime_cap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!has_mime_cap) ext_not_trusted = GF_FALSE;\n\t}\n\n\tif (filter_inst && filter_inst->encoder_stream_type) {\n\t\tconst GF_PropertyValue *pid_st = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (pid_st && (pid_st->value.uint != filter_inst->encoder_stream_type))\n\t\t\treturn GF_FALSE;\n\t}\n\n\tif (priority)\n\t\t(*priority) = freg->priority;\n\n\tif (dst_bundle_idx)\n\t\t(*dst_bundle_idx) = 0;\n\n\t//filters with no explicit input cap accept anything for now, this should be refined ...\n\tif (!in_caps)\n\t\treturn GF_TRUE;\n\n\t//check all input caps of dst filter\n\tfor (i=0; i<nb_in_caps; i++) {\n\t\tconst GF_PropertyValue *pid_cap=NULL;\n\t\tconst GF_FilterCapability *cap = &in_caps[i];\n\n\t\t/*end of cap bundle*/\n\t\tif (i && !(cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\tif (has_file_ext_cap && ext_not_trusted && !mime_matched)\n\t\t\t\tall_caps_matched = GF_FALSE;\n\n\t\t\tif (all_caps_matched) {\n\t\t\t\tif (dst_bundle_idx)\n\t\t\t\t\t(*dst_bundle_idx) = cap_bundle_idx;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tall_caps_matched = GF_TRUE;\n\t\t\tmime_matched = GF_FALSE;\n\t\t\thas_file_ext_cap = GF_FALSE;\n\t\t\tnb_subcaps=0;\n\t\t\tcur_bundle_start = i;\n\t\t\tcap_bundle_idx++;\n\t\t\tif ((for_bundle_idx>=0) && (cap_bundle_idx > (u32) for_bundle_idx)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ((for_bundle_idx>=0) && (cap_bundle_idx < (u32) for_bundle_idx)) {\n\t\t\tall_caps_matched = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not an input cap\n\t\tif (! (cap->flags & GF_CAPFLAG_INPUT) ) {\n\t\t\tif (!skip_explicit_load && (cap->flags & GF_CAPFLAG_LOADED_FILTER) ) {\n\t\t\t\tall_caps_matched = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tnb_subcaps++;\n\t\t//no match for this cap, go on until new one or end\n\t\tif (!all_caps_matched) continue;\n\n\t\tif (cap->code) {\n\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, cap->code);\n\n\t\t\t//special case for file ext: the pid will likely have only one file extension defined, and the output as well\n\t\t\t//we browse all caps of the filter owning the pid, looking for the original file extension property\n\t\t\tif (pid_cap && (cap->code==GF_PROP_PID_FILE_EXT) ) {\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<src_pid->filter->freg->nb_caps; j++) {\n\t\t\t\t\tconst GF_FilterCapability *out_cap = &src_pid->filter->freg->caps[j];\n\t\t\t\t\tif (!(out_cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\t\t\tif (out_cap->code != GF_PROP_PID_FILE_EXT) continue;\n\t\t\t\t\tif (! gf_props_equal(pid_cap, &out_cap->val)) continue;\n\t\t\t\t\tpid_cap = &out_cap->val;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if PID prop for this cap is not found and the cap is MIME (resp. file ext), fetch file_ext (resp MIME)\n\t\t\t so that we check if we have at least one match of file ext or mime in a given bundle*/\n\t\t\tif (!pid_cap) {\n\t\t\t\tif (cap->code==GF_PROP_PID_FILE_EXT)\n\t\t\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_MIME);\n\t\t\t\telse if (cap->code==GF_PROP_PID_MIME)\n\t\t\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_FILE_EXT);\n\t\t\t}\n\t\t}\n\n\t\t//try by name\n\t\tif (!pid_cap && cap->name) pid_cap = gf_filter_pid_get_property_str_first(src_pid_or_ipid, cap->name);\n\n\t\tif (ext_not_trusted && (cap->code==GF_PROP_PID_FILE_EXT)) {\n\t\t\thas_file_ext_cap = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//optional cap, only adjust priority\n\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) {\n\t\t\tif (pid_cap && priority && cap->priority && ((*priority) < cap->priority)) {\n\t\t\t\t(*priority) = cap->priority;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t//we found a property of that type and it is equal\n\t\tif (pid_cap) {\n\t\t\tu32 j;\n\t\t\tBool prop_excluded = GF_FALSE;\n\t\t\tBool prop_equal = GF_FALSE;\n\n\t\t\t//this could be optimized by not checking several times the same cap\n\t\t\tfor (j=0; j<nb_in_caps; j++) {\n\t\t\t\tconst GF_FilterCapability *a_cap = &in_caps[j];\n\n\t\t\t\tif ((j>cur_bundle_start) && ! (a_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//not an input cap\n\t\t\t\tif (! (a_cap->flags & GF_CAPFLAG_INPUT) ) continue;\n\t\t\t\t//not a static and not in bundle\n\t\t\t\tif (! (a_cap->flags & GF_CAPFLAG_STATIC)) {\n\t\t\t\t\tif (j<cur_bundle_start)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cap->code) {\n\t\t\t\t\tif (!cap_code_match(cap->code, a_cap->code) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (!cap->name || !a_cap->name || strcmp(cap->name, a_cap->name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!skip_explicit_load && (a_cap->flags & GF_CAPFLAG_LOADED_FILTER) ) {\n\t\t\t\t\tif (!dst_filter || (dst_filter != src_pid->filter->dst_filter)) {\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (dst_filter->freg != freg) {\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!prop_equal) {\n\t\t\t\t\tprop_equal = gf_props_equal(pid_cap, &a_cap->val);\n\t\t\t\t\t//excluded cap: if value match, don't match this cap at all\n\t\t\t\t\tif (a_cap->flags & GF_CAPFLAG_EXCLUDED) {\n\t\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\t\tprop_excluded = GF_FALSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprop_excluded = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tif (priority && a_cap->priority && ((*priority) < a_cap->priority)) {\n\t\t\t\t\t\t\t(*priority) = a_cap->priority;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!prop_equal && !prop_excluded) {\n\t\t\t\tall_caps_matched=GF_FALSE;\n\t\t\t}\n\t\t\tif (ext_not_trusted && prop_equal && (cap->code==GF_PROP_PID_MIME))\n\t\t\t\tmime_matched = GF_TRUE;\n\t\t}\n\t\telse if (! (cap->flags & (GF_CAPFLAG_EXCLUDED | GF_CAPFLAG_OPTIONAL) ) ) {\n\t\t\tall_caps_matched=GF_FALSE;\n\t\t}\n\t}\n\n\tif (has_file_ext_cap && ext_not_trusted && !mime_matched)\n\t\tall_caps_matched = GF_FALSE;\n\n\tif (nb_subcaps && all_caps_matched) {\n\t\tif (dst_bundle_idx)\n\t\t\t(*dst_bundle_idx) = cap_bundle_idx;\n\t\treturn GF_TRUE;\n\t}\n\n\treturn GF_FALSE;\n}\n\nu32 gf_filter_caps_bundle_count(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\tu32 i, nb_bundles = 0, num_in_bundle=0;\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (! (cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tif (num_in_bundle) nb_bundles++;\n\t\t\tnum_in_bundle=0;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_in_bundle++;\n\t}\n\tif (num_in_bundle) nb_bundles++;\n\treturn nb_bundles;\n}\n\nstatic Bool gf_filter_has_in_out_caps(const GF_FilterCapability *caps, u32 nb_caps, Bool check_in)\n{\n\tu32 i;\n\t//check all input caps of dst filter, count bundles\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *a_cap = &caps[i];\n\t\tif (check_in) {\n\t\t\tif (a_cap->flags & GF_CAPFLAG_INPUT) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a_cap->flags & GF_CAPFLAG_OUTPUT) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n\n}\nBool gf_filter_has_out_caps(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\treturn gf_filter_has_in_out_caps(caps, nb_caps, GF_FALSE);\n}\nBool gf_filter_has_in_caps(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\treturn gf_filter_has_in_out_caps(caps, nb_caps, GF_TRUE);\n}\n\nu32 gf_filter_caps_to_caps_match(const GF_FilterRegister *src, u32 src_bundle_idx, const GF_FilterRegister *dst_reg, GF_Filter *dst_filter, u32 *dst_bundle_idx, u32 for_dst_bundle, u32 *loaded_filter_flags, GF_CapsBundleStore *capstore)\n{\n\tu32 i=0;\n\ts32 first_static_cap=-1;\n\tu32 cur_bundle_start = 0;\n\tu32 cur_bundle_idx = 0;\n\tu32 nb_matched=0;\n\t//u32 nb_out_caps=0;\n\tu32 nb_in_bundles=0;\n\tu32 bundle_score = 0;\n\tu32 *bundles_in_ok = NULL;\n\tu32 *bundles_cap_found = NULL;\n\tu32 *bundles_in_scores = NULL;\n\t//initialize caps matched to true for first cap bundle\n\tBool all_caps_matched = GF_TRUE;\n\tconst GF_FilterCapability *dst_caps = dst_reg->caps;\n\tu32 nb_dst_caps = dst_reg->nb_caps;\n\n\tif (dst_filter && dst_filter->freg==dst_reg && dst_filter->forced_caps) {\n\t\tdst_caps = dst_filter->forced_caps;\n\t\tnb_dst_caps = dst_filter->nb_forced_caps;\n\t}\n\n\t//check all input caps of dst filter, count bundles\n\tif (! gf_filter_has_out_caps(src->caps, src->nb_caps)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no output caps, cannot match filter %s inputs\\n\", src->name, dst_reg->name));\n\t\treturn 0;\n\t}\n\n\t//check all input caps of dst filter, count bundles\n\tnb_in_bundles = gf_filter_caps_bundle_count(dst_caps, nb_dst_caps);\n\tif (!nb_in_bundles) {\n\t\tif (dst_reg->configure_pid) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no caps but pid configure possible, assuming possible connection\\n\", dst_reg->name));\n\t\t\treturn 1;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no caps and no pid configure, no possible connection\\n\", dst_reg->name));\n\t\treturn 0;\n\t}\n\tif (capstore->nb_allocs < nb_in_bundles) {\n\t\tcapstore->nb_allocs = nb_in_bundles;\n\t\tcapstore->bundles_in_ok = gf_realloc(capstore->bundles_in_ok, sizeof(u32) * nb_in_bundles);\n\t\tcapstore->bundles_cap_found = gf_realloc(capstore->bundles_cap_found, sizeof(u32) * nb_in_bundles);\n\t\tcapstore->bundles_in_scores = gf_realloc(capstore->bundles_in_scores,  sizeof(u32) * nb_in_bundles);\n\t}\n\tbundles_in_ok =\tcapstore->bundles_in_ok;\n\tbundles_cap_found = capstore->bundles_cap_found;\n\tbundles_in_scores = capstore->bundles_in_scores;\n\n\tfor (i=0; i<nb_in_bundles; i++) {\n\t\tbundles_in_ok[i] = 1;\n\t\tbundles_cap_found[i] = 0;\n\t\tbundles_in_scores[i] = 0;\n\t}\n\n\t//check all output caps of src filter\n\tfor (i=0; i<src->nb_caps; i++) {\n\t\tu32 j, k;\n\t\tBool already_tested = GF_FALSE;\n\t\tconst GF_FilterCapability *out_cap = &src->caps[i];\n\n\t\tif (i<cur_bundle_start) {\n\t\t\tif (!(out_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\tall_caps_matched = GF_TRUE;\n\t\t\tcur_bundle_start = i+1;\n\t\t\tcur_bundle_idx++;\n\t\t\tif (src_bundle_idx < cur_bundle_idx)\n\t\t\t\tbreak;\n\n\t\t\tif (first_static_cap>=0)\n\t\t\t\ti = (u32) (first_static_cap-1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not our selected output and not static cap\n\t\tif ((src_bundle_idx != cur_bundle_idx) && ! (out_cap->flags & GF_CAPFLAG_STATIC) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not an output cap\n\t\tif (!(out_cap->flags & GF_CAPFLAG_OUTPUT) ) continue;\n\n\t\tif ((first_static_cap==-1) && (out_cap->flags & GF_CAPFLAG_STATIC)) {\n\t\t\tfirst_static_cap = i;\n\t\t}\n\n\n\t\t//no match possible for this cap, wait until next cap start\n\t\tif (!all_caps_matched) continue;\n\n\t\t//check we didn't test a cap with same name/code before us\n\t\tfor (k=cur_bundle_start; k<i; k++) {\n\t\t\tconst GF_FilterCapability *an_out_cap = &src->caps[k];\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out_cap->code && (out_cap->code == an_out_cap->code) ) {\n\t\t\t\talready_tested = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (out_cap->name && an_out_cap->name && !strcmp(out_cap->name, an_out_cap->name)) {\n\t\t\t\talready_tested = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (already_tested) {\n\t\t\tcontinue;\n\t\t}\n\t\t//nb_out_caps++;\n\n\t\t//set cap as OK in all bundles\n\t\tfor (k=0; k<nb_in_bundles; k++) {\n\t\t\tbundles_cap_found[k] = 0;\n\t\t}\n\n\t\t//check all output caps in this bundle with the same code/name, consider OK if one is matched\n\t\tif (first_static_cap>=0)\n\t\t\tk = first_static_cap-1;\n\t\telse\n\t\t\tk = cur_bundle_start;\n\n\t\tfor (; k<src->nb_caps; k++) {\n\t\t\tu32 cur_dst_bundle=0;\n\t\t\tBool static_matched = GF_FALSE;\n\t\t\tu32 nb_caps_tested = 0;\n\t\t\tu32 cap_loaded_filter_only = 0;\n\t\t\tBool matched=GF_FALSE;\n\t\t\tBool exclude=GF_FALSE;\n\t\t\tBool prop_found=GF_FALSE;\n\t\t\tconst GF_FilterCapability *an_out_cap = &src->caps[k];\n\n\t\t\tif (k<cur_bundle_start) {\n\t\t\t\tif (!(an_out_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out_cap->code && !cap_code_match(out_cap->code, an_out_cap->code) )\n\t\t\t\tcontinue;\n\n\t\t\tif (out_cap->name && (!an_out_cap->name || strcmp(out_cap->name, an_out_cap->name)))\n\t\t\t\tcontinue;\n\n\t\t\t//not our selected output and not static cap\n\t\t\tif ((src_bundle_idx != cur_bundle_idx) && ! (an_out_cap->flags & GF_CAPFLAG_STATIC) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnb_matched = 0;\n\t\t\t//check all input caps of dst filter, count ones that are matched\n\t\t\tfor (j=0; j<nb_dst_caps; j++) {\n\t\t\t\tBool prop_equal;\n\t\t\t\tconst GF_FilterCapability *in_cap = &dst_caps[j];\n\n\t\t\t\tif (! (in_cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t\t\tif (((cur_dst_bundle >= for_dst_bundle) || (in_cap->flags & GF_CAPFLAG_STATIC))) {\n\t\t\t\t\t\tif (!matched && !nb_caps_tested && (out_cap->flags & GF_CAPFLAG_EXCLUDED)) {\n\t\t\t\t\t\t\tmatched = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//we found a prop, excluded but with != value hence acceptable, default matching to true\n\t\t\t\t\tif (!matched && prop_found) matched = GF_TRUE;\n\n\t\t\t\t\t//match, flag this bundle as ok\n\t\t\t\t\tif (matched) {\n\t\t\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\t\t\tnb_matched++;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatched = static_matched ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tif (exclude) {\n\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = 0;\n\t\t\t\t\t\texclude = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\tnb_caps_tested = 0;\n\t\t\t\t\tcur_dst_bundle++;\n\t\t\t\t\tif (cur_dst_bundle > for_dst_bundle)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//not an input cap\n\t\t\t\tif (!(in_cap->flags & GF_CAPFLAG_INPUT) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//optional cap, ignore\n\t\t\t\tif (in_cap->flags & GF_CAPFLAG_OPTIONAL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((cur_dst_bundle < for_dst_bundle) && !(in_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//prop was excluded, cannot match in bundle\n\t\t\t\tif (exclude) continue;\n\t\t\t\t//prop was matched, no need to check other caps in the current bundle\n\t\t\t\tif (matched) continue;\n\n\t\t\t\tif (out_cap->code && !cap_code_match(out_cap->code, in_cap->code) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (out_cap->name && (!in_cap->name || strcmp(out_cap->name, in_cap->name)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnb_caps_tested++;\n\t\t\t\t//we found a property of that type , check if equal equal\n\t\t\t\tprop_equal = gf_props_equal(&in_cap->val, &an_out_cap->val);\n\t\t\t\tif ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && !(an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//special case for excluded output caps marked for loaded filter only and optional:\n\t\t\t\t\t//always consider no match, the actual pid link resolving will sort this out\n\t\t\t\t\t//this fixes a bug in reframer -> ffdec links: since ffdec only specifies excluded GF_CODEC_ID caps,\n\t\t\t\t\t//not doing so will always force reframer->ufnalu->rfnalu->ffdec\n\t\t\t\t\tif (an_out_cap->flags & (GF_CAPFLAG_OPTIONAL|GF_CAPFLAG_LOADED_FILTER))\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\n\t\t\t\t\t//prop type matched, output includes it and input excludes it: no match, don't look any further\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tmatched = GF_FALSE;\n\t\t\t\t\t\texclude = GF_TRUE;\n\t\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//remember we found a prop of same type but excluded value\n\t\t\t\t\t\t// we will match unless we match an excluded value\n\t\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//prop type matched, input includes it and output excludes it: no match, don't look any further\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tmatched = GF_FALSE;\n\t\t\t\t\t\texclude = GF_TRUE;\n\t\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//remember we found a prop of same type but excluded value\n\t\t\t\t\t\t//we will match unless we match an excluded value\n\t\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (prop_equal) {\n\t\t\t\t\tmatched = GF_TRUE;\n//\t\t\t\t\tif (an_out_cap->flags & GF_CAPFLAG_STATIC)\n//\t\t\t\t\t\tstatic_matched = GF_TRUE;\n\t\t\t\t} else if ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//prop type matched, input excludes it and output excludes it and no match, remmeber we found the prop type\n\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (prop_found && (in_cap->flags & GF_CAPFLAG_LOADED_FILTER))\n\t\t\t\t\tcap_loaded_filter_only = 1;\n\t\t\t}\n\t\t\tif (nb_caps_tested) {\n\t\t\t\t//we found a prop, excluded but with != value hence acceptable, default matching to true\n\t\t\t\tif (!matched && prop_found) matched = GF_TRUE;\n\t\t\t\t//not match, flag this bundle as not ok\n\t\t\t\tif (matched) {\n\t\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\t\tnb_matched++;\n\t\t\t\t}\n\t\t\t\t//excluded cap was found, disable bundle (might have been activated before we found the excluded cap)\n\t\t\t\telse if (exclude) {\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = 0;\n\t\t\t\t}\n\t\t\t} else if (!nb_dst_caps) {\n\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\tnb_matched++;\n\t\t\t} else if (!nb_matched && !prop_found && (an_out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL)) && (cur_dst_bundle<nb_in_bundles) ) {\n\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\tnb_matched++;\n\t\t\t}\n\t\t}\n\t\t//merge bundle cap\n\t\tnb_matched=0;\n\t\tfor (k=0; k<nb_in_bundles; k++) {\n\t\t\tif (!bundles_cap_found[k])\n\t\t\t\tbundles_in_ok[k] = 0;\n\t\t\telse {\n\t\t\t\tnb_matched += 1;\n\t\t\t\t//we matched this property, keep score for the bundle\n\t\t\t\tbundles_in_scores[k] ++;\n\t\t\t\t//mark if connection is only valid for loaded inputs\n\t\t\t\tif (bundles_cap_found[k]==2)\n\t\t\t\t \tbundles_in_ok[k] |= 1<<1;\n\t\t\t\t//mark if connection is only valid for loaded outputs\n\t\t\t\tif (out_cap->flags & GF_CAPFLAG_LOADED_FILTER)\n\t\t\t\t\tbundles_in_ok[k] |= 1<<2;\n\t\t\t}\n\t\t}\n\n\t\t//not matched and not excluded, skip until next bundle\n\t\tif (!nb_matched && !(out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL))) {\n\t\t\tall_caps_matched = GF_FALSE;\n\t\t}\n\t}\n\n\t//get bundle with highest score\n\tbundle_score = 0;\n\tnb_matched = 0;\n\n\tfor (i=0; i<nb_in_bundles; i++) {\n\t\tif (bundles_in_ok[i]) {\n\t\t\tnb_matched++;\n\t\t\tif (bundle_score < bundles_in_scores[i]) {\n\t\t\t\t*dst_bundle_idx = i;\n\t\t\t\tbundle_score = bundles_in_scores[i];\n\t\t\t\tif (loaded_filter_flags) {\n\t\t\t\t\t*loaded_filter_flags = (bundles_in_ok[i]>>1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (for_dst_bundle==i) {\n\t\t\t\t*dst_bundle_idx = i;\n\t\t\t\tif (loaded_filter_flags) {\n\t\t\t\t\t*loaded_filter_flags = (bundles_in_ok[i]>>1);\n\t\t\t\t}\n\t\t\t\treturn bundles_in_scores[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (!bundle_score) {\n//\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s outputs cap bundle %d do not match filter %s inputs\\n\", src->name, src_bundle_idx, dst_reg->name));\n\t} else {\n//\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s outputs cap bundle %d matches filter %s inputs caps bundle %d (%d total bundle matches, bundle matched %d/%d caps)\\n\", src->name, src_bundle_idx, dst_reg->name, *dst_bundle_idx, nb_matched, bundle_score, nb_out_caps));\n\t}\n\treturn bundle_score;\n}\n\nGF_EXPORT\nBool gf_filter_pid_check_caps(GF_FilterPid *_pid)\n{\n\tu8 priority;\n\tBool res;\n\tGF_Filter *on_filter;\n\tif (PID_IS_OUTPUT(_pid)) return GF_FALSE;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)_pid;\n\ton_filter = pidi->alias_orig ? pidi->alias_orig : pidi->filter;\n\tpidi->pid->local_props = pidi->props;\n\tres = gf_filter_pid_caps_match(pidi->pid, NULL, on_filter, &priority, NULL, on_filter, -1);\n\tpidi->pid->local_props = NULL;\n\treturn res;\n}\n\n\nstatic void concat_reg(GF_FilterSession *sess, char prefRegister[1001], const char *reg_key, const char *args)\n{\n\tu32 len;\n\tchar *forced_reg, *sep;\n\tif (!args) return;\n\tforced_reg = strstr(args, reg_key);\n\tif (!forced_reg) return;\n\tforced_reg += 6;\n\tsep = strchr(forced_reg, sess->sep_args);\n\tlen = sep ? (u32) (sep-forced_reg) : (u32) strlen(forced_reg);\n\tif (len+2+strlen(prefRegister)>1000) {\n\t\treturn;\n\t}\n\tif (prefRegister[0]) {\n\t\tchar szSepChar[2];\n\t\tszSepChar[0] = sess->sep_args;\n\t\tszSepChar[1] = 0;\n\t\tstrcat(prefRegister, szSepChar);\n\t}\n\tstrncat(prefRegister, forced_reg, len);\n}\n\nstatic Bool gf_filter_out_caps_solved_by_connection(const GF_FilterRegister *freg, u32 bundle_idx)\n{\n\tu32 i, k, cur_bundle_idx = 0;\n    u32 nb_out_caps=0;\n\tfor (i=0; i<freg->nb_caps; i++) {\n\t\tu32 nb_caps = 0;\n        u32 cap_bundle_idx = 0;\n\t\tconst GF_FilterCapability *cap = &freg->caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tcur_bundle_idx++;\n\t\t\tif (cur_bundle_idx>bundle_idx) return GF_FALSE;\n            continue;\n\t\t}\n\t\tif (!(cap->flags & GF_CAPFLAG_STATIC) && (bundle_idx>cur_bundle_idx)) continue;\n\t\tif (!(cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\n\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\n\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\tconst GF_FilterCapability *acap = &freg->caps[k];\n            if (!(acap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n                cap_bundle_idx++;\n                continue;\n            }\n\t\t\tif (!(acap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\tif (acap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\t\t\tif (!(acap->flags & GF_CAPFLAG_STATIC) && (cap_bundle_idx!=bundle_idx) ) continue;\n\n\t\t\tif (cap->code && (acap->code==cap->code)) {\n\t\t\t\tnb_caps++;\n\t\t\t} else if (cap->name && acap->name && !strcmp(cap->name, acap->name)) {\n\t\t\t\tnb_caps++;\n\t\t\t}\n\t\t\t//if more than one cap with same code in same bundle, consider the filter is undecided\n\t\t\tif (nb_caps>1)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n        if (nb_caps && !(cap->flags & GF_CAPFLAG_EXCLUDED))\n            nb_out_caps++;\n\t}\n\tif (!nb_out_caps)\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic s32 gf_filter_reg_get_bundle_stream_type(const GF_FilterRegister *freg, u32 cap_idx, Bool for_output)\n{\n\tu32 i, cur_bundle, stype=0, nb_stype=0;\n\n\tcur_bundle = 0;\n\tfor (i=0; i<freg->nb_caps; i++) {\n\t\tu32 cap_stype=0;\n\t\tconst GF_FilterCapability *cap = &freg->caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tcur_bundle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (for_output) {\n\t\t\tif (!(cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t} else {\n\t\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t}\n\t\tif ((cur_bundle != cap_idx) && !(cap->flags & GF_CAPFLAG_STATIC) ) continue;\n\t\t//output type is file or same media type, allow looking for filter chains\n\t\tif (cap->flags & GF_CAPFLAG_EXCLUDED) continue;\n\n\t\tif (cap->code == GF_PROP_PID_STREAM_TYPE)\n\t\t\tcap_stype = cap->val.value.uint;\n\t\telse if ((cap->code == GF_PROP_PID_MIME) || (cap->code == GF_PROP_PID_FILE_EXT) )\n\t\t\tcap_stype = GF_STREAM_FILE;\n\n\t\tif (!cap_stype) continue;\n\n\t\tif (stype != cap_stype) {\n\t\t\tstype = cap_stype;\n\t\t\tnb_stype++;\n\t\t}\n\t}\n\tif (nb_stype==1) return (s32) stype;\n\tif (nb_stype) return -1;\n\treturn 0;\n}\n\n/*recursively enable edges of the graph.\n\treturns 0 if subgraph shall be disabled (will marke edge at the root of the subgraph disabled)\n\treturns 1 if subgraph shall be enabled (will marke edge at the root of the subgraph enabled)\n\treturns 2 if no decision can be taken because the subgraph is too deep. We don't mark the parent edge as disabled because the same subgraph/edge can be used at other places in a shorter path\n*/\nstatic u32 gf_filter_pid_enable_edges(GF_FilterSession *fsess, GF_FilterRegDesc *reg_desc, u32 src_cap_idx, const GF_FilterRegister *src_freg, u32 rlevel, s32 dst_stream_type, GF_FilterRegDesc *parent_desc, GF_FilterPid *pid, u32 pid_stream_type)\n{\n\tu32 i=0;\n\tBool enable_graph = GF_FALSE;\n\tBool aborted_graph_too_deep = GF_FALSE;\n\n\t//we found the source reg we want to connect to!\n\tif (src_freg == reg_desc->freg) {\n\t\treturn 1;\n\t}\n\t//the subgraph is too deep, abort marking edges but don't decide\n\tif (rlevel > fsess->max_resolve_chain_len) {\n\t\treturn 2;\n\t}\n\t//we don't allow loops in dynamic chain resolution, so consider the parent edge invalid\n\tif (reg_desc->in_edges_enabling)\n\t\treturn 0;\n\n\t/*if dst type is FILE, reg_desc is a muxer or the loaded destination (a demuxer or a file)\n\twe only accept dst type FILE for the first call (ie reg desc is the loaded destination), and forbid muxers in the middle of the chain\n\tfor dynamic resolution. This avoids situations such as StreamTypeA->mux->demux->streamtypeB which cannot be resolved\n\n\tnote that it is still possible to use a mux or demux in the chain, but they have to be explicitly loaded\n\t*/\n\tif ((rlevel>1) && (dst_stream_type==GF_STREAM_FILE))\n\t\treturn 0;\n\n\treg_desc->in_edges_enabling = 1;\n\n\tfor (i=0; i<reg_desc->nb_edges; i++) {\n\t\tu32 res;\n\t\ts32 source_stream_type;\n\t\tGF_FilterRegEdge *edge = &reg_desc->edges[i];\n\t\t//this edge is not for our target source cap bundle\n\t\tif (edge->dst_cap_idx != src_cap_idx) continue;\n\n\t\t//edge is already disabled (the subgraph doesn't match our source), don't test it\n\t\tif (edge->status == EDGE_STATUS_DISABLED)\n\t\t\tcontinue;\n\n\t\t//if source is not edge origin and edge is only valid for explicitly loaded filters, disable edge\n\t\tif (edge->loaded_filter_only && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tedge->disabled_depth = rlevel+1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//edge is already enabled (the subgraph matches our source), don't test it but remember to indicate the graph is valid\n\t\tif (edge->status == EDGE_STATUS_ENABLED) {\n\t\t\tenable_graph = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//candidate edge, check stream type\n\t\tsource_stream_type = edge->src_stream_type;\n\n\t\tif (pid->filter->freg == edge->src_reg->freg)\n\t\t\tsource_stream_type = pid_stream_type;\n\n\t\t//source edge cap indicates multiple stream types (demuxer/encoder/decoder dundle)\n\t\tif (source_stream_type<0) {\n\t\t\t//if destination type is known (>=0 and NOT file, inherit it\n\t\t\t//otherwise, we we can't filter out yet\n\t\t\tif ((dst_stream_type>0) && (dst_stream_type != GF_STREAM_FILE))\n\t\t\t\tsource_stream_type = dst_stream_type;\n\t\t}\n\t\t//inherit source type if not specified\n\t\tif (!source_stream_type && dst_stream_type>0)\n\t\t\tsource_stream_type = dst_stream_type;\n\t\t//if source is encrypted type and dest type is set, use dest type\n\t\tif ((source_stream_type==GF_STREAM_ENCRYPTED) && (dst_stream_type>0) && (dst_stream_type!=GF_STREAM_FILE))\n\t\t\tsource_stream_type = dst_stream_type;\n\t\t//if dest is encrypted type and source type is set, use source type\n\t\tif ((dst_stream_type==GF_STREAM_ENCRYPTED) && source_stream_type>0)\n\t\t\tdst_stream_type = source_stream_type;\n\n\t\t//if stream types are know (>0) and not source files, do not mark the edges if they mismatch\n\t\t//moving from non-file type A to non-file type B requires an explicit filter\n\t\tif ((dst_stream_type>0) && (source_stream_type>0) && (source_stream_type != GF_STREAM_FILE) && (dst_stream_type != GF_STREAM_FILE) && (source_stream_type != dst_stream_type)) {\n\n\t\t\t//exception: we allow text|scene|od ->video for dynamic compositor\n\t\t\tif (!(reg_desc->freg->flags & GF_FS_REG_EXPLICIT_ONLY) && (dst_stream_type==GF_STREAM_VISUAL)\n\t\t\t\t&& ((source_stream_type==GF_STREAM_TEXT) || (source_stream_type==GF_STREAM_SCENE) || (source_stream_type==GF_STREAM_OD) )\n\t\t\t) {\n\n\t\t\t} else {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tedge->disabled_depth = rlevel+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tres = gf_filter_pid_enable_edges(fsess, edge->src_reg, edge->src_cap_idx, src_freg, rlevel+1, source_stream_type, reg_desc, pid, pid_stream_type);\n\t\t//if subgraph matches our source reg, mark the edge towards this subgraph as enabled\n\t\tif (res==1) {\n\t\t\tedge->status = EDGE_STATUS_ENABLED;\n\t\t\tenable_graph = GF_TRUE;\n\t\t}\n\t\t//if sub-graph below is too deep, don't mark the edge since we might need to resolve it again with a shorter subgraph\n\t\telse if (res==2) {\n\t\t\taborted_graph_too_deep = GF_TRUE;\n\t\t}\n\t\t//otherwise the subgraph doesn't match our source reg, mark as disaled and never test again\n\t\telse if (res==0) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tedge->disabled_depth = rlevel+1;\n\t\t}\n\t}\n\treg_desc->in_edges_enabling = 0;\n\t//we had enabled edges, the subgraph is valid\n\tif (enable_graph) return 1;\n\t//we aborted because too deep, indicate it to the caller so that the edge is not disabled\n\tif (aborted_graph_too_deep) return 2;\n\t//disable subgraph\n\treturn 0;\n}\n\nstatic void gf_filter_reg_build_graph_single(GF_FilterRegDesc *reg_desc, const GF_FilterRegister *freg, GF_FilterRegDesc *a_reg, Bool freg_has_output, u32 nb_dst_caps, GF_CapsBundleStore *capstore, GF_Filter *dst_filter)\n{\n\tu32 nb_src_caps, k, l;\n\tu32 path_weight;\n\n\t//check which cap of this filter matches our destination\n\tnb_src_caps = gf_filter_caps_bundle_count(a_reg->freg->caps, a_reg->freg->nb_caps);\n\tfor (k=0; k<nb_src_caps; k++) {\n\t\tfor (l=0; l<nb_dst_caps; l++) {\n\t\t\ts32 bundle_idx;\n\n\t\t\tif (gf_filter_has_out_caps(a_reg->freg->caps, a_reg->freg->nb_caps)) {\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\n\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(a_reg->freg, k, (const GF_FilterRegister *) freg, dst_filter, &bundle_idx, l, &loaded_filter_only_flags, capstore);\n\n\t\t\t\tif (path_weight && (bundle_idx == l)) {\n\t\t\t\t\tGF_FilterRegEdge *edge;\n\t\t\t\t\tif (reg_desc->nb_edges==reg_desc->nb_alloc_edges) {\n\t\t\t\t\t\treg_desc->nb_alloc_edges += 10;\n\t\t\t\t\t\treg_desc->edges = gf_realloc(reg_desc->edges, sizeof(GF_FilterRegEdge) * reg_desc->nb_alloc_edges);\n\t\t\t\t\t}\n\t\t\t\t\tassert(path_weight<0xFF);\n\t\t\t\t\tassert(k<0xFFFF);\n\t\t\t\t\tassert(l<0xFFFF);\n\t\t\t\t\tedge = &reg_desc->edges[reg_desc->nb_edges];\n\t\t\t\t\tmemset(edge, 0, sizeof(GF_FilterRegEdge));\n\t\t\t\t\tedge->src_reg = a_reg;\n\t\t\t\t\tedge->weight = (u8) path_weight;\n\t\t\t\t\tedge->src_cap_idx = (u16) k;\n\t\t\t\t\tedge->dst_cap_idx = (u16) l;\n\n\t\t\t\t\t//we inverted the caps, invert the flags\n\t\t\t\t\tif (loaded_filter_only_flags & EDGE_LOADED_SOURCE_ONLY)\n\t\t\t\t\t\tedge->loaded_filter_only |= EDGE_LOADED_DEST_ONLY;\n\t\t\t\t\tif (loaded_filter_only_flags & EDGE_LOADED_DEST_ONLY)\n\t\t\t\t\t\tedge->loaded_filter_only |= EDGE_LOADED_SOURCE_ONLY;\n\t\t\t\t\tedge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);\n\t\t\t\t\treg_desc->nb_edges++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( freg_has_output ) {\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\n\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(freg, l, a_reg->freg, dst_filter, &bundle_idx, k, &loaded_filter_only_flags, capstore);\n\n\t\t\t\tif (path_weight && (bundle_idx == k)) {\n\t\t\t\t\tGF_FilterRegEdge *edge;\n\t\t\t\t\tif (a_reg->nb_edges==a_reg->nb_alloc_edges) {\n\t\t\t\t\t\ta_reg->nb_alloc_edges += 10;\n\t\t\t\t\t\ta_reg->edges = gf_realloc(a_reg->edges, sizeof(GF_FilterRegEdge) * a_reg->nb_alloc_edges);\n\t\t\t\t\t}\n\t\t\t\t\tedge = &a_reg->edges[a_reg->nb_edges];\n\t\t\t\t\tedge->src_reg = reg_desc;\n\t\t\t\t\tedge->weight = (u8) path_weight;\n\t\t\t\t\tedge->src_cap_idx = (u16) l;\n\t\t\t\t\tedge->dst_cap_idx = (u16) k;\n\t\t\t\t\tedge->priority = 0;\n\t\t\t\t\tedge->loaded_filter_only = loaded_filter_only_flags;\n\t\t\t\t\tedge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);\n\t\t\t\t\ta_reg->nb_edges++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GF_FilterRegDesc *gf_filter_reg_build_graph(GF_List *links, const GF_FilterRegister *freg, GF_CapsBundleStore *capstore, GF_FilterPid *src_pid, GF_Filter *dst_filter)\n{\n\tu32 nb_dst_caps, nb_regs, i, nb_caps;\n\tBool freg_has_output;\n\n\tGF_FilterRegDesc *reg_desc = NULL;\n\tconst GF_FilterCapability *caps = freg->caps;\n\tnb_caps = freg->nb_caps;\n\tif (dst_filter && ((freg->flags & (GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM)) || (src_pid && dst_filter->forced_caps) ) ) {\n\t\tcaps = dst_filter->forced_caps;\n\t\tnb_caps = dst_filter->nb_forced_caps;\n\t}\n\n\tfreg_has_output = gf_filter_has_out_caps(caps, nb_caps);\n\n\tGF_SAFEALLOC(reg_desc, GF_FilterRegDesc);\n\tif (!reg_desc) return NULL;\n\n\treg_desc->freg = freg;\n\n\tnb_dst_caps = gf_filter_caps_bundle_count(caps, nb_caps);\n\n\n\t//we are building a register descriptor acting as destination, ignore any output caps\n\tif (src_pid || dst_filter) freg_has_output = GF_FALSE;\n\n\t//setup all connections\n\tnb_regs = gf_list_count(links);\n\tfor (i=0; i<nb_regs; i++) {\n\t\tGF_FilterRegDesc *a_reg = gf_list_get(links, i);\n\t\tif (a_reg->freg == freg) continue;\n\n\t\tgf_filter_reg_build_graph_single(reg_desc, freg, a_reg, freg_has_output, nb_dst_caps, capstore, dst_filter);\n\t}\n\n\tif (!dst_filter && (freg->flags & GF_FS_REG_ALLOW_CYCLIC)) {\n\t\tgf_filter_reg_build_graph_single(reg_desc, freg, reg_desc, freg_has_output, nb_dst_caps, capstore, NULL);\n\t}\n\treturn reg_desc;\n}\n\nvoid gf_filter_sess_build_graph(GF_FilterSession *fsess, const GF_FilterRegister *for_reg)\n{\n\tu32 i, count;\n\tGF_CapsBundleStore capstore;\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\n\tif (!fsess->links) fsess->links = gf_list_new();\n\n\tif (for_reg) {\n\t\tGF_FilterRegDesc *freg_desc = gf_filter_reg_build_graph(fsess->links, for_reg, &capstore, NULL, NULL);\n\t\tif (!freg_desc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to build graph entry for filter %s\\n\", for_reg->name));\n\t\t} else {\n\t\t\tgf_list_add(fsess->links, freg_desc);\n\t\t}\n\t} else {\n#ifndef GPAC_DISABLE_LOG\n\t\tu64 start_time = gf_sys_clock_high_res();\n#endif\n\t\tcount = gf_list_count(fsess->registry);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst GF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\t\tGF_FilterRegDesc *freg_desc = gf_filter_reg_build_graph(fsess->links, freg, &capstore, NULL, NULL);\n\t\t\tif (!freg_desc) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to build graph entry for filter %s\\n\", freg->name));\n\t\t\t} else {\n\t\t\t\tgf_list_add(fsess->links, freg_desc);\n\t\t\t}\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Built filter graph in \"LLU\" us\\n\", gf_sys_clock_high_res() - start_time));\n\n\t\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\tu32 j;\n\t\t\tcount = gf_list_count(fsess->links);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterRegDesc *freg_desc = gf_list_get(fsess->links, i);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources:\", freg_desc->freg->name));\n\t\t\t\tfor (j=0; j<freg_desc->nb_edges; j++ ) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d,%d->%d)\", freg_desc->edges[j].src_reg->freg->name, freg_desc->edges[j].weight, freg_desc->edges[j].src_cap_idx, freg_desc->edges[j].dst_cap_idx));\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t\t\t}\n\t\t}\n\t}\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n}\n\nvoid gf_filter_sess_reset_graph(GF_FilterSession *fsess, const GF_FilterRegister *freg)\n{\n\tgf_mx_p(fsess->links_mx);\n\t//explicit registry removal and not destroying the session\n\tif (freg && fsess->filters) {\n\t\ts32 reg_idx=-1;\n\t\tu32 i, count = gf_list_count(fsess->links);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j;\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(fsess->links, i);\n\t\t\tif (rdesc->freg == freg) {\n\t\t\t\treg_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\t\tif (rdesc->edges[j].src_reg->freg == freg) {\n\t\t\t\t\tif (rdesc->nb_edges > j + 1) {\n\t\t\t\t\t\tmemmove(&rdesc->edges[j], &rdesc->edges[j+1], sizeof (GF_FilterRegEdge) * (rdesc->nb_edges - j - 1));\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t\trdesc->nb_edges--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (reg_idx>=0) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(fsess->links, reg_idx);\n\t\t\tgf_list_rem(fsess->links, reg_idx);\n\t\t\tgf_free(rdesc->edges);\n\t\t\tgf_free(rdesc);\n\t\t}\n\t} else {\n\t\twhile (gf_list_count(fsess->links)) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_pop_back(fsess->links);\n\t\t\tgf_free(rdesc->edges);\n\t\t\tgf_free(rdesc);\n\t\t}\n\t}\n\tgf_mx_v(fsess->links_mx);\n}\n\n#ifndef GPAC_DISABLE_LOG\nvoid dump_dijstra_edges(Bool is_before, GF_FilterRegDesc *reg_dst, GF_List *dijkstra_nodes)\n{\n\tu32 i, count;\n\tif (! gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG))\n\t\treturn;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Dijstra edges %s edge solving\\n\", is_before ? \"before\" : \"after\"));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources: \", reg_dst->freg->name));\n\tfor (i=0; i<reg_dst->nb_edges; i++) {\n\t\tGF_FilterRegEdge *edge = &reg_dst->edges[i];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d(%d),%d,%d->%d)\", edge->src_reg->freg->name, edge->status, edge->disabled_depth, edge->weight, edge->src_cap_idx, edge->dst_cap_idx));\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\n\tcount = gf_list_count(dijkstra_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources: \", rdesc->freg->name));\n\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &rdesc->edges[j];\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d(%d),%d,%d->%d)\", edge->src_reg->freg->name, edge->status, edge->disabled_depth, edge->weight, edge->src_cap_idx, edge->dst_cap_idx));\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t}\n}\n#endif\n\nstatic void gf_filter_pid_resolve_link_dijkstra(GF_FilterPid *pid, GF_Filter *dst, const char *prefRegister, Bool reconfigurable_only, GF_List *out_reg_chain)\n{\n\tGF_FilterRegDesc *reg_dst, *result;\n\tGF_List *dijkstra_nodes;\n\tGF_FilterSession *fsess = pid->filter->session;\n\t//build all edges\n\tu32 i, dijsktra_node_count, dijsktra_edge_count, count;\n\tGF_CapsBundleStore capstore;\n\tBool first;\n\tBool check_codec_id_raw = GF_FALSE;\n\tu32 path_weight, pid_stream_type, max_weight=0;\n\tu64 dijkstra_time_us, sort_time_us, start_time_us = gf_sys_clock_high_res();\n\tconst GF_PropertyValue *p;\n\tif (!fsess->links || ! gf_list_count( fsess->links))\n\t \tgf_filter_sess_build_graph(fsess, NULL);\n\n\tdijkstra_nodes = gf_list_new();\n\n\tresult = NULL;\n\tpid_stream_type = 0;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) pid_stream_type = p->value.uint;\n\n\t//decoders usually do not expose reconfigure_output interface\n\t//if this is a reconfig asking for codecID=raw, check each registry for non-raw->raw conversion\n\t//and if present consider this filter suitable\n\t//note that encoders must use reconfigure output\n\tif (reconfigurable_only\n\t\t&& pid->caps_negociate\n\t\t&& (gf_list_count(pid->caps_negociate->properties)==1)\n\t) {\n\t\tconst GF_PropertyValue *cid = gf_props_get_property(pid->caps_negociate, GF_PROP_PID_CODECID, NULL);\n\t\t//for now we only check decoders, encoders must use reconfigure output\n\t\tif (cid && (cid->value.uint==GF_CODECID_RAW)) {\n\t\t\tcheck_codec_id_raw = cid->value.uint;\n\t\t}\n\t}\n\n\t//1: select all elligible filters for the graph resolution: exclude sources, sinks, explicits, blacklisted and not reconfigurable if we reconfigure\n\tcount = gf_list_count(fsess->links);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tBool disable_filter = GF_FALSE;\n\t\tBool reconf_only = reconfigurable_only;\n\t\tGF_FilterRegDesc *reg_desc = gf_list_get(fsess->links, i);\n\t\tconst GF_FilterRegister *freg = reg_desc->freg;\n\n\t\tif (check_codec_id_raw) {\n\t\t\tBool has_raw_out=GF_FALSE, has_non_raw_in=GF_FALSE;\n\t\t\tfor (j=0; j<freg->nb_caps; j++) {\n\t\t\t\tif (!(freg->caps[j].flags & GF_CAPFLAG_IN_BUNDLE))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (freg->caps[j].code!=GF_PROP_PID_CODECID) continue;\n\n\t\t\t\tif (freg->caps[j].val.value.uint == GF_CODECID_RAW) {\n\t\t\t\t\tif ((freg->caps[j].flags & GF_CAPFLAG_OUTPUT) && ! (freg->caps[j].flags & GF_CAPFLAG_EXCLUDED))\n\t\t\t\t\t\thas_raw_out = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((freg->caps[j].flags & GF_CAPFLAG_INPUT) && ! (freg->caps[j].flags & GF_CAPFLAG_EXCLUDED))\n\t\t\t\t\thas_non_raw_in = GF_TRUE;\n\t\t\t}\n\t\t\tif (has_raw_out && has_non_raw_in)\n\t\t\t\treconf_only = GF_FALSE;\n\t\t}\n\t\t//reset state, except for edges which are reseted after each dijkstra resolution\n\t\treg_desc->destination = NULL;\n\t\treg_desc->cap_idx = 0;\n\t\treg_desc->in_edges_enabling = 0;\n\t\t//set node distance and priority to infinity, whether we are in the final dijsktra set or not\n\t\treg_desc->dist = -1;\n\t\treg_desc->priority = 0xFF;\n\n\t\t//remember our source descriptor - it may be absent of the final node set in case we want reconfigurable only filters\n\t\t//and the source is not reconfigurable\n\t\tif (freg == pid->filter->freg)\n\t\t\tresult = reg_desc;\n\n\t\t//don't add source filters except if PID is from source\n\t\tif (!freg->configure_pid && (freg!=pid->filter->freg)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//freg shall be instantiated\n\t\telse if ((freg->flags & (GF_FS_REG_EXPLICIT_ONLY|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM)) && (freg != pid->filter->freg) && (freg != dst->freg) ) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//no output caps, cannot add\n\t\telse if ((freg != dst->freg) && !gf_filter_has_out_caps(freg->caps, freg->nb_caps)) {\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//we only want reconfigurable output filters\n\t\telse if (reconf_only && !freg->reconfigure_output && (freg != dst->freg)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//blacklisted filter\n\t\telse if (gf_list_find(pid->filter->blacklisted, (void *) freg)>=0) {\n\t\t\t//this commented because not true for multi-pids inputs (tiling) to a decoder\n\t\t\t//assert(freg != dst->freg);\n\t\t\tif (!reconfigurable_only) {\n\t\t\t\tassert(freg != pid->filter->freg);\n\t\t\t}\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//blacklisted adaptation filter\n\t\telse if (pid->adapters_blacklist && (gf_list_find(pid->adapters_blacklist, (void *) freg)>=0)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\n\t\t//reset edge status\n\t\tfor (j=0; j<reg_desc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &reg_desc->edges[j];\n\n\t\t\tedge->disabled_depth = 0;\n\t\t\tif (disable_filter) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tedge->status = EDGE_STATUS_NONE;\n\n\t\t\t//connection from source, disable edge if pid caps mismatch\n\t\t\tif (edge->src_reg->freg == pid->filter->freg) {\n\t\t\t\tu8 priority=0;\n\t\t\t\tu32 dst_bundle_idx;\n\t\t\t\t//check path weight for the given dst cap - we MUST give the target cap otherwise we might get a default match to another cap\n\t\t\t\tpath_weight = gf_filter_pid_caps_match(pid, freg, NULL, &priority, &dst_bundle_idx, pid->filter->dst_filter, edge->dst_cap_idx);\n\t\t\t\tif (!path_weight) {\n\t\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if 0\n\t\t\t\tif (priority)\n\t\t\t\t\tpath_weight *= priority;\n#endif\n\t\t\t}\n\n\t\t\t//if source is not edge origin and edge is only valid for explicitly loaded filters, disable edge\n\t\t\tif ((edge->loaded_filter_only & EDGE_LOADED_SOURCE_ONLY) && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((u32) edge->weight + 1 > max_weight)\n\t\t\t\tmax_weight = (u32) edge->weight + 1;\n\t\t}\n\t\t//not in set\n\t\tif (disable_filter)\n\t\t\tcontinue;\n\n\n\t\t//do not add destination filter\n\t\tif (dst->freg == reg_desc->freg) {\n\t\t\treg_desc->dist = 0;\n\t\t\treg_desc->priority = 0;\n\t\t} else {\n\t\t\tgf_list_add(dijkstra_nodes, reg_desc);\n\t\t}\n\t}\n\t//create a new node for the destination based on elligible filters in the graph\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\treg_dst = gf_filter_reg_build_graph(dijkstra_nodes, dst->freg, &capstore, pid, dst);\n\treg_dst->dist = 0;\n\treg_dst->priority = 0;\n\treg_dst->in_edges_enabling = 0;\n\n\t//enable edges of destination, potentially disabling edges from source filters to dest\n\tfor (i=0; i<reg_dst->nb_edges; i++) {\n\t\tGF_FilterRegEdge *edge = &reg_dst->edges[i];\n\t\tedge->status = EDGE_STATUS_NONE;\n\n\t\t//connection from source, disable edge if pid caps mismatch\n\t\tif (edge->src_reg->freg == pid->filter->freg) {\n\t\t\tu8 priority=0;\n\t\t\tu32 dst_bundle_idx;\n\t\t\tpath_weight = gf_filter_pid_caps_match(pid, dst->freg, dst, &priority, &dst_bundle_idx, pid->filter->dst_filter, -1);\n\t\t\tif (!path_weight) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst_bundle_idx != edge->dst_cap_idx) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//the edge source filter is not loaded, disable edges marked for loaded filter only\n\t\tif ( (edge->loaded_filter_only & EDGE_LOADED_SOURCE_ONLY) && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tcontinue;\n\t\t}\n\t\t//we are relinking to a dynamically loaded filter, only accept edges connecting to the same bundle as when\n\t\t//the initial resolution was done, unless the edge is marked as loaded destination filter only in which case\n\t\t//we accept connection\n\t\tif ((dst->bundle_idx_at_resolution>=0)\n\t\t\t//if dest is a mux, don't check bundle idx\n\t\t\t&& !dst->max_extra_pids\n\t\t\t&& !(edge->loaded_filter_only & EDGE_LOADED_DEST_ONLY)\n\t\t\t&& (edge->dst_cap_idx !=dst->bundle_idx_at_resolution)\n\t\t) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((u32) edge->weight + 1 > max_weight)\n\t\t\tmax_weight = edge->weight + 1;\n\t\t//enable edge and propagate down the graph\n\t\tedge->status = EDGE_STATUS_ENABLED;\n\n\t\tgf_filter_pid_enable_edges(fsess, edge->src_reg, edge->src_cap_idx, pid->filter->freg, 1, edge->src_stream_type, reg_dst, pid, pid_stream_type);\n\t}\n\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\tdump_dijstra_edges(GF_FALSE, reg_dst, dijkstra_nodes);\n\t}\n#endif\n\n\t//remove all filters not used for this resolution (no enabled edges), except source one\n\tcount = gf_list_count(dijkstra_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, nb_edges;\n\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\tif (rdesc->freg == pid->filter->freg) continue;\n\n\t\tnb_edges = 0;\n\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &rdesc->edges[j];\n\t\t\tif (edge->status == EDGE_STATUS_ENABLED) {\n\t\t\t\tnb_edges++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!nb_edges) {\n\t\t\tgf_list_rem(dijkstra_nodes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_LOG\n\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filters in dijkstra set:\"));\n\t\tcount = gf_list_count(dijkstra_nodes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s\", rdesc->freg->name));\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t}\n#endif\n\n\tsort_time_us = gf_sys_clock_high_res();\n\n\n\tdijsktra_edge_count = 0;\n\tdijsktra_node_count = gf_list_count(dijkstra_nodes)+1;\n\tfirst = GF_TRUE;\n\t//OK we have the weighted graph, perform a dijkstra on the graph - we assign by weight, and if same weight we check the priority\n\twhile (1) {\n\t\tGF_FilterRegDesc *current_node = NULL;\n\t\tu32 reg_idx = -1;\n\t\tu32 min_dist = -1;\n\n\t\tcount = gf_list_count(dijkstra_nodes);\n\t\tif (!count) break;\n\n\t\tif (first) {\n\t\t\tcurrent_node = reg_dst;\n\t\t} else {\n\t\t\t//pick up shortest distance\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterRegDesc *reg_desc = gf_list_get(dijkstra_nodes, i);\n\t\t\t\tif (reg_desc->dist < min_dist) {\n\t\t\t\t\tmin_dist = reg_desc->dist;\n\t\t\t\t\tcurrent_node = reg_desc;\n\t\t\t\t\treg_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//remove current\n\t\t\tif (!current_node)\n\t\t\t\tbreak;\n\t\t\tgf_list_rem(dijkstra_nodes, reg_idx);\n\t\t}\n\n\t\tif (current_node->freg == pid->filter->freg) {\n\t\t\tresult = current_node;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: testing filter %s\\n\", current_node->freg->name));\n\n\t\t//compute distances\n\t\tfor (i=0; i<current_node->nb_edges; i++) {\n\t\t\tu8 priority=0;\n\t\t\tGF_FilterRegEdge *redge = &current_node->edges[i];\n\t\t\tu32 dist;\n\t\t\tBool do_switch = GF_FALSE;\n\t\t\tdijsktra_edge_count++;\n\n\t\t\tif (redge->status != EDGE_STATUS_ENABLED)\n\t\t\t\tcontinue;\n\n\t\t\tdist = current_node->dist + 1;//(max_weight - redge->weight);\n\t\t\tif (current_node->freg->flags & GF_FS_REG_HIDE_WEIGHT) {\n\t\t\t\tdist = current_node->dist;\n\t\t\t}\n\n\t\t\tpriority = redge->priority;\n\t\t\tif (redge->src_reg->freg == pid->filter->freg) {\n\t\t\t\ts32 dst_bundle_idx;\n\t\t\t\tif (gf_filter_pid_caps_match(pid, current_node->freg, NULL, &priority, &dst_bundle_idx, dst, redge->dst_cap_idx)) {\n\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist < redge->src_reg->dist) do_switch = GF_TRUE;\n\t\t\telse if (dist == redge->src_reg->dist) {\n\t\t\t\tif (prefRegister[0] && (redge->src_reg->destination != current_node) && strstr(prefRegister, current_node->freg->name)) {\n\t\t\t\t\tdo_switch = GF_TRUE;\n\t\t\t\t\tpriority = 0;\n\t\t\t\t} else if ( (dist == redge->src_reg->dist) && (priority < redge->src_reg->priority) )\n\t\t\t\t\tdo_switch = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (do_switch) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: assign filter %s distance %d destination to %s in cap %d out cap %d priority %d (previous destination %s distance %d priority %d)\\n\", redge->src_reg->freg->name, dist, current_node->freg->name, redge->src_cap_idx, redge->dst_cap_idx, redge->priority, redge->src_reg->destination ? redge->src_reg->destination->freg->name : \"none\", redge->src_reg->dist, redge->src_reg->priority ));\n\t\t\t\tredge->src_reg->dist = dist;\n\t\t\t\tredge->src_reg->priority = priority;\n\t\t\t\tredge->src_reg->destination = current_node;\n\t\t\t\tredge->src_reg->cap_idx = redge->src_cap_idx;\n\t\t\t} else if (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: no shorter path from filter %s distance %d from destination %s priority %d (tested %s dist %d priority %d)\\n\", redge->src_reg->freg->name, redge->src_reg->dist, redge->src_reg->destination ? redge->src_reg->destination->freg->name : \"none\", redge->priority, current_node->freg->name, dist, redge->src_reg->priority));\n\t\t\t}\n\t\t}\n\t\tfirst = GF_FALSE;\n\t}\n\n\tsort_time_us -= start_time_us;\n\tdijkstra_time_us = gf_sys_clock_high_res() - start_time_us;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: sorted filters in \"LLU\" us, Dijkstra done in \"LLU\" us on %d nodes %d edges\\n\", sort_time_us, dijkstra_time_us, dijsktra_node_count, dijsktra_edge_count));\n\n\tif (result && result->destination) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra result: %s(%d)\", result->freg->name, result->cap_idx));\n\t\tresult = result->destination;\n\t\twhile (result->destination) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d)\", result->freg->name, result->cap_idx ));\n\t\t\tgf_list_add(out_reg_chain, (void *) result->freg);\n\t\t\tgf_list_add(out_reg_chain, (void *) &result->freg->caps[result->cap_idx]);\n\t\t\tresult = result->destination;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s\\n\", result->freg->name));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"[Filters] Dijkstra: no results found!\\n\"));\n\t}\n\tgf_list_del(dijkstra_nodes);\n\n\tgf_free(reg_dst->edges);\n\tgf_free(reg_dst);\n}\n\n\n/*\n\t!Resolves a link between a PID and a destination filter\n\n\\param pid source pid to connect\n\\param dst destination filter to connect source PID to\n\\param filter_reassigned indicates the filter has been destroyed and reassigned\n\\param reconfigurable_only indicates the chain should be loaded for reconfigurable filters\n\\return the first filter in the matching chain, or NULL if no match\n*/\nstatic GF_Filter *gf_filter_pid_resolve_link_internal(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned, u32 reconfigurable_only_type, u32 *min_chain_len, GF_List *skip_if_in_filter_list, Bool *skipped)\n{\n\tGF_Filter *chain_input = NULL;\n\tGF_FilterSession *fsess = pid->filter->session;\n\tGF_List *filter_chain;\n\tu32 i, count;\n\tchar *gfloc = NULL;\n\tchar gfloc_c=0;\n\tchar prefRegister[1001];\n\tchar szForceReg[20];\n\tBool reconfigurable_only;\n\n\tif (!fsess->max_resolve_chain_len) return NULL;\n\n\tfilter_chain = gf_list_new();\n\n\tif (!dst) return NULL;\n\n\treconfigurable_only = (reconfigurable_only_type==2) ? GF_TRUE : GF_FALSE;\n\n\tsprintf(szForceReg, \"gfreg%c\", pid->filter->session->sep_name);\n\tprefRegister[0]=0;\n\t//look for reg given in\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->dst_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->dst_args);\n\n\tgf_mx_p(fsess->links_mx);\n\tgf_filter_pid_resolve_link_dijkstra(pid, dst, prefRegister, reconfigurable_only, filter_chain);\n\tgf_mx_v(fsess->links_mx);\n\n\tcount = gf_list_count(filter_chain);\n\tif (min_chain_len) {\n\t\t*min_chain_len = count;\n\t} else if (count==0) {\n\t\tBool can_reassign = GF_TRUE;\n\n\t\t//reassign only for source filters\n\t\tif (pid->filter->num_input_pids) can_reassign = GF_FALSE;\n\t\t//sticky filters cannot be unloaded\n\t\telse if (pid->filter->sticky) can_reassign = GF_FALSE;\n\t\t//if we don't have pending PIDs to setup from the source\n\t\telse if (pid->filter->out_pid_connection_pending) can_reassign = GF_FALSE;\n\t\t//if we don't have pending PIDs to setup from the source\n\t\telse if (pid->filter->num_output_pids) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<pid->filter->num_output_pids; k++) {\n\t\t\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, k);\n\t\t\t\tif (apid->num_destinations) can_reassign = GF_FALSE;\n\t\t\t\telse if ((apid==pid) && (apid->init_task_pending>1)) can_reassign = GF_FALSE;\n\t\t\t\telse if ((apid!=pid) && apid->init_task_pending) can_reassign = GF_FALSE;\n\t\t\t\tif (!can_reassign)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if source filter, try to load another filter - we should complete this with a cache of filter sources\n\t\tif (filter_reassigned && can_reassign) {\n\t\t\tif (! *filter_reassigned) {\n\t\t\t\tif (! gf_filter_swap_source_register(pid->filter) ) {\n\t\t\t\t\t//no filter found for this pid !\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No suitable filter chain found\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Swap source demux to %s\\n\", pid->filter->freg->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*filter_reassigned = GF_TRUE;\n\t\t} else if (!reconfigurable_only) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No suitable filter found for pid %s from filter %s\\n\", pid->name, pid->filter->name));\n\t\t\tif (filter_reassigned)\n\t\t\t\t*filter_reassigned = GF_FALSE;\n\t\t}\n\t} else if (reconfigurable_only && (count>2)) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Cannot find filter chain with only one filter handling reconfigurable output for pid %s from filter %s - not supported\\n\", pid->name, pid->filter->name));\n\t} else {\n\t\tBool dst_is_sink = gf_filter_is_sink(dst);\n\t\tconst char *dst_args = NULL;\n\t\tconst char *args = pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args;\n\t\tGF_FilterPid *a_pid = pid;\n\t\tGF_Filter *prev_af;\n\n\t\tif (skip_if_in_filter_list) {\n\t\t\tassert(skipped);\n\t\t\t*skipped = GF_FALSE;\n\t\t\tu32 nb_skip = gf_list_count(skip_if_in_filter_list);\n\t\t\tconst GF_FilterRegister *chain_start_freg = gf_list_get(filter_chain, 0);\n\t\t\tfor (i=0; i<nb_skip; i++) {\n\t\t\t\tGF_Filter *f = gf_list_get(skip_if_in_filter_list, i);\n\t\t\t\tu32 j;\n\t\t\t\tGF_Filter *dest_f = NULL;\n\t\t\t\tBool true_skip = GF_FALSE;\n\n\t\t\t\tfor (j=0; j<gf_list_count(dst->destination_filters); j++) {\n\t\t\t\t\tdest_f = gf_list_get(dst->destination_filters, j);\n\t\t\t\t\tif ((gf_list_find(f->destination_filters, dest_f)>=0) || (gf_list_find(f->destination_links, dest_f)>=0)) {\n\t\t\t\t\t\ttrue_skip = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdest_f = NULL;\n\t\t\t\t}\n\n\t\t\t\tfor (j=0; j<gf_list_count(dst->destination_links) && !true_skip; j++) {\n\t\t\t\t\tdest_f = gf_list_get(dst->destination_links, j);\n\t\t\t\t\tif ((gf_list_find(f->destination_filters, dest_f)>=0) || (gf_list_find(f->destination_links, dest_f)>=0)) {\n\t\t\t\t\t\ttrue_skip = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdest_f = NULL;\n\t\t\t\t}\n\t\t\t\tif (true_skip) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Skip link from %s:%s to %s because both filters share the same destination %s\\n\", pid->filter->name, pid->name, dst->name, dest_f->name));\n\t\t\t\t\t*skipped = GF_TRUE;\n\t\t\t\t\tgf_list_del(filter_chain);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (f->freg == chain_start_freg) {\n\t\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\t\tif (gf_list_find(f->destination_links, dst)<0)\n\t\t\t\t\t\tgf_list_add(f->destination_links, dst);\n\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Skip link from %s:%s to %s because already connected to filter %s which can handle the connection\\n\", pid->filter->name, pid->name, dst->name, f->name));\n\n\t\t\t\t\t*skipped = GF_TRUE;\n\t\t\t\t\tgf_list_del(filter_chain);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdst_args = dst->src_args ? dst->src_args : dst->orig_args;\n\n\t\twhile (a_pid) {\n\t\t\tGF_FilterPidInst *pidi;\n\t\t\targs = a_pid->filter->src_args;\n\t\t\tif (!args) args = a_pid->filter->orig_args;\n\t\t\tif (args) break;\n\t\t\tgf_mx_p(a_pid->filter->tasks_mx);\n\t\t\tpidi = gf_list_get(a_pid->filter->input_pids, 0);\n\t\t\tgf_mx_v(a_pid->filter->tasks_mx);\n\t\t\tif (!pidi) break;\n\t\t\ta_pid = pidi->pid;\n\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_INFO)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Solved %sfilter chain from filter %s PID %s to filter %s - dumping chain:\\n\", reconfigurable_only_type ? \"adaptation \" : \"\", pid->filter->name, pid->name, dst->freg->name));\n\t\t}\n#endif\n\t\tchar szLocSep[8];\n\t\tsprintf(szLocSep, \"gfloc%c\", fsess->sep_args);\n\t\tgfloc = strstr(args, \"gfloc\");\n\t\tif (gfloc) {\n\t\t\tif ((gfloc>args) && (gfloc[-1]==fsess->sep_args))\n\t\t\t\tgfloc --;\n\n\t\t\tgfloc_c = gfloc[0];\n\t\t\tgfloc[0] = 0;\n\t\t}\n\t\tprev_af = NULL;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Filter *af;\n\t\t\tBool load_first_only = GF_FALSE;\n\t\t\ts32 cap_idx = -1;\n\t\t\tconst GF_FilterRegister *freg;\n\t\t\tconst GF_FilterCapability *cap = NULL;\n\t\t\tu32 k, cur_bundle, bundle_idx=0;\n\t\t\tif (i%2) continue;\n\t\t\tfreg = gf_list_get(filter_chain, i);\n\t\t\tcap = gf_list_get(filter_chain, i + 1);\n\t\t\t//get the cap bundle index - the cap added to the list is the cap with the same index as the bundle start we want\n\t\t\t//(this avoids allocating integers to store the bundle)\n\t\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\t\tif (&freg->caps[k]==cap) {\n\t\t\t\t\tbundle_idx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_bundle = 0;\n\t\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\t\tcap = &freg->caps[k];\n\t\t\t\tif (cur_bundle==bundle_idx) {\n\t\t\t\t\tcap_idx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t\t\tcur_bundle++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if first filter has multiple possible outputs, don't bother loading the entire chain since it is likely wrong\n\t\t\t//(eg demuxers, we don't know yet what's in the file)\n\t\t\tif (!i && gf_filter_out_caps_solved_by_connection(freg, bundle_idx)) {\n\t\t\t\tload_first_only = GF_TRUE;\n\t\t\t} else if (i) {\n\t\t\t\tBool break_chain = GF_FALSE;\n\t\t\t\tu32 j, nb_filters = gf_list_count(fsess->filters);\n\t\t\t\tfor (j=0; j<nb_filters; j++) {\n\t\t\t\t\tGF_Filter *afilter = gf_list_get(fsess->filters, j);\n\t\t\t\t\tif (afilter->freg != freg) continue;\n\t\t\t\t\tif (!afilter->dynamic_filter) continue;\n\t\t\t\t\tif (gf_list_find(pid->filter->destination_links, dst)<0) continue;\n\t\t\t\t\tif (!afilter->max_extra_pids) continue;\n\n\t\t\t\t\t//we load the same dynamic filter and it can accept multiple inputs (probably a mux), we might reuse this filter so stop link resolution now\n\t\t\t\t\t//not doing so would load e new mux filter which would accept the input pids but with potentially no possible output connections\n\t\t\t\t\tbreak_chain = GF_TRUE;\n\t\t\t\t\tif (prev_af) {\n\t\t\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\t\t\tif ( gf_list_find(pid->filter->destination_links, afilter)<0)\n\t\t\t\t\t\t\tgf_list_add(pid->filter->destination_links, afilter);\n\n\t\t\t\t\t\t//remember to which filter we are trying to connect for cap resolution\n\t\t\t\t\t\tprev_af->cap_dst_filter = dst;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (break_chain) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\t%s\\n\", freg->name));\n\n\t\t\taf = gf_filter_new(fsess, freg, args, dst_args, pid->filter->no_dst_arg_inherit ? GF_FILTER_ARG_INHERIT_SOURCE_ONLY : GF_FILTER_ARG_INHERIT, NULL, NULL, GF_TRUE);\n\t\t\tif (!af) goto exit;\n\t\t\taf->subsession_id = dst->subsession_id;\n\t\t\tif (dst->itag) af->itag = gf_strdup(dst->itag);\n\t\t\t\n\t\t\t//destination is sink, check if af is a mux (output cap type STREAM=FILE present)\n\t\t\t//if not, copy subsource_id from pid\n\t\t\tBool af_is_mux = GF_FALSE;\n\t\t\tif (dst_is_sink) {\n\t\t\t\tfor (u32 cidx=0; cidx<freg->nb_caps; cidx++) {\n\t\t\t\t\tconst GF_FilterCapability *a_cap = &freg->caps[cidx];\n\t\t\t\t\tif (!(a_cap->flags & GF_CAPFLAG_IN_BUNDLE)) continue;\n\t\t\t\t\tif (!(a_cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\t\t\tif (a_cap->flags & GF_CAPFLAG_EXCLUDED) continue;\n\t\t\t\t\tif (a_cap->code!=GF_PROP_PID_STREAM_TYPE) continue;\n\t\t\t\t\tif (a_cap->val.value.uint!=GF_STREAM_FILE) break;\n\t\t\t\t\taf_is_mux = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (af_is_mux)\n\t\t\t\taf->subsource_id = 0;\n\t\t\telse if (pid->filter->subsource_id)\n\t\t\t\taf->subsource_id = pid->filter->subsource_id;\n\t\t\t//if subsource not set, force to 1 (we know this af is not a mux)\n\t\t\telse\n\t\t\t\taf->subsource_id = 1;\n\n\t\t\tif (!af->forced_caps) {\n\t\t\t\t//remember our target cap bundle on that filter\n\t\t\t\taf->bundle_idx_at_resolution = bundle_idx;\n\t\t\t\t//remember our target cap on that filter\n\t\t\t\taf->cap_idx_at_resolution = cap_idx;\n\t\t\t}\n\t\t\tif (pid->require_source_id)\n\t\t\t\taf->require_source_id = GF_TRUE;\n\t\t\t\n\t\t\t//copy source IDs for all filters in the chain\n\t\t\t//we cannot figure out the destination sourceID when initializing PID connection tasks\n\t\t\t//by walking up the filter chain because PIDs connection might be pending\n\t\t\t//(upper chain not yet fully connected)\n\t\t\t//if the source had a restricted source_id set, use it, otherwise use the destination source_id\n\t\t\tif (!prev_af && pid->filter->restricted_source_id)\n\t\t\t\taf->source_ids = gf_strdup(pid->filter->restricted_source_id);\n\t\t\telse if (prev_af && prev_af->source_ids)\n\t\t\t\taf->source_ids = gf_strdup(prev_af->source_ids);\n\t\t\telse if (dst->source_ids)\n\t\t\t\taf->source_ids = gf_strdup(dst->source_ids);\n\n\t\t\t//remember our target filter\n\t\t\tif (prev_af)\n\t\t\t\tgf_list_add(prev_af->destination_filters, af);\n\n\t\t\t//last in chain, add dst\n\t\t\tif (i+2==count) {\n\t\t\t\tgf_list_add(af->destination_filters, dst);\n\t\t\t}\n\t\t\t//we will load several filters in chain, add destination to each of the loaded filter so that we remember what was this filter target\n\t\t\t//this avoids browing the chain of filters->destination_filters when doing link resolution\n\t\t\telse if (!load_first_only) {\n\t\t\t\tgf_list_add(af->destination_filters, dst);\n\t\t\t}\n\n\t\t\t//also remember our original target in case we got the link wrong\n\t\t\taf->target_filter = pid->filter->target_filter;\n\n\t\t\tprev_af = af;\n\n\t\t\tif (reconfigurable_only_type) af->is_pid_adaptation_filter = GF_TRUE;\n\n\t\t\t//remember the first in the chain\n\t\t\tif (!i) chain_input = af;\n\n\t\t\tif (load_first_only) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s needs to be connected to decide its outputs, not loading end of the chain\\n\", freg->name));\n\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\tif ( gf_list_find(pid->filter->destination_links, dst)<0)\n\t\t\t\t\tgf_list_add(pid->filter->destination_links, dst);\n\n\t\t\t\t//in case we added it, remove the destination filter\n\t\t\t\tgf_list_del_item(af->destination_filters, dst);\n\n\t\t\t\t//remember to which filter we are trying to connect for cap resolution\n\t\t\t\taf->cap_dst_filter = dst;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (gfloc) gfloc[0] = gfloc_c;\n\n\tgf_list_del(filter_chain);\n\treturn chain_input;\n}\n\nGF_Filter *gf_filter_pid_resolve_link(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, filter_reassigned, 0, NULL, NULL, NULL);\n}\n\nGF_Filter *gf_filter_pid_resolve_link_check_loaded(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned, GF_List *skip_if_in_filter_list, Bool *skipped)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, filter_reassigned, 0, NULL, skip_if_in_filter_list, skipped);\n}\n\nGF_Filter *gf_filter_pid_resolve_link_for_caps(GF_FilterPid *pid, GF_Filter *dst, Bool check_reconfig_only)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, NULL, check_reconfig_only ? 2 : 1, NULL, NULL, NULL);\n}\n\nu32 gf_filter_pid_resolve_link_length(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tu32 chain_len=0;\n\tgf_filter_pid_resolve_link_internal(pid, dst, NULL, 0, &chain_len, NULL, NULL);\n\treturn chain_len;\n}\n\n\nGF_List *gf_filter_pid_compute_link(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tGF_FilterSession *fsess = pid->filter->session;\n\tGF_List *filter_chain;\n\tchar prefRegister[1001];\n\tchar szForceReg[20];\n\n\tif (!fsess->max_resolve_chain_len) return NULL;\n\tif (!dst) return NULL;\n\n\tfilter_chain = gf_list_new();\n\n\ts32 dst_bundle_idx=-1;\n\tif (gf_filter_pid_caps_match(pid, dst->freg, dst, NULL, &dst_bundle_idx, pid->filter->dst_filter, -1)) {\n\t\tgf_list_add(filter_chain, (void*)dst->freg);\n\t\tif ((dst_bundle_idx<0) || ((u32) dst_bundle_idx>=dst->freg->nb_caps))\n\t\t\tdst_bundle_idx=0;\n\n\t\tgf_list_add(filter_chain, (void*)&dst->freg->caps[dst_bundle_idx]);\n\t\treturn filter_chain;\n\t}\n\n\tsprintf(szForceReg, \"gfreg%c\", pid->filter->session->sep_name);\n\tprefRegister[0]=0;\n\t//look for reg given in\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->dst_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->dst_args);\n\n\tgf_mx_p(fsess->links_mx);\n\tgf_filter_pid_resolve_link_dijkstra(pid, dst, prefRegister, GF_FALSE, filter_chain);\n\tgf_mx_v(fsess->links_mx);\n\tif (!gf_list_count(filter_chain)) {\n\t\tgf_list_del(filter_chain);\n\t\treturn NULL;\n\t}\n\tgf_list_add(filter_chain, (void *)dst->freg);\n\tif (dst->freg->nb_caps)\n\t\tgf_list_add(filter_chain, (void*)&dst->freg->caps[0]);\n\treturn filter_chain;\n}\n\n\nstatic void gf_filter_pid_set_args_internal(GF_Filter *filter, GF_FilterPid *pid, char *args, Bool use_default_seps, u32 argfile_level)\n{\n\tchar sep_args, sep_frag, sep_name, sep_list;\n\n\tif (use_default_seps) {\n\t\tsep_args = ':';\n\t\tsep_frag = '#';\n\t\tsep_name = '=';\n\t\tsep_list = ',';\n\t} else {\n\t\tsep_args = filter->session->sep_args;\n\t\tsep_frag = filter->session->sep_frag;\n\t\tsep_name = filter->session->sep_name;\n\t\tsep_list = filter->session->sep_list;\n\t}\n\n\t//parse each arg\n\twhile (args) {\n\t\tu32 p4cc=0;\n\t\tu32 prop_type=GF_PROP_FORBIDEN;\n\t\tBool parse_prop = GF_TRUE;\n\t\tchar *value_next_list = NULL;\n\t\tchar *value_sep = NULL;\n\t\tchar *value, *name, *sep;\n\n\t\t//escaped arg separator, skip everything until next escape sep or end\n\t\tif (args[0] == sep_args) {\n\t\t\tchar szEscape[3];\n\t\t\tszEscape[0] = szEscape[1] = sep_args;\n\t\t\tszEscape[2] = 0;\n\t\t\targs++;\n\t\t\tsep = strstr(args, szEscape);\n\t\t} else {\n\t\t\tif (sep_args == ':') {\n\t\t\t\tsep = (char *)gf_fs_path_escape_colon(filter->session, args);\n\t\t\t} else {\n\t\t\t\tsep = strchr(args, sep_args);\n\t\t\t}\n\t\t}\n\t\tif (sep) {\n\t\t\tchar *xml_start = strchr(args, '<');\n\t\t\tif (xml_start && (xml_start<sep)) {\n\t\t\t\tchar szEnd[3];\n\t\t\t\tszEnd[0] = '>';\n\t\t\t\tszEnd[1] = filter->session->sep_args;\n\t\t\t\tszEnd[2] = 0;\n\t\t\t\tchar *xml_end = strstr(xml_start, szEnd);\n\t\t\t\tif (!xml_end) {\n\t\t\t\t\tsep = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsep = xml_end+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sep) sep[0]=0;\n\n\t\tif (args[0] != sep_frag) {\n\t\t\t//if arg is not one of our reserved keywords and is a valid file, try to open it\n\t\t\tif (strcmp(args, \"gpac\") && strcmp(args, \"gfopt\") && strcmp(args, \"gfloc\") && gf_file_exists(args)) {\n\t\t\t\tif (argfile_level<5) {\n\t\t\t\t\tchar szLine[2001];\n\t\t\t\t\tFILE *arg_file = gf_fopen(args, \"rt\");\n\t\t\t\t\tszLine[2000]=0;\n\t\t\t\t\twhile (!gf_feof(arg_file)) {\n\t\t\t\t\t\tu32 llen;\n\t\t\t\t\t\tchar *subarg, *res;\n\t\t\t\t\t\tszLine[0] = 0;\n\t\t\t\t\t\tres = gf_fgets(szLine, 2000, arg_file);\n\t\t\t\t\t\tif (!res) break;\n\t\t\t\t\t\tllen = (u32) strlen(szLine);\n\t\t\t\t\t\twhile (llen && strchr(\" \\n\\r\\t\", szLine[llen-1])) {\n\t\t\t\t\t\t\tszLine[llen-1]=0;\n\t\t\t\t\t\t\tllen--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!llen)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tsubarg = szLine;\n\t\t\t\t\t\twhile (subarg[0] && strchr(\" \\n\\r\\t\", subarg[0]))\n\t\t\t\t\t\t\tsubarg++;\n\t\t\t\t\t\tif ((subarg[0] == '/') && (subarg[1] == '/'))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tgf_filter_pid_set_args_internal(filter, pid, subarg, use_default_seps, argfile_level+1);\n\t\t\t\t\t}\n\t\t\t\t\tgf_fclose(arg_file);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter argument file has too many nested levels of sub-files, maximum allowed is 5\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto skip_arg;\n\t\t}\n\n\t\tvalue = NULL;\n\t\tvalue_sep = strchr(args, sep_name);\n\t\tif (value_sep) {\n\t\t\tvalue_sep[0]=0;\n\t\t\tvalue = value_sep+1;\n\t\t}\n\t\tname = args+1;\n\n\t\tif (strlen(name)==4) {\n\t\t\tp4cc = GF_4CC(name[0], name[1], name[2], name[3]);\n\t\t\tif (p4cc) prop_type = gf_props_4cc_get_type(p4cc);\n\t\t}\n\t\tif (prop_type==GF_PROP_FORBIDEN) {\n\t\t\tp4cc = gf_props_get_id(name);\n\t\t\tif (p4cc) prop_type = gf_props_4cc_get_type(p4cc);\n\t\t}\n\n\t\t//look for conditional statements: \"(PROP=VAL)VALUE\"\n\t\twhile (value && (value[0]=='(')) {\n\t\t\tBool pid_excluded, needs_resolve, prop_not_found, prop_matched;\n\t\t\tchar prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];\n\n\t\t\tchar *next_val = NULL;\n\t\t\tchar *closing = strchr(value, ')');\n\t\t\tif (!closing) break;\n\n\t\t\tif (!strncmp(value, \"()\", 2)) {\n\t\t\t\tvalue = closing+1;\n\t\t\t\tparse_prop = GF_TRUE;\n\t\t\t\tvalue_next_list = next_val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparse_prop = GF_FALSE;\n\n\t\t\tnext_val = strchr(closing, sep_list);\n\t\t\tif (next_val) next_val[0] = 0;\n\n\t\t\twhile (closing) {\n\t\t\t\tchar *next_closing;\n\t\t\t\tclosing[0] = 0;\n\t\t\t\tprop_matched = filter_pid_check_fragment(pid, value+1, &pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer);\n\t\t\t\tif (prop_not_found) prop_matched = GF_FALSE;\n\t\t\t\tclosing[0] = ')';\n\n\t\t\t\tif (!prop_matched)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strncmp(closing, \")(\", 2)) break;\n\t\t\t\tnext_closing = strchr(closing+2, ')');\n\t\t\t\tif (!next_closing) break;\n\n\t\t\t\tvalue = closing+1;\n\t\t\t\tclosing = next_closing;\n\t\t\t}\n\n\t\t\tif (prop_matched) {\n\t\t\t\tvalue = closing+1;\n\t\t\t\tparse_prop = GF_TRUE;\n\t\t\t\tvalue_next_list = next_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!next_val) break;\n\t\t\tnext_val[0] = sep_list;\n\t\t\tvalue = next_val+1;\n\t\t}\n\n\t\tif (!parse_prop)\n\t\t\tgoto skip_arg;\n\n\n\t\tif (prop_type != GF_PROP_FORBIDEN) {\n\t\t\tGF_PropertyValue p;\n\t\t\tp.type = GF_PROP_FORBIDEN;\n\n\t\t\t//specific parsing for clli: it's a data prop but we allow textual specifiers\n\t\t\tif ((p4cc == GF_PROP_PID_CONTENT_LIGHT_LEVEL) && strchr(value, sep_list) ){\n\t\t\t\tGF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);\n\t\t\t\tif ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==2))  {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);\n\t\t\t\t\tgf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);\n\t\t\t\t\tp.type = GF_PROP_DATA;\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_props_reset_single(&a_p);\n\t\t\t}\n\t\t\t//specific parsing for mdcv: it's a data prop but we allow textual specifiers\n\t\t\telse if ((p4cc == GF_PROP_PID_MASTER_DISPLAY_COLOUR) && strchr(value, sep_list) ) {\n\t\t\t\tGF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);\n\t\t\t\tif ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==10))  {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[2]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[3]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[4]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[5]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[6]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[7]);\n\t\t\t\t\tgf_bs_write_u32(bs, a_p.value.uint_list.vals[8]);\n\t\t\t\t\tgf_bs_write_u32(bs, a_p.value.uint_list.vals[9]);\n\t\t\t\t\tgf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);\n\t\t\t\t\tp.type = GF_PROP_DATA;\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_props_reset_single(&a_p);\n\t\t\t}\n\t\t\t//parse codecID\n\t\t\telse if (p4cc == GF_PROP_PID_CODECID) {\n\t\t\t\t//only for explicit filters\n\t\t\t\tif (filter->dynamic_filter) goto skip_arg;\n\t\t\t\tu32 cid = gf_codecid_parse(value);\n\t\t\t\tif (cid) {\n\t\t\t\t\tp.type = GF_PROP_UINT;\n\t\t\t\t\tp.value.uint = cid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//parse streamtype\n\t\t\telse if (p4cc == GF_PROP_PID_STREAM_TYPE) {\n\t\t\t\t//only for explicit filters\n\t\t\t\tif (filter->dynamic_filter) goto skip_arg;\n\t\t\t\tu32 st = gf_stream_type_by_name(value);\n\t\t\t\tif (st!=GF_STREAM_UNKNOWN) {\n\t\t\t\t\tp.type = GF_PROP_UINT;\n\t\t\t\t\tp.value.uint = st;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//pix formats and others are parsed as specific prop types\n\n\t\t\tif (p.type == GF_PROP_FORBIDEN) {\n\t\t\t\tp = gf_props_parse_value(prop_type, name, value, NULL, sep_list);\n\t\t\t}\n\n\t\t\tif (p.type != GF_PROP_FORBIDEN) {\n\t\t\t\tif (prop_type==GF_PROP_NAME) {\n\t\t\t\t\tp.type = GF_PROP_STRING;\n\t\t\t\t\tgf_filter_pid_set_property(pid, p4cc, &p);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(pid, p4cc, &p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((p4cc==GF_PROP_PID_TEMPLATE) && p.value.string) {\n\t\t\t\tif (strstr(p.value.string, \"$Bandwidth$\")) {\n\t\t\t\t\tgf_opts_set_key(\"temp\", \"force_indexing\", \"true\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prop_type==GF_PROP_STRING_LIST) {\n\t\t\t\tp.value.string_list.vals = NULL;\n\t\t\t\tp.value.string_list.nb_items = 0;\n\t\t\t}\n\t\t\t//use uint_list as base type for lists\n\t\t\telse if ((prop_type==GF_PROP_UINT_LIST) || (prop_type==GF_PROP_SINT_LIST) || (prop_type==GF_PROP_VEC2I_LIST) || (prop_type==GF_PROP_4CC_LIST)) {\n\t\t\t\tp.value.uint_list.vals = NULL;\n\t\t\t}\n\t\t\tgf_props_reset_single(&p);\n\t\t} else if (value) {\n\t\t\tBool reset_prop=GF_FALSE;\n\t\t\tGF_PropertyValue p;\n\t\t\tif (!strncmp(value, \"bxml@\", 5)) {\n\t\t\t\tp = gf_props_parse_value(GF_PROP_DATA_NO_COPY, name, value, NULL, sep_list);\n\t\t\t} else if (!strncmp(value, \"file@\", 5)) {\n\t\t\t\tp = gf_props_parse_value(GF_PROP_STRING, name, value, NULL, sep_list);\n\t\t\t\tp.type = GF_PROP_STRING_NO_COPY;\n\t\t\t} else {\n\t\t\t\tu32 ptype = GF_PROP_FORBIDEN;\n\t\t\t\tchar *type_sep = strchr(value, '@');\n\t\t\t\tif (type_sep) {\n\t\t\t\t\ttype_sep[0] = 0;\n\t\t\t\t\tptype = gf_props_parse_type(value);\n\t\t\t\t\tif (ptype==GF_PROP_FORBIDEN) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Unrecognized property type %s, defaulting to string\\n\", value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = type_sep+1;\n\t\t\t\t\t}\n\t\t\t\t\ttype_sep[0] = '@';\n\t\t\t\t}\n\t\t\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\t\t\tif (ptype == GF_PROP_FORBIDEN) {\n\t\t\t\t\tp.type = GF_PROP_STRING;\n\t\t\t\t\tp.value.string = value;\n\t\t\t\t} else {\n\t\t\t\t\tp = gf_props_parse_value(ptype, name, value, NULL, sep_list);\n\t\t\t\t\treset_prop = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pid_set_property_dyn(pid, name, &p);\n\t\t\tif (reset_prop) gf_props_reset_single(&p);\n\t\t}\n\t\tif (value_next_list)\n\t\t\tvalue_next_list[0] = sep_list;\n\nskip_arg:\n\t\tif (value_sep)\n\t\t\tvalue_sep[0] = sep_name;\n\n\t\tif (sep) {\n\t\t\tsep[0] = sep_args;\n\t\t\targs=sep+1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_push_properties(GF_FilterPid *pid, char *args, Bool direct_merge, Bool use_default_seps)\n{\n\tif (!args) return GF_OK;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to write property on input PID in filter %s - ignoring\\n\", pid->filter->name ? pid->filter->name : pid->filter->freg->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//pid props specified by user are merged directly\n\tif (direct_merge) {\n\t\tBool req_map_bck = pid->request_property_map;\n\t\tpid->request_property_map = GF_FALSE;\n\t\tgf_filter_pid_set_args_internal(pid->filter, pid, args, use_default_seps, 0);\n\t\tpid->request_property_map = req_map_bck;\n\t} else {\n\t\tgf_filter_pid_set_args_internal(pid->filter, pid, args, use_default_seps, 0);\n\t}\n\treturn GF_OK;\n}\n\nvoid gf_filter_pid_set_args(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tBool req_map_bck;\n\tchar *args;\n\tif (!filter->src_args && !filter->orig_args) return;\n\targs = filter->orig_args ? filter->orig_args : filter->src_args;\n\n\t//pid props specified by user are merged directly\n\treq_map_bck = pid->request_property_map;\n\tpid->request_property_map = GF_FALSE;\n\tgf_filter_pid_set_args_internal(filter, pid, args, GF_FALSE, 0);\n\tpid->request_property_map = req_map_bck;\n}\n\nstatic const char *gf_filter_last_id_in_chain(GF_Filter *filter, Bool ignore_first)\n{\n\tu32 i;\n\tconst char *id;\n\tif (!ignore_first) {\n\t\tif (filter->id) return filter->id;\n\t\tif (!filter->dynamic_filter) return NULL;\n\t}\n\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif (pidi->pid->filter->id) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn pidi->pid->filter->id;\n\t\t}\n\t\t//stop at first non dyn filter\n\t\tif (!pidi->pid->filter->dynamic_filter) continue;\n\t\tid = gf_filter_last_id_in_chain(pidi->pid->filter, GF_FALSE);\n\t\tif (id) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn id;\n\t\t}\n\t\t//single source filter, no need to browse remaining pids\n\t\tif (pidi->pid->filter->single_source)\n\t\t\tbreak;\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn NULL;\n}\n\nvoid gf_filter_pid_retry_caps_negotiate(GF_FilterPid *src_pid, GF_FilterPid *pid, GF_Filter *dst_filter)\n{\n\tassert(dst_filter);\n\tsrc_pid->caps_negociate = pid->caps_negociate;\n\tpid->caps_negociate = NULL;\n\tsrc_pid->caps_dst_filter = dst_filter;\n\t//blacklist filter for adaptation\n\tif (!src_pid->adapters_blacklist) src_pid->adapters_blacklist = gf_list_new();\n\tgf_list_add(src_pid->adapters_blacklist, (void *) pid->filter->freg);\n\t//once != 0 will trigger reconfiguration, so set this once all vars have been set\n\tsafe_int_inc(& src_pid->filter->nb_caps_renegociate );\n\n\t//disconnect source pid from filter - this will unload the filter itself\n\tgf_fs_post_task(src_pid->filter->session, gf_filter_pid_disconnect_task, pid->filter, src_pid, \"pidinst_disconnect\", NULL);\n}\n\n\nstatic Bool gf_filter_pid_needs_explicit_resolution(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tu32 i;\n\tconst GF_FilterCapability *caps;\n\tu32 nb_caps;\n\tBool dst_has_raw_cid_in = GF_FALSE;\n\tconst GF_PropertyValue *stream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (!stream_type) return GF_TRUE;\n\n\tif (stream_type->value.uint==GF_STREAM_FILE) return GF_FALSE;\n\tif (stream_type->value.uint==GF_STREAM_ENCRYPTED) {\n\t\tstream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\tif (!stream_type) return GF_TRUE;\n\t}\n\n\tcaps = dst->forced_caps ? dst->forced_caps : dst->freg->caps;\n\tnb_caps = dst->forced_caps ? dst->nb_forced_caps : dst->freg->nb_caps;\n\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\n\t\tif (cap->code != GF_PROP_PID_CODECID) continue;\n\t\tif (cap->val.value.uint==GF_CODECID_RAW)\n\t\t\tdst_has_raw_cid_in = GF_TRUE;\n\t}\n\n\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\n\t\tif (cap->code != GF_PROP_PID_STREAM_TYPE) continue;\n\t\t//output type is file or same media type, allow looking for filter chains\n\t\tif ((cap->val.value.uint==GF_STREAM_FILE) || (cap->val.value.uint==stream_type->value.uint)) return GF_FALSE;\n\t\t//allow text|scene|video -> raw video for dynamic compositor\n\t\tif (dst_has_raw_cid_in  && (cap->val.value.uint==GF_STREAM_VISUAL)) {\n\t\t\tswitch (stream_type->value.uint) {\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\treturn GF_FALSE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//no mathing type found, we will need an explicit filter to solve this link (ie the link will be to the explicit filter)\n\treturn GF_TRUE;\n}\n\nstatic void add_possible_link_destination(GF_List *possible_linked_resolutions, GF_Filter *filter_dst)\n{\n\tu32 i;\n\n\tfor (i=0; i<gf_list_count(possible_linked_resolutions); i++) {\n\t\tGF_Filter *parent = gf_list_get(possible_linked_resolutions, i);\n\t\tif (parent->max_extra_pids) continue;\n\n\t\tif ((gf_list_find(filter_dst->destination_links, parent)>=0) || (gf_list_find(filter_dst->destination_filters, parent)>=0)) {\n\t\t\tgf_list_rem(possible_linked_resolutions, i);\n\t\t\tgf_list_insert(possible_linked_resolutions, filter_dst, i);\n\t\t\treturn;\n\t\t}\n\t\tif ((gf_list_find(parent->destination_links, filter_dst)>=0) || (gf_list_find(parent->destination_filters, filter_dst)>=0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(possible_linked_resolutions, filter_dst);\n}\n\n#if 0\nstatic void dump_pid_props(GF_FilterPid *pid)\n{\n\tu32 idx = 0;\n\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\tconst GF_PropertyEntry *p;\n\tGF_PropertyMap *pmap = gf_list_get(pid->properties, 0);\n\twhile (pmap && (p = gf_list_enum(pmap->properties, &idx))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Pid prop %s: %s\\n\", gf_props_4cc_get_name(p->p4cc), gf_props_dump(p->p4cc, &p->prop, szDump, GF_PROP_DUMP_DATA_NONE) ));\n\t}\n}\n#endif\n\nstatic Bool gf_pid_in_parent_chain(GF_FilterPid *pid, GF_FilterPid *look_for_pid)\n{\n\tu32 i, ret=GF_FALSE;\n\tif (pid == look_for_pid) return GF_TRUE;\n\t//browse all parent PIDs\n\t//stop checking at the first explicit filter with ID\n\tif (!pid->filter->dynamic_filter && pid->filter->id) return GF_FALSE;\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (gf_pid_in_parent_chain(pidi->pid, look_for_pid)) {\n\t\t\tret = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\t//single source filter, no need to look further\n\t\tif (pidi->pid->filter->single_source)\n\t\t\tbreak;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn ret;\n}\n\nstatic Bool filter_match_target_dst(GF_List *flist, GF_Filter *dst)\n{\n\tu32 i, count=gf_list_count(flist);\n\tfor (i=0;i<count;i++) {\n\t\tGF_Filter *f = gf_list_get(flist, i);\n\t\tif (f==dst) return GF_TRUE;\n\t\tif (filter_match_target_dst(f->destination_filters, dst))\n\t\t\treturn GF_TRUE;\n\t\tif (filter_match_target_dst(f->destination_links, dst))\n\t\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic Bool parent_chain_has_dyn_pids(GF_Filter *filter)\n{\n\tu32 i;\n\tif (filter->freg->flags & GF_FS_REG_DYNAMIC_PIDS) return GF_TRUE;\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif (parent_chain_has_dyn_pids(pidi->pid->filter)) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nstatic void gf_filter_pid_init_task(GF_FSTask *task)\n{\n\tu32 f_idx, count;\n\tBool found_dest=GF_FALSE;\n\tBool found_matching_sourceid;\n\tBool can_reassign_filter = GF_FALSE;\n\tBool can_try_link_resolution=GF_FALSE;\n\tBool link_sinks_only = GF_FALSE;\n\tBool implicit_link_found = GF_FALSE;\n\tu32 num_pass=0;\n\tGF_List *loaded_filters = NULL;\n\tGF_List *linked_dest_filters = NULL;\n    GF_List *force_link_resolutions = NULL;\n    GF_List *possible_linked_resolutions = NULL;\n\tGF_Filter *filter = task->filter;\n\tGF_FilterPid *pid = task->pid;\n\tGF_Filter *dynamic_filter_clone = NULL;\n\tBool filter_found_but_pid_excluded = GF_FALSE;\n\tBool possible_link_found_implicit_mode = GF_FALSE;\n\tu32 pid_is_file = 0;\n\tconst char *filter_id;\n\n\tif (pid->destroyed || pid->removed) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\treturn;\n\t}\n\tpid->props_changed_since_connect = GF_FALSE;\n\n\t//swap pid is pending on the possible destination filter\n\tif (filter->swap_pidinst_src || filter->swap_pidinst_dst) {\n\t\ttask->requeue_request = GF_TRUE;\n\t\ttask->can_swap = 1;\n\t\treturn;\n\t}\n\tif (filter->caps_negociate) {\n\t\tif (! gf_filter_reconf_output(filter, pid))\n\t\t\treturn;\n\t}\n\n\tgf_fs_check_graph_load(filter->session, GF_TRUE);\n\n\tif (filter->user_pid_props)\n\t\tgf_filter_pid_set_args(filter, pid);\n\n\t//explicit source, check if demux is forcd\n\tif (!pid->filter->dynamic_filter\n\t\t&& !pid->filter->num_input_pids\n\t\t&& (pid->filter->freg->flags & GF_FS_REG_FORCE_REMUX)\n\t) {\n\t\tconst GF_PropertyValue *st = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (st && (st->value.uint==GF_STREAM_FILE))\n\t\t\tpid_is_file = 1;\n\t}\n\n\t//get filter ID:\n\t//this is a source - since we may have inserted filters in the middle (demuxers typically), get the last explicitly loaded ID in the chain\n\tif (filter->subsource_id) {\n\t\tfilter_id = gf_filter_last_id_in_chain(filter, GF_FALSE);\n\t\tif (!filter_id && filter->cloned_from)\n\t\t\tfilter_id = gf_filter_last_id_in_chain(filter->cloned_from, GF_FALSE);\n\t}\n\t//this is a sink or a mux - only use ID if defined on filter whether explicitly loaded or not ( some filters e.g. dasher,flist will self-assign an ID)\n\telse {\n\t\t//if clone use ID from clone otherwise linking will likely fail\n\t\tfilter_id = filter->cloned_from ? filter->cloned_from->id : filter->id;\n\t}\n\n\t//we lock the instantiated filter list for the entire resolution process\n\t//we must unlock this mutex before calling lock on a filter mutex (->tasks_mx)\n\t//either directly or in functions calling it (e.g. gf_filter_in_parent_chain)\n\t//in case another thread is reconfiguring a filter fA:\n\t//- fA would have tasks_mx locked, and could be waiting for session->filters_mx to insert a new filter (inserting a filter chain)\n\t//- trying to lock fA->tasks_mx would then deadlock\n\t//cf issue 1799\n\tgf_mx_p(filter->session->filters_mx);\n\n\tlinked_dest_filters = gf_list_new();\n\tforce_link_resolutions = gf_list_new();\n    possible_linked_resolutions = gf_list_new();\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s:%s init\\n\", pid->filter->name, pid->name));\n\n\t//we use at max 3 passes:\n\t//pass 1: try direct connections without loading intermediate filter chains. If PID gets connected, skip other passes\n\t//pass 2: try loading intermediate filter chains, but disable filter register swapping. If PID gets connected, skip last\n\t//pass 3: try loading intermediate filter chains, potentially swapping the source register\nrestart:\n\n\tif (num_pass) {\n\n\t\t//we're about to load filters to solve the link, use the already linked destination filters as list of loaded filters.\n\t\t//Not doing so may lead to loading several instances of the same filter for cases like:\n\t\t//-i encrypted aout vout\n\t\t//the first pid init (src->aout/vout) will load a demux, registering aout and vout as destination of demux\n\t\t//the second pid init (demux.Audio -> aout) will load cdcrypt, remove aout from demux destinations\n\t\t//the third pid init (demux.video) will\n\t\t//- match cdcrypt and link to it, but will not remove vout from demux destinations, resulting in further linking (this pass)\n\t\t//- create a new cdcrypt to solve demux.video -> vout\n\t\t\n//\t\tloaded_filters = gf_list_new();\n\t\tloaded_filters = gf_list_clone(linked_dest_filters);\n\t}\n\n\tfound_matching_sourceid = GF_FALSE;\n\n\t//relock the filter list.\n\t//If the filter_dst we were checking is no longer present, rewind and go on\n\t//otherwise update its index (might be less if some filters were removed)\n#define RELOCK_FILTER_LIST\\\n\t\tgf_mx_p(filter->session->filters_mx); \\\n\t\tcount = gf_list_count(filter->session->filters); \\\n\t\tf_dst_idx = gf_list_find(filter->session->filters, filter_dst); \\\n\t\tif (f_dst_idx < 0) {\\\n\t\t\tf_idx--;\\\n\t\t} else {\\\n\t\t\tf_idx = f_dst_idx;\\\n\t\t}\n\n\n\t//try to connect pid to all running filters\n\tcount = gf_list_count(filter->session->filters);\n\tfor (f_idx=0; f_idx<count; f_idx++) {\n\t\ts32 f_dst_idx;\n\t\tBool needs_clone;\n\t\tBool cap_matched, in_parent_chain, is_sink;\n\t\tBool ignore_source_ids;\n\t\tBool use_explicit_link;\n\t\tGF_Filter *filter_dst;\n\nsingle_retry:\n\n\t\tignore_source_ids = GF_FALSE;\n\t\tuse_explicit_link = GF_FALSE;\n\t\tfilter_dst = gf_list_get(filter->session->filters, f_idx);\n\t\t//this can happen in multithreaded cases with filters being removed while we check for links\n\t\tif (!filter_dst)\n\t\t\tbreak;\n\t\t//source filter\n\t\tif (!filter_dst->freg->configure_pid) continue;\n\t\tif (filter_dst->finalized || filter_dst->removed || filter_dst->disabled || filter_dst->marked_for_removal || filter_dst->no_inputs) continue;\n\t\tif (filter_dst->target_filter == pid->filter) continue;\n\n\t\t//handle re-entrant filter registries (eg filter foo of type A output usually cannot connect to filter bar of type A)\n\t\tif (pid->pid->filter->freg == filter_dst->freg) {\n\t\t\t//only allowed for:\n\t\t\tif (\n\t\t\t\t// explicitly loaded filters\n\t\t\t\tfilter->dynamic_filter\n\t\t\t\t//if cyclic explictly allowed by filter registry or if script or custom filter\n\t\t\t\t|| !(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tis_sink = GF_FALSE;\n\t\tif (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) {\n\t\t\tif (filter_dst->dynamic_filter) {\n\t\t\t\tif (!filter_dst->subsource_id) {\n\t\t\t\t\tis_sink = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (filter_dst->forced_caps) {\n\t\t\t\tis_sink = !gf_filter_has_out_caps(filter_dst->forced_caps, filter_dst->nb_forced_caps);\n\t\t\t} else {\n\t\t\t\tis_sink = !gf_filter_has_out_caps(filter_dst->freg->caps, filter_dst->freg->nb_caps);\n\t\t\t}\n\t\t}\n\n\t\t//we linked to a sink in implicit mode and new filter is not a sink, continue\n\t\tif (link_sinks_only && !is_sink) continue;\n\t\t//we linked to a non-sink filter in implicit mode and the destination has no sourceID, continue\n\t\tif (implicit_link_found && !filter_dst->source_ids) {\n\t\t\t//destination not a sink, do not connect\n\t\t\tif (!is_sink) continue;\n\t\t\t//destination is a sink, do not connect if destination is not already registered as target for our filter\n\t\t\t//we need to check this for case such as\n\t\t\t//rtpin(avc) -> avc\n\t\t\t//           -> ts\n\t\t\t//which will invoke the AVC unframer/rewriter (ufnalu) only once and then try to link it to both TS mux and fout\n\t\t\tif ((gf_list_find(filter->destination_filters, filter_dst)<0)\n\t\t\t\t&& (gf_list_find(filter->destination_links, filter_dst)<0)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//check we are not already connected to this filter - we need this in case destination links/filters lists are reset\n\t\tif (pid->num_destinations) {\n\t\t\tu32 j;\n\t\t\tBool already_linked = GF_FALSE;\n\t\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\t\tif (pidi->filter == filter_dst) {\n\t\t\t\t\talready_linked=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (already_linked) continue;\n\t\t}\n\n\t\t//we already linked to this one\n\t\tif (gf_list_find(linked_dest_filters, filter_dst)>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s already linked to filter %s\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\tif (gf_list_count(pid->filter->destination_filters)) {\n\t\t\ts32 ours = gf_list_find(pid->filter->destination_filters, filter_dst);\n\t\t\tif (ours<0) {\n\t\t\t\tours = num_pass ? gf_list_del_item(pid->filter->destination_links, filter_dst) : -1;\n\t\t\t\tif (!filter_dst->source_ids && (ours<0)) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has destination filters, filter %s not one of them\\n\", pid->name, filter_dst->name));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t} else {\n\t\t\t\tfilter_dst->in_link_resolution = 0;\n\t\t\t\tpid->filter->dst_filter = filter_dst;\n\t\t\t\t//for mux->output case, the filter ID may be NULL but we still want to link\n\t\t\t\tif (!num_pass && !filter->subsource_id)\n\t\t\t\t\tignore_source_ids = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (num_pass && gf_list_count(filter->destination_links)) {\n\t\t\ts32 ours = gf_list_find(pid->filter->destination_links, filter_dst);\n\t\t\tif (ours<0) {\n\t\t\t\tours = gf_list_find(possible_linked_resolutions, filter_dst);\n\t\t\t\tif (ours<0) {\n\t\t\t\t\tours = gf_list_find(force_link_resolutions, filter_dst);\n\t\t\t\t}\n\t\t\t\tif (ours<0) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has destination links, filter %s not one of them\\n\", pid->name, filter_dst->name));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpid->filter->dst_filter = NULL;\n\t\t}\n\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\tif (gf_list_count(filter_dst->source_filters)) {\n\t\t\tu32 j, count2 = gf_list_count(filter_dst->source_filters);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tBool in_par;\n\t\t\t\tGF_Filter *srcf = gf_list_get(filter_dst->source_filters, j);\n\t\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\t\t\tin_par = gf_filter_in_parent_chain(pid->filter, srcf);\n\t\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t\tif (in_par) {\n\t\t\t\t\tignore_source_ids = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\tRELOCK_FILTER_LIST\n\n\t\t//if destination accepts only one input and connected or connection pending\n\t\t//note that if destination uses dynamic clone through source ids, we need to check this filter\n\t\tif (!filter_dst->max_extra_pids\n\t\t \t&& !filter_dst->dynamic_source_ids\n\t\t\t&& (filter_dst->num_input_pids || filter_dst->in_pid_connection_pending || filter_dst->in_link_resolution)\n\t\t \t&& (!filter->swap_pidinst_dst || (filter->swap_pidinst_dst->filter != filter_dst))\n\t\t) {\n\t\t\tif ((filter_dst->clonable==GF_FILTER_CLONE_PROBE)\n\t\t\t\t&& !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)\n\t\t\t\t&& !filter->source_ids\n\t\t\t)\n\t\t\t\tfilter_dst->clonable = GF_FILTER_NO_CLONE;\n\n\t\t\t//not explicitly clonable, don't connect to it\n\t\t\tif (filter_dst->clonable==GF_FILTER_NO_CLONE) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s not clonable\\n\", filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//explicitly clonable but caps don't match, don't connect to it\n\t\t\tif (!gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1)) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s caps does not match clonable filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_list_find(pid->filter->blacklisted, (void *) filter_dst->freg)>=0) continue;\n\n\t\t//we try to load a filter chain, so don't test against filters loaded for another chain\n\t\tif (filter_dst->dynamic_filter && (filter_dst != pid->filter->dst_filter)) {\n\t\t\t//dst was explicitly set and does not match\n\t\t\tif (pid->filter->dst_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has explicit dest %s not %s\\n\", pid->name, pid->filter->dst_filter->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//dst was not set, we may try to connect to this filter if it allows several input\n\t\t\t//this is typically the case for muxers instantiated dynamically\n\t\t\tif (!filter_dst->max_extra_pids) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has explicit dest %s (%p) matching but no extra pid possible\\n\", pid->name, filter_dst->name, filter_dst));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//pid->filter->dst_filter NULL and pid->filter->target_filter is not: we had a wrong resolved chain to target\n\t\t//so only attempt to relink the chain if dst_filter is the expected target\n\t\tif (!pid->filter->dst_filter && pid->filter->target_filter && (filter_dst != pid->filter->target_filter)) {\n\t\t\tif (filter_dst->target_filter != pid->filter->target_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has target filter %s not matching %s->%s\\n\", pid->name, pid->filter->target_filter->name, filter_dst->name, filter_dst->target_filter ? filter_dst->target_filter->name : \"null\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//if the target filter of this filter is the same as ours, try to connect - typically scalable streams decoding\n\t\t}\n\n\t\t//dynamic filters only connect to their destination, unless explicit connections through sources\n\t\t//we could remove this but this highly complicates PID resolution\n\t\tif (!filter_dst->source_ids && pid->filter->dynamic_filter && pid->filter->dst_filter && (filter_dst!=pid->filter->dst_filter)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has dest filter %s not matching %s\\n\", pid->name, pid->filter->dst_filter->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\t//walk up through the parent graph and check if this filter is already in. If so don't connect\n\t\t//since we don't allow re-entrant PIDs\n\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tin_parent_chain = gf_filter_in_parent_chain(filter, filter_dst);\n\n\t\tRELOCK_FILTER_LIST\n\n\t\tif (in_parent_chain) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has filter %s in its parent chain\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\n\t\t//do not create cyclic graphs due to link resolution (dynamic filters)\n\t\t//look in all registered input PIDs of filter_dst and check if the current PID being linked has one of these pid in its source chain.\n\t\t//If so, do not link. this solves:\n\t\t//      fin:ID1 [-> dmx] (PID1) -> dynf1 (PID2) -> dst1:SID=1\n\t\t//                              -> dynf2 (PID3) -> dst2:SID=1\n\t\t//In this case, PID2 will inherit ID1 and could be accepted a source of dynf2 which already has PID1 registered\n\t\t//by walking up PID2 parent chain we check that PID1 will not be linked twice to the same filter\n\t\t//\n\t\t//We stop inspecting at the first filter with ID in the source\n\t\tif (filter->dynamic_filter)  {\n\t\t\tBool cyclic_detected = GF_FALSE;\n\t\t\tu32 k;\n\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t//check filters pending a configure on filter_dst\n\t\t\tfor (k=0; k<gf_list_count(filter_dst->temp_input_pids); k++) {\n\t\t\t\tGF_FilterPid *a_src_pid = gf_list_get(filter_dst->temp_input_pids, k);\n\t\t\t\tif (a_src_pid == pid) continue;\n\t\t\t\tif (gf_pid_in_parent_chain(pid, a_src_pid))\n\t\t\t\t\tcyclic_detected = GF_TRUE;\n\t\t\t}\n\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\n\t\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t//check filters already connected on filter_dst\n\t\t\tfor (k=0; k<filter_dst->num_input_pids && !cyclic_detected; k++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter_dst->input_pids, k);\n\t\t\t\tif (pidi->pid == pid) continue;\n\t\t\t\tif (gf_pid_in_parent_chain(pid, pidi->pid))\n\t\t\t\t\tcyclic_detected = GF_TRUE;\n\t\t\t}\n\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\n\t\t\tRELOCK_FILTER_LIST\n\n\t\t\tif (cyclic_detected) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s:%s has one or more PID in input chain already connected to filter %s, breaking cycle\\n\", pid->name, pid->filter->name, filter_dst->name));\n\t\t\t\tgf_list_del_item(force_link_resolutions, filter_dst);\n\t\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_links); k++) {\n\t\t\t\t\tGF_Filter *a_dst = gf_list_get(filter_dst->destination_links, k);\n                   gf_list_del_item(force_link_resolutions, a_dst);\n\t\t\t\t}\n\t\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {\n\t\t\t\t\tGF_Filter *a_dst = gf_list_get(filter_dst->destination_filters, k);\n                    gf_list_del_item(force_link_resolutions, a_dst);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if the original filter is in the parent chain of this PID's filter, don't connect (equivalent to re-entrant)\n\t\tif (filter_dst->cloned_from) {\n\t\t\tif (gf_filter_in_parent_chain(filter, filter_dst->cloned_from) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has the original of cloned filter %s in its parent chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (gf_filter_in_parent_chain(filter_dst->cloned_from, filter) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has the original of cloned filter %s in its output filter chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if the filter is in the parent chain of this PID's original filter, don't connect (equivalent to re-entrant)\n\t\tif (filter->cloned_from) {\n\t\t\tif (gf_filter_in_parent_chain(filter->cloned_from, filter_dst) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s filter is cloned and has filter %s in its clone parent chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if we have sourceID info on the destination, check them\n\t\tneeds_clone=GF_FALSE;\n\t\tif (filter_id) {\n\t\t\tif (filter_dst->source_ids) {\n\t\t\t\tBool pid_excluded=GF_FALSE;\n\t\t\t\tif (!filter_source_id_match(pid, filter_id, filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\t\tBool not_ours=GF_TRUE;\n\t\t\t\t\t//if filter is a dynamic one with an ID set, fetch ID from previous filter in chain\n\t\t\t\t\t//this is need for cases such as \"-i source filterFoo @ -o live.mpd\":\n\t\t\t\t\t//the dasher filter will be dynamically loaded AND will also assign itself a filter ID\n\t\t\t\t\t//due to internal filter (dasher) logic\n\t\t\t\t\t//that dasher filter ID will be different from the ID assigned by '@' on dst file's sourceID,\n\t\t\t\t\t//which is the filter ID of filterFoo\n\t\t\t\t\tif (filter->dynamic_filter && filter->id) {\n\t\t\t\t\t\tconst char *src_filter_id = gf_filter_last_id_in_chain(filter, GF_TRUE);\n\t\t\t\t\t\tif (filter_source_id_match(pid, src_filter_id, filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\t\t\t\tnot_ours = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (not_ours) {\n\t\t\t\t\t\tif (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;\n\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s does not match source ID for filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if we are a dynamic filter linking to a destination filter without ID (no link directive) and\n\t\t\t\t//implicit mode is used, use implicit linking\n\t\t\t\t//otherwise force explicit linking\n\t\t\t\t//this avoids that dyn filters loaded for a link targeting an implicitly link filter link to a later filter:\n\t\t\t\t//avsource enc_v @ FX output\n\t\t\t\t//if enc_v loads a filter FA to connect to FX, we don't want FA->output\n\t\t\t\tif (!filter->dynamic_filter || filter_dst->id || !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE))\n\t\t\t\t\tuse_explicit_link = GF_TRUE;\n\t\t\t}\n\t\t\t//if no source ID on the dst filter, this means the dst filter accepts any possible connections from out filter\n\t\t\t//unless prevented for this pid\n\t\t\telse if (pid->require_source_id) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s requires source ID, not set for filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//no filterID and dst expects only specific filters, continue\n\t\telse if (filter_dst->source_ids && !ignore_source_ids) {\n\t\t\tBool pid_excluded=GF_FALSE;\n\t\t\tif ( (filter_dst->source_ids[0]!='*')\n\t\t\t\t&& (filter_dst->source_ids[0]!=filter->session->sep_frag)\n\t\t\t\t&& (filter_dst->source_ids[0]!=filter->session->sep_neg)\n\t\t\t\t) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s does not match filter %s source ID\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!filter_source_id_match(pid, \"*\", filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\tif (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s is excluded by filter %s source ID\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuse_explicit_link = GF_TRUE;\n\t\t}\n\t\telse if (filter->subsession_id != filter_dst->subsession_id) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s and filter %s not in same subsession and no links directive\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\t//filters are in the same subsession and have a subsource_id (not part of chain-to-sink)\n\t\t//only link if same subsource_id\n\t\telse if (filter->subsource_id && filter_dst->subsource_id && (filter->subsource_id != filter_dst->subsource_id)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s and filter %s do not have same source and no links directive\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\tif (needs_clone) {\n\t\t\t//remember this filter as clonable (dynamic source id scheme) if none yet found.\n\t\t\t//If we had a matching sourceID, clone is not needed\n\t\t\tif (!num_pass && !dynamic_filter_clone && !found_matching_sourceid) {\n\t\t\t\tdynamic_filter_clone = filter_dst;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s needs cloning of filter %s\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t} else if (dynamic_filter_clone && dynamic_filter_clone->freg==filter_dst->freg) {\n\t\t\tdynamic_filter_clone = NULL;\n\t\t}\n\t\t//remember we had a sourceid match\n\t\tfound_matching_sourceid = GF_TRUE;\n\n\t\t//we have a match, check if caps are OK\n\t\tcap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1);\n\n\t\t//dst filter forces demuxing, pid is file and caps matched, do not test and do not activate link resolution\n\t\t//if can_try_link_resolution is still false at end of pass one, we will insert a reframer\n\t\tif (cap_matched && filter_dst->force_demux && pid_is_file) {\n\t\t\tif (pid_is_file==1)\n\t\t\t\tpid_is_file = 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcan_try_link_resolution = GF_TRUE;\n\n\t\t//this is the right destination filter. We however need to check if we don't have a possible destination link\n\t\t//whose destination is this destination (typically mux > fout/pipe/sock case). If that's the case, swap the destination\n\t\t//filter with the intermediate node before matching caps and resolving link\n\t\tif (num_pass) {\n\t\t\tu32 k, alt_count = gf_list_count(possible_linked_resolutions);\n\t\t\tfor (k=0; k<alt_count; k++) {\n\t\t\t\tGF_Filter *adest = gf_list_get(possible_linked_resolutions, k);\n\t\t\t\t//we only apply this if the destination filter has the GF_FS_REG_DYNAMIC_REDIRECT flag set.\n\t\t\t\t//Not doing so could results in broken link resolution:\n\t\t\t\t//PID1(AVC) -> decoder1 -> compositor\n\t\t\t\t//PID2(PNG) -> decoder2 -> compositor\n\t\t\t\t//However this algo would force a connection of PID2 to decoder1 if decoder1 accepts multiple inputs, regardless of PID2 caps\n\t\t\t\tif (! (adest->freg->flags & GF_FS_REG_DYNAMIC_REDIRECT))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((gf_list_find(adest->destination_filters, filter_dst)>=0) || (gf_list_find(adest->destination_links, filter_dst)>=0) ) {\n\t\t\t\t\tfilter_dst = adest;\n\t\t\t\t\tgf_list_rem(possible_linked_resolutions, k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//if clonable filter and no match, check if we would match the caps without caps override of dest\n\t\t//note we don't do this on sources for the time being, since this might trigger undesired resolution of file->file\n\t\tif (!cap_matched && (filter_dst->clonable==GF_FILTER_CLONE) && pid->filter->num_input_pids) {\n\t\t\tcap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, NULL, NULL, NULL, pid->filter->dst_filter, -1);\n\t\t}\n\n\t\tif (!cap_matched) {\n\t\t\tBool skipped = GF_FALSE;\n\t\t\tBool reassigned=GF_FALSE;\n\t\t\tGF_Filter *new_f;\n\n\t\t\t//we don't load filter chains if we have a change of media type from anything except file to anything except file\n\t\t\t//i.e. transmodality (eg video->audio) can only be done through explicit filters\n\t\t\tif (gf_filter_pid_needs_explicit_resolution(pid, filter_dst)) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s needs explicit resolution for linking to filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//we had a destination set during link resolve, and we don't match that filter, consider the link resolution wrong\n\t\t\tif (pid->filter->dst_filter && (filter_dst == pid->filter->dst_filter)) {\n\t\t\t\tGF_Filter *old_dst = pid->filter->dst_filter;\n\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t\tgf_list_del_item(pid->filter->destination_links, filter_dst);\n\t\t\t\tgf_list_del_item(pid->filter->destination_filters, filter_dst);\n\t\t\t\t//nobody using this filter, destroy\n\t\t\t\tif (old_dst->dynamic_filter\n\t\t\t\t\t&& !old_dst->has_pending_pids\n\t\t\t\t\t&& !old_dst->num_input_pids\n\t\t\t\t\t&& !old_dst->num_output_pids\n\t\t\t\t\t&& !old_dst->out_pid_connection_pending\n\t\t\t\t) {\n\t\t\t\t\tBool skip = ((old_dst==filter_dst) && (filter_dst->dynamic_filter!=2)) ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tgf_filter_post_remove(old_dst);\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!num_pass) {\n                //we have an explicit link instruction so we must try dynamic link even if we connect to another filter\n                //is_sink set, same thing (implicit mode only, force link to sink)\n\t\t\t\tif (filter_dst->source_ids || (is_sink && !implicit_link_found)) {\n                    gf_list_add(force_link_resolutions, filter_dst);\n                    //! filter is an alias, prevent linking to the filter being aliased\n                    if (filter_dst->multi_sink_target) {\n\t\t\t\t\t\tgf_list_del_item(force_link_resolutions, filter_dst->multi_sink_target);\n\t\t\t\t\t\tgf_list_add(linked_dest_filters, filter_dst->multi_sink_target);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//register as possible destination link. If a filter already registered is a destination of this possible link\n\t\t\t\t\t//only the possible link will be kept\n\t\t\t\t\tif (!possible_link_found_implicit_mode)\n\t\t\t\t\t\tadd_possible_link_destination(possible_linked_resolutions, filter_dst);\n\n\t\t\t\t\t//implicit link mode: if possible destination is not a sink, stop checking for possible links\n\t\t\t\t\t//continue however first pass in case we have a direct match with a dynamic filter, eg:\n\t\t\t\t\t//tiled_input.mpd -> compositor -> ...\n\t\t\t\t\t//the first pid will resolve to dashin + tileagg\n\t\t\t\t\t//the second pid from dashin must link to tileagg, but if we stop the pass 0 loop\n\t\t\t\t\t//it would link to compositor with a new tileagg filter\n\t\t\t\t\tif (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) && !is_sink) {\n\t\t\t\t\t\tpossible_link_found_implicit_mode = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfilter_found_but_pid_excluded = GF_FALSE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Attempting to solve link between PID %s:%s and filter %s\\n\", pid->filter->freg->name, pid->name, filter_dst->name));\n\n\t\t\tif (num_pass==1) reassigned = GF_TRUE;\n\t\t\telse reassigned = GF_FALSE;\n\n\t\t\t//we pass the list of loaded filters for this pid, so that we don't instanciate twice the same chain start\n\t\t\tnew_f = gf_filter_pid_resolve_link_check_loaded(pid, filter_dst, &reassigned, loaded_filters, &skipped);\n\n\t\t\t//try to load filters\n\t\t\tif (! new_f) {\n\t\t\t\tif (skipped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid->filter->session->run_status!=GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s:%s init canceled (session abort)\\n\", pid->filter->name, pid->name));\n\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\tgf_list_del(linked_dest_filters);\n                    gf_list_del(force_link_resolutions);\n                    gf_list_del(possible_linked_resolutions);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//filter was reassigned (pid is destroyed), return\n\t\t\t\tif (reassigned) {\n\t\t\t\t\tif (num_pass==1) {\n\t\t\t\t\t\tcan_reassign_filter = GF_TRUE;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\tgf_list_del(linked_dest_filters);\n                    gf_list_del(force_link_resolutions);\n                    gf_list_del(possible_linked_resolutions);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//we might had it wrong solving the chain initially, break the chain\n\t\t\t\tif (filter_dst->dynamic_filter && filter_dst->dst_filter) {\n\t\t\t\t\tGF_Filter *new_dst = filter_dst;\n\t\t\t\t\twhile (new_dst->dst_filter && new_dst->dynamic_filter) {\n\t\t\t\t\t\tGF_Filter *f = new_dst;\n\t\t\t\t\t\tnew_dst = new_dst->dst_filter;\n\t\t\t\t\t\tif (!f->num_input_pids && !f->num_output_pids && !f->in_pid_connection_pending) {\n\t\t\t\t\t\t\tgf_filter_post_remove(f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t\t\tnew_f = gf_filter_pid_resolve_link(pid, new_dst, &reassigned);\n\t\t\t\t\tif (!new_f) {\n\t\t\t\t\t\tif (reassigned) {\n\t\t\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\t\t\tgf_list_del(linked_dest_filters);\n                            gf_list_del(force_link_resolutions);\n                            gf_list_del(possible_linked_resolutions);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//good to go !\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//in implicit link, if target is not here push it (we have no SID/FID to solve that later)\n\t\t\tif ((filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)\n\t\t\t\t&& !gf_list_count(new_f->destination_filters)\n\t\t\t\t&& !gf_list_count(new_f->destination_links)\n\t\t\t\t&& !filter_dst->source_ids\n\t\t\t) {\n\t\t\t\tgf_list_add(new_f->destination_links, filter_dst);\n\t\t\t}\n\n\t\t\t//target was in clone probe but we have loaded a mux, disable clone\n\t\t\tif ((filter_dst->clonable==GF_FILTER_CLONE_PROBE) && new_f->max_extra_pids)\n\t\t\t\tfilter_dst->clonable = GF_FILTER_NO_CLONE;\n\n\t\t\tgf_list_del_item(filter->destination_filters, filter_dst);\n\t\t\tif (gf_list_find(new_f->destination_filters, filter_dst)>=0) {\n\t\t\t\tif (filter_dst->clonable==GF_FILTER_NO_CLONE)\n\t\t\t\t\tfilter_dst->in_link_resolution = GF_TRUE;\n\t\t\t}\n\n\t\t\tfilter_dst = new_f;\n\t\t\tgf_list_add(loaded_filters, new_f);\n\t\t}\n\n\t\tif (!(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))) {\n\t\t\tassert(pid->pid->filter->freg != filter_dst->freg);\n\t\t}\n\n\t\tsafe_int_inc(&pid->filter->out_pid_connection_pending);\n\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\tgf_list_add(filter_dst->temp_input_pids, pid);\n\t\tif (pid->filter != filter_dst->single_source)\n\t\t\tfilter_dst->single_source = NULL;\n\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\tgf_filter_pid_post_connect_task(filter_dst, pid);\n\n\t\tfound_dest = GF_TRUE;\n\t\tgf_list_add(linked_dest_filters, filter_dst);\n\n\t\tgf_list_del_item(filter->destination_links, filter_dst);\n\t\t/*we are linking to a mux, check all destination filters registered with the muxer and remove them from our possible destination links*/\n\t\tif (filter_dst->max_extra_pids) {\n\t\t\tu32 k=0;\n\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {\n\t\t\t\tGF_Filter *dst_f = gf_list_get(filter_dst->destination_filters, k);\n\t\t\t\tgf_list_del_item(filter->destination_links, dst_f);\n\t\t\t}\n\t\t}\n\n\t\t//implicit link mode: if target was a sink, allow further sink connections, otherwise stop linking\n\t\tif (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)) {\n\t\t\tif (is_sink)\n\t\t\t\tlink_sinks_only = GF_TRUE;\n\t\t\telse if (!implicit_link_found) {\n\t\t\t\tu32 k=0;\n\t\t\t\tfor (k=0; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\t\tGF_Filter *dst_f = gf_list_get(force_link_resolutions, k);\n\t\t\t\t\tif (!dst_f->source_ids) {\n\t\t\t\t\t\tgf_list_rem(force_link_resolutions, k);\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\timplicit_link_found = GF_TRUE;\n\t\t\t}\n\t\t}\n    }\n\n\tif (!num_pass) {\n\t\tu32 i, k;\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\t//cleanup forced filter list:\n\t\t//remove any forced filter which is a destination of a filter we already linked to\n\t\tfor (i=0; i< gf_list_count(linked_dest_filters); i++) {\n\t\t\tGF_Filter *filter_dst = gf_list_get(linked_dest_filters, i);\n\t\t\tfor (k=0; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\tGF_Filter *dst_link = gf_list_get(force_link_resolutions, k);\n\t\t\t\tif (//if forced filter is in parent chain (already connected filters), don't force a link\n\t\t\t\t\tgf_filter_in_parent_chain(filter_dst, dst_link)\n\t\t\t\t\t|| gf_filter_in_parent_chain(dst_link, filter_dst)\n\t\t\t\t\t//if forced filter is in destination of filter (connection pending), don't force a link\n\t\t\t\t\t//we need to walk up the destination chain, not just check the first level since the filter_dst might be connected\n\t\t\t\t\t//and no longer have dst_link in its destination filter list\n\t\t\t\t\t//typical case is multithreaded mode with mux or tileagg filter\n\t\t\t\t\t|| filter_match_target_dst(filter_dst->destination_filters, dst_link)\n\t\t\t\t\t|| filter_match_target_dst(filter_dst->destination_links, dst_link)\n\t\t\t\t\t//if forced filter's target is the same as what we connected to, don't force a link\n\t\t\t\t\t|| (dst_link->target_filter == filter_dst)\n\t\t\t\t) {\n\t\t\t\t\tgf_list_rem(force_link_resolutions, k);\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//cleanup forced link resolution list: remove any forced filter which is a destination of another forced filter\n\t\t//this is needed when multiple pids link to a single dynamically loaded mux, where we could end up\n\t\t//with both the  destination link and the mux (in this order) in this list, creating a new mux if the destination has a pending link\n\t\tfor (i=0; i<gf_list_count(force_link_resolutions); i++) {\n\t\t\tGF_Filter *forced_dst = gf_list_get(force_link_resolutions, i);\n\t\t\tfor (k=i+1; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\tGF_Filter *forced_inserted = gf_list_get(force_link_resolutions, k);\n\n\t\t\t\tif (gf_filter_in_parent_chain(forced_inserted, forced_dst)\n\t\t\t\t\t|| filter_match_target_dst(forced_inserted->destination_filters, forced_dst)\n\t\t\t\t\t|| filter_match_target_dst(forced_inserted->destination_links, forced_dst)\n\t\t\t\t) {\n\t\t\t\t\tgf_list_rem(force_link_resolutions, i);\n\t\t\t\t\t//prevent linking to this filter\n\t\t\t\t\tgf_list_add(linked_dest_filters, forced_dst);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_mx_p(filter->session->filters_mx);\n\t}\n\n\tif (loaded_filters) {\n\t\tgf_list_del(loaded_filters);\n\t\tloaded_filters = NULL;\n\t}\n\n\t//we still have possible destination links and we can try link resolution, do it\n\tif (!num_pass && gf_list_count(filter->destination_links) && can_try_link_resolution && filter->session->max_resolve_chain_len) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n    //we must do the second pass if a filter has an explicit link set through source ID\n\tif (!num_pass && gf_list_count(force_link_resolutions)) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n\n    //connection task posted, nothing left to do\n\tif (found_dest) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tpid->filter->disabled = GF_FILTER_ENABLED;\n\t\tgf_list_del(linked_dest_filters);\n        gf_list_del(force_link_resolutions);\n        gf_list_del(possible_linked_resolutions);\n\t\tgf_fs_check_graph_load(filter->session, GF_FALSE);\n\t\tif (pid->not_connected) {\n\t\t\tpid->not_connected = 0;\n\t\t\tassert(pid->filter->num_out_pids_not_connected);\n\t\t\tpid->filter->num_out_pids_not_connected--;\n\t\t}\n\t\treturn;\n\t}\n\n\t//on first pass, if we found a clone (eg a filter using freg:#PropName=*), instantiate this clone and redo the pid linking to this clone (last entry in the filter list)\n\tif (dynamic_filter_clone && !num_pass) {\n\t\tGF_Filter *clone = gf_filter_clone(dynamic_filter_clone, NULL);\n\t\tif (clone) {\n\t\t\tassert(dynamic_filter_clone->dynamic_source_ids);\n\t\t\tgf_free(clone->source_ids);\n\t\t\tclone->source_ids = gf_strdup(dynamic_filter_clone->dynamic_source_ids);\n\t\t\tclone->cloned_from = NULL;\n\t\t\tcount = gf_list_count(filter->session->filters);\n\t\t\tgf_list_add(pid->filter->destination_links, clone);\n\t\t\tf_idx = count-1;\n\t\t\tnum_pass = 1;\n\t\t\tgoto single_retry;\n\t\t}\n\t}\n\n\t//nothing found at first pass and demuxed forced, inject a reframer filter\n\tif (!num_pass && !can_try_link_resolution && (pid_is_file==2)) {\n\t\tGF_Err e;\n\t\tGF_Filter *f = gf_fs_load_filter(filter->session, \"reframer\", &e);\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Local file PID %s to local file detected, forcing remux\\n\", pid->name));\n\t\t\tf->dynamic_filter = 2;\n\t\t\tf->subsession_id = pid->filter->subsession_id;\n\t\t\tf->subsource_id = pid->filter->subsource_id;\n\t\t\t//force pid's filter destination to the reframer - this will in pass #2:\n\t\t\t//- force solving file->reframer, loading the demuxer\n\t\t\t//- since caps between pid and reframer don't match and reframer is not used by anyone, the reframer will be removed\n\t\t\t//We end up with a demuxed source with no intermediate reframer filter :)\n\t\t\tpid->filter->dst_filter = f;\n\t\t\tnum_pass = 1;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t//nothing found, redo a pass, this time allowing for link resolve\n\tif (!num_pass && can_try_link_resolution && filter->session->max_resolve_chain_len) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n\tif ((num_pass==1) && can_reassign_filter) {\n\t\tif (filter->session->flags & GF_FS_FLAG_NO_REASSIGN) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID %s in filter %s not connected, source reassignment was possible but is disabled\\n\", pid->name, pid->filter->name));\n\t\t} else {\n\t\t\tnum_pass = 2;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s in filter %s not connected to any loaded filter, trying source reassignment\\n\", pid->name, pid->filter->name));\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tgf_fs_check_graph_load(filter->session, GF_FALSE);\n\n\tgf_list_del(linked_dest_filters);\n    gf_list_del(force_link_resolutions);\n    gf_list_del(possible_linked_resolutions);\n\tgf_mx_v(filter->session->filters_mx);\n\n\tif (pid->num_destinations && !pid->not_connected) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\treturn;\n\t}\n\tfilter->num_out_pids_not_connected ++;\n\t//remove sparse info\n\tif (pid->is_sparse) {\n\t\tassert(filter->nb_sparse_pids);\n\t\tsafe_int_dec(&filter->nb_sparse_pids);\n\t\tpid->is_sparse = 0;\n\t}\n\n\tGF_FilterEvent evt;\n\tif (filter_found_but_pid_excluded) {\n\t\t//PID was not included in explicit connection lists\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s in filter %s not connected to any loaded filter due to source directives\\n\", pid->name, pid->filter->name));\n\t\tpid->not_connected = 1;\n\t} else {\n\t\t//no filter found for this pid !\n\t\tif (!pid->not_connected_ok && (filter->session->flags & GF_FS_FLAG_FULL_LINK) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"No filter chain found for PID %s in filter %s to any loaded filters - ABORTING!\\n\", pid->name, pid->filter->name));\n\t\t\tfilter->session->last_connect_error = GF_FILTER_NOT_FOUND;\n\t\t\tfilter->session->run_status = GF_FILTER_NOT_FOUND;\n\t\t\tfilter->session->in_final_flush = GF_TRUE;\n\t\t\tassert(pid->init_task_pending);\n\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\treturn;\n\t\t}\n\n\t\tGF_LOG(pid->not_connected_ok ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_FILTER, (\"No filter chain found for PID %s in filter %s to any loaded filters - NOT CONNECTED\\n\", pid->name, pid->filter->name));\n\n\t\tif (pid->filter->freg->process_event) {\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\tpid->filter->freg->process_event(filter, &evt);\n\t\t}\n\t\tpid->not_connected = 1;\n\t}\n\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\tevt.play.initial_broadcast_play = 2;\n\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\tevt.play.initial_broadcast_play = 2;\n\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\tgf_filter_pid_set_eos(pid);\n\tif (!pid->not_connected_ok\n\t\t&& !parent_chain_has_dyn_pids(pid->filter)\n\t\t&& (pid->filter->num_out_pids_not_connected == pid->filter->num_output_pids)\n\t) {\n\t\tpid->filter->disabled = GF_FILTER_DISABLED;\n\n\t\tif (can_reassign_filter) {\n\t\t\tgf_filter_setup_failure(pid->filter, GF_FILTER_NOT_FOUND);\n\t\t}\n\t}\n\n\tif (!filter_found_but_pid_excluded && !pid->not_connected_ok && !filter->session->max_resolve_chain_len) {\n\t\tfilter->session->last_connect_error = GF_FILTER_NOT_FOUND;\n\t}\n\n\tassert(pid->init_task_pending);\n\tsafe_int_dec(&pid->init_task_pending);\n\treturn;\n}\n\nvoid gf_filter_pid_post_connect_task(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tassert(pid->pid);\n\tassert(pid->filter != filter);\n\tif (!(filter->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))) {\n\t\tassert(pid->filter->freg != filter->freg);\n\t}\n\tassert(filter->freg->configure_pid);\n\tsafe_int_inc(&filter->session->pid_connect_tasks_pending);\n\tsafe_int_inc(&filter->in_pid_connection_pending);\n\tgf_fs_post_task_ex(filter->session, gf_filter_pid_connect_task, filter, pid, \"pid_connect\", NULL, GF_TRUE, GF_FALSE, GF_FALSE, TASK_TYPE_NONE);\n}\n\n\nvoid gf_filter_pid_post_init_task(GF_Filter *filter, GF_FilterPid *pid)\n{\n//\tBool force_main_thread=GF_FALSE;\n\tif (pid->init_task_pending) return;\n\n\tsafe_int_inc(&pid->init_task_pending);\n//\tif (filter->session->force_main_thread_tasks)\n\t//force pid_init on main thread to avoid concurrent graph resolutions. While it works well for simple cases, it is problematic\n\t//for complex chains involving a lot of filters (typically gui loading icons)\n\tBool force_main_thread = GF_TRUE;\n\n\tgf_fs_post_task_ex(filter->session, gf_filter_pid_init_task, filter, pid, \"pid_init\", NULL, GF_FALSE, force_main_thread, GF_FALSE, TASK_TYPE_NONE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_framing_mode(GF_FilterPid *pid, Bool requires_full_blocks)\n{\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set framing info on an output pid in filter %s\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidinst->requires_full_data_block = requires_full_blocks;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_FilterPid *gf_filter_pid_new(GF_Filter *filter)\n{\n\tchar szName[30];\n\tGF_FilterPid *pid;\n\tGF_SAFEALLOC(pid, GF_FilterPid);\n\tif (!pid) return NULL;\n\tpid->filter = filter;\n\tpid->destinations = gf_list_new();\n\tpid->properties = gf_list_new();\n\tif (!filter->output_pids) filter->output_pids = gf_list_new();\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_add(filter->output_pids, pid);\n\tfilter->num_output_pids = gf_list_count(filter->output_pids);\n\tgf_mx_v(filter->tasks_mx);\n\tpid->pid = pid;\n\tpid->playback_speed_scaler = GF_FILTER_SPEED_SCALER;\n\tpid->require_source_id = filter->require_source_id;\n\n\tsprintf(szName, \"PID%d\", filter->num_output_pids);\n\tpid->name = gf_strdup(szName);\n\n\tfilter->has_pending_pids = GF_TRUE;\n\tgf_fq_add(filter->pending_pids, pid);\n\n\tgf_mx_p(filter->tasks_mx);\n\t//by default copy properties if only one input pid\n\tif (filter->num_input_pids==1) {\n\t\tGF_FilterPid *pidi = gf_list_get(filter->input_pids, 0);\n\t\tgf_filter_pid_copy_properties(pid, pidi);\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn pid;\n}\n\nvoid gf_filter_pid_del(GF_FilterPid *pid)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s destruction (%p)\\n\", pid->filter->name, pid->name, pid));\n\twhile (gf_list_count(pid->destinations)) {\n\t\tgf_filter_pid_inst_del(gf_list_pop_back(pid->destinations));\n\t}\n\tgf_list_del(pid->destinations);\n\n\twhile (gf_list_count(pid->properties)) {\n\t\tGF_PropertyMap *prop = gf_list_pop_back(pid->properties);\n\t\tassert(prop->reference_count);\n\t\tif (safe_int_dec(&prop->reference_count) == 0) {\n\t\t\tgf_props_del(prop);\n\t\t}\n\t}\n\tgf_list_del(pid->properties);\n\n\tif(pid->caps_negociate) {\n\t\tassert(pid->caps_negociate->reference_count);\n\t\tif (safe_int_dec(&pid->caps_negociate->reference_count) == 0) {\n\t\t\tgf_props_del(pid->caps_negociate);\n\t\t}\n\t}\n\n\tif (pid->adapters_blacklist)\n\t\tgf_list_del(pid->adapters_blacklist);\n\n\tif (pid->infos) {\n\t\tassert(pid->infos->reference_count);\n\t\tif (safe_int_dec(&pid->infos->reference_count) == 0) {\n\t\t\tgf_props_del(pid->infos);\n\t\t}\n\t}\n\tif (pid->name) gf_free(pid->name);\n\tgf_free(pid);\n}\n\nvoid gf_filter_pid_del_task(GF_FSTask *task)\n{\n\tgf_filter_pid_del(task->pid);\n}\n\nstatic GF_PropertyMap *check_new_pid_props(GF_FilterPid *pid, Bool merge_props)\n{\n\tu32 i, nb_recf;\n\tGF_PropertyMap *old_map;\n\tGF_PropertyMap *map;\n\n\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\tgf_mx_p(pid->filter->tasks_mx);\n\told_map = gf_list_last(pid->properties);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\tpid->props_changed_since_connect = GF_TRUE;\n\tif (old_map && !pid->request_property_map) {\n\t\treturn old_map;\n\t}\n\tmap = gf_props_new(pid->filter);\n\tif (!map)\n\t\treturn NULL;\n\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\tgf_mx_p(pid->filter->tasks_mx);\n\tgf_list_add(pid->properties, map);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\tpid->request_property_map = GF_FALSE;\n\tpid->pid_info_changed = GF_FALSE;\n\n\t//when creating a new map, ref_count of old map is decremented\n\tif (old_map) {\n\t\tif (merge_props)\n\t\t\tgf_props_merge_property(map, old_map, NULL, NULL);\n\n\t\tassert(old_map->reference_count);\n\t\tif (safe_int_dec(&old_map->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pid->properties, old_map);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tgf_props_del(old_map);\n\t\t}\n\t}\n\n\t//trick here: we may be reconfigured before any packet is being dispatched\n\t//so we need to manually trigger reconfigure of outputs\n\tnb_recf = 0;\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\tif (!pidi->filter->process_task_queued) {\n\t\t\t//remember the pid prop map to use\n\t\t\tpidi->reconfig_pid_props = map;\n\t\t\tnb_recf++;\n\t\t}\n\t}\n\tif (nb_recf)\n\t\tpid->filter->reconfigure_outputs = GF_TRUE;\n\treturn map;\n}\n\nstatic GF_Err gf_filter_pid_set_property_full(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, char *dyn_name, const GF_PropertyValue *value, Bool is_info)\n{\n\tGF_PropertyMap *map;\n\tconst GF_PropertyValue *oldp;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to write property on input PID in filter %s - ignoring\\n\", pid->filter->name ? pid->filter->name : pid->filter->freg->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (prop_4cc) {\n\t\toldp = gf_filter_pid_get_property(pid, prop_4cc);\n\t} else {\n\t\toldp = gf_filter_pid_get_property_str(pid, prop_name ? prop_name : dyn_name);\n\t}\n\tif (!oldp && !value)\n\t\treturn GF_OK;\n\tif (oldp && value) {\n\t\tif (gf_props_equal_strict(oldp, value)) {\n\t\t\tif (value->type==GF_PROP_DATA_NO_COPY) gf_free(value->value.data.ptr);\n\t\t\telse if (value->type==GF_PROP_STRING_NO_COPY) gf_free(value->value.string);\n\t\t\telse if (value->type==GF_PROP_STRING_LIST) gf_props_reset_single((GF_PropertyValue *) value);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//info property, do not request a new property map\n\tif (is_info) {\n\t\tmap = pid->infos;\n\t\tif (!map) {\n\t\t\tmap = pid->infos = gf_props_new(pid->filter);\n\t\t}\n\t\tpid->pid_info_changed = GF_TRUE;\n\t} else {\n\t\t//always merge properties\n\t\tmap = check_new_pid_props(pid, GF_TRUE);\n\t}\n\tif (!map) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (value && (prop_4cc==GF_PROP_PID_TIMESCALE))\n\t\tmap->timescale = value->value.uint;\n\n\t//if change of codecid or streamtype, remove ISOBMFF templates and subtype for codec\n\tif (oldp && value) {\n\t\tBool reset=0;\n\t\tif (prop_4cc == GF_PROP_PID_CODECID) {\n\t\t\treset = 2;\n\t\t} else if (prop_4cc == GF_PROP_PID_STREAM_TYPE) {\n\t\t\tif ((oldp->value.uint==GF_STREAM_ENCRYPTED) || (value->value.uint==GF_STREAM_ENCRYPTED))\n\t\t\t\treset = 1;\n\t\t}\n\t\tif (reset) {\n\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, NULL, NULL, NULL);\n\t\t\tif (reset==2) {\n\t\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_STSD_TEMPLATE, NULL, NULL, NULL);\n\t\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_SUBTYPE, NULL, NULL, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value && (prop_4cc == GF_PROP_PID_ID) && !pid->name) {\n\t\tchar szName[100];\n\t\tsprintf(szName, \"PID%d\", value->value.uint);\n\t\tgf_filter_pid_set_name(pid, szName);\n\t}\n\treturn gf_props_set_property(map, prop_4cc, prop_name, dyn_name, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, prop_4cc, NULL, NULL, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, name, NULL, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, NULL, name, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, prop_4cc, NULL, NULL, value, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, name, NULL, value, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, NULL, name, value, GF_TRUE);\n}\n\nstatic GF_Err gf_filter_pid_negociate_property_full(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, char *dyn_name, const GF_PropertyValue *value)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to negociate property on output PID in filter %s - ignoring\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpid = pid->pid;\n\tif (!pid->caps_negociate) {\n\t\tassert(!pid->caps_negociate_pidi_list);\n\t\tpid->caps_negociate = gf_props_new(pid->filter);\n\t\tpid->caps_negociate_pidi_list = gf_list_new();\n\t\tpid->caps_negociate_direct = GF_TRUE;\n\t\tgf_list_add(pid->caps_negociate_pidi_list, pidi);\n\t\t//we start a new caps negotiation step, reset any blacklist on pid\n\t\tif (pid->adapters_blacklist) {\n\t\t\tgf_list_del(pid->adapters_blacklist);\n\t\t\tpid->adapters_blacklist = NULL;\n\t\t}\n\t\tsafe_int_inc(&pid->filter->nb_caps_renegociate);\n\t}\n\telse {\n\t\tconst GF_PropertyValue *p;\n\t\t//new PID instance asking for cap negociation\n\t\tif (gf_list_find(pid->caps_negociate_pidi_list, pidi)<0) {\n\t\t\tgf_list_add(pid->caps_negociate_pidi_list, pidi);\n\t\t}\n\n\t\t//check if same property to list\n\t\tp = gf_props_get_property(pid->caps_negociate, prop_4cc, prop_name);\n\t\tif (p) {\n\t\t\tif (gf_props_equal(p, value))\n\t\t\t\treturn GF_OK;\n\t\t\t//not the same value, disable direct caps negociate\n\t\t\tpid->caps_negociate_direct = GF_FALSE;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_INFO)) {\n\t\tchar p_dump[GF_PROP_DUMP_ARG_SIZE];\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s negociate property %s to %s\\n\",\n\t\t\tpid->filter->name, \tprop_name ? prop_name : gf_props_4cc_get_name(prop_4cc),\n\t\t\tgf_props_dump(prop_4cc, value, p_dump, GF_PROP_DUMP_DATA_NONE)\n\t\t));\n\t}\n#endif\n\n\t//pid is end of stream or pid instance has packet pendings, we will need a new chain to adapt these packets formats\n\tif (pid->has_seen_eos || gf_fq_count(pidi->packets)) {\n\t\tgf_fs_post_task(pid->filter->session, gf_filter_renegociate_output_task, pid->filter, NULL, \"filter renegociate\", NULL);\n\t}\n\treturn gf_props_set_property(pid->caps_negociate, prop_4cc, prop_name, dyn_name, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, prop_4cc, NULL, NULL, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, 0, name, NULL, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, 0, NULL, name, value);\n}\n\n\nstatic GF_PropertyMap *filter_pid_get_prop_map(GF_FilterPid *pid, Bool first_prop_if_output)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\t\t//first time we access the props, use the first entry in the property list\n\t\tif (!pidi->props) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tpidi->props = gf_list_get(pid->pid->properties, 0);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tassert(pidi->props);\n\t\t\tsafe_int_inc(&pidi->props->reference_count);\n\t\t}\n\t\treturn pidi->props;\n\t} else {\n\t\tGF_PropertyMap *res_map = NULL;\n\t\tpid = pid->pid;\n\t\tif (pid->local_props) return pid->local_props;\n\n\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tif (first_prop_if_output)\n\t\t\tres_map = gf_list_get(pid->properties, 0);\n\t\telse\n\t\t\tres_map = gf_list_last(pid->properties);\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn res_map;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_property(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, prop_4cc, NULL);\n}\n\nconst GF_PropertyValue *gf_filter_pid_get_property_first(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_TRUE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, prop_4cc, NULL);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_property_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, 0, prop_name);\n}\n\nconst GF_PropertyValue *gf_filter_pid_get_property_str_first(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_TRUE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, 0, prop_name);\n}\n\nconst GF_PropertyEntry *gf_filter_pid_get_property_entry(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property_entry(map, prop_4cc, NULL);\n}\n\nGF_EXPORT\nconst GF_PropertyEntry *gf_filter_pid_get_property_entry_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property_entry(map, 0, prop_name);\n}\n\nstatic const GF_PropertyValue *gf_filter_pid_get_info_internal(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, Bool first_call,  GF_PropertyEntry **propentry)\n{\n\tu32 i;\n\tconst GF_PropertyEntry *prop_ent = NULL;\n\tGF_PropertyMap *map;\n\t*propentry = NULL;\n\t\n\tif (first_call) {\n\t\tgf_mx_p(pid->filter->session->info_mx);\n\t}\n\tmap = filter_pid_get_prop_map(pid, GF_FALSE);\n\n\tif (map) {\n\t\tprop_ent = gf_props_get_property_entry(map, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\tif (pid->pid->infos) {\n\t\tprop_ent = gf_props_get_property_entry(pid->pid->infos, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tprop_ent = NULL;\n\t\tgoto exit;\n\t}\n\tpid = pid->pid;\n\tif (pid->infos) {\n\t\tprop_ent = gf_props_get_property_entry(pid->infos, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tconst GF_PropertyValue *prop;\n\t\tGF_FilterPid *pidinst = gf_list_get(pid->filter->input_pids, i);\n\t\tif (!pidinst->pid) continue;\n\t\tif (!pidinst->pid->filter) continue;\n\t\tif (pidinst->pid->filter->removed) continue;\n\n\t\tprop = gf_filter_pid_get_info_internal((GF_FilterPid *)pidinst, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tprop_ent = *propentry;\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\tprop_ent = NULL;\n\nexit:\n\tif (first_call) {\n\t\tgf_mx_v(pid->filter->session->info_mx);\n\t}\n\tif (!prop_ent) {\n\t\t*propentry = NULL;\n\t\treturn NULL;\n\t}\n\tif (! (*propentry)) {\n\t\t*propentry = (GF_PropertyEntry *) prop_ent;\n\t\tsafe_int_inc(&prop_ent->reference_count);\n\t}\n\treturn &prop_ent->prop;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_info(GF_FilterPid *pid, u32 prop_4cc, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_pid_get_info_internal(pid, prop_4cc, NULL, GF_TRUE, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_info_str(GF_FilterPid *pid, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_pid_get_info_internal(pid, 0, prop_name, GF_TRUE, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_enum_info(GF_FilterPid *pid, u32 *idx, u32 *prop_4cc, const char **prop_name)\n{\n\tu32 i, cur_idx=0, nb_in_pid=0;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\tcur_idx = *idx;\n\tif (pid->infos) {\n\t\tcur_idx = *idx;\n\t\tconst GF_PropertyValue *prop = gf_props_enum_property(pid->infos, &cur_idx, prop_4cc, prop_name);\n\t\tif (prop) {\n\t\t\t*idx = cur_idx;\n\t\t\treturn prop;\n\t\t}\n\t\tnb_in_pid = cur_idx;\n\t\tcur_idx = *idx - nb_in_pid;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tu32 sub_idx = cur_idx;\n\t\tconst GF_PropertyValue * prop;\n\t\tGF_FilterPid *pidinst = gf_list_get(pid->filter->input_pids, i);\n\t\tprop = gf_filter_pid_enum_info((GF_FilterPid *)pidinst, &sub_idx, prop_4cc, prop_name);\n\t\tif (prop) {\n\t\t\t*idx = nb_in_pid + sub_idx;\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn prop;\n\t\t}\n\t\tnb_in_pid += sub_idx;\n\t\tcur_idx = *idx - nb_in_pid;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn NULL;\n}\n\n\nstatic const GF_PropertyValue *gf_filter_get_info_internal(GF_Filter *filter, u32 prop_4cc, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tu32 i;\n\tconst GF_PropertyValue *prop=NULL;\n\n\tgf_mx_p(filter->session->info_mx);\n\tgf_mx_p(filter->tasks_mx);\n\n\t//TODO avoid doing back and forth ...\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tprop = gf_filter_pid_get_info_internal(pid, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tgf_mx_v(filter->session->info_mx);\n\t\t\treturn prop;\n\t\t}\n\t}\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidinst = gf_list_get(filter->input_pids, i);\n\t\tprop = gf_filter_pid_get_info_internal(pidinst->pid, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tgf_mx_v(filter->session->info_mx);\n\t\t\treturn prop;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\tgf_mx_v(filter->session->info_mx);\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_get_info(GF_Filter *filter, u32 prop_4cc, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_get_info_internal(filter, prop_4cc, NULL, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_get_info_str(GF_Filter *filter, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_get_info_internal(filter, 0, prop_name, propentry);\n}\n\nGF_EXPORT\nvoid gf_filter_release_property(GF_PropertyEntry *propentry)\n{\n\tif (propentry) {\n\t\tgf_props_del_property(propentry);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_reset_properties(GF_FilterPid *pid)\n{\n\tGF_PropertyMap *map;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset all properties on input PID in filter %s - ignoring\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//don't merge properties, we will reset them anyway\n\tmap = check_new_pid_props(pid, GF_FALSE);\n\n\tif (!map) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tgf_props_reset(map);\n\treturn GF_OK;\n\n}\n\nstatic GF_Err gf_filter_pid_merge_properties_internal(GF_FilterPid *dst_pid, GF_FilterPid *src_pid, gf_filter_prop_filter filter_prop, void *cbk, Bool is_merge)\n{\n\tGF_PropertyMap *dst_props, *src_props = NULL, *old_dst_props=NULL;\n\tif (PID_IS_INPUT(dst_pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset all properties on input PID in filter %s - ignoring\\n\", dst_pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_merge) {\n\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\told_dst_props = gf_list_last(dst_pid->properties);\n\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t}\n\n\t//don't merge properties with old state we merge with source pid\n\tdst_props = check_new_pid_props(dst_pid, GF_FALSE);\n\n\tif (!dst_props) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", dst_pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\t//if pid is input, use the current properties - cf filter_pid_get_prop_map\n\tif (PID_IS_INPUT(src_pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)src_pid;\n\t\tif (!pidi->props) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\t\tpidi->props = gf_list_get(src_pid->pid->properties, 0);\n\t\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t\t\tassert(pidi->props);\n\t\t\tsafe_int_inc(&pidi->props->reference_count);\n\t\t}\n\t\tsrc_props = pidi->props;\n\t}\n\t//move to rela pid\n\tsrc_pid = src_pid->pid;\n\t//this is a copy props on output pid\n\tif (!src_props) {\n\t\t//our list is not thread-safe, so we must lock the filter when destroying the props\n\t\t//otherwise gf_list_last() (this caller) might use the last entry while another thread sets this last entry to NULL\n\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\tsrc_props = gf_list_last(src_pid->properties);\n\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t\tif (!src_props) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties to copy from pid %s in filter %s, ignoring merge\\n\", src_pid->name, src_pid->filter->name));\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (src_pid->name && !old_dst_props)\n\t\tgf_filter_pid_set_name(dst_pid, src_pid->name);\n\n\tif (!is_merge) {\n\t\tgf_props_reset(dst_props);\n\t} else {\n\t\t//we created a new map\n\t\tif (old_dst_props && (old_dst_props!=dst_props)) {\n\t\t\tGF_Err e = gf_props_merge_property(dst_props, old_dst_props, NULL, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn gf_props_merge_property(dst_props, src_props, filter_prop, cbk);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_merge_properties(GF_FilterPid *dst_pid, GF_FilterPid *src_pid, gf_filter_prop_filter filter_prop, void *cbk )\n{\n\treturn gf_filter_pid_merge_properties_internal(dst_pid, src_pid, filter_prop, cbk, GF_TRUE);\n}\nGF_EXPORT\nGF_Err gf_filter_pid_copy_properties(GF_FilterPid *dst_pid, GF_FilterPid *src_pid)\n{\n\treturn gf_filter_pid_merge_properties_internal(dst_pid, src_pid, NULL, NULL, GF_FALSE);\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_packet_count(GF_FilterPid *pid)\n{\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tpidinst = gf_list_get(pid->destinations, 0);\n\t\tif (! pidinst) return 0;\n\t\treturn gf_fq_count(pidinst->packets) - pidinst->nb_eos_signaled - pidinst->nb_clocks_signaled;\n\n\t} else {\n\t\tif (pidinst->discard_packets) return 0;\n\t\treturn gf_fq_count(pidinst->packets) - pidinst->nb_eos_signaled - pidinst->nb_clocks_signaled;\n\t}\n}\n\nstatic Bool gf_filter_pid_filter_internal_packet(GF_FilterPidInst *pidi, GF_FilterPacketInstance *pcki)\n{\n\tBool is_internal = GF_FALSE;\n\tu32 ctype = (pcki->pck->info.flags & GF_PCK_CMD_MASK);\n\tif (ctype == GF_PCK_CMD_PID_EOS ) {\n\t\tpcki->pid->is_end_of_stream = pcki->pid->pid->has_seen_eos ? GF_TRUE : GF_FALSE;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found EOS packet in PID %s in filter %s - eos %d\\n\", pidi->pid->name, pidi->filter->name, pcki->pid->pid->has_seen_eos));\n\t\tassert(pcki->pid->nb_eos_signaled);\n\t\tsafe_int_dec(&pcki->pid->nb_eos_signaled);\n\t\tis_internal = GF_TRUE;\n\t} else if (ctype == GF_PCK_CMD_PID_REM) {\n\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_disconnect_task, pidi->filter, pidi->pid, \"pidinst_disconnect\", NULL);\n\n\t\tis_internal = GF_TRUE;\n\t}\n\tctype = (pcki->pck->info.flags & GF_PCK_CKTYPE_MASK) >> GF_PCK_CKTYPE_POS;\n\n\tif (ctype) {\n\t\tu32 timescale;\n\t\tif (pcki->pid->handles_clock_references) return GF_FALSE;\n\t\tassert(pcki->pid->nb_clocks_signaled);\n\t\tsafe_int_dec(&pcki->pid->nb_clocks_signaled);\n\t\t//signal destination\n\t\tassert(!pcki->pid->filter->next_clock_dispatch_type || !pcki->pid->filter->num_output_pids);\n\n\t\ttimescale = pcki->pck->pid_props ? pcki->pck->pid_props->timescale : 0;\n\t\tpcki->pid->filter->next_clock_dispatch = pcki->pck->info.cts;\n\t\tpcki->pid->filter->next_clock_dispatch_timescale = timescale;\n\t\tpcki->pid->filter->next_clock_dispatch_type = ctype;\n\n\t\t//keep clock values but only override clock type if no discontinuity is pending\n\t\tpcki->pid->last_clock_value = pcki->pck->info.cts;\n\t\tpcki->pid->last_clock_timescale = timescale;\n\t\tif (pcki->pid->last_clock_type != GF_FILTER_CLOCK_PCR_DISC)\n\t\t\tpcki->pid->last_clock_type = ctype;\n\n\t\tif (ctype == GF_FILTER_CLOCK_PCR_DISC) {\n\t\t\tassert(pcki->pid->last_clock_type == GF_FILTER_CLOCK_PCR_DISC);\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Internal clock reference packet filtered - PID %s clock ref \"LLU\"/%d - type %d\\n\", pcki->pid->pid->name, pcki->pid->last_clock_value, pcki->pid->last_clock_timescale, pcki->pid->last_clock_type));\n\t\t//the following call to drop_packet will trigger clock forwarding to all output pids\n\t\tis_internal = GF_TRUE;\n\t}\n\n\tif (is_internal) gf_filter_pid_drop_packet((GF_FilterPid *)pidi);\n\treturn is_internal;\n}\n\nstatic Bool filter_pck_check_prop_change(GF_FilterPidInst *pidinst, GF_FilterPacketInstance *pcki, Bool do_notif)\n{\n\tif ( (pcki->pck->info.flags & GF_PCKF_PROPS_CHANGED) && !pcki->pid_props_change_done) {\n\t\tGF_Err e;\n\t\tBool skip_props = GF_FALSE;\n\n\t\tpcki->pid_props_change_done = 1;\n\n\t\t//it may happen that:\n\t\t//- the props are not set when querying the first packet (no prop queries on pid)\n\t\t//- the new props are already set if filter_pid_get_property was queried before the first packet dispatch\n\t\tif (pidinst->props) {\n\t\t\tif (pidinst->force_reconfig || (pidinst->props != pcki->pck->pid_props)) {\n\t\t\t\t//destroy if last occurence, removing it from pid as well\n\t\t\t\t//only remove if last about to be destroyed, since we may have several pid instances consuming from this pid\n\t\t\t\tassert(pidinst->props->reference_count);\n\t\t\t\tif (safe_int_dec(& pidinst->props->reference_count) == 0) {\n\t\t\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\t\t\tgf_props_del(pidinst->props);\n\t\t\t\t}\n\t\t\t\tpidinst->force_reconfig = GF_FALSE;\n\t\t\t\t//set new one\n\t\t\t\tpidinst->props = pcki->pck->pid_props;\n\t\t\t\tsafe_int_inc( & pidinst->props->reference_count );\n\t\t\t} else {\n\t\t\t\t//it may happen that pid_configure for destination was called after packet being dispatched, in\n\t\t\t\t//which case we are already properly configured\n\t\t\t\tskip_props = GF_TRUE;\n\t\t\t\tif (do_notif) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s was already configured with the last property set, ignoring reconfigure\\n\", pidinst->pid->filter->name, pidinst->pid->name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!skip_props) {\n\t\t\tif (do_notif) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s property changed at this packet, triggering reconfigure\\n\", pidinst->pid->filter->name, pidinst->pid->name));\n\n\t\t\t\tassert(pidinst->filter->freg->configure_pid);\n\t\t\t}\n\n\t\t\t//reset the blacklist whenever reconfiguring, since we may need to reload a new filter chain\n\t\t\t//in which a previously blacklisted filter (failing (re)configure for previous state) could\n\t\t\t//now work, eg moving from formatA to formatB then back to formatA\n\t\t\tgf_list_reset(pidinst->filter->blacklisted);\n\n\t\t\tif (do_notif) {\n\t\t\t\te = gf_filter_pid_configure(pidinst->filter, pidinst->pid, GF_PID_CONF_RECONFIG);\n\t\t\t\tif (e != GF_OK) return GF_TRUE;\n\t\t\t\tif (pidinst->pid->caps_negociate)\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_FilterPacket *gf_filter_pid_get_packet(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to fetch a packet on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (pidinst->discard_packets || (!pidinst->force_flush && pidinst->detach_pending)) {\n\t\tpidinst->filter->nb_pck_io++;\n\t\treturn NULL;\n\t}\n\nrestart:\n\tpcki = (GF_FilterPacketInstance *)gf_fq_head(pidinst->packets);\n\t//no packets\n\tif (!pcki) {\n\t\tif (!pidinst->pid || !pidinst->pid->filter || !pidinst->filter) return NULL;\n\t\tif (pidinst->pid->filter->disabled) {\n\t\t\tpidinst->is_end_of_stream = pidinst->pid->has_seen_eos = GF_TRUE;\n\t\t}\n\t\tif (!pidinst->is_end_of_stream && pidinst->pid->filter->would_block)\n\t\t\tgf_filter_pid_check_unblock(pidinst->pid);\n\t\tpidinst->filter->nb_pck_io++;\n\t\treturn NULL;\n\t}\n\tassert(pcki->pck);\n\n\tif (gf_filter_pid_filter_internal_packet(pidinst, pcki)) {\n\t\t//avoid recursion\n\t\tgoto restart;\n\t}\n\tpcki->pid->is_end_of_stream = GF_FALSE;\n\n\tif (filter_pck_check_prop_change(pidinst, pcki, GF_TRUE))\n\t\treturn NULL;\n\n\tif ( (pcki->pck->info.flags & GF_PCKF_INFO_CHANGED) && !pcki->pid_info_change_done) {\n\t\tBool res=GF_FALSE;\n\n\t\t//it may happen that this filter pid is pulled from another thread than ours (eg audio callback), in which case\n\t\t//we cannot go reentrant, we have to wait until the filter is not in use ...\n\t\tif (pidinst->filter->freg->process_event && pidinst->filter->process_th_id && (pidinst->filter->process_th_id != gf_th_id()) ) {\n\t\t\treturn NULL;\n\t\t}\n\t\tpcki->pid_info_change_done = 1;\n\n\t\tif (pidinst->filter->freg->process_event) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_INFO_UPDATE, pid);\n\n\t\t\t//the following may fail when some filters use threading on their own\n\t\t\t//FSESS_CHECK_THREAD(pidinst->filter)\n\t\t\tres = pidinst->filter->freg->process_event(pidinst->filter, &evt);\n\t\t}\n\t\t\n\t\tif (!res) {\n\t\t\tpidinst->filter->pid_info_changed = GF_TRUE;\n\t\t}\n\t}\n\tpidinst->last_pck_fetch_time = gf_sys_clock_high_res();\n\n\treturn (GF_FilterPacket *)pcki;\n}\n\nstatic GF_FilterPacketInstance *gf_filter_pid_probe_next_packet(GF_FilterPidInst *pidinst)\n{\n\tu32 i=0;\n\t//get first packet that is not an internal command\n\t//if packet is a clock, consume it\n\twhile (1) {\n\t\tGF_FilterPacketInstance *pcki = (GF_FilterPacketInstance *)gf_fq_get(pidinst->packets, i);\n\t\tif (!pcki) break;\n\t\ti++;\n\n\t\tu32 ctype = (pcki->pck->info.flags & GF_PCK_CMD_MASK);\n\t\tif (ctype == GF_PCK_CMD_PID_EOS ) {\n\t\t\tbreak;\n\t\t} else if (ctype == GF_PCK_CMD_PID_REM) {\n\t\t\tbreak;\n\t\t}\n\t\tctype = (pcki->pck->info.flags & GF_PCK_CKTYPE_MASK) >> GF_PCK_CKTYPE_POS;\n\n\t\tif (ctype) {\n\t\t\tif (pcki->pid->handles_clock_references) return NULL;\n\n\t\t\tgf_filter_pid_filter_internal_packet(pidinst, pcki);\n\t\t\treturn gf_filter_pid_probe_next_packet(pidinst);\n\t\t}\n\t\treturn pcki;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_filter_pid_get_first_packet_cts(GF_FilterPid *pid, u64 *cts)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pidinst->discard_packets) return GF_FALSE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_FALSE;\n\t}\n\tassert(pcki->pck);\n\tif (pidinst->requires_full_data_block && !(pcki->pck->info.flags & GF_PCKF_BLOCK_END))\n\t\treturn GF_FALSE;\n\n\tGF_PropertyMap *map = gf_list_get(pidinst->pid->properties, 0);\n\tif (map)\n\t\t*cts = gf_timestamp_rescale(pcki->pck->info.cts, pcki->pck->pid_props->timescale, map->timescale);\n\telse\n\t\t*cts = pcki->pck->info.cts;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_first_packet_is_empty(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_TRUE;\n\t}\n\tif (pidinst->discard_packets) return GF_TRUE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_TRUE;\n\t}\n\tassert(pcki->pck);\n\n\tif (pidinst->requires_full_data_block && !(pcki->pck->info.flags & GF_PCKF_BLOCK_END))\n\t\treturn GF_TRUE;\n\treturn (pcki->pck->data_length || pcki->pck->frame_ifce) ? GF_FALSE : GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_first_packet_is_blocking_ref(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pidinst->discard_packets) return GF_FALSE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_FALSE;\n\t}\n\tassert(pcki->pck);\n\treturn gf_filter_pck_is_blocking_ref(pcki->pck);\n}\n\n\nstatic void gf_filter_pidinst_update_stats(GF_FilterPidInst *pidi, GF_FilterPacket *pck)\n{\n\tu64 now = gf_sys_clock_high_res();\n\tu64 dec_time = now - pidi->last_pck_fetch_time;\n\tif (pck->info.flags & GF_PCK_CMD_MASK) return;\n\tif (!pidi->filter || pidi->pid->filter->removed) return;\n\n\tpidi->filter->nb_pck_processed++;\n\tpidi->filter->nb_bytes_processed += pck->data_length;\n\n\tpidi->total_process_time += dec_time;\n\tif (!pidi->nb_processed) {\n\t\tpidi->first_frame_time = pidi->last_pck_fetch_time;\n\t}\n\n\tpidi->nb_processed++;\n\tif (pck->info.flags & GF_PCK_SAP_MASK) {\n\t\tpidi->nb_sap_processed ++;\n\t\tif (dec_time > pidi->max_sap_process_time) pidi->max_sap_process_time = dec_time;\n\t\tpidi->total_sap_process_time += dec_time;\n\t}\n\n\tif (dec_time > pidi->max_process_time) pidi->max_process_time = dec_time;\n\n\tif (pck->data_length) {\n\t\tBool has_ts = GF_TRUE;\n\t\tu64 ts = (pck->info.dts != GF_FILTER_NO_TS) ? pck->info.dts : pck->info.cts;\n\t\tif ((ts != GF_FILTER_NO_TS) && pck->pid_props && pck->pid_props->timescale) {\n\t\t\tts = gf_timestamp_rescale(ts, pck->pid_props->timescale, 1000000);\n\t\t} else {\n\t\t\thas_ts = GF_FALSE;\n\t\t}\n\t\t\n\t\tif (!pidi->cur_bit_size) {\n\t\t\tpidi->stats_start_ts = ts;\n\t\t\tpidi->stats_start_us = now;\n\t\t\tpidi->cur_bit_size = 8*pck->data_length;\n\t\t} else {\n\t\t\tBool flush_stats = GF_FALSE;\n\t\t\tpidi->cur_bit_size += 8*pck->data_length;\n\n\t\t\tif (has_ts) {\n\t\t\t\tif (pidi->stats_start_ts + 1000000 <= ts) flush_stats = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (pidi->stats_start_us + 1000000 <= now) flush_stats = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (flush_stats) {\n\t\t\t\tu64 rate;\n\t\t\t\tu64 diff_t;\n\n\t\t\t\tif (has_ts) {\n\t\t\t\t\trate = pidi->cur_bit_size;\n\t\t\t\t\trate *= 1000000;\n\t\t\t\t\tdiff_t = ts - pidi->stats_start_ts;\n\t\t\t\t\tif (!diff_t) diff_t = 1;\n \t\t\t\t\trate /= diff_t;\n\t\t\t\t\tpidi->avg_bit_rate = (u32) rate;\n\t\t\t\t\tif (pidi->avg_bit_rate > pidi->max_bit_rate) pidi->max_bit_rate = pidi->avg_bit_rate;\n\t\t\t\t}\n\n\t\t\t\trate = pidi->cur_bit_size;\n\t\t\t\trate *= 1000000;\n\t\t\t\tdiff_t = now - pidi->stats_start_us;\n\t\t\t\tif (!diff_t) diff_t = 1;\n\t\t\t\trate /= diff_t;\n\t\t\t\tpidi->avg_process_rate = (u32) rate;\n\t\t\t\tif (pidi->avg_process_rate > pidi->max_process_rate) pidi->max_process_rate = pidi->avg_process_rate;\n\n\t\t\t\t//reset stats\n\t\t\t\tpidi->cur_bit_size = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void gf_filter_pidinst_reset_stats(GF_FilterPidInst *pidi)\n{\n\tpidi->last_pck_fetch_time = 0;\n\tpidi->stats_start_ts = 0;\n\tpidi->stats_start_us = 0;\n\tpidi->cur_bit_size = 0;\n\tpidi->avg_bit_rate = 0;\n\tpidi->max_bit_rate = 0;\n\tpidi->avg_process_rate = 0;\n\tpidi->max_process_rate = 0;\n\tpidi->nb_processed = 0;\n\tpidi->nb_sap_processed = 0;\n\tpidi->total_process_time = 0;\n\tpidi->total_sap_process_time = 0;\n\tpidi->max_process_time = 0;\n\tpidi->max_sap_process_time = 0;\n\tpidi->first_frame_time = 0;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_drop_packet(GF_FilterPid *pid)\n{\n#ifdef GPAC_MEMORY_TRACKING\n\tu32 prev_nb_allocs, prev_nb_reallocs, nb_allocs, nb_reallocs;\n#endif\n\tu32 timescale = 0;\n\tu32 nb_pck=0;\n\tGF_FilterPacket *pck=NULL;\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to discard a packet on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn;\n\t}\n\tif (pidinst->filter)\n\t\tpidinst->filter->nb_pck_io++;\n\n\t//remove pck instance\n\tpcki = gf_fq_pop(pidinst->packets);\n\n\tif (!pcki) {\n\t\tif (pidinst->filter && !pidinst->filter->finalized && !pidinst->discard_packets) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to discard a packet already discarded in filter %s\\n\", pid->filter->name));\n\t\t}\n\t\treturn;\n\t}\n\n\tgf_rmt_begin(pck_drop, GF_RMT_AGGREGATE);\n\tpck = pcki->pck;\n\t//move to source pid\n\tpid = pid->pid;\n\tif (pck->pid_props)\n\t\ttimescale = pck->pid_props->timescale;\n\n\t//if not detached, undo main_thread flag - cf gf_filter_instance_detach_pid\n\tif (pidinst->filter && (pck->info.flags & GF_PCKF_FORCE_MAIN)) {\n\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t}\n\n\tgf_filter_pidinst_update_stats(pidinst, pck);\n\tif (timescale && (pck->info.cts!=GF_FILTER_NO_TS)) {\n\t\tpidinst->last_ts_drop.num = pck->info.cts;\n\t\tpidinst->last_ts_drop.den = timescale;\n\t}\n\n\n\t//make sure we lock the tasks mutex before getting the packet count, otherwise we might end up with a wrong number of packets\n\t//if one thread (the caller here) consumes one packet while the dispatching thread is still upddating the state for that pid\n\tgf_mx_p(pid->filter->tasks_mx);\n\tnb_pck = gf_fq_count(pidinst->packets);\n\n\tif (!nb_pck) {\n\t\tsafe_int64_sub(&pidinst->buffer_duration, pidinst->buffer_duration);\n\t} else if (pck->info.duration && (pck->info.flags & GF_PCKF_BLOCK_START) && timescale) {\n\t\ts64 d = gf_timestamp_rescale(pck->info.duration, timescale, 1000000);\n\t\tif (d > pidinst->buffer_duration) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Corrupted buffer level in PID instance %s (%s -> %s), dropping packet duration \"LLD\" us greater than buffer duration \"LLU\" us\\n\", pid->name, pid->filter->name, pidinst->filter ? pidinst->filter->name : \"disconnected\", d, pidinst->buffer_duration));\n\t\t\td = pidinst->buffer_duration;\n\t\t}\n\t\tassert(d <= pidinst->buffer_duration);\n\t\tsafe_int64_sub(&pidinst->buffer_duration, (s32) d);\n\t}\n\n\tif ( (pid->num_destinations==1) || (pid->filter->session->blocking_mode==GF_FS_NOBLOCK_FANOUT)) {\n\t\tif (nb_pck<pid->nb_buffer_unit) {\n\t\t\tpid->nb_buffer_unit = nb_pck;\n\t\t}\n\t\tif (!pid->buffer_duration || (pidinst->buffer_duration < (s64) pid->buffer_duration)) {\n\t\t\tpid->buffer_duration = pidinst->buffer_duration;\n\t\t}\n\t}\n\t//handle fan-out: we must browse all other pid instances and compute max buffer/nb_pck per pids\n\t//so that we don't unblock the PID if some instance is still blocking\n\telse {\n\t\tu32 i;\n\t\tu32 min_pck = nb_pck;\n\t\ts64 min_dur = pidinst->buffer_duration;\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(pid->destinations, i);\n\t\t\tif (a_pidi==pidinst) continue;\n\t\t\tif (a_pidi->buffer_duration > min_dur)\n\t\t\t\tmin_dur = a_pidi->buffer_duration;\n\t\t\tnb_pck = gf_fq_count(a_pidi->packets);\n\t\t\tif (nb_pck>min_pck)\n\t\t\t\tmin_pck = nb_pck;\n\t\t}\n\t\tpid->buffer_duration = min_dur;\n\t\tpid->nb_buffer_unit = min_pck;\n\t}\n\tgf_filter_pid_check_unblock(pid);\n\n\tgf_mx_v(pid->filter->tasks_mx);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {\n\t\tu8 sap_type = (pck->info.flags & GF_PCK_SAP_MASK) >> GF_PCK_SAP_POS;\n\t\tBool seek_flag = (pck->info.flags & GF_PCKF_SEEK) ? 1 : 0;\n\n\t\tif ((pck->info.dts != GF_FILTER_NO_TS) && (pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.dts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t}\n\t}\n#endif\n\n\t//destroy pcki\n\tpcki->pck = NULL;\n\tpcki->pid = NULL;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&prev_nb_allocs, NULL, &prev_nb_reallocs, NULL);\n\t}\n#endif\n\n\tif (pid->filter->pcks_inst_reservoir) {\n\t\tgf_fq_add(pid->filter->pcks_inst_reservoir, pcki);\n\t} else {\n\t\tgf_free(pcki);\n\t}\n\t//unref pck\n\tassert(pck->reference_count);\n\tif (safe_int_dec(&pck->reference_count) == 0) {\n\t\tgf_filter_packet_destroy(pck);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&nb_allocs, NULL, &nb_reallocs, NULL);\n\n\t\tpid->filter->session->nb_alloc_pck += (nb_allocs - prev_nb_allocs);\n\t\tpid->filter->session->nb_realloc_pck += (nb_reallocs - prev_nb_reallocs);\n\t}\n#endif\n\n\t//decrement number of pending packet on target filter if this is not a destroy\n\tif (pidinst->filter) {\n\t\tassert(pidinst->filter->pending_packets);\n\t\tsafe_int_dec(&pidinst->filter->pending_packets);\n\n\t\tgf_filter_forward_clock(pidinst->filter);\n\t}\n\n\tgf_rmt_end();\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_eos(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\n\tif (pidi->detach_pending)\n\t\treturn GF_FALSE;\n\t\t\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (!pid->pid) return GF_TRUE;\n\tif (!pid->pid->has_seen_eos && !pidi->discard_inputs && !pidi->discard_packets) {\n\t\tpidi->is_end_of_stream = GF_FALSE;\n\t\treturn GF_FALSE;\n\t}\n\t//peek next for eos\n\tpcki = (GF_FilterPacketInstance *)gf_fq_head(pidi->packets);\n\tif (pcki)\n\t\tgf_filter_pid_filter_internal_packet(pidi, pcki);\n\n\tif (pidi->discard_packets && !pid->pid->filter->session->in_final_flush) return GF_FALSE;\n\tif (!pidi->is_end_of_stream) return GF_FALSE;\n\tif (!pidi->filter->eos_probe_state)\n\t\tpidi->filter->eos_probe_state = 1;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_eos(GF_FilterPid *pid)\n{\n\tGF_FilterPacket *pck;\n\t//allow NULL as input (most filters blindly call set_eos on output even if no output)\n\tif (!pid) return;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to signal EOS on input PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tif (pid->has_seen_eos) return;\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"EOS signaled on PID %s in filter %s\\n\", pid->name, pid->filter->name));\n\t//we create a fake packet for eos signaling\n\tpck = gf_filter_pck_new_shared_internal(pid, NULL, 0, NULL, GF_TRUE);\n\tif (!pck) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to allocate new packet for EOS on PID %s in filter %s\\n\", pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tpck->pck->info.flags |= GF_PCK_CMD_PID_EOS;\n\tgf_filter_pck_send(pck);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_enum_properties(GF_FilterPid *pid, u32 *idx, u32 *prop_4cc, const char **prop_name)\n{\n\tGF_PropertyMap *props;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tprops = pidi->props;\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t} else {\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tprops = gf_list_last(pid->properties);\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n\tif (!props) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for pid in filter %s, ignoring enum\\n\", pid->filter->name));\n\t\t*idx = 0xFFFFFFFF;\n\t\treturn NULL;\n\t}\n\treturn gf_props_enum_property(props, idx, prop_4cc, prop_name);\n}\n\nGF_EXPORT\nBool gf_filter_pid_would_block(GF_FilterPid *pid)\n{\n\tBool would_block=GF_FALSE;\n\tBool result=GF_FALSE;\n#ifdef DEBUG_BLOCKMODE\n\tBool blockmode_broken=GF_FALSE;\n#endif\n\tif (PID_IS_INPUT(pid)) {\n\t\tpid = pid->pid;\n\t\tif (pid->would_block) return GF_TRUE;\n\t\treturn GF_FALSE;\n\t}\n\n\tif (pid->filter->session->blocking_mode==GF_FS_NOBLOCK)\n\t\treturn GF_FALSE;\n\t//input pid(s) are being flushed, prevent blocking\n\tif (pid->filter->in_force_flush)\n\t\treturn GF_FALSE;\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\t//either block according to the number of dispatched units (decoder output) or to the requested buffer duration\n\tif (pid->max_buffer_unit) {\n\t\tif (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER >= pid->max_buffer_unit * pid->playback_speed_scaler) {\n\t\t\twould_block = GF_TRUE;\n\t\t}\n#ifdef DEBUG_BLOCKMODE\n\t\tif ((pid->num_destinations==1) && !pid->filter->blockmode_broken && ( (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER > 100 * pid->max_buffer_unit * pid->playback_speed_scaler) ) ) {\n\t\t\tblockmode_broken = GF_TRUE;\n\t\t}\n#endif\n\t} else if (pid->max_buffer_time) {\n\t\tif (pid->buffer_duration * GF_FILTER_SPEED_SCALER > pid->max_buffer_time * pid->playback_speed_scaler) {\n\t\t\twould_block = GF_TRUE;\n\t\t}\n#ifdef DEBUG_BLOCKMODE\n\t\tif ((pid->num_destinations==1) && !pid->filter->blockmode_broken && (pid->buffer_duration * GF_FILTER_SPEED_SCALER > 100 * pid->max_buffer_time * pid->playback_speed_scaler) ) {\n\t\t\tblockmode_broken = GF_TRUE;\n\t\t}\n#endif\n\t}\n\n#ifdef DEBUG_BLOCKMODE\n\tif (blockmode_broken) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Filter %s PID %s block mode not respected: %u units \"LLU\" us vs %u max units \"LLU\" max buffer\\n\", pid->pid->filter->name, pid->pid->name, pid->nb_buffer_unit, pid->buffer_duration, pid->max_buffer_unit, pid->max_buffer_time));\n\n\t\tpid->filter->blockmode_broken = GF_TRUE;\n\t}\n#endif\n\n\tresult = would_block;\n\t//if PID is sparse and filter has more than one active output:\n\t//- force the pid to move to blocking state\n\t//- return the true status so that filters checking gf_filter_pid_would_block will dispatch frame if any\n\t//\n\t//This avoids considering a demux filter (with e.g., AV+text) as non-blocking when all its non-sparse PIDs are blocked\n\tif (!pid->would_block && pid->is_sparse && !pid->not_connected\n\t\t&& (pid->filter->num_output_pids > 1+pid->filter->num_out_pids_not_connected)\n\t\t//don't do this if only sparse pids are connected\n\t\t&& (pid->filter->nb_sparse_pids + pid->filter->num_out_pids_not_connected < pid->filter->num_output_pids)\n\t)\n\t\twould_block = GF_TRUE;\n\n\tif (would_block && !pid->would_block) {\n\t\tsafe_int_inc(&pid->would_block);\n\t\tsafe_int_inc(&pid->filter->would_block);\n\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {\n\t\t\tif (pid->max_buffer_unit) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s blocked (%d units vs %d max units) - %d filter PIDs blocked\\n\", pid->pid->filter->name, pid->pid->name, pid->nb_buffer_unit, pid->max_buffer_unit, pid->filter->would_block));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s blocked (\"LLU\" us vs \"LLU\" max buffer) - %d filter PIDs blocked\\n\", pid->pid->filter->name, pid->pid->name, pid->buffer_duration, pid->max_buffer_time, pid->filter->would_block));\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tassert(pid->filter->would_block <= pid->filter->num_output_pids);\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn result;\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_sparse(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FALSE;\n\treturn pid->pid->is_sparse;\n}\n\nstatic u64 gf_filter_pid_query_buffer_duration_internal(GF_FilterPid *pid, Bool check_pid_full, Bool force_update)\n{\n\tu32 count, i, j;\n\tu64 duration=0;\n\tif (!pid || pid->filter->session->in_final_flush)\n\t\treturn GF_FILTER_NO_TS;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_Filter *filter;\n\t\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\t\tif (!pidinst->pid) return 0;\n\t\tfilter = pidinst->pid->filter;\n\t\tif (check_pid_full) {\n\t\t\tu32 buffer_full = GF_FALSE;\n\t\t\tBool buffer_valid = GF_FALSE;\n\n\t\t\tif (pidinst->pid->max_buffer_unit) {\n\t\t\t\tbuffer_valid = GF_TRUE;\n\t\t\t\tif (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)\n\t\t\t\t\tbuffer_full = GF_TRUE;\n\t\t\t}\n\t\t\tif (pidinst->pid->max_buffer_time) {\n\t\t\t\tbuffer_valid = GF_TRUE;\n\t\t\t\tif (pidinst->pid->max_buffer_time<=pidinst->pid->buffer_duration)\n\t\t\t\t\tbuffer_full = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (buffer_valid) {\n\t\t\t\tif (!buffer_full) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)\n\t\t\t\t\treturn GF_FILTER_NO_TS;\n\t\t\t}\n\t\t}\n\n\t\t//this is a very costly recursive call until each source, and is likely to be an overkill\n\t\t//if many PIDs (large tiling configurations for example)\n\t\t//we cache the last computed value and only update every 10 ms\n\t\tif (!force_update && (pidinst->filter->last_schedule_task_time - pidinst->last_buf_query_clock < 10000)) {\n\t\t\treturn pidinst->last_buf_query_dur;\n\t\t}\n\t\tpidinst->last_buf_query_clock = pidinst->filter->last_schedule_task_time;\n\t\tforce_update = GF_TRUE;\n\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tcount = filter->num_input_pids;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 dur = gf_filter_pid_query_buffer_duration_internal( gf_list_get(filter->input_pids, i), GF_FALSE, force_update);\n\t\t\tif (dur > duration)\n\t\t\t\tduration = dur;\n\n\t\t\t//only probe for first pid when this is a mux or a reassembly filter\n\t\t\t//this is not as precise but avoids spending too much time here for very large number of input pids (tiling)\n\t\t\tif ((count>1) && (filter->num_output_pids==1))\n\t\t\t\tbreak;\n\t\t}\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tduration += pidinst->buffer_duration;\n\t\tpidinst->last_buf_query_dur = duration;\n\t\treturn duration;\n\t} else {\n\t\tu32 count2;\n\t\tu64 max_dur=0;\n\n\t\tif (check_pid_full) {\n\t\t\tif (pid->max_buffer_unit && (pid->max_buffer_unit>pid->nb_buffer_unit))\n\t\t\t\treturn 0;\n\t\t\tif (pid->max_buffer_time && (pid->max_buffer_time>pid->buffer_duration))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcount = pid->num_destinations;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPidInst *pidinst = gf_list_get(pid->destinations, i);\n\n\t\t\tcount2 = pidinst->filter->num_output_pids;\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_FilterPid *pid_n = gf_list_get(pidinst->filter->output_pids, i);\n\t\t\t\tu64 dur = gf_filter_pid_query_buffer_duration_internal(pid_n, GF_FALSE, GF_FALSE);\n\t\t\t\tif (dur > max_dur ) max_dur = dur;\n\t\t\t}\n\t\t}\n\t\tduration += max_dur;\n\t}\n\treturn duration;\n}\n\nGF_EXPORT\nu64 gf_filter_pid_query_buffer_duration(GF_FilterPid *pid, Bool check_pid_full)\n{\n\treturn gf_filter_pid_query_buffer_duration_internal(pid, check_pid_full, GF_FALSE);\n\n}\nGF_EXPORT\nBool gf_filter_pid_has_seen_eos(GF_FilterPid *pid)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->has_seen_eos) return GF_TRUE;\n\tif (pid->pid->filter->block_eos) return GF_FALSE;\n\tgf_mx_p(pid->pid->filter->tasks_mx);\n\tfor (i=0; i<pid->pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->filter->input_pids, i);\n\t\tif (gf_filter_pid_has_seen_eos((GF_FilterPid *) pidi)) {\n\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(pid->pid->filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_eos_received(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->has_seen_eos) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nGF_EXPORT\nconst char *gf_filter_event_name(GF_FEventType type)\n{\n\tswitch (type) {\n\tcase GF_FEVT_PLAY: return \"PLAY\";\n\tcase GF_FEVT_SET_SPEED: return \"SET_SPEED\";\n\tcase GF_FEVT_STOP: return \"STOP\";\n\tcase GF_FEVT_SOURCE_SEEK: return \"SOURCE_SEEK\";\n\tcase GF_FEVT_SOURCE_SWITCH: return \"SOURCE_SWITCH\";\n\tcase GF_FEVT_ATTACH_SCENE: return \"ATTACH_SCENE\";\n\tcase GF_FEVT_RESET_SCENE: return \"RESET_SCENE\";\n\tcase GF_FEVT_PAUSE: return \"PAUSE\";\n\tcase GF_FEVT_RESUME: return \"RESUME\";\n\tcase GF_FEVT_QUALITY_SWITCH: return \"QUALITY_SWITCH\";\n\tcase GF_FEVT_VISIBILITY_HINT: return \"VISIBILITY_HINT\";\n\tcase GF_FEVT_INFO_UPDATE: return \"INFO_UPDATE\";\n\tcase GF_FEVT_BUFFER_REQ: return \"BUFFER_REQ\";\n\tcase GF_FEVT_USER: return \"USER\";\n\tcase GF_FEVT_SEGMENT_SIZE: return \"SEGMENT_SIZE\";\n\tcase GF_FEVT_FRAGMENT_SIZE: return \"FRAGMENT_SIZE\";\n\tcase GF_FEVT_CAPS_CHANGE: return \"CAPS_CHANGED\";\n\tcase GF_FEVT_CONNECT_FAIL: return \"CONNECT_FAIL\";\n\tcase GF_FEVT_FILE_DELETE: return \"FILE_DELETE\";\n\tcase GF_FEVT_PLAY_HINT: return \"PLAY_HINT\";\n\tcase GF_FEVT_ENCODE_HINTS: return \"ENCODE_HINTS\";\n\tcase GF_FEVT_NTP_REF: return \"NTP_REF\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic void gf_filter_pid_reset_task_ex(GF_FSTask *task, Bool *had_eos)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)task->udta;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s input PID %s (from %s) resetting buffer\\n\", task->filter->name, pidi->pid->name, pidi->pid->filter->name ));\n\n\tif (had_eos) *had_eos = GF_FALSE;\n\n\t//aggregate any pending packet\n\tgf_filter_aggregate_packets(pidi);\n\n\t//trash packets without checking for internal commands except EOS any pending packet\n\twhile (gf_fq_count(pidi->packets)) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_head(pidi->packets);\n\t\tif ( (pcki->pck->info.flags & GF_PCK_CMD_MASK) == GF_PCK_CMD_PID_EOS) {\n\t\t\tif (had_eos)\n\t\t\t\t*had_eos = GF_TRUE;\n\t\t}\n\t\t//check props change otherwise we could accumulate pid properties no longer valid\n\t\tfilter_pck_check_prop_change(pidi, pcki, GF_FALSE);\n\n\t\tgf_filter_pid_drop_packet((GF_FilterPid *) pidi);\n\t}\n\n\tgf_filter_pidinst_reset_stats(pidi);\n\n\tassert(pidi->discard_packets);\n\tsafe_int_dec(&pidi->discard_packets);\n\n\tpidi->last_block_ended = GF_TRUE;\n\tpidi->first_block_started = GF_FALSE;\n\tpidi->is_end_of_stream = GF_FALSE;\n\tpidi->buffer_duration = 0;\n\tpidi->nb_eos_signaled = 0;\n\tpidi->pid->has_seen_eos = GF_FALSE;\n\tpidi->last_clock_type = 0;\n\n\tassert(pidi->pid->filter->stream_reset_pending);\n\tsafe_int_dec(& pidi->pid->filter->stream_reset_pending );\n\n\tpidi->pid->nb_buffer_unit = 0;\n\tpidi->pid->buffer_duration = 0;\n\tgf_filter_pid_check_unblock(pidi->pid);\n}\n\nstatic void gf_filter_pid_reset_task(GF_FSTask *task)\n{\n\tgf_filter_pid_reset_task_ex(task, NULL);\n}\n\nstatic void gf_filter_pid_reset_stop_task(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)task->udta;\n\tBool has_eos;\n\tgf_filter_pid_reset_task_ex(task, &has_eos);\n\tpidi->is_end_of_stream = has_eos;\n\tpidi->pid->has_seen_eos = has_eos;\n}\n\ntypedef struct\n{\n\tu32 ref_count;\n\tchar string[1];\n} GF_RefString;\n\n#define TO_REFSTRING(_v) _v ? (GF_RefString *) (_v - offsetof(GF_RefString, string)) : NULL\n\nstatic GF_RefString *evt_get_refstr(GF_FilterEvent *evt)\n{\n\tif (evt->base.type == GF_FEVT_FILE_DELETE) {\n\t\treturn TO_REFSTRING(evt->file_del.url);\n\t}\n\tif (evt->base.type == GF_FEVT_SOURCE_SWITCH) {\n\t\treturn TO_REFSTRING(evt->seek.source_switch);\n\t}\n\tif (evt->base.type == GF_FEVT_SEGMENT_SIZE) {\n\t\treturn TO_REFSTRING(evt->seg_size.seg_url);\n\t}\n\treturn NULL;\n}\nstatic GF_FilterEvent *dup_evt(GF_FilterEvent *evt)\n{\n\tGF_FilterEvent *an_evt;\n\tGF_RefString *rstr = evt_get_refstr(evt);\n\tan_evt = gf_malloc(sizeof(GF_FilterEvent));\n\tmemcpy(an_evt, evt, sizeof(GF_FilterEvent));\n\tif (rstr) {\n\t\tsafe_int_inc(&rstr->ref_count);\n\t}\n\treturn an_evt;\n}\n\nstatic void free_evt(GF_FilterEvent *evt)\n{\n\tGF_RefString *rstr = evt_get_refstr(evt);\n\tif (rstr) {\n\t\tassert(rstr->ref_count);\n\t\tif (safe_int_dec(&rstr->ref_count) == 0) {\n\t\t\tgf_free(rstr);\n\t\t}\n\t}\n\tgf_free(evt);\n}\n\nstatic GF_FilterEvent *init_evt(GF_FilterEvent *evt)\n{\n\tchar **url_addr_src = NULL;\n\tchar **url_addr_dst = NULL;\n\tGF_FilterEvent *an_evt = gf_malloc(sizeof(GF_FilterEvent));\n\tmemcpy(an_evt, evt, sizeof(GF_FilterEvent));\n\n\tif (evt->base.type==GF_FEVT_FILE_DELETE) {\n\t\turl_addr_src = (char **) &evt->file_del.url;\n\t\turl_addr_dst = (char **) &an_evt->file_del.url;\n\t} else if (evt->base.type==GF_FEVT_SOURCE_SWITCH) {\n\t\turl_addr_src = (char **) &evt->seek.source_switch;\n\t\turl_addr_dst = (char **) &an_evt->seek.source_switch;\n\t} else if (evt->base.type==GF_FEVT_SEGMENT_SIZE) {\n\t\turl_addr_src = (char **) &evt->seg_size.seg_url;\n\t\turl_addr_dst = (char **) &an_evt->seg_size.seg_url;\n\t}\n\tif (url_addr_src) {\n\t\tchar *url = *url_addr_src;\n\t\tif (!url) {\n\t\t\t*url_addr_dst = NULL;\n\t\t} else {\n\t\t\tu32 len = (u32) strlen(url);\n\t\t\tGF_RefString *rstr = gf_malloc(sizeof(GF_RefString) + sizeof(char)*len);\n\t\t\trstr->ref_count=1;\n\t\t\tstrcpy( (char *) &rstr->string[0], url);\n\t\t\t*url_addr_dst = (char *) &rstr->string[0];\n\t\t}\n\t}\n\treturn an_evt;\n}\n\n\nstatic Bool filter_pid_is_raw_source(GF_FilterPid *pid)\n{\n\tu32 i;\n\tBool res = GF_TRUE;\n\tif (!pid->raw_media) {\n\t\tif (pid->stream_type!=GF_STREAM_FILE)\n\t\t\treturn GF_FALSE;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (pidi->pid->nb_decoder_inputs) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tif (! filter_pid_is_raw_source(pidi->pid)) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn res;\n}\n\nvoid gf_filter_pid_send_event_downstream(GF_FSTask *task)\n{\n\tu32 i, count, nb_playing=0, nb_paused=0;\n\tBool canceled = GF_FALSE;\n\tBool forced_cancel = GF_FALSE;\n\tGF_FilterEvent *evt = task->udta;\n\tGF_Filter *f = task->filter;\n\tGF_List *dispatched_filters = NULL;\n\tGF_FilterPidInst *for_pidi = (GF_FilterPidInst *)task->pid;\n\n\tif (for_pidi && (for_pidi->pid == task->pid)) {\n\t\tfor_pidi = NULL;\n\t}\n\n\t//if stream reset task is posted, wait for it before processing this event\n\tif (f->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\t//if some pids are still detached, wait for the connection before processing this event\n\tif (f->detached_pid_inst) {\n\t\tTASK_REQUEUE(task)\n\t\ttask->can_swap = 1;\n\t\treturn;\n\t}\n\n\tif (evt->base.on_pid) {\n\t\tassert(evt->base.on_pid->filter->num_events_queued);\n\t\tsafe_int_dec(&evt->base.on_pid->filter->num_events_queued);\n\t}\n\tif (f->finalized) {\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\n\tif (for_pidi) {\n\t\t//update pid instance status\n\t\tswitch (evt->base.type) {\n\t\tcase GF_FEVT_PLAY:\n\t\tcase GF_FEVT_SOURCE_SEEK:\n\t\t\tfor_pidi->is_playing = GF_TRUE;\n\t\t\tfor_pidi->play_queued = 0;\n\t\t\tbreak;\n\t\tcase GF_FEVT_STOP:\n\t\t\tfor_pidi->is_playing = GF_FALSE;\n\t\t\tfor_pidi->stop_queued = 0;\n\t\t\tbreak;\n\t\tcase GF_FEVT_PAUSE:\n\t\t\tfor_pidi->is_paused = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_FEVT_RESUME:\n\t\t\tfor_pidi->is_paused = GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (evt->base.on_pid) {\n\t\tGF_FilterPid *pid = (GF_FilterPid *) evt->base.on_pid->pid;\n\t\t//we have destination for this pid but this is an event not targeting a dedicated pid instance, this\n\t\t//means this was a connect fail, do not process event as other parts of the graphs are using this filter\n\t\tif (pid->num_destinations && !for_pidi\n\t\t\t&& ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_STOP) || (evt->base.type==GF_FEVT_CONNECT_FAIL))\n\t\t) {\n\t\t\t//we incremented discard counter in gf_filter_pid_send_event_internal for stop, decrement\n\t\t\t//this typically happen when pid has 2 destinations, one OK and the other one failed to configure\n\t\t\tif (evt->base.type==GF_FEVT_STOP) {\n\t\t\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\t\t\tfor_pidi = gf_list_get(pid->destinations, i);\n\t\t\t\t\tif (for_pidi->discard_packets)\n\t\t\t\t\t\tsafe_int_dec(&for_pidi->discard_packets);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_evt(evt);\n\t\t\treturn;\n\t\t}\n\t\t//update number of playing/paused pids\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tif (pidi->is_playing) nb_playing++;\n\t\t\tif (pidi->is_paused) nb_paused++;\n\t\t}\n\t}\n\n\tif (evt->base.type == GF_FEVT_BUFFER_REQ) {\n\t\tif (!evt->base.on_pid) {\n\t\t\tfree_evt(evt);\n\t\t\treturn;\n\t\t}\n\t\t//, set buffering at this level if:\n\t\tif (\n\t\t\t//- pid is a decoder input\n\t\t\tevt->base.on_pid->nb_decoder_inputs\n\t\t\t//- buffer req event explicitly requested for this pid\n\t\t\t|| evt->buffer_req.pid_only\n\t\t\t//- pid is a raw media source\n\t\t\t|| filter_pid_is_raw_source(evt->base.on_pid)\n\t\t) {\n\t\t\tevt->base.on_pid->max_buffer_time = evt->base.on_pid->user_max_buffer_time = evt->buffer_req.max_buffer_us;\n\t\t\tevt->base.on_pid->user_max_playout_time = evt->buffer_req.max_playout_us;\n\t\t\tevt->base.on_pid->user_min_playout_time = evt->buffer_req.min_playout_us;\n\t\t\tevt->base.on_pid->max_buffer_unit = 0;\n\t\t\tevt->base.on_pid->user_buffer_forced = evt->buffer_req.pid_only;\n\t\t\t//update blocking state\n\t\t\tif (evt->base.on_pid->would_block)\n\t\t\t\tgf_filter_pid_check_unblock(evt->base.on_pid);\n\t\t\telse\n\t\t\t\tgf_filter_pid_would_block(evt->base.on_pid);\n\t\t\tcanceled = GF_TRUE;\n\t\t} else {\n\t\t\tevt->base.on_pid->user_buffer_forced = GF_FALSE;\n\t\t}\n\t} else if (evt->base.on_pid && (evt->base.type == GF_FEVT_PLAY)\n\t\t&& (evt->base.on_pid->pid->is_playing || (((GF_FilterPid *) evt->base.on_pid->pid)->not_connected==2))\n\t\t) {\n\t\tif (evt->base.on_pid->pid->is_playing) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is already playing, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t}\n\t\tfree_evt(evt);\n\t\treturn;\n\t} else if (evt->base.on_pid && (evt->base.type == GF_FEVT_STOP)\n\t\t&& (\n\t\t\t//stop request on pid already stop\n\t\t\t!evt->base.on_pid->pid->is_playing\n\t\t\t//fan out but some instances are still playing\n\t\t\t|| nb_playing\n\t\t)\n\t) {\n\t\tGF_FilterPid *pid = (GF_FilterPid *) evt->base.on_pid->pid;\n\n\t\tif (!evt->base.on_pid->pid->is_playing) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is not playing, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID has playing destinations, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t}\n\n\t\tgf_mx_p(f->tasks_mx);\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) gf_list_get(pid->destinations, i);\n\t\t\t//don't forget we pre-processed stop by incrementing the discard counter and setting discard_packets on pid instances\n\t\t\t//undo this\n\t\t\tif (pidi->discard_packets) {\n\t\t\t\tsafe_int_dec(&pidi->discard_packets);\n\t\t\t}\n\t\t}\n\t\tif (!evt->base.on_pid->pid->is_playing) {\n\t\t\tif ((f->num_input_pids==f->num_output_pids) && (f->num_input_pids==1)) {\n\t\t\t\tgf_filter_pid_set_discard(gf_list_get(f->input_pids, 0), GF_TRUE);\n\t\t\t}\n\t\t\tif (pid->not_connected)\n\t\t\t\tpid->not_connected = 2;\n\t\t}\n\t\tgf_mx_v(f->tasks_mx);\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//do not allow pause if already paused\n\telse if ((nb_paused>1) && (evt->base.type == GF_FEVT_PAUSE) ) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is already paused, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//do not allow resume if some instances are still paused\n\telse if (nb_paused && (evt->base.type == GF_FEVT_RESUME) ) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but some PID instances are still paused, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//cancel connect failure if some destinations are successfully connected\n\telse if ((evt->base.type==GF_FEVT_CONNECT_FAIL) && evt->base.on_pid->is_playing) {\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//otherwise process\n\telse {\n\t\t//reset EOS to false on source switch before executing the event, so that a filter may set a pid to EOS in the callback\n\t\tif (evt->base.type==GF_FEVT_SOURCE_SWITCH) {\n\t\t\t//if session has been aborted, cancel event - this avoids the dashin requesting a source switch on a source that is not yet over\n\t\t\tif (f->session->in_final_flush) {\n\t\t\t\tfree_evt(evt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (i=0; i<f->num_output_pids; i++) {\n\t\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, i);\n\t\t\t\tapid->has_seen_eos = GF_FALSE;\n\t\t\t\tgf_filter_pid_check_unblock(apid);\n\t\t\t}\n\t\t}\n\n\t\tif (f->freg->process_event) {\n\t\t\tFSESS_CHECK_THREAD(f)\n\t\t\tcanceled = f->freg->process_event(f, evt);\n\t\t}\n\t\tif (!canceled && (evt->base.type==GF_FEVT_STOP) && evt->play.forced_dash_segment_switch) {\n\t\t\tGF_FilterPidInst *pid_inst = gf_list_get(f->input_pids, 0);\n\t\t\t//input is source filter, cancel\n\t\t\tif (pid_inst && ((pid_inst->pid->filter->num_input_pids==0) || (pid_inst->pid->filter->freg->flags & GF_FS_REG_ACT_AS_SOURCE))) {\n\t\t\t\tcanceled = GF_TRUE;\n\t\t\t\tforced_cancel = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s processed event %s - canceled %s\\n\", f->name, evt->base.on_pid ? evt->base.on_pid->name : \"none\", gf_filter_event_name(evt->base.type), canceled ? \"yes\" : \"no\" ));\n\n\tif (evt->base.on_pid && ((evt->base.type == GF_FEVT_STOP) || (evt->base.type==GF_FEVT_SOURCE_SEEK) || (evt->base.type==GF_FEVT_PLAY)) ) {\n\t\tBool do_reset = GF_TRUE;\n\t\tGF_FilterPidInst *p = (GF_FilterPidInst *) evt->base.on_pid;\n\t\tGF_FilterPid *pid = p->pid;\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t//we need to force a PID reset when the first PLAY is > 0, since some filters may have dispatched packets during the initialization\n\t\t//phase\n\t\tif (evt->base.type==GF_FEVT_PLAY) {\n\t\t\tpid->is_playing = GF_TRUE;\n\t\t\tpid->filter->nb_pids_playing++;\n\t\t\tif (pid->initial_play_done) {\n\t\t\t\tdo_reset = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tpid->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range < 0.1)\n\t\t\t\t\tdo_reset = GF_FALSE;\n\t\t\t}\n\t\t} else if (evt->base.type==GF_FEVT_STOP) {\n\t\t\tpid->is_playing = GF_FALSE;\n\t\t\tpid->filter->nb_pids_playing--;\n\n\t\t\tif (pid->not_connected)\n\t\t\t\tpid->not_connected = 2;\n\t\t} else if (evt->base.type==GF_FEVT_SOURCE_SEEK) {\n\t\t\tpid->is_playing = GF_TRUE;\n\t\t\tpid->filter->nb_pids_playing++;\n\t\t}\n\t\tfor (i=0; i<pid->num_destinations && do_reset; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tpidi->last_clock_type = 0;\n\n\t\t\tif (!pidi->discard_packets) {\n\t\t\t\tsafe_int_inc(&pidi->discard_packets);\n\t\t\t}\n\n\t\t\tsafe_int_inc(& pid->filter->stream_reset_pending );\n\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\t\t//post task on destination filter\n\t\t\tif (evt->base.type==GF_FEVT_STOP)\n\t\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_reset_stop_task, pidi->filter, NULL, \"reset_stop_pid\", pidi);\n\t\t\telse\n\t\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_reset_task, pidi->filter, NULL, \"reset_pid\", pidi);\n\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t}\n\t\tpid->nb_reaggregation_pending = 0;\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n\t\n\tgf_mx_p(f->tasks_mx);\n\n\t//after  play or seek, request a process task for source filters or filters having pending packets\n\tif (!f->num_input_pids || f->pending_packets) {\n\t\tif ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\t\tgf_filter_post_process_task(f);\n\t\t}\n\t}\n\n\t//quick hack for filters with one input pid and one outout pid, set discard on/off on the input\n\t//this avoids cases like TS demux dispatching data to inactive filters not checking their input\n\t//which ends up in session deadlock (filter still flagged as active and with pending packets)\n\t//if more than one input or more than one output, only the filter can decide what to do if some of the\n\t//streams are active and other not\n\tif ((f->num_input_pids==f->num_output_pids) && (f->num_input_pids==1)) {\n\t\tGF_FilterPidInst *apidi = gf_list_get(f->input_pids, 0);\n\t\tif (apidi->pid) {\n\t\t\t//unlock before setting discard to avoid deadlocks during shutdown\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\tif (evt->base.type==GF_FEVT_STOP) {\n\t\t\t\tif (forced_cancel) {\n\t\t\t\t\t//we stop propagating the event to the source, but we must reset the source pid\n\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_TRUE);\n//\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_FALSE);\n\t\t\t\t} else if (!canceled) {\n\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else if (evt->base.type==GF_FEVT_PLAY) {\n\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_FALSE);\n\t\t\t}\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t}\n\t}\n\tgf_mx_v(f->tasks_mx);\n\n\tif ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_SET_SPEED)) {\n\t\tif (evt->base.on_pid) {\n\t\t\tu32 scaler = (u32)  ( (evt->play.speed<0) ? -evt->play.speed : evt->play.speed ) * GF_FILTER_SPEED_SCALER;\n\t\t\tif (!scaler) scaler = GF_FILTER_SPEED_SCALER;\n\t\t\tif (scaler != evt->base.on_pid->playback_speed_scaler) {\n\t\t\t\tu32 prev_scaler = evt->base.on_pid->playback_speed_scaler;\n\t\t\t\tevt->base.on_pid->playback_speed_scaler = scaler;\n\t\t\t\t//lowering speed, we may need to trigger blocking\n\t\t\t\tif (scaler<prev_scaler)\n\t\t\t\t\tgf_filter_pid_would_block(evt->base.on_pid);\n\t\t\t\t//increasing speed, we may want to unblock\n\t\t\t\telse\n\t\t\t\t\tgf_filter_pid_check_unblock(evt->base.on_pid);\n\t\t\t}\n\t\t}\n\t}\n\n\t//no more input pids\n\tgf_mx_p(f->tasks_mx);\n\tcount = f->num_input_pids;\n\tif (count==0) canceled = GF_TRUE;\n\n\tif (canceled) {\n\t\tfree_evt(evt);\n\t\tgf_mx_v(f->tasks_mx);\n\t\treturn;\n\t}\n\n\tif (!task->pid) dispatched_filters = gf_list_new();\n\n\t//otherwise forward event to each input PID\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterEvent *an_evt;\n\t\tGF_FilterPidInst *pid_inst = gf_list_get(f->input_pids, i);\n\t\tGF_FilterPid *pid = pid_inst->pid;\n\t\tif (!pid) continue;\n\n\t\tif (dispatched_filters) {\n\t\t\tif (gf_list_find(dispatched_filters, pid_inst->pid->filter) >=0 )\n\t\t\t\tcontinue;\n\n\t\t\tgf_list_add(dispatched_filters, pid_inst->pid->filter);\n\t\t}\n\n\t\t//mark pid instance as about to be reset to avoid processing PID destroy task before\n\t\tif ((evt->base.type == GF_FEVT_STOP) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\t\tsafe_int_inc(&pid_inst->discard_packets);\n\t\t}\n\n\t\tan_evt = dup_evt(evt);\n\t\tan_evt->base.on_pid = task->pid ? pid : NULL;\n\n\t\tsafe_int_inc(&pid->filter->num_events_queued);\n\t\t\n\t\tgf_fs_post_task_class(pid->filter->session, gf_filter_pid_send_event_downstream, pid->filter, task->pid ? (GF_FilterPid *) pid_inst : NULL, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n\t}\n\tgf_mx_v(f->tasks_mx);\n\tif (dispatched_filters) gf_list_del(dispatched_filters);\n\tfree_evt(evt);\n\treturn;\n}\n\nvoid gf_filter_pid_send_event_upstream(GF_FSTask *task)\n{\n\tu32 i, j;\n\tBool canceled = GF_FALSE;\n\tGF_FilterEvent *evt = task->udta;\n\tGF_Filter *f = task->filter;\n\n\tif (f->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tcanceled = f->freg->process_event ? f->freg->process_event(f, evt) : GF_FALSE;\n\tif (!canceled) {\n\t\tfor (i=0; i<f->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, i);\n\t\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\t\tGF_FilterEvent *an_evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(apid->destinations, j);\n\n\t\t\t\tan_evt = dup_evt(evt);\n\t\t\t\tan_evt->base.on_pid = (GF_FilterPid *)pidi;\n\t\t\t\tgf_fs_post_task_class(pidi->filter->session, gf_filter_pid_send_event_upstream, pidi->filter, NULL, \"upstream_event\", an_evt, TASK_TYPE_EVENT);\n\t\t\t}\n\t\t}\n\t}\n\tfree_evt(evt);\n}\n\nvoid gf_filter_pid_send_event_internal(GF_FilterPid *pid, GF_FilterEvent *evt, Bool force_downstream)\n{\n\tGF_FilterEvent *an_evt;\n\tGF_FilterPid *target_pid=NULL;\n\tBool upstream=GF_FALSE;\n\tif (!pid) {\n\t\tpid = evt->base.on_pid;\n\t\tif (!pid) return;\n\t}\n\t//filter is being shut down, prevent any event posting\n\tif (pid->filter->finalized) return;\n\n\tif ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;\n\n\tif (!force_downstream && PID_IS_OUTPUT(pid)) {\n\t\tupstream = GF_TRUE;\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s queuing %s event %s\\n\", pid->pid->filter->name, pid->pid->name, upstream ? \"upstream\" : \"downstream\", gf_filter_event_name(evt->base.type) ));\n\n\tif (upstream) {\n\t\tu32 i, j;\n\n\t\tan_evt = init_evt(evt);\n\n\t\tfor (i=0; i<pid->filter->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);\n\t\t\tif (evt->base.on_pid && (apid != evt->base.on_pid)) continue;\n\t\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\t\tGF_FilterEvent *up_evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(apid->destinations, j);\n\n\t\t\t\tup_evt = dup_evt(an_evt);\n\t\t\t\tup_evt->base.on_pid = (GF_FilterPid *)pidi;\n\t\t\t\tgf_fs_post_task_class(pidi->filter->session, gf_filter_pid_send_event_upstream, pidi->filter, NULL, \"upstream_event\", up_evt, TASK_TYPE_EVENT);\n\t\t\t}\n\t\t}\n\t\tfree_evt(an_evt);\n\t\treturn;\n\t}\n\n\n\tif ((evt->base.type == GF_FEVT_STOP)\n\t\t|| (evt->base.type == GF_FEVT_PLAY)\n\t\t|| (evt->base.type==GF_FEVT_SOURCE_SEEK)\n\t) {\n\t\tu32 i, nb_playing=0;\n\t\tBool do_reset = GF_TRUE;\n\t\tgf_mx_p(pid->pid->filter->tasks_mx);\n\n\t\tfor (i=0; i<pid->pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);\n\t\t\tif (pidi->is_playing || pidi->play_queued) nb_playing++;\n\t\t\tif (pidi->stop_queued) nb_playing--;\n\n\t\t\t//pre-check pid instance play state\n\t\t\tif (pidi == (GF_FilterPidInst *)evt->base.on_pid) {\n\t\t\t\t//if STOP and pid instance already stop, silently discard\n\t\t\t\tif ((evt->base.type == GF_FEVT_STOP) && !pidi->is_playing && !pidi->play_queued) {\n\t\t\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//if PLAY and pid instance already playing, silently discard\n\t\t\t\telse if ((evt->base.type == GF_FEVT_PLAY) && pidi->is_playing && !pidi->stop_queued) {\n\t\t\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//do not set discard_packets flag on pid instance when:\n\t\t//- pid has at least one active output and we play one\n\t\t//- pid has more than one active output and we stop one\n\t\tif (evt->base.type == GF_FEVT_STOP) {\n\t\t\tif (nb_playing>1)\n\t\t\t\tdo_reset = GF_FALSE;\n\n\t\t\tif (PID_IS_INPUT(pid)) {\n\t\t\t\t((GF_FilterPidInst*)evt->base.on_pid)->stop_queued = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (nb_playing)\n\t\t\t\tdo_reset = GF_FALSE;\n\t\t\tif (PID_IS_INPUT(pid)) {\n\t\t\t\t((GF_FilterPidInst*)evt->base.on_pid)->play_queued = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<pid->pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);\n\n\t\t\tif (!do_reset && (pidi != (GF_FilterPidInst*)evt->base.on_pid))\n\t\t\t\tcontinue;\n\n\t\t\tif (evt->base.type == GF_FEVT_PLAY) {\n\t\t\t\tpidi->is_end_of_stream = GF_FALSE;\n\t\t\t} else {\n\t\t\t\t//flag pid instance to discard all packets (cf above note)\n\t\t\t\tsafe_int_inc(&pidi->discard_packets);\n\t\t\t}\n\t\t}\n\n\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t}\n\n\tan_evt = init_evt(evt);\n\tif (evt->base.on_pid) {\n\t\ttarget_pid = evt->base.on_pid;\n\t\tan_evt->base.on_pid = evt->base.on_pid->pid;\n\t\tsafe_int_inc(&target_pid->pid->filter->num_events_queued);\n\t}\n\tgf_fs_post_task_class(pid->pid->filter->session, gf_filter_pid_send_event_downstream, pid->pid->filter, target_pid, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_send_event(GF_FilterPid *pid, GF_FilterEvent *evt)\n{\n\tif (!evt) return;\n\tif (evt->base.type==GF_FEVT_RESET_SCENE) return;\n\tif (evt->base.type==GF_FEVT_INFO_UPDATE) return;\n\n\tgf_filter_pid_send_event_internal(pid, evt, GF_FALSE);\n}\n\nGF_EXPORT\nvoid gf_filter_send_event(GF_Filter *filter, GF_FilterEvent *evt, Bool upstream)\n{\n\tGF_FilterEvent *an_evt;\n\tif (!filter) return;\n\tif (filter->multi_sink_target)\n\t\tfilter = filter->multi_sink_target;\n\n\t//filter is being shut down, prevent any event posting\n\tif (filter->finalized) return;\n\tif (!evt) return;\n\tif ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;\n\n\tif (evt->base.type==GF_FEVT_RESET_SCENE)\n\t\treturn;\n\n\tif (evt->base.on_pid && PID_IS_OUTPUT(evt->base.on_pid)) {\n\t\tgf_filter_pid_send_event_internal(evt->base.on_pid, evt, GF_FALSE);\n\t\treturn;\n\t}\n\n\t//switch and seek events are only sent on source filters\n\tif ((evt->base.type==GF_FEVT_SOURCE_SWITCH) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\tif (filter->num_input_pids && !(filter->freg->flags & GF_FS_REG_ACT_AS_SOURCE)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Sending %s event on non source filter %s is not allowed, discarding)\\n\", gf_filter_event_name(evt->base.type), filter->name));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tan_evt = init_evt(evt);\n\n\tif (evt->base.on_pid) {\n\t\tsafe_int_inc(&evt->base.on_pid->filter->num_events_queued);\n\t}\n\tif (upstream)\n\t\tgf_fs_post_task_class(filter->session, gf_filter_pid_send_event_upstream, filter, evt->base.on_pid, \"upstream_event\", an_evt, TASK_TYPE_EVENT);\n\telse\n\t\tgf_fs_post_task_class(filter->session, gf_filter_pid_send_event_downstream, filter, evt->base.on_pid, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n}\n\n\nGF_EXPORT\nvoid gf_filter_pid_exec_event(GF_FilterPid *pid, GF_FilterEvent *evt)\n{\n\t//filter is being shut down, prevent any event posting\n\tif (pid->pid->filter->finalized) return;\n\tif (! (pid->pid->filter->freg->flags &\tGF_FS_REG_MAIN_THREAD)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Executing event on PID %s created by filter %s not running on main thread, not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\n\tif (pid->pid->filter->freg->process_event) {\n\t\tif (evt->base.on_pid) evt->base.on_pid = evt->base.on_pid->pid;\n\t\tFSESS_CHECK_THREAD(pid->pid->filter)\n\t\tpid->pid->filter->freg->process_event(pid->pid->filter, evt);\n\t}\n}\n\n\nGF_EXPORT\nBool gf_filter_pid_is_filter_in_parents(GF_FilterPid *pid, GF_Filter *filter)\n{\n\tif (!pid || !filter) return GF_FALSE;\n\tpid = pid->pid;\n\treturn gf_filter_in_parent_chain(pid->filter, filter);\n}\n\n\n\nGF_EXPORT\nBool gf_filter_pid_share_origin(GF_FilterPid *pid, GF_FilterPid *other_pid)\n{\n    if (!pid || !other_pid) return GF_FALSE;\n    pid = pid->pid;\n    other_pid = other_pid->pid;\n    if (gf_filter_in_parent_chain(pid->filter, other_pid->filter))\n        return GF_TRUE;\n    if (gf_filter_in_parent_chain(other_pid->filter, pid->filter))\n        return GF_TRUE;\n    return GF_FALSE;\n}\n\nstatic void filter_pid_inst_collect_stats(GF_FilterPidInst *pidi, GF_FilterPidStatistics *stats)\n{\n\tif (!pidi->pid) return;\n\n\tstats->average_bitrate += pidi->avg_bit_rate;\n\tif (!stats->first_process_time || (stats->first_process_time > pidi->first_frame_time))\n\t\tstats->first_process_time = pidi->first_frame_time;\n\tif (stats->last_process_time < pidi->last_pck_fetch_time)\n\t\tstats->last_process_time = pidi->last_pck_fetch_time;\n\n\tstats->max_bitrate += pidi->max_bit_rate;\n\n\tif (stats->max_process_time < (u32) pidi->max_process_time)\n\t\tstats->max_process_time = (u32) pidi->max_process_time;\n\tif (stats->max_sap_process_time < (u32) pidi->max_sap_process_time)\n\t\tstats->max_sap_process_time = (u32) pidi->max_sap_process_time;\n\tif (!stats->min_frame_dur || (stats->min_frame_dur > pidi->pid->min_pck_duration))\n\t\tstats->min_frame_dur = pidi->pid->min_pck_duration;\n\tstats->nb_processed += pidi->nb_processed;\n\tstats->nb_saps += pidi->nb_sap_processed;\n\tstats->total_process_time += pidi->total_process_time;\n\tstats->total_sap_process_time += pidi->total_sap_process_time;\n\tstats->average_process_rate += pidi->avg_process_rate;\n\tstats->max_process_rate += pidi->max_process_rate;\n\n\tif (stats->nb_buffer_units < pidi->pid->nb_buffer_unit)\n\t\tstats->nb_buffer_units = pidi->pid->nb_buffer_unit;\n\tif (stats->max_buffer_time < pidi->pid->max_buffer_time)\n\t\tstats->max_buffer_time = pidi->pid->max_buffer_time;\n\n\tif (stats->max_playout_time < pidi->pid->user_max_playout_time)\n\t\tstats->max_playout_time = pidi->pid->user_max_playout_time;\n\tif (!stats->min_playout_time || (stats->min_playout_time > pidi->pid->user_min_playout_time))\n\t\tstats->min_playout_time = pidi->pid->user_min_playout_time;\n\n\tif (stats->buffer_time < pidi->pid->buffer_duration)\n\t\tstats->buffer_time = pidi->pid->buffer_duration;\n\n\tif (!stats->last_ts_drop.den\n\t\t|| gf_timestamp_less(stats->last_ts_drop.num, stats->last_ts_drop.den, pidi->last_ts_drop.num, pidi->last_ts_drop.den)\n\t) {\n\t\tstats->last_ts_drop = pidi->last_ts_drop;\n\t}\n\tif (!stats->last_ts_sent.den\n\t\t|| gf_timestamp_less(stats->last_ts_sent.num, stats->last_ts_sent.den, pidi->pid->last_ts_sent.num, pidi->pid->last_ts_sent.den)\n\t) {\n\t\tstats->last_ts_sent = pidi->pid->last_ts_sent;\n\t}\n\n\tif (pidi->last_rt_report) {\n\t\tstats->last_rt_report = pidi->last_rt_report;\n\t\tstats->rtt = pidi->rtt;\n\t\tstats->jitter = pidi->jitter;\n\t\tstats->loss_rate = pidi->loss_rate;\n\t}\n}\n\nstatic void filter_pid_collect_stats(GF_List *pidi_list, GF_FilterPidStatistics *stats)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(pidi_list); i++) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) gf_list_get(pidi_list, i);\n\t\tif (!pidi->pid) continue;\n\n\t\tfilter_pid_inst_collect_stats(pidi, stats);\n\t}\n}\n\n\nstatic GF_Filter *filter_locate_enc_dec_sink(GF_Filter *filter, Bool locate_decoder)\n{\n\tu32 i, j;\n\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *res;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (( (pidi->is_decoder_input || pid->user_buffer_forced) && locate_decoder)\n\t\t\t\t|| (pidi->is_encoder_input && !locate_decoder)\n\t\t\t)\n\t\t\t\treturn pidi->filter;\n\t\t\tres = filter_locate_enc_dec_sink(pidi->filter, locate_decoder);\n\t\t\tif (res) return res;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic GF_Filter *filter_locate_enc_dec_src(GF_Filter *filter, Bool locate_decoder)\n{\n\tu32 i;\n\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_Filter *res;\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif ((pidi->is_decoder_input && locate_decoder)\n\t\t\t|| (pidi->is_encoder_input && !locate_decoder)\n\t\t) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn filter;\n\t\t}\n\t\tres = filter_locate_enc_dec_sink(pidi->pid->filter, locate_decoder);\n\t\tif (res) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn res;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn NULL;\n}\n\nstatic GF_Filter *filter_locate_sink(GF_Filter *filter)\n{\n\tu32 i, j;\n\n\tif (!filter->num_output_pids) {\n\t\treturn filter;\n\t}\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *res;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tres = filter_locate_sink(pidi->filter);\n\t\t\tif (res) return res;\n\t\t}\n\t}\n\treturn NULL;\n}\nGF_EXPORT\nGF_Err gf_filter_pid_get_statistics(GF_FilterPid *pid, GF_FilterPidStatistics *stats, GF_FilterPidStatsLocation location)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tGF_Filter *filter=NULL;\n\tBool for_decoder=GF_TRUE;\n\n\tmemset(stats, 0, sizeof(GF_FilterPidStatistics) );\n\tif (!pidi->pid) {\n\t\tstats->disconnected = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\tswitch (location) {\n\tcase GF_STATS_LOCAL:\n\t\tif (PID_IS_OUTPUT(pid)) {\n\t\t\tfilter_pid_collect_stats(pid->destinations, stats);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tfilter_pid_inst_collect_stats(pidi, stats);\n\t\treturn GF_OK;\n\tcase GF_STATS_LOCAL_INPUTS:\n\t\tif (PID_IS_OUTPUT(pid)) {\n\t\t\tfilter_pid_collect_stats(pid->destinations, stats);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tfilter = pidi->pid->filter;\n\t\tbreak;\n\tcase GF_STATS_ENCODER_SOURCE:\n\t\tfor_decoder = GF_FALSE;\n\tcase GF_STATS_DECODER_SOURCE:\n\t\tfilter = filter_locate_enc_dec_src(pidi->pid->filter, for_decoder);\n\t\tbreak;\n\tcase GF_STATS_ENCODER_SINK:\n\t\tfor_decoder = GF_FALSE;\n\tcase GF_STATS_DECODER_SINK:\n\t\tfilter = filter_locate_enc_dec_sink(pidi->pid->filter, for_decoder);\n\t\tbreak;\n\tcase GF_STATS_SINK:\n\t\tfilter = filter_locate_sink(pidi->pid->filter);\n\t\tbreak;\n\t}\n\tif (!filter) {\n\t\treturn GF_NOT_FOUND;\n\t}\n\tgf_mx_p(filter->tasks_mx);\n\tfilter_pid_collect_stats(filter->input_pids, stats);\n\tgf_mx_v(filter->tasks_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_remove(GF_FilterPid *pid)\n{\n\tGF_FilterPacket *pck;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Removing PID input filter (%s:%s) not allowed\\n\", pid->filter->name, pid->pid->name));\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s removed output PID %s\\n\", pid->filter->name, pid->pid->name));\n\n\tif (pid->filter->removed) {\n\t\treturn;\n\t}\n\tif (pid->removed) {\n\t\treturn;\n\t}\n\tpid->removed = GF_TRUE;\n\tif (pid->filter->marked_for_removal || (pid->has_seen_eos && !pid->nb_buffer_unit)) {\n\t\tu32 i;\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_disconnect_task, pidi->filter, pidi->pid, \"pidinst_disconnect\", NULL);\n\t\t}\n\t\treturn;\n\t}\n\n\t//we create a fake packet for removal signaling\n\tpck = gf_filter_pck_new_shared_internal(pid, NULL, 0, NULL, GF_TRUE);\n\tif (!pck) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to allocate new packet for PID %s remove in filter %s\\n\", pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tpck->pck->info.flags |= GF_PCK_CMD_PID_REM;\n\tgf_filter_pck_send(pck);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_try_pull(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to pull from output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid = pid->pid;\n#ifndef GPAC_DISABLE_THREADS\n\tif (pid->filter->session->threads) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter pull in multithread mode not yet implementing - defaulting to 1 ms sleep\\n\", pid->pid->name, pid->filter->name));\n\t\tgf_sleep(1);\n\t\treturn;\n\t}\n#endif\n\n\tgf_filter_process_inline(pid->filter);\n}\n\n\nGF_EXPORT\nGF_FilterClockType gf_filter_pid_get_clock_info(GF_FilterPid *pid, u64 *clock_time, u32 *timescale)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tGF_FilterClockType res;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying clock on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FILTER_CLOCK_NONE;\n\t}\n\tif (clock_time) *clock_time = pidi->last_clock_value;\n\tif (timescale) *timescale = pidi->last_clock_timescale;\n\tres = pidi->last_clock_type;\n\tpidi->last_clock_type = 0;\n\treturn res;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_timescale(GF_FilterPid *pid)\n{\n\tGF_PropertyMap *map;\n\tif (!pid) return 0;\n\t//if input pid, the active PID config is the first one\n\tif (PID_IS_INPUT(pid))\n\t\tmap = gf_list_get(pid->pid->properties, 0);\n\t//if output pid, the active PID config is the last one one\n\telse\n\t\tmap = gf_list_last(pid->pid->properties);\n\treturn map ? map->timescale : 0;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_clear_eos(GF_FilterPid *pid, Bool clear_all)\n{\n\tu32 i, j;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Clearing EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid = pid->pid;\n\tfor (i=0; i<pid->filter->num_output_pids; i++) {\n\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);\n\t\tif (!clear_all && (pid != apid)) continue;\n\n\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(apid->destinations, j);\n\t\t\tif (apidi->filter != pidi->filter) continue;\n\n\t\t\tif (apidi->is_end_of_stream) {\n\t\t\t\tapidi->is_end_of_stream = GF_FALSE;\n\t\t\t}\n\t\t\tif (apid->has_seen_eos) {\n\t\t\t\tapid->has_seen_eos = GF_FALSE;\n\t\t\t\tgf_filter_pid_check_unblock(apid);\n\t\t\t}\n\n\t\t\tif (apidi->pid->filter->would_block && apidi->pid->filter->num_input_pids) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_mx_p(apidi->pid->filter->tasks_mx);\n\t\t\t\tfor (k=0; k<apidi->pid->filter->num_input_pids; k++) {\n\t\t\t\t\tGF_FilterPidInst *source_pid_inst = gf_list_get(apidi->pid->filter->input_pids, k);\n\t\t\t\t\tgf_filter_pid_clear_eos((GF_FilterPid *) source_pid_inst, clear_all);\n\t\t\t\t}\n\t\t\t\tgf_mx_v(apidi->pid->filter->tasks_mx);\n\t\t\t}\n\t\t}\n\t}\n\n\t//if filter is blocking we cannot clear EOS down the chain\n\tif (clear_all && !pid->filter->would_block) {\n\t\t//block parent\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(pid->filter->input_pids, i);\n\t\t\tgf_filter_pid_clear_eos((GF_FilterPid *) apidi, GF_TRUE);\n\t\t}\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_clock_mode(GF_FilterPid *pid, Bool filter_in_charge)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Changing clock mode on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpidi->handles_clock_references = filter_in_charge;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_args(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying args on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (pid->pid->filter->src_args) return pid->pid->filter->src_args;\n\treturn pid->pid->filter->orig_args;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_max_buffer(GF_FilterPid *pid, u32 total_duration_us)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Setting max buffer on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->max_buffer_time = pid->user_max_buffer_time = total_duration_us;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_max_buffer(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying max buffer on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn 0;\n\t}\n\treturn pid->pid->user_max_buffer_time;\n}\n\n\nGF_EXPORT\nvoid gf_filter_pid_set_loose_connect(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Setting loose connect on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->not_connected_ok = GF_TRUE;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_caps_query(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tu32 i;\n\tGF_PropertyMap *map = pid->pid->caps_negociate;\n\tif (PID_IS_INPUT(pid)) {\n\t\tu32 k;\n\t\tGF_Filter *dst = pid->filter->cap_dst_filter;\n\t\t//the first entry in destination filters may be the final destination and won't hold any caps query\n\t\t//we therefore use the last entry which points to the next filter in the chain\n\t\tif (!dst) dst = gf_list_last(pid->filter->destination_filters);\n\t\tif (!dst) dst = gf_list_get(pid->filter->destination_links, 0);\n\n\t\tif (!dst || (dst->cap_idx_at_resolution<0) ) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Reconfig caps query on input PID %s in filter %s with no destination filter set\\n\", pid->pid->name, pid->filter->name));\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (k=dst->cap_idx_at_resolution; k<dst->freg->nb_caps; k++) {\n\t\t\tconst GF_FilterCapability *cap = &dst->freg->caps[k];\n\t\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) return NULL;\n\n\t\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\t\t\tif (cap->code == prop_4cc) return &cap->val;\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (map) return gf_props_get_property(map, prop_4cc, NULL);\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tu32 j;\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\tfor (j=0; j<pidi->filter->nb_forced_caps; j++) {\n\t\t\tif (pidi->filter->forced_caps[j].code==prop_4cc)\n\t\t\t\treturn &pidi->filter->forced_caps[j].val;\n\t\t}\n\t\t//walk up the chain\n\t\tfor (j=0; j<pidi->filter->num_output_pids; j++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(pidi->filter->output_pids, j);\n\t\t\tif (apid) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_caps_query(apid, prop_4cc);\n\t\t\t\tif (p) return p;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//trick here: we may not be connected yet (called during a configure_pid), use the target destination\n\t//of the filter as caps source\n\tif (gf_list_count(pid->filter->destination_filters) ) {\n\t\tGF_Filter *a_filter = gf_list_get(pid->filter->destination_filters, 0);\n\t\twhile (a_filter) {\n\t\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t\t}\n\t\t\ta_filter = gf_list_get(a_filter->destination_filters, 0);\n\t\t}\n\t}\n\n\t//second trick here: we may not be connected yet (called during a configure_pid), use the target destination\n\t//of the filter as caps source\n\tif (pid->filter->cap_dst_filter) {\n\t\tGF_Filter *a_filter = pid->filter->cap_dst_filter;\n\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t}\n\t\t//not found, check if dst filter is alread linked to a dest - may happen when loading muxes with different chain length:\n\t\t//-i obu -i mp4a -o file.ts\n\t\t//the link fin->mp4dmx->m2tsmx->file.ts is solved before fin->rfav1->ufobu->m2tsmx->ts\n\t\ta_filter = a_filter->dst_filter;\n\t\twhile (a_filter) {\n\t\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t\t}\n\t\t\ta_filter = a_filter->dst_filter;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_caps_query_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Reconfig caps query on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tmap = pid->caps_negociate;\n\treturn map ? gf_props_get_property(map, 0, prop_name) : NULL;\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_pid_resolve_file_template_ex(GF_FilterPid *pid, char szTemplate[GF_MAX_PATH], char szFinalName[GF_MAX_PATH], u32 file_idx, const char *file_suffix, const char *filename)\n{\n\tu32 k;\n\tGF_FilterPacket *pck;\n\tchar szFormat[30], szTemplateVal[GF_MAX_PATH], szPropVal[GF_PROP_DUMP_ARG_SIZE];\n\tchar *name = szTemplate;\n\tif (!strchr(szTemplate, '$')) {\n\t\tstrcpy(szFinalName, szTemplate);\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pid_get_packet(pid);\n\t\n\tk = 0;\n\twhile (name[0]) {\n\t\tchar *sep=NULL;\n\t\tchar *fsep=NULL;\n\t\tconst char *str_val = NULL;\n\t\ts64 value = 0;\n\t\tBool is_ok = GF_TRUE;\n\t\tBool do_skip = GF_FALSE;\n\t\tBool has_val = GF_FALSE;\n\t\tBool is_file_str = GF_FALSE;\n\t\tu32 prop_4cc = 0;\n\t\tGF_PropertyValue prop_val_patched;\n\t\tconst GF_PropertyValue *prop_val = NULL;\n\n\t\tif (k+1==GF_MAX_PATH) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Not enough memory to solve file template %s\\n\", szTemplate));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tif (name[0] != '$') {\n\t\t\tszFinalName[k] = name[0];\n\t\t\tk++;\n\t\t\tname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (name[1]=='$') {\n\t\t\tszFinalName[k] = '$';\n\t\t\tname++;\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\t\tsep = strchr(name+1, '$');\n\t\tif (!sep) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] broken file template expecting $KEYWORD$, couldn't find second '$'\\n\", szTemplate));\n\t\t\tstrcpy(szFinalName, szTemplate);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tszFormat[0] = '%';\n\t\tszFormat[1] = 'd';\n\t\tszFormat[2] = 0;\n\n\t\tszFinalName[k] = 0;\n\t\tname++;\n\t\tsep[0]=0;\n\t\tfsep = strchr(name, '%');\n\t\tif (fsep) {\n\t\t\tstrcpy(szFormat, fsep);\n\t\t\tfsep[0]=0;\n\t\t}\n\n\t\tif (!strcmp(name, \"num\")) {\n\t\t\tname += 3;\n\t\t\tvalue = file_idx;\n\t\t\thas_val = GF_TRUE;\n\t\t} else if (!strcmp(name, \"URL\")) {\n\t\t\tif (!filename)\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);\n\t\t\tis_file_str = GF_TRUE;\n\t\t} else if (!strcmp(name, \"File\")) {\n\t\t\tif (!filename) {\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_FILEPATH);\n\t\t\t\t//if filepath is a gmem:// wrapped, don't use it !\n\t\t\t\tif (prop_val && !strncmp(prop_val->value.string, \"gmem://\", 7))\n\t\t\t\t\tprop_val = NULL;\n\n\t\t\t\tif (!prop_val)\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);\n\n\t\t\t\tif (!prop_val && pid->pid->name) {\n\t\t\t\t\tprop_val_patched.type = GF_PROP_STRING;\n\t\t\t\t\tprop_val_patched.value.string = pid->pid->name;\n\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\tis_file_str = GF_TRUE;\n\t\t} else if (!strcmp(name, \"PID\")) {\n\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ID);\n\t\t} else if (!strcmp(name, \"FS\")) {\n\t\t\tstr_val = file_suffix ? file_suffix : \"\";\n\t\t\tis_ok = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Type\")) {\n\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (prop_val) {\n\t\t\t\tstr_val = gf_stream_type_short_name(prop_val->value.uint);\n\t\t\t\tis_ok = GF_TRUE;\n\t\t\t}\n\t\t\tprop_val = NULL;\n\t\t} else if (!strncmp(name, \"p4cc=\", 5)) {\n\t\t\tif (strlen(name) != 9) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] wrong length in 4CC template, expecting 4cc=ABCD\\n\", name));\n\t\t\t\tis_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tprop_4cc = GF_4CC(name[5],name[6],name[7],name[8]);\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, prop_4cc);\n\t\t\t\tif (!prop_val && pck) {\n\t\t\t\t\tprop_val = gf_filter_pck_get_property(pck, prop_4cc);\n\t\t\t\t}\n\t\t\t\tif (!prop_val) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] no pid property of type %s\\n\", name+5));\n\t\t\t\t\tis_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strncmp(name, \"pname=\", 6)) {\n\t\t\tprop_val = gf_filter_pid_get_property_str_first(pid, name+6);\n\t\t\tif (!prop_val && pck) {\n\t\t\t\tprop_val = gf_filter_pck_get_property_str(pck, name+6);\n\t\t\t}\n\t\t\tif (!prop_val) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] no pid property named %s\\n\", name+6));\n\t\t\t\tis_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//DASH reserved\n\t\telse if (!strcmp(name, \"Number\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Time\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"RepresentationID\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Bandwidth\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"SubNumber\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"Init\", 4) && (name[4]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"XInit\", 5) && (name[5]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"Path\", 4) && (name[4]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else {\n\t\t\tchar *next_eq = strchr(name, '=');\n\t\t\tchar *next_sep = strchr(name, '$');\n\t\t\tif (!next_eq || (next_eq - name < next_sep - name)) {\n\t\t\t\tprop_4cc = gf_props_get_id(name);\n\t\t\t\t//not matching, try with name\n\t\t\t\tif (!prop_4cc) {\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_str_first(pid, name);\n\t\t\t\t\tif (!prop_val && pck)\n\t\t\t\t\t\tprop_val = gf_filter_pck_get_property_str(pck, name);\n\t\t\t\t} else {\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, prop_4cc);\n\t\t\t\t\tif (!prop_val && pck)\n\t\t\t\t\t\tprop_val = gf_filter_pck_get_property(pck, prop_4cc);\n\t\t\t\t}\n\n\t\t\t\tif (!prop_val && pck) {\n\t\t\t\t\tif (!strcmp(name, \"cts\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_LUINT;\n\t\t\t\t\t\tprop_val_patched.value.longuint = gf_filter_pck_get_cts(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"dts\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_LUINT;\n\t\t\t\t\t\tprop_val_patched.value.longuint = gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"dur\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_UINT;\n\t\t\t\t\t\tprop_val_patched.value.uint = gf_filter_pck_get_duration(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"sap\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_UINT;\n\t\t\t\t\t\tprop_val_patched.value.uint = gf_filter_pck_get_sap(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!prop_val) {\n\t\t\t\t\tif (!prop_4cc) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Unrecognized template %s\\n\", name));\n\t\t\t\t\t}\n\t\t\t\t\tis_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 i, len = (u32) (next_sep ? 1+(next_sep - name) : strlen(name) );\n\t\t\t\tszFinalName[k]='$';\n\t\t\t\tk++;\n\t\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\t\tszFinalName[k] = name[0];\n\t\t\t\t\tk++;\n\t\t\t\t\tname++;\n\t\t\t\t}\n\t\t\t\tszFinalName[k]='$';\n\t\t\t\tk++;\n\t\t\t\tsep[0] = '$';\n\t\t\t\tname = sep+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fsep) fsep[0] = '%';\n\t\tif (do_skip) {\n\t\t\tsep[0] = '$';\n\t\t\tszFinalName[k] = '$';\n\t\t\tk++;\n\t\t\twhile (name[0] && (name[0] != '$')) {\n\t\t\t\tszFinalName[k] = name[0];\n\t\t\t\tk++;\n\t\t\t\tname++;\n\t\t\t}\n\t\t\tszFinalName[k] = '$';\n\t\t\tk++;\n\t\t\tname++;\n\n\n\t\t\tcontinue;\n\n\t\t}\n\n\n\t\tif (!is_ok && !prop_val && prop_4cc) {\n\t\t\tif (prop_4cc==GF_PROP_PID_CROP_POS) {\n\t\t\t\tprop_val_patched.type = GF_PROP_VEC2I;\n\t\t\t\tprop_val_patched.value.vec2i.x = 0;\n\t\t\t\tprop_val_patched.value.vec2i.y = 0;\n\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\tis_ok=GF_TRUE;\n\t\t\t}\n\t\t\telse if (prop_4cc==GF_PROP_PID_ORIG_SIZE) {\n\t\t\t\tprop_val_patched.type = GF_PROP_VEC2I;\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_WIDTH);\n\t\t\t\tprop_val_patched.value.vec2i.x = prop_val ? prop_val->value.uint : 0;\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_HEIGHT);\n\t\t\t\tprop_val_patched.value.vec2i.y = prop_val ? prop_val->value.uint : 0;\n\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\tis_ok=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] property %s not found for pid, cannot resolve template\\n\", name));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_ok) {\n\t\t\tif (sep) sep[0] = '$';\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (prop_val) {\n\t\t\tif ((prop_val->type==GF_PROP_UINT) || (prop_val->type==GF_PROP_SINT)) {\n\t\t\t\tvalue = prop_val->value.uint;\n\t\t\t\thas_val = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tstr_val = gf_props_dump_val(prop_val, szPropVal, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t}\n\t\t} else if (is_file_str) {\n\t\t\tstr_val = filename;\n\t\t}\n\t\tszTemplateVal[0]=0;\n\t\tif (has_val) {\n\t\t\tsprintf(szTemplateVal, szFormat, value);\n\t\t} else if (str_val) {\n\t\t\tif (is_file_str) {\n\t\t\t\tif (!strncmp(str_val, \"gfio://\", 7))\n\t\t\t\t\tstr_val = gf_fileio_translate_url(str_val);\n\n\t\t\t\tif (filename) {\n\t\t\t\t\tstrcpy(szTemplateVal, filename);\n\t\t\t\t} else {\n\t\t\t\t\tchar *ext, *sname;\n\t\t\t\t\text = strstr(str_val, \"://\");\n\t\t\t\t\tsname = strrchr(ext ? ext+4 : str_val, '/');\n\t\t\t\t\tif (!sname) sname = strrchr(ext ? ext+4 : str_val, '\\\\');\n\t\t\t\t\tif (sname && ext)\n\t\t\t\t\t\tstr_val = sname+1;\n\n\t\t\t\t\tif (!sname) sname = (char *) str_val;\n\t\t\t\t\telse sname++;\n\n\t\t\t\t\text = strrchr(str_val, '.');\n\n\t\t\t\t\tif (ext && (ext > sname) ) {\n\t\t\t\t\t\tu32 len = (u32) (ext - sname);\n\t\t\t\t\t\tstrncpy(szTemplateVal, sname, ext - sname);\n\t\t\t\t\t\tszTemplateVal[len] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(szTemplateVal, sname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrcpy(szTemplateVal, str_val);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] property %s not found for pid, cannot resolve template\\n\", name));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (k + strlen(szTemplateVal) > GF_MAX_PATH) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Not enough memory to solve file template %s\\n\", szTemplate));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t\tstrcat(szFinalName, szTemplateVal);\n\t\tk = (u32) strlen(szFinalName);\n\n\t\tif (!sep) break;\n\t\tsep[0] = '$';\n\t\tname = sep+1;\n\t}\n\tszFinalName[k] = 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_resolve_file_template(GF_FilterPid *pid, char szTemplate[GF_MAX_PATH], char szFinalName[GF_MAX_PATH], u32 file_idx, const char *file_suffix)\n{\n\treturn gf_filter_pid_resolve_file_template_ex(pid, szTemplate, szFinalName, file_idx, file_suffix, NULL);\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_discard(GF_FilterPid *pid, Bool discard_on)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt at discarding packets on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (discard_on) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Discarding packets on PID %s (filter %s to %s)\\n\", pid->pid->name, pid->pid->filter->name, pid->filter->name));\n\t\tgf_filter_aggregate_packets(pidi);\n\t\t//force discarding\n\t\tu32 pck_discard_bck = pidi->discard_packets;\n\t\tpidi->discard_packets = 0;\n\t\twhile (gf_filter_pid_get_packet(pid)) {\n\t\t\tgf_filter_pid_drop_packet(pid);\n\t\t}\n\t\tpidi->discard_packets = pck_discard_bck;\n\t\tpidi->is_end_of_stream = GF_TRUE;\n\t} else {\n\t\t//no more packets in queue or postponed, we can trust the EOS signal on the PID\n\t\t//otherwise even though the PID has seen the EOS, it is not yet processed by the pid instance, signaling it\n\t\t//would break up filters (for example dash demux) relying on precise EOS signals which must be toggled at the EOS packet\n\t\t//once all previous packets have been processed\n\t\tif (!gf_fq_count(pidi->packets) && !pid->pid->filter->postponed_packets)\n\t\t\tpidi->is_end_of_stream = pid->pid->has_seen_eos;\n\t}\n\tpidi->discard_inputs = discard_on ? 1 : 0;\n\treturn GF_OK;\n}\n\nstatic char *gf_filter_pid_get_dst_string(GF_FilterSession *sess, const char *_args, Bool is_dst)\n{\n\tchar *target, *sep;\n\tchar szKey[6];\n\tu32 len;\n\tif (!_args) return NULL;\n\n\tif (is_dst)\n\t\tsprintf(szKey, \"dst%c\", sess->sep_name);\n\telse\n\t\tsprintf(szKey, \"src%c\", sess->sep_name);\n\n\ttarget = strstr(_args, szKey);\n\tif (!target) return NULL;\n\n\tsep = (char *) gf_fs_path_escape_colon(sess, target + 4);\n\ttarget += 4;\n\tif (sep) len = (u32) (sep - target);\n\telse len = (u32) strlen(target);\n\n\tchar *res = gf_malloc(sizeof(char)* (len+1));\n\tmemcpy(res, target, sizeof(char)* len);\n\tres[len]=0;\n\treturn res;\n}\n\n\nGF_EXPORT\nchar *gf_filter_pid_get_destination(GF_FilterPid *pid)\n{\n\tconst char *dst_args;\n\tchar *res;\n\tu32 i, j;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query destination on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\n\tdst_args = pid->filter->dst_args;\n\tif (!dst_args) dst_args = pid->filter->src_args;\n\tres = gf_filter_pid_get_dst_string(pid->filter->session, dst_args, GF_TRUE);\n\tif (res) return res;\n\n\t//if not set this means we have explicitly loaded the filter\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\n\t\tdst_args = pidi->filter->dst_args;\n\t\tif (!dst_args) dst_args = pidi->filter->src_args;\n\t\tres = gf_filter_pid_get_dst_string(pid->filter->session, dst_args, GF_TRUE);\n\t\tif (res) return res;\n\n\t\tfor (j=0; j<pidi->filter->num_output_pids; j++) {\n\t\t\tGF_FilterPid *a_pid = gf_list_get(pidi->filter->output_pids, j);\n\t\t\tchar *dst = gf_filter_pid_get_destination(a_pid);\n\t\t\tif (dst) return dst;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nchar *gf_filter_pid_get_source(GF_FilterPid *pid)\n{\n\tconst char *src_args;\n\tchar *res;\n//\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query source on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\n\tsrc_args = pid->filter->src_args;\n\tif (!src_args) src_args = pid->filter->dst_args;\n\tres = gf_filter_pid_get_dst_string(pid->filter->session, src_args, GF_FALSE);\n\tif (res) return res;\n\n\t//if not set this means we have explicitly loaded the filter\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\n\t\tsrc_args = pidi->pid->filter->src_args;\n\t\tif (!src_args) src_args = pidi->pid->filter->dst_args;\n\t\tres = gf_filter_pid_get_dst_string(pid->filter->session, src_args, GF_FALSE);\n\t\tif (res) {\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn res;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn NULL;\n}\n\nGF_FilterPid *gf_filter_pid_first_pid_for_source(GF_FilterPid *pid, GF_Filter *source)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to locate PID on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPid *a_pid;\n\t\tGF_FilterPidInst *a_pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (gf_filter_in_parent_chain(a_pidi->pid->filter, source))\n\t\t\treturn (GF_FilterPid *) a_pidi;\n\t\ta_pid = gf_filter_pid_first_pid_for_source((GF_FilterPid *) a_pidi, source);\n\t\tif (a_pid) return a_pid;\n\t}\n\treturn NULL;\n\n}\n\nGF_EXPORT\nvoid gf_filter_pid_discard_block(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset block mode on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tif (!pid->has_seen_eos) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to reset block mode on PID %s in filter %s not in end of stream, ignoring\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_mx_p(pid->filter->tasks_mx);\n\tif (pid->would_block) {\n\t\tsafe_int_dec(&pid->would_block);\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_require_source_id(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set require_source_id input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpid->require_source_id = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_min_pck_duration(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query min_pck_duration on output pid PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn 0;\n\t}\n\treturn pid->pid->min_pck_duration;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_recompute_dts(GF_FilterPid *pid, Bool do_recompute)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set recompute_dts on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->recompute_dts = do_recompute;\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_playing(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FALSE;\n\treturn pid->pid->is_playing;\n\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_allow_direct_dispatch(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set direct dispatch mode on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n#ifndef GPAC_DISABLE_THREADS\n\tif (pid->filter->session->threads)\n\t\treturn GF_OK;\n#endif\n\tpid->direct_dispatch = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid *gf_filter_pid_get_alias_udta(GF_FilterPid *_pid)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(_pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query multi_sink original filter context on output pid %s in filter %s not allowed\\n\", _pid->pid->name, _pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpidi = (GF_FilterPidInst *) _pid;\n\tif (!pidi->alias_orig) return NULL;\n\treturn pidi->alias_orig->filter_udta;\n}\n\nGF_EXPORT\nGF_Filter *gf_filter_pid_get_source_filter(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query source filter on output pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\treturn pid->pid->filter;\n}\n\nGF_EXPORT\nGF_Filter *gf_filter_pid_enum_destinations(GF_FilterPid *pid, u32 idx)\n{\n\tGF_FilterPidInst *dst_pid;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query destination filters on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (idx>=pid->num_destinations) return NULL;\n\tdst_pid = gf_list_get(pid->destinations, idx);\n\treturn dst_pid->filter;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_ignore_blocking(GF_FilterPid *pid, Bool do_ignore)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set output pid  %s in filter %s to ignore block mode not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidi = (GF_FilterPidInst *) pid;\n\tpidi->pid->ignore_blocking = do_ignore;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_filter_pid_get_next_ts(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FILTER_NO_TS;\n\tu64 dts = pid->pid->last_pck_dts;\n\tif (dts == GF_FILTER_NO_TS)\n\t\tdts = pid->pid->last_pck_cts;\n\tif (dts == GF_FILTER_NO_TS)\n\t\treturn dts;\n\tdts += pid->pid->last_pck_dur;\n\treturn dts;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_udta_flags(GF_FilterPid *pid)\n{\n\tif (!pid) return 0;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\treturn pid->udta_flags;\n\t}\n\treturn ((GF_FilterPidInst *)pid)->udta_flags;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_udta_flags(GF_FilterPid *pid, u32 flags)\n{\n\tif (!pid) return GF_BAD_PARAM;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tpid->udta_flags = flags;\n\t} else {\n\t\t((GF_FilterPidInst *)pid)->udta_flags = flags;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_filter_pid_has_decoder(GF_FilterPid *pid)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query decoder presence on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->nb_decoder_inputs)\n\t\treturn GF_TRUE;\n\tgf_mx_p(pid->pid->filter->tasks_mx);\n\tfor (i=0; i<pid->pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->filter->input_pids, i);\n\t\tif (gf_filter_pid_has_decoder((GF_FilterPid *) pidi)) {\n\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(pid->pid->filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_rt_stats(GF_FilterPid *pid, u32 rtt_ms, u32 jitter_us, u32 loss_rate)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set real-time stats on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidi = (GF_FilterPidInst*)pid;\n\tpidi->last_rt_report = gf_sys_clock_high_res();\n\tpidi->rtt = rtt_ms;\n\tpidi->jitter = jitter_us;\n\tpidi->loss_rate = loss_rate;\n\treturn GF_OK;\n}\n\n\n#include <gpac/internal/media_dev.h>\nGF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr);\nGF_Err rfc_6381_get_codec_m4v(char *szCodec, u32 codec_id, u8 *dsi, u32 dsi_size);\nGF_Err rfc_6381_get_codec_avc(char *szCodec, u32 subtype, GF_AVCConfig *avcc);\nGF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc);\nGF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c, COLR colr);\nGF_Err rfc_6381_get_codec_vpx(char *szCodec, u32 subtype, GF_VPConfig *vpcc, COLR colr);\nGF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecoderConfigurationRecord *dovi);\nGF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc);\nGF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl);\nGF_Err rfc_6381_get_codec_uncv(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size);\nGF_Err rfc6381_codec_name_default(char *szCodec, u32 subtype, u32 codec_id);\n\n\nGF_Err gf_filter_pid_get_rfc_6381_codec_string(GF_FilterPid *pid, char *szCodec, Bool force_inband, Bool force_sbr, const GF_PropertyValue *tile_base_dcd, u32 *out_inband_forced)\n{\n\tu32 subtype=0, subtype_src=0, codec_id, stream_type;\n\ts32 mha_pl=-1;\n\tBool is_tile_base = GF_FALSE;\n\tconst GF_PropertyValue *p, *dcd, *dcd_enh, *dovi, *codec;\n\tCOLR colr;\n\n\tmemset(&colr, 0, sizeof(colr));\n\tszCodec[0] = 0;\n\tif (!pid) return GF_BAD_PARAM;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (!p) return GF_BAD_PARAM;\n\tcodec_id = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p) return GF_BAD_PARAM;\n\tstream_type = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) subtype_src = p->value.uint;\n\n\tdcd = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tdcd_enh = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\n\t// If colour information is supplied in [the colr] box, and also in the video bitstream, [the] box takes precedence\n\t{\n\t\tconst GF_PropertyValue *p1 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_PRIMARIES),\n\t\t                       *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_TRANSFER),\n\t\t                       *p3 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_MX),\n\t\t                       *p4 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_RANGE);\n\t\tif (p1 && p2 && p3 && p4) {\n\t\t\tcolr.override = GF_TRUE;\n\t\t\tcolr.colour_primaries = p1->value.uint;\n\t\t\tcolr.transfer_characteristics = p2->value.uint;\n\t\t\tcolr.matrix_coefficients = p3->value.uint;\n\t\t\tcolr.full_range = p4->value.boolean;\n\t\t} else if (!p1 && !p2 && !p3 && !p4) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Incomplete upstream-filter 'colr' information. Ignoring.\\n\"));\n\t\t}\n\t}\n\n\tif (!force_inband) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\tif (p) {\n\t\t\t//input uses inband parameters, force it on output regardless of bitstream switching mode\n\t\t\tswitch (p->value.uint) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_VVI1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tforce_inband = GF_TRUE;\n\t\t\t\tif (out_inband_forced) *out_inband_forced = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcodec = gf_filter_pid_get_property(pid, GF_PROP_PID_CODEC);\n\tif (codec && (codec->type==GF_PROP_STRING) && codec->value.string) {\n\t\tconst char *codec_str = codec->value.string;\n\t\tif (codec_str[0] != '.') {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", codec_str);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!subtype_src)\n\t\t\tsubtype_src = gf_codecid_4cc_type(codec_id);\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s%s\", gf_4cc_to_str(subtype_src), codec_str);\n\t\treturn GF_OK;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean) is_tile_base = GF_TRUE;\n\n\n\tdovi = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\tif (dovi) {\n\t\tGF_Err e;\n\t\tGF_BitStream *bs = gf_bs_new(dovi->value.data.ptr, dovi->value.data.size, GF_BITSTREAM_READ);\n\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\tgf_bs_del(bs);\n\t\tif (!dvcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for Dolby Vision file (\\\"%s\\\")\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tswitch (codec_id) {\n\t\tcase GF_CODECID_HEVC:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, force_inband ? GF_ISOM_SUBTYPE_DVHE : GF_ISOM_SUBTYPE_DVH1, dvcc);\n\t\t\tbreak;\n\t\tcase GF_CODECID_AVC:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, force_inband ? GF_ISOM_SUBTYPE_DVAV : GF_ISOM_SUBTYPE_DVA1, dvcc);\n\t\t\tbreak;\n\t\tcase GF_CODECID_AV1:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, GF_ISOM_SUBTYPE_DAV1, dvcc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t}\n\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\treturn e;\n\t}\n\n\tswitch (codec_id) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\t\treturn rfc_6381_get_codec_aac(szCodec, codec_id, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0, force_sbr);\n\n\tcase GF_CODECID_MPEG4_PART2:\n\t\treturn rfc_6381_get_codec_m4v(szCodec, codec_id, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0);\n\t\tbreak;\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_MVC:\n\t\tif (dcd_enh) dcd = dcd_enh;\n\t\tsubtype = (codec_id==GF_CODECID_SVC) ? GF_ISOM_SUBTYPE_SVC_H264 : GF_ISOM_SUBTYPE_MVC_H264;\n\tcase GF_CODECID_AVC:\n\t\tif (!subtype) {\n\t\t\tif (force_inband) {\n\t\t\t\tsubtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC4_H264 : GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\t} else {\n\t\t\t\tsubtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC2_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t}\n\t\t}\n\t\tif (dcd) {\n\t\t\tGF_AVCConfig *avcc = gf_odf_avc_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\t\t\tif (avcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_CODECID_LHVC:\n\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;\n\t\t//fallthrough\n\tcase GF_CODECID_HEVC_TILES:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tif (!dcd && tile_base_dcd) dcd = tile_base_dcd;\n\n\t\t//fallthrough\n\tcase GF_CODECID_HEVC:\n\t\tif (!subtype) {\n\t\t\tif (is_tile_base) {\n\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;\n\t\t\t} else if (dcd_enh) {\n\t\t\t\tif (dcd) {\n\t\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;\n\t\t\t\t} else {\n\t\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t\t}\n\t\t}\n\t\tif (dcd || dcd_enh) {\n\t\t\tGF_HEVCConfig *hvcc = dcd ? gf_odf_hevc_cfg_read(dcd->value.data.ptr, dcd->value.data.size, GF_FALSE) : NULL;\n\t\t\tif (hvcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);\n\t\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] HEVC config not compliant !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381]  Cannot find HEVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n#endif\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_CODECID_AV1:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_AV01;\n\n\t\tif (dcd) {\n\t\t\tGF_AV1Config *av1c = gf_odf_av1_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\t\t\tif (av1c) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_av1(szCodec, subtype, av1c, colr);\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] AV1 config not conformant\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AV1 config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_CODECID_VP8:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_VP08;\n\tcase GF_CODECID_VP9:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_VP09;\n\n\t\tif (dcd) {\n\t\t\tGF_VPConfig *vpcc = gf_odf_vp_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\n\t\t\tif (vpcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc, colr);\n\t\t\t\tgf_odf_vp_cfg_del(vpcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for VP file (\\\"%s\\\").\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find VPX config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n\tcase GF_CODECID_MHAS:\n\t\tsubtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\tif (!dcd) {\n\t\t\tconst GF_PropertyValue *pl = gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\t\tif (pl) mha_pl = (s32) pl->value.uint;\n\t\t}\n\t\t//fallthrough\n\tcase GF_CODECID_MPHA:\n\t\tif (!subtype)\n\t\t\tsubtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHA1;\n\n\t\treturn rfc_6381_get_codec_mpegha(szCodec, subtype, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0, mha_pl);\n\n\tcase GF_CODECID_VVC:\n\t\tif (!subtype) {\n\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_VVI1 : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tif (dcd) {\n\t\t\tGF_VVCConfig *vvcc = gf_odf_vvc_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.\", gf_4cc_to_str(subtype));\n\t\t\tif (vvcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);\n\t\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for VP file (\\\"%s\\\")\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find VVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\treturn rfc_6381_get_codec_uncv(szCodec, subtype, dcd->value.data.ptr, dcd->value.data.size);\n\tdefault:\n\t\tsubtype = gf_codecid_4cc_type(codec_id);\n\t\tif (!subtype) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) subtype = p->value.uint;\n\t\t}\n\t\tif (!subtype && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (stream_type==GF_STREAM_VISUAL) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\t\tif (p) subtype = gf_pixel_fmt_to_qt_type(p->value.uint);\n\t\t\t}\n\t\t\telse if (stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\t\tif (p) subtype = gf_audio_fmt_to_isobmf(p->value.uint);\n\t\t\t}\n\t\t}\n\n\t\tif (!subtype) {\n\t\t\tconst char *mime = gf_codecid_mime(codec_id);\n\t\t\tif (mime) mime = strchr(mime, '/');\n\t\t\tif (mime) mime++;\n\t\t\tif (mime && mime[0] && strcmp(mime, \"octet-string\")) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known, using mime type %s\\n\", mime));\n\t\t\t\tstrcpy(szCodec, mime);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known, cannot set codec string\\n\" ));\n\t\t\tstrcpy(szCodec, \"unkn\");\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\treturn rfc6381_codec_name_default(szCodec, subtype, codec_id);\n\t}\n\treturn GF_OK;\n}\n"], "fixing_code": ["\t/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / filters sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terfsess of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"filter_session.h\"\n#include <gpac/constants.h>\n#include <gpac/bitstream.h>\n\nstatic void free_evt(GF_FilterEvent *evt);\n\nstatic void pcki_del(GF_FilterPacketInstance *pcki)\n{\n\tassert(pcki->pck->reference_count);\n\tif (safe_int_dec(&pcki->pck->reference_count) == 0) {\n\t\tgf_filter_packet_destroy(pcki->pck);\n\t}\n\tgf_free(pcki);\n}\n\nvoid gf_filter_pid_inst_reset(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\twhile (gf_fq_count(pidinst->packets)) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_pop(pidinst->packets);\n\t\tpcki_del(pcki);\n\t}\n\n\twhile (gf_list_count(pidinst->pck_reassembly)) {\n\t\tGF_FilterPacketInstance *pcki = gf_list_pop_back(pidinst->pck_reassembly);\n\t\tpcki_del(pcki);\n\t}\n}\n\nvoid gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t//not in parent pid, may happen when reattaching a pid inst to a different pid\n\t\t//in this case do NOT delete the props\n\t\tif (gf_list_find(pidinst->pid->properties, pidinst->props)>=0) {\n\t\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\t\tgf_props_del(pidinst->props);\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t}\n\tgf_free(pidinst);\n}\n\nstatic GF_FilterPidInst *gf_filter_pid_inst_new(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tGF_FilterPidInst *pidinst;\n\tGF_SAFEALLOC(pidinst, GF_FilterPidInst);\n\tif (!pidinst) return NULL;\n\tpidinst->pid = pid;\n\tpidinst->filter = filter;\n\n\tif (filter->session->use_locks) {\n\t\tchar szName[200];\n\t\tu32 pid_idx = 1 + gf_list_find(pid->filter->output_pids, pid);\n\t\tu32 dst_idx = 1 + pid->num_destinations;\n\t\tsnprintf(szName, 200, \"F%sPid%dDest%dPackets\", filter->name, pid_idx, dst_idx);\n\t\tpidinst->pck_mx = gf_mx_new(szName);\n\t}\n\n\tpidinst->packets = gf_fq_new(pidinst->pck_mx);\n\n\tpidinst->pck_reassembly = gf_list_new();\n\tpidinst->last_block_ended = GF_TRUE;\n\treturn pidinst;\n}\n\nstatic void gf_filter_pid_check_unblock(GF_FilterPid *pid)\n{\n\tBool unblock;\n\n\tif (pid->ignore_blocking) {\n\t\treturn;\n\t}\n\t//if we are in end of stream state and done with all packets, stay blocked\n\tif (pid->has_seen_eos && !pid->nb_buffer_unit) {\n\t\tif (!pid->would_block) {\n\t\t\tsafe_int_inc(&pid->would_block);\n\t\t\tsafe_int_inc(&pid->filter->would_block);\n\t\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\t\t}\n\t\treturn;\n\t}\n\n\tunblock=GF_FALSE;\n\n\tassert(pid->playback_speed_scaler);\n\n\t//we block according to the number of dispatched units (decoder output) or to the requested buffer duration\n\t//for other streams - unblock accordingly\n\tif (pid->max_buffer_unit) {\n\t\tif (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER < pid->max_buffer_unit * pid->playback_speed_scaler) {\n\t\t\tunblock=GF_TRUE;\n\t\t}\n\t} else if (pid->buffer_duration * GF_FILTER_SPEED_SCALER < pid->max_buffer_time * pid->playback_speed_scaler) {\n\t\tunblock=GF_TRUE;\n\t}\n\n\tif (!unblock) {\n\t\treturn;\n\t}\n\tgf_mx_p(pid->filter->tasks_mx);\n\tunblock = GF_FALSE;\n\n\t//unblock pid\n\tif (pid->would_block) {\n\t\tsafe_int_dec(&pid->would_block);\n\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t\tassert((s32)pid->filter->would_block>=0);\n\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s unblocked (filter has %d blocking pids)\\n\", pid->pid->filter->name, pid->pid->name, pid->pid->filter->would_block));\n\n\t\t//check filter unblock\n\t\tunblock = GF_TRUE;\n\t}\n\t//pid was not blocking but filter is no longer scheduled (might happen in multi-threaded modes), check filter unblock\n\telse if (!pid->filter->process_task_queued) {\n\t\tunblock = GF_TRUE;\n\t}\n\n\tif (unblock && (pid->filter->would_block + pid->filter->num_out_pids_not_connected < pid->filter->num_output_pids)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has only %d / %d blocked pids, requesting process task (%d queued)\\n\", pid->filter->name, pid->filter->would_block + pid->filter->num_out_pids_not_connected, pid->filter->num_output_pids, pid->filter->process_task_queued));\n\n\t\t//post a process task\n\t\tgf_filter_post_process_task(pid->filter);\n\t}\n\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\nstatic void gf_filter_pid_inst_check_dependencies(GF_FilterPidInst *pidi)\n{\n\tconst GF_PropertyValue *p;\n\tu32 i, dep_id = 0;\n\tGF_FilterPid *pid = pidi->pid;\n\tGF_Filter *filter = pid->filter;\n\n\t//check pid dependency\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) dep_id = p->value.uint;\n\n\tif (!dep_id) return;\n\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *a_pid = gf_list_get(filter->output_pids, i);\n\t\tif (a_pid==pid) continue;\n\t\tp = gf_filter_pid_get_property_first(a_pid, GF_PROP_PID_ID);\n\t\tif (!p) p = gf_filter_pid_get_property_first(a_pid, GF_PROP_PID_ESID);\n\t\tif (!p || (p->value.uint != dep_id)) continue;\n\n\t\tfor (j=0; j<a_pid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(a_pid->destinations, j);\n\t\t\tif (a_pidi == pidi) continue;\n\t\t\tif (! a_pidi->is_decoder_input) continue;\n\n\t\t\tif (a_pidi->filter == pidi->filter) continue;\n\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Filter %s PID %s connected to decoder %s, but dependent stream %s connected to %s - switching pid destination\\n\", a_pid->filter->name, a_pid->name, a_pidi->filter->name, pidi->pid->name, pidi->filter->name));\n\n\t\t\t//disconnect this pid instance from its current decoder\n\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_disconnect_task, a_pidi->filter, a_pid, \"pidinst_disconnect\", NULL);\n\n\t\t\t//reconnect this pid instance to the new decoder\n\t\t\tsafe_int_inc(&pid->filter->out_pid_connection_pending);\n\t\t\tgf_filter_pid_post_connect_task(pidi->filter, a_pid);\n\n\t\t}\n\t}\n}\n\nstatic void gf_filter_pid_update_caps(GF_FilterPid *pid)\n{\n\tu32 mtype=0, codecid=0;\n\tu32 i;\n\tconst GF_PropertyValue *p;\n\n\tpid->raw_media = GF_FALSE;\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_CODECID);\n\tif (p) codecid = p->value.uint;\n\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) mtype = p->value.uint;\n\n\tBool was_sparse = pid->is_sparse;\n\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_SPARSE);\n\tif (p) {\n\t\tpid->is_sparse = p->value.boolean;\n\t} else {\n\t\tu32 otype = mtype;\n\t\tp = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\tif (p) otype = p->value.uint;\n\t\tswitch (otype) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_FILE:\n\t\t\tpid->is_sparse = GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpid->is_sparse = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (was_sparse && !pid->is_sparse)\n\t\tsafe_int_dec(&pid->filter->nb_sparse_pids);\n\telse if (!was_sparse && pid->is_sparse)\n\t\tsafe_int_inc(&pid->filter->nb_sparse_pids);\n\n\n\tpid->stream_type = mtype;\n\tpid->codecid = codecid;\n\n\tu32 buffer_us = pid->filter->pid_buffer_max_us ? pid->filter->pid_buffer_max_us : pid->filter->session->default_pid_buffer_max_us;\n\tif (pid->user_max_buffer_time) {\n\t\tpid->max_buffer_time = MAX(pid->user_max_buffer_time, buffer_us);\n\t\tpid->max_buffer_unit = 0;\n\t} else {\n\t\tpid->max_buffer_time = buffer_us;\n\t\tpid->max_buffer_unit = pid->filter->pid_buffer_max_units ? pid->filter->pid_buffer_max_units : pid->filter->session->default_pid_buffer_max_units;\n\t}\n\tpid->raw_media = GF_FALSE;\n\n\tif (codecid!=GF_CODECID_RAW) {\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\t\tu32 i_codecid=0, i_type=0;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\t\tif (!pidi->pid) continue;\n\t\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (p) i_type = p->value.uint;\n\n\t\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) i_codecid = p->value.uint;\n\t\t\t//same stream type but changing from raw to not raw: this is an encoder input pid\n\t\t\tif ((mtype==i_type) && (i_codecid==GF_CODECID_RAW)) {\n\t\t\t\tpidi->is_encoder_input = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn;\n\t}\n\n\t//output is a decoded raw stream: if some input has same type but different codecid this is a decoder\n\t//set input buffer size\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tu32 i_codecid=0, i_type=0;\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (!pidi->pid) continue;\n\n\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (p) i_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);\n\t\tif (p) i_codecid = p->value.uint;\n\n\t\t//same stream type but changing format type: this is a decoder input pid, set buffer req\n\t\tif ((mtype==i_type) && (codecid != i_codecid)) {\n\n\t\t\tbuffer_us = pid->filter->pid_decode_buffer_max_us ? pid->filter->pid_decode_buffer_max_us : pid->filter->session->decoder_pid_buffer_max_us;\n\t\t\t//default decoder buffer\n\t\t\tpidi->pid->max_buffer_time = MAX(pidi->pid->user_max_buffer_time, buffer_us);\n\t\t\tpidi->pid->max_buffer_unit = 0;\n\n\t\t\t//composition buffer\n\t\t\tif (pid->filter->pid_buffer_max_units) {\n\t\t\t\tpid->max_buffer_unit = pid->filter->pid_buffer_max_units;\n\t\t\t} else if (mtype==GF_STREAM_VISUAL) {\n\t\t\t\tpid->max_buffer_unit = 4;\n\t\t\t} else if (mtype==GF_STREAM_AUDIO) {\n\t\t\t\tpid->max_buffer_unit = 20;\n\t\t\t}\n\n\t\t\tif (!pidi->is_decoder_input) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s pid instance %s marked as decoder input\\n\",  pidi->pid->filter->name, pidi->pid->name));\n\t\t\t\tpidi->is_decoder_input = GF_TRUE;\n\t\t\t\tsafe_int_inc(&pidi->pid->nb_decoder_inputs);\n\n\t\t\t\tif ((i_type == GF_STREAM_AUDIO) || (i_type == GF_STREAM_VISUAL))\n\t\t\t\t\tgf_filter_pid_inst_check_dependencies(pidi);\n\t\t\t}\n\t\t}\n\t\t//same media type, same codec: raw stream\n\t\telse if (mtype==i_type) {\n\t\t\tpid->raw_media = GF_TRUE;\n\t\t\t//special case if single input pid filter, copy buffer props from input\n\t\t\tif (pid->filter->num_input_pids==1) {\n\t\t\t\tGF_FilterPidInst *pid_in = gf_list_get(pid->filter->input_pids, i);\n\t\t\t\tif ((pid_in->pid->max_buffer_unit>1) || pid_in->pid->max_buffer_time) {\n\t\t\t\t\tpid->max_buffer_unit = pid_in->pid->max_buffer_unit;\n\t\t\t\t\tpid->filter->pid_buffer_max_units = pid_in->pid->max_buffer_unit;\n\t\t\t\t\tpid->max_buffer_time = pid_in->pid->max_buffer_time;\n\t\t\t\t\tpid->filter->pid_buffer_max_us = (u32) pid_in->pid->max_buffer_time;\n\t\t\t\t}\n\t\t\t\t//if input has a single destination, reset buffer props to default\n\t\t\t\tif (pid_in->pid->num_destinations==1) {\n\t\t\t\t\tpid_in->pid->max_buffer_unit = 1;\n\t\t\t\t\tpid_in->pid->max_buffer_time = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//input is file, output is not and codec ID is raw, this is a raw media pid\n\t\telse if ((i_type==GF_STREAM_FILE) && (mtype!=GF_STREAM_FILE) && (codecid==GF_CODECID_RAW) ) {\n\t\t\tpid->raw_media = GF_TRUE;\n\t\t}\n\t}\n\t//source pid, mark raw media\n\tif (!pid->filter->num_input_pids && pid->num_destinations) {\n\t\tpid->raw_media = GF_TRUE;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\n#define TASK_REQUEUE(_t) \\\n\t_t->requeue_request = GF_TRUE; \\\n\t_t->schedule_next_time = gf_sys_clock_high_res() + 50; \\\n\nvoid gf_filter_pid_inst_delete_task(GF_FSTask *task)\n{\n\tGF_FilterPid *pid = task->pid;\n\tGF_FilterPidInst *pidinst = task->udta;\n\tGF_Filter *filter = pid->filter;\n\tBool pid_still_alive = GF_FALSE;\n\n\tassert(filter);\n\t//reset in process\n\tif ((pidinst->filter && pidinst->discard_packets) || filter->stream_reset_pending || filter->abort_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\t//reset PID instance buffers before checking number of output shared packets\n\t//otherwise we may block because some of the shared packets are in the\n\t//pid instance buffer (not consumed)\n\tgf_filter_pid_inst_reset(pidinst);\n\n\t//we still have packets out there!\n\tif (pidinst->pid->nb_shared_packets_out) {\n\t\t//special case for disconnect of fanouts, destroy even if shared packets out\n\t\tif (!pid->num_destinations || ((pid->num_destinations>=1) && (gf_list_find(pid->destinations, pidinst)>=0))) {\n\t\t\tTASK_REQUEUE(task)\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//WARNING at this point pidinst->filter may be destroyed\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid instance %s destruction (%d fan-out)\\n\",  filter->name, pid->name, pid->num_destinations));\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tif (pidinst->pid->num_pidinst_del_pending) {\n\t\tpidinst->pid->num_pidinst_del_pending--;\n\t\tif (pidinst->pid->num_pidinst_del_pending)\n\t\t\tpid_still_alive = GF_TRUE;\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\n\tif (pidinst->is_decoder_input) {\n\t\tassert(pid->nb_decoder_inputs);\n\t\tsafe_int_dec(&pid->nb_decoder_inputs);\n\t}\n\tgf_filter_pid_inst_del(pidinst);\n\t//recompute max buf dur and nb units to update blocking state\n\tif (pid->num_destinations) {\n\t\tu32 i;\n\t\tu32 nb_pck = 0;\n\t\ts64 buf_dur = 0;\n\t\tfor (i = 0; i < pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(pid->destinations, i);\n\t\t\tu32 npck = gf_fq_count(apidi->packets);\n\t\t\tif (npck > nb_pck) nb_pck = npck;\n\t\t\tif (apidi->buffer_duration > buf_dur) buf_dur = apidi->buffer_duration;\n\t\t}\n\t\tpid->nb_buffer_unit = nb_pck;\n\t\tpid->buffer_duration = buf_dur;\n\t} else {\n\t\tpid->nb_buffer_unit = 0;\n\t\tpid->buffer_duration = 0;\n\t}\n\n\tassert(pid->filter == filter);\n\n\tif (pid_still_alive)\n\t\treturn;\n\n\t//some more destinations on pid, update blocking state\n\tif (pid->num_destinations || pid->init_task_pending) {\n\t\tif (pid->would_block)\n\t\t\tgf_filter_pid_check_unblock(pid);\n\t\telse\n\t\t\tgf_filter_pid_would_block(pid);\n\n\t\treturn;\n\t}\n\tgf_mx_p(filter->tasks_mx);\n\t//still some input to the filter, cannot destroy the output pid\n\tif (gf_list_count(filter->input_pids)) {\n\t\tgf_mx_v(filter->tasks_mx);\n\t\treturn;\n\t}\n\t//no more destinations on pid, unblock if blocking\n\tif (pid->would_block) {\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t}\n\n\t//we cannot remove an output pid since the filter may still check status on that pid or try to dispatch packets\n\t//removal/destruction must come from the filter\n\t//we only count the number of output pids that have been internally discarded by this function, and trigger filter removal if last\n\tpid->removed = GF_TRUE;\n\n\t//filter still active and has no input, check if there are no more output pids valid. If so, remove filter\n\tif (!gf_list_count(filter->input_pids) && !filter->finalized) {\n\t\tu32 i, nb_opid_rem=0;\n\t\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(filter->output_pids, i);\n\t\t\tif (apid->removed) nb_opid_rem++;\n\t\t}\n\t\tif (gf_list_count(filter->output_pids)==nb_opid_rem) {\n\t\t\tgf_filter_post_remove(filter);\n\t\t}\n\t}\n\n\tgf_mx_v(filter->tasks_mx);\n}\n\nstatic void gf_filter_pid_inst_swap_delete(GF_Filter *filter, GF_FilterPid *pid, GF_FilterPidInst *pidinst, GF_FilterPidInst *dst_swapinst)\n{\n\tu32 i, j;\n\n\t//reset PID instance buffers before checking number of output shared packets\n\t//otherwise we may block because some of the shared packets are in the\n\t//pid instance buffer (not consumed)\n\tgf_filter_pid_inst_reset(pidinst);\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid instance %s swap destruction\\n\",  filter->name, pidinst->pid ? pidinst->pid->name : pid->name));\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_del_item(filter->input_pids, pidinst);\n\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\tif (!filter->num_input_pids)\n\t\tfilter->single_source = NULL;\n\tgf_mx_v(filter->tasks_mx);\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\n\tif (pidinst->is_decoder_input) {\n\t\tassert(pid->nb_decoder_inputs);\n\t\tsafe_int_dec(&pid->nb_decoder_inputs);\n\t}\n\t//this pid instance is registered to destination filter for chain reconfigure, don't discard it\n\tif (filter->detached_pid_inst && (gf_list_find(filter->detached_pid_inst, pidinst)>=0) )\n\t\treturn;\n\n\tgf_filter_pid_inst_del(pidinst);\n\n\tif (filter->num_input_pids) return;\n\t//we still have other pid instances registered for chain reconfigure, don't discard the filter\n\tif (filter->detached_pid_inst) return;\n\n\t//filter no longer used, disconnect chain\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *a_pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<a_pid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(a_pid->destinations, j);\n\t\t\tif (a_pidi == dst_swapinst) continue;\n\n\t\t\tgf_filter_pid_inst_swap_delete(a_pidi->filter, a_pid, a_pidi, dst_swapinst);\n\t\t}\n\t}\n\tfilter->swap_pidinst_dst = NULL;\n\tfilter->swap_pidinst_src = NULL;\n\tgf_filter_post_remove(filter);\n}\n\nstatic void gf_filter_pid_inst_swap_delete_task(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidinst = task->udta;\n\tGF_Filter *filter = pidinst->filter;\n\tGF_FilterPid *pid = task->pid ? task->pid : pidinst->pid;\n\tGF_FilterPidInst *dst_swapinst = pidinst->filter->swap_pidinst_dst;\n\n\t//reset in process\n\tif ((pidinst->filter && pidinst->discard_packets)\n\t\t|| filter->stream_reset_pending\n\t\t|| filter->nb_shared_packets_out\n\t) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\tif (pidinst->filter)\n\t\tpidinst->filter->swap_pidinst_dst = NULL;\n\n\tgf_filter_pid_inst_swap_delete(filter, pid, pidinst, dst_swapinst);\n}\n\nstatic void gf_filter_pid_inst_swap(GF_Filter *filter, GF_FilterPidInst *dst)\n{\n\tGF_PropertyMap *prev_dst_props;\n\tu32 nb_pck_transfer=0;\n\tGF_FilterPidInst *src = filter->swap_pidinst_src;\n\tif (!src) src = filter->swap_pidinst_dst;\n\t\n\tif (src) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s swaping PID %s to PID %s\\n\", filter->name, src->pid->name, dst->pid->name));\n\t}\n\n\t\n\tif (filter->swap_needs_init) {\n\t\t//we are in detach state, the packet queue of the old PID is never read\n\t\tassert(filter->swap_pidinst_dst && filter->swap_pidinst_dst->detach_pending);\n\t\t//we are in pending state, the origin of the old PID is never dispatching\n//\t\tassert(dst->pid && dst->pid->filter && dst->pid->filter->out_pid_connection_pending);\n\t\t//we can therefore swap the packet queues safely and other important info\n\t}\n\t//otherwise we actually swap the pid instance on the same PID\n\telse {\n\t\tgf_mx_p(dst->pid->filter->tasks_mx);\n\t\tif (src)\n\t\t\tgf_list_del_item(dst->pid->destinations, src);\n\t\tif (gf_list_find(dst->pid->destinations, dst)<0)\n\t\t\tgf_list_add(dst->pid->destinations, dst);\n\t\tdst->pid->num_destinations = gf_list_count(dst->pid->destinations);\n\t\tif (gf_list_find(dst->filter->input_pids, dst)<0) {\n\t\t\tgf_list_add(dst->filter->input_pids, dst);\n\t\t\tdst->filter->num_input_pids = gf_list_count(dst->filter->input_pids);\n\n\t\t\tif (dst->filter->num_input_pids==1) {\n\t\t\t\tdst->filter->single_source = dst->pid->filter;\n\t\t\t} else if (dst->filter->single_source != dst->pid->filter) {\n\t\t\t\tdst->filter->single_source = NULL;\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(dst->pid->filter->tasks_mx);\n\t}\n\n\tif (src) {\n\t\tGF_FilterPacketInstance *pcki;\n\t\twhile (1) {\n\t\t\tpcki = gf_fq_pop(src->packets);\n\t\t\tif (!pcki) break;\n\t\t\tassert(src->filter->pending_packets);\n\t\t\tsafe_int_dec(&src->filter->pending_packets);\n\n\t\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\t\tassert(src->filter->nb_main_thread_forced);\n\t\t\t\tsafe_int_dec(&src->filter->nb_main_thread_forced);\n\t\t\t\tsafe_int_inc(&dst->filter->nb_main_thread_forced);\n\t\t\t}\n\t\t\tpcki->pid = dst;\n\t\t\tgf_fq_add(dst->packets, pcki);\n\t\t\tsafe_int_inc(&dst->filter->pending_packets);\n\t\t\tnb_pck_transfer++;\n\t\t}\n\t\tif (src->requires_full_data_block && gf_list_count(src->pck_reassembly)) {\n\t\t\tdst->requires_full_data_block = src->requires_full_data_block;\n\t\t\tdst->last_block_ended = src->last_block_ended;\n\t\t\tdst->first_block_started = src->first_block_started;\n\t\t\tif (!dst->pck_reassembly) dst->pck_reassembly = gf_list_new();\n\t\t\twhile (gf_list_count(src->pck_reassembly)) {\n\t\t\t\tpcki = gf_list_pop_front(src->pck_reassembly);\n\t\t\t\tpcki->pid = dst;\n\t\t\t\tgf_list_add(dst->pck_reassembly, pcki);\n\t\t\t}\n\t\t}\n\t\t//copy over state\n\t\tdst->is_end_of_stream = src->is_end_of_stream;\n\t\tdst->nb_eos_signaled = src->nb_eos_signaled;\n\t\tdst->buffer_duration = src->buffer_duration;\n\t\tdst->nb_clocks_signaled = src->nb_clocks_signaled;\n\n\t\t//switch previous src property map to this new pid (this avoids rewriting props of already dispatched packets)\n\t\t//it may happen that we already have props on dest, due to configure of the pid\n\t\t//use the old props as new ones and merge the previous props of dst in the new props\n\t\tprev_dst_props = dst->props;\n\t\tdst->props = src->props;\n\t\tdst->force_reconfig = GF_TRUE;\n\t\tsrc->force_reconfig = GF_TRUE;\n\t\tsrc->props = NULL;\n\t\tif (prev_dst_props) {\n\t\t\tif (dst->props) {\n\t\t\t\tgf_props_merge_property(dst->props, prev_dst_props, NULL, NULL);\n\t\t\t\tassert(prev_dst_props->reference_count);\n\t\t\t\tif (safe_int_dec(&prev_dst_props->reference_count) == 0) {\n\t\t\t\t\tgf_props_del(prev_dst_props);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst->props = prev_dst_props;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_pck_transfer && !dst->filter->process_task_queued) {\n\t\t\tgf_filter_post_process_task(dst->filter);\n\t\t}\n\t}\n\n\n\tsrc = filter->swap_pidinst_dst;\n\tif (src) {\n\t\tif (filter->swap_needs_init) {\n\t\t\t//exit out special handling of the pid since we are ready to detach\n\t\t\tassert(src->filter->stream_reset_pending);\n\t\t\tsafe_int_dec(&src->filter->stream_reset_pending);\n\n\t\t\t//post detach task, we will reset the swap_pidinst only once truly deconnected from filter\n\t\t\tsafe_int_inc(&src->pid->filter->detach_pid_tasks_pending);\n\t\t\tsafe_int_inc(&filter->detach_pid_tasks_pending);\n\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_detach_task, src->filter, src->pid, \"pidinst_detach\", filter);\n\t\t} else {\n\t\t\tGF_Filter *src_filter = src->filter;\n\t\t\tassert(!src->filter->sticky);\n\t\t\tassert(src->filter->num_input_pids==1);\n\n\t\t\tgf_mx_p(src_filter->tasks_mx);\n\t\t\tgf_list_del_item(src_filter->input_pids, src);\n\t\t\tsrc_filter->num_input_pids = gf_list_count(src_filter->input_pids);\n\t\t\tif (!src_filter->num_input_pids)\n\t\t\t\tsrc_filter->single_source = NULL;\n\t\t\tgf_mx_v(src_filter->tasks_mx);\n\n\t\t\tgf_list_del_item(src->pid->destinations, src);\n\t\t\tsrc->pid->num_destinations = gf_list_count(src->pid->destinations);\n\t\t\tgf_filter_pid_inst_del(src);\n\n\t\t\tfilter->swap_pidinst_dst = NULL;\n\t\t\tfilter->swap_pidinst_src = NULL;\n\t\t\tgf_filter_post_remove(src_filter);\n\t\t}\n\t}\n\t\n\tif (filter->swap_pidinst_src) {\n\t\tsrc = filter->swap_pidinst_src;\n\t\tassert(!src->filter->swap_pidinst_dst);\n\t\tsrc->filter->swap_pidinst_dst = filter->swap_pidinst_dst;\n\t\tsrc->filter->swap_pending = GF_TRUE;\n\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_swap_delete_task, src->filter, src->pid, \"pid_inst_delete\", src);\n\t}\n}\n\n//check all packets scheduled on main thread, unflag dest filter nb_main_thread_forced and set dest to NULL\n//we must do that because the packets may be destroyed after the pid instance is detached\n//so the destination filter would be NULL by then\nvoid gf_filter_instance_detach_pid(GF_FilterPidInst *pidinst)\n{\n\tu32 i, count;\n\tif (!pidinst->filter) return;\n\n\tcount = gf_fq_count(pidinst->packets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_get(pidinst->packets, i);\n\t\tif (!pcki) break;\n\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t\t}\n\t}\n\tcount = gf_list_count(pidinst->pck_reassembly);\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterPacketInstance *pcki = gf_list_get(pidinst->pck_reassembly, i);\n\t\tif (!pcki) break;\n\t\tif (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {\n\t\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t\t}\n\t}\n\tpidinst->filter = NULL;\n}\n\nvoid task_canceled(GF_FSTask *task)\n{\n\tif (task->class_type==TASK_TYPE_EVENT) {\n\t\tGF_FilterEvent *evt = task->udta;\n\t\tfree_evt(evt);\n\t}\n\telse if (task->class_type==TASK_TYPE_SETUP) {\n\t\tgf_free(task->udta);\n\t}\n\telse if (task->class_type==TASK_TYPE_USER) {\n\t\tgf_free(task->udta);\n\t\tgf_free((char *)task->log_name);\n\t\ttask->log_name = NULL;\n\t}\n}\n\n\ntypedef enum {\n\tGF_PID_CONF_CONNECT,\n\tGF_PID_CONF_RECONFIG,\n\tGF_PID_CONF_REMOVE,\n} GF_PidConnectType;\n\nstatic GF_Err gf_filter_pid_configure(GF_Filter *filter, GF_FilterPid *pid, GF_PidConnectType ctype)\n{\n\tu32 i, count;\n\tGF_Err e;\n\tBool refire_events=GF_FALSE;\n\tBool new_pid_inst=GF_FALSE;\n\tBool remove_filter=GF_FALSE;\n\tGF_FilterPidInst *pidinst=NULL;\n\tGF_Filter *alias_orig = NULL;\n\n\tif (filter->multi_sink_target) {\n\t\talias_orig = filter;\n\t\tfilter = filter->multi_sink_target;\n\t}\n\n\tassert(filter->freg->configure_pid);\n\tif (filter->finalized) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to configure PID %s in finalized filter %s\\n\",  pid->name, filter->name));\n\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\tassert(pid->filter->out_pid_connection_pending);\n\t\t\tsafe_int_dec(&pid->filter->out_pid_connection_pending);\n\t\t}\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\n\tif (filter->detached_pid_inst) {\n\t\tcount = gf_list_count(filter->detached_pid_inst);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tpidinst = gf_list_get(filter->detached_pid_inst, i);\n\t\t\tif (pidinst->filter==filter) {\n\t\t\t\tgf_list_rem(filter->detached_pid_inst, i);\n\t\t\t\t//reattach new filter and pid\n\t\t\t\tpidinst->filter = filter;\n\t\t\t\tpidinst->pid = pid;\n\n\t\t\t\tassert(!pidinst->props);\n\n\t\t\t\t//and treat as new pid inst\n\t\t\t\tif (ctype == GF_PID_CONF_CONNECT) {\n\t\t\t\t\tnew_pid_inst=GF_TRUE;\n\t\t\t\t\tif (!pid->filter->nb_pids_playing && (pidinst->is_playing || pidinst->is_paused))\n\t\t\t\t\t\trefire_events = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tassert(pidinst->detach_pending);\n\t\t\t\tsafe_int_dec(&pidinst->detach_pending);\n\t\t\t\t//revert temp sticky flag\n\t\t\t\tif (filter->sticky == 2)\n\t\t\t\t\tfilter->sticky = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpidinst=NULL;\n\t\t}\n\t\tif (! gf_list_count(filter->detached_pid_inst)) {\n\t\t\tgf_list_del(filter->detached_pid_inst);\n\t\t\tfilter->detached_pid_inst = NULL;\n\t\t}\n\t}\n\tif (!pidinst) {\n\t\tcount = pid->num_destinations;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tpidinst = gf_list_get(pid->destinations, i);\n\t\t\tif (pidinst->filter==filter) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpidinst=NULL;\n\t\t}\n\t}\n\n\t//first connection of this PID to this filter\n\tif (!pidinst) {\n\t\tif (ctype != GF_PID_CONF_CONNECT) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to disconnect PID %s not present in filter %s inputs\\n\",  pid->name, filter->name));\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tpidinst = gf_filter_pid_inst_new(filter, pid);\n\t\tnew_pid_inst=GF_TRUE;\n\t}\n\tif (!pidinst->alias_orig)\n\t\tpidinst->alias_orig = alias_orig;\n\n\t//if new, add the PID to input/output before calling configure\n\tif (new_pid_inst) {\n\t\tassert(pidinst);\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Registering %s:%s as destination for %s:%s\\n\", pid->filter->name, pid->name, pidinst->filter->name, pidinst->pid->name));\n\t\tgf_list_add(pid->destinations, pidinst);\n\t\tpid->num_destinations = gf_list_count(pid->destinations);\n\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tif (!filter->input_pids) filter->input_pids = gf_list_new();\n\t\tgf_list_add(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (filter->num_input_pids==1) {\n\t\t\tfilter->single_source = pidinst->pid->filter;\n\t\t} else if (filter->single_source != pidinst->pid->filter) {\n\t\t\tfilter->single_source = NULL;\n\t\t}\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t//new connection, update caps in case we have events using caps (buffer req) being sent\n\t\t//while processing the configure (they would be dispatched on the source filter, not the dest one being\n\t\t//processed here)\n\t\tgf_filter_pid_update_caps(pid);\n\t}\n\n\t//we are swaping a PID instance (dyn insert of a filter), do it before reconnecting\n\t//in order to have properties in place\n\t//TODO: handle error case, we might need to re-switch the pid inst!\n\tif (filter->swap_pending) {\n\t\tgf_filter_pid_inst_swap(filter, pidinst);\n\t\tfilter->swap_pending = GF_FALSE;\n\t}\n\n\tfilter->in_connect_err = GF_EOS;\n\t//commented out: audio thread may be pulling packets out of the pid but not in the compositor:process, which\n\t//could be called for video at the same time...\n#if 0\n\tFSESS_CHECK_THREAD(filter)\n#endif\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s reconfigure\\n\", pidinst->filter->name, pidinst->pid->name));\n\te = filter->freg->configure_pid(filter, (GF_FilterPid*) pidinst, (ctype==GF_PID_CONF_REMOVE) ? GF_TRUE : GF_FALSE);\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (filter->session->check_allocs) {\n\t\tif (filter->nb_consecutive_process >= filter->max_nb_consecutive_process) {\n\t\t\tfilter->max_nb_consecutive_process = filter->nb_consecutive_process;\n\t\t\tfilter->max_nb_process = filter->nb_process_since_reset;\n\t\t\tfilter->max_stats_nb_alloc = filter->stats_nb_alloc;\n\t\t\tfilter->max_stats_nb_calloc = filter->stats_nb_calloc;\n\t\t\tfilter->max_stats_nb_realloc = filter->stats_nb_realloc;\n\t\t\tfilter->max_stats_nb_free = filter->stats_nb_free;\n\t\t}\n\t\tfilter->stats_mem_allocated = 0;\n\t\tfilter->stats_nb_alloc = filter->stats_nb_realloc = filter->stats_nb_free = 0;\n\t\tfilter->nb_process_since_reset = filter->nb_consecutive_process = 0;\n\t}\n#endif\n\tif ((e==GF_OK) && (filter->in_connect_err<GF_OK))\n\t\te = filter->in_connect_err;\n\n\tfilter->in_connect_err = GF_OK;\n\t\n\tif (e==GF_OK) {\n\t\t//if new, register the new pid instance, and the source pid as input to this filter\n\t\tif (new_pid_inst) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s (%p) PID %s (%p) (%d fan-out) connected to filter %s (%p)\\n\", pid->filter->name, pid->filter, pid->name, pid, pid->num_destinations, filter->name, filter));\n\t\t}\n\t\t//reset blacklist on source if connect OK - this is required when reconfiguring multiple times to the same filter, eg\n\t\t//jpeg->raw->jpeg, the first jpeg->raw would blacklist jpeg dec from source, preventing resolution to work at raw->jpeg switch\n\t\tgf_list_reset(pidinst->pid->filter->blacklisted);\n\t}\n\t//failure on reconfigure, try reloading a filter chain\n\telse if ((ctype==GF_PID_CONF_RECONFIG) && (e != GF_FILTER_NOT_SUPPORTED)) {\n\t\t//mark pid as end of stream to let filter flush\n\t\tpidinst->is_end_of_stream = GF_TRUE;\n\t\tif (e==GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to reconfigure PID %s:%s in filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\n\t\t\tfilter->session->last_connect_error = e;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Failed to reconfigure PID %s:%s in filter %s: %s, reloading filter graph\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t\tgf_list_add(pid->filter->blacklisted, (void *) filter->freg);\n\t\t\tgf_filter_relink_dst(pidinst, e);\n\t\t}\n\t} else {\n\n\t\t//error, remove from input and output\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (!filter->num_input_pids)\n\t\t\tfilter->single_source = NULL;\n\t\tfilter->freg->configure_pid(filter, (GF_FilterPid *) pidinst, GF_TRUE);\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\tgf_list_del_item(pidinst->pid->destinations, pidinst);\n\t\tpidinst->pid->num_destinations = gf_list_count(pidinst->pid->destinations);\n\t\t//detach filter from pid instance\n\t\tgf_filter_instance_detach_pid(pidinst);\n\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\n\t\t//if connect and error, direct delete of pid\n\t\tif (new_pid_inst) {\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pid->destinations, pidinst);\n\t\t\tpid->num_destinations = gf_list_count(pid->destinations);\n\n\t\t\t//cancel all tasks targeting this pid\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tcount = gf_fq_count(pid->filter->tasks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FSTask *t = gf_fq_get(pid->filter->tasks, i);\n\t\t\t\tif (t->pid == (GF_FilterPid *) pidinst) {\n\t\t\t\t\tt->run_task = task_canceled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\t\t//destroy pid instance\n\t\t\tgf_filter_pid_inst_del(pidinst);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t}\n\n\n\t\tif (e==GF_REQUIRES_NEW_INSTANCE) {\n\t\t\t//TODO: copy over args from current filter\n\t\t\tGF_Filter *new_filter = gf_filter_clone(filter, pid->filter);\n\t\t\tif (new_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Clone filter %s, new instance for pid %s\\n\", filter->name, pid->name));\n\t\t\t\tgf_filter_pid_post_connect_task(new_filter, pid);\n\t\t\t\treturn GF_OK;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to clone filter %s\\n\", filter->name));\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (e && (ctype==GF_PID_CONF_REMOVE)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to disconnect filter %s PID %s from filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t}\n\t\telse if (e) {\n\t\t\tif (e!= GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to connect filter %s PID %s to filter %s: %s\\n\", pid->filter->name, pid->name, filter->name, gf_error_to_string(e) ));\n\t\t\t}\n\n\t\t\tif ((e==GF_BAD_PARAM)\n\t\t\t\t|| (e==GF_SERVICE_ERROR)\n\t\t\t\t|| (e==GF_REMOTE_SERVICE_ERROR)\n\t\t\t\t|| (e==GF_FILTER_NOT_SUPPORTED)\n\t\t\t\t|| (e==GF_EOS)\n\t\t\t\t|| (filter->session->flags & GF_FS_FLAG_NO_REASSIGN)\n\t\t\t) {\n\t\t\t\tif (filter->session->flags & GF_FS_FLAG_NO_REASSIGN) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter reassignment disabled, skippping chain reload for filter %s PID %s\\n\", pid->filter->name, pid->name ));\n\t\t\t\t}\n\t\t\t\tif (e!= GF_EOS) {\n\t\t\t\t\tfilter->session->last_connect_error = e;\n\t\t\t\t}\n\n\t\t\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\t\t\t\t\tgf_filter_pid_set_eos(pid);\n\n\t\t\t\t\tif (pid->filter->freg->process_event) {\n\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\t\t\t\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (!filter->num_input_pids && !filter->num_output_pids) {\n\t\t\t\t\t\tremove_filter = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (filter->has_out_caps) {\n\t\t\t\tBool unload_filter = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Blacklisting %s as output from %s and retrying connections\\n\", filter->name, pid->filter->name));\n\t\t\t\t//try to load another filter to handle that connection\n\t\t\t\t//1-blacklist this filter\n\t\t\t\tgf_list_add(pid->filter->blacklisted, (void *) filter->freg);\n\t\t\t\t//2-disconnect all other inputs, and post a re-init\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\twhile (gf_list_count(filter->input_pids)) {\n\t\t\t\t\tGF_FilterPidInst *a_pidinst = gf_list_pop_back(filter->input_pids);\n\t\t\t\t\tFSESS_CHECK_THREAD(filter)\n\t\t\t\t\tfilter->num_input_pids--;\n\t\t\t\t\tfilter->freg->configure_pid(filter, (GF_FilterPid *) a_pidinst, GF_TRUE);\n\n\t\t\t\t\tgf_filter_pid_post_init_task(a_pidinst->pid->filter, a_pidinst->pid);\n\t\t\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_delete_task, a_pidinst->pid->filter, a_pidinst->pid, \"pid_inst_delete\", a_pidinst);\n\n\t\t\t\t\tunload_filter = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfilter->num_input_pids = 0;\n\t\t\t\tfilter->single_source = NULL;\n\t\t\t\tfilter->removed = 1;\n\t\t\t\tfilter->has_pending_pids = GF_FALSE;\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t\t\t//do not assign session->last_connect_error since we are retrying a connection\n\n\t\t\t\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\t\t\t\tassert(pid->filter->out_pid_connection_pending);\n\t\t\t\t\tsafe_int_dec(&pid->filter->out_pid_connection_pending);\n\t\t\t\t}\n\t\t\t\t//3- post a re-init on this pid\n\t\t\t\tgf_filter_pid_post_init_task(pid->filter, pid);\n\n\t\t\t\tif (unload_filter) {\n\t\t\t\t\tassert(!gf_list_count(filter->input_pids));\n\n\t\t\t\t\tif (filter->num_output_pids) {\n\t\t\t\t\t\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\t\tGF_FilterPid *opid = gf_list_get(filter->output_pids, i);\n\t\t\t\t\t\t\tfor (j=0; j< opid->num_destinations; j++) {\n\t\t\t\t\t\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(opid->destinations, j);\n\t\t\t\t\t\t\t\ta_pidi->pid = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_list_reset(opid->destinations);\n\t\t\t\t\t\t\topid->num_destinations = 0;\n\t\t\t\t\t\t\tgf_filter_pid_remove(opid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilter->swap_pidinst_src = NULL;\n\t\t\t\t\tif (filter->swap_pidinst_dst) {\n\t\t\t\t\t\tGF_Filter *target = filter->swap_pidinst_dst->filter;\n\t\t\t\t\t\tassert(target);\n\t\t\t\t\t\tif (!target->detached_pid_inst) {\n\t\t\t\t\t\t\ttarget->detached_pid_inst = gf_list_new();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//detach props\n\t\t\t\t\t\tif (filter->swap_pidinst_dst->props) {\n\t\t\t\t\t\t\tGF_FilterPidInst *swap_pidi = filter->swap_pidinst_dst;\n\t\t\t\t\t\t\tif (safe_int_dec(&swap_pidi->props->reference_count)==0) {\n\t\t\t\t\t\t\t\tgf_mx_p(swap_pidi->pid->filter->tasks_mx);\n\t\t\t\t\t\t\t\tgf_list_del_item(swap_pidi->pid->properties, pidinst->props);\n\t\t\t\t\t\t\t\tgf_mx_v(swap_pidi->pid->filter->tasks_mx);\n\t\t\t\t\t\t\t\tgf_props_del(pidinst->props);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfilter->swap_pidinst_dst->props = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfilter->swap_pidinst_dst->pid = NULL;\n\t\t\t\t\t\tif (gf_list_find(target->detached_pid_inst, filter->swap_pidinst_dst)<0)\n\t\t\t\t\t\t\tgf_list_add(target->detached_pid_inst, filter->swap_pidinst_dst);\n\t\t\t\t\t}\n\t\t\t\t\tfilter->swap_pidinst_dst = NULL;\n\t\t\t\t\tif (filter->on_setup_error) {\n\t\t\t\t\t\tgf_filter_notification_failure(filter, e, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_post_remove(filter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to reconfigure input of sink %s, cannot rebuild graph\\n\", filter->name));\n\t\t\t\tif (pid->filter->freg->process_event) {\n\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\t\t\tpid->filter->freg->process_event(pid->filter, &evt);\n\t\t\t\t}\n\t\t\t\tfilter->session->last_connect_error = e;\n\t\t\t}\n\t\t} else {\n\t\t\tfilter->session->last_connect_error = GF_OK;\n\t\t}\n\n\t\t//try to run filter no matter what\n\t\tif (filter->session->requires_solved_graph)\n\t\t\treturn e;\n\t}\n\n\t//flush all pending pid init requests following the call to init\n\tif (filter->has_pending_pids) {\n\t\tfilter->has_pending_pids = GF_FALSE;\n\t\twhile (gf_fq_count(filter->pending_pids)) {\n\t\t\tGF_FilterPid *a_pid=gf_fq_pop(filter->pending_pids);\n\t\t\t//filter is a pid adaptation filter (dynamically loaded to solve prop negociation)\n\t\t\t//copy over play state if the input PID was already playing\n\t\t\tif (pid->is_playing && filter->is_pid_adaptation_filter)\n\t\t\t\ta_pid->is_playing = GF_TRUE;\n\n\t\t\tgf_filter_pid_post_init_task(filter, a_pid);\n\t\t}\n\t}\n\n\tif (ctype==GF_PID_CONF_REMOVE) {\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->input_pids, pidinst);\n\t\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\t\tif (!filter->num_input_pids)\n\t\t\tfilter->single_source = NULL;\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\t//PID instance is no longer in graph, we must remove it from pid destination to avoid propagating events\n\t\t//on to-be freed pid instance.\n\t\t//however we must have fan-outs (N>1 pid instance per PID), and removing the pid inst would trigger a pid destruction\n\t\t//on the first gf_filter_pid_inst_delete_task executed.\n\t\t//we therefore track at the PID level the number of gf_filter_pid_inst_delete_task tasks pending and\n\t\t//won't destroy the PID until that number is O\n\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\tpidinst->pid->num_pidinst_del_pending ++;\n\t\tgf_list_del_item(pidinst->pid->destinations, pidinst);\n\t\tpidinst->pid->num_destinations = gf_list_count(pidinst->pid->destinations);\n\t\tgf_filter_instance_detach_pid(pidinst);\n\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\n\t\t//disconnected the last input, flag as removed\n\t\tif (!filter->num_input_pids && !filter->sticky) {\n\t\t\tgf_filter_reset_pending_packets(filter);\n\t\t\tfilter->removed = 1;\n\t\t}\n\t\t//post a pid_delete task to also trigger removal of the filter if needed\n\t\tgf_fs_post_task(filter->session, gf_filter_pid_inst_delete_task, pid->filter, pid, \"pid_inst_delete\", pidinst);\n\n\t\treturn e;\n\t}\n\n\tif (ctype==GF_PID_CONF_CONNECT) {\n\t\tassert(pid->filter->out_pid_connection_pending);\n\t\tif (safe_int_dec(&pid->filter->out_pid_connection_pending) == 0) {\n\n\t\t\t//we must resent play/pause events when a new pid is reattached to an old pid instance\n\t\t\t//in case one of the injected filter(s) monitors play state of the pids (eg reframers)\n\t\t\tif (refire_events) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tif (pidinst->is_playing) {\n\t\t\t\t\tpidinst->is_playing = GF_FALSE;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, (GF_FilterPid*)pidinst);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *)pidinst, &evt);\n\t\t\t\t}\n\t\t\t\tif (pidinst->is_paused) {\n\t\t\t\t\tpidinst->is_paused = GF_FALSE;\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PAUSE, (GF_FilterPid*)pidinst);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *)pidinst, &evt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\t//postponed packets dispatched by source while setting up PID, flush through process()\n\t\t\t\t//pending packets (not yet consumed but in PID buffer), start processing\n\t\t\t\tif (pid->filter->postponed_packets || pid->filter->pending_packets || pid->filter->nb_caps_renegociate) {\n\t\t\t\t\tgf_filter_post_process_task(pid->filter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (remove_filter && !filter->sticky)\n\t\t\tgf_filter_post_remove(filter);\n\t}\n\t//once all pid have been (re)connected, update any internal caps\n\tgf_filter_pid_update_caps(pid);\n\treturn e;\n}\n\nstatic void gf_filter_pid_connect_task(GF_FSTask *task)\n{\n\tGF_Filter *filter = task->filter;\n\tGF_FilterSession *fsess = filter->session;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s pid %s connecting to %s (%p)\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name, filter));\n\n\t//filter will require a new instance, clone it\n\tif (filter->num_input_pids && (filter->max_extra_pids <= filter->num_input_pids - 1)) {\n\t\tGF_Filter *new_filter = gf_filter_clone(filter, task->pid->pid->filter);\n\t\tif (new_filter) {\n\t\t\tfilter = new_filter;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to clone filter %s\\n\", filter->name));\n\t\t\tassert(filter->in_pid_connection_pending);\n\t\t\tsafe_int_dec(&filter->in_pid_connection_pending);\n\t\t\tif (task->pid->pid) {\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\tgf_list_del_item(filter->temp_input_pids, task->pid->pid);\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (task->pid->pid) {\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tgf_list_del_item(filter->temp_input_pids, task->pid->pid);\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tgf_filter_pid_configure(filter, task->pid->pid, GF_PID_CONF_CONNECT);\n\t\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\t\tif (!task->pid->pid->nb_pck_sent) {\n\t\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t\t}\n\t}\n\t\n\t//filter may now be the clone, decrement on original filter\n\tassert(task->filter->in_pid_connection_pending);\n\tsafe_int_dec(&task->filter->in_pid_connection_pending);\n\n\tgf_fs_cleanup_filters(fsess);\n\n}\n\nvoid gf_filter_pid_reconfigure_task(GF_FSTask *task)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s reconfigure to %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\n\tif (task->pid->pid) {\n\t\tgf_filter_pid_configure(task->filter, task->pid->pid, GF_PID_CONF_RECONFIG);\n\t\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\t\tif (!task->pid->pid->nb_pck_sent) {\n\t\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t\t}\n\t}\n}\n\nvoid gf_filter_pid_reconfigure_task_discard(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) task->pid;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s reconfigure to %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\n\tif (!pidi->pid) return;\n\tgf_filter_pid_configure(task->filter, pidi->pid, GF_PID_CONF_RECONFIG);\n\t//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure\n\tif (!task->pid->pid->nb_pck_sent) {\n\t\ttask->pid->pid->request_property_map = GF_TRUE;\n\t\ttask->pid->pid->pid_info_changed = GF_FALSE;\n\t}\n\n\tif (pidi->discard_inputs==2) {\n\t\tgf_filter_aggregate_packets(pidi);\n\t\twhile (gf_filter_pid_get_packet((GF_FilterPid *) pidi)) {\n\t\t\tgf_filter_pid_drop_packet((GF_FilterPid *) pidi);\n\t\t}\n\t\t//move back to regular discard\n\t\tpidi->discard_inputs = 1;\n\t}\n}\nvoid gf_filter_pid_disconnect_task(GF_FSTask *task)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s disconnect from %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\tgf_filter_pid_configure(task->filter, task->pid->pid, GF_PID_CONF_REMOVE);\n\n\tgf_mx_p(task->filter->tasks_mx);\n\t//if the filter has no more connected ins and outs, remove it\n\tif (task->filter->removed && !gf_list_count(task->filter->output_pids) && !gf_list_count(task->filter->input_pids)) {\n\t\tBool direct_mode = task->filter->session->direct_mode;\n\t\tgf_filter_post_remove(task->filter);\n\t\tif (direct_mode) {\n\t\t\tgf_mx_v(task->filter->tasks_mx);\n\t\t\ttask->filter = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_mx_v(task->filter->tasks_mx);\n}\n\nvoid gf_filter_pid_detach_task(GF_FSTask *task)\n{\n\tu32 i, count;\n\tGF_Filter *filter = task->filter;\n\tGF_FilterPid *pid = task->pid->pid;\n\tGF_FilterPidInst *pidinst=NULL;\n\tGF_Filter *new_chain_input = task->udta;\n\n\t//we may have concurrent reset (due to play/stop/seek) and caps renegotiation\n\t//wait for the pid to be reset before detaching\n\tif (pid->filter->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\tif (new_chain_input->in_pid_connection_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tcount = pid->num_destinations;\n\tfor (i=0; i<count; i++) {\n\t\tpidinst = gf_list_get(pid->destinations, i);\n\t\tif (pidinst->filter==filter) {\n\t\t\tbreak;\n\t\t}\n\t\tpidinst=NULL;\n\t}\n\t//flush any packets dispatched before detaching\n\tif (pidinst && gf_fq_count(pidinst->packets)) {\n\t\tBool in_process = filter->in_process;\n\t\tfilter->in_process = GF_FALSE;\n\t\t//prevent pid_would_block calls\n\t\tfilter->in_force_flush = GF_TRUE;\n\t\tpidinst->force_flush = GF_TRUE;\n\t\tgf_filter_process_inline(filter);\n\t\tpidinst->force_flush = GF_FALSE;\n\t\tfilter->in_force_flush = GF_FALSE;\n\t\tfilter->in_process = in_process;\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tassert(filter->freg->configure_pid);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s detach from %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\tassert(pid->filter->detach_pid_tasks_pending);\n\tsafe_int_dec(&pid->filter->detach_pid_tasks_pending);\n\n\t//first connection of this PID to this filter\n\tif (!pidinst) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to detach PID %s not present in filter %s inputs\\n\",  pid->name, filter->name));\n\t\t//when swaping encoder, we may have swap_pidinst_dst not NULL so only check swap_pidinst_src\n\t\tassert(!new_chain_input->swap_pidinst_src);\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t\treturn;\n\t}\n\n\t//detach props\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(& pidinst->props->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tpidinst->props = NULL;\n\n\tgf_mx_p(filter->tasks_mx);\n\t//detach pid - remove all packets in our pid instance and also update filter pending_packets\n\tcount = gf_fq_count(pidinst->packets);\n\tassert(count <= filter->pending_packets);\n\tsafe_int_sub(&filter->pending_packets, (s32) count);\n\tgf_filter_pid_inst_reset(pidinst);\n\tpidinst->pid = NULL;\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tgf_list_del_item(filter->input_pids, pidinst);\n\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\tif (!filter->num_input_pids)\n\t\tfilter->single_source = NULL;\n\tgf_mx_v(filter->tasks_mx);\n\n\tif (!filter->detached_pid_inst) {\n\t\tfilter->detached_pid_inst = gf_list_new();\n\t}\n\tif (gf_list_find(filter->detached_pid_inst, pidinst)<0)\n\t\tgf_list_add(filter->detached_pid_inst, pidinst);\n\n\t//we are done, reset filter swap instance so that connection can take place\n\tif (new_chain_input->swap_needs_init) {\n\t\tnew_chain_input->swap_pidinst_dst = NULL;\n\t\tnew_chain_input->swap_pidinst_src = NULL;\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t}\n\tassert(new_chain_input->detach_pid_tasks_pending);\n\tsafe_int_dec(&new_chain_input->detach_pid_tasks_pending);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_name(GF_FilterPid *pid, const char *name)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to assign name %s to input PID %s in filter %s - ignoring\\n\", name, pid->pid->name, pid->pid->filter->name));\n\t} else if (name) {\n\t\tif (pid->name && !strcmp(pid->name, name)) return;\n\t\tif (pid->name) gf_free(pid->name);\n\t\tpid->name = gf_strdup(name);\n\t}\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_name(GF_FilterPid *pid)\n{\n\treturn pid->pid->name;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_filter_name(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\treturn pid->pid->filter->name;\n\t}\n\treturn pid->filter->name;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_orig_src_args(GF_FilterPid *pid, Bool for_unicity)\n{\n\tu32 i;\n\tconst char *args;\n\t//move to true source pid\n\tpid = pid->pid;\n\targs = pid->filter->src_args;\n\tif (args && strstr(args, \"src\")) return args;\n\tgf_mx_p(pid->filter->tasks_mx);\n\tif (!pid->filter->num_input_pids) {\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn args;\n\t}\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (for_unicity && (pidi->pid->num_destinations>1)) {\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn \"__GPAC_SRC_FANOUT__\";\n\t\t}\n\t\tconst char *arg_src = gf_filter_pid_orig_src_args(pidi->pid, for_unicity);\n\t\tif (arg_src) {\n\t\t\tif (for_unicity && !strcmp(arg_src, \"__GPAC_SRC_FANOUT__\"))\n\t\t\t\targ_src = pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args;\n\t\t\tif (arg_src) {\n\t\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\t\treturn arg_src;\n\t\t\t}\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn args;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_source_filter_name(GF_FilterPid *pid)\n{\n\tGF_Filter *filter  = pid->pid->filter;\n\twhile (1) {\n\t\tGF_Filter *f;\n\t\tif (!filter) break;\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tif (!filter->num_input_pids) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tbreak;\n\t\t}\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, 0);\n\t\tf = pidi->pid->filter;\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tfilter = f;\n\t}\n\tif (!filter) return NULL;\n\treturn filter->name ? filter->name : filter->freg->name;\n}\n\nGF_EXPORT\nBool gf_filter_pid_get_buffer_occupancy(GF_FilterPid *pid, u32 *max_slots, u32 *nb_pck, u32 *max_duration, u32 *duration)\n{\n\tif (max_slots) *max_slots = pid->pid->max_buffer_unit;\n\tif (max_duration) *max_duration = (u32) pid->pid->max_buffer_time;\n\n\tif (pid->filter->session->in_final_flush) {\n\t\tif (duration) *duration =  (u32) pid->pid->max_buffer_time;\n\t\tif (nb_pck) *nb_pck = pid->pid->nb_buffer_unit;\n\t\treturn GF_FALSE;\n\t}\n\tif (nb_pck) *nb_pck = pid->pid->nb_buffer_unit;\n\tif (duration) *duration = (u32) pid->pid->buffer_duration;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_udta(GF_FilterPid *pid, void *udta)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\t((GF_FilterPidInst *)pid)->udta = udta;\n\t} else {\n\t\tpid->udta = udta;\n\t}\n}\n\nGF_EXPORT\nvoid *gf_filter_pid_get_udta(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\treturn ((GF_FilterPidInst *)pid)->udta;\n\t} else {\n\t\treturn pid->udta;\n\t}\n}\n\nstatic Bool filter_pid_check_fragment(GF_FilterPid *src_pid, char *frag_name, Bool *pid_excluded, Bool *needs_resolve, Bool *prop_not_found, char prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE])\n{\n\tchar *psep;\n\tu32 comp_type=0;\n\tBool is_neg = GF_FALSE;\n\tconst GF_PropertyEntry *pent;\n\tconst GF_PropertyEntry *pent_val=NULL;\n\t*needs_resolve = GF_FALSE;\n\t*prop_not_found = GF_FALSE;\n\n\tif (frag_name[0] == src_pid->filter->session->sep_neg) {\n\t\tfrag_name++;\n\t\tis_neg = GF_TRUE;\n\t}\n\t//special case for stream types filters\n\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_STREAM_TYPE);\n\tif (pent) {\n\t\tu32 matched=0;\n\t\tu32 type=0;\n\t\tu32 ptype = pent->prop.value.uint;\n\n\t\tif (!strnicmp(frag_name, \"audio\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_AUDIO;\n\t\t} else if (!strnicmp(frag_name, \"video\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_VISUAL;\n\t\t} else if (!strnicmp(frag_name, \"scene\", 5)) {\n\t\t\tmatched=5;\n\t\t\ttype=GF_STREAM_SCENE;\n\t\t} else if (!strnicmp(frag_name, \"font\", 4)) {\n\t\t\tmatched=4;\n\t\t\ttype=GF_STREAM_FONT;\n\t\t} else if (!strnicmp(frag_name, \"text\", 4)) {\n\t\t\tmatched=4;\n\t\t\ttype=GF_STREAM_TEXT;\n\t\t} else {\n\t\t\t//frag name is a 4CC, check if we have an isom handler set\n\t\t\t//if same 4CC consider we have a match\n\t\t\tif (strlen(frag_name)==4) {\n\t\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_ISOM_HANDLER);\n\t\t\t\tif (pent && (pent->prop.value.uint == gf_4cc_parse(frag_name)) ) {\n\t\t\t\t\tmatched=4;\n\t\t\t\t\ttype = ptype;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//stream is encrypted and desired type is not, get original stream type\n\t\tif ((ptype == GF_STREAM_ENCRYPTED) && type && (type != GF_STREAM_ENCRYPTED) ) {\n\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\t\tif (pent) ptype = pent->prop.value.uint;\n\t\t}\n\n\t\tif (matched &&\n\t\t\t( (!is_neg && (type != ptype)) || (is_neg && (type == ptype)) )\n\t\t) {\n\t\t\t//special case: if we request a non-file stream but the pid is a file, we will need a demux to\n\t\t\t//move from file to A/V/... streams, so we accept any #MEDIA from file streams\n\t\t\tif (ptype == GF_STREAM_FILE) {\n\t\t\t\t*prop_not_found = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\n\t\tif (matched) {\n\t\t\tu32 idx=0;\n\t\t\tu32 k, count_pid;\n\t\t\tif (strlen(frag_name)==matched) return GF_TRUE;\n\t\t\tidx = atoi(frag_name+matched);\n\t\t\tcount_pid = src_pid->filter->num_output_pids;\n\t\t\tfor (k=0; k<count_pid; k++) {\n\t\t\t\tGF_FilterPid *p = gf_list_get(src_pid->filter->output_pids, k);\n\t\t\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\t\tif (pent && pent->prop.value.uint==type) {\n\t\t\t\t\tidx--;\n\t\t\t\t\tif (!idx\n\t\t\t\t\t\t//special case if single output of source, consider it a match\n\t\t\t\t\t\t//this is needed for cases where intermediate filters are single-pid:\n\t\t\t\t\t\t//mp4dmx @#video1 @ f1 @ f2 @ f3 @@0#video2 @f4 @f5 @f6\n\t\t\t\t\t\t//filters f2 and f5 will only output a single pid\n\t\t\t\t\t\t|| ((count_pid==1) && !src_pid->filter->max_extra_pids)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (p==src_pid) return GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\t//special case for codec type filters\n\tif (!strcmp(frag_name, \"raw\")) {\n\t\tpent = gf_filter_pid_get_property_entry(src_pid, GF_PROP_PID_CODECID);\n\t\tif (pent) {\n\t\t\tBool is_eq = (pent->prop.value.uint==GF_CODECID_RAW) ? GF_TRUE : GF_FALSE;\n\t\t\tif (is_neg) is_eq = !is_eq;\n\t\t\tif (is_eq) return GF_TRUE;\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\t//not codec ID set for pid, assume match\n\t\treturn GF_TRUE;\n\t}\n\n\t//generic property addressing code(or builtin name)=val\n\tpsep = strchr(frag_name, src_pid->filter->session->sep_name);\n\tif (!psep) {\n\t\tpsep = strchr(frag_name, '-');\n\t\tif (psep) comp_type = 1;\n\t\telse {\n\t\t\tpsep = strchr(frag_name, '+');\n\t\t\tif (psep) comp_type = 2;\n\t\t}\n\t}\n\n\tif (!psep) {\n\t\t*prop_not_found = GF_TRUE;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID addressing %s not recognized, ignoring and assuming match\\n\", frag_name ));\n\t\treturn GF_TRUE;\n\t}\n\n\tBool is_equal = GF_FALSE;\n\tBool use_not_equal = GF_FALSE;\n\tGF_PropertyValue prop_val;\n\tu32 p4cc = 0;\n\tchar c=psep[0];\n\tpsep[0] = 0;\n\tpent=NULL;\n\n\t//special case for tag\n\tif (!strcmp(frag_name, \"TAG\") || !strcmp(frag_name, \"ITAG\")) {\n\t\tpsep[0] = c;\n\t\tif (src_pid->filter->tag) {\n\t\t\tBool is_eq;\n\t\t\t//check for negation\n\t\t\tif ( (psep[0]==src_pid->filter->session->sep_name) && (psep[1]==src_pid->filter->session->sep_neg) ) {\n\t\t\t\tpsep++;\n\t\t\t\tuse_not_equal = GF_TRUE;\n\t\t\t}\n\n\t\t\tis_eq = !strcmp(psep+1, src_pid->filter->tag);\n\t\t\tif (use_not_equal) is_eq = !is_eq;\n\t\t\tif (is_eq) return GF_TRUE;\n\t\t\t*pid_excluded = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\t//not tag set for pid's filter, assume match\n\t\treturn GF_TRUE;\n\t}\n\n\n\t//check for built-in property\n\tp4cc = gf_props_get_id(frag_name);\n\tif (!p4cc && !strcmp(frag_name, \"PID\") )\n\t\tp4cc = GF_PROP_PID_ID;\n\n\tif (!p4cc && (strlen(frag_name)==4))\n\t\tp4cc = GF_4CC(frag_name[0], frag_name[1], frag_name[2], frag_name[3]);\n\n\tif (p4cc) pent = gf_filter_pid_get_property_entry(src_pid, p4cc);\n\t//not a built-in property, find prop by name\n\tif (!pent) {\n\t\tpent = gf_filter_pid_get_property_entry_str(src_pid, frag_name);\n\t}\n\n\tpsep[0] = c;\n\n\t//if the property is not found, we accept the connection\n\tif (!pent) {\n\t\t*prop_not_found = GF_TRUE;\n\t\treturn GF_TRUE;\n\t}\n\t//check for dynamic assignment\n\tif ( (psep[0]==src_pid->filter->session->sep_name) && ((psep[1]=='*') || (psep[1]=='\\0') ) ) {\n\t\t*needs_resolve = GF_TRUE;\n\t\tgf_props_dump_val(&pent->prop, prop_dump_buffer, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\treturn GF_FALSE;\n\t}\n\n\t//check for negation\n\tif ( (psep[0]==src_pid->filter->session->sep_name) && (psep[1]==src_pid->filter->session->sep_neg) ) {\n\t\tpsep++;\n\t\tuse_not_equal = GF_TRUE;\n\t}\n\n\t//parse the property, based on its property type\n\tif (pent->p4cc==GF_PROP_PID_CODECID) {\n\t\tprop_val.type = GF_PROP_UINT;\n\t\tprop_val.value.uint = gf_codecid_parse(psep+1);\n\t}\n\t//parse the property, based on its property type\n\telse if (pent->p4cc==GF_PROP_PID_STREAM_TYPE) {\n\t\tprop_val.type = GF_PROP_UINT;\n\t\tprop_val.value.uint = gf_stream_type_by_name(psep+1);\n\t} else {\n\t\tu32 val_is_prop = gf_props_get_id(psep+1);\n\t\tif (val_is_prop) {\n\t\t\tpent_val = gf_filter_pid_get_property_entry(src_pid, val_is_prop);\n\t\t\tif (pent_val) {\n\t\t\t\tprop_val = pent_val->prop;\n\t\t\t} else {\n\t\t\t\t*pid_excluded = GF_TRUE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tprop_val = gf_props_parse_value(pent->prop.type, frag_name, psep+1, NULL, src_pid->filter->session->sep_list);\n\t\t}\n\t}\n\tif (!comp_type) {\n\t\tis_equal = gf_props_equal(&pent->prop, &prop_val);\n\t\tif (use_not_equal) is_equal = !is_equal;\n\t} else {\n\t\tswitch (prop_val.type) {\n\t\tcase GF_PROP_SINT:\n\t\t\tif (pent->prop.value.sint<prop_val.value.sint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\tif (pent->prop.value.uint<prop_val.value.uint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_LSINT:\n\t\t\tif (pent->prop.value.longsint<prop_val.value.longsint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\tif (pent->prop.value.longuint<prop_val.value.longuint) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FLOAT:\n\t\t\tif (pent->prop.value.fnumber<prop_val.value.fnumber) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_DOUBLE:\n\t\t\tif (pent->prop.value.number<prop_val.value.number) is_equal = GF_TRUE;\n\t\t\tif (comp_type==2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\tif (pent->prop.value.frac.num * prop_val.value.frac.den < pent->prop.value.frac.den * prop_val.value.frac.num) is_equal = GF_TRUE;\n\t\t\tif (comp_type == 2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION64:\n\t\t\tif (pent->prop.value.lfrac.num * prop_val.value.lfrac.den < pent->prop.value.lfrac.den * prop_val.value.lfrac.num) is_equal = GF_TRUE;\n\t\t\tif (comp_type == 2) is_equal = !is_equal;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID addressing uses \\'%s\\' comparison on property %s which is not a number, defaulting to equal=true\\n\", (comp_type==1) ? \"less than\" : \"more than\", gf_props_4cc_get_name(p4cc) ));\n\t\t\tis_equal = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!pent_val)\n\t\tgf_props_reset_single(&prop_val);\n\n\tif (!is_equal) *pid_excluded = GF_TRUE;\n\n\treturn is_equal;\n}\n\nstatic Bool filter_source_id_match(GF_FilterPid *src_pid, const char *id, GF_Filter *dst_filter, Bool *pid_excluded, Bool *needs_clone)\n{\n\tconst char *source_ids;\n\tchar *resolved_source_ids = NULL;\n\tBool result = GF_FALSE;\n\tBool first_pass = GF_TRUE;\n\tBool has_default_match;\n\tBool is_pid_excluded;\n\t*pid_excluded = GF_FALSE;\n\tif (!dst_filter->source_ids)\n\t\treturn GF_TRUE;\n\tif (!id)\n\t\treturn GF_FALSE;\n\nsourceid_reassign:\n\tsource_ids = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;\n\tif (!first_pass) {\n\t\tassert(dst_filter->dynamic_source_ids);\n\t\tsource_ids = dst_filter->dynamic_source_ids;\n\t}\n\thas_default_match = GF_FALSE;\n\tis_pid_excluded = GF_FALSE;\n\n\twhile (source_ids) {\n\t\tBool all_matched = GF_TRUE;\n\t\tBool all_frags_not_found = GF_TRUE;\n\t\tu32 len, sublen;\n\t\tBool last=GF_FALSE;\n\t\tchar *frag_name, *frag_clone;\n\t\tchar *sep;\n\t\tBool use_neg = GF_FALSE;\n\t\tif (source_ids[0] == src_pid->filter->session->sep_neg) {\n\t\t\tsource_ids++;\n\t\t\tuse_neg = GF_TRUE;\n\t\t}\n\n\t\tsep = strchr(source_ids, src_pid->filter->session->sep_list);\n\t\tif (sep) {\n\t\t\tlen = (u32) (sep - source_ids);\n\t\t} else {\n\t\t\tlen = (u32) strlen(source_ids);\n\t\t\tlast=GF_TRUE;\n\t\t}\n\n\t\tfrag_name = strchr(source_ids, src_pid->filter->session->sep_frag);\n\t\tif (frag_name > source_ids + len) frag_name = NULL;\n\t\tsublen = frag_name ? (u32) (frag_name - source_ids) : len;\n\t\t//skip frag char\n\t\tif (frag_name) frag_name++;\n\n\t\t//any ID, always match\n\t\tif (source_ids[0]=='*') { }\n\t\t// id does not match\n\t\telse {\n\t\t\tBool res = strncmp(id, source_ids, sublen) ? GF_FALSE : GF_TRUE;\n\t\t\tif (use_neg) res = !res;\n\t\t\tif (!res) {\n\t\t\t\tsource_ids += len+1;\n\t\t\t\tif (last) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//no fragment or fragment match pid name, OK\n\t\tif (!frag_name || !strcmp(src_pid->name, frag_name)) {\n\t\t\tresult = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tfrag_clone = NULL;\n\t\tif (!last) {\n\t\t\tfrag_clone = gf_strdup(frag_name);\n\t\t\tchar *nsep = strchr(frag_clone, src_pid->filter->session->sep_list);\n\t\t\tassert(nsep);\n\t\t\tnsep[0] = 0;\n\t\t\tfrag_name = frag_clone;\n\t\t}\n\n\t\t//for all listed fragment extensions\n\t\twhile (frag_name && all_matched) {\n\t\t\tchar prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];\n\t\t\tBool needs_resolve = GF_FALSE;\n\t\t\tBool prop_not_found = GF_FALSE;\n\t\t\tBool local_pid_excluded = GF_FALSE;\n\t\t\tchar *next_frag = strchr(frag_name, src_pid->filter->session->sep_frag);\n\t\t\tif (next_frag) next_frag[0] = 0;\n\n\t\t\tif (! filter_pid_check_fragment(src_pid, frag_name, &local_pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer)) {\n\t\t\t\tif (needs_resolve) {\n\t\t\t\t\tif (first_pass) {\n\t\t\t\t\t\tchar *sid = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;\n\t\t\t\t\t\tchar *frag_sep = strchr(frag_name, dst_filter->session->sep_name);\n\t\t\t\t\t\tassert(frag_sep);\n\t\t\t\t\t\tif (next_frag) next_frag[0] = src_pid->filter->session->sep_frag;\n\n\t\t\t\t\t\tchar *new_source_ids = gf_malloc(sizeof(char) * (strlen(sid) + strlen(prop_dump_buffer)+1));\n\t\t\t\t\t\tu32 clen = (u32) (1+frag_sep - sid);\n\t\t\t\t\t\tstrncpy(new_source_ids, sid, clen);\n\t\t\t\t\t\tnew_source_ids[clen]=0;\n\t\t\t\t\t\tstrcat(new_source_ids, prop_dump_buffer);\n\t\t\t\t\t\tif (next_frag) strcat(new_source_ids, next_frag);\n\n\t\t\t\t\t\tif (resolved_source_ids) gf_free(resolved_source_ids);\n\t\t\t\t\t\tresolved_source_ids = new_source_ids;\n\t\t\t\t\t\tif (frag_clone) gf_free(frag_clone);\n\t\t\t\t\t\tgoto sourceid_reassign;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tall_matched = GF_FALSE;\n\t\t\t\t\t//remember we failed because PID was excluded by sourceID\n\t\t\t\t\tif (local_pid_excluded)\n\t\t\t\t\t\tis_pid_excluded = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//remember we succeed because PID has no matching property\n\t\t\t\tif (!prop_not_found)\n\t\t\t\t\tall_frags_not_found = GF_FALSE;\n\t\t\t}\n\n\t\t\tif (!next_frag) break;\n\n\t\t\tnext_frag[0] = src_pid->filter->session->sep_frag;\n\t\t\tfrag_name = next_frag+1;\n\t\t}\n\t\tif (frag_clone) gf_free(frag_clone);\n\t\tif (all_matched) {\n\t\t\t//exact match on one or more properties, don't look any further\n\t\t\tif (!all_frags_not_found) {\n\t\t\t\tresult = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//remember we had a default match, but don't set result yet and parse other SIDs\n\t\t\thas_default_match = GF_TRUE;\n\t\t}\n\t\t*needs_clone = GF_FALSE;\n\t\tif (!sep) break;\n\t\tsource_ids = sep+1;\n\t}\n\n\tif (!result) {\n\t\t//we had a default match and pid was not excluded by any SIDs, consider we pass\n\t\tif (has_default_match && !is_pid_excluded)\n\t\t\tresult = GF_TRUE;\n\t}\n\n\tif (!result) {\n\t\tif (resolved_source_ids) gf_free(resolved_source_ids);\n\t\tif (dst_filter->dynamic_source_ids && first_pass) {\n\t\t\tfirst_pass = GF_FALSE;\n\t\t\tgoto sourceid_reassign;\n\t\t}\n\t\t*pid_excluded = is_pid_excluded;\n\t\treturn GF_FALSE;\n\t}\n\tif (resolved_source_ids) {\n\t\tif (!dst_filter->dynamic_source_ids) {\n\t\t\tdst_filter->dynamic_source_ids = dst_filter->source_ids;\n\t\t\tdst_filter->source_ids = resolved_source_ids;\n\t\t} else {\n\t\t\tgf_free(dst_filter->source_ids);\n\t\t\tdst_filter->source_ids = resolved_source_ids;\n\t\t}\n\t}\n\tif (!first_pass) {\n\t\t*needs_clone = GF_TRUE;\n\t}\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_in_parent_chain(GF_Filter *parent, GF_Filter *filter)\n{\n\tu32 i;\n\tif (parent == filter) return GF_TRUE;\n\n\t//browse all parent PIDs - we must lock the parent filter\n\t//as some pid init tasks may be in process in other threads\n\tgf_mx_p(parent->tasks_mx);\n\tif (!parent->num_input_pids) {\n\t\tgf_mx_v(parent->tasks_mx);\n\t\treturn GF_FALSE;\n\t}\n\t//single source filter, do not browse pids\n\tif (parent->single_source) {\n\t\tBool res = gf_filter_in_parent_chain(parent->single_source, filter);\n\t\tgf_mx_v(parent->tasks_mx);\n\t\treturn res;\n\t}\n\tfor (i=0; i<parent->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(parent->input_pids, i);\n\t\tif (gf_filter_in_parent_chain(pidi->pid->filter, filter)) {\n\t\t\tgf_mx_v(parent->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tfor (i=0; i<gf_list_count(parent->temp_input_pids); i++) {\n\t\tGF_FilterPid *a_src_pid = gf_list_get(parent->temp_input_pids, i);\n\t\tif (gf_filter_in_parent_chain(a_src_pid->filter, filter)) {\n\t\t\tgf_mx_v(parent->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(parent->tasks_mx);\n\treturn GF_FALSE;\n}\n\n\nstatic Bool cap_code_match(u32 c1, u32 c2)\n{\n\tif (c1==c2) return GF_TRUE;\n\t/*we consider GF_PROP_PID_FILE_EXT and GF_PROP_PID_MIME are the same so that we check\n\tif we have at least one match of file ext or mime in a given bundle*/\n\tif ((c1==GF_PROP_PID_FILE_EXT) && (c2==GF_PROP_PID_MIME)) return GF_TRUE;\n\tif ((c1==GF_PROP_PID_MIME) && (c2==GF_PROP_PID_FILE_EXT)) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nBool gf_filter_pid_caps_match(GF_FilterPid *src_pid_or_ipid, const GF_FilterRegister *freg, GF_Filter *filter_inst, u8 *priority, u32 *dst_bundle_idx, GF_Filter *dst_filter, s32 for_bundle_idx)\n{\n\tu32 i=0;\n\tu32 cur_bundle_start = 0;\n\tu32 cap_bundle_idx = 0;\n\tu32 nb_subcaps=0;\n\tBool skip_explicit_load = GF_FALSE;\n\tBool all_caps_matched = GF_TRUE;\n\tBool mime_matched = GF_FALSE;\n\tBool has_file_ext_cap = GF_FALSE;\n\tBool ext_not_trusted;\n\tGF_FilterPid *src_pid = src_pid_or_ipid->pid;\n\tconst GF_FilterCapability *in_caps;\n\tu32 nb_in_caps;\n\n\tif (!freg) {\n\t\tassert(dst_filter);\n\t\tfreg = dst_filter->freg;\n\t\tskip_explicit_load = GF_TRUE;\n\t}\n\n\tin_caps = freg->caps;\n\tnb_in_caps = freg->nb_caps;\n\tif (filter_inst && (filter_inst->freg==freg)) {\n\t\tskip_explicit_load = GF_TRUE;\n\t\tif (filter_inst->forced_caps) {\n\t\t\tin_caps = filter_inst->forced_caps;\n\t\t\tnb_in_caps = filter_inst->nb_forced_caps;\n\t\t}\n\t}\n\text_not_trusted = src_pid->ext_not_trusted;\n\tif (ext_not_trusted) {\n\t\tBool has_mime_cap = GF_FALSE;\n\n\t\tfor (i=0; i<nb_in_caps; i++) {\n\t\t\tconst GF_FilterCapability *cap = &in_caps[i];\n\t\t\tif (! (cap->flags & GF_CAPFLAG_INPUT) ) continue;\n\t\t\tif (cap->code == GF_PROP_PID_MIME) {\n\t\t\t\thas_mime_cap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!has_mime_cap) ext_not_trusted = GF_FALSE;\n\t}\n\n\tif (filter_inst && filter_inst->encoder_stream_type) {\n\t\tconst GF_PropertyValue *pid_st = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (pid_st && (pid_st->value.uint != filter_inst->encoder_stream_type))\n\t\t\treturn GF_FALSE;\n\t}\n\n\tif (priority)\n\t\t(*priority) = freg->priority;\n\n\tif (dst_bundle_idx)\n\t\t(*dst_bundle_idx) = 0;\n\n\t//filters with no explicit input cap accept anything for now, this should be refined ...\n\tif (!in_caps)\n\t\treturn GF_TRUE;\n\n\t//check all input caps of dst filter\n\tfor (i=0; i<nb_in_caps; i++) {\n\t\tconst GF_PropertyValue *pid_cap=NULL;\n\t\tconst GF_FilterCapability *cap = &in_caps[i];\n\n\t\t/*end of cap bundle*/\n\t\tif (i && !(cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\tif (has_file_ext_cap && ext_not_trusted && !mime_matched)\n\t\t\t\tall_caps_matched = GF_FALSE;\n\n\t\t\tif (all_caps_matched) {\n\t\t\t\tif (dst_bundle_idx)\n\t\t\t\t\t(*dst_bundle_idx) = cap_bundle_idx;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tall_caps_matched = GF_TRUE;\n\t\t\tmime_matched = GF_FALSE;\n\t\t\thas_file_ext_cap = GF_FALSE;\n\t\t\tnb_subcaps=0;\n\t\t\tcur_bundle_start = i;\n\t\t\tcap_bundle_idx++;\n\t\t\tif ((for_bundle_idx>=0) && (cap_bundle_idx > (u32) for_bundle_idx)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ((for_bundle_idx>=0) && (cap_bundle_idx < (u32) for_bundle_idx)) {\n\t\t\tall_caps_matched = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not an input cap\n\t\tif (! (cap->flags & GF_CAPFLAG_INPUT) ) {\n\t\t\tif (!skip_explicit_load && (cap->flags & GF_CAPFLAG_LOADED_FILTER) ) {\n\t\t\t\tall_caps_matched = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tnb_subcaps++;\n\t\t//no match for this cap, go on until new one or end\n\t\tif (!all_caps_matched) continue;\n\n\t\tif (cap->code) {\n\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, cap->code);\n\n\t\t\t//special case for file ext: the pid will likely have only one file extension defined, and the output as well\n\t\t\t//we browse all caps of the filter owning the pid, looking for the original file extension property\n\t\t\tif (pid_cap && (cap->code==GF_PROP_PID_FILE_EXT) ) {\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<src_pid->filter->freg->nb_caps; j++) {\n\t\t\t\t\tconst GF_FilterCapability *out_cap = &src_pid->filter->freg->caps[j];\n\t\t\t\t\tif (!(out_cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\t\t\tif (out_cap->code != GF_PROP_PID_FILE_EXT) continue;\n\t\t\t\t\tif (! gf_props_equal(pid_cap, &out_cap->val)) continue;\n\t\t\t\t\tpid_cap = &out_cap->val;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if PID prop for this cap is not found and the cap is MIME (resp. file ext), fetch file_ext (resp MIME)\n\t\t\t so that we check if we have at least one match of file ext or mime in a given bundle*/\n\t\t\tif (!pid_cap) {\n\t\t\t\tif (cap->code==GF_PROP_PID_FILE_EXT)\n\t\t\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_MIME);\n\t\t\t\telse if (cap->code==GF_PROP_PID_MIME)\n\t\t\t\t\tpid_cap = gf_filter_pid_get_property_first(src_pid_or_ipid, GF_PROP_PID_FILE_EXT);\n\t\t\t}\n\t\t}\n\n\t\t//try by name\n\t\tif (!pid_cap && cap->name) pid_cap = gf_filter_pid_get_property_str_first(src_pid_or_ipid, cap->name);\n\n\t\tif (ext_not_trusted && (cap->code==GF_PROP_PID_FILE_EXT)) {\n\t\t\thas_file_ext_cap = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//optional cap, only adjust priority\n\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) {\n\t\t\tif (pid_cap && priority && cap->priority && ((*priority) < cap->priority)) {\n\t\t\t\t(*priority) = cap->priority;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t//we found a property of that type and it is equal\n\t\tif (pid_cap) {\n\t\t\tu32 j;\n\t\t\tBool prop_excluded = GF_FALSE;\n\t\t\tBool prop_equal = GF_FALSE;\n\n\t\t\t//this could be optimized by not checking several times the same cap\n\t\t\tfor (j=0; j<nb_in_caps; j++) {\n\t\t\t\tconst GF_FilterCapability *a_cap = &in_caps[j];\n\n\t\t\t\tif ((j>cur_bundle_start) && ! (a_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//not an input cap\n\t\t\t\tif (! (a_cap->flags & GF_CAPFLAG_INPUT) ) continue;\n\t\t\t\t//not a static and not in bundle\n\t\t\t\tif (! (a_cap->flags & GF_CAPFLAG_STATIC)) {\n\t\t\t\t\tif (j<cur_bundle_start)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cap->code) {\n\t\t\t\t\tif (!cap_code_match(cap->code, a_cap->code) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (!cap->name || !a_cap->name || strcmp(cap->name, a_cap->name)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!skip_explicit_load && (a_cap->flags & GF_CAPFLAG_LOADED_FILTER) ) {\n\t\t\t\t\tif (!dst_filter || (dst_filter != src_pid->filter->dst_filter)) {\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (dst_filter->freg != freg) {\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!prop_equal) {\n\t\t\t\t\tprop_equal = gf_props_equal(pid_cap, &a_cap->val);\n\t\t\t\t\t//excluded cap: if value match, don't match this cap at all\n\t\t\t\t\tif (a_cap->flags & GF_CAPFLAG_EXCLUDED) {\n\t\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\t\tprop_equal = GF_FALSE;\n\t\t\t\t\t\t\tprop_excluded = GF_FALSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprop_excluded = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tif (priority && a_cap->priority && ((*priority) < a_cap->priority)) {\n\t\t\t\t\t\t\t(*priority) = a_cap->priority;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!prop_equal && !prop_excluded) {\n\t\t\t\tall_caps_matched=GF_FALSE;\n\t\t\t}\n\t\t\tif (ext_not_trusted && prop_equal && (cap->code==GF_PROP_PID_MIME))\n\t\t\t\tmime_matched = GF_TRUE;\n\t\t}\n\t\telse if (! (cap->flags & (GF_CAPFLAG_EXCLUDED | GF_CAPFLAG_OPTIONAL) ) ) {\n\t\t\tall_caps_matched=GF_FALSE;\n\t\t}\n\t}\n\n\tif (has_file_ext_cap && ext_not_trusted && !mime_matched)\n\t\tall_caps_matched = GF_FALSE;\n\n\tif (nb_subcaps && all_caps_matched) {\n\t\tif (dst_bundle_idx)\n\t\t\t(*dst_bundle_idx) = cap_bundle_idx;\n\t\treturn GF_TRUE;\n\t}\n\n\treturn GF_FALSE;\n}\n\nu32 gf_filter_caps_bundle_count(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\tu32 i, nb_bundles = 0, num_in_bundle=0;\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (! (cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tif (num_in_bundle) nb_bundles++;\n\t\t\tnum_in_bundle=0;\n\t\t\tcontinue;\n\t\t}\n\t\tnum_in_bundle++;\n\t}\n\tif (num_in_bundle) nb_bundles++;\n\treturn nb_bundles;\n}\n\nstatic Bool gf_filter_has_in_out_caps(const GF_FilterCapability *caps, u32 nb_caps, Bool check_in)\n{\n\tu32 i;\n\t//check all input caps of dst filter, count bundles\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *a_cap = &caps[i];\n\t\tif (check_in) {\n\t\t\tif (a_cap->flags & GF_CAPFLAG_INPUT) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a_cap->flags & GF_CAPFLAG_OUTPUT) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n\n}\nBool gf_filter_has_out_caps(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\treturn gf_filter_has_in_out_caps(caps, nb_caps, GF_FALSE);\n}\nBool gf_filter_has_in_caps(const GF_FilterCapability *caps, u32 nb_caps)\n{\n\treturn gf_filter_has_in_out_caps(caps, nb_caps, GF_TRUE);\n}\n\nu32 gf_filter_caps_to_caps_match(const GF_FilterRegister *src, u32 src_bundle_idx, const GF_FilterRegister *dst_reg, GF_Filter *dst_filter, u32 *dst_bundle_idx, u32 for_dst_bundle, u32 *loaded_filter_flags, GF_CapsBundleStore *capstore)\n{\n\tu32 i=0;\n\ts32 first_static_cap=-1;\n\tu32 cur_bundle_start = 0;\n\tu32 cur_bundle_idx = 0;\n\tu32 nb_matched=0;\n\t//u32 nb_out_caps=0;\n\tu32 nb_in_bundles=0;\n\tu32 bundle_score = 0;\n\tu32 *bundles_in_ok = NULL;\n\tu32 *bundles_cap_found = NULL;\n\tu32 *bundles_in_scores = NULL;\n\t//initialize caps matched to true for first cap bundle\n\tBool all_caps_matched = GF_TRUE;\n\tconst GF_FilterCapability *dst_caps = dst_reg->caps;\n\tu32 nb_dst_caps = dst_reg->nb_caps;\n\n\tif (dst_filter && dst_filter->freg==dst_reg && dst_filter->forced_caps) {\n\t\tdst_caps = dst_filter->forced_caps;\n\t\tnb_dst_caps = dst_filter->nb_forced_caps;\n\t}\n\n\t//check all input caps of dst filter, count bundles\n\tif (! gf_filter_has_out_caps(src->caps, src->nb_caps)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no output caps, cannot match filter %s inputs\\n\", src->name, dst_reg->name));\n\t\treturn 0;\n\t}\n\n\t//check all input caps of dst filter, count bundles\n\tnb_in_bundles = gf_filter_caps_bundle_count(dst_caps, nb_dst_caps);\n\tif (!nb_in_bundles) {\n\t\tif (dst_reg->configure_pid) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no caps but pid configure possible, assuming possible connection\\n\", dst_reg->name));\n\t\t\treturn 1;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no caps and no pid configure, no possible connection\\n\", dst_reg->name));\n\t\treturn 0;\n\t}\n\tif (capstore->nb_allocs < nb_in_bundles) {\n\t\tcapstore->nb_allocs = nb_in_bundles;\n\t\tcapstore->bundles_in_ok = gf_realloc(capstore->bundles_in_ok, sizeof(u32) * nb_in_bundles);\n\t\tcapstore->bundles_cap_found = gf_realloc(capstore->bundles_cap_found, sizeof(u32) * nb_in_bundles);\n\t\tcapstore->bundles_in_scores = gf_realloc(capstore->bundles_in_scores,  sizeof(u32) * nb_in_bundles);\n\t}\n\tbundles_in_ok =\tcapstore->bundles_in_ok;\n\tbundles_cap_found = capstore->bundles_cap_found;\n\tbundles_in_scores = capstore->bundles_in_scores;\n\n\tfor (i=0; i<nb_in_bundles; i++) {\n\t\tbundles_in_ok[i] = 1;\n\t\tbundles_cap_found[i] = 0;\n\t\tbundles_in_scores[i] = 0;\n\t}\n\n\t//check all output caps of src filter\n\tfor (i=0; i<src->nb_caps; i++) {\n\t\tu32 j, k;\n\t\tBool already_tested = GF_FALSE;\n\t\tconst GF_FilterCapability *out_cap = &src->caps[i];\n\n\t\tif (i<cur_bundle_start) {\n\t\t\tif (!(out_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\tall_caps_matched = GF_TRUE;\n\t\t\tcur_bundle_start = i+1;\n\t\t\tcur_bundle_idx++;\n\t\t\tif (src_bundle_idx < cur_bundle_idx)\n\t\t\t\tbreak;\n\n\t\t\tif (first_static_cap>=0)\n\t\t\t\ti = (u32) (first_static_cap-1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not our selected output and not static cap\n\t\tif ((src_bundle_idx != cur_bundle_idx) && ! (out_cap->flags & GF_CAPFLAG_STATIC) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//not an output cap\n\t\tif (!(out_cap->flags & GF_CAPFLAG_OUTPUT) ) continue;\n\n\t\tif ((first_static_cap==-1) && (out_cap->flags & GF_CAPFLAG_STATIC)) {\n\t\t\tfirst_static_cap = i;\n\t\t}\n\n\n\t\t//no match possible for this cap, wait until next cap start\n\t\tif (!all_caps_matched) continue;\n\n\t\t//check we didn't test a cap with same name/code before us\n\t\tfor (k=cur_bundle_start; k<i; k++) {\n\t\t\tconst GF_FilterCapability *an_out_cap = &src->caps[k];\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out_cap->code && (out_cap->code == an_out_cap->code) ) {\n\t\t\t\talready_tested = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (out_cap->name && an_out_cap->name && !strcmp(out_cap->name, an_out_cap->name)) {\n\t\t\t\talready_tested = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (already_tested) {\n\t\t\tcontinue;\n\t\t}\n\t\t//nb_out_caps++;\n\n\t\t//set cap as OK in all bundles\n\t\tfor (k=0; k<nb_in_bundles; k++) {\n\t\t\tbundles_cap_found[k] = 0;\n\t\t}\n\n\t\t//check all output caps in this bundle with the same code/name, consider OK if one is matched\n\t\tif (first_static_cap>=0)\n\t\t\tk = first_static_cap-1;\n\t\telse\n\t\t\tk = cur_bundle_start;\n\n\t\tfor (; k<src->nb_caps; k++) {\n\t\t\tu32 cur_dst_bundle=0;\n\t\t\tBool static_matched = GF_FALSE;\n\t\t\tu32 nb_caps_tested = 0;\n\t\t\tu32 cap_loaded_filter_only = 0;\n\t\t\tBool matched=GF_FALSE;\n\t\t\tBool exclude=GF_FALSE;\n\t\t\tBool prop_found=GF_FALSE;\n\t\t\tconst GF_FilterCapability *an_out_cap = &src->caps[k];\n\n\t\t\tif (k<cur_bundle_start) {\n\t\t\t\tif (!(an_out_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out_cap->code && !cap_code_match(out_cap->code, an_out_cap->code) )\n\t\t\t\tcontinue;\n\n\t\t\tif (out_cap->name && (!an_out_cap->name || strcmp(out_cap->name, an_out_cap->name)))\n\t\t\t\tcontinue;\n\n\t\t\t//not our selected output and not static cap\n\t\t\tif ((src_bundle_idx != cur_bundle_idx) && ! (an_out_cap->flags & GF_CAPFLAG_STATIC) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnb_matched = 0;\n\t\t\t//check all input caps of dst filter, count ones that are matched\n\t\t\tfor (j=0; j<nb_dst_caps; j++) {\n\t\t\t\tBool prop_equal;\n\t\t\t\tconst GF_FilterCapability *in_cap = &dst_caps[j];\n\n\t\t\t\tif (! (in_cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t\t\tif (((cur_dst_bundle >= for_dst_bundle) || (in_cap->flags & GF_CAPFLAG_STATIC))) {\n\t\t\t\t\t\tif (!matched && !nb_caps_tested && (out_cap->flags & GF_CAPFLAG_EXCLUDED)) {\n\t\t\t\t\t\t\tmatched = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//we found a prop, excluded but with != value hence acceptable, default matching to true\n\t\t\t\t\tif (!matched && prop_found) matched = GF_TRUE;\n\n\t\t\t\t\t//match, flag this bundle as ok\n\t\t\t\t\tif (matched) {\n\t\t\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\t\t\tnb_matched++;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatched = static_matched ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tif (exclude) {\n\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = 0;\n\t\t\t\t\t\texclude = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\tnb_caps_tested = 0;\n\t\t\t\t\tcur_dst_bundle++;\n\t\t\t\t\tif (cur_dst_bundle > for_dst_bundle)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//not an input cap\n\t\t\t\tif (!(in_cap->flags & GF_CAPFLAG_INPUT) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//optional cap, ignore\n\t\t\t\tif (in_cap->flags & GF_CAPFLAG_OPTIONAL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((cur_dst_bundle < for_dst_bundle) && !(in_cap->flags & GF_CAPFLAG_STATIC))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//prop was excluded, cannot match in bundle\n\t\t\t\tif (exclude) continue;\n\t\t\t\t//prop was matched, no need to check other caps in the current bundle\n\t\t\t\tif (matched) continue;\n\n\t\t\t\tif (out_cap->code && !cap_code_match(out_cap->code, in_cap->code) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (out_cap->name && (!in_cap->name || strcmp(out_cap->name, in_cap->name)))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnb_caps_tested++;\n\t\t\t\t//we found a property of that type , check if equal equal\n\t\t\t\tprop_equal = gf_props_equal(&in_cap->val, &an_out_cap->val);\n\t\t\t\tif ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && !(an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//special case for excluded output caps marked for loaded filter only and optional:\n\t\t\t\t\t//always consider no match, the actual pid link resolving will sort this out\n\t\t\t\t\t//this fixes a bug in reframer -> ffdec links: since ffdec only specifies excluded GF_CODEC_ID caps,\n\t\t\t\t\t//not doing so will always force reframer->ufnalu->rfnalu->ffdec\n\t\t\t\t\tif (an_out_cap->flags & (GF_CAPFLAG_OPTIONAL|GF_CAPFLAG_LOADED_FILTER))\n\t\t\t\t\t\tprop_equal = GF_FALSE;\n\n\t\t\t\t\t//prop type matched, output includes it and input excludes it: no match, don't look any further\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tmatched = GF_FALSE;\n\t\t\t\t\t\texclude = GF_TRUE;\n\t\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//remember we found a prop of same type but excluded value\n\t\t\t\t\t\t// we will match unless we match an excluded value\n\t\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//prop type matched, input includes it and output excludes it: no match, don't look any further\n\t\t\t\t\tif (prop_equal) {\n\t\t\t\t\t\tmatched = GF_FALSE;\n\t\t\t\t\t\texclude = GF_TRUE;\n\t\t\t\t\t\tprop_found = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//remember we found a prop of same type but excluded value\n\t\t\t\t\t\t//we will match unless we match an excluded value\n\t\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (prop_equal) {\n\t\t\t\t\tmatched = GF_TRUE;\n//\t\t\t\t\tif (an_out_cap->flags & GF_CAPFLAG_STATIC)\n//\t\t\t\t\t\tstatic_matched = GF_TRUE;\n\t\t\t\t} else if ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {\n\t\t\t\t\t//prop type matched, input excludes it and output excludes it and no match, remmeber we found the prop type\n\t\t\t\t\tprop_found = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (prop_found && (in_cap->flags & GF_CAPFLAG_LOADED_FILTER))\n\t\t\t\t\tcap_loaded_filter_only = 1;\n\t\t\t}\n\t\t\tif (nb_caps_tested) {\n\t\t\t\t//we found a prop, excluded but with != value hence acceptable, default matching to true\n\t\t\t\tif (!matched && prop_found) matched = GF_TRUE;\n\t\t\t\t//not match, flag this bundle as not ok\n\t\t\t\tif (matched) {\n\t\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\t\tnb_matched++;\n\t\t\t\t}\n\t\t\t\t//excluded cap was found, disable bundle (might have been activated before we found the excluded cap)\n\t\t\t\telse if (exclude) {\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = 0;\n\t\t\t\t}\n\t\t\t} else if (!nb_dst_caps) {\n\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\tnb_matched++;\n\t\t\t} else if (!nb_matched && !prop_found && (an_out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL)) && (cur_dst_bundle<nb_in_bundles) ) {\n\t\t\t\tif (!bundles_cap_found[cur_dst_bundle])\n\t\t\t\t\tbundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;\n\n\t\t\t\tnb_matched++;\n\t\t\t}\n\t\t}\n\t\t//merge bundle cap\n\t\tnb_matched=0;\n\t\tfor (k=0; k<nb_in_bundles; k++) {\n\t\t\tif (!bundles_cap_found[k])\n\t\t\t\tbundles_in_ok[k] = 0;\n\t\t\telse {\n\t\t\t\tnb_matched += 1;\n\t\t\t\t//we matched this property, keep score for the bundle\n\t\t\t\tbundles_in_scores[k] ++;\n\t\t\t\t//mark if connection is only valid for loaded inputs\n\t\t\t\tif (bundles_cap_found[k]==2)\n\t\t\t\t \tbundles_in_ok[k] |= 1<<1;\n\t\t\t\t//mark if connection is only valid for loaded outputs\n\t\t\t\tif (out_cap->flags & GF_CAPFLAG_LOADED_FILTER)\n\t\t\t\t\tbundles_in_ok[k] |= 1<<2;\n\t\t\t}\n\t\t}\n\n\t\t//not matched and not excluded, skip until next bundle\n\t\tif (!nb_matched && !(out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL))) {\n\t\t\tall_caps_matched = GF_FALSE;\n\t\t}\n\t}\n\n\t//get bundle with highest score\n\tbundle_score = 0;\n\tnb_matched = 0;\n\n\tfor (i=0; i<nb_in_bundles; i++) {\n\t\tif (bundles_in_ok[i]) {\n\t\t\tnb_matched++;\n\t\t\tif (bundle_score < bundles_in_scores[i]) {\n\t\t\t\t*dst_bundle_idx = i;\n\t\t\t\tbundle_score = bundles_in_scores[i];\n\t\t\t\tif (loaded_filter_flags) {\n\t\t\t\t\t*loaded_filter_flags = (bundles_in_ok[i]>>1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (for_dst_bundle==i) {\n\t\t\t\t*dst_bundle_idx = i;\n\t\t\t\tif (loaded_filter_flags) {\n\t\t\t\t\t*loaded_filter_flags = (bundles_in_ok[i]>>1);\n\t\t\t\t}\n\t\t\t\treturn bundles_in_scores[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (!bundle_score) {\n//\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s outputs cap bundle %d do not match filter %s inputs\\n\", src->name, src_bundle_idx, dst_reg->name));\n\t} else {\n//\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s outputs cap bundle %d matches filter %s inputs caps bundle %d (%d total bundle matches, bundle matched %d/%d caps)\\n\", src->name, src_bundle_idx, dst_reg->name, *dst_bundle_idx, nb_matched, bundle_score, nb_out_caps));\n\t}\n\treturn bundle_score;\n}\n\nGF_EXPORT\nBool gf_filter_pid_check_caps(GF_FilterPid *_pid)\n{\n\tu8 priority;\n\tBool res;\n\tGF_Filter *on_filter;\n\tif (PID_IS_OUTPUT(_pid)) return GF_FALSE;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)_pid;\n\ton_filter = pidi->alias_orig ? pidi->alias_orig : pidi->filter;\n\tpidi->pid->local_props = pidi->props;\n\tres = gf_filter_pid_caps_match(pidi->pid, NULL, on_filter, &priority, NULL, on_filter, -1);\n\tpidi->pid->local_props = NULL;\n\treturn res;\n}\n\n\nstatic void concat_reg(GF_FilterSession *sess, char prefRegister[1001], const char *reg_key, const char *args)\n{\n\tu32 len;\n\tchar *forced_reg, *sep;\n\tif (!args) return;\n\tforced_reg = strstr(args, reg_key);\n\tif (!forced_reg) return;\n\tforced_reg += 6;\n\tsep = strchr(forced_reg, sess->sep_args);\n\tlen = sep ? (u32) (sep-forced_reg) : (u32) strlen(forced_reg);\n\tif (len+2+strlen(prefRegister)>1000) {\n\t\treturn;\n\t}\n\tif (prefRegister[0]) {\n\t\tchar szSepChar[2];\n\t\tszSepChar[0] = sess->sep_args;\n\t\tszSepChar[1] = 0;\n\t\tstrcat(prefRegister, szSepChar);\n\t}\n\tstrncat(prefRegister, forced_reg, len);\n}\n\nstatic Bool gf_filter_out_caps_solved_by_connection(const GF_FilterRegister *freg, u32 bundle_idx)\n{\n\tu32 i, k, cur_bundle_idx = 0;\n    u32 nb_out_caps=0;\n\tfor (i=0; i<freg->nb_caps; i++) {\n\t\tu32 nb_caps = 0;\n        u32 cap_bundle_idx = 0;\n\t\tconst GF_FilterCapability *cap = &freg->caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tcur_bundle_idx++;\n\t\t\tif (cur_bundle_idx>bundle_idx) return GF_FALSE;\n            continue;\n\t\t}\n\t\tif (!(cap->flags & GF_CAPFLAG_STATIC) && (bundle_idx>cur_bundle_idx)) continue;\n\t\tif (!(cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\n\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\n\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\tconst GF_FilterCapability *acap = &freg->caps[k];\n            if (!(acap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n                cap_bundle_idx++;\n                continue;\n            }\n\t\t\tif (!(acap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\tif (acap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\t\t\tif (!(acap->flags & GF_CAPFLAG_STATIC) && (cap_bundle_idx!=bundle_idx) ) continue;\n\n\t\t\tif (cap->code && (acap->code==cap->code)) {\n\t\t\t\tnb_caps++;\n\t\t\t} else if (cap->name && acap->name && !strcmp(cap->name, acap->name)) {\n\t\t\t\tnb_caps++;\n\t\t\t}\n\t\t\t//if more than one cap with same code in same bundle, consider the filter is undecided\n\t\t\tif (nb_caps>1)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n        if (nb_caps && !(cap->flags & GF_CAPFLAG_EXCLUDED))\n            nb_out_caps++;\n\t}\n\tif (!nb_out_caps)\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic s32 gf_filter_reg_get_bundle_stream_type(const GF_FilterRegister *freg, u32 cap_idx, Bool for_output)\n{\n\tu32 i, cur_bundle, stype=0, nb_stype=0;\n\n\tcur_bundle = 0;\n\tfor (i=0; i<freg->nb_caps; i++) {\n\t\tu32 cap_stype=0;\n\t\tconst GF_FilterCapability *cap = &freg->caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\tcur_bundle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (for_output) {\n\t\t\tif (!(cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t} else {\n\t\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t}\n\t\tif ((cur_bundle != cap_idx) && !(cap->flags & GF_CAPFLAG_STATIC) ) continue;\n\t\t//output type is file or same media type, allow looking for filter chains\n\t\tif (cap->flags & GF_CAPFLAG_EXCLUDED) continue;\n\n\t\tif (cap->code == GF_PROP_PID_STREAM_TYPE)\n\t\t\tcap_stype = cap->val.value.uint;\n\t\telse if ((cap->code == GF_PROP_PID_MIME) || (cap->code == GF_PROP_PID_FILE_EXT) )\n\t\t\tcap_stype = GF_STREAM_FILE;\n\n\t\tif (!cap_stype) continue;\n\n\t\tif (stype != cap_stype) {\n\t\t\tstype = cap_stype;\n\t\t\tnb_stype++;\n\t\t}\n\t}\n\tif (nb_stype==1) return (s32) stype;\n\tif (nb_stype) return -1;\n\treturn 0;\n}\n\n/*recursively enable edges of the graph.\n\treturns 0 if subgraph shall be disabled (will marke edge at the root of the subgraph disabled)\n\treturns 1 if subgraph shall be enabled (will marke edge at the root of the subgraph enabled)\n\treturns 2 if no decision can be taken because the subgraph is too deep. We don't mark the parent edge as disabled because the same subgraph/edge can be used at other places in a shorter path\n*/\nstatic u32 gf_filter_pid_enable_edges(GF_FilterSession *fsess, GF_FilterRegDesc *reg_desc, u32 src_cap_idx, const GF_FilterRegister *src_freg, u32 rlevel, s32 dst_stream_type, GF_FilterRegDesc *parent_desc, GF_FilterPid *pid, u32 pid_stream_type)\n{\n\tu32 i=0;\n\tBool enable_graph = GF_FALSE;\n\tBool aborted_graph_too_deep = GF_FALSE;\n\n\t//we found the source reg we want to connect to!\n\tif (src_freg == reg_desc->freg) {\n\t\treturn 1;\n\t}\n\t//the subgraph is too deep, abort marking edges but don't decide\n\tif (rlevel > fsess->max_resolve_chain_len) {\n\t\treturn 2;\n\t}\n\t//we don't allow loops in dynamic chain resolution, so consider the parent edge invalid\n\tif (reg_desc->in_edges_enabling)\n\t\treturn 0;\n\n\t/*if dst type is FILE, reg_desc is a muxer or the loaded destination (a demuxer or a file)\n\twe only accept dst type FILE for the first call (ie reg desc is the loaded destination), and forbid muxers in the middle of the chain\n\tfor dynamic resolution. This avoids situations such as StreamTypeA->mux->demux->streamtypeB which cannot be resolved\n\n\tnote that it is still possible to use a mux or demux in the chain, but they have to be explicitly loaded\n\t*/\n\tif ((rlevel>1) && (dst_stream_type==GF_STREAM_FILE))\n\t\treturn 0;\n\n\treg_desc->in_edges_enabling = 1;\n\n\tfor (i=0; i<reg_desc->nb_edges; i++) {\n\t\tu32 res;\n\t\ts32 source_stream_type;\n\t\tGF_FilterRegEdge *edge = &reg_desc->edges[i];\n\t\t//this edge is not for our target source cap bundle\n\t\tif (edge->dst_cap_idx != src_cap_idx) continue;\n\n\t\t//edge is already disabled (the subgraph doesn't match our source), don't test it\n\t\tif (edge->status == EDGE_STATUS_DISABLED)\n\t\t\tcontinue;\n\n\t\t//if source is not edge origin and edge is only valid for explicitly loaded filters, disable edge\n\t\tif (edge->loaded_filter_only && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tedge->disabled_depth = rlevel+1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//edge is already enabled (the subgraph matches our source), don't test it but remember to indicate the graph is valid\n\t\tif (edge->status == EDGE_STATUS_ENABLED) {\n\t\t\tenable_graph = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//candidate edge, check stream type\n\t\tsource_stream_type = edge->src_stream_type;\n\n\t\tif (pid->filter->freg == edge->src_reg->freg)\n\t\t\tsource_stream_type = pid_stream_type;\n\n\t\t//source edge cap indicates multiple stream types (demuxer/encoder/decoder dundle)\n\t\tif (source_stream_type<0) {\n\t\t\t//if destination type is known (>=0 and NOT file, inherit it\n\t\t\t//otherwise, we we can't filter out yet\n\t\t\tif ((dst_stream_type>0) && (dst_stream_type != GF_STREAM_FILE))\n\t\t\t\tsource_stream_type = dst_stream_type;\n\t\t}\n\t\t//inherit source type if not specified\n\t\tif (!source_stream_type && dst_stream_type>0)\n\t\t\tsource_stream_type = dst_stream_type;\n\t\t//if source is encrypted type and dest type is set, use dest type\n\t\tif ((source_stream_type==GF_STREAM_ENCRYPTED) && (dst_stream_type>0) && (dst_stream_type!=GF_STREAM_FILE))\n\t\t\tsource_stream_type = dst_stream_type;\n\t\t//if dest is encrypted type and source type is set, use source type\n\t\tif ((dst_stream_type==GF_STREAM_ENCRYPTED) && source_stream_type>0)\n\t\t\tdst_stream_type = source_stream_type;\n\n\t\t//if stream types are know (>0) and not source files, do not mark the edges if they mismatch\n\t\t//moving from non-file type A to non-file type B requires an explicit filter\n\t\tif ((dst_stream_type>0) && (source_stream_type>0) && (source_stream_type != GF_STREAM_FILE) && (dst_stream_type != GF_STREAM_FILE) && (source_stream_type != dst_stream_type)) {\n\n\t\t\t//exception: we allow text|scene|od ->video for dynamic compositor\n\t\t\tif (!(reg_desc->freg->flags & GF_FS_REG_EXPLICIT_ONLY) && (dst_stream_type==GF_STREAM_VISUAL)\n\t\t\t\t&& ((source_stream_type==GF_STREAM_TEXT) || (source_stream_type==GF_STREAM_SCENE) || (source_stream_type==GF_STREAM_OD) )\n\t\t\t) {\n\n\t\t\t} else {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tedge->disabled_depth = rlevel+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tres = gf_filter_pid_enable_edges(fsess, edge->src_reg, edge->src_cap_idx, src_freg, rlevel+1, source_stream_type, reg_desc, pid, pid_stream_type);\n\t\t//if subgraph matches our source reg, mark the edge towards this subgraph as enabled\n\t\tif (res==1) {\n\t\t\tedge->status = EDGE_STATUS_ENABLED;\n\t\t\tenable_graph = GF_TRUE;\n\t\t}\n\t\t//if sub-graph below is too deep, don't mark the edge since we might need to resolve it again with a shorter subgraph\n\t\telse if (res==2) {\n\t\t\taborted_graph_too_deep = GF_TRUE;\n\t\t}\n\t\t//otherwise the subgraph doesn't match our source reg, mark as disaled and never test again\n\t\telse if (res==0) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tedge->disabled_depth = rlevel+1;\n\t\t}\n\t}\n\treg_desc->in_edges_enabling = 0;\n\t//we had enabled edges, the subgraph is valid\n\tif (enable_graph) return 1;\n\t//we aborted because too deep, indicate it to the caller so that the edge is not disabled\n\tif (aborted_graph_too_deep) return 2;\n\t//disable subgraph\n\treturn 0;\n}\n\nstatic void gf_filter_reg_build_graph_single(GF_FilterRegDesc *reg_desc, const GF_FilterRegister *freg, GF_FilterRegDesc *a_reg, Bool freg_has_output, u32 nb_dst_caps, GF_CapsBundleStore *capstore, GF_Filter *dst_filter)\n{\n\tu32 nb_src_caps, k, l;\n\tu32 path_weight;\n\n\t//check which cap of this filter matches our destination\n\tnb_src_caps = gf_filter_caps_bundle_count(a_reg->freg->caps, a_reg->freg->nb_caps);\n\tfor (k=0; k<nb_src_caps; k++) {\n\t\tfor (l=0; l<nb_dst_caps; l++) {\n\t\t\ts32 bundle_idx;\n\n\t\t\tif (gf_filter_has_out_caps(a_reg->freg->caps, a_reg->freg->nb_caps)) {\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\n\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(a_reg->freg, k, (const GF_FilterRegister *) freg, dst_filter, &bundle_idx, l, &loaded_filter_only_flags, capstore);\n\n\t\t\t\tif (path_weight && (bundle_idx == l)) {\n\t\t\t\t\tGF_FilterRegEdge *edge;\n\t\t\t\t\tif (reg_desc->nb_edges==reg_desc->nb_alloc_edges) {\n\t\t\t\t\t\treg_desc->nb_alloc_edges += 10;\n\t\t\t\t\t\treg_desc->edges = gf_realloc(reg_desc->edges, sizeof(GF_FilterRegEdge) * reg_desc->nb_alloc_edges);\n\t\t\t\t\t}\n\t\t\t\t\tassert(path_weight<0xFF);\n\t\t\t\t\tassert(k<0xFFFF);\n\t\t\t\t\tassert(l<0xFFFF);\n\t\t\t\t\tedge = &reg_desc->edges[reg_desc->nb_edges];\n\t\t\t\t\tmemset(edge, 0, sizeof(GF_FilterRegEdge));\n\t\t\t\t\tedge->src_reg = a_reg;\n\t\t\t\t\tedge->weight = (u8) path_weight;\n\t\t\t\t\tedge->src_cap_idx = (u16) k;\n\t\t\t\t\tedge->dst_cap_idx = (u16) l;\n\n\t\t\t\t\t//we inverted the caps, invert the flags\n\t\t\t\t\tif (loaded_filter_only_flags & EDGE_LOADED_SOURCE_ONLY)\n\t\t\t\t\t\tedge->loaded_filter_only |= EDGE_LOADED_DEST_ONLY;\n\t\t\t\t\tif (loaded_filter_only_flags & EDGE_LOADED_DEST_ONLY)\n\t\t\t\t\t\tedge->loaded_filter_only |= EDGE_LOADED_SOURCE_ONLY;\n\t\t\t\t\tedge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);\n\t\t\t\t\treg_desc->nb_edges++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( freg_has_output ) {\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\n\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(freg, l, a_reg->freg, dst_filter, &bundle_idx, k, &loaded_filter_only_flags, capstore);\n\n\t\t\t\tif (path_weight && (bundle_idx == k)) {\n\t\t\t\t\tGF_FilterRegEdge *edge;\n\t\t\t\t\tif (a_reg->nb_edges==a_reg->nb_alloc_edges) {\n\t\t\t\t\t\ta_reg->nb_alloc_edges += 10;\n\t\t\t\t\t\ta_reg->edges = gf_realloc(a_reg->edges, sizeof(GF_FilterRegEdge) * a_reg->nb_alloc_edges);\n\t\t\t\t\t}\n\t\t\t\t\tedge = &a_reg->edges[a_reg->nb_edges];\n\t\t\t\t\tedge->src_reg = reg_desc;\n\t\t\t\t\tedge->weight = (u8) path_weight;\n\t\t\t\t\tedge->src_cap_idx = (u16) l;\n\t\t\t\t\tedge->dst_cap_idx = (u16) k;\n\t\t\t\t\tedge->priority = 0;\n\t\t\t\t\tedge->loaded_filter_only = loaded_filter_only_flags;\n\t\t\t\t\tedge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);\n\t\t\t\t\ta_reg->nb_edges++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GF_FilterRegDesc *gf_filter_reg_build_graph(GF_List *links, const GF_FilterRegister *freg, GF_CapsBundleStore *capstore, GF_FilterPid *src_pid, GF_Filter *dst_filter)\n{\n\tu32 nb_dst_caps, nb_regs, i, nb_caps;\n\tBool freg_has_output;\n\n\tGF_FilterRegDesc *reg_desc = NULL;\n\tconst GF_FilterCapability *caps = freg->caps;\n\tnb_caps = freg->nb_caps;\n\tif (dst_filter && ((freg->flags & (GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM)) || (src_pid && dst_filter->forced_caps) ) ) {\n\t\tcaps = dst_filter->forced_caps;\n\t\tnb_caps = dst_filter->nb_forced_caps;\n\t}\n\n\tfreg_has_output = gf_filter_has_out_caps(caps, nb_caps);\n\n\tGF_SAFEALLOC(reg_desc, GF_FilterRegDesc);\n\tif (!reg_desc) return NULL;\n\n\treg_desc->freg = freg;\n\n\tnb_dst_caps = gf_filter_caps_bundle_count(caps, nb_caps);\n\n\n\t//we are building a register descriptor acting as destination, ignore any output caps\n\tif (src_pid || dst_filter) freg_has_output = GF_FALSE;\n\n\t//setup all connections\n\tnb_regs = gf_list_count(links);\n\tfor (i=0; i<nb_regs; i++) {\n\t\tGF_FilterRegDesc *a_reg = gf_list_get(links, i);\n\t\tif (a_reg->freg == freg) continue;\n\n\t\tgf_filter_reg_build_graph_single(reg_desc, freg, a_reg, freg_has_output, nb_dst_caps, capstore, dst_filter);\n\t}\n\n\tif (!dst_filter && (freg->flags & GF_FS_REG_ALLOW_CYCLIC)) {\n\t\tgf_filter_reg_build_graph_single(reg_desc, freg, reg_desc, freg_has_output, nb_dst_caps, capstore, NULL);\n\t}\n\treturn reg_desc;\n}\n\nvoid gf_filter_sess_build_graph(GF_FilterSession *fsess, const GF_FilterRegister *for_reg)\n{\n\tu32 i, count;\n\tGF_CapsBundleStore capstore;\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\n\tif (!fsess->links) fsess->links = gf_list_new();\n\n\tif (for_reg) {\n\t\tGF_FilterRegDesc *freg_desc = gf_filter_reg_build_graph(fsess->links, for_reg, &capstore, NULL, NULL);\n\t\tif (!freg_desc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to build graph entry for filter %s\\n\", for_reg->name));\n\t\t} else {\n\t\t\tgf_list_add(fsess->links, freg_desc);\n\t\t}\n\t} else {\n#ifndef GPAC_DISABLE_LOG\n\t\tu64 start_time = gf_sys_clock_high_res();\n#endif\n\t\tcount = gf_list_count(fsess->registry);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst GF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\t\tGF_FilterRegDesc *freg_desc = gf_filter_reg_build_graph(fsess->links, freg, &capstore, NULL, NULL);\n\t\t\tif (!freg_desc) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to build graph entry for filter %s\\n\", freg->name));\n\t\t\t} else {\n\t\t\t\tgf_list_add(fsess->links, freg_desc);\n\t\t\t}\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Built filter graph in \"LLU\" us\\n\", gf_sys_clock_high_res() - start_time));\n\n\t\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\tu32 j;\n\t\t\tcount = gf_list_count(fsess->links);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterRegDesc *freg_desc = gf_list_get(fsess->links, i);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources:\", freg_desc->freg->name));\n\t\t\t\tfor (j=0; j<freg_desc->nb_edges; j++ ) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d,%d->%d)\", freg_desc->edges[j].src_reg->freg->name, freg_desc->edges[j].weight, freg_desc->edges[j].src_cap_idx, freg_desc->edges[j].dst_cap_idx));\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t\t\t}\n\t\t}\n\t}\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n}\n\nvoid gf_filter_sess_reset_graph(GF_FilterSession *fsess, const GF_FilterRegister *freg)\n{\n\tgf_mx_p(fsess->links_mx);\n\t//explicit registry removal and not destroying the session\n\tif (freg && fsess->filters) {\n\t\ts32 reg_idx=-1;\n\t\tu32 i, count = gf_list_count(fsess->links);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j;\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(fsess->links, i);\n\t\t\tif (rdesc->freg == freg) {\n\t\t\t\treg_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\t\tif (rdesc->edges[j].src_reg->freg == freg) {\n\t\t\t\t\tif (rdesc->nb_edges > j + 1) {\n\t\t\t\t\t\tmemmove(&rdesc->edges[j], &rdesc->edges[j+1], sizeof (GF_FilterRegEdge) * (rdesc->nb_edges - j - 1));\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t\trdesc->nb_edges--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (reg_idx>=0) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(fsess->links, reg_idx);\n\t\t\tgf_list_rem(fsess->links, reg_idx);\n\t\t\tgf_free(rdesc->edges);\n\t\t\tgf_free(rdesc);\n\t\t}\n\t} else {\n\t\twhile (gf_list_count(fsess->links)) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_pop_back(fsess->links);\n\t\t\tgf_free(rdesc->edges);\n\t\t\tgf_free(rdesc);\n\t\t}\n\t}\n\tgf_mx_v(fsess->links_mx);\n}\n\n#ifndef GPAC_DISABLE_LOG\nvoid dump_dijstra_edges(Bool is_before, GF_FilterRegDesc *reg_dst, GF_List *dijkstra_nodes)\n{\n\tu32 i, count;\n\tif (! gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG))\n\t\treturn;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Dijstra edges %s edge solving\\n\", is_before ? \"before\" : \"after\"));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources: \", reg_dst->freg->name));\n\tfor (i=0; i<reg_dst->nb_edges; i++) {\n\t\tGF_FilterRegEdge *edge = &reg_dst->edges[i];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d(%d),%d,%d->%d)\", edge->src_reg->freg->name, edge->status, edge->disabled_depth, edge->weight, edge->src_cap_idx, edge->dst_cap_idx));\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\n\tcount = gf_list_count(dijkstra_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s sources: \", rdesc->freg->name));\n\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &rdesc->edges[j];\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d(%d),%d,%d->%d)\", edge->src_reg->freg->name, edge->status, edge->disabled_depth, edge->weight, edge->src_cap_idx, edge->dst_cap_idx));\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t}\n}\n#endif\n\nstatic void gf_filter_pid_resolve_link_dijkstra(GF_FilterPid *pid, GF_Filter *dst, const char *prefRegister, Bool reconfigurable_only, GF_List *out_reg_chain)\n{\n\tGF_FilterRegDesc *reg_dst, *result;\n\tGF_List *dijkstra_nodes;\n\tGF_FilterSession *fsess = pid->filter->session;\n\t//build all edges\n\tu32 i, dijsktra_node_count, dijsktra_edge_count, count;\n\tGF_CapsBundleStore capstore;\n\tBool first;\n\tBool check_codec_id_raw = GF_FALSE;\n\tu32 path_weight, pid_stream_type, max_weight=0;\n\tu64 dijkstra_time_us, sort_time_us, start_time_us = gf_sys_clock_high_res();\n\tconst GF_PropertyValue *p;\n\tif (!fsess->links || ! gf_list_count( fsess->links))\n\t \tgf_filter_sess_build_graph(fsess, NULL);\n\n\tdijkstra_nodes = gf_list_new();\n\n\tresult = NULL;\n\tpid_stream_type = 0;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) pid_stream_type = p->value.uint;\n\n\t//decoders usually do not expose reconfigure_output interface\n\t//if this is a reconfig asking for codecID=raw, check each registry for non-raw->raw conversion\n\t//and if present consider this filter suitable\n\t//note that encoders must use reconfigure output\n\tif (reconfigurable_only\n\t\t&& pid->caps_negociate\n\t\t&& (gf_list_count(pid->caps_negociate->properties)==1)\n\t) {\n\t\tconst GF_PropertyValue *cid = gf_props_get_property(pid->caps_negociate, GF_PROP_PID_CODECID, NULL);\n\t\t//for now we only check decoders, encoders must use reconfigure output\n\t\tif (cid && (cid->value.uint==GF_CODECID_RAW)) {\n\t\t\tcheck_codec_id_raw = cid->value.uint;\n\t\t}\n\t}\n\n\t//1: select all elligible filters for the graph resolution: exclude sources, sinks, explicits, blacklisted and not reconfigurable if we reconfigure\n\tcount = gf_list_count(fsess->links);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tBool disable_filter = GF_FALSE;\n\t\tBool reconf_only = reconfigurable_only;\n\t\tGF_FilterRegDesc *reg_desc = gf_list_get(fsess->links, i);\n\t\tconst GF_FilterRegister *freg = reg_desc->freg;\n\n\t\tif (check_codec_id_raw) {\n\t\t\tBool has_raw_out=GF_FALSE, has_non_raw_in=GF_FALSE;\n\t\t\tfor (j=0; j<freg->nb_caps; j++) {\n\t\t\t\tif (!(freg->caps[j].flags & GF_CAPFLAG_IN_BUNDLE))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (freg->caps[j].code!=GF_PROP_PID_CODECID) continue;\n\n\t\t\t\tif (freg->caps[j].val.value.uint == GF_CODECID_RAW) {\n\t\t\t\t\tif ((freg->caps[j].flags & GF_CAPFLAG_OUTPUT) && ! (freg->caps[j].flags & GF_CAPFLAG_EXCLUDED))\n\t\t\t\t\t\thas_raw_out = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((freg->caps[j].flags & GF_CAPFLAG_INPUT) && ! (freg->caps[j].flags & GF_CAPFLAG_EXCLUDED))\n\t\t\t\t\thas_non_raw_in = GF_TRUE;\n\t\t\t}\n\t\t\tif (has_raw_out && has_non_raw_in)\n\t\t\t\treconf_only = GF_FALSE;\n\t\t}\n\t\t//reset state, except for edges which are reseted after each dijkstra resolution\n\t\treg_desc->destination = NULL;\n\t\treg_desc->cap_idx = 0;\n\t\treg_desc->in_edges_enabling = 0;\n\t\t//set node distance and priority to infinity, whether we are in the final dijsktra set or not\n\t\treg_desc->dist = -1;\n\t\treg_desc->priority = 0xFF;\n\n\t\t//remember our source descriptor - it may be absent of the final node set in case we want reconfigurable only filters\n\t\t//and the source is not reconfigurable\n\t\tif (freg == pid->filter->freg)\n\t\t\tresult = reg_desc;\n\n\t\t//don't add source filters except if PID is from source\n\t\tif (!freg->configure_pid && (freg!=pid->filter->freg)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//freg shall be instantiated\n\t\telse if ((freg->flags & (GF_FS_REG_EXPLICIT_ONLY|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM)) && (freg != pid->filter->freg) && (freg != dst->freg) ) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//no output caps, cannot add\n\t\telse if ((freg != dst->freg) && !gf_filter_has_out_caps(freg->caps, freg->nb_caps)) {\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//we only want reconfigurable output filters\n\t\telse if (reconf_only && !freg->reconfigure_output && (freg != dst->freg)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//blacklisted filter\n\t\telse if (gf_list_find(pid->filter->blacklisted, (void *) freg)>=0) {\n\t\t\t//this commented because not true for multi-pids inputs (tiling) to a decoder\n\t\t\t//assert(freg != dst->freg);\n\t\t\tif (!reconfigurable_only) {\n\t\t\t\tassert(freg != pid->filter->freg);\n\t\t\t}\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\t\t//blacklisted adaptation filter\n\t\telse if (pid->adapters_blacklist && (gf_list_find(pid->adapters_blacklist, (void *) freg)>=0)) {\n\t\t\tassert(freg != dst->freg);\n\t\t\tdisable_filter = GF_TRUE;\n\t\t}\n\n\t\t//reset edge status\n\t\tfor (j=0; j<reg_desc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &reg_desc->edges[j];\n\n\t\t\tedge->disabled_depth = 0;\n\t\t\tif (disable_filter) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tedge->status = EDGE_STATUS_NONE;\n\n\t\t\t//connection from source, disable edge if pid caps mismatch\n\t\t\tif (edge->src_reg->freg == pid->filter->freg) {\n\t\t\t\tu8 priority=0;\n\t\t\t\tu32 dst_bundle_idx;\n\t\t\t\t//check path weight for the given dst cap - we MUST give the target cap otherwise we might get a default match to another cap\n\t\t\t\tpath_weight = gf_filter_pid_caps_match(pid, freg, NULL, &priority, &dst_bundle_idx, pid->filter->dst_filter, edge->dst_cap_idx);\n\t\t\t\tif (!path_weight) {\n\t\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if 0\n\t\t\t\tif (priority)\n\t\t\t\t\tpath_weight *= priority;\n#endif\n\t\t\t}\n\n\t\t\t//if source is not edge origin and edge is only valid for explicitly loaded filters, disable edge\n\t\t\tif ((edge->loaded_filter_only & EDGE_LOADED_SOURCE_ONLY) && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((u32) edge->weight + 1 > max_weight)\n\t\t\t\tmax_weight = (u32) edge->weight + 1;\n\t\t}\n\t\t//not in set\n\t\tif (disable_filter)\n\t\t\tcontinue;\n\n\n\t\t//do not add destination filter\n\t\tif (dst->freg == reg_desc->freg) {\n\t\t\treg_desc->dist = 0;\n\t\t\treg_desc->priority = 0;\n\t\t} else {\n\t\t\tgf_list_add(dijkstra_nodes, reg_desc);\n\t\t}\n\t}\n\t//create a new node for the destination based on elligible filters in the graph\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\treg_dst = gf_filter_reg_build_graph(dijkstra_nodes, dst->freg, &capstore, pid, dst);\n\treg_dst->dist = 0;\n\treg_dst->priority = 0;\n\treg_dst->in_edges_enabling = 0;\n\n\t//enable edges of destination, potentially disabling edges from source filters to dest\n\tfor (i=0; i<reg_dst->nb_edges; i++) {\n\t\tGF_FilterRegEdge *edge = &reg_dst->edges[i];\n\t\tedge->status = EDGE_STATUS_NONE;\n\n\t\t//connection from source, disable edge if pid caps mismatch\n\t\tif (edge->src_reg->freg == pid->filter->freg) {\n\t\t\tu8 priority=0;\n\t\t\tu32 dst_bundle_idx;\n\t\t\tpath_weight = gf_filter_pid_caps_match(pid, dst->freg, dst, &priority, &dst_bundle_idx, pid->filter->dst_filter, -1);\n\t\t\tif (!path_weight) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst_bundle_idx != edge->dst_cap_idx) {\n\t\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//the edge source filter is not loaded, disable edges marked for loaded filter only\n\t\tif ( (edge->loaded_filter_only & EDGE_LOADED_SOURCE_ONLY) && (edge->src_reg->freg != pid->filter->freg) ) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tcontinue;\n\t\t}\n\t\t//we are relinking to a dynamically loaded filter, only accept edges connecting to the same bundle as when\n\t\t//the initial resolution was done, unless the edge is marked as loaded destination filter only in which case\n\t\t//we accept connection\n\t\tif ((dst->bundle_idx_at_resolution>=0)\n\t\t\t//if dest is a mux, don't check bundle idx\n\t\t\t&& !dst->max_extra_pids\n\t\t\t&& !(edge->loaded_filter_only & EDGE_LOADED_DEST_ONLY)\n\t\t\t&& (edge->dst_cap_idx !=dst->bundle_idx_at_resolution)\n\t\t) {\n\t\t\tedge->status = EDGE_STATUS_DISABLED;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((u32) edge->weight + 1 > max_weight)\n\t\t\tmax_weight = edge->weight + 1;\n\t\t//enable edge and propagate down the graph\n\t\tedge->status = EDGE_STATUS_ENABLED;\n\n\t\tgf_filter_pid_enable_edges(fsess, edge->src_reg, edge->src_cap_idx, pid->filter->freg, 1, edge->src_stream_type, reg_dst, pid, pid_stream_type);\n\t}\n\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\tdump_dijstra_edges(GF_FALSE, reg_dst, dijkstra_nodes);\n\t}\n#endif\n\n\t//remove all filters not used for this resolution (no enabled edges), except source one\n\tcount = gf_list_count(dijkstra_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, nb_edges;\n\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\tif (rdesc->freg == pid->filter->freg) continue;\n\n\t\tnb_edges = 0;\n\t\tfor (j=0; j<rdesc->nb_edges; j++) {\n\t\t\tGF_FilterRegEdge *edge = &rdesc->edges[j];\n\t\t\tif (edge->status == EDGE_STATUS_ENABLED) {\n\t\t\t\tnb_edges++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!nb_edges) {\n\t\t\tgf_list_rem(dijkstra_nodes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_LOG\n\tif (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filters in dijkstra set:\"));\n\t\tcount = gf_list_count(dijkstra_nodes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterRegDesc *rdesc = gf_list_get(dijkstra_nodes, i);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s\", rdesc->freg->name));\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\n\"));\n\t}\n#endif\n\n\tsort_time_us = gf_sys_clock_high_res();\n\n\n\tdijsktra_edge_count = 0;\n\tdijsktra_node_count = gf_list_count(dijkstra_nodes)+1;\n\tfirst = GF_TRUE;\n\t//OK we have the weighted graph, perform a dijkstra on the graph - we assign by weight, and if same weight we check the priority\n\twhile (1) {\n\t\tGF_FilterRegDesc *current_node = NULL;\n\t\tu32 reg_idx = -1;\n\t\tu32 min_dist = -1;\n\n\t\tcount = gf_list_count(dijkstra_nodes);\n\t\tif (!count) break;\n\n\t\tif (first) {\n\t\t\tcurrent_node = reg_dst;\n\t\t} else {\n\t\t\t//pick up shortest distance\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterRegDesc *reg_desc = gf_list_get(dijkstra_nodes, i);\n\t\t\t\tif (reg_desc->dist < min_dist) {\n\t\t\t\t\tmin_dist = reg_desc->dist;\n\t\t\t\t\tcurrent_node = reg_desc;\n\t\t\t\t\treg_idx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//remove current\n\t\t\tif (!current_node)\n\t\t\t\tbreak;\n\t\t\tgf_list_rem(dijkstra_nodes, reg_idx);\n\t\t}\n\n\t\tif (current_node->freg == pid->filter->freg) {\n\t\t\tresult = current_node;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: testing filter %s\\n\", current_node->freg->name));\n\n\t\t//compute distances\n\t\tfor (i=0; i<current_node->nb_edges; i++) {\n\t\t\tu8 priority=0;\n\t\t\tGF_FilterRegEdge *redge = &current_node->edges[i];\n\t\t\tu32 dist;\n\t\t\tBool do_switch = GF_FALSE;\n\t\t\tdijsktra_edge_count++;\n\n\t\t\tif (redge->status != EDGE_STATUS_ENABLED)\n\t\t\t\tcontinue;\n\n\t\t\tdist = current_node->dist + 1;//(max_weight - redge->weight);\n\t\t\tif (current_node->freg->flags & GF_FS_REG_HIDE_WEIGHT) {\n\t\t\t\tdist = current_node->dist;\n\t\t\t}\n\n\t\t\tpriority = redge->priority;\n\t\t\tif (redge->src_reg->freg == pid->filter->freg) {\n\t\t\t\ts32 dst_bundle_idx;\n\t\t\t\tif (gf_filter_pid_caps_match(pid, current_node->freg, NULL, &priority, &dst_bundle_idx, dst, redge->dst_cap_idx)) {\n\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist < redge->src_reg->dist) do_switch = GF_TRUE;\n\t\t\telse if (dist == redge->src_reg->dist) {\n\t\t\t\tif (prefRegister[0] && (redge->src_reg->destination != current_node) && strstr(prefRegister, current_node->freg->name)) {\n\t\t\t\t\tdo_switch = GF_TRUE;\n\t\t\t\t\tpriority = 0;\n\t\t\t\t} else if ( (dist == redge->src_reg->dist) && (priority < redge->src_reg->priority) )\n\t\t\t\t\tdo_switch = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (do_switch) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: assign filter %s distance %d destination to %s in cap %d out cap %d priority %d (previous destination %s distance %d priority %d)\\n\", redge->src_reg->freg->name, dist, current_node->freg->name, redge->src_cap_idx, redge->dst_cap_idx, redge->priority, redge->src_reg->destination ? redge->src_reg->destination->freg->name : \"none\", redge->src_reg->dist, redge->src_reg->priority ));\n\t\t\t\tredge->src_reg->dist = dist;\n\t\t\t\tredge->src_reg->priority = priority;\n\t\t\t\tredge->src_reg->destination = current_node;\n\t\t\t\tredge->src_reg->cap_idx = redge->src_cap_idx;\n\t\t\t} else if (fsess->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: no shorter path from filter %s distance %d from destination %s priority %d (tested %s dist %d priority %d)\\n\", redge->src_reg->freg->name, redge->src_reg->dist, redge->src_reg->destination ? redge->src_reg->destination->freg->name : \"none\", redge->priority, current_node->freg->name, dist, redge->src_reg->priority));\n\t\t\t}\n\t\t}\n\t\tfirst = GF_FALSE;\n\t}\n\n\tsort_time_us -= start_time_us;\n\tdijkstra_time_us = gf_sys_clock_high_res() - start_time_us;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra: sorted filters in \"LLU\" us, Dijkstra done in \"LLU\" us on %d nodes %d edges\\n\", sort_time_us, dijkstra_time_us, dijsktra_node_count, dijsktra_edge_count));\n\n\tif (result && result->destination) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"[Filters] Dijkstra result: %s(%d)\", result->freg->name, result->cap_idx));\n\t\tresult = result->destination;\n\t\twhile (result->destination) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s(%d)\", result->freg->name, result->cap_idx ));\n\t\t\tgf_list_add(out_reg_chain, (void *) result->freg);\n\t\t\tgf_list_add(out_reg_chain, (void *) &result->freg->caps[result->cap_idx]);\n\t\t\tresult = result->destination;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\" %s\\n\", result->freg->name));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"[Filters] Dijkstra: no results found!\\n\"));\n\t}\n\tgf_list_del(dijkstra_nodes);\n\n\tgf_free(reg_dst->edges);\n\tgf_free(reg_dst);\n}\n\n\n/*\n\t!Resolves a link between a PID and a destination filter\n\n\\param pid source pid to connect\n\\param dst destination filter to connect source PID to\n\\param filter_reassigned indicates the filter has been destroyed and reassigned\n\\param reconfigurable_only indicates the chain should be loaded for reconfigurable filters\n\\return the first filter in the matching chain, or NULL if no match\n*/\nstatic GF_Filter *gf_filter_pid_resolve_link_internal(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned, u32 reconfigurable_only_type, u32 *min_chain_len, GF_List *skip_if_in_filter_list, Bool *skipped)\n{\n\tGF_Filter *chain_input = NULL;\n\tGF_FilterSession *fsess = pid->filter->session;\n\tGF_List *filter_chain;\n\tu32 i, count;\n\tchar *gfloc = NULL;\n\tchar gfloc_c=0;\n\tchar prefRegister[1001];\n\tchar szForceReg[20];\n\tBool reconfigurable_only;\n\n\tif (!fsess->max_resolve_chain_len) return NULL;\n\n\tfilter_chain = gf_list_new();\n\n\tif (!dst) return NULL;\n\n\treconfigurable_only = (reconfigurable_only_type==2) ? GF_TRUE : GF_FALSE;\n\n\tsprintf(szForceReg, \"gfreg%c\", pid->filter->session->sep_name);\n\tprefRegister[0]=0;\n\t//look for reg given in\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->dst_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->dst_args);\n\n\tgf_mx_p(fsess->links_mx);\n\tgf_filter_pid_resolve_link_dijkstra(pid, dst, prefRegister, reconfigurable_only, filter_chain);\n\tgf_mx_v(fsess->links_mx);\n\n\tcount = gf_list_count(filter_chain);\n\tif (min_chain_len) {\n\t\t*min_chain_len = count;\n\t} else if (count==0) {\n\t\tBool can_reassign = GF_TRUE;\n\n\t\t//reassign only for source filters\n\t\tif (pid->filter->num_input_pids) can_reassign = GF_FALSE;\n\t\t//sticky filters cannot be unloaded\n\t\telse if (pid->filter->sticky) can_reassign = GF_FALSE;\n\t\t//if we don't have pending PIDs to setup from the source\n\t\telse if (pid->filter->out_pid_connection_pending) can_reassign = GF_FALSE;\n\t\t//if we don't have pending PIDs to setup from the source\n\t\telse if (pid->filter->num_output_pids) {\n\t\t\tu32 k;\n\t\t\tfor (k=0; k<pid->filter->num_output_pids; k++) {\n\t\t\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, k);\n\t\t\t\tif (apid->num_destinations) can_reassign = GF_FALSE;\n\t\t\t\telse if ((apid==pid) && (apid->init_task_pending>1)) can_reassign = GF_FALSE;\n\t\t\t\telse if ((apid!=pid) && apid->init_task_pending) can_reassign = GF_FALSE;\n\t\t\t\tif (!can_reassign)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if source filter, try to load another filter - we should complete this with a cache of filter sources\n\t\tif (filter_reassigned && can_reassign) {\n\t\t\tif (! *filter_reassigned) {\n\t\t\t\tif (! gf_filter_swap_source_register(pid->filter) ) {\n\t\t\t\t\t//no filter found for this pid !\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No suitable filter chain found\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Swap source demux to %s\\n\", pid->filter->freg->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\t*filter_reassigned = GF_TRUE;\n\t\t} else if (!reconfigurable_only) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No suitable filter found for pid %s from filter %s\\n\", pid->name, pid->filter->name));\n\t\t\tif (filter_reassigned)\n\t\t\t\t*filter_reassigned = GF_FALSE;\n\t\t}\n\t} else if (reconfigurable_only && (count>2)) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Cannot find filter chain with only one filter handling reconfigurable output for pid %s from filter %s - not supported\\n\", pid->name, pid->filter->name));\n\t} else {\n\t\tBool dst_is_sink = gf_filter_is_sink(dst);\n\t\tconst char *dst_args = NULL;\n\t\tconst char *args = pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args;\n\t\tGF_FilterPid *a_pid = pid;\n\t\tGF_Filter *prev_af;\n\n\t\tif (skip_if_in_filter_list) {\n\t\t\tassert(skipped);\n\t\t\t*skipped = GF_FALSE;\n\t\t\tu32 nb_skip = gf_list_count(skip_if_in_filter_list);\n\t\t\tconst GF_FilterRegister *chain_start_freg = gf_list_get(filter_chain, 0);\n\t\t\tfor (i=0; i<nb_skip; i++) {\n\t\t\t\tGF_Filter *f = gf_list_get(skip_if_in_filter_list, i);\n\t\t\t\tu32 j;\n\t\t\t\tGF_Filter *dest_f = NULL;\n\t\t\t\tBool true_skip = GF_FALSE;\n\n\t\t\t\tfor (j=0; j<gf_list_count(dst->destination_filters); j++) {\n\t\t\t\t\tdest_f = gf_list_get(dst->destination_filters, j);\n\t\t\t\t\tif ((gf_list_find(f->destination_filters, dest_f)>=0) || (gf_list_find(f->destination_links, dest_f)>=0)) {\n\t\t\t\t\t\ttrue_skip = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdest_f = NULL;\n\t\t\t\t}\n\n\t\t\t\tfor (j=0; j<gf_list_count(dst->destination_links) && !true_skip; j++) {\n\t\t\t\t\tdest_f = gf_list_get(dst->destination_links, j);\n\t\t\t\t\tif ((gf_list_find(f->destination_filters, dest_f)>=0) || (gf_list_find(f->destination_links, dest_f)>=0)) {\n\t\t\t\t\t\ttrue_skip = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdest_f = NULL;\n\t\t\t\t}\n\t\t\t\tif (true_skip) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Skip link from %s:%s to %s because both filters share the same destination %s\\n\", pid->filter->name, pid->name, dst->name, dest_f->name));\n\t\t\t\t\t*skipped = GF_TRUE;\n\t\t\t\t\tgf_list_del(filter_chain);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (f->freg == chain_start_freg) {\n\t\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\t\tif (gf_list_find(f->destination_links, dst)<0)\n\t\t\t\t\t\tgf_list_add(f->destination_links, dst);\n\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Skip link from %s:%s to %s because already connected to filter %s which can handle the connection\\n\", pid->filter->name, pid->name, dst->name, f->name));\n\n\t\t\t\t\t*skipped = GF_TRUE;\n\t\t\t\t\tgf_list_del(filter_chain);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdst_args = dst->src_args ? dst->src_args : dst->orig_args;\n\n\t\twhile (a_pid) {\n\t\t\tGF_FilterPidInst *pidi;\n\t\t\targs = a_pid->filter->src_args;\n\t\t\tif (!args) args = a_pid->filter->orig_args;\n\t\t\tif (args) break;\n\t\t\tgf_mx_p(a_pid->filter->tasks_mx);\n\t\t\tpidi = gf_list_get(a_pid->filter->input_pids, 0);\n\t\t\tgf_mx_v(a_pid->filter->tasks_mx);\n\t\t\tif (!pidi) break;\n\t\t\ta_pid = pidi->pid;\n\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_INFO)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Solved %sfilter chain from filter %s PID %s to filter %s - dumping chain:\\n\", reconfigurable_only_type ? \"adaptation \" : \"\", pid->filter->name, pid->name, dst->freg->name));\n\t\t}\n#endif\n\t\tchar szLocSep[8];\n\t\tsprintf(szLocSep, \"gfloc%c\", fsess->sep_args);\n\t\tgfloc = strstr(args, \"gfloc\");\n\t\tif (gfloc) {\n\t\t\tif ((gfloc>args) && (gfloc[-1]==fsess->sep_args))\n\t\t\t\tgfloc --;\n\n\t\t\tgfloc_c = gfloc[0];\n\t\t\tgfloc[0] = 0;\n\t\t}\n\t\tprev_af = NULL;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Filter *af;\n\t\t\tBool load_first_only = GF_FALSE;\n\t\t\ts32 cap_idx = -1;\n\t\t\tconst GF_FilterRegister *freg;\n\t\t\tconst GF_FilterCapability *cap = NULL;\n\t\t\tu32 k, cur_bundle, bundle_idx=0;\n\t\t\tif (i%2) continue;\n\t\t\tfreg = gf_list_get(filter_chain, i);\n\t\t\tcap = gf_list_get(filter_chain, i + 1);\n\t\t\t//get the cap bundle index - the cap added to the list is the cap with the same index as the bundle start we want\n\t\t\t//(this avoids allocating integers to store the bundle)\n\t\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\t\tif (&freg->caps[k]==cap) {\n\t\t\t\t\tbundle_idx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_bundle = 0;\n\t\t\tfor (k=0; k<freg->nb_caps; k++) {\n\t\t\t\tcap = &freg->caps[k];\n\t\t\t\tif (cur_bundle==bundle_idx) {\n\t\t\t\t\tcap_idx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t\t\tcur_bundle++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if first filter has multiple possible outputs, don't bother loading the entire chain since it is likely wrong\n\t\t\t//(eg demuxers, we don't know yet what's in the file)\n\t\t\tif (!i && gf_filter_out_caps_solved_by_connection(freg, bundle_idx)) {\n\t\t\t\tload_first_only = GF_TRUE;\n\t\t\t} else if (i) {\n\t\t\t\tBool break_chain = GF_FALSE;\n\t\t\t\tu32 j, nb_filters = gf_list_count(fsess->filters);\n\t\t\t\tfor (j=0; j<nb_filters; j++) {\n\t\t\t\t\tGF_Filter *afilter = gf_list_get(fsess->filters, j);\n\t\t\t\t\tif (afilter->freg != freg) continue;\n\t\t\t\t\tif (!afilter->dynamic_filter) continue;\n\t\t\t\t\tif (gf_list_find(pid->filter->destination_links, dst)<0) continue;\n\t\t\t\t\tif (!afilter->max_extra_pids) continue;\n\n\t\t\t\t\t//we load the same dynamic filter and it can accept multiple inputs (probably a mux), we might reuse this filter so stop link resolution now\n\t\t\t\t\t//not doing so would load e new mux filter which would accept the input pids but with potentially no possible output connections\n\t\t\t\t\tbreak_chain = GF_TRUE;\n\t\t\t\t\tif (prev_af) {\n\t\t\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\t\t\tif ( gf_list_find(pid->filter->destination_links, afilter)<0)\n\t\t\t\t\t\t\tgf_list_add(pid->filter->destination_links, afilter);\n\n\t\t\t\t\t\t//remember to which filter we are trying to connect for cap resolution\n\t\t\t\t\t\tprev_af->cap_dst_filter = dst;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (break_chain) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"\\t%s\\n\", freg->name));\n\n\t\t\taf = gf_filter_new(fsess, freg, args, dst_args, pid->filter->no_dst_arg_inherit ? GF_FILTER_ARG_INHERIT_SOURCE_ONLY : GF_FILTER_ARG_INHERIT, NULL, NULL, GF_TRUE);\n\t\t\tif (!af) goto exit;\n\t\t\taf->subsession_id = dst->subsession_id;\n\t\t\tif (dst->itag) af->itag = gf_strdup(dst->itag);\n\t\t\t\n\t\t\t//destination is sink, check if af is a mux (output cap type STREAM=FILE present)\n\t\t\t//if not, copy subsource_id from pid\n\t\t\tBool af_is_mux = GF_FALSE;\n\t\t\tif (dst_is_sink) {\n\t\t\t\tfor (u32 cidx=0; cidx<freg->nb_caps; cidx++) {\n\t\t\t\t\tconst GF_FilterCapability *a_cap = &freg->caps[cidx];\n\t\t\t\t\tif (!(a_cap->flags & GF_CAPFLAG_IN_BUNDLE)) continue;\n\t\t\t\t\tif (!(a_cap->flags & GF_CAPFLAG_OUTPUT)) continue;\n\t\t\t\t\tif (a_cap->flags & GF_CAPFLAG_EXCLUDED) continue;\n\t\t\t\t\tif (a_cap->code!=GF_PROP_PID_STREAM_TYPE) continue;\n\t\t\t\t\tif (a_cap->val.value.uint!=GF_STREAM_FILE) break;\n\t\t\t\t\taf_is_mux = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (af_is_mux)\n\t\t\t\taf->subsource_id = 0;\n\t\t\telse if (pid->filter->subsource_id)\n\t\t\t\taf->subsource_id = pid->filter->subsource_id;\n\t\t\t//if subsource not set, force to 1 (we know this af is not a mux)\n\t\t\telse\n\t\t\t\taf->subsource_id = 1;\n\n\t\t\tif (!af->forced_caps) {\n\t\t\t\t//remember our target cap bundle on that filter\n\t\t\t\taf->bundle_idx_at_resolution = bundle_idx;\n\t\t\t\t//remember our target cap on that filter\n\t\t\t\taf->cap_idx_at_resolution = cap_idx;\n\t\t\t}\n\t\t\tif (pid->require_source_id)\n\t\t\t\taf->require_source_id = GF_TRUE;\n\t\t\t\n\t\t\t//copy source IDs for all filters in the chain\n\t\t\t//we cannot figure out the destination sourceID when initializing PID connection tasks\n\t\t\t//by walking up the filter chain because PIDs connection might be pending\n\t\t\t//(upper chain not yet fully connected)\n\t\t\t//if the source had a restricted source_id set, use it, otherwise use the destination source_id\n\t\t\tif (!prev_af && pid->filter->restricted_source_id)\n\t\t\t\taf->source_ids = gf_strdup(pid->filter->restricted_source_id);\n\t\t\telse if (prev_af && prev_af->source_ids)\n\t\t\t\taf->source_ids = gf_strdup(prev_af->source_ids);\n\t\t\telse if (dst->source_ids)\n\t\t\t\taf->source_ids = gf_strdup(dst->source_ids);\n\n\t\t\t//remember our target filter\n\t\t\tif (prev_af)\n\t\t\t\tgf_list_add(prev_af->destination_filters, af);\n\n\t\t\t//last in chain, add dst\n\t\t\tif (i+2==count) {\n\t\t\t\tgf_list_add(af->destination_filters, dst);\n\t\t\t}\n\t\t\t//we will load several filters in chain, add destination to each of the loaded filter so that we remember what was this filter target\n\t\t\t//this avoids browing the chain of filters->destination_filters when doing link resolution\n\t\t\telse if (!load_first_only) {\n\t\t\t\tgf_list_add(af->destination_filters, dst);\n\t\t\t}\n\n\t\t\t//also remember our original target in case we got the link wrong\n\t\t\taf->target_filter = pid->filter->target_filter;\n\n\t\t\tprev_af = af;\n\n\t\t\tif (reconfigurable_only_type) af->is_pid_adaptation_filter = GF_TRUE;\n\n\t\t\t//remember the first in the chain\n\t\t\tif (!i) chain_input = af;\n\n\t\t\tif (load_first_only) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s needs to be connected to decide its outputs, not loading end of the chain\\n\", freg->name));\n\t\t\t\t//store destination as future destination link for this new filter\n\t\t\t\tif ( gf_list_find(pid->filter->destination_links, dst)<0)\n\t\t\t\t\tgf_list_add(pid->filter->destination_links, dst);\n\n\t\t\t\t//in case we added it, remove the destination filter\n\t\t\t\tgf_list_del_item(af->destination_filters, dst);\n\n\t\t\t\t//remember to which filter we are trying to connect for cap resolution\n\t\t\t\taf->cap_dst_filter = dst;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tif (gfloc) gfloc[0] = gfloc_c;\n\n\tgf_list_del(filter_chain);\n\treturn chain_input;\n}\n\nGF_Filter *gf_filter_pid_resolve_link(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, filter_reassigned, 0, NULL, NULL, NULL);\n}\n\nGF_Filter *gf_filter_pid_resolve_link_check_loaded(GF_FilterPid *pid, GF_Filter *dst, Bool *filter_reassigned, GF_List *skip_if_in_filter_list, Bool *skipped)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, filter_reassigned, 0, NULL, skip_if_in_filter_list, skipped);\n}\n\nGF_Filter *gf_filter_pid_resolve_link_for_caps(GF_FilterPid *pid, GF_Filter *dst, Bool check_reconfig_only)\n{\n\treturn gf_filter_pid_resolve_link_internal(pid, dst, NULL, check_reconfig_only ? 2 : 1, NULL, NULL, NULL);\n}\n\nu32 gf_filter_pid_resolve_link_length(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tu32 chain_len=0;\n\tgf_filter_pid_resolve_link_internal(pid, dst, NULL, 0, &chain_len, NULL, NULL);\n\treturn chain_len;\n}\n\n\nGF_List *gf_filter_pid_compute_link(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tGF_FilterSession *fsess = pid->filter->session;\n\tGF_List *filter_chain;\n\tchar prefRegister[1001];\n\tchar szForceReg[20];\n\n\tif (!fsess->max_resolve_chain_len) return NULL;\n\tif (!dst) return NULL;\n\n\tfilter_chain = gf_list_new();\n\n\ts32 dst_bundle_idx=-1;\n\tif (gf_filter_pid_caps_match(pid, dst->freg, dst, NULL, &dst_bundle_idx, pid->filter->dst_filter, -1)) {\n\t\tgf_list_add(filter_chain, (void*)dst->freg);\n\t\tif ((dst_bundle_idx<0) || ((u32) dst_bundle_idx>=dst->freg->nb_caps))\n\t\t\tdst_bundle_idx=0;\n\n\t\tgf_list_add(filter_chain, (void*)&dst->freg->caps[dst_bundle_idx]);\n\t\treturn filter_chain;\n\t}\n\n\tsprintf(szForceReg, \"gfreg%c\", pid->filter->session->sep_name);\n\tprefRegister[0]=0;\n\t//look for reg given in\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->orig_args ? pid->filter->orig_args : pid->filter->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, pid->filter->dst_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->src_args);\n\tconcat_reg(pid->filter->session, prefRegister, szForceReg, dst->dst_args);\n\n\tgf_mx_p(fsess->links_mx);\n\tgf_filter_pid_resolve_link_dijkstra(pid, dst, prefRegister, GF_FALSE, filter_chain);\n\tgf_mx_v(fsess->links_mx);\n\tif (!gf_list_count(filter_chain)) {\n\t\tgf_list_del(filter_chain);\n\t\treturn NULL;\n\t}\n\tgf_list_add(filter_chain, (void *)dst->freg);\n\tif (dst->freg->nb_caps)\n\t\tgf_list_add(filter_chain, (void*)&dst->freg->caps[0]);\n\treturn filter_chain;\n}\n\n\nstatic void gf_filter_pid_set_args_internal(GF_Filter *filter, GF_FilterPid *pid, char *args, Bool use_default_seps, u32 argfile_level)\n{\n\tchar sep_args, sep_frag, sep_name, sep_list;\n\n\tif (use_default_seps) {\n\t\tsep_args = ':';\n\t\tsep_frag = '#';\n\t\tsep_name = '=';\n\t\tsep_list = ',';\n\t} else {\n\t\tsep_args = filter->session->sep_args;\n\t\tsep_frag = filter->session->sep_frag;\n\t\tsep_name = filter->session->sep_name;\n\t\tsep_list = filter->session->sep_list;\n\t}\n\n\t//parse each arg\n\twhile (args) {\n\t\tu32 p4cc=0;\n\t\tu32 prop_type=GF_PROP_FORBIDEN;\n\t\tBool parse_prop = GF_TRUE;\n\t\tchar *value_next_list = NULL;\n\t\tchar *value_sep = NULL;\n\t\tchar *value, *name, *sep;\n\n\t\t//escaped arg separator, skip everything until next escape sep or end\n\t\tif (args[0] == sep_args) {\n\t\t\tchar szEscape[3];\n\t\t\tszEscape[0] = szEscape[1] = sep_args;\n\t\t\tszEscape[2] = 0;\n\t\t\targs++;\n\t\t\tsep = strstr(args, szEscape);\n\t\t} else {\n\t\t\tif (sep_args == ':') {\n\t\t\t\tsep = (char *)gf_fs_path_escape_colon(filter->session, args);\n\t\t\t} else {\n\t\t\t\tsep = strchr(args, sep_args);\n\t\t\t}\n\t\t}\n\t\tif (sep) {\n\t\t\tchar *xml_start = strchr(args, '<');\n\t\t\tif (xml_start && (xml_start<sep)) {\n\t\t\t\tchar szEnd[3];\n\t\t\t\tszEnd[0] = '>';\n\t\t\t\tszEnd[1] = filter->session->sep_args;\n\t\t\t\tszEnd[2] = 0;\n\t\t\t\tchar *xml_end = strstr(xml_start, szEnd);\n\t\t\t\tif (!xml_end) {\n\t\t\t\t\tsep = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tsep = xml_end+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sep) sep[0]=0;\n\n\t\tif (args[0] != sep_frag) {\n\t\t\t//if arg is not one of our reserved keywords and is a valid file, try to open it\n\t\t\tif (strcmp(args, \"gpac\") && strcmp(args, \"gfopt\") && strcmp(args, \"gfloc\") && gf_file_exists(args)) {\n\t\t\t\tif (argfile_level<5) {\n\t\t\t\t\tchar szLine[2001];\n\t\t\t\t\tFILE *arg_file = gf_fopen(args, \"rt\");\n\t\t\t\t\tszLine[2000]=0;\n\t\t\t\t\twhile (!gf_feof(arg_file)) {\n\t\t\t\t\t\tu32 llen;\n\t\t\t\t\t\tchar *subarg, *res;\n\t\t\t\t\t\tszLine[0] = 0;\n\t\t\t\t\t\tres = gf_fgets(szLine, 2000, arg_file);\n\t\t\t\t\t\tif (!res) break;\n\t\t\t\t\t\tllen = (u32) strlen(szLine);\n\t\t\t\t\t\twhile (llen && strchr(\" \\n\\r\\t\", szLine[llen-1])) {\n\t\t\t\t\t\t\tszLine[llen-1]=0;\n\t\t\t\t\t\t\tllen--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!llen)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tsubarg = szLine;\n\t\t\t\t\t\twhile (subarg[0] && strchr(\" \\n\\r\\t\", subarg[0]))\n\t\t\t\t\t\t\tsubarg++;\n\t\t\t\t\t\tif ((subarg[0] == '/') && (subarg[1] == '/'))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tgf_filter_pid_set_args_internal(filter, pid, subarg, use_default_seps, argfile_level+1);\n\t\t\t\t\t}\n\t\t\t\t\tgf_fclose(arg_file);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter argument file has too many nested levels of sub-files, maximum allowed is 5\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto skip_arg;\n\t\t}\n\n\t\tvalue = NULL;\n\t\tvalue_sep = strchr(args, sep_name);\n\t\tif (value_sep) {\n\t\t\tvalue_sep[0]=0;\n\t\t\tvalue = value_sep+1;\n\t\t}\n\t\tname = args+1;\n\n\t\tif (strlen(name)==4) {\n\t\t\tp4cc = GF_4CC(name[0], name[1], name[2], name[3]);\n\t\t\tif (p4cc) prop_type = gf_props_4cc_get_type(p4cc);\n\t\t}\n\t\tif (prop_type==GF_PROP_FORBIDEN) {\n\t\t\tp4cc = gf_props_get_id(name);\n\t\t\tif (p4cc) prop_type = gf_props_4cc_get_type(p4cc);\n\t\t}\n\n\t\t//look for conditional statements: \"(PROP=VAL)VALUE\"\n\t\twhile (value && (value[0]=='(')) {\n\t\t\tBool pid_excluded, needs_resolve, prop_not_found, prop_matched;\n\t\t\tchar prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];\n\n\t\t\tchar *next_val = NULL;\n\t\t\tchar *closing = strchr(value, ')');\n\t\t\tif (!closing) break;\n\n\t\t\tif (!strncmp(value, \"()\", 2)) {\n\t\t\t\tvalue = closing+1;\n\t\t\t\tparse_prop = GF_TRUE;\n\t\t\t\tvalue_next_list = next_val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparse_prop = GF_FALSE;\n\n\t\t\tnext_val = strchr(closing, sep_list);\n\t\t\tif (next_val) next_val[0] = 0;\n\n\t\t\twhile (closing) {\n\t\t\t\tchar *next_closing;\n\t\t\t\tclosing[0] = 0;\n\t\t\t\tprop_matched = filter_pid_check_fragment(pid, value+1, &pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer);\n\t\t\t\tif (prop_not_found) prop_matched = GF_FALSE;\n\t\t\t\tclosing[0] = ')';\n\n\t\t\t\tif (!prop_matched)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strncmp(closing, \")(\", 2)) break;\n\t\t\t\tnext_closing = strchr(closing+2, ')');\n\t\t\t\tif (!next_closing) break;\n\n\t\t\t\tvalue = closing+1;\n\t\t\t\tclosing = next_closing;\n\t\t\t}\n\n\t\t\tif (prop_matched) {\n\t\t\t\tvalue = closing+1;\n\t\t\t\tparse_prop = GF_TRUE;\n\t\t\t\tvalue_next_list = next_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!next_val) break;\n\t\t\tnext_val[0] = sep_list;\n\t\t\tvalue = next_val+1;\n\t\t}\n\n\t\tif (!parse_prop)\n\t\t\tgoto skip_arg;\n\n\n\t\tif (prop_type != GF_PROP_FORBIDEN) {\n\t\t\tGF_PropertyValue p;\n\t\t\tp.type = GF_PROP_FORBIDEN;\n\n\t\t\t//specific parsing for clli: it's a data prop but we allow textual specifiers\n\t\t\tif ((p4cc == GF_PROP_PID_CONTENT_LIGHT_LEVEL) && strchr(value, sep_list) ){\n\t\t\t\tGF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);\n\t\t\t\tif ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==2))  {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);\n\t\t\t\t\tgf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);\n\t\t\t\t\tp.type = GF_PROP_DATA;\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_props_reset_single(&a_p);\n\t\t\t}\n\t\t\t//specific parsing for mdcv: it's a data prop but we allow textual specifiers\n\t\t\telse if ((p4cc == GF_PROP_PID_MASTER_DISPLAY_COLOUR) && strchr(value, sep_list) ) {\n\t\t\t\tGF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);\n\t\t\t\tif ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==10))  {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[2]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[3]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[4]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[5]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[6]);\n\t\t\t\t\tgf_bs_write_u16(bs, a_p.value.uint_list.vals[7]);\n\t\t\t\t\tgf_bs_write_u32(bs, a_p.value.uint_list.vals[8]);\n\t\t\t\t\tgf_bs_write_u32(bs, a_p.value.uint_list.vals[9]);\n\t\t\t\t\tgf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);\n\t\t\t\t\tp.type = GF_PROP_DATA;\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_props_reset_single(&a_p);\n\t\t\t}\n\t\t\t//parse codecID\n\t\t\telse if (p4cc == GF_PROP_PID_CODECID) {\n\t\t\t\t//only for explicit filters\n\t\t\t\tif (filter->dynamic_filter) goto skip_arg;\n\t\t\t\tu32 cid = gf_codecid_parse(value);\n\t\t\t\tif (cid) {\n\t\t\t\t\tp.type = GF_PROP_UINT;\n\t\t\t\t\tp.value.uint = cid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//parse streamtype\n\t\t\telse if (p4cc == GF_PROP_PID_STREAM_TYPE) {\n\t\t\t\t//only for explicit filters\n\t\t\t\tif (filter->dynamic_filter) goto skip_arg;\n\t\t\t\tu32 st = gf_stream_type_by_name(value);\n\t\t\t\tif (st!=GF_STREAM_UNKNOWN) {\n\t\t\t\t\tp.type = GF_PROP_UINT;\n\t\t\t\t\tp.value.uint = st;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//pix formats and others are parsed as specific prop types\n\n\t\t\tif (p.type == GF_PROP_FORBIDEN) {\n\t\t\t\tp = gf_props_parse_value(prop_type, name, value, NULL, sep_list);\n\t\t\t}\n\n\t\t\tif (p.type != GF_PROP_FORBIDEN) {\n\t\t\t\tif (prop_type==GF_PROP_NAME) {\n\t\t\t\t\tp.type = GF_PROP_STRING;\n\t\t\t\t\tgf_filter_pid_set_property(pid, p4cc, &p);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(pid, p4cc, &p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((p4cc==GF_PROP_PID_TEMPLATE) && p.value.string) {\n\t\t\t\tif (strstr(p.value.string, \"$Bandwidth$\")) {\n\t\t\t\t\tgf_opts_set_key(\"temp\", \"force_indexing\", \"true\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prop_type==GF_PROP_STRING_LIST) {\n\t\t\t\tp.value.string_list.vals = NULL;\n\t\t\t\tp.value.string_list.nb_items = 0;\n\t\t\t}\n\t\t\t//use uint_list as base type for lists\n\t\t\telse if ((prop_type==GF_PROP_UINT_LIST) || (prop_type==GF_PROP_SINT_LIST) || (prop_type==GF_PROP_VEC2I_LIST) || (prop_type==GF_PROP_4CC_LIST)) {\n\t\t\t\tp.value.uint_list.vals = NULL;\n\t\t\t}\n\t\t\tgf_props_reset_single(&p);\n\t\t} else if (value) {\n\t\t\tBool reset_prop=GF_FALSE;\n\t\t\tGF_PropertyValue p;\n\t\t\tif (!strncmp(value, \"bxml@\", 5)) {\n\t\t\t\tp = gf_props_parse_value(GF_PROP_DATA_NO_COPY, name, value, NULL, sep_list);\n\t\t\t} else if (!strncmp(value, \"file@\", 5)) {\n\t\t\t\tp = gf_props_parse_value(GF_PROP_STRING, name, value, NULL, sep_list);\n\t\t\t\tp.type = GF_PROP_STRING_NO_COPY;\n\t\t\t} else {\n\t\t\t\tu32 ptype = GF_PROP_FORBIDEN;\n\t\t\t\tchar *type_sep = strchr(value, '@');\n\t\t\t\tif (type_sep) {\n\t\t\t\t\ttype_sep[0] = 0;\n\t\t\t\t\tptype = gf_props_parse_type(value);\n\t\t\t\t\tif (ptype==GF_PROP_FORBIDEN) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Unrecognized property type %s, defaulting to string\\n\", value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = type_sep+1;\n\t\t\t\t\t}\n\t\t\t\t\ttype_sep[0] = '@';\n\t\t\t\t}\n\t\t\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\t\t\tif (ptype == GF_PROP_FORBIDEN) {\n\t\t\t\t\tp.type = GF_PROP_STRING;\n\t\t\t\t\tp.value.string = value;\n\t\t\t\t} else {\n\t\t\t\t\tp = gf_props_parse_value(ptype, name, value, NULL, sep_list);\n\t\t\t\t\treset_prop = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pid_set_property_dyn(pid, name, &p);\n\t\t\tif (reset_prop) gf_props_reset_single(&p);\n\t\t}\n\t\tif (value_next_list)\n\t\t\tvalue_next_list[0] = sep_list;\n\nskip_arg:\n\t\tif (value_sep)\n\t\t\tvalue_sep[0] = sep_name;\n\n\t\tif (sep) {\n\t\t\tsep[0] = sep_args;\n\t\t\targs=sep+1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_push_properties(GF_FilterPid *pid, char *args, Bool direct_merge, Bool use_default_seps)\n{\n\tif (!args) return GF_OK;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to write property on input PID in filter %s - ignoring\\n\", pid->filter->name ? pid->filter->name : pid->filter->freg->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//pid props specified by user are merged directly\n\tif (direct_merge) {\n\t\tBool req_map_bck = pid->request_property_map;\n\t\tpid->request_property_map = GF_FALSE;\n\t\tgf_filter_pid_set_args_internal(pid->filter, pid, args, use_default_seps, 0);\n\t\tpid->request_property_map = req_map_bck;\n\t} else {\n\t\tgf_filter_pid_set_args_internal(pid->filter, pid, args, use_default_seps, 0);\n\t}\n\treturn GF_OK;\n}\n\nvoid gf_filter_pid_set_args(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tBool req_map_bck;\n\tchar *args;\n\tif (!filter->src_args && !filter->orig_args) return;\n\targs = filter->orig_args ? filter->orig_args : filter->src_args;\n\n\t//pid props specified by user are merged directly\n\treq_map_bck = pid->request_property_map;\n\tpid->request_property_map = GF_FALSE;\n\tgf_filter_pid_set_args_internal(filter, pid, args, GF_FALSE, 0);\n\tpid->request_property_map = req_map_bck;\n}\n\nstatic const char *gf_filter_last_id_in_chain(GF_Filter *filter, Bool ignore_first)\n{\n\tu32 i;\n\tconst char *id;\n\tif (!ignore_first) {\n\t\tif (filter->id) return filter->id;\n\t\tif (!filter->dynamic_filter) return NULL;\n\t}\n\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif (pidi->pid->filter->id) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn pidi->pid->filter->id;\n\t\t}\n\t\t//stop at first non dyn filter\n\t\tif (!pidi->pid->filter->dynamic_filter) continue;\n\t\tid = gf_filter_last_id_in_chain(pidi->pid->filter, GF_FALSE);\n\t\tif (id) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn id;\n\t\t}\n\t\t//single source filter, no need to browse remaining pids\n\t\tif (pidi->pid->filter->single_source)\n\t\t\tbreak;\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn NULL;\n}\n\nvoid gf_filter_pid_retry_caps_negotiate(GF_FilterPid *src_pid, GF_FilterPid *pid, GF_Filter *dst_filter)\n{\n\tassert(dst_filter);\n\tsrc_pid->caps_negociate = pid->caps_negociate;\n\tpid->caps_negociate = NULL;\n\tsrc_pid->caps_dst_filter = dst_filter;\n\t//blacklist filter for adaptation\n\tif (!src_pid->adapters_blacklist) src_pid->adapters_blacklist = gf_list_new();\n\tgf_list_add(src_pid->adapters_blacklist, (void *) pid->filter->freg);\n\t//once != 0 will trigger reconfiguration, so set this once all vars have been set\n\tsafe_int_inc(& src_pid->filter->nb_caps_renegociate );\n\n\t//disconnect source pid from filter - this will unload the filter itself\n\tgf_fs_post_task(src_pid->filter->session, gf_filter_pid_disconnect_task, pid->filter, src_pid, \"pidinst_disconnect\", NULL);\n}\n\n\nstatic Bool gf_filter_pid_needs_explicit_resolution(GF_FilterPid *pid, GF_Filter *dst)\n{\n\tu32 i;\n\tconst GF_FilterCapability *caps;\n\tu32 nb_caps;\n\tBool dst_has_raw_cid_in = GF_FALSE;\n\tconst GF_PropertyValue *stream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (!stream_type) return GF_TRUE;\n\n\tif (stream_type->value.uint==GF_STREAM_FILE) return GF_FALSE;\n\tif (stream_type->value.uint==GF_STREAM_ENCRYPTED) {\n\t\tstream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);\n\t\tif (!stream_type) return GF_TRUE;\n\t}\n\n\tcaps = dst->forced_caps ? dst->forced_caps : dst->freg->caps;\n\tnb_caps = dst->forced_caps ? dst->nb_forced_caps : dst->freg->nb_caps;\n\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\n\t\tif (cap->code != GF_PROP_PID_CODECID) continue;\n\t\tif (cap->val.value.uint==GF_CODECID_RAW)\n\t\t\tdst_has_raw_cid_in = GF_TRUE;\n\t}\n\n\n\tfor (i=0; i<nb_caps; i++) {\n\t\tconst GF_FilterCapability *cap = &caps[i];\n\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\n\t\tif (cap->code != GF_PROP_PID_STREAM_TYPE) continue;\n\t\t//output type is file or same media type, allow looking for filter chains\n\t\tif ((cap->val.value.uint==GF_STREAM_FILE) || (cap->val.value.uint==stream_type->value.uint)) return GF_FALSE;\n\t\t//allow text|scene|video -> raw video for dynamic compositor\n\t\tif (dst_has_raw_cid_in  && (cap->val.value.uint==GF_STREAM_VISUAL)) {\n\t\t\tswitch (stream_type->value.uint) {\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\treturn GF_FALSE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//no mathing type found, we will need an explicit filter to solve this link (ie the link will be to the explicit filter)\n\treturn GF_TRUE;\n}\n\nstatic void add_possible_link_destination(GF_List *possible_linked_resolutions, GF_Filter *filter_dst)\n{\n\tu32 i;\n\n\tfor (i=0; i<gf_list_count(possible_linked_resolutions); i++) {\n\t\tGF_Filter *parent = gf_list_get(possible_linked_resolutions, i);\n\t\tif (parent->max_extra_pids) continue;\n\n\t\tif ((gf_list_find(filter_dst->destination_links, parent)>=0) || (gf_list_find(filter_dst->destination_filters, parent)>=0)) {\n\t\t\tgf_list_rem(possible_linked_resolutions, i);\n\t\t\tgf_list_insert(possible_linked_resolutions, filter_dst, i);\n\t\t\treturn;\n\t\t}\n\t\tif ((gf_list_find(parent->destination_links, filter_dst)>=0) || (gf_list_find(parent->destination_filters, filter_dst)>=0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\tgf_list_add(possible_linked_resolutions, filter_dst);\n}\n\n#if 0\nstatic void dump_pid_props(GF_FilterPid *pid)\n{\n\tu32 idx = 0;\n\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\tconst GF_PropertyEntry *p;\n\tGF_PropertyMap *pmap = gf_list_get(pid->properties, 0);\n\twhile (pmap && (p = gf_list_enum(pmap->properties, &idx))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Pid prop %s: %s\\n\", gf_props_4cc_get_name(p->p4cc), gf_props_dump(p->p4cc, &p->prop, szDump, GF_PROP_DUMP_DATA_NONE) ));\n\t}\n}\n#endif\n\nstatic Bool gf_pid_in_parent_chain(GF_FilterPid *pid, GF_FilterPid *look_for_pid)\n{\n\tu32 i, ret=GF_FALSE;\n\tif (pid == look_for_pid) return GF_TRUE;\n\t//browse all parent PIDs\n\t//stop checking at the first explicit filter with ID\n\tif (!pid->filter->dynamic_filter && pid->filter->id) return GF_FALSE;\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (gf_pid_in_parent_chain(pidi->pid, look_for_pid)) {\n\t\t\tret = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\t//single source filter, no need to look further\n\t\tif (pidi->pid->filter->single_source)\n\t\t\tbreak;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn ret;\n}\n\nstatic Bool filter_match_target_dst(GF_List *flist, GF_Filter *dst)\n{\n\tu32 i, count=gf_list_count(flist);\n\tfor (i=0;i<count;i++) {\n\t\tGF_Filter *f = gf_list_get(flist, i);\n\t\tif (f==dst) return GF_TRUE;\n\t\tif (filter_match_target_dst(f->destination_filters, dst))\n\t\t\treturn GF_TRUE;\n\t\tif (filter_match_target_dst(f->destination_links, dst))\n\t\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic Bool parent_chain_has_dyn_pids(GF_Filter *filter)\n{\n\tu32 i;\n\tif (filter->freg->flags & GF_FS_REG_DYNAMIC_PIDS) return GF_TRUE;\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif (parent_chain_has_dyn_pids(pidi->pid->filter)) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nstatic void gf_filter_pid_init_task(GF_FSTask *task)\n{\n\tu32 f_idx, count;\n\tBool found_dest=GF_FALSE;\n\tBool found_matching_sourceid;\n\tBool can_reassign_filter = GF_FALSE;\n\tBool can_try_link_resolution=GF_FALSE;\n\tBool link_sinks_only = GF_FALSE;\n\tBool implicit_link_found = GF_FALSE;\n\tu32 num_pass=0;\n\tGF_List *loaded_filters = NULL;\n\tGF_List *linked_dest_filters = NULL;\n    GF_List *force_link_resolutions = NULL;\n    GF_List *possible_linked_resolutions = NULL;\n\tGF_Filter *filter = task->filter;\n\tGF_FilterPid *pid = task->pid;\n\tGF_Filter *dynamic_filter_clone = NULL;\n\tBool filter_found_but_pid_excluded = GF_FALSE;\n\tBool possible_link_found_implicit_mode = GF_FALSE;\n\tu32 pid_is_file = 0;\n\tconst char *filter_id;\n\n\tif (pid->destroyed || pid->removed) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\treturn;\n\t}\n\tpid->props_changed_since_connect = GF_FALSE;\n\n\t//swap pid is pending on the possible destination filter\n\tif (filter->swap_pidinst_src || filter->swap_pidinst_dst) {\n\t\ttask->requeue_request = GF_TRUE;\n\t\ttask->can_swap = 1;\n\t\treturn;\n\t}\n\tif (filter->caps_negociate) {\n\t\tif (! gf_filter_reconf_output(filter, pid))\n\t\t\treturn;\n\t}\n\n\tgf_fs_check_graph_load(filter->session, GF_TRUE);\n\n\tif (filter->user_pid_props)\n\t\tgf_filter_pid_set_args(filter, pid);\n\n\t//explicit source, check if demux is forcd\n\tif (!pid->filter->dynamic_filter\n\t\t&& !pid->filter->num_input_pids\n\t\t&& (pid->filter->freg->flags & GF_FS_REG_FORCE_REMUX)\n\t) {\n\t\tconst GF_PropertyValue *st = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (st && (st->value.uint==GF_STREAM_FILE))\n\t\t\tpid_is_file = 1;\n\t}\n\n\t//get filter ID:\n\t//this is a source - since we may have inserted filters in the middle (demuxers typically), get the last explicitly loaded ID in the chain\n\tif (filter->subsource_id) {\n\t\tfilter_id = gf_filter_last_id_in_chain(filter, GF_FALSE);\n\t\tif (!filter_id && filter->cloned_from)\n\t\t\tfilter_id = gf_filter_last_id_in_chain(filter->cloned_from, GF_FALSE);\n\t}\n\t//this is a sink or a mux - only use ID if defined on filter whether explicitly loaded or not ( some filters e.g. dasher,flist will self-assign an ID)\n\telse {\n\t\t//if clone use ID from clone otherwise linking will likely fail\n\t\tfilter_id = filter->cloned_from ? filter->cloned_from->id : filter->id;\n\t}\n\n\t//we lock the instantiated filter list for the entire resolution process\n\t//we must unlock this mutex before calling lock on a filter mutex (->tasks_mx)\n\t//either directly or in functions calling it (e.g. gf_filter_in_parent_chain)\n\t//in case another thread is reconfiguring a filter fA:\n\t//- fA would have tasks_mx locked, and could be waiting for session->filters_mx to insert a new filter (inserting a filter chain)\n\t//- trying to lock fA->tasks_mx would then deadlock\n\t//cf issue 1799\n\tgf_mx_p(filter->session->filters_mx);\n\n\tlinked_dest_filters = gf_list_new();\n\tforce_link_resolutions = gf_list_new();\n    possible_linked_resolutions = gf_list_new();\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s:%s init\\n\", pid->filter->name, pid->name));\n\n\t//we use at max 3 passes:\n\t//pass 1: try direct connections without loading intermediate filter chains. If PID gets connected, skip other passes\n\t//pass 2: try loading intermediate filter chains, but disable filter register swapping. If PID gets connected, skip last\n\t//pass 3: try loading intermediate filter chains, potentially swapping the source register\nrestart:\n\n\tif (num_pass) {\n\n\t\t//we're about to load filters to solve the link, use the already linked destination filters as list of loaded filters.\n\t\t//Not doing so may lead to loading several instances of the same filter for cases like:\n\t\t//-i encrypted aout vout\n\t\t//the first pid init (src->aout/vout) will load a demux, registering aout and vout as destination of demux\n\t\t//the second pid init (demux.Audio -> aout) will load cdcrypt, remove aout from demux destinations\n\t\t//the third pid init (demux.video) will\n\t\t//- match cdcrypt and link to it, but will not remove vout from demux destinations, resulting in further linking (this pass)\n\t\t//- create a new cdcrypt to solve demux.video -> vout\n\t\t\n//\t\tloaded_filters = gf_list_new();\n\t\tloaded_filters = gf_list_clone(linked_dest_filters);\n\t}\n\n\tfound_matching_sourceid = GF_FALSE;\n\n\t//relock the filter list.\n\t//If the filter_dst we were checking is no longer present, rewind and go on\n\t//otherwise update its index (might be less if some filters were removed)\n#define RELOCK_FILTER_LIST\\\n\t\tgf_mx_p(filter->session->filters_mx); \\\n\t\tcount = gf_list_count(filter->session->filters); \\\n\t\tf_dst_idx = gf_list_find(filter->session->filters, filter_dst); \\\n\t\tif (f_dst_idx < 0) {\\\n\t\t\tf_idx--;\\\n\t\t} else {\\\n\t\t\tf_idx = f_dst_idx;\\\n\t\t}\n\n\n\t//try to connect pid to all running filters\n\tcount = gf_list_count(filter->session->filters);\n\tfor (f_idx=0; f_idx<count; f_idx++) {\n\t\ts32 f_dst_idx;\n\t\tBool needs_clone;\n\t\tBool cap_matched, in_parent_chain, is_sink;\n\t\tBool ignore_source_ids;\n\t\tBool use_explicit_link;\n\t\tGF_Filter *filter_dst;\n\nsingle_retry:\n\n\t\tignore_source_ids = GF_FALSE;\n\t\tuse_explicit_link = GF_FALSE;\n\t\tfilter_dst = gf_list_get(filter->session->filters, f_idx);\n\t\t//this can happen in multithreaded cases with filters being removed while we check for links\n\t\tif (!filter_dst)\n\t\t\tbreak;\n\t\t//source filter\n\t\tif (!filter_dst->freg->configure_pid) continue;\n\t\tif (filter_dst->finalized || filter_dst->removed || filter_dst->disabled || filter_dst->marked_for_removal || filter_dst->no_inputs) continue;\n\t\tif (filter_dst->target_filter == pid->filter) continue;\n\n\t\t//handle re-entrant filter registries (eg filter foo of type A output usually cannot connect to filter bar of type A)\n\t\tif (pid->pid->filter->freg == filter_dst->freg) {\n\t\t\t//only allowed for:\n\t\t\tif (\n\t\t\t\t// explicitly loaded filters\n\t\t\t\tfilter->dynamic_filter\n\t\t\t\t//if cyclic explictly allowed by filter registry or if script or custom filter\n\t\t\t\t|| !(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tis_sink = GF_FALSE;\n\t\tif (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) {\n\t\t\tif (filter_dst->dynamic_filter) {\n\t\t\t\tif (!filter_dst->subsource_id) {\n\t\t\t\t\tis_sink = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (filter_dst->forced_caps) {\n\t\t\t\tis_sink = !gf_filter_has_out_caps(filter_dst->forced_caps, filter_dst->nb_forced_caps);\n\t\t\t} else {\n\t\t\t\tis_sink = !gf_filter_has_out_caps(filter_dst->freg->caps, filter_dst->freg->nb_caps);\n\t\t\t}\n\t\t}\n\n\t\t//we linked to a sink in implicit mode and new filter is not a sink, continue\n\t\tif (link_sinks_only && !is_sink) continue;\n\t\t//we linked to a non-sink filter in implicit mode and the destination has no sourceID, continue\n\t\tif (implicit_link_found && !filter_dst->source_ids) {\n\t\t\t//destination not a sink, do not connect\n\t\t\tif (!is_sink) continue;\n\t\t\t//destination is a sink, do not connect if destination is not already registered as target for our filter\n\t\t\t//we need to check this for case such as\n\t\t\t//rtpin(avc) -> avc\n\t\t\t//           -> ts\n\t\t\t//which will invoke the AVC unframer/rewriter (ufnalu) only once and then try to link it to both TS mux and fout\n\t\t\tif ((gf_list_find(filter->destination_filters, filter_dst)<0)\n\t\t\t\t&& (gf_list_find(filter->destination_links, filter_dst)<0)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//check we are not already connected to this filter - we need this in case destination links/filters lists are reset\n\t\tif (pid->num_destinations) {\n\t\t\tu32 j;\n\t\t\tBool already_linked = GF_FALSE;\n\t\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\t\tif (pidi->filter == filter_dst) {\n\t\t\t\t\talready_linked=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (already_linked) continue;\n\t\t}\n\n\t\t//we already linked to this one\n\t\tif (gf_list_find(linked_dest_filters, filter_dst)>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s already linked to filter %s\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\tif (gf_list_count(pid->filter->destination_filters)) {\n\t\t\ts32 ours = gf_list_find(pid->filter->destination_filters, filter_dst);\n\t\t\tif (ours<0) {\n\t\t\t\tours = num_pass ? gf_list_del_item(pid->filter->destination_links, filter_dst) : -1;\n\t\t\t\tif (!filter_dst->source_ids && (ours<0)) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has destination filters, filter %s not one of them\\n\", pid->name, filter_dst->name));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t} else {\n\t\t\t\tfilter_dst->in_link_resolution = 0;\n\t\t\t\tpid->filter->dst_filter = filter_dst;\n\t\t\t\t//for mux->output case, the filter ID may be NULL but we still want to link\n\t\t\t\tif (!num_pass && !filter->subsource_id)\n\t\t\t\t\tignore_source_ids = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (num_pass && gf_list_count(filter->destination_links)) {\n\t\t\ts32 ours = gf_list_find(pid->filter->destination_links, filter_dst);\n\t\t\tif (ours<0) {\n\t\t\t\tours = gf_list_find(possible_linked_resolutions, filter_dst);\n\t\t\t\tif (ours<0) {\n\t\t\t\t\tours = gf_list_find(force_link_resolutions, filter_dst);\n\t\t\t\t}\n\t\t\t\tif (ours<0) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has destination links, filter %s not one of them\\n\", pid->name, filter_dst->name));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpid->filter->dst_filter = NULL;\n\t\t}\n\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\tif (gf_list_count(filter_dst->source_filters)) {\n\t\t\tu32 j, count2 = gf_list_count(filter_dst->source_filters);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tBool in_par;\n\t\t\t\tGF_Filter *srcf = gf_list_get(filter_dst->source_filters, j);\n\t\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\t\t\tin_par = gf_filter_in_parent_chain(pid->filter, srcf);\n\t\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t\tif (in_par) {\n\t\t\t\t\tignore_source_ids = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\tRELOCK_FILTER_LIST\n\n\t\t//if destination accepts only one input and connected or connection pending\n\t\t//note that if destination uses dynamic clone through source ids, we need to check this filter\n\t\tif (!filter_dst->max_extra_pids\n\t\t \t&& !filter_dst->dynamic_source_ids\n\t\t\t&& (filter_dst->num_input_pids || filter_dst->in_pid_connection_pending || filter_dst->in_link_resolution)\n\t\t \t&& (!filter->swap_pidinst_dst || (filter->swap_pidinst_dst->filter != filter_dst))\n\t\t) {\n\t\t\tif ((filter_dst->clonable==GF_FILTER_CLONE_PROBE)\n\t\t\t\t&& !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)\n\t\t\t\t&& !filter->source_ids\n\t\t\t)\n\t\t\t\tfilter_dst->clonable = GF_FILTER_NO_CLONE;\n\n\t\t\t//not explicitly clonable, don't connect to it\n\t\t\tif (filter_dst->clonable==GF_FILTER_NO_CLONE) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s not clonable\\n\", filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//explicitly clonable but caps don't match, don't connect to it\n\t\t\tif (!gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1)) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s caps does not match clonable filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_list_find(pid->filter->blacklisted, (void *) filter_dst->freg)>=0) continue;\n\n\t\t//we try to load a filter chain, so don't test against filters loaded for another chain\n\t\tif (filter_dst->dynamic_filter && (filter_dst != pid->filter->dst_filter)) {\n\t\t\t//dst was explicitly set and does not match\n\t\t\tif (pid->filter->dst_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has explicit dest %s not %s\\n\", pid->name, pid->filter->dst_filter->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//dst was not set, we may try to connect to this filter if it allows several input\n\t\t\t//this is typically the case for muxers instantiated dynamically\n\t\t\tif (!filter_dst->max_extra_pids) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has explicit dest %s (%p) matching but no extra pid possible\\n\", pid->name, filter_dst->name, filter_dst));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//pid->filter->dst_filter NULL and pid->filter->target_filter is not: we had a wrong resolved chain to target\n\t\t//so only attempt to relink the chain if dst_filter is the expected target\n\t\tif (!pid->filter->dst_filter && pid->filter->target_filter && (filter_dst != pid->filter->target_filter)) {\n\t\t\tif (filter_dst->target_filter != pid->filter->target_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has target filter %s not matching %s->%s\\n\", pid->name, pid->filter->target_filter->name, filter_dst->name, filter_dst->target_filter ? filter_dst->target_filter->name : \"null\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//if the target filter of this filter is the same as ours, try to connect - typically scalable streams decoding\n\t\t}\n\n\t\t//dynamic filters only connect to their destination, unless explicit connections through sources\n\t\t//we could remove this but this highly complicates PID resolution\n\t\tif (!filter_dst->source_ids && pid->filter->dynamic_filter && pid->filter->dst_filter && (filter_dst!=pid->filter->dst_filter)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has dest filter %s not matching %s\\n\", pid->name, pid->filter->dst_filter->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\t//walk up through the parent graph and check if this filter is already in. If so don't connect\n\t\t//since we don't allow re-entrant PIDs\n\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tin_parent_chain = gf_filter_in_parent_chain(filter, filter_dst);\n\n\t\tRELOCK_FILTER_LIST\n\n\t\tif (in_parent_chain) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has filter %s in its parent chain\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\n\t\t//do not create cyclic graphs due to link resolution (dynamic filters)\n\t\t//look in all registered input PIDs of filter_dst and check if the current PID being linked has one of these pid in its source chain.\n\t\t//If so, do not link. this solves:\n\t\t//      fin:ID1 [-> dmx] (PID1) -> dynf1 (PID2) -> dst1:SID=1\n\t\t//                              -> dynf2 (PID3) -> dst2:SID=1\n\t\t//In this case, PID2 will inherit ID1 and could be accepted a source of dynf2 which already has PID1 registered\n\t\t//by walking up PID2 parent chain we check that PID1 will not be linked twice to the same filter\n\t\t//\n\t\t//We stop inspecting at the first filter with ID in the source\n\t\tif (filter->dynamic_filter)  {\n\t\t\tBool cyclic_detected = GF_FALSE;\n\t\t\tu32 k;\n\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t//check filters pending a configure on filter_dst\n\t\t\tfor (k=0; k<gf_list_count(filter_dst->temp_input_pids); k++) {\n\t\t\t\tGF_FilterPid *a_src_pid = gf_list_get(filter_dst->temp_input_pids, k);\n\t\t\t\tif (a_src_pid == pid) continue;\n\t\t\t\tif (gf_pid_in_parent_chain(pid, a_src_pid))\n\t\t\t\t\tcyclic_detected = GF_TRUE;\n\t\t\t}\n\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\n\t\t\t//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain\n\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\t\t//check filters already connected on filter_dst\n\t\t\tfor (k=0; k<filter_dst->num_input_pids && !cyclic_detected; k++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter_dst->input_pids, k);\n\t\t\t\tif (pidi->pid == pid) continue;\n\t\t\t\tif (gf_pid_in_parent_chain(pid, pidi->pid))\n\t\t\t\t\tcyclic_detected = GF_TRUE;\n\t\t\t}\n\t\t\tgf_mx_v(filter_dst->tasks_mx);\n\n\t\t\tRELOCK_FILTER_LIST\n\n\t\t\tif (cyclic_detected) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s:%s has one or more PID in input chain already connected to filter %s, breaking cycle\\n\", pid->name, pid->filter->name, filter_dst->name));\n\t\t\t\tgf_list_del_item(force_link_resolutions, filter_dst);\n\t\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_links); k++) {\n\t\t\t\t\tGF_Filter *a_dst = gf_list_get(filter_dst->destination_links, k);\n                   gf_list_del_item(force_link_resolutions, a_dst);\n\t\t\t\t}\n\t\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {\n\t\t\t\t\tGF_Filter *a_dst = gf_list_get(filter_dst->destination_filters, k);\n                    gf_list_del_item(force_link_resolutions, a_dst);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if the original filter is in the parent chain of this PID's filter, don't connect (equivalent to re-entrant)\n\t\tif (filter_dst->cloned_from) {\n\t\t\tif (gf_filter_in_parent_chain(filter, filter_dst->cloned_from) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has the original of cloned filter %s in its parent chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (gf_filter_in_parent_chain(filter_dst->cloned_from, filter) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s has the original of cloned filter %s in its output filter chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if the filter is in the parent chain of this PID's original filter, don't connect (equivalent to re-entrant)\n\t\tif (filter->cloned_from) {\n\t\t\tif (gf_filter_in_parent_chain(filter->cloned_from, filter_dst) ) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s filter is cloned and has filter %s in its clone parent chain\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//if we have sourceID info on the destination, check them\n\t\tneeds_clone=GF_FALSE;\n\t\tif (filter_id) {\n\t\t\tif (filter_dst->source_ids) {\n\t\t\t\tBool pid_excluded=GF_FALSE;\n\t\t\t\tif (!filter_source_id_match(pid, filter_id, filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\t\tBool not_ours=GF_TRUE;\n\t\t\t\t\t//if filter is a dynamic one with an ID set, fetch ID from previous filter in chain\n\t\t\t\t\t//this is need for cases such as \"-i source filterFoo @ -o live.mpd\":\n\t\t\t\t\t//the dasher filter will be dynamically loaded AND will also assign itself a filter ID\n\t\t\t\t\t//due to internal filter (dasher) logic\n\t\t\t\t\t//that dasher filter ID will be different from the ID assigned by '@' on dst file's sourceID,\n\t\t\t\t\t//which is the filter ID of filterFoo\n\t\t\t\t\tif (filter->dynamic_filter && filter->id) {\n\t\t\t\t\t\tconst char *src_filter_id = gf_filter_last_id_in_chain(filter, GF_TRUE);\n\t\t\t\t\t\tif (filter_source_id_match(pid, src_filter_id, filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\t\t\t\tnot_ours = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (not_ours) {\n\t\t\t\t\t\tif (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;\n\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s does not match source ID for filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if we are a dynamic filter linking to a destination filter without ID (no link directive) and\n\t\t\t\t//implicit mode is used, use implicit linking\n\t\t\t\t//otherwise force explicit linking\n\t\t\t\t//this avoids that dyn filters loaded for a link targeting an implicitly link filter link to a later filter:\n\t\t\t\t//avsource enc_v @ FX output\n\t\t\t\t//if enc_v loads a filter FA to connect to FX, we don't want FA->output\n\t\t\t\tif (!filter->dynamic_filter || filter_dst->id || !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE))\n\t\t\t\t\tuse_explicit_link = GF_TRUE;\n\t\t\t}\n\t\t\t//if no source ID on the dst filter, this means the dst filter accepts any possible connections from out filter\n\t\t\t//unless prevented for this pid\n\t\t\telse if (pid->require_source_id) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s requires source ID, not set for filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//no filterID and dst expects only specific filters, continue\n\t\telse if (filter_dst->source_ids && !ignore_source_ids) {\n\t\t\tBool pid_excluded=GF_FALSE;\n\t\t\tif ( (filter_dst->source_ids[0]!='*')\n\t\t\t\t&& (filter_dst->source_ids[0]!=filter->session->sep_frag)\n\t\t\t\t&& (filter_dst->source_ids[0]!=filter->session->sep_neg)\n\t\t\t\t) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s does not match filter %s source ID\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!filter_source_id_match(pid, \"*\", filter_dst, &pid_excluded, &needs_clone)) {\n\t\t\t\tif (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s is excluded by filter %s source ID\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuse_explicit_link = GF_TRUE;\n\t\t}\n\t\telse if (filter->subsession_id != filter_dst->subsession_id) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s and filter %s not in same subsession and no links directive\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\t//filters are in the same subsession and have a subsource_id (not part of chain-to-sink)\n\t\t//only link if same subsource_id\n\t\telse if (filter->subsource_id && filter_dst->subsource_id && (filter->subsource_id != filter_dst->subsource_id)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s and filter %s do not have same source and no links directive\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t}\n\t\tif (needs_clone) {\n\t\t\t//remember this filter as clonable (dynamic source id scheme) if none yet found.\n\t\t\t//If we had a matching sourceID, clone is not needed\n\t\t\tif (!num_pass && !dynamic_filter_clone && !found_matching_sourceid) {\n\t\t\t\tdynamic_filter_clone = filter_dst;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s needs cloning of filter %s\\n\", pid->name, filter_dst->name));\n\t\t\tcontinue;\n\t\t} else if (dynamic_filter_clone && dynamic_filter_clone->freg==filter_dst->freg) {\n\t\t\tdynamic_filter_clone = NULL;\n\t\t}\n\t\t//remember we had a sourceid match\n\t\tfound_matching_sourceid = GF_TRUE;\n\n\t\t//we have a match, check if caps are OK\n\t\tcap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1);\n\n\t\t//dst filter forces demuxing, pid is file and caps matched, do not test and do not activate link resolution\n\t\t//if can_try_link_resolution is still false at end of pass one, we will insert a reframer\n\t\tif (cap_matched && filter_dst->force_demux && pid_is_file) {\n\t\t\tif (pid_is_file==1)\n\t\t\t\tpid_is_file = 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcan_try_link_resolution = GF_TRUE;\n\n\t\t//this is the right destination filter. We however need to check if we don't have a possible destination link\n\t\t//whose destination is this destination (typically mux > fout/pipe/sock case). If that's the case, swap the destination\n\t\t//filter with the intermediate node before matching caps and resolving link\n\t\tif (num_pass) {\n\t\t\tu32 k, alt_count = gf_list_count(possible_linked_resolutions);\n\t\t\tfor (k=0; k<alt_count; k++) {\n\t\t\t\tGF_Filter *adest = gf_list_get(possible_linked_resolutions, k);\n\t\t\t\t//we only apply this if the destination filter has the GF_FS_REG_DYNAMIC_REDIRECT flag set.\n\t\t\t\t//Not doing so could results in broken link resolution:\n\t\t\t\t//PID1(AVC) -> decoder1 -> compositor\n\t\t\t\t//PID2(PNG) -> decoder2 -> compositor\n\t\t\t\t//However this algo would force a connection of PID2 to decoder1 if decoder1 accepts multiple inputs, regardless of PID2 caps\n\t\t\t\tif (! (adest->freg->flags & GF_FS_REG_DYNAMIC_REDIRECT))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((gf_list_find(adest->destination_filters, filter_dst)>=0) || (gf_list_find(adest->destination_links, filter_dst)>=0) ) {\n\t\t\t\t\tfilter_dst = adest;\n\t\t\t\t\tgf_list_rem(possible_linked_resolutions, k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//if clonable filter and no match, check if we would match the caps without caps override of dest\n\t\t//note we don't do this on sources for the time being, since this might trigger undesired resolution of file->file\n\t\tif (!cap_matched && (filter_dst->clonable==GF_FILTER_CLONE) && pid->filter->num_input_pids) {\n\t\t\tcap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, NULL, NULL, NULL, pid->filter->dst_filter, -1);\n\t\t}\n\n\t\tif (!cap_matched) {\n\t\t\tBool skipped = GF_FALSE;\n\t\t\tBool reassigned=GF_FALSE;\n\t\t\tGF_Filter *new_f;\n\n\t\t\t//we don't load filter chains if we have a change of media type from anything except file to anything except file\n\t\t\t//i.e. transmodality (eg video->audio) can only be done through explicit filters\n\t\t\tif (gf_filter_pid_needs_explicit_resolution(pid, filter_dst)) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s needs explicit resolution for linking to filter %s\\n\", pid->name, filter_dst->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//we had a destination set during link resolve, and we don't match that filter, consider the link resolution wrong\n\t\t\tif (pid->filter->dst_filter && (filter_dst == pid->filter->dst_filter)) {\n\t\t\t\tGF_Filter *old_dst = pid->filter->dst_filter;\n\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t\tgf_list_del_item(pid->filter->destination_links, filter_dst);\n\t\t\t\tgf_list_del_item(pid->filter->destination_filters, filter_dst);\n\t\t\t\t//nobody using this filter, destroy\n\t\t\t\tif (old_dst->dynamic_filter\n\t\t\t\t\t&& !old_dst->has_pending_pids\n\t\t\t\t\t&& !old_dst->num_input_pids\n\t\t\t\t\t&& !old_dst->num_output_pids\n\t\t\t\t\t&& !old_dst->out_pid_connection_pending\n\t\t\t\t) {\n\t\t\t\t\tBool skip = ((old_dst==filter_dst) && (filter_dst->dynamic_filter!=2)) ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tgf_filter_post_remove(old_dst);\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!num_pass) {\n                //we have an explicit link instruction so we must try dynamic link even if we connect to another filter\n                //is_sink set, same thing (implicit mode only, force link to sink)\n\t\t\t\tif (filter_dst->source_ids || (is_sink && !implicit_link_found)) {\n                    gf_list_add(force_link_resolutions, filter_dst);\n                    //! filter is an alias, prevent linking to the filter being aliased\n                    if (filter_dst->multi_sink_target) {\n\t\t\t\t\t\tgf_list_del_item(force_link_resolutions, filter_dst->multi_sink_target);\n\t\t\t\t\t\tgf_list_add(linked_dest_filters, filter_dst->multi_sink_target);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//register as possible destination link. If a filter already registered is a destination of this possible link\n\t\t\t\t\t//only the possible link will be kept\n\t\t\t\t\tif (!possible_link_found_implicit_mode)\n\t\t\t\t\t\tadd_possible_link_destination(possible_linked_resolutions, filter_dst);\n\n\t\t\t\t\t//implicit link mode: if possible destination is not a sink, stop checking for possible links\n\t\t\t\t\t//continue however first pass in case we have a direct match with a dynamic filter, eg:\n\t\t\t\t\t//tiled_input.mpd -> compositor -> ...\n\t\t\t\t\t//the first pid will resolve to dashin + tileagg\n\t\t\t\t\t//the second pid from dashin must link to tileagg, but if we stop the pass 0 loop\n\t\t\t\t\t//it would link to compositor with a new tileagg filter\n\t\t\t\t\tif (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) && !is_sink) {\n\t\t\t\t\t\tpossible_link_found_implicit_mode = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfilter_found_but_pid_excluded = GF_FALSE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Attempting to solve link between PID %s:%s and filter %s\\n\", pid->filter->freg->name, pid->name, filter_dst->name));\n\n\t\t\tif (num_pass==1) reassigned = GF_TRUE;\n\t\t\telse reassigned = GF_FALSE;\n\n\t\t\t//we pass the list of loaded filters for this pid, so that we don't instanciate twice the same chain start\n\t\t\tnew_f = gf_filter_pid_resolve_link_check_loaded(pid, filter_dst, &reassigned, loaded_filters, &skipped);\n\n\t\t\t//try to load filters\n\t\t\tif (! new_f) {\n\t\t\t\tif (skipped) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid->filter->session->run_status!=GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"PID %s:%s init canceled (session abort)\\n\", pid->filter->name, pid->name));\n\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\tgf_list_del(linked_dest_filters);\n                    gf_list_del(force_link_resolutions);\n                    gf_list_del(possible_linked_resolutions);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//filter was reassigned (pid is destroyed), return\n\t\t\t\tif (reassigned) {\n\t\t\t\t\tif (num_pass==1) {\n\t\t\t\t\t\tcan_reassign_filter = GF_TRUE;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\tgf_list_del(linked_dest_filters);\n                    gf_list_del(force_link_resolutions);\n                    gf_list_del(possible_linked_resolutions);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//we might had it wrong solving the chain initially, break the chain\n\t\t\t\tif (filter_dst->dynamic_filter && filter_dst->dst_filter) {\n\t\t\t\t\tGF_Filter *new_dst = filter_dst;\n\t\t\t\t\twhile (new_dst->dst_filter && new_dst->dynamic_filter) {\n\t\t\t\t\t\tGF_Filter *f = new_dst;\n\t\t\t\t\t\tnew_dst = new_dst->dst_filter;\n\t\t\t\t\t\tif (!f->num_input_pids && !f->num_output_pids && !f->in_pid_connection_pending) {\n\t\t\t\t\t\t\tgf_filter_post_remove(f);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpid->filter->dst_filter = NULL;\n\t\t\t\t\tnew_f = gf_filter_pid_resolve_link(pid, new_dst, &reassigned);\n\t\t\t\t\tif (!new_f) {\n\t\t\t\t\t\tif (reassigned) {\n\t\t\t\t\t\t\tgf_mx_v(filter->session->filters_mx);\n\t\t\t\t\t\t\tassert(pid->init_task_pending);\n\t\t\t\t\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\t\t\t\t\tif (loaded_filters) gf_list_del(loaded_filters);\n\t\t\t\t\t\t\tgf_list_del(linked_dest_filters);\n                            gf_list_del(force_link_resolutions);\n                            gf_list_del(possible_linked_resolutions);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//good to go !\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//in implicit link, if target is not here push it (we have no SID/FID to solve that later)\n\t\t\tif ((filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)\n\t\t\t\t&& !gf_list_count(new_f->destination_filters)\n\t\t\t\t&& !gf_list_count(new_f->destination_links)\n\t\t\t\t&& !filter_dst->source_ids\n\t\t\t) {\n\t\t\t\tgf_list_add(new_f->destination_links, filter_dst);\n\t\t\t}\n\n\t\t\t//target was in clone probe but we have loaded a mux, disable clone\n\t\t\tif ((filter_dst->clonable==GF_FILTER_CLONE_PROBE) && new_f->max_extra_pids)\n\t\t\t\tfilter_dst->clonable = GF_FILTER_NO_CLONE;\n\n\t\t\tgf_list_del_item(filter->destination_filters, filter_dst);\n\t\t\tif (gf_list_find(new_f->destination_filters, filter_dst)>=0) {\n\t\t\t\tif (filter_dst->clonable==GF_FILTER_NO_CLONE)\n\t\t\t\t\tfilter_dst->in_link_resolution = GF_TRUE;\n\t\t\t}\n\n\t\t\tfilter_dst = new_f;\n\t\t\tgf_list_add(loaded_filters, new_f);\n\t\t}\n\n\t\tif (!(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))) {\n\t\t\tassert(pid->pid->filter->freg != filter_dst->freg);\n\t\t}\n\n\t\tsafe_int_inc(&pid->filter->out_pid_connection_pending);\n\t\tgf_mx_p(filter_dst->tasks_mx);\n\t\tgf_list_add(filter_dst->temp_input_pids, pid);\n\t\tif (pid->filter != filter_dst->single_source)\n\t\t\tfilter_dst->single_source = NULL;\n\t\tgf_mx_v(filter_dst->tasks_mx);\n\t\tgf_filter_pid_post_connect_task(filter_dst, pid);\n\n\t\tfound_dest = GF_TRUE;\n\t\tgf_list_add(linked_dest_filters, filter_dst);\n\n\t\tgf_list_del_item(filter->destination_links, filter_dst);\n\t\t/*we are linking to a mux, check all destination filters registered with the muxer and remove them from our possible destination links*/\n\t\tif (filter_dst->max_extra_pids) {\n\t\t\tu32 k=0;\n\t\t\tfor (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {\n\t\t\t\tGF_Filter *dst_f = gf_list_get(filter_dst->destination_filters, k);\n\t\t\t\tgf_list_del_item(filter->destination_links, dst_f);\n\t\t\t}\n\t\t}\n\n\t\t//implicit link mode: if target was a sink, allow further sink connections, otherwise stop linking\n\t\tif (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)) {\n\t\t\tif (is_sink)\n\t\t\t\tlink_sinks_only = GF_TRUE;\n\t\t\telse if (!implicit_link_found) {\n\t\t\t\tu32 k=0;\n\t\t\t\tfor (k=0; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\t\tGF_Filter *dst_f = gf_list_get(force_link_resolutions, k);\n\t\t\t\t\tif (!dst_f->source_ids) {\n\t\t\t\t\t\tgf_list_rem(force_link_resolutions, k);\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\timplicit_link_found = GF_TRUE;\n\t\t\t}\n\t\t}\n    }\n\n\tif (!num_pass) {\n\t\tu32 i, k;\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\t//cleanup forced filter list:\n\t\t//remove any forced filter which is a destination of a filter we already linked to\n\t\tfor (i=0; i< gf_list_count(linked_dest_filters); i++) {\n\t\t\tGF_Filter *filter_dst = gf_list_get(linked_dest_filters, i);\n\t\t\tfor (k=0; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\tGF_Filter *dst_link = gf_list_get(force_link_resolutions, k);\n\t\t\t\tif (//if forced filter is in parent chain (already connected filters), don't force a link\n\t\t\t\t\tgf_filter_in_parent_chain(filter_dst, dst_link)\n\t\t\t\t\t|| gf_filter_in_parent_chain(dst_link, filter_dst)\n\t\t\t\t\t//if forced filter is in destination of filter (connection pending), don't force a link\n\t\t\t\t\t//we need to walk up the destination chain, not just check the first level since the filter_dst might be connected\n\t\t\t\t\t//and no longer have dst_link in its destination filter list\n\t\t\t\t\t//typical case is multithreaded mode with mux or tileagg filter\n\t\t\t\t\t|| filter_match_target_dst(filter_dst->destination_filters, dst_link)\n\t\t\t\t\t|| filter_match_target_dst(filter_dst->destination_links, dst_link)\n\t\t\t\t\t//if forced filter's target is the same as what we connected to, don't force a link\n\t\t\t\t\t|| (dst_link->target_filter == filter_dst)\n\t\t\t\t) {\n\t\t\t\t\tgf_list_rem(force_link_resolutions, k);\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//cleanup forced link resolution list: remove any forced filter which is a destination of another forced filter\n\t\t//this is needed when multiple pids link to a single dynamically loaded mux, where we could end up\n\t\t//with both the  destination link and the mux (in this order) in this list, creating a new mux if the destination has a pending link\n\t\tfor (i=0; i<gf_list_count(force_link_resolutions); i++) {\n\t\t\tGF_Filter *forced_dst = gf_list_get(force_link_resolutions, i);\n\t\t\tfor (k=i+1; k<gf_list_count(force_link_resolutions); k++) {\n\t\t\t\tGF_Filter *forced_inserted = gf_list_get(force_link_resolutions, k);\n\n\t\t\t\tif (gf_filter_in_parent_chain(forced_inserted, forced_dst)\n\t\t\t\t\t|| filter_match_target_dst(forced_inserted->destination_filters, forced_dst)\n\t\t\t\t\t|| filter_match_target_dst(forced_inserted->destination_links, forced_dst)\n\t\t\t\t) {\n\t\t\t\t\tgf_list_rem(force_link_resolutions, i);\n\t\t\t\t\t//prevent linking to this filter\n\t\t\t\t\tgf_list_add(linked_dest_filters, forced_dst);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_mx_p(filter->session->filters_mx);\n\t}\n\n\tif (loaded_filters) {\n\t\tgf_list_del(loaded_filters);\n\t\tloaded_filters = NULL;\n\t}\n\n\t//we still have possible destination links and we can try link resolution, do it\n\tif (!num_pass && gf_list_count(filter->destination_links) && can_try_link_resolution && filter->session->max_resolve_chain_len) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n    //we must do the second pass if a filter has an explicit link set through source ID\n\tif (!num_pass && gf_list_count(force_link_resolutions)) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n\n    //connection task posted, nothing left to do\n\tif (found_dest) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\tgf_mx_v(filter->session->filters_mx);\n\t\tpid->filter->disabled = GF_FILTER_ENABLED;\n\t\tgf_list_del(linked_dest_filters);\n        gf_list_del(force_link_resolutions);\n        gf_list_del(possible_linked_resolutions);\n\t\tgf_fs_check_graph_load(filter->session, GF_FALSE);\n\t\tif (pid->not_connected) {\n\t\t\tpid->not_connected = 0;\n\t\t\tassert(pid->filter->num_out_pids_not_connected);\n\t\t\tpid->filter->num_out_pids_not_connected--;\n\t\t}\n\t\treturn;\n\t}\n\n\t//on first pass, if we found a clone (eg a filter using freg:#PropName=*), instantiate this clone and redo the pid linking to this clone (last entry in the filter list)\n\tif (dynamic_filter_clone && !num_pass) {\n\t\tGF_Filter *clone = gf_filter_clone(dynamic_filter_clone, NULL);\n\t\tif (clone) {\n\t\t\tassert(dynamic_filter_clone->dynamic_source_ids);\n\t\t\tgf_free(clone->source_ids);\n\t\t\tclone->source_ids = gf_strdup(dynamic_filter_clone->dynamic_source_ids);\n\t\t\tclone->cloned_from = NULL;\n\t\t\tcount = gf_list_count(filter->session->filters);\n\t\t\tgf_list_add(pid->filter->destination_links, clone);\n\t\t\tf_idx = count-1;\n\t\t\tnum_pass = 1;\n\t\t\tgoto single_retry;\n\t\t}\n\t}\n\n\t//nothing found at first pass and demuxed forced, inject a reframer filter\n\tif (!num_pass && !can_try_link_resolution && (pid_is_file==2)) {\n\t\tGF_Err e;\n\t\tGF_Filter *f = gf_fs_load_filter(filter->session, \"reframer\", &e);\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Local file PID %s to local file detected, forcing remux\\n\", pid->name));\n\t\t\tf->dynamic_filter = 2;\n\t\t\tf->subsession_id = pid->filter->subsession_id;\n\t\t\tf->subsource_id = pid->filter->subsource_id;\n\t\t\t//force pid's filter destination to the reframer - this will in pass #2:\n\t\t\t//- force solving file->reframer, loading the demuxer\n\t\t\t//- since caps between pid and reframer don't match and reframer is not used by anyone, the reframer will be removed\n\t\t\t//We end up with a demuxed source with no intermediate reframer filter :)\n\t\t\tpid->filter->dst_filter = f;\n\t\t\tnum_pass = 1;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t//nothing found, redo a pass, this time allowing for link resolve\n\tif (!num_pass && can_try_link_resolution && filter->session->max_resolve_chain_len) {\n\t\tnum_pass = 1;\n\t\tgoto restart;\n\t}\n\tif ((num_pass==1) && can_reassign_filter) {\n\t\tif (filter->session->flags & GF_FS_FLAG_NO_REASSIGN) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"PID %s in filter %s not connected, source reassignment was possible but is disabled\\n\", pid->name, pid->filter->name));\n\t\t} else {\n\t\t\tnum_pass = 2;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s in filter %s not connected to any loaded filter, trying source reassignment\\n\", pid->name, pid->filter->name));\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tgf_fs_check_graph_load(filter->session, GF_FALSE);\n\n\tgf_list_del(linked_dest_filters);\n    gf_list_del(force_link_resolutions);\n    gf_list_del(possible_linked_resolutions);\n\tgf_mx_v(filter->session->filters_mx);\n\n\tif (pid->num_destinations && !pid->not_connected) {\n\t\tassert(pid->init_task_pending);\n\t\tsafe_int_dec(&pid->init_task_pending);\n\t\treturn;\n\t}\n\tfilter->num_out_pids_not_connected ++;\n\t//remove sparse info\n\tif (pid->is_sparse) {\n\t\tassert(filter->nb_sparse_pids);\n\t\tsafe_int_dec(&filter->nb_sparse_pids);\n\t\tpid->is_sparse = 0;\n\t}\n\n\tGF_FilterEvent evt;\n\tif (filter_found_but_pid_excluded) {\n\t\t//PID was not included in explicit connection lists\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s in filter %s not connected to any loaded filter due to source directives\\n\", pid->name, pid->filter->name));\n\t\tpid->not_connected = 1;\n\t} else {\n\t\t//no filter found for this pid !\n\t\tif (!pid->not_connected_ok && (filter->session->flags & GF_FS_FLAG_FULL_LINK) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"No filter chain found for PID %s in filter %s to any loaded filters - ABORTING!\\n\", pid->name, pid->filter->name));\n\t\t\tfilter->session->last_connect_error = GF_FILTER_NOT_FOUND;\n\t\t\tfilter->session->run_status = GF_FILTER_NOT_FOUND;\n\t\t\tfilter->session->in_final_flush = GF_TRUE;\n\t\t\tassert(pid->init_task_pending);\n\t\t\tsafe_int_dec(&pid->init_task_pending);\n\t\t\treturn;\n\t\t}\n\n\t\tGF_LOG(pid->not_connected_ok ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_FILTER, (\"No filter chain found for PID %s in filter %s to any loaded filters - NOT CONNECTED\\n\", pid->name, pid->filter->name));\n\n\t\tif (pid->filter->freg->process_event) {\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);\n\t\t\tpid->filter->freg->process_event(filter, &evt);\n\t\t}\n\t\tpid->not_connected = 1;\n\t}\n\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\tevt.play.initial_broadcast_play = 2;\n\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\tevt.play.initial_broadcast_play = 2;\n\tgf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);\n\n\tgf_filter_pid_set_eos(pid);\n\tif (!pid->not_connected_ok\n\t\t&& !parent_chain_has_dyn_pids(pid->filter)\n\t\t&& (pid->filter->num_out_pids_not_connected == pid->filter->num_output_pids)\n\t) {\n\t\tpid->filter->disabled = GF_FILTER_DISABLED;\n\n\t\tif (can_reassign_filter) {\n\t\t\tgf_filter_setup_failure(pid->filter, GF_FILTER_NOT_FOUND);\n\t\t}\n\t}\n\n\tif (!filter_found_but_pid_excluded && !pid->not_connected_ok && !filter->session->max_resolve_chain_len) {\n\t\tfilter->session->last_connect_error = GF_FILTER_NOT_FOUND;\n\t}\n\n\tassert(pid->init_task_pending);\n\tsafe_int_dec(&pid->init_task_pending);\n\treturn;\n}\n\nvoid gf_filter_pid_post_connect_task(GF_Filter *filter, GF_FilterPid *pid)\n{\n\tassert(pid->pid);\n\tassert(pid->filter != filter);\n\tif (!(filter->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))) {\n\t\tassert(pid->filter->freg != filter->freg);\n\t}\n\tassert(filter->freg->configure_pid);\n\tsafe_int_inc(&filter->session->pid_connect_tasks_pending);\n\tsafe_int_inc(&filter->in_pid_connection_pending);\n\tgf_fs_post_task_ex(filter->session, gf_filter_pid_connect_task, filter, pid, \"pid_connect\", NULL, GF_TRUE, GF_FALSE, GF_FALSE, TASK_TYPE_NONE);\n}\n\n\nvoid gf_filter_pid_post_init_task(GF_Filter *filter, GF_FilterPid *pid)\n{\n//\tBool force_main_thread=GF_FALSE;\n\tif (pid->init_task_pending) return;\n\n\tsafe_int_inc(&pid->init_task_pending);\n//\tif (filter->session->force_main_thread_tasks)\n\t//force pid_init on main thread to avoid concurrent graph resolutions. While it works well for simple cases, it is problematic\n\t//for complex chains involving a lot of filters (typically gui loading icons)\n\tBool force_main_thread = GF_TRUE;\n\n\tgf_fs_post_task_ex(filter->session, gf_filter_pid_init_task, filter, pid, \"pid_init\", NULL, GF_FALSE, force_main_thread, GF_FALSE, TASK_TYPE_NONE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_framing_mode(GF_FilterPid *pid, Bool requires_full_blocks)\n{\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set framing info on an output pid in filter %s\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidinst->requires_full_data_block = requires_full_blocks;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_FilterPid *gf_filter_pid_new(GF_Filter *filter)\n{\n\tchar szName[30];\n\tGF_FilterPid *pid;\n\tGF_SAFEALLOC(pid, GF_FilterPid);\n\tif (!pid) return NULL;\n\tpid->filter = filter;\n\tpid->destinations = gf_list_new();\n\tpid->properties = gf_list_new();\n\tif (!filter->output_pids) filter->output_pids = gf_list_new();\n\tgf_mx_p(filter->tasks_mx);\n\tgf_list_add(filter->output_pids, pid);\n\tfilter->num_output_pids = gf_list_count(filter->output_pids);\n\tgf_mx_v(filter->tasks_mx);\n\tpid->pid = pid;\n\tpid->playback_speed_scaler = GF_FILTER_SPEED_SCALER;\n\tpid->require_source_id = filter->require_source_id;\n\n\tsprintf(szName, \"PID%d\", filter->num_output_pids);\n\tpid->name = gf_strdup(szName);\n\n\tfilter->has_pending_pids = GF_TRUE;\n\tgf_fq_add(filter->pending_pids, pid);\n\n\tgf_mx_p(filter->tasks_mx);\n\t//by default copy properties if only one input pid\n\tif (filter->num_input_pids==1) {\n\t\tGF_FilterPid *pidi = gf_list_get(filter->input_pids, 0);\n\t\tgf_filter_pid_copy_properties(pid, pidi);\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn pid;\n}\n\nvoid gf_filter_pid_del(GF_FilterPid *pid)\n{\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s destruction (%p)\\n\", pid->filter->name, pid->name, pid));\n\twhile (gf_list_count(pid->destinations)) {\n\t\tgf_filter_pid_inst_del(gf_list_pop_back(pid->destinations));\n\t}\n\tgf_list_del(pid->destinations);\n\n\twhile (gf_list_count(pid->properties)) {\n\t\tGF_PropertyMap *prop = gf_list_pop_back(pid->properties);\n\t\tassert(prop->reference_count);\n\t\tif (safe_int_dec(&prop->reference_count) == 0) {\n\t\t\tgf_props_del(prop);\n\t\t}\n\t}\n\tgf_list_del(pid->properties);\n\n\tif(pid->caps_negociate) {\n\t\tassert(pid->caps_negociate->reference_count);\n\t\tif (safe_int_dec(&pid->caps_negociate->reference_count) == 0) {\n\t\t\tgf_props_del(pid->caps_negociate);\n\t\t}\n\t}\n\n\tif (pid->adapters_blacklist)\n\t\tgf_list_del(pid->adapters_blacklist);\n\n\tif (pid->infos) {\n\t\tassert(pid->infos->reference_count);\n\t\tif (safe_int_dec(&pid->infos->reference_count) == 0) {\n\t\t\tgf_props_del(pid->infos);\n\t\t}\n\t}\n\tif (pid->name) gf_free(pid->name);\n\tgf_free(pid);\n}\n\nvoid gf_filter_pid_del_task(GF_FSTask *task)\n{\n\tgf_filter_pid_del(task->pid);\n}\n\nstatic GF_PropertyMap *check_new_pid_props(GF_FilterPid *pid, Bool merge_props)\n{\n\tu32 i, nb_recf;\n\tGF_PropertyMap *old_map;\n\tGF_PropertyMap *map;\n\n\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\tgf_mx_p(pid->filter->tasks_mx);\n\told_map = gf_list_last(pid->properties);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\tpid->props_changed_since_connect = GF_TRUE;\n\tif (old_map && !pid->request_property_map) {\n\t\treturn old_map;\n\t}\n\tmap = gf_props_new(pid->filter);\n\tif (!map)\n\t\treturn NULL;\n\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\tgf_mx_p(pid->filter->tasks_mx);\n\tgf_list_add(pid->properties, map);\n\tgf_mx_v(pid->filter->tasks_mx);\n\n\tpid->request_property_map = GF_FALSE;\n\tpid->pid_info_changed = GF_FALSE;\n\n\t//when creating a new map, ref_count of old map is decremented\n\tif (old_map) {\n\t\tif (merge_props)\n\t\t\tgf_props_merge_property(map, old_map, NULL, NULL);\n\n\t\tassert(old_map->reference_count);\n\t\tif (safe_int_dec(&old_map->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pid->properties, old_map);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tgf_props_del(old_map);\n\t\t}\n\t}\n\n\t//trick here: we may be reconfigured before any packet is being dispatched\n\t//so we need to manually trigger reconfigure of outputs\n\tnb_recf = 0;\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\tif (!pidi->filter->process_task_queued) {\n\t\t\t//remember the pid prop map to use\n\t\t\tpidi->reconfig_pid_props = map;\n\t\t\tnb_recf++;\n\t\t}\n\t}\n\tif (nb_recf)\n\t\tpid->filter->reconfigure_outputs = GF_TRUE;\n\treturn map;\n}\n\nstatic GF_Err gf_filter_pid_set_property_full(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, char *dyn_name, const GF_PropertyValue *value, Bool is_info)\n{\n\tGF_PropertyMap *map;\n\tconst GF_PropertyValue *oldp;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to write property on input PID in filter %s - ignoring\\n\", pid->filter->name ? pid->filter->name : pid->filter->freg->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (prop_4cc) {\n\t\toldp = gf_filter_pid_get_property(pid, prop_4cc);\n\t} else {\n\t\toldp = gf_filter_pid_get_property_str(pid, prop_name ? prop_name : dyn_name);\n\t}\n\tif (!oldp && !value)\n\t\treturn GF_OK;\n\tif (oldp && value) {\n\t\tif (gf_props_equal_strict(oldp, value)) {\n\t\t\tif (value->type==GF_PROP_DATA_NO_COPY) gf_free(value->value.data.ptr);\n\t\t\telse if (value->type==GF_PROP_STRING_NO_COPY) gf_free(value->value.string);\n\t\t\telse if (value->type==GF_PROP_STRING_LIST) gf_props_reset_single((GF_PropertyValue *) value);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//info property, do not request a new property map\n\tif (is_info) {\n\t\tmap = pid->infos;\n\t\tif (!map) {\n\t\t\tmap = pid->infos = gf_props_new(pid->filter);\n\t\t}\n\t\tpid->pid_info_changed = GF_TRUE;\n\t} else {\n\t\t//always merge properties\n\t\tmap = check_new_pid_props(pid, GF_TRUE);\n\t}\n\tif (!map) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (value && (prop_4cc==GF_PROP_PID_TIMESCALE))\n\t\tmap->timescale = value->value.uint;\n\n\t//if change of codecid or streamtype, remove ISOBMFF templates and subtype for codec\n\tif (oldp && value) {\n\t\tBool reset=0;\n\t\tif (prop_4cc == GF_PROP_PID_CODECID) {\n\t\t\treset = 2;\n\t\t} else if (prop_4cc == GF_PROP_PID_STREAM_TYPE) {\n\t\t\tif ((oldp->value.uint==GF_STREAM_ENCRYPTED) || (value->value.uint==GF_STREAM_ENCRYPTED))\n\t\t\t\treset = 1;\n\t\t}\n\t\tif (reset) {\n\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, NULL, NULL, NULL);\n\t\t\tif (reset==2) {\n\t\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_STSD_TEMPLATE, NULL, NULL, NULL);\n\t\t\t\tgf_props_set_property(map, GF_PROP_PID_ISOM_SUBTYPE, NULL, NULL, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value && (prop_4cc == GF_PROP_PID_ID) && !pid->name) {\n\t\tchar szName[100];\n\t\tsprintf(szName, \"PID%d\", value->value.uint);\n\t\tgf_filter_pid_set_name(pid, szName);\n\t}\n\treturn gf_props_set_property(map, prop_4cc, prop_name, dyn_name, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, prop_4cc, NULL, NULL, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, name, NULL, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_property_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, NULL, name, value, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, prop_4cc, NULL, NULL, value, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, name, NULL, value, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_info_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_set_property_full(pid, 0, NULL, name, value, GF_TRUE);\n}\n\nstatic GF_Err gf_filter_pid_negociate_property_full(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, char *dyn_name, const GF_PropertyValue *value)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to negociate property on output PID in filter %s - ignoring\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpid = pid->pid;\n\tif (!pid->caps_negociate) {\n\t\tassert(!pid->caps_negociate_pidi_list);\n\t\tpid->caps_negociate = gf_props_new(pid->filter);\n\t\tpid->caps_negociate_pidi_list = gf_list_new();\n\t\tpid->caps_negociate_direct = GF_TRUE;\n\t\tgf_list_add(pid->caps_negociate_pidi_list, pidi);\n\t\t//we start a new caps negotiation step, reset any blacklist on pid\n\t\tif (pid->adapters_blacklist) {\n\t\t\tgf_list_del(pid->adapters_blacklist);\n\t\t\tpid->adapters_blacklist = NULL;\n\t\t}\n\t\tsafe_int_inc(&pid->filter->nb_caps_renegociate);\n\t}\n\telse {\n\t\tconst GF_PropertyValue *p;\n\t\t//new PID instance asking for cap negociation\n\t\tif (gf_list_find(pid->caps_negociate_pidi_list, pidi)<0) {\n\t\t\tgf_list_add(pid->caps_negociate_pidi_list, pidi);\n\t\t}\n\n\t\t//check if same property to list\n\t\tp = gf_props_get_property(pid->caps_negociate, prop_4cc, prop_name);\n\t\tif (p) {\n\t\t\tif (gf_props_equal(p, value))\n\t\t\t\treturn GF_OK;\n\t\t\t//not the same value, disable direct caps negociate\n\t\t\tpid->caps_negociate_direct = GF_FALSE;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_INFO)) {\n\t\tchar p_dump[GF_PROP_DUMP_ARG_SIZE];\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"PID %s negociate property %s to %s\\n\",\n\t\t\tpid->filter->name, \tprop_name ? prop_name : gf_props_4cc_get_name(prop_4cc),\n\t\t\tgf_props_dump(prop_4cc, value, p_dump, GF_PROP_DUMP_DATA_NONE)\n\t\t));\n\t}\n#endif\n\n\t//pid is end of stream or pid instance has packet pendings, we will need a new chain to adapt these packets formats\n\tif (pid->has_seen_eos || gf_fq_count(pidi->packets)) {\n\t\tgf_fs_post_task(pid->filter->session, gf_filter_renegociate_output_task, pid->filter, NULL, \"filter renegociate\", NULL);\n\t}\n\treturn gf_props_set_property(pid->caps_negociate, prop_4cc, prop_name, dyn_name, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property(GF_FilterPid *pid, u32 prop_4cc, const GF_PropertyValue *value)\n{\n\tif (!prop_4cc) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, prop_4cc, NULL, NULL, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property_str(GF_FilterPid *pid, const char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, 0, name, NULL, value);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_negociate_property_dyn(GF_FilterPid *pid, char *name, const GF_PropertyValue *value)\n{\n\tif (!name) return GF_BAD_PARAM;\n\treturn gf_filter_pid_negociate_property_full(pid, 0, NULL, name, value);\n}\n\n\nstatic GF_PropertyMap *filter_pid_get_prop_map(GF_FilterPid *pid, Bool first_prop_if_output)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\t\t//first time we access the props, use the first entry in the property list\n\t\tif (!pidi->props) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t\tpidi->props = gf_list_get(pid->pid->properties, 0);\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tassert(pidi->props);\n\t\t\tsafe_int_inc(&pidi->props->reference_count);\n\t\t}\n\t\treturn pidi->props;\n\t} else {\n\t\tGF_PropertyMap *res_map = NULL;\n\t\tpid = pid->pid;\n\t\tif (pid->local_props) return pid->local_props;\n\n\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tif (first_prop_if_output)\n\t\t\tres_map = gf_list_get(pid->properties, 0);\n\t\telse\n\t\t\tres_map = gf_list_last(pid->properties);\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\treturn res_map;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_property(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, prop_4cc, NULL);\n}\n\nconst GF_PropertyValue *gf_filter_pid_get_property_first(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_TRUE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, prop_4cc, NULL);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_property_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, 0, prop_name);\n}\n\nconst GF_PropertyValue *gf_filter_pid_get_property_str_first(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_TRUE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property(map, 0, prop_name);\n}\n\nconst GF_PropertyEntry *gf_filter_pid_get_property_entry(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property_entry(map, prop_4cc, NULL);\n}\n\nGF_EXPORT\nconst GF_PropertyEntry *gf_filter_pid_get_property_entry_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map = filter_pid_get_prop_map(pid, GF_FALSE);\n\tif (!map)\n\t\treturn NULL;\n\treturn gf_props_get_property_entry(map, 0, prop_name);\n}\n\nstatic const GF_PropertyValue *gf_filter_pid_get_info_internal(GF_FilterPid *pid, u32 prop_4cc, const char *prop_name, Bool first_call,  GF_PropertyEntry **propentry)\n{\n\tu32 i;\n\tconst GF_PropertyEntry *prop_ent = NULL;\n\tGF_PropertyMap *map;\n\t*propentry = NULL;\n\t\n\tif (first_call) {\n\t\tgf_mx_p(pid->filter->session->info_mx);\n\t}\n\tmap = filter_pid_get_prop_map(pid, GF_FALSE);\n\n\tif (map) {\n\t\tprop_ent = gf_props_get_property_entry(map, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\tif (pid->pid->infos) {\n\t\tprop_ent = gf_props_get_property_entry(pid->pid->infos, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tprop_ent = NULL;\n\t\tgoto exit;\n\t}\n\tpid = pid->pid;\n\tif (pid->infos) {\n\t\tprop_ent = gf_props_get_property_entry(pid->infos, prop_4cc, prop_name);\n\t\tif (prop_ent) goto exit;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tconst GF_PropertyValue *prop;\n\t\tGF_FilterPid *pidinst = gf_list_get(pid->filter->input_pids, i);\n\t\tif (!pidinst->pid) continue;\n\t\tif (!pidinst->pid->filter) continue;\n\t\tif (pidinst->pid->filter->removed) continue;\n\n\t\tprop = gf_filter_pid_get_info_internal((GF_FilterPid *)pidinst, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tprop_ent = *propentry;\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\tprop_ent = NULL;\n\nexit:\n\tif (first_call) {\n\t\tgf_mx_v(pid->filter->session->info_mx);\n\t}\n\tif (!prop_ent) {\n\t\t*propentry = NULL;\n\t\treturn NULL;\n\t}\n\tif (! (*propentry)) {\n\t\t*propentry = (GF_PropertyEntry *) prop_ent;\n\t\tsafe_int_inc(&prop_ent->reference_count);\n\t}\n\treturn &prop_ent->prop;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_info(GF_FilterPid *pid, u32 prop_4cc, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_pid_get_info_internal(pid, prop_4cc, NULL, GF_TRUE, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_get_info_str(GF_FilterPid *pid, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_pid_get_info_internal(pid, 0, prop_name, GF_TRUE, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_enum_info(GF_FilterPid *pid, u32 *idx, u32 *prop_4cc, const char **prop_name)\n{\n\tu32 i, cur_idx=0, nb_in_pid=0;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\tcur_idx = *idx;\n\tif (pid->infos) {\n\t\tcur_idx = *idx;\n\t\tconst GF_PropertyValue *prop = gf_props_enum_property(pid->infos, &cur_idx, prop_4cc, prop_name);\n\t\tif (prop) {\n\t\t\t*idx = cur_idx;\n\t\t\treturn prop;\n\t\t}\n\t\tnb_in_pid = cur_idx;\n\t\tcur_idx = *idx - nb_in_pid;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tu32 sub_idx = cur_idx;\n\t\tconst GF_PropertyValue * prop;\n\t\tGF_FilterPid *pidinst = gf_list_get(pid->filter->input_pids, i);\n\t\tprop = gf_filter_pid_enum_info((GF_FilterPid *)pidinst, &sub_idx, prop_4cc, prop_name);\n\t\tif (prop) {\n\t\t\t*idx = nb_in_pid + sub_idx;\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn prop;\n\t\t}\n\t\tnb_in_pid += sub_idx;\n\t\tcur_idx = *idx - nb_in_pid;\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn NULL;\n}\n\n\nstatic const GF_PropertyValue *gf_filter_get_info_internal(GF_Filter *filter, u32 prop_4cc, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tu32 i;\n\tconst GF_PropertyValue *prop=NULL;\n\n\tgf_mx_p(filter->session->info_mx);\n\tgf_mx_p(filter->tasks_mx);\n\n\t//TODO avoid doing back and forth ...\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tprop = gf_filter_pid_get_info_internal(pid, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tgf_mx_v(filter->session->info_mx);\n\t\t\treturn prop;\n\t\t}\n\t}\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidinst = gf_list_get(filter->input_pids, i);\n\t\tprop = gf_filter_pid_get_info_internal(pidinst->pid, prop_4cc, prop_name, GF_FALSE, propentry);\n\t\tif (prop) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tgf_mx_v(filter->session->info_mx);\n\t\t\treturn prop;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\tgf_mx_v(filter->session->info_mx);\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_get_info(GF_Filter *filter, u32 prop_4cc, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_get_info_internal(filter, prop_4cc, NULL, propentry);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_get_info_str(GF_Filter *filter, const char *prop_name, GF_PropertyEntry **propentry)\n{\n\tif (!propentry) return NULL;\n\tif (*propentry) {\n\t\tgf_filter_release_property(*propentry);\n\t\t*propentry = NULL;\n\t}\n\treturn gf_filter_get_info_internal(filter, 0, prop_name, propentry);\n}\n\nGF_EXPORT\nvoid gf_filter_release_property(GF_PropertyEntry *propentry)\n{\n\tif (propentry) {\n\t\tgf_props_del_property(propentry);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_reset_properties(GF_FilterPid *pid)\n{\n\tGF_PropertyMap *map;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset all properties on input PID in filter %s - ignoring\\n\", pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//don't merge properties, we will reset them anyway\n\tmap = check_new_pid_props(pid, GF_FALSE);\n\n\tif (!map) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tgf_props_reset(map);\n\treturn GF_OK;\n\n}\n\nstatic GF_Err gf_filter_pid_merge_properties_internal(GF_FilterPid *dst_pid, GF_FilterPid *src_pid, gf_filter_prop_filter filter_prop, void *cbk, Bool is_merge)\n{\n\tGF_PropertyMap *dst_props, *src_props = NULL, *old_dst_props=NULL;\n\tif (PID_IS_INPUT(dst_pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset all properties on input PID in filter %s - ignoring\\n\", dst_pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_merge) {\n\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\told_dst_props = gf_list_last(dst_pid->properties);\n\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t}\n\n\t//don't merge properties with old state we merge with source pid\n\tdst_props = check_new_pid_props(dst_pid, GF_FALSE);\n\n\tif (!dst_props) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for destination pid in filter %s, ignoring reset\\n\", dst_pid->filter->name));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\t//if pid is input, use the current properties - cf filter_pid_get_prop_map\n\tif (PID_IS_INPUT(src_pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)src_pid;\n\t\tif (!pidi->props) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\t\tpidi->props = gf_list_get(src_pid->pid->properties, 0);\n\t\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t\t\tassert(pidi->props);\n\t\t\tsafe_int_inc(&pidi->props->reference_count);\n\t\t}\n\t\tsrc_props = pidi->props;\n\t}\n\t//move to real pid\n\tsrc_pid = src_pid->pid;\n\t//this is a copy props on output pid\n\tif (!src_props) {\n\t\t//our list is not thread-safe, so we must lock the filter when destroying the props\n\t\t//otherwise gf_list_last() (this caller) might use the last entry while another thread sets this last entry to NULL\n\t\tgf_mx_p(src_pid->filter->tasks_mx);\n\t\tsrc_props = gf_list_last(src_pid->properties);\n\t\tgf_mx_v(src_pid->filter->tasks_mx);\n\t\tif (!src_props) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties to copy from pid %s in filter %s, ignoring merge\\n\", src_pid->name, src_pid->filter->name));\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (src_pid->name && !old_dst_props)\n\t\tgf_filter_pid_set_name(dst_pid, src_pid->name);\n\n\tif (!is_merge) {\n\t\tgf_props_reset(dst_props);\n\t} else {\n\t\t//we created a new map\n\t\tif (old_dst_props && (old_dst_props!=dst_props)) {\n\t\t\tGF_Err e = gf_props_merge_property(dst_props, old_dst_props, NULL, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn gf_props_merge_property(dst_props, src_props, filter_prop, cbk);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_merge_properties(GF_FilterPid *dst_pid, GF_FilterPid *src_pid, gf_filter_prop_filter filter_prop, void *cbk )\n{\n\treturn gf_filter_pid_merge_properties_internal(dst_pid, src_pid, filter_prop, cbk, GF_TRUE);\n}\nGF_EXPORT\nGF_Err gf_filter_pid_copy_properties(GF_FilterPid *dst_pid, GF_FilterPid *src_pid)\n{\n\treturn gf_filter_pid_merge_properties_internal(dst_pid, src_pid, NULL, NULL, GF_FALSE);\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_packet_count(GF_FilterPid *pid)\n{\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tpidinst = gf_list_get(pid->destinations, 0);\n\t\tif (! pidinst) return 0;\n\t\treturn gf_fq_count(pidinst->packets) - pidinst->nb_eos_signaled - pidinst->nb_clocks_signaled;\n\n\t} else {\n\t\tif (pidinst->discard_packets) return 0;\n\t\treturn gf_fq_count(pidinst->packets) - pidinst->nb_eos_signaled - pidinst->nb_clocks_signaled;\n\t}\n}\n\nstatic Bool gf_filter_pid_filter_internal_packet(GF_FilterPidInst *pidi, GF_FilterPacketInstance *pcki)\n{\n\tBool is_internal = GF_FALSE;\n\tu32 ctype = (pcki->pck->info.flags & GF_PCK_CMD_MASK);\n\tif (ctype == GF_PCK_CMD_PID_EOS ) {\n\t\tpcki->pid->is_end_of_stream = pcki->pid->pid->has_seen_eos ? GF_TRUE : GF_FALSE;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found EOS packet in PID %s in filter %s - eos %d\\n\", pidi->pid->name, pidi->filter->name, pcki->pid->pid->has_seen_eos));\n\t\tassert(pcki->pid->nb_eos_signaled);\n\t\tsafe_int_dec(&pcki->pid->nb_eos_signaled);\n\t\tis_internal = GF_TRUE;\n\t} else if (ctype == GF_PCK_CMD_PID_REM) {\n\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_disconnect_task, pidi->filter, pidi->pid, \"pidinst_disconnect\", NULL);\n\n\t\tis_internal = GF_TRUE;\n\t}\n\tctype = (pcki->pck->info.flags & GF_PCK_CKTYPE_MASK) >> GF_PCK_CKTYPE_POS;\n\n\tif (ctype) {\n\t\tu32 timescale;\n\t\tif (pcki->pid->handles_clock_references) return GF_FALSE;\n\t\tassert(pcki->pid->nb_clocks_signaled);\n\t\tsafe_int_dec(&pcki->pid->nb_clocks_signaled);\n\t\t//signal destination\n\t\tassert(!pcki->pid->filter->next_clock_dispatch_type || !pcki->pid->filter->num_output_pids);\n\n\t\ttimescale = pcki->pck->pid_props ? pcki->pck->pid_props->timescale : 0;\n\t\tpcki->pid->filter->next_clock_dispatch = pcki->pck->info.cts;\n\t\tpcki->pid->filter->next_clock_dispatch_timescale = timescale;\n\t\tpcki->pid->filter->next_clock_dispatch_type = ctype;\n\n\t\t//keep clock values but only override clock type if no discontinuity is pending\n\t\tpcki->pid->last_clock_value = pcki->pck->info.cts;\n\t\tpcki->pid->last_clock_timescale = timescale;\n\t\tif (pcki->pid->last_clock_type != GF_FILTER_CLOCK_PCR_DISC)\n\t\t\tpcki->pid->last_clock_type = ctype;\n\n\t\tif (ctype == GF_FILTER_CLOCK_PCR_DISC) {\n\t\t\tassert(pcki->pid->last_clock_type == GF_FILTER_CLOCK_PCR_DISC);\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Internal clock reference packet filtered - PID %s clock ref \"LLU\"/%d - type %d\\n\", pcki->pid->pid->name, pcki->pid->last_clock_value, pcki->pid->last_clock_timescale, pcki->pid->last_clock_type));\n\t\t//the following call to drop_packet will trigger clock forwarding to all output pids\n\t\tis_internal = GF_TRUE;\n\t}\n\n\tif (is_internal) gf_filter_pid_drop_packet((GF_FilterPid *)pidi);\n\treturn is_internal;\n}\n\nstatic Bool filter_pck_check_prop_change(GF_FilterPidInst *pidinst, GF_FilterPacketInstance *pcki, Bool do_notif)\n{\n\tif ( (pcki->pck->info.flags & GF_PCKF_PROPS_CHANGED) && !pcki->pid_props_change_done) {\n\t\tGF_Err e;\n\t\tBool skip_props = GF_FALSE;\n\n\t\tpcki->pid_props_change_done = 1;\n\n\t\t//it may happen that:\n\t\t//- the props are not set when querying the first packet (no prop queries on pid)\n\t\t//- the new props are already set if filter_pid_get_property was queried before the first packet dispatch\n\t\tif (pidinst->props) {\n\t\t\tif (pidinst->force_reconfig || (pidinst->props != pcki->pck->pid_props)) {\n\t\t\t\t//destroy if last occurence, removing it from pid as well\n\t\t\t\t//only remove if last about to be destroyed, since we may have several pid instances consuming from this pid\n\t\t\t\tassert(pidinst->props->reference_count);\n\t\t\t\tif (safe_int_dec(& pidinst->props->reference_count) == 0) {\n\t\t\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\t\t\tgf_props_del(pidinst->props);\n\t\t\t\t}\n\t\t\t\tpidinst->force_reconfig = GF_FALSE;\n\t\t\t\t//set new one\n\t\t\t\tpidinst->props = pcki->pck->pid_props;\n\t\t\t\tsafe_int_inc( & pidinst->props->reference_count );\n\t\t\t} else {\n\t\t\t\t//it may happen that pid_configure for destination was called after packet being dispatched, in\n\t\t\t\t//which case we are already properly configured\n\t\t\t\tskip_props = GF_TRUE;\n\t\t\t\tif (do_notif) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s was already configured with the last property set, ignoring reconfigure\\n\", pidinst->pid->filter->name, pidinst->pid->name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!skip_props) {\n\t\t\tif (do_notif) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s property changed at this packet, triggering reconfigure\\n\", pidinst->pid->filter->name, pidinst->pid->name));\n\n\t\t\t\tassert(pidinst->filter->freg->configure_pid);\n\t\t\t}\n\n\t\t\t//reset the blacklist whenever reconfiguring, since we may need to reload a new filter chain\n\t\t\t//in which a previously blacklisted filter (failing (re)configure for previous state) could\n\t\t\t//now work, eg moving from formatA to formatB then back to formatA\n\t\t\tgf_list_reset(pidinst->filter->blacklisted);\n\n\t\t\tif (do_notif) {\n\t\t\t\te = gf_filter_pid_configure(pidinst->filter, pidinst->pid, GF_PID_CONF_RECONFIG);\n\t\t\t\tif (e != GF_OK) return GF_TRUE;\n\t\t\t\tif (pidinst->pid->caps_negociate)\n\t\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_FilterPacket *gf_filter_pid_get_packet(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to fetch a packet on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (pidinst->discard_packets || (!pidinst->force_flush && pidinst->detach_pending)) {\n\t\tpidinst->filter->nb_pck_io++;\n\t\treturn NULL;\n\t}\n\nrestart:\n\tpcki = (GF_FilterPacketInstance *)gf_fq_head(pidinst->packets);\n\t//no packets\n\tif (!pcki) {\n\t\tif (!pidinst->pid || !pidinst->pid->filter || !pidinst->filter) return NULL;\n\t\tif (pidinst->pid->filter->disabled) {\n\t\t\tpidinst->is_end_of_stream = pidinst->pid->has_seen_eos = GF_TRUE;\n\t\t}\n\t\tif (!pidinst->is_end_of_stream && pidinst->pid->filter->would_block)\n\t\t\tgf_filter_pid_check_unblock(pidinst->pid);\n\t\tpidinst->filter->nb_pck_io++;\n\t\treturn NULL;\n\t}\n\tassert(pcki->pck);\n\n\tif (gf_filter_pid_filter_internal_packet(pidinst, pcki)) {\n\t\t//avoid recursion\n\t\tgoto restart;\n\t}\n\tpcki->pid->is_end_of_stream = GF_FALSE;\n\n\tif (filter_pck_check_prop_change(pidinst, pcki, GF_TRUE))\n\t\treturn NULL;\n\n\tif ( (pcki->pck->info.flags & GF_PCKF_INFO_CHANGED) && !pcki->pid_info_change_done) {\n\t\tBool res=GF_FALSE;\n\n\t\t//it may happen that this filter pid is pulled from another thread than ours (eg audio callback), in which case\n\t\t//we cannot go reentrant, we have to wait until the filter is not in use ...\n\t\tif (pidinst->filter->freg->process_event && pidinst->filter->process_th_id && (pidinst->filter->process_th_id != gf_th_id()) ) {\n\t\t\treturn NULL;\n\t\t}\n\t\tpcki->pid_info_change_done = 1;\n\n\t\tif (pidinst->filter->freg->process_event) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_INFO_UPDATE, pid);\n\n\t\t\t//the following may fail when some filters use threading on their own\n\t\t\t//FSESS_CHECK_THREAD(pidinst->filter)\n\t\t\tres = pidinst->filter->freg->process_event(pidinst->filter, &evt);\n\t\t}\n\t\t\n\t\tif (!res) {\n\t\t\tpidinst->filter->pid_info_changed = GF_TRUE;\n\t\t}\n\t}\n\tpidinst->last_pck_fetch_time = gf_sys_clock_high_res();\n\n\treturn (GF_FilterPacket *)pcki;\n}\n\nstatic GF_FilterPacketInstance *gf_filter_pid_probe_next_packet(GF_FilterPidInst *pidinst)\n{\n\tu32 i=0;\n\t//get first packet that is not an internal command\n\t//if packet is a clock, consume it\n\twhile (1) {\n\t\tGF_FilterPacketInstance *pcki = (GF_FilterPacketInstance *)gf_fq_get(pidinst->packets, i);\n\t\tif (!pcki) break;\n\t\ti++;\n\n\t\tu32 ctype = (pcki->pck->info.flags & GF_PCK_CMD_MASK);\n\t\tif (ctype == GF_PCK_CMD_PID_EOS ) {\n\t\t\tbreak;\n\t\t} else if (ctype == GF_PCK_CMD_PID_REM) {\n\t\t\tbreak;\n\t\t}\n\t\tctype = (pcki->pck->info.flags & GF_PCK_CKTYPE_MASK) >> GF_PCK_CKTYPE_POS;\n\n\t\tif (ctype) {\n\t\t\tif (pcki->pid->handles_clock_references) return NULL;\n\n\t\t\tgf_filter_pid_filter_internal_packet(pidinst, pcki);\n\t\t\treturn gf_filter_pid_probe_next_packet(pidinst);\n\t\t}\n\t\treturn pcki;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_filter_pid_get_first_packet_cts(GF_FilterPid *pid, u64 *cts)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pidinst->discard_packets) return GF_FALSE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_FALSE;\n\t}\n\tassert(pcki->pck);\n\tif (pidinst->requires_full_data_block && !(pcki->pck->info.flags & GF_PCKF_BLOCK_END))\n\t\treturn GF_FALSE;\n\n\tGF_PropertyMap *map = gf_list_get(pidinst->pid->properties, 0);\n\tif (map)\n\t\t*cts = gf_timestamp_rescale(pcki->pck->info.cts, pcki->pck->pid_props->timescale, map->timescale);\n\telse\n\t\t*cts = pcki->pck->info.cts;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_first_packet_is_empty(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_TRUE;\n\t}\n\tif (pidinst->discard_packets) return GF_TRUE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_TRUE;\n\t}\n\tassert(pcki->pck);\n\n\tif (pidinst->requires_full_data_block && !(pcki->pck->info.flags & GF_PCKF_BLOCK_END))\n\t\treturn GF_TRUE;\n\treturn (pcki->pck->data_length || pcki->pck->frame_ifce) ? GF_FALSE : GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_first_packet_is_blocking_ref(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to read packet CTS on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pidinst->discard_packets) return GF_FALSE;\n\n\tpcki = gf_filter_pid_probe_next_packet(pidinst);\n\t//no packets\n\tif (!pcki) {\n\t\treturn GF_FALSE;\n\t}\n\tassert(pcki->pck);\n\treturn gf_filter_pck_is_blocking_ref(pcki->pck);\n}\n\n\nstatic void gf_filter_pidinst_update_stats(GF_FilterPidInst *pidi, GF_FilterPacket *pck)\n{\n\tu64 now = gf_sys_clock_high_res();\n\tu64 dec_time = now - pidi->last_pck_fetch_time;\n\tif (pck->info.flags & GF_PCK_CMD_MASK) return;\n\tif (!pidi->filter || pidi->pid->filter->removed) return;\n\n\tpidi->filter->nb_pck_processed++;\n\tpidi->filter->nb_bytes_processed += pck->data_length;\n\n\tpidi->total_process_time += dec_time;\n\tif (!pidi->nb_processed) {\n\t\tpidi->first_frame_time = pidi->last_pck_fetch_time;\n\t}\n\n\tpidi->nb_processed++;\n\tif (pck->info.flags & GF_PCK_SAP_MASK) {\n\t\tpidi->nb_sap_processed ++;\n\t\tif (dec_time > pidi->max_sap_process_time) pidi->max_sap_process_time = dec_time;\n\t\tpidi->total_sap_process_time += dec_time;\n\t}\n\n\tif (dec_time > pidi->max_process_time) pidi->max_process_time = dec_time;\n\n\tif (pck->data_length) {\n\t\tBool has_ts = GF_TRUE;\n\t\tu64 ts = (pck->info.dts != GF_FILTER_NO_TS) ? pck->info.dts : pck->info.cts;\n\t\tif ((ts != GF_FILTER_NO_TS) && pck->pid_props && pck->pid_props->timescale) {\n\t\t\tts = gf_timestamp_rescale(ts, pck->pid_props->timescale, 1000000);\n\t\t} else {\n\t\t\thas_ts = GF_FALSE;\n\t\t}\n\t\t\n\t\tif (!pidi->cur_bit_size) {\n\t\t\tpidi->stats_start_ts = ts;\n\t\t\tpidi->stats_start_us = now;\n\t\t\tpidi->cur_bit_size = 8*pck->data_length;\n\t\t} else {\n\t\t\tBool flush_stats = GF_FALSE;\n\t\t\tpidi->cur_bit_size += 8*pck->data_length;\n\n\t\t\tif (has_ts) {\n\t\t\t\tif (pidi->stats_start_ts + 1000000 <= ts) flush_stats = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (pidi->stats_start_us + 1000000 <= now) flush_stats = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (flush_stats) {\n\t\t\t\tu64 rate;\n\t\t\t\tu64 diff_t;\n\n\t\t\t\tif (has_ts) {\n\t\t\t\t\trate = pidi->cur_bit_size;\n\t\t\t\t\trate *= 1000000;\n\t\t\t\t\tdiff_t = ts - pidi->stats_start_ts;\n\t\t\t\t\tif (!diff_t) diff_t = 1;\n \t\t\t\t\trate /= diff_t;\n\t\t\t\t\tpidi->avg_bit_rate = (u32) rate;\n\t\t\t\t\tif (pidi->avg_bit_rate > pidi->max_bit_rate) pidi->max_bit_rate = pidi->avg_bit_rate;\n\t\t\t\t}\n\n\t\t\t\trate = pidi->cur_bit_size;\n\t\t\t\trate *= 1000000;\n\t\t\t\tdiff_t = now - pidi->stats_start_us;\n\t\t\t\tif (!diff_t) diff_t = 1;\n\t\t\t\trate /= diff_t;\n\t\t\t\tpidi->avg_process_rate = (u32) rate;\n\t\t\t\tif (pidi->avg_process_rate > pidi->max_process_rate) pidi->max_process_rate = pidi->avg_process_rate;\n\n\t\t\t\t//reset stats\n\t\t\t\tpidi->cur_bit_size = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void gf_filter_pidinst_reset_stats(GF_FilterPidInst *pidi)\n{\n\tpidi->last_pck_fetch_time = 0;\n\tpidi->stats_start_ts = 0;\n\tpidi->stats_start_us = 0;\n\tpidi->cur_bit_size = 0;\n\tpidi->avg_bit_rate = 0;\n\tpidi->max_bit_rate = 0;\n\tpidi->avg_process_rate = 0;\n\tpidi->max_process_rate = 0;\n\tpidi->nb_processed = 0;\n\tpidi->nb_sap_processed = 0;\n\tpidi->total_process_time = 0;\n\tpidi->total_sap_process_time = 0;\n\tpidi->max_process_time = 0;\n\tpidi->max_sap_process_time = 0;\n\tpidi->first_frame_time = 0;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_drop_packet(GF_FilterPid *pid)\n{\n#ifdef GPAC_MEMORY_TRACKING\n\tu32 prev_nb_allocs, prev_nb_reallocs, nb_allocs, nb_reallocs;\n#endif\n\tu32 timescale = 0;\n\tu32 nb_pck=0;\n\tGF_FilterPacket *pck=NULL;\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to discard a packet on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn;\n\t}\n\tif (pidinst->filter)\n\t\tpidinst->filter->nb_pck_io++;\n\n\t//remove pck instance\n\tpcki = gf_fq_pop(pidinst->packets);\n\n\tif (!pcki) {\n\t\tif (pidinst->filter && !pidinst->filter->finalized && !pidinst->discard_packets) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to discard a packet already discarded in filter %s\\n\", pid->filter->name));\n\t\t}\n\t\treturn;\n\t}\n\n\tgf_rmt_begin(pck_drop, GF_RMT_AGGREGATE);\n\tpck = pcki->pck;\n\t//move to source pid\n\tpid = pid->pid;\n\tif (pck->pid_props)\n\t\ttimescale = pck->pid_props->timescale;\n\n\t//if not detached, undo main_thread flag - cf gf_filter_instance_detach_pid\n\tif (pidinst->filter && (pck->info.flags & GF_PCKF_FORCE_MAIN)) {\n\t\tassert(pidinst->filter->nb_main_thread_forced);\n\t\tsafe_int_dec(&pidinst->filter->nb_main_thread_forced);\n\t}\n\n\tgf_filter_pidinst_update_stats(pidinst, pck);\n\tif (timescale && (pck->info.cts!=GF_FILTER_NO_TS)) {\n\t\tpidinst->last_ts_drop.num = pck->info.cts;\n\t\tpidinst->last_ts_drop.den = timescale;\n\t}\n\n\n\t//make sure we lock the tasks mutex before getting the packet count, otherwise we might end up with a wrong number of packets\n\t//if one thread (the caller here) consumes one packet while the dispatching thread is still upddating the state for that pid\n\tgf_mx_p(pid->filter->tasks_mx);\n\tnb_pck = gf_fq_count(pidinst->packets);\n\n\tif (!nb_pck) {\n\t\tsafe_int64_sub(&pidinst->buffer_duration, pidinst->buffer_duration);\n\t} else if (pck->info.duration && (pck->info.flags & GF_PCKF_BLOCK_START) && timescale) {\n\t\ts64 d = gf_timestamp_rescale(pck->info.duration, timescale, 1000000);\n\t\tif (d > pidinst->buffer_duration) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Corrupted buffer level in PID instance %s (%s -> %s), dropping packet duration \"LLD\" us greater than buffer duration \"LLU\" us\\n\", pid->name, pid->filter->name, pidinst->filter ? pidinst->filter->name : \"disconnected\", d, pidinst->buffer_duration));\n\t\t\td = pidinst->buffer_duration;\n\t\t}\n\t\tassert(d <= pidinst->buffer_duration);\n\t\tsafe_int64_sub(&pidinst->buffer_duration, (s32) d);\n\t}\n\n\tif ( (pid->num_destinations==1) || (pid->filter->session->blocking_mode==GF_FS_NOBLOCK_FANOUT)) {\n\t\tif (nb_pck<pid->nb_buffer_unit) {\n\t\t\tpid->nb_buffer_unit = nb_pck;\n\t\t}\n\t\tif (!pid->buffer_duration || (pidinst->buffer_duration < (s64) pid->buffer_duration)) {\n\t\t\tpid->buffer_duration = pidinst->buffer_duration;\n\t\t}\n\t}\n\t//handle fan-out: we must browse all other pid instances and compute max buffer/nb_pck per pids\n\t//so that we don't unblock the PID if some instance is still blocking\n\telse {\n\t\tu32 i;\n\t\tu32 min_pck = nb_pck;\n\t\ts64 min_dur = pidinst->buffer_duration;\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(pid->destinations, i);\n\t\t\tif (a_pidi==pidinst) continue;\n\t\t\tif (a_pidi->buffer_duration > min_dur)\n\t\t\t\tmin_dur = a_pidi->buffer_duration;\n\t\t\tnb_pck = gf_fq_count(a_pidi->packets);\n\t\t\tif (nb_pck>min_pck)\n\t\t\t\tmin_pck = nb_pck;\n\t\t}\n\t\tpid->buffer_duration = min_dur;\n\t\tpid->nb_buffer_unit = min_pck;\n\t}\n\tgf_filter_pid_check_unblock(pid);\n\n\tgf_mx_v(pid->filter->tasks_mx);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {\n\t\tu8 sap_type = (pck->info.flags & GF_PCK_SAP_MASK) >> GF_PCK_SAP_POS;\n\t\tBool seek_flag = (pck->info.flags & GF_PCKF_SEEK) ? 1 : 0;\n\n\t\tif ((pck->info.dts != GF_FILTER_NO_TS) && (pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.dts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t}\n\t}\n#endif\n\n\t//destroy pcki\n\tpcki->pck = NULL;\n\tpcki->pid = NULL;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&prev_nb_allocs, NULL, &prev_nb_reallocs, NULL);\n\t}\n#endif\n\n\tif (pid->filter->pcks_inst_reservoir) {\n\t\tgf_fq_add(pid->filter->pcks_inst_reservoir, pcki);\n\t} else {\n\t\tgf_free(pcki);\n\t}\n\t//unref pck\n\tassert(pck->reference_count);\n\tif (safe_int_dec(&pck->reference_count) == 0) {\n\t\tgf_filter_packet_destroy(pck);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&nb_allocs, NULL, &nb_reallocs, NULL);\n\n\t\tpid->filter->session->nb_alloc_pck += (nb_allocs - prev_nb_allocs);\n\t\tpid->filter->session->nb_realloc_pck += (nb_reallocs - prev_nb_reallocs);\n\t}\n#endif\n\n\t//decrement number of pending packet on target filter if this is not a destroy\n\tif (pidinst->filter) {\n\t\tassert(pidinst->filter->pending_packets);\n\t\tsafe_int_dec(&pidinst->filter->pending_packets);\n\n\t\tgf_filter_forward_clock(pidinst->filter);\n\t}\n\n\tgf_rmt_end();\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_eos(GF_FilterPid *pid)\n{\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\n\tif (pidi->detach_pending)\n\t\treturn GF_FALSE;\n\t\t\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (!pid->pid) return GF_TRUE;\n\tif (!pid->pid->has_seen_eos && !pidi->discard_inputs && !pidi->discard_packets) {\n\t\tpidi->is_end_of_stream = GF_FALSE;\n\t\treturn GF_FALSE;\n\t}\n\t//peek next for eos\n\tpcki = (GF_FilterPacketInstance *)gf_fq_head(pidi->packets);\n\tif (pcki)\n\t\tgf_filter_pid_filter_internal_packet(pidi, pcki);\n\n\tif (pidi->discard_packets && !pid->pid->filter->session->in_final_flush) return GF_FALSE;\n\tif (!pidi->is_end_of_stream) return GF_FALSE;\n\tif (!pidi->filter->eos_probe_state)\n\t\tpidi->filter->eos_probe_state = 1;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_eos(GF_FilterPid *pid)\n{\n\tGF_FilterPacket *pck;\n\t//allow NULL as input (most filters blindly call set_eos on output even if no output)\n\tif (!pid) return;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to signal EOS on input PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tif (pid->has_seen_eos) return;\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"EOS signaled on PID %s in filter %s\\n\", pid->name, pid->filter->name));\n\t//we create a fake packet for eos signaling\n\tpck = gf_filter_pck_new_shared_internal(pid, NULL, 0, NULL, GF_TRUE);\n\tif (!pck) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to allocate new packet for EOS on PID %s in filter %s\\n\", pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tpck->pck->info.flags |= GF_PCK_CMD_PID_EOS;\n\tgf_filter_pck_send(pck);\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_enum_properties(GF_FilterPid *pid, u32 *idx, u32 *prop_4cc, const char **prop_name)\n{\n\tGF_PropertyMap *props;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tprops = pidi->props;\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t} else {\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tprops = gf_list_last(pid->properties);\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n\tif (!props) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"No properties for pid in filter %s, ignoring enum\\n\", pid->filter->name));\n\t\t*idx = 0xFFFFFFFF;\n\t\treturn NULL;\n\t}\n\treturn gf_props_enum_property(props, idx, prop_4cc, prop_name);\n}\n\nGF_EXPORT\nBool gf_filter_pid_would_block(GF_FilterPid *pid)\n{\n\tBool would_block=GF_FALSE;\n\tBool result=GF_FALSE;\n#ifdef DEBUG_BLOCKMODE\n\tBool blockmode_broken=GF_FALSE;\n#endif\n\tif (PID_IS_INPUT(pid)) {\n\t\tpid = pid->pid;\n\t\tif (pid->would_block) return GF_TRUE;\n\t\treturn GF_FALSE;\n\t}\n\n\tif (pid->filter->session->blocking_mode==GF_FS_NOBLOCK)\n\t\treturn GF_FALSE;\n\t//input pid(s) are being flushed, prevent blocking\n\tif (pid->filter->in_force_flush)\n\t\treturn GF_FALSE;\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\t//either block according to the number of dispatched units (decoder output) or to the requested buffer duration\n\tif (pid->max_buffer_unit) {\n\t\tif (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER >= pid->max_buffer_unit * pid->playback_speed_scaler) {\n\t\t\twould_block = GF_TRUE;\n\t\t}\n#ifdef DEBUG_BLOCKMODE\n\t\tif ((pid->num_destinations==1) && !pid->filter->blockmode_broken && ( (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER > 100 * pid->max_buffer_unit * pid->playback_speed_scaler) ) ) {\n\t\t\tblockmode_broken = GF_TRUE;\n\t\t}\n#endif\n\t} else if (pid->max_buffer_time) {\n\t\tif (pid->buffer_duration * GF_FILTER_SPEED_SCALER > pid->max_buffer_time * pid->playback_speed_scaler) {\n\t\t\twould_block = GF_TRUE;\n\t\t}\n#ifdef DEBUG_BLOCKMODE\n\t\tif ((pid->num_destinations==1) && !pid->filter->blockmode_broken && (pid->buffer_duration * GF_FILTER_SPEED_SCALER > 100 * pid->max_buffer_time * pid->playback_speed_scaler) ) {\n\t\t\tblockmode_broken = GF_TRUE;\n\t\t}\n#endif\n\t}\n\n#ifdef DEBUG_BLOCKMODE\n\tif (blockmode_broken) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Filter %s PID %s block mode not respected: %u units \"LLU\" us vs %u max units \"LLU\" max buffer\\n\", pid->pid->filter->name, pid->pid->name, pid->nb_buffer_unit, pid->buffer_duration, pid->max_buffer_unit, pid->max_buffer_time));\n\n\t\tpid->filter->blockmode_broken = GF_TRUE;\n\t}\n#endif\n\n\tresult = would_block;\n\t//if PID is sparse and filter has more than one active output:\n\t//- force the pid to move to blocking state\n\t//- return the true status so that filters checking gf_filter_pid_would_block will dispatch frame if any\n\t//\n\t//This avoids considering a demux filter (with e.g., AV+text) as non-blocking when all its non-sparse PIDs are blocked\n\tif (!pid->would_block && pid->is_sparse && !pid->not_connected\n\t\t&& (pid->filter->num_output_pids > 1+pid->filter->num_out_pids_not_connected)\n\t\t//don't do this if only sparse pids are connected\n\t\t&& (pid->filter->nb_sparse_pids + pid->filter->num_out_pids_not_connected < pid->filter->num_output_pids)\n\t)\n\t\twould_block = GF_TRUE;\n\n\tif (would_block && !pid->would_block) {\n\t\tsafe_int_inc(&pid->would_block);\n\t\tsafe_int_inc(&pid->filter->would_block);\n\t\tassert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {\n\t\t\tif (pid->max_buffer_unit) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s blocked (%d units vs %d max units) - %d filter PIDs blocked\\n\", pid->pid->filter->name, pid->pid->name, pid->nb_buffer_unit, pid->max_buffer_unit, pid->filter->would_block));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s blocked (\"LLU\" us vs \"LLU\" max buffer) - %d filter PIDs blocked\\n\", pid->pid->filter->name, pid->pid->name, pid->buffer_duration, pid->max_buffer_time, pid->filter->would_block));\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tassert(pid->filter->would_block <= pid->filter->num_output_pids);\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn result;\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_sparse(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FALSE;\n\treturn pid->pid->is_sparse;\n}\n\nstatic u64 gf_filter_pid_query_buffer_duration_internal(GF_FilterPid *pid, Bool check_pid_full, Bool force_update)\n{\n\tu32 count, i, j;\n\tu64 duration=0;\n\tif (!pid || pid->filter->session->in_final_flush)\n\t\treturn GF_FILTER_NO_TS;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_Filter *filter;\n\t\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\t\tif (!pidinst->pid) return 0;\n\t\tfilter = pidinst->pid->filter;\n\t\tif (check_pid_full) {\n\t\t\tu32 buffer_full = GF_FALSE;\n\t\t\tBool buffer_valid = GF_FALSE;\n\n\t\t\tif (pidinst->pid->max_buffer_unit) {\n\t\t\t\tbuffer_valid = GF_TRUE;\n\t\t\t\tif (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)\n\t\t\t\t\tbuffer_full = GF_TRUE;\n\t\t\t}\n\t\t\tif (pidinst->pid->max_buffer_time) {\n\t\t\t\tbuffer_valid = GF_TRUE;\n\t\t\t\tif (pidinst->pid->max_buffer_time<=pidinst->pid->buffer_duration)\n\t\t\t\t\tbuffer_full = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (buffer_valid) {\n\t\t\t\tif (!buffer_full) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)\n\t\t\t\t\treturn GF_FILTER_NO_TS;\n\t\t\t}\n\t\t}\n\n\t\t//this is a very costly recursive call until each source, and is likely to be an overkill\n\t\t//if many PIDs (large tiling configurations for example)\n\t\t//we cache the last computed value and only update every 10 ms\n\t\tif (!force_update && (pidinst->filter->last_schedule_task_time - pidinst->last_buf_query_clock < 10000)) {\n\t\t\treturn pidinst->last_buf_query_dur;\n\t\t}\n\t\tpidinst->last_buf_query_clock = pidinst->filter->last_schedule_task_time;\n\t\tforce_update = GF_TRUE;\n\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tcount = filter->num_input_pids;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 dur = gf_filter_pid_query_buffer_duration_internal( gf_list_get(filter->input_pids, i), GF_FALSE, force_update);\n\t\t\tif (dur > duration)\n\t\t\t\tduration = dur;\n\n\t\t\t//only probe for first pid when this is a mux or a reassembly filter\n\t\t\t//this is not as precise but avoids spending too much time here for very large number of input pids (tiling)\n\t\t\tif ((count>1) && (filter->num_output_pids==1))\n\t\t\t\tbreak;\n\t\t}\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tduration += pidinst->buffer_duration;\n\t\tpidinst->last_buf_query_dur = duration;\n\t\treturn duration;\n\t} else {\n\t\tu32 count2;\n\t\tu64 max_dur=0;\n\n\t\tif (check_pid_full) {\n\t\t\tif (pid->max_buffer_unit && (pid->max_buffer_unit>pid->nb_buffer_unit))\n\t\t\t\treturn 0;\n\t\t\tif (pid->max_buffer_time && (pid->max_buffer_time>pid->buffer_duration))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcount = pid->num_destinations;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPidInst *pidinst = gf_list_get(pid->destinations, i);\n\n\t\t\tcount2 = pidinst->filter->num_output_pids;\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_FilterPid *pid_n = gf_list_get(pidinst->filter->output_pids, i);\n\t\t\t\tu64 dur = gf_filter_pid_query_buffer_duration_internal(pid_n, GF_FALSE, GF_FALSE);\n\t\t\t\tif (dur > max_dur ) max_dur = dur;\n\t\t\t}\n\t\t}\n\t\tduration += max_dur;\n\t}\n\treturn duration;\n}\n\nGF_EXPORT\nu64 gf_filter_pid_query_buffer_duration(GF_FilterPid *pid, Bool check_pid_full)\n{\n\treturn gf_filter_pid_query_buffer_duration_internal(pid, check_pid_full, GF_FALSE);\n\n}\nGF_EXPORT\nBool gf_filter_pid_has_seen_eos(GF_FilterPid *pid)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->has_seen_eos) return GF_TRUE;\n\tif (pid->pid->filter->block_eos) return GF_FALSE;\n\tgf_mx_p(pid->pid->filter->tasks_mx);\n\tfor (i=0; i<pid->pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->filter->input_pids, i);\n\t\tif (gf_filter_pid_has_seen_eos((GF_FilterPid *) pidi)) {\n\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(pid->pid->filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_filter_pid_eos_received(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->has_seen_eos) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\nGF_EXPORT\nconst char *gf_filter_event_name(GF_FEventType type)\n{\n\tswitch (type) {\n\tcase GF_FEVT_PLAY: return \"PLAY\";\n\tcase GF_FEVT_SET_SPEED: return \"SET_SPEED\";\n\tcase GF_FEVT_STOP: return \"STOP\";\n\tcase GF_FEVT_SOURCE_SEEK: return \"SOURCE_SEEK\";\n\tcase GF_FEVT_SOURCE_SWITCH: return \"SOURCE_SWITCH\";\n\tcase GF_FEVT_ATTACH_SCENE: return \"ATTACH_SCENE\";\n\tcase GF_FEVT_RESET_SCENE: return \"RESET_SCENE\";\n\tcase GF_FEVT_PAUSE: return \"PAUSE\";\n\tcase GF_FEVT_RESUME: return \"RESUME\";\n\tcase GF_FEVT_QUALITY_SWITCH: return \"QUALITY_SWITCH\";\n\tcase GF_FEVT_VISIBILITY_HINT: return \"VISIBILITY_HINT\";\n\tcase GF_FEVT_INFO_UPDATE: return \"INFO_UPDATE\";\n\tcase GF_FEVT_BUFFER_REQ: return \"BUFFER_REQ\";\n\tcase GF_FEVT_USER: return \"USER\";\n\tcase GF_FEVT_SEGMENT_SIZE: return \"SEGMENT_SIZE\";\n\tcase GF_FEVT_FRAGMENT_SIZE: return \"FRAGMENT_SIZE\";\n\tcase GF_FEVT_CAPS_CHANGE: return \"CAPS_CHANGED\";\n\tcase GF_FEVT_CONNECT_FAIL: return \"CONNECT_FAIL\";\n\tcase GF_FEVT_FILE_DELETE: return \"FILE_DELETE\";\n\tcase GF_FEVT_PLAY_HINT: return \"PLAY_HINT\";\n\tcase GF_FEVT_ENCODE_HINTS: return \"ENCODE_HINTS\";\n\tcase GF_FEVT_NTP_REF: return \"NTP_REF\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic void gf_filter_pid_reset_task_ex(GF_FSTask *task, Bool *had_eos)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)task->udta;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s input PID %s (from %s) resetting buffer\\n\", task->filter->name, pidi->pid->name, pidi->pid->filter->name ));\n\n\tif (had_eos) *had_eos = GF_FALSE;\n\n\t//aggregate any pending packet\n\tgf_filter_aggregate_packets(pidi);\n\n\t//trash packets without checking for internal commands except EOS any pending packet\n\twhile (gf_fq_count(pidi->packets)) {\n\t\tGF_FilterPacketInstance *pcki = gf_fq_head(pidi->packets);\n\t\tif ( (pcki->pck->info.flags & GF_PCK_CMD_MASK) == GF_PCK_CMD_PID_EOS) {\n\t\t\tif (had_eos)\n\t\t\t\t*had_eos = GF_TRUE;\n\t\t}\n\t\t//check props change otherwise we could accumulate pid properties no longer valid\n\t\tfilter_pck_check_prop_change(pidi, pcki, GF_FALSE);\n\n\t\tgf_filter_pid_drop_packet((GF_FilterPid *) pidi);\n\t}\n\n\tgf_filter_pidinst_reset_stats(pidi);\n\n\tassert(pidi->discard_packets);\n\tsafe_int_dec(&pidi->discard_packets);\n\n\tpidi->last_block_ended = GF_TRUE;\n\tpidi->first_block_started = GF_FALSE;\n\tpidi->is_end_of_stream = GF_FALSE;\n\tpidi->buffer_duration = 0;\n\tpidi->nb_eos_signaled = 0;\n\tpidi->pid->has_seen_eos = GF_FALSE;\n\tpidi->last_clock_type = 0;\n\n\tassert(pidi->pid->filter->stream_reset_pending);\n\tsafe_int_dec(& pidi->pid->filter->stream_reset_pending );\n\n\tpidi->pid->nb_buffer_unit = 0;\n\tpidi->pid->buffer_duration = 0;\n\tgf_filter_pid_check_unblock(pidi->pid);\n}\n\nstatic void gf_filter_pid_reset_task(GF_FSTask *task)\n{\n\tgf_filter_pid_reset_task_ex(task, NULL);\n}\n\nstatic void gf_filter_pid_reset_stop_task(GF_FSTask *task)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)task->udta;\n\tBool has_eos;\n\tgf_filter_pid_reset_task_ex(task, &has_eos);\n\tpidi->is_end_of_stream = has_eos;\n\tpidi->pid->has_seen_eos = has_eos;\n}\n\ntypedef struct\n{\n\tu32 ref_count;\n\tchar string[1];\n} GF_RefString;\n\n#define TO_REFSTRING(_v) _v ? (GF_RefString *) (_v - offsetof(GF_RefString, string)) : NULL\n\nstatic GF_RefString *evt_get_refstr(GF_FilterEvent *evt)\n{\n\tif (evt->base.type == GF_FEVT_FILE_DELETE) {\n\t\treturn TO_REFSTRING(evt->file_del.url);\n\t}\n\tif (evt->base.type == GF_FEVT_SOURCE_SWITCH) {\n\t\treturn TO_REFSTRING(evt->seek.source_switch);\n\t}\n\tif (evt->base.type == GF_FEVT_SEGMENT_SIZE) {\n\t\treturn TO_REFSTRING(evt->seg_size.seg_url);\n\t}\n\treturn NULL;\n}\nstatic GF_FilterEvent *dup_evt(GF_FilterEvent *evt)\n{\n\tGF_FilterEvent *an_evt;\n\tGF_RefString *rstr = evt_get_refstr(evt);\n\tan_evt = gf_malloc(sizeof(GF_FilterEvent));\n\tmemcpy(an_evt, evt, sizeof(GF_FilterEvent));\n\tif (rstr) {\n\t\tsafe_int_inc(&rstr->ref_count);\n\t}\n\treturn an_evt;\n}\n\nstatic void free_evt(GF_FilterEvent *evt)\n{\n\tGF_RefString *rstr = evt_get_refstr(evt);\n\tif (rstr) {\n\t\tassert(rstr->ref_count);\n\t\tif (safe_int_dec(&rstr->ref_count) == 0) {\n\t\t\tgf_free(rstr);\n\t\t}\n\t}\n\tgf_free(evt);\n}\n\nstatic GF_FilterEvent *init_evt(GF_FilterEvent *evt)\n{\n\tchar **url_addr_src = NULL;\n\tchar **url_addr_dst = NULL;\n\tGF_FilterEvent *an_evt = gf_malloc(sizeof(GF_FilterEvent));\n\tmemcpy(an_evt, evt, sizeof(GF_FilterEvent));\n\n\tif (evt->base.type==GF_FEVT_FILE_DELETE) {\n\t\turl_addr_src = (char **) &evt->file_del.url;\n\t\turl_addr_dst = (char **) &an_evt->file_del.url;\n\t} else if (evt->base.type==GF_FEVT_SOURCE_SWITCH) {\n\t\turl_addr_src = (char **) &evt->seek.source_switch;\n\t\turl_addr_dst = (char **) &an_evt->seek.source_switch;\n\t} else if (evt->base.type==GF_FEVT_SEGMENT_SIZE) {\n\t\turl_addr_src = (char **) &evt->seg_size.seg_url;\n\t\turl_addr_dst = (char **) &an_evt->seg_size.seg_url;\n\t}\n\tif (url_addr_src) {\n\t\tchar *url = *url_addr_src;\n\t\tif (!url) {\n\t\t\t*url_addr_dst = NULL;\n\t\t} else {\n\t\t\tu32 len = (u32) strlen(url);\n\t\t\tGF_RefString *rstr = gf_malloc(sizeof(GF_RefString) + sizeof(char)*len);\n\t\t\trstr->ref_count=1;\n\t\t\tstrcpy( (char *) &rstr->string[0], url);\n\t\t\t*url_addr_dst = (char *) &rstr->string[0];\n\t\t}\n\t}\n\treturn an_evt;\n}\n\n\nstatic Bool filter_pid_is_raw_source(GF_FilterPid *pid)\n{\n\tu32 i;\n\tBool res = GF_TRUE;\n\tif (!pid->raw_media) {\n\t\tif (pid->stream_type!=GF_STREAM_FILE)\n\t\t\treturn GF_FALSE;\n\t}\n\n\tgf_mx_p(pid->filter->tasks_mx);\n\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (pidi->pid->nb_decoder_inputs) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tif (! filter_pid_is_raw_source(pidi->pid)) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn res;\n}\n\nvoid gf_filter_pid_send_event_downstream(GF_FSTask *task)\n{\n\tu32 i, count, nb_playing=0, nb_paused=0;\n\tBool canceled = GF_FALSE;\n\tBool forced_cancel = GF_FALSE;\n\tGF_FilterEvent *evt = task->udta;\n\tGF_Filter *f = task->filter;\n\tGF_List *dispatched_filters = NULL;\n\tGF_FilterPidInst *for_pidi = (GF_FilterPidInst *)task->pid;\n\n\tif (for_pidi && (for_pidi->pid == task->pid)) {\n\t\tfor_pidi = NULL;\n\t}\n\n\t//if stream reset task is posted, wait for it before processing this event\n\tif (f->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\t//if some pids are still detached, wait for the connection before processing this event\n\tif (f->detached_pid_inst) {\n\t\tTASK_REQUEUE(task)\n\t\ttask->can_swap = 1;\n\t\treturn;\n\t}\n\n\tif (evt->base.on_pid) {\n\t\tassert(evt->base.on_pid->filter->num_events_queued);\n\t\tsafe_int_dec(&evt->base.on_pid->filter->num_events_queued);\n\t}\n\tif (f->finalized) {\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\n\tif (for_pidi) {\n\t\t//update pid instance status\n\t\tswitch (evt->base.type) {\n\t\tcase GF_FEVT_PLAY:\n\t\tcase GF_FEVT_SOURCE_SEEK:\n\t\t\tfor_pidi->is_playing = GF_TRUE;\n\t\t\tfor_pidi->play_queued = 0;\n\t\t\tbreak;\n\t\tcase GF_FEVT_STOP:\n\t\t\tfor_pidi->is_playing = GF_FALSE;\n\t\t\tfor_pidi->stop_queued = 0;\n\t\t\tbreak;\n\t\tcase GF_FEVT_PAUSE:\n\t\t\tfor_pidi->is_paused = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_FEVT_RESUME:\n\t\t\tfor_pidi->is_paused = GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (evt->base.on_pid) {\n\t\tGF_FilterPid *pid = (GF_FilterPid *) evt->base.on_pid->pid;\n\t\t//we have destination for this pid but this is an event not targeting a dedicated pid instance, this\n\t\t//means this was a connect fail, do not process event as other parts of the graphs are using this filter\n\t\tif (pid->num_destinations && !for_pidi\n\t\t\t&& ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_STOP) || (evt->base.type==GF_FEVT_CONNECT_FAIL))\n\t\t) {\n\t\t\t//we incremented discard counter in gf_filter_pid_send_event_internal for stop, decrement\n\t\t\t//this typically happen when pid has 2 destinations, one OK and the other one failed to configure\n\t\t\tif (evt->base.type==GF_FEVT_STOP) {\n\t\t\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\t\t\tfor_pidi = gf_list_get(pid->destinations, i);\n\t\t\t\t\tif (for_pidi->discard_packets)\n\t\t\t\t\t\tsafe_int_dec(&for_pidi->discard_packets);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_evt(evt);\n\t\t\treturn;\n\t\t}\n\t\t//update number of playing/paused pids\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tif (pidi->is_playing) nb_playing++;\n\t\t\tif (pidi->is_paused) nb_paused++;\n\t\t}\n\t}\n\n\tif (evt->base.type == GF_FEVT_BUFFER_REQ) {\n\t\tif (!evt->base.on_pid) {\n\t\t\tfree_evt(evt);\n\t\t\treturn;\n\t\t}\n\t\t//, set buffering at this level if:\n\t\tif (\n\t\t\t//- pid is a decoder input\n\t\t\tevt->base.on_pid->nb_decoder_inputs\n\t\t\t//- buffer req event explicitly requested for this pid\n\t\t\t|| evt->buffer_req.pid_only\n\t\t\t//- pid is a raw media source\n\t\t\t|| filter_pid_is_raw_source(evt->base.on_pid)\n\t\t) {\n\t\t\tevt->base.on_pid->max_buffer_time = evt->base.on_pid->user_max_buffer_time = evt->buffer_req.max_buffer_us;\n\t\t\tevt->base.on_pid->user_max_playout_time = evt->buffer_req.max_playout_us;\n\t\t\tevt->base.on_pid->user_min_playout_time = evt->buffer_req.min_playout_us;\n\t\t\tevt->base.on_pid->max_buffer_unit = 0;\n\t\t\tevt->base.on_pid->user_buffer_forced = evt->buffer_req.pid_only;\n\t\t\t//update blocking state\n\t\t\tif (evt->base.on_pid->would_block)\n\t\t\t\tgf_filter_pid_check_unblock(evt->base.on_pid);\n\t\t\telse\n\t\t\t\tgf_filter_pid_would_block(evt->base.on_pid);\n\t\t\tcanceled = GF_TRUE;\n\t\t} else {\n\t\t\tevt->base.on_pid->user_buffer_forced = GF_FALSE;\n\t\t}\n\t} else if (evt->base.on_pid && (evt->base.type == GF_FEVT_PLAY)\n\t\t&& (evt->base.on_pid->pid->is_playing || (((GF_FilterPid *) evt->base.on_pid->pid)->not_connected==2))\n\t\t) {\n\t\tif (evt->base.on_pid->pid->is_playing) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is already playing, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t}\n\t\tfree_evt(evt);\n\t\treturn;\n\t} else if (evt->base.on_pid && (evt->base.type == GF_FEVT_STOP)\n\t\t&& (\n\t\t\t//stop request on pid already stop\n\t\t\t!evt->base.on_pid->pid->is_playing\n\t\t\t//fan out but some instances are still playing\n\t\t\t|| nb_playing\n\t\t)\n\t) {\n\t\tGF_FilterPid *pid = (GF_FilterPid *) evt->base.on_pid->pid;\n\n\t\tif (!evt->base.on_pid->pid->is_playing) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is not playing, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID has playing destinations, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\t}\n\n\t\tgf_mx_p(f->tasks_mx);\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) gf_list_get(pid->destinations, i);\n\t\t\t//don't forget we pre-processed stop by incrementing the discard counter and setting discard_packets on pid instances\n\t\t\t//undo this\n\t\t\tif (pidi->discard_packets) {\n\t\t\t\tsafe_int_dec(&pidi->discard_packets);\n\t\t\t}\n\t\t}\n\t\tif (!evt->base.on_pid->pid->is_playing) {\n\t\t\tif ((f->num_input_pids==f->num_output_pids) && (f->num_input_pids==1)) {\n\t\t\t\tgf_filter_pid_set_discard(gf_list_get(f->input_pids, 0), GF_TRUE);\n\t\t\t}\n\t\t\tif (pid->not_connected)\n\t\t\t\tpid->not_connected = 2;\n\t\t}\n\t\tgf_mx_v(f->tasks_mx);\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//do not allow pause if already paused\n\telse if ((nb_paused>1) && (evt->base.type == GF_FEVT_PAUSE) ) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but PID is already paused, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//do not allow resume if some instances are still paused\n\telse if (nb_paused && (evt->base.type == GF_FEVT_RESUME) ) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s event %s but some PID instances are still paused, discarding\\n\", f->name, evt->base.on_pid->name, gf_filter_event_name(evt->base.type)));\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//cancel connect failure if some destinations are successfully connected\n\telse if ((evt->base.type==GF_FEVT_CONNECT_FAIL) && evt->base.on_pid->is_playing) {\n\t\tfree_evt(evt);\n\t\treturn;\n\t}\n\t//otherwise process\n\telse {\n\t\t//reset EOS to false on source switch before executing the event, so that a filter may set a pid to EOS in the callback\n\t\tif (evt->base.type==GF_FEVT_SOURCE_SWITCH) {\n\t\t\t//if session has been aborted, cancel event - this avoids the dashin requesting a source switch on a source that is not yet over\n\t\t\tif (f->session->in_final_flush) {\n\t\t\t\tfree_evt(evt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (i=0; i<f->num_output_pids; i++) {\n\t\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, i);\n\t\t\t\tapid->has_seen_eos = GF_FALSE;\n\t\t\t\tgf_filter_pid_check_unblock(apid);\n\t\t\t}\n\t\t}\n\n\t\tif (f->freg->process_event) {\n\t\t\tFSESS_CHECK_THREAD(f)\n\t\t\tcanceled = f->freg->process_event(f, evt);\n\t\t}\n\t\tif (!canceled && (evt->base.type==GF_FEVT_STOP) && evt->play.forced_dash_segment_switch) {\n\t\t\tGF_FilterPidInst *pid_inst = gf_list_get(f->input_pids, 0);\n\t\t\t//input is source filter, cancel\n\t\t\tif (pid_inst && ((pid_inst->pid->filter->num_input_pids==0) || (pid_inst->pid->filter->freg->flags & GF_FS_REG_ACT_AS_SOURCE))) {\n\t\t\t\tcanceled = GF_TRUE;\n\t\t\t\tforced_cancel = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s processed event %s - canceled %s\\n\", f->name, evt->base.on_pid ? evt->base.on_pid->name : \"none\", gf_filter_event_name(evt->base.type), canceled ? \"yes\" : \"no\" ));\n\n\tif (evt->base.on_pid && ((evt->base.type == GF_FEVT_STOP) || (evt->base.type==GF_FEVT_SOURCE_SEEK) || (evt->base.type==GF_FEVT_PLAY)) ) {\n\t\tBool do_reset = GF_TRUE;\n\t\tGF_FilterPidInst *p = (GF_FilterPidInst *) evt->base.on_pid;\n\t\tGF_FilterPid *pid = p->pid;\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t//we need to force a PID reset when the first PLAY is > 0, since some filters may have dispatched packets during the initialization\n\t\t//phase\n\t\tif (evt->base.type==GF_FEVT_PLAY) {\n\t\t\tpid->is_playing = GF_TRUE;\n\t\t\tpid->filter->nb_pids_playing++;\n\t\t\tif (pid->initial_play_done) {\n\t\t\t\tdo_reset = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tpid->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range < 0.1)\n\t\t\t\t\tdo_reset = GF_FALSE;\n\t\t\t}\n\t\t} else if (evt->base.type==GF_FEVT_STOP) {\n\t\t\tpid->is_playing = GF_FALSE;\n\t\t\tpid->filter->nb_pids_playing--;\n\n\t\t\tif (pid->not_connected)\n\t\t\t\tpid->not_connected = 2;\n\t\t} else if (evt->base.type==GF_FEVT_SOURCE_SEEK) {\n\t\t\tpid->is_playing = GF_TRUE;\n\t\t\tpid->filter->nb_pids_playing++;\n\t\t}\n\t\tfor (i=0; i<pid->num_destinations && do_reset; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tpidi->last_clock_type = 0;\n\n\t\t\tif (!pidi->discard_packets) {\n\t\t\t\tsafe_int_inc(&pidi->discard_packets);\n\t\t\t}\n\n\t\t\tsafe_int_inc(& pid->filter->stream_reset_pending );\n\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\n\t\t\t//post task on destination filter\n\t\t\tif (evt->base.type==GF_FEVT_STOP)\n\t\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_reset_stop_task, pidi->filter, NULL, \"reset_stop_pid\", pidi);\n\t\t\telse\n\t\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_reset_task, pidi->filter, NULL, \"reset_pid\", pidi);\n\n\t\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\t}\n\t\tpid->nb_reaggregation_pending = 0;\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n\t\n\tgf_mx_p(f->tasks_mx);\n\n\t//after  play or seek, request a process task for source filters or filters having pending packets\n\tif (!f->num_input_pids || f->pending_packets) {\n\t\tif ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\t\tgf_filter_post_process_task(f);\n\t\t}\n\t}\n\n\t//quick hack for filters with one input pid and one outout pid, set discard on/off on the input\n\t//this avoids cases like TS demux dispatching data to inactive filters not checking their input\n\t//which ends up in session deadlock (filter still flagged as active and with pending packets)\n\t//if more than one input or more than one output, only the filter can decide what to do if some of the\n\t//streams are active and other not\n\tif ((f->num_input_pids==f->num_output_pids) && (f->num_input_pids==1)) {\n\t\tGF_FilterPidInst *apidi = gf_list_get(f->input_pids, 0);\n\t\tif (apidi->pid) {\n\t\t\t//unlock before setting discard to avoid deadlocks during shutdown\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\tif (evt->base.type==GF_FEVT_STOP) {\n\t\t\t\tif (forced_cancel) {\n\t\t\t\t\t//we stop propagating the event to the source, but we must reset the source pid\n\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_TRUE);\n//\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_FALSE);\n\t\t\t\t} else if (!canceled) {\n\t\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else if (evt->base.type==GF_FEVT_PLAY) {\n\t\t\t\tgf_filter_pid_set_discard((GF_FilterPid *)apidi, GF_FALSE);\n\t\t\t}\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t}\n\t}\n\tgf_mx_v(f->tasks_mx);\n\n\tif ((evt->base.type==GF_FEVT_PLAY) || (evt->base.type==GF_FEVT_SET_SPEED)) {\n\t\tif (evt->base.on_pid) {\n\t\t\tu32 scaler = (u32)  ( (evt->play.speed<0) ? -evt->play.speed : evt->play.speed ) * GF_FILTER_SPEED_SCALER;\n\t\t\tif (!scaler) scaler = GF_FILTER_SPEED_SCALER;\n\t\t\tif (scaler != evt->base.on_pid->playback_speed_scaler) {\n\t\t\t\tu32 prev_scaler = evt->base.on_pid->playback_speed_scaler;\n\t\t\t\tevt->base.on_pid->playback_speed_scaler = scaler;\n\t\t\t\t//lowering speed, we may need to trigger blocking\n\t\t\t\tif (scaler<prev_scaler)\n\t\t\t\t\tgf_filter_pid_would_block(evt->base.on_pid);\n\t\t\t\t//increasing speed, we may want to unblock\n\t\t\t\telse\n\t\t\t\t\tgf_filter_pid_check_unblock(evt->base.on_pid);\n\t\t\t}\n\t\t}\n\t}\n\n\t//no more input pids\n\tgf_mx_p(f->tasks_mx);\n\tcount = f->num_input_pids;\n\tif (count==0) canceled = GF_TRUE;\n\n\tif (canceled) {\n\t\tfree_evt(evt);\n\t\tgf_mx_v(f->tasks_mx);\n\t\treturn;\n\t}\n\n\tif (!task->pid) dispatched_filters = gf_list_new();\n\n\t//otherwise forward event to each input PID\n\tfor (i=0; i<count; i++) {\n\t\tGF_FilterEvent *an_evt;\n\t\tGF_FilterPidInst *pid_inst = gf_list_get(f->input_pids, i);\n\t\tGF_FilterPid *pid = pid_inst->pid;\n\t\tif (!pid) continue;\n\n\t\tif (dispatched_filters) {\n\t\t\tif (gf_list_find(dispatched_filters, pid_inst->pid->filter) >=0 )\n\t\t\t\tcontinue;\n\n\t\t\tgf_list_add(dispatched_filters, pid_inst->pid->filter);\n\t\t}\n\n\t\t//mark pid instance as about to be reset to avoid processing PID destroy task before\n\t\tif ((evt->base.type == GF_FEVT_STOP) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\t\tsafe_int_inc(&pid_inst->discard_packets);\n\t\t}\n\n\t\tan_evt = dup_evt(evt);\n\t\tan_evt->base.on_pid = task->pid ? pid : NULL;\n\n\t\tsafe_int_inc(&pid->filter->num_events_queued);\n\t\t\n\t\tgf_fs_post_task_class(pid->filter->session, gf_filter_pid_send_event_downstream, pid->filter, task->pid ? (GF_FilterPid *) pid_inst : NULL, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n\t}\n\tgf_mx_v(f->tasks_mx);\n\tif (dispatched_filters) gf_list_del(dispatched_filters);\n\tfree_evt(evt);\n\treturn;\n}\n\nvoid gf_filter_pid_send_event_upstream(GF_FSTask *task)\n{\n\tu32 i, j;\n\tBool canceled = GF_FALSE;\n\tGF_FilterEvent *evt = task->udta;\n\tGF_Filter *f = task->filter;\n\n\tif (f->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tcanceled = f->freg->process_event ? f->freg->process_event(f, evt) : GF_FALSE;\n\tif (!canceled) {\n\t\tfor (i=0; i<f->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, i);\n\t\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\t\tGF_FilterEvent *an_evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(apid->destinations, j);\n\n\t\t\t\tan_evt = dup_evt(evt);\n\t\t\t\tan_evt->base.on_pid = (GF_FilterPid *)pidi;\n\t\t\t\tgf_fs_post_task_class(pidi->filter->session, gf_filter_pid_send_event_upstream, pidi->filter, NULL, \"upstream_event\", an_evt, TASK_TYPE_EVENT);\n\t\t\t}\n\t\t}\n\t}\n\tfree_evt(evt);\n}\n\nvoid gf_filter_pid_send_event_internal(GF_FilterPid *pid, GF_FilterEvent *evt, Bool force_downstream)\n{\n\tGF_FilterEvent *an_evt;\n\tGF_FilterPid *target_pid=NULL;\n\tBool upstream=GF_FALSE;\n\tif (!pid) {\n\t\tpid = evt->base.on_pid;\n\t\tif (!pid) return;\n\t}\n\t//filter is being shut down, prevent any event posting\n\tif (pid->filter->finalized) return;\n\n\tif ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;\n\n\tif (!force_downstream && PID_IS_OUTPUT(pid)) {\n\t\tupstream = GF_TRUE;\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s PID %s queuing %s event %s\\n\", pid->pid->filter->name, pid->pid->name, upstream ? \"upstream\" : \"downstream\", gf_filter_event_name(evt->base.type) ));\n\n\tif (upstream) {\n\t\tu32 i, j;\n\n\t\tan_evt = init_evt(evt);\n\n\t\tfor (i=0; i<pid->filter->num_output_pids; i++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);\n\t\t\tif (evt->base.on_pid && (apid != evt->base.on_pid)) continue;\n\t\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\t\tGF_FilterEvent *up_evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(apid->destinations, j);\n\n\t\t\t\tup_evt = dup_evt(an_evt);\n\t\t\t\tup_evt->base.on_pid = (GF_FilterPid *)pidi;\n\t\t\t\tgf_fs_post_task_class(pidi->filter->session, gf_filter_pid_send_event_upstream, pidi->filter, NULL, \"upstream_event\", up_evt, TASK_TYPE_EVENT);\n\t\t\t}\n\t\t}\n\t\tfree_evt(an_evt);\n\t\treturn;\n\t}\n\n\n\tif ((evt->base.type == GF_FEVT_STOP)\n\t\t|| (evt->base.type == GF_FEVT_PLAY)\n\t\t|| (evt->base.type==GF_FEVT_SOURCE_SEEK)\n\t) {\n\t\tu32 i, nb_playing=0;\n\t\tBool do_reset = GF_TRUE;\n\t\tgf_mx_p(pid->pid->filter->tasks_mx);\n\n\t\tfor (i=0; i<pid->pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);\n\t\t\tif (pidi->is_playing || pidi->play_queued) nb_playing++;\n\t\t\tif (pidi->stop_queued) nb_playing--;\n\n\t\t\t//pre-check pid instance play state\n\t\t\tif (pidi == (GF_FilterPidInst *)evt->base.on_pid) {\n\t\t\t\t//if STOP and pid instance already stop, silently discard\n\t\t\t\tif ((evt->base.type == GF_FEVT_STOP) && !pidi->is_playing && !pidi->play_queued) {\n\t\t\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//if PLAY and pid instance already playing, silently discard\n\t\t\t\telse if ((evt->base.type == GF_FEVT_PLAY) && pidi->is_playing && !pidi->stop_queued) {\n\t\t\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//do not set discard_packets flag on pid instance when:\n\t\t//- pid has at least one active output and we play one\n\t\t//- pid has more than one active output and we stop one\n\t\tif (evt->base.type == GF_FEVT_STOP) {\n\t\t\tif (nb_playing>1)\n\t\t\t\tdo_reset = GF_FALSE;\n\n\t\t\tif (PID_IS_INPUT(pid)) {\n\t\t\t\t((GF_FilterPidInst*)evt->base.on_pid)->stop_queued = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (nb_playing)\n\t\t\t\tdo_reset = GF_FALSE;\n\t\t\tif (PID_IS_INPUT(pid)) {\n\t\t\t\t((GF_FilterPidInst*)evt->base.on_pid)->play_queued = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<pid->pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);\n\n\t\t\tif (!do_reset && (pidi != (GF_FilterPidInst*)evt->base.on_pid))\n\t\t\t\tcontinue;\n\n\t\t\tif (evt->base.type == GF_FEVT_PLAY) {\n\t\t\t\tpidi->is_end_of_stream = GF_FALSE;\n\t\t\t} else {\n\t\t\t\t//flag pid instance to discard all packets (cf above note)\n\t\t\t\tsafe_int_inc(&pidi->discard_packets);\n\t\t\t}\n\t\t}\n\n\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t}\n\n\tan_evt = init_evt(evt);\n\tif (evt->base.on_pid) {\n\t\ttarget_pid = evt->base.on_pid;\n\t\tan_evt->base.on_pid = evt->base.on_pid->pid;\n\t\tsafe_int_inc(&target_pid->pid->filter->num_events_queued);\n\t}\n\tgf_fs_post_task_class(pid->pid->filter->session, gf_filter_pid_send_event_downstream, pid->pid->filter, target_pid, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_send_event(GF_FilterPid *pid, GF_FilterEvent *evt)\n{\n\tif (!evt) return;\n\tif (evt->base.type==GF_FEVT_RESET_SCENE) return;\n\tif (evt->base.type==GF_FEVT_INFO_UPDATE) return;\n\n\tgf_filter_pid_send_event_internal(pid, evt, GF_FALSE);\n}\n\nGF_EXPORT\nvoid gf_filter_send_event(GF_Filter *filter, GF_FilterEvent *evt, Bool upstream)\n{\n\tGF_FilterEvent *an_evt;\n\tif (!filter) return;\n\tif (filter->multi_sink_target)\n\t\tfilter = filter->multi_sink_target;\n\n\t//filter is being shut down, prevent any event posting\n\tif (filter->finalized) return;\n\tif (!evt) return;\n\tif ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;\n\n\tif (evt->base.type==GF_FEVT_RESET_SCENE)\n\t\treturn;\n\n\tif (evt->base.on_pid && PID_IS_OUTPUT(evt->base.on_pid)) {\n\t\tgf_filter_pid_send_event_internal(evt->base.on_pid, evt, GF_FALSE);\n\t\treturn;\n\t}\n\n\t//switch and seek events are only sent on source filters\n\tif ((evt->base.type==GF_FEVT_SOURCE_SWITCH) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {\n\t\tif (filter->num_input_pids && !(filter->freg->flags & GF_FS_REG_ACT_AS_SOURCE)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Sending %s event on non source filter %s is not allowed, discarding)\\n\", gf_filter_event_name(evt->base.type), filter->name));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tan_evt = init_evt(evt);\n\n\tif (evt->base.on_pid) {\n\t\tsafe_int_inc(&evt->base.on_pid->filter->num_events_queued);\n\t}\n\tif (upstream)\n\t\tgf_fs_post_task_class(filter->session, gf_filter_pid_send_event_upstream, filter, evt->base.on_pid, \"upstream_event\", an_evt, TASK_TYPE_EVENT);\n\telse\n\t\tgf_fs_post_task_class(filter->session, gf_filter_pid_send_event_downstream, filter, evt->base.on_pid, \"downstream_event\", an_evt, TASK_TYPE_EVENT);\n}\n\n\nGF_EXPORT\nvoid gf_filter_pid_exec_event(GF_FilterPid *pid, GF_FilterEvent *evt)\n{\n\t//filter is being shut down, prevent any event posting\n\tif (pid->pid->filter->finalized) return;\n\tif (! (pid->pid->filter->freg->flags &\tGF_FS_REG_MAIN_THREAD)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Executing event on PID %s created by filter %s not running on main thread, not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\n\tif (pid->pid->filter->freg->process_event) {\n\t\tif (evt->base.on_pid) evt->base.on_pid = evt->base.on_pid->pid;\n\t\tFSESS_CHECK_THREAD(pid->pid->filter)\n\t\tpid->pid->filter->freg->process_event(pid->pid->filter, evt);\n\t}\n}\n\n\nGF_EXPORT\nBool gf_filter_pid_is_filter_in_parents(GF_FilterPid *pid, GF_Filter *filter)\n{\n\tif (!pid || !filter) return GF_FALSE;\n\tpid = pid->pid;\n\treturn gf_filter_in_parent_chain(pid->filter, filter);\n}\n\n\n\nGF_EXPORT\nBool gf_filter_pid_share_origin(GF_FilterPid *pid, GF_FilterPid *other_pid)\n{\n    if (!pid || !other_pid) return GF_FALSE;\n    pid = pid->pid;\n    other_pid = other_pid->pid;\n    if (gf_filter_in_parent_chain(pid->filter, other_pid->filter))\n        return GF_TRUE;\n    if (gf_filter_in_parent_chain(other_pid->filter, pid->filter))\n        return GF_TRUE;\n    return GF_FALSE;\n}\n\nstatic void filter_pid_inst_collect_stats(GF_FilterPidInst *pidi, GF_FilterPidStatistics *stats)\n{\n\tif (!pidi->pid) return;\n\n\tstats->average_bitrate += pidi->avg_bit_rate;\n\tif (!stats->first_process_time || (stats->first_process_time > pidi->first_frame_time))\n\t\tstats->first_process_time = pidi->first_frame_time;\n\tif (stats->last_process_time < pidi->last_pck_fetch_time)\n\t\tstats->last_process_time = pidi->last_pck_fetch_time;\n\n\tstats->max_bitrate += pidi->max_bit_rate;\n\n\tif (stats->max_process_time < (u32) pidi->max_process_time)\n\t\tstats->max_process_time = (u32) pidi->max_process_time;\n\tif (stats->max_sap_process_time < (u32) pidi->max_sap_process_time)\n\t\tstats->max_sap_process_time = (u32) pidi->max_sap_process_time;\n\tif (!stats->min_frame_dur || (stats->min_frame_dur > pidi->pid->min_pck_duration))\n\t\tstats->min_frame_dur = pidi->pid->min_pck_duration;\n\tstats->nb_processed += pidi->nb_processed;\n\tstats->nb_saps += pidi->nb_sap_processed;\n\tstats->total_process_time += pidi->total_process_time;\n\tstats->total_sap_process_time += pidi->total_sap_process_time;\n\tstats->average_process_rate += pidi->avg_process_rate;\n\tstats->max_process_rate += pidi->max_process_rate;\n\n\tif (stats->nb_buffer_units < pidi->pid->nb_buffer_unit)\n\t\tstats->nb_buffer_units = pidi->pid->nb_buffer_unit;\n\tif (stats->max_buffer_time < pidi->pid->max_buffer_time)\n\t\tstats->max_buffer_time = pidi->pid->max_buffer_time;\n\n\tif (stats->max_playout_time < pidi->pid->user_max_playout_time)\n\t\tstats->max_playout_time = pidi->pid->user_max_playout_time;\n\tif (!stats->min_playout_time || (stats->min_playout_time > pidi->pid->user_min_playout_time))\n\t\tstats->min_playout_time = pidi->pid->user_min_playout_time;\n\n\tif (stats->buffer_time < pidi->pid->buffer_duration)\n\t\tstats->buffer_time = pidi->pid->buffer_duration;\n\n\tif (!stats->last_ts_drop.den\n\t\t|| gf_timestamp_less(stats->last_ts_drop.num, stats->last_ts_drop.den, pidi->last_ts_drop.num, pidi->last_ts_drop.den)\n\t) {\n\t\tstats->last_ts_drop = pidi->last_ts_drop;\n\t}\n\tif (!stats->last_ts_sent.den\n\t\t|| gf_timestamp_less(stats->last_ts_sent.num, stats->last_ts_sent.den, pidi->pid->last_ts_sent.num, pidi->pid->last_ts_sent.den)\n\t) {\n\t\tstats->last_ts_sent = pidi->pid->last_ts_sent;\n\t}\n\n\tif (pidi->last_rt_report) {\n\t\tstats->last_rt_report = pidi->last_rt_report;\n\t\tstats->rtt = pidi->rtt;\n\t\tstats->jitter = pidi->jitter;\n\t\tstats->loss_rate = pidi->loss_rate;\n\t}\n}\n\nstatic void filter_pid_collect_stats(GF_List *pidi_list, GF_FilterPidStatistics *stats)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(pidi_list); i++) {\n\t\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) gf_list_get(pidi_list, i);\n\t\tif (!pidi->pid) continue;\n\n\t\tfilter_pid_inst_collect_stats(pidi, stats);\n\t}\n}\n\n\nstatic GF_Filter *filter_locate_enc_dec_sink(GF_Filter *filter, Bool locate_decoder)\n{\n\tu32 i, j;\n\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *res;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (( (pidi->is_decoder_input || pid->user_buffer_forced) && locate_decoder)\n\t\t\t\t|| (pidi->is_encoder_input && !locate_decoder)\n\t\t\t)\n\t\t\t\treturn pidi->filter;\n\t\t\tres = filter_locate_enc_dec_sink(pidi->filter, locate_decoder);\n\t\t\tif (res) return res;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic GF_Filter *filter_locate_enc_dec_src(GF_Filter *filter, Bool locate_decoder)\n{\n\tu32 i;\n\n\tgf_mx_p(filter->tasks_mx);\n\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\tGF_Filter *res;\n\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\tif ((pidi->is_decoder_input && locate_decoder)\n\t\t\t|| (pidi->is_encoder_input && !locate_decoder)\n\t\t) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn filter;\n\t\t}\n\t\tres = filter_locate_enc_dec_sink(pidi->pid->filter, locate_decoder);\n\t\tif (res) {\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\treturn res;\n\t\t}\n\t}\n\tgf_mx_v(filter->tasks_mx);\n\treturn NULL;\n}\n\nstatic GF_Filter *filter_locate_sink(GF_Filter *filter)\n{\n\tu32 i, j;\n\n\tif (!filter->num_output_pids) {\n\t\treturn filter;\n\t}\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *res;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tres = filter_locate_sink(pidi->filter);\n\t\t\tif (res) return res;\n\t\t}\n\t}\n\treturn NULL;\n}\nGF_EXPORT\nGF_Err gf_filter_pid_get_statistics(GF_FilterPid *pid, GF_FilterPidStatistics *stats, GF_FilterPidStatsLocation location)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tGF_Filter *filter=NULL;\n\tBool for_decoder=GF_TRUE;\n\n\tmemset(stats, 0, sizeof(GF_FilterPidStatistics) );\n\tif (!pidi->pid) {\n\t\tstats->disconnected = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\tswitch (location) {\n\tcase GF_STATS_LOCAL:\n\t\tif (PID_IS_OUTPUT(pid)) {\n\t\t\tfilter_pid_collect_stats(pid->destinations, stats);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tfilter_pid_inst_collect_stats(pidi, stats);\n\t\treturn GF_OK;\n\tcase GF_STATS_LOCAL_INPUTS:\n\t\tif (PID_IS_OUTPUT(pid)) {\n\t\t\tfilter_pid_collect_stats(pid->destinations, stats);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tfilter = pidi->pid->filter;\n\t\tbreak;\n\tcase GF_STATS_ENCODER_SOURCE:\n\t\tfor_decoder = GF_FALSE;\n\tcase GF_STATS_DECODER_SOURCE:\n\t\tfilter = filter_locate_enc_dec_src(pidi->pid->filter, for_decoder);\n\t\tbreak;\n\tcase GF_STATS_ENCODER_SINK:\n\t\tfor_decoder = GF_FALSE;\n\tcase GF_STATS_DECODER_SINK:\n\t\tfilter = filter_locate_enc_dec_sink(pidi->pid->filter, for_decoder);\n\t\tbreak;\n\tcase GF_STATS_SINK:\n\t\tfilter = filter_locate_sink(pidi->pid->filter);\n\t\tbreak;\n\t}\n\tif (!filter) {\n\t\treturn GF_NOT_FOUND;\n\t}\n\tgf_mx_p(filter->tasks_mx);\n\tfilter_pid_collect_stats(filter->input_pids, stats);\n\tgf_mx_v(filter->tasks_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_remove(GF_FilterPid *pid)\n{\n\tGF_FilterPacket *pck;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Removing PID input filter (%s:%s) not allowed\\n\", pid->filter->name, pid->pid->name));\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s removed output PID %s\\n\", pid->filter->name, pid->pid->name));\n\n\tif (pid->filter->removed) {\n\t\treturn;\n\t}\n\tif (pid->removed) {\n\t\treturn;\n\t}\n\tpid->removed = GF_TRUE;\n\tif (pid->filter->marked_for_removal || (pid->has_seen_eos && !pid->nb_buffer_unit)) {\n\t\tu32 i;\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\t\tgf_fs_post_task(pidi->filter->session, gf_filter_pid_disconnect_task, pidi->filter, pidi->pid, \"pidinst_disconnect\", NULL);\n\t\t}\n\t\treturn;\n\t}\n\n\t//we create a fake packet for removal signaling\n\tpck = gf_filter_pck_new_shared_internal(pid, NULL, 0, NULL, GF_TRUE);\n\tif (!pck) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to allocate new packet for PID %s remove in filter %s\\n\", pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tpck->pck->info.flags |= GF_PCK_CMD_PID_REM;\n\tgf_filter_pck_send(pck);\n}\n\nGF_EXPORT\nvoid gf_filter_pid_try_pull(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to pull from output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid = pid->pid;\n#ifndef GPAC_DISABLE_THREADS\n\tif (pid->filter->session->threads) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter pull in multithread mode not yet implementing - defaulting to 1 ms sleep\\n\", pid->pid->name, pid->filter->name));\n\t\tgf_sleep(1);\n\t\treturn;\n\t}\n#endif\n\n\tgf_filter_process_inline(pid->filter);\n}\n\n\nGF_EXPORT\nGF_FilterClockType gf_filter_pid_get_clock_info(GF_FilterPid *pid, u64 *clock_time, u32 *timescale)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tGF_FilterClockType res;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying clock on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FILTER_CLOCK_NONE;\n\t}\n\tif (clock_time) *clock_time = pidi->last_clock_value;\n\tif (timescale) *timescale = pidi->last_clock_timescale;\n\tres = pidi->last_clock_type;\n\tpidi->last_clock_type = 0;\n\treturn res;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_timescale(GF_FilterPid *pid)\n{\n\tGF_PropertyMap *map;\n\tif (!pid) return 0;\n\t//if input pid, the active PID config is the first one\n\tif (PID_IS_INPUT(pid))\n\t\tmap = gf_list_get(pid->pid->properties, 0);\n\t//if output pid, the active PID config is the last one one\n\telse\n\t\tmap = gf_list_last(pid->pid->properties);\n\treturn map ? map->timescale : 0;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_clear_eos(GF_FilterPid *pid, Bool clear_all)\n{\n\tu32 i, j;\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Clearing EOS on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid = pid->pid;\n\tfor (i=0; i<pid->filter->num_output_pids; i++) {\n\t\tGF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);\n\t\tif (!clear_all && (pid != apid)) continue;\n\n\t\tfor (j=0; j<apid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(apid->destinations, j);\n\t\t\tif (apidi->filter != pidi->filter) continue;\n\n\t\t\tif (apidi->is_end_of_stream) {\n\t\t\t\tapidi->is_end_of_stream = GF_FALSE;\n\t\t\t}\n\t\t\tif (apid->has_seen_eos) {\n\t\t\t\tapid->has_seen_eos = GF_FALSE;\n\t\t\t\tgf_filter_pid_check_unblock(apid);\n\t\t\t}\n\n\t\t\tif (apidi->pid->filter->would_block && apidi->pid->filter->num_input_pids) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_mx_p(apidi->pid->filter->tasks_mx);\n\t\t\t\tfor (k=0; k<apidi->pid->filter->num_input_pids; k++) {\n\t\t\t\t\tGF_FilterPidInst *source_pid_inst = gf_list_get(apidi->pid->filter->input_pids, k);\n\t\t\t\t\tgf_filter_pid_clear_eos((GF_FilterPid *) source_pid_inst, clear_all);\n\t\t\t\t}\n\t\t\t\tgf_mx_v(apidi->pid->filter->tasks_mx);\n\t\t\t}\n\t\t}\n\t}\n\n\t//if filter is blocking we cannot clear EOS down the chain\n\tif (clear_all && !pid->filter->would_block) {\n\t\t//block parent\n\t\tgf_mx_p(pid->filter->tasks_mx);\n\t\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\t\tGF_FilterPidInst *apidi = gf_list_get(pid->filter->input_pids, i);\n\t\t\tgf_filter_pid_clear_eos((GF_FilterPid *) apidi, GF_TRUE);\n\t\t}\n\t\tgf_mx_v(pid->filter->tasks_mx);\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_clock_mode(GF_FilterPid *pid, Bool filter_in_charge)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Changing clock mode on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpidi->handles_clock_references = filter_in_charge;\n}\n\nGF_EXPORT\nconst char *gf_filter_pid_get_args(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying args on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (pid->pid->filter->src_args) return pid->pid->filter->src_args;\n\treturn pid->pid->filter->orig_args;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_set_max_buffer(GF_FilterPid *pid, u32 total_duration_us)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Setting max buffer on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->max_buffer_time = pid->user_max_buffer_time = total_duration_us;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_max_buffer(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Querying max buffer on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn 0;\n\t}\n\treturn pid->pid->user_max_buffer_time;\n}\n\n\nGF_EXPORT\nvoid gf_filter_pid_set_loose_connect(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Setting loose connect on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->not_connected_ok = GF_TRUE;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_caps_query(GF_FilterPid *pid, u32 prop_4cc)\n{\n\tu32 i;\n\tGF_PropertyMap *map = pid->pid->caps_negociate;\n\tif (PID_IS_INPUT(pid)) {\n\t\tu32 k;\n\t\tGF_Filter *dst = pid->filter->cap_dst_filter;\n\t\t//the first entry in destination filters may be the final destination and won't hold any caps query\n\t\t//we therefore use the last entry which points to the next filter in the chain\n\t\tif (!dst) dst = gf_list_last(pid->filter->destination_filters);\n\t\tif (!dst) dst = gf_list_get(pid->filter->destination_links, 0);\n\n\t\tif (!dst || (dst->cap_idx_at_resolution<0) ) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Reconfig caps query on input PID %s in filter %s with no destination filter set\\n\", pid->pid->name, pid->filter->name));\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (k=dst->cap_idx_at_resolution; k<dst->freg->nb_caps; k++) {\n\t\t\tconst GF_FilterCapability *cap = &dst->freg->caps[k];\n\t\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) return NULL;\n\n\t\t\tif (!(cap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t\tif (cap->flags & GF_CAPFLAG_OPTIONAL) continue;\n\t\t\tif (cap->code == prop_4cc) return &cap->val;\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (map) return gf_props_get_property(map, prop_4cc, NULL);\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tu32 j;\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\t\tfor (j=0; j<pidi->filter->nb_forced_caps; j++) {\n\t\t\tif (pidi->filter->forced_caps[j].code==prop_4cc)\n\t\t\t\treturn &pidi->filter->forced_caps[j].val;\n\t\t}\n\t\t//walk up the chain\n\t\tfor (j=0; j<pidi->filter->num_output_pids; j++) {\n\t\t\tGF_FilterPid *apid = gf_list_get(pidi->filter->output_pids, j);\n\t\t\tif (apid) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_caps_query(apid, prop_4cc);\n\t\t\t\tif (p) return p;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//trick here: we may not be connected yet (called during a configure_pid), use the target destination\n\t//of the filter as caps source\n\tif (gf_list_count(pid->filter->destination_filters) ) {\n\t\tGF_Filter *a_filter = gf_list_get(pid->filter->destination_filters, 0);\n\t\twhile (a_filter) {\n\t\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t\t}\n\t\t\ta_filter = gf_list_get(a_filter->destination_filters, 0);\n\t\t}\n\t}\n\n\t//second trick here: we may not be connected yet (called during a configure_pid), use the target destination\n\t//of the filter as caps source\n\tif (pid->filter->cap_dst_filter) {\n\t\tGF_Filter *a_filter = pid->filter->cap_dst_filter;\n\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t}\n\t\t//not found, check if dst filter is alread linked to a dest - may happen when loading muxes with different chain length:\n\t\t//-i obu -i mp4a -o file.ts\n\t\t//the link fin->mp4dmx->m2tsmx->file.ts is solved before fin->rfav1->ufobu->m2tsmx->ts\n\t\ta_filter = a_filter->dst_filter;\n\t\twhile (a_filter) {\n\t\t\tfor (i=0; i<a_filter->nb_forced_caps; i++) {\n\t\t\t\tif (a_filter->forced_caps[i].code==prop_4cc)\n\t\t\t\t\treturn &a_filter->forced_caps[i].val;\n\t\t\t}\n\t\t\ta_filter = a_filter->dst_filter;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nGF_EXPORT\nconst GF_PropertyValue *gf_filter_pid_caps_query_str(GF_FilterPid *pid, const char *prop_name)\n{\n\tGF_PropertyMap *map;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Reconfig caps query on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tmap = pid->caps_negociate;\n\treturn map ? gf_props_get_property(map, 0, prop_name) : NULL;\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_pid_resolve_file_template_ex(GF_FilterPid *pid, char szTemplate[GF_MAX_PATH], char szFinalName[GF_MAX_PATH], u32 file_idx, const char *file_suffix, const char *filename)\n{\n\tu32 k;\n\tGF_FilterPacket *pck;\n\tchar szFormat[30], szTemplateVal[GF_MAX_PATH], szPropVal[GF_PROP_DUMP_ARG_SIZE];\n\tchar *name = szTemplate;\n\tif (!strchr(szTemplate, '$')) {\n\t\tstrcpy(szFinalName, szTemplate);\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pid_get_packet(pid);\n\t\n\tk = 0;\n\twhile (name[0]) {\n\t\tchar *sep=NULL;\n\t\tchar *fsep=NULL;\n\t\tconst char *str_val = NULL;\n\t\ts64 value = 0;\n\t\tBool is_ok = GF_TRUE;\n\t\tBool do_skip = GF_FALSE;\n\t\tBool has_val = GF_FALSE;\n\t\tBool is_file_str = GF_FALSE;\n\t\tu32 prop_4cc = 0;\n\t\tGF_PropertyValue prop_val_patched;\n\t\tconst GF_PropertyValue *prop_val = NULL;\n\n\t\tif (k+1==GF_MAX_PATH) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Not enough memory to solve file template %s\\n\", szTemplate));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tif (name[0] != '$') {\n\t\t\tszFinalName[k] = name[0];\n\t\t\tk++;\n\t\t\tname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (name[1]=='$') {\n\t\t\tszFinalName[k] = '$';\n\t\t\tname++;\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\t\tsep = strchr(name+1, '$');\n\t\tif (!sep) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] broken file template expecting $KEYWORD$, couldn't find second '$'\\n\", szTemplate));\n\t\t\tstrcpy(szFinalName, szTemplate);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tszFormat[0] = '%';\n\t\tszFormat[1] = 'd';\n\t\tszFormat[2] = 0;\n\n\t\tszFinalName[k] = 0;\n\t\tname++;\n\t\tsep[0]=0;\n\t\tfsep = strchr(name, '%');\n\t\tif (fsep) {\n\t\t\tstrcpy(szFormat, fsep);\n\t\t\tfsep[0]=0;\n\t\t}\n\n\t\tif (!strcmp(name, \"num\")) {\n\t\t\tname += 3;\n\t\t\tvalue = file_idx;\n\t\t\thas_val = GF_TRUE;\n\t\t} else if (!strcmp(name, \"URL\")) {\n\t\t\tif (!filename)\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);\n\t\t\tis_file_str = GF_TRUE;\n\t\t} else if (!strcmp(name, \"File\")) {\n\t\t\tif (!filename) {\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_FILEPATH);\n\t\t\t\t//if filepath is a gmem:// wrapped, don't use it !\n\t\t\t\tif (prop_val && !strncmp(prop_val->value.string, \"gmem://\", 7))\n\t\t\t\t\tprop_val = NULL;\n\n\t\t\t\tif (!prop_val)\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);\n\n\t\t\t\tif (!prop_val && pid->pid->name) {\n\t\t\t\t\tprop_val_patched.type = GF_PROP_STRING;\n\t\t\t\t\tprop_val_patched.value.string = pid->pid->name;\n\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\tis_file_str = GF_TRUE;\n\t\t} else if (!strcmp(name, \"PID\")) {\n\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ID);\n\t\t} else if (!strcmp(name, \"FS\")) {\n\t\t\tstr_val = file_suffix ? file_suffix : \"\";\n\t\t\tis_ok = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Type\")) {\n\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (prop_val) {\n\t\t\t\tstr_val = gf_stream_type_short_name(prop_val->value.uint);\n\t\t\t\tis_ok = GF_TRUE;\n\t\t\t}\n\t\t\tprop_val = NULL;\n\t\t} else if (!strncmp(name, \"p4cc=\", 5)) {\n\t\t\tif (strlen(name) != 9) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] wrong length in 4CC template, expecting 4cc=ABCD\\n\", name));\n\t\t\t\tis_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tprop_4cc = GF_4CC(name[5],name[6],name[7],name[8]);\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, prop_4cc);\n\t\t\t\tif (!prop_val && pck) {\n\t\t\t\t\tprop_val = gf_filter_pck_get_property(pck, prop_4cc);\n\t\t\t\t}\n\t\t\t\tif (!prop_val) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] no pid property of type %s\\n\", name+5));\n\t\t\t\t\tis_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strncmp(name, \"pname=\", 6)) {\n\t\t\tprop_val = gf_filter_pid_get_property_str_first(pid, name+6);\n\t\t\tif (!prop_val && pck) {\n\t\t\t\tprop_val = gf_filter_pck_get_property_str(pck, name+6);\n\t\t\t}\n\t\t\tif (!prop_val) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] no pid property named %s\\n\", name+6));\n\t\t\t\tis_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//DASH reserved\n\t\telse if (!strcmp(name, \"Number\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Time\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"RepresentationID\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"Bandwidth\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strcmp(name, \"SubNumber\")) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"Init\", 4) && (name[4]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"XInit\", 5) && (name[5]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else if (!strncmp(name, \"Path\", 4) && (name[4]=='=')) {\n\t\t\tdo_skip = GF_TRUE;\n\t\t} else {\n\t\t\tchar *next_eq = strchr(name, '=');\n\t\t\tchar *next_sep = strchr(name, '$');\n\t\t\tif (!next_eq || (next_eq - name < next_sep - name)) {\n\t\t\t\tprop_4cc = gf_props_get_id(name);\n\t\t\t\t//not matching, try with name\n\t\t\t\tif (!prop_4cc) {\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_str_first(pid, name);\n\t\t\t\t\tif (!prop_val && pck)\n\t\t\t\t\t\tprop_val = gf_filter_pck_get_property_str(pck, name);\n\t\t\t\t} else {\n\t\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, prop_4cc);\n\t\t\t\t\tif (!prop_val && pck)\n\t\t\t\t\t\tprop_val = gf_filter_pck_get_property(pck, prop_4cc);\n\t\t\t\t}\n\n\t\t\t\tif (!prop_val && pck) {\n\t\t\t\t\tif (!strcmp(name, \"cts\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_LUINT;\n\t\t\t\t\t\tprop_val_patched.value.longuint = gf_filter_pck_get_cts(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"dts\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_LUINT;\n\t\t\t\t\t\tprop_val_patched.value.longuint = gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"dur\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_UINT;\n\t\t\t\t\t\tprop_val_patched.value.uint = gf_filter_pck_get_duration(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t} else if (!strcmp(name, \"sap\")) {\n\t\t\t\t\t\tprop_val_patched.type = GF_PROP_UINT;\n\t\t\t\t\t\tprop_val_patched.value.uint = gf_filter_pck_get_sap(pck);\n\t\t\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!prop_val) {\n\t\t\t\t\tif (!prop_4cc) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Unrecognized template %s\\n\", name));\n\t\t\t\t\t}\n\t\t\t\t\tis_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 i, len = (u32) (next_sep ? 1+(next_sep - name) : strlen(name) );\n\t\t\t\tszFinalName[k]='$';\n\t\t\t\tk++;\n\t\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\t\tszFinalName[k] = name[0];\n\t\t\t\t\tk++;\n\t\t\t\t\tname++;\n\t\t\t\t}\n\t\t\t\tszFinalName[k]='$';\n\t\t\t\tk++;\n\t\t\t\tsep[0] = '$';\n\t\t\t\tname = sep+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fsep) fsep[0] = '%';\n\t\tif (do_skip) {\n\t\t\tsep[0] = '$';\n\t\t\tszFinalName[k] = '$';\n\t\t\tk++;\n\t\t\twhile (name[0] && (name[0] != '$')) {\n\t\t\t\tszFinalName[k] = name[0];\n\t\t\t\tk++;\n\t\t\t\tname++;\n\t\t\t}\n\t\t\tszFinalName[k] = '$';\n\t\t\tk++;\n\t\t\tname++;\n\n\n\t\t\tcontinue;\n\n\t\t}\n\n\n\t\tif (!is_ok && !prop_val && prop_4cc) {\n\t\t\tif (prop_4cc==GF_PROP_PID_CROP_POS) {\n\t\t\t\tprop_val_patched.type = GF_PROP_VEC2I;\n\t\t\t\tprop_val_patched.value.vec2i.x = 0;\n\t\t\t\tprop_val_patched.value.vec2i.y = 0;\n\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\tis_ok=GF_TRUE;\n\t\t\t}\n\t\t\telse if (prop_4cc==GF_PROP_PID_ORIG_SIZE) {\n\t\t\t\tprop_val_patched.type = GF_PROP_VEC2I;\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_WIDTH);\n\t\t\t\tprop_val_patched.value.vec2i.x = prop_val ? prop_val->value.uint : 0;\n\t\t\t\tprop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_HEIGHT);\n\t\t\t\tprop_val_patched.value.vec2i.y = prop_val ? prop_val->value.uint : 0;\n\t\t\t\tprop_val = &prop_val_patched;\n\t\t\t\tis_ok=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] property %s not found for pid, cannot resolve template\\n\", name));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_ok) {\n\t\t\tif (sep) sep[0] = '$';\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (prop_val) {\n\t\t\tif ((prop_val->type==GF_PROP_UINT) || (prop_val->type==GF_PROP_SINT)) {\n\t\t\t\tvalue = prop_val->value.uint;\n\t\t\t\thas_val = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tstr_val = gf_props_dump_val(prop_val, szPropVal, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t}\n\t\t} else if (is_file_str) {\n\t\t\tstr_val = filename;\n\t\t}\n\t\tszTemplateVal[0]=0;\n\t\tif (has_val) {\n\t\t\tsprintf(szTemplateVal, szFormat, value);\n\t\t} else if (str_val) {\n\t\t\tif (is_file_str) {\n\t\t\t\tif (!strncmp(str_val, \"gfio://\", 7))\n\t\t\t\t\tstr_val = gf_fileio_translate_url(str_val);\n\n\t\t\t\tif (filename) {\n\t\t\t\t\tstrcpy(szTemplateVal, filename);\n\t\t\t\t} else {\n\t\t\t\t\tchar *ext, *sname;\n\t\t\t\t\text = strstr(str_val, \"://\");\n\t\t\t\t\tsname = strrchr(ext ? ext+4 : str_val, '/');\n\t\t\t\t\tif (!sname) sname = strrchr(ext ? ext+4 : str_val, '\\\\');\n\t\t\t\t\tif (sname && ext)\n\t\t\t\t\t\tstr_val = sname+1;\n\n\t\t\t\t\tif (!sname) sname = (char *) str_val;\n\t\t\t\t\telse sname++;\n\n\t\t\t\t\text = strrchr(str_val, '.');\n\n\t\t\t\t\tif (ext && (ext > sname) ) {\n\t\t\t\t\t\tu32 len = (u32) (ext - sname);\n\t\t\t\t\t\tstrncpy(szTemplateVal, sname, ext - sname);\n\t\t\t\t\t\tszTemplateVal[len] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(szTemplateVal, sname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrcpy(szTemplateVal, str_val);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] property %s not found for pid, cannot resolve template\\n\", name));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (k + strlen(szTemplateVal) > GF_MAX_PATH) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"[Filter] Not enough memory to solve file template %s\\n\", szTemplate));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t\tstrcat(szFinalName, szTemplateVal);\n\t\tk = (u32) strlen(szFinalName);\n\n\t\tif (!sep) break;\n\t\tsep[0] = '$';\n\t\tname = sep+1;\n\t}\n\tszFinalName[k] = 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_resolve_file_template(GF_FilterPid *pid, char szTemplate[GF_MAX_PATH], char szFinalName[GF_MAX_PATH], u32 file_idx, const char *file_suffix)\n{\n\treturn gf_filter_pid_resolve_file_template_ex(pid, szTemplate, szFinalName, file_idx, file_suffix, NULL);\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_discard(GF_FilterPid *pid, Bool discard_on)\n{\n\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt at discarding packets on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (discard_on) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Discarding packets on PID %s (filter %s to %s)\\n\", pid->pid->name, pid->pid->filter->name, pid->filter->name));\n\t\tgf_filter_aggregate_packets(pidi);\n\t\t//force discarding\n\t\tu32 pck_discard_bck = pidi->discard_packets;\n\t\tpidi->discard_packets = 0;\n\t\twhile (gf_filter_pid_get_packet(pid)) {\n\t\t\tgf_filter_pid_drop_packet(pid);\n\t\t}\n\t\tpidi->discard_packets = pck_discard_bck;\n\t\tpidi->is_end_of_stream = GF_TRUE;\n\t} else {\n\t\t//no more packets in queue or postponed, we can trust the EOS signal on the PID\n\t\t//otherwise even though the PID has seen the EOS, it is not yet processed by the pid instance, signaling it\n\t\t//would break up filters (for example dash demux) relying on precise EOS signals which must be toggled at the EOS packet\n\t\t//once all previous packets have been processed\n\t\tif (!gf_fq_count(pidi->packets) && !pid->pid->filter->postponed_packets)\n\t\t\tpidi->is_end_of_stream = pid->pid->has_seen_eos;\n\t}\n\tpidi->discard_inputs = discard_on ? 1 : 0;\n\treturn GF_OK;\n}\n\nstatic char *gf_filter_pid_get_dst_string(GF_FilterSession *sess, const char *_args, Bool is_dst)\n{\n\tchar *target, *sep;\n\tchar szKey[6];\n\tu32 len;\n\tif (!_args) return NULL;\n\n\tif (is_dst)\n\t\tsprintf(szKey, \"dst%c\", sess->sep_name);\n\telse\n\t\tsprintf(szKey, \"src%c\", sess->sep_name);\n\n\ttarget = strstr(_args, szKey);\n\tif (!target) return NULL;\n\n\tsep = (char *) gf_fs_path_escape_colon(sess, target + 4);\n\ttarget += 4;\n\tif (sep) len = (u32) (sep - target);\n\telse len = (u32) strlen(target);\n\n\tchar *res = gf_malloc(sizeof(char)* (len+1));\n\tmemcpy(res, target, sizeof(char)* len);\n\tres[len]=0;\n\treturn res;\n}\n\n\nGF_EXPORT\nchar *gf_filter_pid_get_destination(GF_FilterPid *pid)\n{\n\tconst char *dst_args;\n\tchar *res;\n\tu32 i, j;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query destination on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\n\tdst_args = pid->filter->dst_args;\n\tif (!dst_args) dst_args = pid->filter->src_args;\n\tres = gf_filter_pid_get_dst_string(pid->filter->session, dst_args, GF_TRUE);\n\tif (res) return res;\n\n\t//if not set this means we have explicitly loaded the filter\n\tfor (i=0; i<pid->num_destinations; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, i);\n\n\t\tdst_args = pidi->filter->dst_args;\n\t\tif (!dst_args) dst_args = pidi->filter->src_args;\n\t\tres = gf_filter_pid_get_dst_string(pid->filter->session, dst_args, GF_TRUE);\n\t\tif (res) return res;\n\n\t\tfor (j=0; j<pidi->filter->num_output_pids; j++) {\n\t\t\tGF_FilterPid *a_pid = gf_list_get(pidi->filter->output_pids, j);\n\t\t\tchar *dst = gf_filter_pid_get_destination(a_pid);\n\t\t\tif (dst) return dst;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nchar *gf_filter_pid_get_source(GF_FilterPid *pid)\n{\n\tconst char *src_args;\n\tchar *res;\n//\tGF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query source on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\n\tsrc_args = pid->filter->src_args;\n\tif (!src_args) src_args = pid->filter->dst_args;\n\tres = gf_filter_pid_get_dst_string(pid->filter->session, src_args, GF_FALSE);\n\tif (res) return res;\n\n\t//if not set this means we have explicitly loaded the filter\n\tgf_mx_p(pid->filter->tasks_mx);\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);\n\n\t\tsrc_args = pidi->pid->filter->src_args;\n\t\tif (!src_args) src_args = pidi->pid->filter->dst_args;\n\t\tres = gf_filter_pid_get_dst_string(pid->filter->session, src_args, GF_FALSE);\n\t\tif (res) {\n\t\t\tgf_mx_v(pid->filter->tasks_mx);\n\t\t\treturn res;\n\t\t}\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n\treturn NULL;\n}\n\nGF_FilterPid *gf_filter_pid_first_pid_for_source(GF_FilterPid *pid, GF_Filter *source)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to locate PID on output PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpid = pid->pid;\n\tfor (i=0; i<pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPid *a_pid;\n\t\tGF_FilterPidInst *a_pidi = gf_list_get(pid->filter->input_pids, i);\n\t\tif (gf_filter_in_parent_chain(a_pidi->pid->filter, source))\n\t\t\treturn (GF_FilterPid *) a_pidi;\n\t\ta_pid = gf_filter_pid_first_pid_for_source((GF_FilterPid *) a_pidi, source);\n\t\tif (a_pid) return a_pid;\n\t}\n\treturn NULL;\n\n}\n\nGF_EXPORT\nvoid gf_filter_pid_discard_block(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to reset block mode on input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tif (!pid->has_seen_eos) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to reset block mode on PID %s in filter %s not in end of stream, ignoring\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tgf_mx_p(pid->filter->tasks_mx);\n\tif (pid->would_block) {\n\t\tsafe_int_dec(&pid->would_block);\n\t\tassert(pid->filter->would_block);\n\t\tsafe_int_dec(&pid->filter->would_block);\n\t}\n\tgf_mx_v(pid->filter->tasks_mx);\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_require_source_id(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set require_source_id input PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpid->require_source_id = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_min_pck_duration(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query min_pck_duration on output pid PID %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn 0;\n\t}\n\treturn pid->pid->min_pck_duration;\n}\n\nGF_EXPORT\nvoid gf_filter_pid_recompute_dts(GF_FilterPid *pid, Bool do_recompute)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set recompute_dts on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn;\n\t}\n\tpid->recompute_dts = do_recompute;\n}\n\nGF_EXPORT\nBool gf_filter_pid_is_playing(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FALSE;\n\treturn pid->pid->is_playing;\n\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_allow_direct_dispatch(GF_FilterPid *pid)\n{\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set direct dispatch mode on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n#ifndef GPAC_DISABLE_THREADS\n\tif (pid->filter->session->threads)\n\t\treturn GF_OK;\n#endif\n\tpid->direct_dispatch = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid *gf_filter_pid_get_alias_udta(GF_FilterPid *_pid)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(_pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query multi_sink original filter context on output pid %s in filter %s not allowed\\n\", _pid->pid->name, _pid->filter->name));\n\t\treturn NULL;\n\t}\n\tpidi = (GF_FilterPidInst *) _pid;\n\tif (!pidi->alias_orig) return NULL;\n\treturn pidi->alias_orig->filter_udta;\n}\n\nGF_EXPORT\nGF_Filter *gf_filter_pid_get_source_filter(GF_FilterPid *pid)\n{\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query source filter on output pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\treturn pid->pid->filter;\n}\n\nGF_EXPORT\nGF_Filter *gf_filter_pid_enum_destinations(GF_FilterPid *pid, u32 idx)\n{\n\tGF_FilterPidInst *dst_pid;\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query destination filters on input pid %s in filter %s not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (idx>=pid->num_destinations) return NULL;\n\tdst_pid = gf_list_get(pid->destinations, idx);\n\treturn dst_pid->filter;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_ignore_blocking(GF_FilterPid *pid, Bool do_ignore)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set output pid  %s in filter %s to ignore block mode not allowed\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidi = (GF_FilterPidInst *) pid;\n\tpidi->pid->ignore_blocking = do_ignore;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu64 gf_filter_pid_get_next_ts(GF_FilterPid *pid)\n{\n\tif (!pid) return GF_FILTER_NO_TS;\n\tu64 dts = pid->pid->last_pck_dts;\n\tif (dts == GF_FILTER_NO_TS)\n\t\tdts = pid->pid->last_pck_cts;\n\tif (dts == GF_FILTER_NO_TS)\n\t\treturn dts;\n\tdts += pid->pid->last_pck_dur;\n\treturn dts;\n}\n\nGF_EXPORT\nu32 gf_filter_pid_get_udta_flags(GF_FilterPid *pid)\n{\n\tif (!pid) return 0;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\treturn pid->udta_flags;\n\t}\n\treturn ((GF_FilterPidInst *)pid)->udta_flags;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_udta_flags(GF_FilterPid *pid, u32 flags)\n{\n\tif (!pid) return GF_BAD_PARAM;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tpid->udta_flags = flags;\n\t} else {\n\t\t((GF_FilterPidInst *)pid)->udta_flags = flags;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_filter_pid_has_decoder(GF_FilterPid *pid)\n{\n\tu32 i;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to query decoder presence on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_FALSE;\n\t}\n\tif (pid->pid->nb_decoder_inputs)\n\t\treturn GF_TRUE;\n\tgf_mx_p(pid->pid->filter->tasks_mx);\n\tfor (i=0; i<pid->pid->filter->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(pid->pid->filter->input_pids, i);\n\t\tif (gf_filter_pid_has_decoder((GF_FilterPid *) pidi)) {\n\t\t\tgf_mx_v(pid->pid->filter->tasks_mx);\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tgf_mx_v(pid->pid->filter->tasks_mx);\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_filter_pid_set_rt_stats(GF_FilterPid *pid, u32 rtt_ms, u32 jitter_us, u32 loss_rate)\n{\n\tGF_FilterPidInst *pidi;\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to set real-time stats on output PID %s in filter %s\\n\", pid->pid->name, pid->filter->name));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tpidi = (GF_FilterPidInst*)pid;\n\tpidi->last_rt_report = gf_sys_clock_high_res();\n\tpidi->rtt = rtt_ms;\n\tpidi->jitter = jitter_us;\n\tpidi->loss_rate = loss_rate;\n\treturn GF_OK;\n}\n\n\n#include <gpac/internal/media_dev.h>\nGF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr);\nGF_Err rfc_6381_get_codec_m4v(char *szCodec, u32 codec_id, u8 *dsi, u32 dsi_size);\nGF_Err rfc_6381_get_codec_avc(char *szCodec, u32 subtype, GF_AVCConfig *avcc);\nGF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc);\nGF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c, COLR colr);\nGF_Err rfc_6381_get_codec_vpx(char *szCodec, u32 subtype, GF_VPConfig *vpcc, COLR colr);\nGF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecoderConfigurationRecord *dovi);\nGF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc);\nGF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl);\nGF_Err rfc_6381_get_codec_uncv(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size);\nGF_Err rfc6381_codec_name_default(char *szCodec, u32 subtype, u32 codec_id);\n\n\nGF_Err gf_filter_pid_get_rfc_6381_codec_string(GF_FilterPid *pid, char *szCodec, Bool force_inband, Bool force_sbr, const GF_PropertyValue *tile_base_dcd, u32 *out_inband_forced)\n{\n\tu32 subtype=0, subtype_src=0, codec_id, stream_type;\n\ts32 mha_pl=-1;\n\tBool is_tile_base = GF_FALSE;\n\tconst GF_PropertyValue *p, *dcd, *dcd_enh, *dovi, *codec;\n\tCOLR colr;\n\n\tmemset(&colr, 0, sizeof(colr));\n\tszCodec[0] = 0;\n\tif (!pid) return GF_BAD_PARAM;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (!p) return GF_BAD_PARAM;\n\tcodec_id = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p) return GF_BAD_PARAM;\n\tstream_type = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) subtype_src = p->value.uint;\n\n\tdcd = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tdcd_enh = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\n\t// If colour information is supplied in [the colr] box, and also in the video bitstream, [the] box takes precedence\n\t{\n\t\tconst GF_PropertyValue *p1 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_PRIMARIES),\n\t\t                       *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_TRANSFER),\n\t\t                       *p3 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_MX),\n\t\t                       *p4 = gf_filter_pid_get_property(pid, GF_PROP_PID_COLR_RANGE);\n\t\tif (p1 && p2 && p3 && p4) {\n\t\t\tcolr.override = GF_TRUE;\n\t\t\tcolr.colour_primaries = p1->value.uint;\n\t\t\tcolr.transfer_characteristics = p2->value.uint;\n\t\t\tcolr.matrix_coefficients = p3->value.uint;\n\t\t\tcolr.full_range = p4->value.boolean;\n\t\t} else if (!p1 && !p2 && !p3 && !p4) {\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Incomplete upstream-filter 'colr' information. Ignoring.\\n\"));\n\t\t}\n\t}\n\n\tif (!force_inband) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\tif (p) {\n\t\t\t//input uses inband parameters, force it on output regardless of bitstream switching mode\n\t\t\tswitch (p->value.uint) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_VVI1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tforce_inband = GF_TRUE;\n\t\t\t\tif (out_inband_forced) *out_inband_forced = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcodec = gf_filter_pid_get_property(pid, GF_PROP_PID_CODEC);\n\tif (codec && (codec->type==GF_PROP_STRING) && codec->value.string) {\n\t\tconst char *codec_str = codec->value.string;\n\t\tif (codec_str[0] != '.') {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", codec_str);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!subtype_src)\n\t\t\tsubtype_src = gf_codecid_4cc_type(codec_id);\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s%s\", gf_4cc_to_str(subtype_src), codec_str);\n\t\treturn GF_OK;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean) is_tile_base = GF_TRUE;\n\n\n\tdovi = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\tif (dovi) {\n\t\tGF_Err e;\n\t\tGF_BitStream *bs = gf_bs_new(dovi->value.data.ptr, dovi->value.data.size, GF_BITSTREAM_READ);\n\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\tgf_bs_del(bs);\n\t\tif (!dvcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for Dolby Vision file (\\\"%s\\\")\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tswitch (codec_id) {\n\t\tcase GF_CODECID_HEVC:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, force_inband ? GF_ISOM_SUBTYPE_DVHE : GF_ISOM_SUBTYPE_DVH1, dvcc);\n\t\t\tbreak;\n\t\tcase GF_CODECID_AVC:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, force_inband ? GF_ISOM_SUBTYPE_DVAV : GF_ISOM_SUBTYPE_DVA1, dvcc);\n\t\t\tbreak;\n\t\tcase GF_CODECID_AV1:\n\t\t\te = rfc_6381_get_codec_dolby_vision(szCodec, GF_ISOM_SUBTYPE_DAV1, dvcc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t}\n\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\treturn e;\n\t}\n\n\tswitch (codec_id) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\t\treturn rfc_6381_get_codec_aac(szCodec, codec_id, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0, force_sbr);\n\n\tcase GF_CODECID_MPEG4_PART2:\n\t\treturn rfc_6381_get_codec_m4v(szCodec, codec_id, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0);\n\t\tbreak;\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_MVC:\n\t\tif (dcd_enh) dcd = dcd_enh;\n\t\tsubtype = (codec_id==GF_CODECID_SVC) ? GF_ISOM_SUBTYPE_SVC_H264 : GF_ISOM_SUBTYPE_MVC_H264;\n\tcase GF_CODECID_AVC:\n\t\tif (!subtype) {\n\t\t\tif (force_inband) {\n\t\t\t\tsubtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC4_H264 : GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\t} else {\n\t\t\t\tsubtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC2_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t}\n\t\t}\n\t\tif (dcd) {\n\t\t\tGF_AVCConfig *avcc = gf_odf_avc_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\t\t\tif (avcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_CODECID_LHVC:\n\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;\n\t\t//fallthrough\n\tcase GF_CODECID_HEVC_TILES:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tif (!dcd && tile_base_dcd) dcd = tile_base_dcd;\n\n\t\t//fallthrough\n\tcase GF_CODECID_HEVC:\n\t\tif (!subtype) {\n\t\t\tif (is_tile_base) {\n\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;\n\t\t\t} else if (dcd_enh) {\n\t\t\t\tif (dcd) {\n\t\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;\n\t\t\t\t} else {\n\t\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_HEV1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t\t}\n\t\t}\n\t\tif (dcd || dcd_enh) {\n\t\t\tGF_HEVCConfig *hvcc = dcd ? gf_odf_hevc_cfg_read(dcd->value.data.ptr, dcd->value.data.size, GF_FALSE) : NULL;\n\t\t\tif (hvcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);\n\t\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] HEVC config not compliant !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381]  Cannot find HEVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n#endif\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_CODECID_AV1:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_AV01;\n\n\t\tif (dcd) {\n\t\t\tGF_AV1Config *av1c = gf_odf_av1_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\t\t\tif (av1c) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_av1(szCodec, subtype, av1c, colr);\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] AV1 config not conformant\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AV1 config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_CODECID_VP8:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_VP08;\n\tcase GF_CODECID_VP9:\n\t\tif (!subtype) subtype = GF_ISOM_SUBTYPE_VP09;\n\n\t\tif (dcd) {\n\t\t\tGF_VPConfig *vpcc = gf_odf_vp_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\n\t\t\tif (vpcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc, colr);\n\t\t\t\tgf_odf_vp_cfg_del(vpcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for VP file (\\\"%s\\\").\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find VPX config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n\tcase GF_CODECID_MHAS:\n\t\tsubtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\tif (!dcd) {\n\t\t\tconst GF_PropertyValue *pl = gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\t\tif (pl) mha_pl = (s32) pl->value.uint;\n\t\t}\n\t\t//fallthrough\n\tcase GF_CODECID_MPHA:\n\t\tif (!subtype)\n\t\t\tsubtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHA1;\n\n\t\treturn rfc_6381_get_codec_mpegha(szCodec, subtype, dcd ? dcd->value.data.ptr : NULL, dcd ? dcd->value.data.size : 0, mha_pl);\n\n\tcase GF_CODECID_VVC:\n\t\tif (!subtype) {\n\t\t\tsubtype = force_inband ? GF_ISOM_SUBTYPE_VVI1 : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tif (dcd) {\n\t\t\tGF_VVCConfig *vvcc = gf_odf_vvc_cfg_read(dcd->value.data.ptr, dcd->value.data.size);\n\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.\", gf_4cc_to_str(subtype));\n\t\t\tif (vvcc) {\n\t\t\t\tGF_Err e = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);\n\t\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] No config found for VP file (\\\"%s\\\")\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find VVC config, using default %s\\n\", szCodec));\n\t\treturn GF_OK;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\treturn rfc_6381_get_codec_uncv(szCodec, subtype, dcd->value.data.ptr, dcd->value.data.size);\n\tdefault:\n\t\tsubtype = gf_codecid_4cc_type(codec_id);\n\t\tif (!subtype) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) subtype = p->value.uint;\n\t\t}\n\t\tif (!subtype && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (stream_type==GF_STREAM_VISUAL) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\t\tif (p) subtype = gf_pixel_fmt_to_qt_type(p->value.uint);\n\t\t\t}\n\t\t\telse if (stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\t\tif (p) subtype = gf_audio_fmt_to_isobmf(p->value.uint);\n\t\t\t}\n\t\t}\n\n\t\tif (!subtype) {\n\t\t\tconst char *mime = gf_codecid_mime(codec_id);\n\t\t\tif (mime) mime = strchr(mime, '/');\n\t\t\tif (mime) mime++;\n\t\t\tif (mime && mime[0] && strcmp(mime, \"octet-string\")) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known, using mime type %s\\n\", mime));\n\t\t\t\tstrcpy(szCodec, mime);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known, cannot set codec string\\n\" ));\n\t\t\tstrcpy(szCodec, \"unkn\");\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\treturn rfc6381_codec_name_default(szCodec, subtype, codec_id);\n\t}\n\treturn GF_OK;\n}\n"], "filenames": ["src/filter_core/filter_pid.c"], "buggy_code_start_loc": [65], "buggy_code_end_loc": [5947], "fixing_code_start_loc": [65], "fixing_code_end_loc": [5958], "type": "CWE-400", "message": "Denial of Service in GitHub repository gpac/gpac prior to 2.4.0.", "other": {"cve": {"id": "CVE-2023-1654", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-27T16:15:10.017", "lastModified": "2023-05-27T04:15:24.377", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Denial of Service in GitHub repository gpac/gpac prior to 2.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.0", "matchCriteriaId": "46EDD964-D166-4879-8E48-CF3AC00AF840"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/2c055153d401b8c49422971e3a0159869652d3da", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/33652b56-128f-41a7-afcc-10641f69ff14", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/2c055153d401b8c49422971e3a0159869652d3da"}}