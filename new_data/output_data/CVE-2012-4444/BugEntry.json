{"buggy_code": ["/*\n *\tIPv6 fragment reassembly\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on: net/ipv4/ip_fragment.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n *\tFixes:\n *\tAndi Kleen\tMake it work with multiple hosts.\n *\t\t\tMore RFC compliance.\n *\n *      Horst von Brand Add missing #include <linux/string.h>\n *\tAlexey Kuznetsov\tSMP races, threading, cleanup.\n *\tPatrick McHardy\t\tLRU queue of frag heads for evictor.\n *\tMitsuru KANDA @USAGI\tRegister inet6_protocol{}.\n *\tDavid Stevens and\n *\tYOSHIFUJI,H. @USAGI\tAlways remove fragment header to\n *\t\t\t\tcalculate ICV correctly.\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/inet_frag.h>\n\nstruct ip6frag_skb_cb\n{\n\tstruct inet6_skb_parm\th;\n\tint\t\t\toffset;\n};\n\n#define FRAG6_CB(skb)\t((struct ip6frag_skb_cb*)((skb)->cb))\n\n\n/*\n *\tEquivalent of ipv4 struct ipq\n */\n\nstruct frag_queue\n{\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tint\t\t\tiif;\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n};\n\nstatic struct inet_frags ip6_frags;\n\nint ip6_frag_nqueues(struct net *net)\n{\n\treturn net->ipv6.frags.nqueues;\n}\n\nint ip6_frag_mem(struct net *net)\n{\n\treturn atomic_read(&net->ipv6.frags.mem);\n}\n\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\n\t\t\t  struct net_device *dev);\n\n/*\n * callers should be careful not to use the hash value outside the ipfrag_lock\n * as doing so could race with ipfrag_hash_rnd being recalculated.\n */\nunsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}\nEXPORT_SYMBOL_GPL(inet6_hash_frag);\n\nstatic unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}\n\nint ip6_frag_match(struct inet_frag_queue *q, void *a)\n{\n\tstruct frag_queue *fq;\n\tstruct ip6_create_arg *arg = a;\n\n\tfq = container_of(q, struct frag_queue, q);\n\treturn (fq->id == arg->id && fq->user == arg->user &&\n\t\t\tipv6_addr_equal(&fq->saddr, arg->src) &&\n\t\t\tipv6_addr_equal(&fq->daddr, arg->dst));\n}\nEXPORT_SYMBOL(ip6_frag_match);\n\n/* Memory Tracking Functions. */\nstatic void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}\n\nvoid ip6_frag_init(struct inet_frag_queue *q, void *a)\n{\n\tstruct frag_queue *fq = container_of(q, struct frag_queue, q);\n\tstruct ip6_create_arg *arg = a;\n\n\tfq->id = arg->id;\n\tfq->user = arg->user;\n\tipv6_addr_copy(&fq->saddr, arg->src);\n\tipv6_addr_copy(&fq->daddr, arg->dst);\n}\nEXPORT_SYMBOL(ip6_frag_init);\n\n/* Destruction primitives. */\n\nstatic __inline__ void fq_put(struct frag_queue *fq)\n{\n\tinet_frag_put(&fq->q, &ip6_frags);\n}\n\n/* Kill fq entry. It is not destroyed immediately,\n * because caller (and someone more) holds reference count.\n */\nstatic __inline__ void fq_kill(struct frag_queue *fq)\n{\n\tinet_frag_kill(&fq->q, &ip6_frags);\n}\n\nstatic void ip6_evictor(struct net *net, struct inet6_dev *idev)\n{\n\tint evicted;\n\n\tevicted = inet_frag_evictor(&net->ipv6.frags, &ip6_frags);\n\tif (evicted)\n\t\tIP6_ADD_STATS_BH(net, idev, IPSTATS_MIB_REASMFAILS, evicted);\n}\n\nstatic void ip6_frag_expire(unsigned long data)\n{\n\tstruct frag_queue *fq;\n\tstruct net_device *dev = NULL;\n\tstruct net *net;\n\n\tfq = container_of((struct inet_frag_queue *)data, struct frag_queue, q);\n\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tfq_kill(fq);\n\n\tnet = container_of(fq->q.net, struct net, ipv6.frags);\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, fq->iif);\n\tif (!dev)\n\t\tgoto out_rcu_unlock;\n\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\n\n\t/* Don't send error if the first segment did not arrive. */\n\tif (!(fq->q.last_in & INET_FRAG_FIRST_IN) || !fq->q.fragments)\n\t\tgoto out_rcu_unlock;\n\n\t/*\n\t   But use as source device on which LAST ARRIVED\n\t   segment was received. And do not use fq->dev\n\t   pointer directly, device might already disappeared.\n\t */\n\tfq->q.fragments->dev = dev;\n\ticmpv6_send(fq->q.fragments, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\trcu_read_unlock();\nout:\n\tspin_unlock(&fq->q.lock);\n\tfq_put(fq);\n}\n\nstatic __inline__ struct frag_queue *\nfq_find(struct net *net, __be32 id, struct in6_addr *src, struct in6_addr *dst)\n{\n\tstruct inet_frag_queue *q;\n\tstruct ip6_create_arg arg;\n\tunsigned int hash;\n\n\targ.id = id;\n\targ.user = IP6_DEFRAG_LOCAL_DELIVER;\n\targ.src = src;\n\targ.dst = dst;\n\n\tread_lock(&ip6_frags.lock);\n\thash = inet6_hash_frag(id, src, dst, ip6_frags.rnd);\n\n\tq = inet_frag_find(&net->ipv6.frags, &ip6_frags, &arg, hash);\n\tif (q == NULL)\n\t\treturn NULL;\n\n\treturn container_of(q, struct frag_queue, q);\n}\n\nstatic int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* We found where to put this one.  Check for overlap with\n\t * preceding fragment, and, if needed, align things so that\n\t * any overlaps are eliminated.\n\t */\n\tif (prev) {\n\t\tint i = (FRAG6_CB(prev)->offset + prev->len) - offset;\n\n\t\tif (i > 0) {\n\t\t\toffset += i;\n\t\t\tif (end <= offset)\n\t\t\t\tgoto err;\n\t\t\tif (!pskb_pull(skb, i))\n\t\t\t\tgoto err;\n\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t}\n\n\t/* Look for overlap with succeeding segments.\n\t * If we can merge fragments, do it.\n\t */\n\twhile (next && FRAG6_CB(next)->offset < end) {\n\t\tint i = end - FRAG6_CB(next)->offset; /* overlap is 'i' bytes */\n\n\t\tif (i < next->len) {\n\t\t\t/* Eat head of the next overlapped fragment\n\t\t\t * and leave the loop. The next ones cannot overlap.\n\t\t\t */\n\t\t\tif (!pskb_pull(next, i))\n\t\t\t\tgoto err;\n\t\t\tFRAG6_CB(next)->offset += i;\t/* next fragment */\n\t\t\tfq->q.meat -= i;\n\t\t\tif (next->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tnext->ip_summed = CHECKSUM_NONE;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct sk_buff *free_it = next;\n\n\t\t\t/* Old fragment is completely overridden with\n\t\t\t * new one drop it.\n\t\t\t */\n\t\t\tnext = next->next;\n\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tfq->q.fragments = next;\n\n\t\t\tfq->q.meat -= free_it->len;\n\t\t\tfrag_kfree_skb(fq->q.net, free_it);\n\t\t}\n\t}\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n/*\n *\tCheck if this packet is complete.\n *\tReturns NULL on failure by any reason, and pointer\n *\tto current nexthdr field in reassembled frame.\n *\n *\tIt is called with locked fq, and caller must check that\n *\tqueue is eligible for reassembly i.e. it is not COMPLETE,\n *\tthe last and the first frames arrived and all the bits are here.\n */\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\n\t\t\t  struct net_device *dev)\n{\n\tstruct net *net = container_of(fq->q.net, struct net, ipv6.frags);\n\tstruct sk_buff *fp, *head = fq->q.fragments;\n\tint    payload_len;\n\tunsigned int nhoff;\n\n\tfq_kill(fq);\n\n\t/* Make the one we just received the head. */\n\tif (prev) {\n\t\thead = prev->next;\n\t\tfp = skb_clone(head, GFP_ATOMIC);\n\n\t\tif (!fp)\n\t\t\tgoto out_oom;\n\n\t\tfp->next = head->next;\n\t\tif (!fp->next)\n\t\t\tfq->q.fragments_tail = fp;\n\t\tprev->next = fp;\n\n\t\tskb_morph(head, fq->q.fragments);\n\t\thead->next = fq->q.fragments->next;\n\n\t\tkfree_skb(fq->q.fragments);\n\t\tfq->q.fragments = head;\n\t}\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC))\n\t\tgoto out_oom;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frags(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)\n\t\t\tgoto out_oom;\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_shinfo(head)->frags[i].size;\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tatomic_add(clone->truesize, &fq->q.net->mem);\n\t}\n\n\t/* We have to remove fragment header from datagram and to relocate\n\t * header in order to calculate ICV correctly. */\n\tnhoff = fq->nhoffset;\n\tskb_network_header(head)[nhoff] = skb_transport_header(head)[0];\n\tmemmove(head->head + sizeof(struct frag_hdr), head->head,\n\t\t(head->data - head->head) - sizeof(struct frag_hdr));\n\thead->mac_header += sizeof(struct frag_hdr);\n\thead->network_header += sizeof(struct frag_hdr);\n\n\tskb_shinfo(head)->frag_list = head->next;\n\tskb_reset_transport_header(head);\n\tskb_push(head, head->data - skb_network_header(head));\n\n\tfor (fp=head->next; fp; fp = fp->next) {\n\t\thead->data_len += fp->len;\n\t\thead->len += fp->len;\n\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\thead->truesize += fp->truesize;\n\t}\n\tatomic_sub(head->truesize, &fq->q.net->mem);\n\n\thead->next = NULL;\n\thead->dev = dev;\n\thead->tstamp = fq->q.stamp;\n\tipv6_hdr(head)->payload_len = htons(payload_len);\n\tIP6CB(head)->nhoff = nhoff;\n\n\t/* Yes, and fold redundant checksum back. 8) */\n\tif (head->ip_summed == CHECKSUM_COMPLETE)\n\t\thead->csum = csum_partial(skb_network_header(head),\n\t\t\t\t\t  skb_network_header_len(head),\n\t\t\t\t\t  head->csum);\n\n\trcu_read_lock();\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);\n\trcu_read_unlock();\n\tfq->q.fragments = NULL;\n\tfq->q.fragments_tail = NULL;\n\treturn 1;\n\nout_oversize:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"ip6_frag_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"ip6_frag_reasm: no memory for reassembly\\n\");\nout_fail:\n\trcu_read_lock();\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\n\trcu_read_unlock();\n\treturn -1;\n}\n\nstatic int ipv6_frag_rcv(struct sk_buff *skb)\n{\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMREQDS);\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (hdr->payload_len==0)\n\t\tgoto fail_hdr;\n\n\tif (!pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t sizeof(struct frag_hdr))))\n\t\tgoto fail_hdr;\n\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tif (!(fhdr->frag_off & htons(0xFFF9))) {\n\t\t/* It is not a fragmented frame */\n\t\tskb->transport_header += sizeof(struct frag_hdr);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMOKS);\n\n\t\tIP6CB(skb)->nhoff = (u8 *)fhdr - skb_network_header(skb);\n\t\treturn 1;\n\t}\n\n\tif (atomic_read(&net->ipv6.frags.mem) > net->ipv6.frags.high_thresh)\n\t\tip6_evictor(net, ip6_dst_idev(skb_dst(skb)));\n\n\tfq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr);\n\tif (fq != NULL) {\n\t\tint ret;\n\n\t\tspin_lock(&fq->q.lock);\n\n\t\tret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)->nhoff);\n\n\t\tspin_unlock(&fq->q.lock);\n\t\tfq_put(fq);\n\t\treturn ret;\n\t}\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n\nfail_hdr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol frag_protocol =\n{\n\t.handler\t=\tipv6_frag_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table ip6_frags_ns_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_high_thresh\",\n\t\t.data\t\t= &init_net.ipv6.frags.high_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_low_thresh\",\n\t\t.data\t\t= &init_net.ipv6.frags.low_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_time\",\n\t\t.data\t\t= &init_net.ipv6.frags.timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table ip6_frags_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_secret_interval\",\n\t\t.data\t\t= &ip6_frags.secret_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic int __net_init ip6_frags_ns_sysctl_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = ip6_frags_ns_ctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(ip6_frags_ns_ctl_table), GFP_KERNEL);\n\t\tif (table == NULL)\n\t\t\tgoto err_alloc;\n\n\t\ttable[0].data = &net->ipv6.frags.high_thresh;\n\t\ttable[1].data = &net->ipv6.frags.low_thresh;\n\t\ttable[2].data = &net->ipv6.frags.timeout;\n\t}\n\n\thdr = register_net_sysctl_table(net, net_ipv6_ctl_path, table);\n\tif (hdr == NULL)\n\t\tgoto err_reg;\n\n\tnet->ipv6.sysctl.frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->ipv6.sysctl.frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv6.sysctl.frags_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\nstatic struct ctl_table_header *ip6_ctl_header;\n\nstatic int ip6_frags_sysctl_register(void)\n{\n\tip6_ctl_header = register_net_sysctl_rotable(net_ipv6_ctl_path,\n\t\t\tip6_frags_ctl_table);\n\treturn ip6_ctl_header == NULL ? -ENOMEM : 0;\n}\n\nstatic void ip6_frags_sysctl_unregister(void)\n{\n\tunregister_net_sysctl_table(ip6_ctl_header);\n}\n#else\nstatic inline int ip6_frags_ns_sysctl_register(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n}\n\nstatic inline int ip6_frags_sysctl_register(void)\n{\n\treturn 0;\n}\n\nstatic inline void ip6_frags_sysctl_unregister(void)\n{\n}\n#endif\n\nstatic int __net_init ipv6_frags_init_net(struct net *net)\n{\n\tnet->ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnet->ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnet->ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;\n\n\tinet_frags_init_net(&net->ipv6.frags);\n\n\treturn ip6_frags_ns_sysctl_register(net);\n}\n\nstatic void __net_exit ipv6_frags_exit_net(struct net *net)\n{\n\tip6_frags_ns_sysctl_unregister(net);\n\tinet_frags_exit_net(&net->ipv6.frags, &ip6_frags);\n}\n\nstatic struct pernet_operations ip6_frags_ops = {\n\t.init = ipv6_frags_init_net,\n\t.exit = ipv6_frags_exit_net,\n};\n\nint __init ipv6_frag_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ip6_frags_sysctl_register();\n\tif (ret)\n\t\tgoto err_sysctl;\n\n\tret = register_pernet_subsys(&ip6_frags_ops);\n\tif (ret)\n\t\tgoto err_pernet;\n\n\tip6_frags.hashfn = ip6_hashfn;\n\tip6_frags.constructor = ip6_frag_init;\n\tip6_frags.destructor = NULL;\n\tip6_frags.skb_free = NULL;\n\tip6_frags.qsize = sizeof(struct frag_queue);\n\tip6_frags.match = ip6_frag_match;\n\tip6_frags.frag_expire = ip6_frag_expire;\n\tip6_frags.secret_interval = 10 * 60 * HZ;\n\tinet_frags_init(&ip6_frags);\nout:\n\treturn ret;\n\nerr_pernet:\n\tip6_frags_sysctl_unregister();\nerr_sysctl:\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tgoto out;\n}\n\nvoid ipv6_frag_exit(void)\n{\n\tinet_frags_fini(&ip6_frags);\n\tip6_frags_sysctl_unregister();\n\tunregister_pernet_subsys(&ip6_frags_ops);\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n}\n"], "fixing_code": ["/*\n *\tIPv6 fragment reassembly\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on: net/ipv4/ip_fragment.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/*\n *\tFixes:\n *\tAndi Kleen\tMake it work with multiple hosts.\n *\t\t\tMore RFC compliance.\n *\n *      Horst von Brand Add missing #include <linux/string.h>\n *\tAlexey Kuznetsov\tSMP races, threading, cleanup.\n *\tPatrick McHardy\t\tLRU queue of frag heads for evictor.\n *\tMitsuru KANDA @USAGI\tRegister inet6_protocol{}.\n *\tDavid Stevens and\n *\tYOSHIFUJI,H. @USAGI\tAlways remove fragment header to\n *\t\t\t\tcalculate ICV correctly.\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/inet_frag.h>\n\nstruct ip6frag_skb_cb\n{\n\tstruct inet6_skb_parm\th;\n\tint\t\t\toffset;\n};\n\n#define FRAG6_CB(skb)\t((struct ip6frag_skb_cb*)((skb)->cb))\n\n\n/*\n *\tEquivalent of ipv4 struct ipq\n */\n\nstruct frag_queue\n{\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tint\t\t\tiif;\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n};\n\nstatic struct inet_frags ip6_frags;\n\nint ip6_frag_nqueues(struct net *net)\n{\n\treturn net->ipv6.frags.nqueues;\n}\n\nint ip6_frag_mem(struct net *net)\n{\n\treturn atomic_read(&net->ipv6.frags.mem);\n}\n\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\n\t\t\t  struct net_device *dev);\n\n/*\n * callers should be careful not to use the hash value outside the ipfrag_lock\n * as doing so could race with ipfrag_hash_rnd being recalculated.\n */\nunsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}\nEXPORT_SYMBOL_GPL(inet6_hash_frag);\n\nstatic unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}\n\nint ip6_frag_match(struct inet_frag_queue *q, void *a)\n{\n\tstruct frag_queue *fq;\n\tstruct ip6_create_arg *arg = a;\n\n\tfq = container_of(q, struct frag_queue, q);\n\treturn (fq->id == arg->id && fq->user == arg->user &&\n\t\t\tipv6_addr_equal(&fq->saddr, arg->src) &&\n\t\t\tipv6_addr_equal(&fq->daddr, arg->dst));\n}\nEXPORT_SYMBOL(ip6_frag_match);\n\nvoid ip6_frag_init(struct inet_frag_queue *q, void *a)\n{\n\tstruct frag_queue *fq = container_of(q, struct frag_queue, q);\n\tstruct ip6_create_arg *arg = a;\n\n\tfq->id = arg->id;\n\tfq->user = arg->user;\n\tipv6_addr_copy(&fq->saddr, arg->src);\n\tipv6_addr_copy(&fq->daddr, arg->dst);\n}\nEXPORT_SYMBOL(ip6_frag_init);\n\n/* Destruction primitives. */\n\nstatic __inline__ void fq_put(struct frag_queue *fq)\n{\n\tinet_frag_put(&fq->q, &ip6_frags);\n}\n\n/* Kill fq entry. It is not destroyed immediately,\n * because caller (and someone more) holds reference count.\n */\nstatic __inline__ void fq_kill(struct frag_queue *fq)\n{\n\tinet_frag_kill(&fq->q, &ip6_frags);\n}\n\nstatic void ip6_evictor(struct net *net, struct inet6_dev *idev)\n{\n\tint evicted;\n\n\tevicted = inet_frag_evictor(&net->ipv6.frags, &ip6_frags);\n\tif (evicted)\n\t\tIP6_ADD_STATS_BH(net, idev, IPSTATS_MIB_REASMFAILS, evicted);\n}\n\nstatic void ip6_frag_expire(unsigned long data)\n{\n\tstruct frag_queue *fq;\n\tstruct net_device *dev = NULL;\n\tstruct net *net;\n\n\tfq = container_of((struct inet_frag_queue *)data, struct frag_queue, q);\n\n\tspin_lock(&fq->q.lock);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tfq_kill(fq);\n\n\tnet = container_of(fq->q.net, struct net, ipv6.frags);\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, fq->iif);\n\tif (!dev)\n\t\tgoto out_rcu_unlock;\n\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\n\n\t/* Don't send error if the first segment did not arrive. */\n\tif (!(fq->q.last_in & INET_FRAG_FIRST_IN) || !fq->q.fragments)\n\t\tgoto out_rcu_unlock;\n\n\t/*\n\t   But use as source device on which LAST ARRIVED\n\t   segment was received. And do not use fq->dev\n\t   pointer directly, device might already disappeared.\n\t */\n\tfq->q.fragments->dev = dev;\n\ticmpv6_send(fq->q.fragments, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\trcu_read_unlock();\nout:\n\tspin_unlock(&fq->q.lock);\n\tfq_put(fq);\n}\n\nstatic __inline__ struct frag_queue *\nfq_find(struct net *net, __be32 id, struct in6_addr *src, struct in6_addr *dst)\n{\n\tstruct inet_frag_queue *q;\n\tstruct ip6_create_arg arg;\n\tunsigned int hash;\n\n\targ.id = id;\n\targ.user = IP6_DEFRAG_LOCAL_DELIVER;\n\targ.src = src;\n\targ.dst = dst;\n\n\tread_lock(&ip6_frags.lock);\n\thash = inet6_hash_frag(id, src, dst, ip6_frags.rnd);\n\n\tq = inet_frag_find(&net->ipv6.frags, &ip6_frags, &arg, hash);\n\tif (q == NULL)\n\t\treturn NULL;\n\n\treturn container_of(q, struct frag_queue, q);\n}\n\nstatic int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* RFC5722, Section 4:\n\t *                                  When reassembling an IPv6 datagram, if\n\t *   one or more its constituent fragments is determined to be an\n\t *   overlapping fragment, the entire datagram (and any constituent\n\t *   fragments, including those not yet received) MUST be silently\n\t *   discarded.\n\t */\n\n\t/* Check for overlap with preceding fragment. */\n\tif (prev &&\n\t    (FRAG6_CB(prev)->offset + prev->len) - offset > 0)\n\t\tgoto discard_fq;\n\n\t/* Look for overlap with succeeding segment. */\n\tif (next && FRAG6_CB(next)->offset < end)\n\t\tgoto discard_fq;\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\ndiscard_fq:\n\tfq_kill(fq);\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n/*\n *\tCheck if this packet is complete.\n *\tReturns NULL on failure by any reason, and pointer\n *\tto current nexthdr field in reassembled frame.\n *\n *\tIt is called with locked fq, and caller must check that\n *\tqueue is eligible for reassembly i.e. it is not COMPLETE,\n *\tthe last and the first frames arrived and all the bits are here.\n */\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\n\t\t\t  struct net_device *dev)\n{\n\tstruct net *net = container_of(fq->q.net, struct net, ipv6.frags);\n\tstruct sk_buff *fp, *head = fq->q.fragments;\n\tint    payload_len;\n\tunsigned int nhoff;\n\n\tfq_kill(fq);\n\n\t/* Make the one we just received the head. */\n\tif (prev) {\n\t\thead = prev->next;\n\t\tfp = skb_clone(head, GFP_ATOMIC);\n\n\t\tif (!fp)\n\t\t\tgoto out_oom;\n\n\t\tfp->next = head->next;\n\t\tif (!fp->next)\n\t\t\tfq->q.fragments_tail = fp;\n\t\tprev->next = fp;\n\n\t\tskb_morph(head, fq->q.fragments);\n\t\thead->next = fq->q.fragments->next;\n\n\t\tkfree_skb(fq->q.fragments);\n\t\tfq->q.fragments = head;\n\t}\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN)\n\t\tgoto out_oversize;\n\n\t/* Head of list must not be cloned. */\n\tif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC))\n\t\tgoto out_oom;\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frags(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL)\n\t\t\tgoto out_oom;\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_shinfo(head)->frags[i].size;\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\t\tatomic_add(clone->truesize, &fq->q.net->mem);\n\t}\n\n\t/* We have to remove fragment header from datagram and to relocate\n\t * header in order to calculate ICV correctly. */\n\tnhoff = fq->nhoffset;\n\tskb_network_header(head)[nhoff] = skb_transport_header(head)[0];\n\tmemmove(head->head + sizeof(struct frag_hdr), head->head,\n\t\t(head->data - head->head) - sizeof(struct frag_hdr));\n\thead->mac_header += sizeof(struct frag_hdr);\n\thead->network_header += sizeof(struct frag_hdr);\n\n\tskb_shinfo(head)->frag_list = head->next;\n\tskb_reset_transport_header(head);\n\tskb_push(head, head->data - skb_network_header(head));\n\n\tfor (fp=head->next; fp; fp = fp->next) {\n\t\thead->data_len += fp->len;\n\t\thead->len += fp->len;\n\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\thead->truesize += fp->truesize;\n\t}\n\tatomic_sub(head->truesize, &fq->q.net->mem);\n\n\thead->next = NULL;\n\thead->dev = dev;\n\thead->tstamp = fq->q.stamp;\n\tipv6_hdr(head)->payload_len = htons(payload_len);\n\tIP6CB(head)->nhoff = nhoff;\n\n\t/* Yes, and fold redundant checksum back. 8) */\n\tif (head->ip_summed == CHECKSUM_COMPLETE)\n\t\thead->csum = csum_partial(skb_network_header(head),\n\t\t\t\t\t  skb_network_header_len(head),\n\t\t\t\t\t  head->csum);\n\n\trcu_read_lock();\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);\n\trcu_read_unlock();\n\tfq->q.fragments = NULL;\n\tfq->q.fragments_tail = NULL;\n\treturn 1;\n\nout_oversize:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"ip6_frag_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"ip6_frag_reasm: no memory for reassembly\\n\");\nout_fail:\n\trcu_read_lock();\n\tIP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\n\trcu_read_unlock();\n\treturn -1;\n}\n\nstatic int ipv6_frag_rcv(struct sk_buff *skb)\n{\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMREQDS);\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (hdr->payload_len==0)\n\t\tgoto fail_hdr;\n\n\tif (!pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t sizeof(struct frag_hdr))))\n\t\tgoto fail_hdr;\n\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tif (!(fhdr->frag_off & htons(0xFFF9))) {\n\t\t/* It is not a fragmented frame */\n\t\tskb->transport_header += sizeof(struct frag_hdr);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMOKS);\n\n\t\tIP6CB(skb)->nhoff = (u8 *)fhdr - skb_network_header(skb);\n\t\treturn 1;\n\t}\n\n\tif (atomic_read(&net->ipv6.frags.mem) > net->ipv6.frags.high_thresh)\n\t\tip6_evictor(net, ip6_dst_idev(skb_dst(skb)));\n\n\tfq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr);\n\tif (fq != NULL) {\n\t\tint ret;\n\n\t\tspin_lock(&fq->q.lock);\n\n\t\tret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)->nhoff);\n\n\t\tspin_unlock(&fq->q.lock);\n\t\tfq_put(fq);\n\t\treturn ret;\n\t}\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n\nfail_hdr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol frag_protocol =\n{\n\t.handler\t=\tipv6_frag_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table ip6_frags_ns_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_high_thresh\",\n\t\t.data\t\t= &init_net.ipv6.frags.high_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_low_thresh\",\n\t\t.data\t\t= &init_net.ipv6.frags.low_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_time\",\n\t\t.data\t\t= &init_net.ipv6.frags.timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table ip6_frags_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_secret_interval\",\n\t\t.data\t\t= &ip6_frags.secret_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic int __net_init ip6_frags_ns_sysctl_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = ip6_frags_ns_ctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(ip6_frags_ns_ctl_table), GFP_KERNEL);\n\t\tif (table == NULL)\n\t\t\tgoto err_alloc;\n\n\t\ttable[0].data = &net->ipv6.frags.high_thresh;\n\t\ttable[1].data = &net->ipv6.frags.low_thresh;\n\t\ttable[2].data = &net->ipv6.frags.timeout;\n\t}\n\n\thdr = register_net_sysctl_table(net, net_ipv6_ctl_path, table);\n\tif (hdr == NULL)\n\t\tgoto err_reg;\n\n\tnet->ipv6.sysctl.frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->ipv6.sysctl.frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv6.sysctl.frags_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\nstatic struct ctl_table_header *ip6_ctl_header;\n\nstatic int ip6_frags_sysctl_register(void)\n{\n\tip6_ctl_header = register_net_sysctl_rotable(net_ipv6_ctl_path,\n\t\t\tip6_frags_ctl_table);\n\treturn ip6_ctl_header == NULL ? -ENOMEM : 0;\n}\n\nstatic void ip6_frags_sysctl_unregister(void)\n{\n\tunregister_net_sysctl_table(ip6_ctl_header);\n}\n#else\nstatic inline int ip6_frags_ns_sysctl_register(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n}\n\nstatic inline int ip6_frags_sysctl_register(void)\n{\n\treturn 0;\n}\n\nstatic inline void ip6_frags_sysctl_unregister(void)\n{\n}\n#endif\n\nstatic int __net_init ipv6_frags_init_net(struct net *net)\n{\n\tnet->ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnet->ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnet->ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;\n\n\tinet_frags_init_net(&net->ipv6.frags);\n\n\treturn ip6_frags_ns_sysctl_register(net);\n}\n\nstatic void __net_exit ipv6_frags_exit_net(struct net *net)\n{\n\tip6_frags_ns_sysctl_unregister(net);\n\tinet_frags_exit_net(&net->ipv6.frags, &ip6_frags);\n}\n\nstatic struct pernet_operations ip6_frags_ops = {\n\t.init = ipv6_frags_init_net,\n\t.exit = ipv6_frags_exit_net,\n};\n\nint __init ipv6_frag_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ip6_frags_sysctl_register();\n\tif (ret)\n\t\tgoto err_sysctl;\n\n\tret = register_pernet_subsys(&ip6_frags_ops);\n\tif (ret)\n\t\tgoto err_pernet;\n\n\tip6_frags.hashfn = ip6_hashfn;\n\tip6_frags.constructor = ip6_frag_init;\n\tip6_frags.destructor = NULL;\n\tip6_frags.skb_free = NULL;\n\tip6_frags.qsize = sizeof(struct frag_queue);\n\tip6_frags.match = ip6_frag_match;\n\tip6_frags.frag_expire = ip6_frag_expire;\n\tip6_frags.secret_interval = 10 * 60 * HZ;\n\tinet_frags_init(&ip6_frags);\nout:\n\treturn ret;\n\nerr_pernet:\n\tip6_frags_sysctl_unregister();\nerr_sysctl:\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tgoto out;\n}\n\nvoid ipv6_frag_exit(void)\n{\n\tinet_frags_fini(&ip6_frags);\n\tip6_frags_sysctl_unregister();\n\tunregister_pernet_subsys(&ip6_frags_ops);\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n}\n"], "filenames": ["net/ipv6/reassembly.c"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [438], "fixing_code_start_loc": [150], "fixing_code_end_loc": [398], "type": "NVD-CWE-noinfo", "message": "The ip6_frag_queue function in net/ipv6/reassembly.c in the Linux kernel before 2.6.36 allows remote attackers to bypass intended network restrictions via overlapping IPv6 fragments.", "other": {"cve": {"id": "CVE-2012-4444", "sourceIdentifier": "secalert@redhat.com", "published": "2012-12-21T11:47:36.533", "lastModified": "2023-02-13T04:34:32.253", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ip6_frag_queue function in net/ipv6/reassembly.c in the Linux kernel before 2.6.36 allows remote attackers to bypass intended network restrictions via overlapping IPv6 fragments."}, {"lang": "es", "value": "La funci\u00f3n ip6_frag_queue en net/ipv6/reassembly.c en el kernel de Linux antes de v2.6.36 permite a atacantes remotos evitar las restricciones de red a trav\u00e9s de la superposici\u00f3n de fragmentos IPv6.\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:rc8:*:*:*:*:*:*", "versionEndIncluding": "2.6.36", "matchCriteriaId": "CE582DCD-BC73-4540-87C8-71E2C3926305"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:*:*:*:*:*:*:*", "matchCriteriaId": "10E55450-F6D9-483C-9CC8-E651E5A12AB1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc1:*:*:*:*:*:*", "matchCriteriaId": "45273823-29EA-44DE-8444-3933402C5793"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc2:*:*:*:*:*:*", "matchCriteriaId": "88F60E74-09DB-4D4A-B922-4A46EED0EC20"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc3:*:*:*:*:*:*", "matchCriteriaId": "E242D3DE-D1DC-406A-BCC3-C4380B7EC369"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc4:*:*:*:*:*:*", "matchCriteriaId": "5EE58B00-70BB-493D-ACDE-77F486984392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc4:x86_32:*:*:*:*:*", "matchCriteriaId": "06EFB3F7-2EAE-4A56-A9A1-E8C734E6B91E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc5:*:*:*:*:*:*", "matchCriteriaId": "8598D6E5-0C5C-4A31-841A-C12801DB7D91"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc6:*:*:*:*:*:*", "matchCriteriaId": "59800B0A-477B-42F8-A58A-5144F455AE01"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc7:*:*:*:*:*:*", "matchCriteriaId": "65210718-2AF2-47E5-A1A7-CE72B926F9F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30:rc8:*:*:*:*:*:*", "matchCriteriaId": "724E1180-5A91-4503-8723-C59528794884"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.1:*:*:*:*:*:*:*", "matchCriteriaId": "99AC6D46-A0BF-4F1D-88BB-03BF74FDB84F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.2:*:*:*:*:*:*:*", "matchCriteriaId": "CC40B6DE-09D9-422B-965B-7EB9F6661DEB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.3:*:*:*:*:*:*:*", "matchCriteriaId": "FEFB6E91-34CD-4FC5-A8E1-8F5760A9B4C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.4:*:*:*:*:*:*:*", "matchCriteriaId": "91170B40-4D25-4E40-8F0B-DBC1AE217F99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E28B8B9-B832-4D77-BE1A-BB5D8A678678"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.6:*:*:*:*:*:*:*", "matchCriteriaId": "56DF61F4-5DA1-4D79-B6C0-0E4DB825FB3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.7:*:*:*:*:*:*:*", "matchCriteriaId": "468745AA-0BE5-4B22-91FA-2FD350BD2F64"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.8:*:*:*:*:*:*:*", "matchCriteriaId": "FF208118-3534-47E5-9943-83EF165F1249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.9:*:*:*:*:*:*:*", "matchCriteriaId": "427E3009-A2F2-4ED2-8D1A-14938F639D2A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.30.10:*:*:*:*:*:*:*", "matchCriteriaId": "DD3663BD-4EF5-496C-A573-2639C9E72214"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:*:*:*:*:*:*:*", "matchCriteriaId": "C4033E0B-A3A1-4CC5-956A-AAA0FB905DDA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc1:*:*:*:*:*:*", "matchCriteriaId": "29C4A364-ED36-4AC8-AD1E-8BD18DD9324D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc2:*:*:*:*:*:*", "matchCriteriaId": "4049867A-E3B2-4DC1-8966-0477E6A5D582"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc3:*:*:*:*:*:*", "matchCriteriaId": "A2507858-675B-4DA2-A49E-00DB54700CF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc4:*:*:*:*:*:*", "matchCriteriaId": "0A25EA55-3F1C-440C-A383-0BB9556C9508"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc5:*:*:*:*:*:*", "matchCriteriaId": "B2665356-4EF5-4543-AD15-67FDB851DCCD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc6:*:*:*:*:*:*", "matchCriteriaId": "26E7609B-B058-496D-ACDD-7F69FBDE89E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc7:*:*:*:*:*:*", "matchCriteriaId": "210BF049-8B3C-4ACC-BF8E-2C3551477602"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc8:*:*:*:*:*:*", "matchCriteriaId": "1837F32C-80D3-4E10-AE5D-E9F5A11A434E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31:rc9:*:*:*:*:*:*", "matchCriteriaId": "4B4E132B-A69A-4CD1-B4D9-E17C4361A3AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc2:*:*:*:*:*:*:*", "matchCriteriaId": "3C86BC69-06B6-45C7-9821-45D42D44B240"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc3:*:*:*:*:*:*:*", "matchCriteriaId": "EA0353B9-907F-4B89-9104-2F4434159F0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc4:*:*:*:*:*:*:*", "matchCriteriaId": "7D1FF505-4135-4005-BD1A-3AC913FEE20A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc5:*:*:*:*:*:*:*", "matchCriteriaId": "5D31D04B-1E65-4FD6-AEED-3F365C65FCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc6:*:*:*:*:*:*:*", "matchCriteriaId": "24CFD647-3926-462F-B264-56E136B74F81"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc7:*:*:*:*:*:*:*", "matchCriteriaId": "BE71B9D7-B52E-426A-831D-ADEDC38318E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc8:*:*:*:*:*:*:*", "matchCriteriaId": "C6FFA2CD-0EC9-4FBB-93DC-80736622CFCA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc9:*:*:*:*:*:*:*", "matchCriteriaId": "B64401A9-58F5-4CB6-B0E2-A3A2B92659EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31-rc10:*:*:*:*:*:*:*", "matchCriteriaId": "89137307-D97D-4D8B-9291-21DE1E6C56D3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.1:*:*:*:*:*:*:*", "matchCriteriaId": "AC3151BF-4BEE-4415-ABA2-E6D40673E591"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.2:*:*:*:*:*:*:*", "matchCriteriaId": "1037E899-6DB3-423D-9AD0-FE79A67E9681"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.3:*:*:*:*:*:*:*", "matchCriteriaId": "E4DD2F05-F990-417A-BD6D-CD9A7EB2BD55"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.4:*:*:*:*:*:*:*", "matchCriteriaId": "0634D7FE-7685-4669-8EF9-54E99683D28E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.5:*:*:*:*:*:*:*", "matchCriteriaId": "9EEEB962-0E8D-402B-989E-96875453C609"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.6:*:*:*:*:*:*:*", "matchCriteriaId": "0042D9C4-7081-4DC2-A5B5-2649374B44F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.7:*:*:*:*:*:*:*", "matchCriteriaId": "9CD18FA2-677A-4934-88E6-0BB78D789875"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.8:*:*:*:*:*:*:*", "matchCriteriaId": "24EF19A2-A1CC-4410-8704-EF4041428383"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.9:*:*:*:*:*:*:*", "matchCriteriaId": "C9502A7E-2BFF-43A7-BF6B-ADC023BD9331"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.10:*:*:*:*:*:*:*", "matchCriteriaId": "6DC9A36E-1779-49DE-83CE-B8479CA018FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.11:*:*:*:*:*:*:*", "matchCriteriaId": "60B18050-4720-4ACB-AEE2-DEB4BFCA7B6E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.12:*:*:*:*:*:*:*", "matchCriteriaId": "9704C4B5-28F1-4F62-A389-8A9917E8E99D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.13:*:*:*:*:*:*:*", "matchCriteriaId": "6574F543-0B91-49A6-81FA-8142007BCD54"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.31.14:*:*:*:*:*:*:*", "matchCriteriaId": "4CD7F9D0-3AE3-4687-B1C9-36AD04D96F52"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:*:*:*:*:*:*:*", "matchCriteriaId": "46568A0D-F374-4DAB-9B64-FCC74A9AA07B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc1:*:*:*:*:*:*", "matchCriteriaId": "C85D4E0A-14DA-4884-AF6F-A0F54304430F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc3:*:*:*:*:*:*", "matchCriteriaId": "218DE1D1-3843-4076-9AE4-70AA0FD99B3E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc4:*:*:*:*:*:*", "matchCriteriaId": "2677114B-AF05-42EB-BBC8-FA85CD631C21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc5:*:*:*:*:*:*", "matchCriteriaId": "FA8D64E1-A700-4D9E-9063-EC3CFC1A6D98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc6:*:*:*:*:*:*", "matchCriteriaId": "1B6C0A59-556F-4579-9AD2-4ABAE01FE2CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc7:*:*:*:*:*:*", "matchCriteriaId": "DBE3083A-0FA6-4854-8F65-05E8364B3A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32:rc8:*:*:*:*:*:*", "matchCriteriaId": "57F8D95D-DC49-46B3-A460-2352D7E540EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.1:*:*:*:*:*:*:*", "matchCriteriaId": "084A2575-E5A6-43BD-8CE5-1EF628AA9ACB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.2:*:*:*:*:*:*:*", "matchCriteriaId": "041CE8AF-711C-496D-BDF2-B4AB655C0C8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.3:*:*:*:*:*:*:*", "matchCriteriaId": "FE192302-F569-4301-83F2-AEE020FB77B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.4:*:*:*:*:*:*:*", "matchCriteriaId": "2597A691-01B8-4FD2-AF71-D4BCC15C6F10"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.5:*:*:*:*:*:*:*", "matchCriteriaId": "533A03F0-D7C4-42EF-BAD7-2B5A9A9D68EC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.6:*:*:*:*:*:*:*", "matchCriteriaId": "EDBA84AD-CB87-418B-BBF7-8E910FB8FD5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.7:*:*:*:*:*:*:*", "matchCriteriaId": "A0FA9FA7-3BE3-415B-AA06-A2401B2AD8DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.8:*:*:*:*:*:*:*", "matchCriteriaId": "A93EFB49-0195-4471-9445-DA944CD55459"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.9:*:*:*:*:*:*:*", "matchCriteriaId": "075C2C0A-E5E7-412C-9B28-3E3363A2DF05"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.10:*:*:*:*:*:*:*", "matchCriteriaId": "534281D8-EAEB-4E78-8835-E6BA318BE866"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.11:*:*:*:*:*:*:*", "matchCriteriaId": "192A8675-4413-4ADD-BF9E-DFD757C76387"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.12:*:*:*:*:*:*:*", "matchCriteriaId": "1E15D428-B54A-499D-8677-63C73A2C2934"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.13:*:*:*:*:*:*:*", "matchCriteriaId": "8804EC33-1751-4493-98D7-B85F326ABAD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.14:*:*:*:*:*:*:*", "matchCriteriaId": "BC94715E-208F-421E-8FCA-81E86175C983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.15:*:*:*:*:*:*:*", "matchCriteriaId": "982071FC-873D-4C38-817B-F5853699135D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.16:*:*:*:*:*:*:*", "matchCriteriaId": "6B721839-AB4C-4DE7-834F-E790DE770066"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.17:*:*:*:*:*:*:*", "matchCriteriaId": "75965543-51D3-4809-8815-EA80BAC85C98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.18:*:*:*:*:*:*:*", "matchCriteriaId": "4CEC8F08-EE90-41CA-A30F-D34290168571"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.19:*:*:*:*:*:*:*", "matchCriteriaId": "3A23998B-F0EE-4143-A206-AFD47EC8BD2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.20:*:*:*:*:*:*:*", "matchCriteriaId": "EAB711D9-B2DE-4C8F-A03C-EFF57664416C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.21:*:*:*:*:*:*:*", "matchCriteriaId": "5A2B2D5E-FDBC-4BCE-9925-1F6D5256C237"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.22:*:*:*:*:*:*:*", "matchCriteriaId": "5BC0D45F-8619-4EB7-B074-90CD70A4BE6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.23:*:*:*:*:*:*:*", "matchCriteriaId": "F7A7996C-04D2-4B0B-A1AE-E4430DE9BB80"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.24:*:*:*:*:*:*:*", "matchCriteriaId": "FD8BC35B-8304-4B11-BD48-A8633B1D97AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.25:*:*:*:*:*:*:*", "matchCriteriaId": "44A8D565-A7EC-47CD-A72E-FBFDC6254718"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.26:*:*:*:*:*:*:*", "matchCriteriaId": "0521A4B9-8A42-41B8-AD31-BCEB90D1E58B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.27:*:*:*:*:*:*:*", "matchCriteriaId": "9428FC60-D446-46C0-9305-127BCCF11E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.28:*:*:*:*:*:*:*", "matchCriteriaId": "7D2C6313-534F-4AAE-8DE7-B15410EFAC33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.29:*:*:*:*:*:*:*", "matchCriteriaId": "38FCB9CD-1D91-4355-B00C-48F5270CB0D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.30:*:*:*:*:*:*:*", "matchCriteriaId": "66265F3F-55D1-4F73-817A-9752E13D8B4E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.31:*:*:*:*:*:*:*", "matchCriteriaId": "3D6F4940-F31E-4D1F-989E-C4FB9CA756BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.32:*:*:*:*:*:*:*", "matchCriteriaId": "CEDE0109-B00A-409A-A403-975A7657367F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.33:*:*:*:*:*:*:*", "matchCriteriaId": "EB665B30-A013-4724-B21B-1F9696CBF861"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.34:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA2632-BAA2-48BA-8DEA-AF4460D8794F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.35:*:*:*:*:*:*:*", "matchCriteriaId": "8694695B-5D4D-4136-83F4-E29F0E410613"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.36:*:*:*:*:*:*:*", "matchCriteriaId": "7C62F815-BDC3-4D56-96AA-3BCDD2F88E1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.37:*:*:*:*:*:*:*", "matchCriteriaId": "CE306F97-0BC4-472A-AF34-70F652CDA615"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.38:*:*:*:*:*:*:*", "matchCriteriaId": "D273697C-EDFD-4D0F-96C7-4EF583EB0D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.39:*:*:*:*:*:*:*", "matchCriteriaId": "3D96D53C-21FF-4BC2-B414-A0610B2C895B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.40:*:*:*:*:*:*:*", "matchCriteriaId": "0FAF66F2-4740-4B85-885A-C1B61AD463AB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.41:*:*:*:*:*:*:*", "matchCriteriaId": "A5442BAC-D654-400F-9B1C-81C36B3425E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.42:*:*:*:*:*:*:*", "matchCriteriaId": "48FB9998-A3B3-4164-B3C7-5E2D667B9B84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.43:*:*:*:*:*:*:*", "matchCriteriaId": "EA595B7C-AC9E-4A27-A96C-9C6398626C8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.44:*:*:*:*:*:*:*", "matchCriteriaId": "12DC0713-8F83-4FF4-A1E4-D4BD3273A4A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.45:*:*:*:*:*:*:*", "matchCriteriaId": "25FDE762-B5E7-43AA-8889-43FF057ECCB7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.46:*:*:*:*:*:*:*", "matchCriteriaId": "1AFC49DE-B882-4E6D-914F-AF3A4B1DED65"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.47:*:*:*:*:*:*:*", "matchCriteriaId": "BEAD1D24-AE22-40CE-97C5-530650802779"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.48:*:*:*:*:*:*:*", "matchCriteriaId": "E7267C1F-7545-47D9-A734-D1503B836182"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.49:*:*:*:*:*:*:*", "matchCriteriaId": "26A662EA-3FA9-48DD-86E6-C143CC217301"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.50:*:*:*:*:*:*:*", "matchCriteriaId": "2D341758-5A25-4ED0-AC0C-7818C10B9C09"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.51:*:*:*:*:*:*:*", "matchCriteriaId": "4E94429E-BB47-4394-AEC7-78A8DB15C14C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.52:*:*:*:*:*:*:*", "matchCriteriaId": "24710583-8DBA-49B3-A98E-2AE654AE08F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.53:*:*:*:*:*:*:*", "matchCriteriaId": "52BBD72A-ACD0-4809-A7A8-CC934F62562B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.54:*:*:*:*:*:*:*", "matchCriteriaId": "F5CF66D2-F8CB-4452-9B5C-9013BC7EEAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.55:*:*:*:*:*:*:*", "matchCriteriaId": "C873C76C-5EC2-4CEC-B10C-839CB4B13659"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.56:*:*:*:*:*:*:*", "matchCriteriaId": "CAC9316C-5E97-4F23-859F-6627FD6CC385"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.57:*:*:*:*:*:*:*", "matchCriteriaId": "B646D34E-0FF9-4EEA-A543-E1ABD1044A23"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.32.58:*:*:*:*:*:*:*", "matchCriteriaId": "80AAAE5D-0726-49E2-AF99-042DD960C3A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:*:*:*:*:*:*:*", "matchCriteriaId": "D81C2911-5781-46A4-AD27-F946BD44EAEC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DB53511-E1B0-4F81-BE9E-B52E84E9C30E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc2:*:*:*:*:*:*", "matchCriteriaId": "207306A0-19F5-4E49-945C-A5E4DD442459"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc3:*:*:*:*:*:*", "matchCriteriaId": "1DE43C00-5967-44A1-ACEB-B7AF66EEBB53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc4:*:*:*:*:*:*", "matchCriteriaId": "B33B5E4B-FCB3-4343-B992-F0ADB853754B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc5:*:*:*:*:*:*", "matchCriteriaId": "D7295BBE-A9E3-44F6-9DD6-0FD6C2591E11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc6:*:*:*:*:*:*", "matchCriteriaId": "B220EA3F-55B3-4B6E-8285-B28ADEF50138"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc7:*:*:*:*:*:*", "matchCriteriaId": "C61AB348-ACF4-4F88-AC9D-BEC63B76399C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33:rc8:*:*:*:*:*:*", "matchCriteriaId": "C3AFD58E-A261-4398-BA11-B62A091261F6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.1:*:*:*:*:*:*:*", "matchCriteriaId": "17721A7D-E955-407B-AACB-97F859CE79C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.2:*:*:*:*:*:*:*", "matchCriteriaId": "7B04F515-29A7-4D6A-AFC5-3A115F8A5918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.3:*:*:*:*:*:*:*", "matchCriteriaId": "7514928F-8992-4B8A-8AF4-E89F1CB6EFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.4:*:*:*:*:*:*:*", "matchCriteriaId": "BD6324B7-1329-4C6B-8DDB-D489250E07C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.5:*:*:*:*:*:*:*", "matchCriteriaId": "A7910FE5-E02C-4B20-9F27-F488E76BDE93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.6:*:*:*:*:*:*:*", "matchCriteriaId": "96F85BC2-54C4-4450-B3BA-A2A8EB78A81C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.7:*:*:*:*:*:*:*", "matchCriteriaId": "25E5B510-1096-42E8-8BD1-E9198D588050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.8:*:*:*:*:*:*:*", "matchCriteriaId": "29787617-FFDD-4BDE-97EB-330675B99614"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.9:*:*:*:*:*:*:*", "matchCriteriaId": "7B28D3CE-E432-4F10-BF25-D03B0D89388A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.10:*:*:*:*:*:*:*", "matchCriteriaId": "E587FF24-AA5D-454B-8928-9C3CE03C419C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.11:*:*:*:*:*:*:*", "matchCriteriaId": "9DDBAAA5-240F-4DE5-BAA1-89508BD2CD8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.12:*:*:*:*:*:*:*", "matchCriteriaId": "F5D61706-2974-4C96-8196-9F3F56F1791F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.13:*:*:*:*:*:*:*", "matchCriteriaId": "46C5D7F1-152C-435F-8694-A66D0008289B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.14:*:*:*:*:*:*:*", "matchCriteriaId": "BEA2A352-7F4F-449D-AE23-24D39BFE0DB3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.15:*:*:*:*:*:*:*", "matchCriteriaId": "D9763287-12D3-485D-9DB4-0EBBEB2858C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.16:*:*:*:*:*:*:*", "matchCriteriaId": "9CDB80CE-2F1D-47EE-AE64-EA07B0AA3C20"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.17:*:*:*:*:*:*:*", "matchCriteriaId": "E70E77F5-12EF-4E12-8D34-9C56D23CAB22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.18:*:*:*:*:*:*:*", "matchCriteriaId": "B0139175-7049-4A2D-878E-EC43325DB5B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.19:*:*:*:*:*:*:*", "matchCriteriaId": "18483901-EC47-45AD-A9EB-30591AA1247E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.33.20:*:*:*:*:*:*:*", "matchCriteriaId": "9C069C17-8314-49BA-9CF5-E5F086F49381"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:*:*:*:*:*:*:*", "matchCriteriaId": "F9F7B49B-7CDF-426C-9688-5E990846DBF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc1:*:*:*:*:*:*", "matchCriteriaId": "2033D2AE-EB00-4696-B72F-8739021D1788"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc2:*:*:*:*:*:*", "matchCriteriaId": "86D3F64C-3F27-43E0-B0D4-62CE1E1F4EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc3:*:*:*:*:*:*", "matchCriteriaId": "7927713B-5EB0-41EB-86A9-9935775162E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc4:*:*:*:*:*:*", "matchCriteriaId": "59037296-3143-4FBB-AFF7-D4FE2C85502F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc5:*:*:*:*:*:*", "matchCriteriaId": "9CA27FD5-7DBF-4C85-80A9-D523B2E4B033"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc6:*:*:*:*:*:*", "matchCriteriaId": "9711E333-A8E7-4F4B-BCFD-2023E889651A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34:rc7:*:*:*:*:*:*", "matchCriteriaId": "E04D3358-973B-42A1-8E08-2E3AE947193C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.1:*:*:*:*:*:*:*", "matchCriteriaId": "B39BF614-85CD-4C6A-877C-724FB6F5B125"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.2:*:*:*:*:*:*:*", "matchCriteriaId": "DD31EA80-D021-4E47-8FB0-E1F23E379EA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.3:*:*:*:*:*:*:*", "matchCriteriaId": "0C683054-0275-4A92-B003-9C9A5A03B6E2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.4:*:*:*:*:*:*:*", "matchCriteriaId": "A25DDBE8-9DA5-4515-AAAF-037D4D201898"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.5:*:*:*:*:*:*:*", "matchCriteriaId": "4499A795-2C87-4E0F-BFFB-63E47AE3EEB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.6:*:*:*:*:*:*:*", "matchCriteriaId": "1D11D058-0864-415A-97D6-C67BBBEB0E6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.7:*:*:*:*:*:*:*", "matchCriteriaId": "CF479FF8-8EB2-4436-89EB-FBA3EFA41184"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.8:*:*:*:*:*:*:*", "matchCriteriaId": "086028C0-0025-479A-8977-A880651D2433"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.9:*:*:*:*:*:*:*", "matchCriteriaId": "CC3435ED-DAB4-4BC0-AA30-D164258E0F0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.34.10:*:*:*:*:*:*:*", "matchCriteriaId": "798809DE-1B1E-4C0D-830B-72C549156645"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:*:*:*:*:*:*:*", "matchCriteriaId": "5480B0CF-B462-4172-9F6E-D94B451CF869"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc1:*:*:*:*:*:*", "matchCriteriaId": "17ACC235-F2C3-42B5-9244-DCCDC4704BA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc2:*:*:*:*:*:*", "matchCriteriaId": "EA4BC3D2-70FF-4EED-9DC8-B378F88F4D36"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc3:*:*:*:*:*:*", "matchCriteriaId": "A7ACC123-06D8-4A3F-8730-AA7FF6EFBD35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc4:*:*:*:*:*:*", "matchCriteriaId": "3F6891F7-2B07-4A96-A0D6-AC528B7E0DD8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc5:*:*:*:*:*:*", "matchCriteriaId": "657BCE5D-DC8B-4BE2-AED8-BC52C738F999"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35:rc6:*:*:*:*:*:*", "matchCriteriaId": "160E9402-241A-44AE-A92A-9629CA656F38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.1:*:*:*:*:*:*:*", "matchCriteriaId": "D2CD9FB1-AB83-427A-8923-97ED7ADFD63D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.2:*:*:*:*:*:*:*", "matchCriteriaId": "1B2E5B71-BF7F-426A-BE5E-0481010725E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.3:*:*:*:*:*:*:*", "matchCriteriaId": "4540D1DF-9ED8-45DB-B868-BD195DDCB8B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.4:*:*:*:*:*:*:*", "matchCriteriaId": "CB33FE45-7254-4F8D-AC22-0FEA559A8567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.5:*:*:*:*:*:*:*", "matchCriteriaId": "52E43E71-2F62-40E5-BF56-15D26806B7AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.6:*:*:*:*:*:*:*", "matchCriteriaId": "B422B61F-AE80-4F86-AACA-F86EE47983A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.7:*:*:*:*:*:*:*", "matchCriteriaId": "BDA2DB37-7A2D-400D-889E-36175DCDF3FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.8:*:*:*:*:*:*:*", "matchCriteriaId": "40C2CAA9-8EAF-43C7-B0CE-D1A09663C49B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.9:*:*:*:*:*:*:*", "matchCriteriaId": "AA1CA35C-5F52-4095-B0EA-7A22481F4360"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.10:*:*:*:*:*:*:*", "matchCriteriaId": "EDB46950-0C6F-4A13-9425-3FCAF3C09A75"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.11:*:*:*:*:*:*:*", "matchCriteriaId": "55189BDD-5644-4B48-A94E-E71977F3376F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.12:*:*:*:*:*:*:*", "matchCriteriaId": "D1DACBA1-004B-4416-A52B-235A607181AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.35.13:*:*:*:*:*:*:*", "matchCriteriaId": "45B536B6-FE29-4775-B4A6-B198A9475B19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc1:*:*:*:*:*:*", "matchCriteriaId": "DBE26099-6D2C-4FAF-B15C-CBF985D59171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2C193FF-3723-4BE9-8787-DED7D455FA8F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc3:*:*:*:*:*:*", "matchCriteriaId": "F874FE6A-968D-47E1-900A-E154E41EDAF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc4:*:*:*:*:*:*", "matchCriteriaId": "14B7B8AE-CE83-4F0E-9138-6F165D97C19F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc5:*:*:*:*:*:*", "matchCriteriaId": "B434ACFB-2B01-491A-B2E5-40FA0E11B3B1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc6:*:*:*:*:*:*", "matchCriteriaId": "CF88CADB-AB36-4633-807B-44AB3145F748"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36:rc7:*:*:*:*:*:*", "matchCriteriaId": "9D9830C2-0E2D-4A5A-B78F-5D4A4721B268"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.36", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=70789d7052239992824628db8133de08dc78e593", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00000.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1580.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/11/09/2", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1660-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1661-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=874835", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/70789d7052239992824628db8133de08dc78e593", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://media.blackhat.com/bh-eu-12/Atlasis/bh-eu-12-Atlasis-Attacking_IPv6-WP.pdf", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/70789d7052239992824628db8133de08dc78e593"}}