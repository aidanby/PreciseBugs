{"buggy_code": ["package service\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-errors/errors\"\n\tgrpc_auth \"github.com/grpc-ecosystem/go-grpc-middleware/auth\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/encrypter\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/server\"\n\t\"github.com/openfga/openfga/server/authn\"\n\t\"github.com/openfga/openfga/server/authn/oidc\"\n\t\"github.com/openfga/openfga/server/authn/presharedkey\"\n\t\"github.com/openfga/openfga/server/middleware\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/openfga/openfga/storage/caching\"\n\t\"github.com/openfga/openfga/storage/memory\"\n\t\"github.com/openfga/openfga/storage/mysql\"\n\t\"github.com/openfga/openfga/storage/postgres\"\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n)\n\nvar (\n\tErrInvalidGRPCTLSConfig = errors.New(\"'grpc.tls.cert' and 'grpc.tls.key' configs must be set\")\n\tErrInvalidHTTPTLSConfig = errors.New(\"'http.tls.cert' and 'http.tls.key' configs must be set\")\n)\n\n// DatastoreConfig defines OpenFGA server configurations for datastore specific settings.\ntype DatastoreConfig struct {\n\n\t// Engine is the datastore engine to use (e.g. 'memory', 'postgres', 'mysql')\n\tEngine string\n\tURI    string\n\n\t// MaxCacheSize is the maximum number of cache keys that the storage cache can store before evicting\n\t// old keys. The storage cache is used to cache query results for various static resources\n\t// such as type definitions.\n\tMaxCacheSize int\n}\n\n// GRPCConfig defines OpenFGA server configurations for grpc server specific settings.\ntype GRPCConfig struct {\n\tAddr string\n\tTLS  TLSConfig\n}\n\n// HTTPConfig defines OpenFGA server configurations for HTTP server specific settings.\ntype HTTPConfig struct {\n\tEnabled bool\n\tAddr    string\n\tTLS     TLSConfig\n\n\t// UpstreamTimeout is the timeout duration for proxying HTTP requests upstream\n\t// to the grpc endpoint.\n\tUpstreamTimeout time.Duration\n\n\tCORSAllowedOrigins []string `default:\"*\" split_words:\"true\"`\n\tCORSAllowedHeaders []string `default:\"*\" split_words:\"true\"`\n}\n\n// TLSConfig defines configuration specific to Transport Layer Security (TLS) settings.\ntype TLSConfig struct {\n\tEnabled  bool\n\tCertPath string `mapstructure:\"cert\"`\n\tKeyPath  string `mapstructure:\"key\"`\n}\n\n// AuthnConfig defines OpenFGA server configurations for authentication specific settings.\ntype AuthnConfig struct {\n\n\t// Method is the authentication method that should be enforced (e.g. 'none', 'preshared', 'oidc')\n\tMethod                   string\n\t*AuthnOIDCConfig         `mapstructure:\"oidc\"`\n\t*AuthnPresharedKeyConfig `mapstructure:\"preshared\"`\n}\n\n// AuthnOIDCConfig defines configurations for the 'oidc' method of authentication.\ntype AuthnOIDCConfig struct {\n\tIssuer   string\n\tAudience string\n}\n\n// AuthnPresharedKeyConfig defines configurations for the 'preshared' method of authentication.\ntype AuthnPresharedKeyConfig struct {\n\n\t// Keys define the preshared keys to verify authn tokens against.\n\tKeys []string\n}\n\n// LogConfig defines OpenFGA server configurations for log specific settings. For production we\n// recommend using the 'json' log format.\ntype LogConfig struct {\n\n\t// Format is the log format to use in the log output (e.g. 'text' or 'json')\n\tFormat string\n}\n\n// PlaygroundConfig defines OpenFGA server configurations for the Playground specific settings.\ntype PlaygroundConfig struct {\n\tEnabled bool\n\tPort    int\n}\n\n// ProfilerConfig defines server configurations specific to pprof profiling.\ntype ProfilerConfig struct {\n\tEnabled bool\n\tAddr    string\n}\n\ntype Config struct {\n\t// If you change any of these settings, please update the documentation at https://github.com/openfga/openfga.dev/blob/main/docs/content/intro/setup-openfga.mdx\n\n\t// ListObjectsDeadline defines the maximum amount of time to accumulate ListObjects results\n\t// before the server will respond. This is to protect the server from misuse of the\n\t// ListObjects endpoints.\n\tListObjectsDeadline time.Duration\n\n\t// ListObjectsMaxResults defines the maximum number of ListObjects results to accumulate\n\t// before the server will respond. This is to protect the server from misuse of the\n\t// ListObjects endpoints.\n\tListObjectsMaxResults uint32\n\n\t// MaxTuplesPerWrite defines the maximum number of tuples per Write endpoint.\n\tMaxTuplesPerWrite int\n\n\t// MaxTypesPerAuthorizationModel defines the maximum number of type definitions per authorization model for the WriteAuthorizationModel endpoint.\n\tMaxTypesPerAuthorizationModel int\n\n\t// ChangelogHorizonOffset is an offset in minutes from the current time. Changes that occur after this offset will not be included in the response of ReadChanges.\n\tChangelogHorizonOffset int\n\n\t// ResolveNodeLimit indicates how deeply nested an authorization model can be.\n\tResolveNodeLimit uint32\n\n\tDatastore  DatastoreConfig\n\tGRPC       GRPCConfig\n\tHTTP       HTTPConfig\n\tAuthn      AuthnConfig\n\tLog        LogConfig\n\tPlayground PlaygroundConfig\n\tProfiler   ProfilerConfig\n}\n\nfunc DefaultConfigWithRandomPorts() (*Config, error) {\n\tconfig := DefaultConfig()\n\n\tl, err := net.Listen(\"tcp\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.Close()\n\thttpPort := l.Addr().(*net.TCPAddr).Port\n\n\tl, err = net.Listen(\"tcp\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.Close()\n\tgrpcPort := l.Addr().(*net.TCPAddr).Port\n\n\tconfig.GRPC.Addr = fmt.Sprintf(\"0.0.0.0:%d\", grpcPort)\n\tconfig.HTTP.Addr = fmt.Sprintf(\"0.0.0.0:%d\", httpPort)\n\n\treturn config, nil\n}\n\n// DefaultConfig returns the OpenFGA server default configurations.\nfunc DefaultConfig() *Config {\n\treturn &Config{\n\t\tMaxTuplesPerWrite:             100,\n\t\tMaxTypesPerAuthorizationModel: 100,\n\t\tChangelogHorizonOffset:        0,\n\t\tResolveNodeLimit:              25,\n\t\tListObjectsDeadline:           3 * time.Second, // there is a 3-second timeout elsewhere\n\t\tListObjectsMaxResults:         1000,\n\t\tDatastore: DatastoreConfig{\n\t\t\tEngine:       \"memory\",\n\t\t\tMaxCacheSize: 100000,\n\t\t},\n\t\tGRPC: GRPCConfig{\n\t\t\tAddr: \"0.0.0.0:8081\",\n\t\t\tTLS:  TLSConfig{Enabled: false},\n\t\t},\n\t\tHTTP: HTTPConfig{\n\t\t\tEnabled:            true,\n\t\t\tAddr:               \"0.0.0.0:8080\",\n\t\t\tTLS:                TLSConfig{Enabled: false},\n\t\t\tUpstreamTimeout:    5 * time.Second,\n\t\t\tCORSAllowedOrigins: []string{\"*\"},\n\t\t\tCORSAllowedHeaders: []string{\"*\"},\n\t\t},\n\t\tAuthn: AuthnConfig{\n\t\t\tMethod:                  \"none\",\n\t\t\tAuthnPresharedKeyConfig: &AuthnPresharedKeyConfig{},\n\t\t\tAuthnOIDCConfig:         &AuthnOIDCConfig{},\n\t\t},\n\t\tLog: LogConfig{\n\t\t\tFormat: \"text\",\n\t\t},\n\t\tPlayground: PlaygroundConfig{\n\t\t\tEnabled: true,\n\t\t\tPort:    3000,\n\t\t},\n\t\tProfiler: ProfilerConfig{\n\t\t\tEnabled: false,\n\t\t\tAddr:    \":3001\",\n\t\t},\n\t}\n}\n\n// GetServiceConfig returns the OpenFGA server configuration based on the values provided in the server's 'config.yaml' file.\n// The 'config.yaml' file is loaded from '/etc/openfga', '$HOME/.openfga', or the current working directory. If no configuration\n// file is present, the default values are returned.\nfunc GetServiceConfig() (*Config, error) {\n\n\tconfig := DefaultConfig()\n\n\tviper.SetConfigName(\"config\")\n\tviper.SetConfigType(\"yaml\")\n\n\tconfigPaths := []string{\"/etc/openfga\", \"$HOME/.openfga\", \".\"}\n\tfor _, path := range configPaths {\n\t\tviper.AddConfigPath(path)\n\t}\n\tviper.SetEnvPrefix(\"OPENFGA\")\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\tviper.AutomaticEnv()\n\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\t_, ok := err.(viper.ConfigFileNotFoundError)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"failed to load server config: %w\", err)\n\t\t}\n\t}\n\n\tif err := viper.Unmarshal(config); err != nil {\n\t\treturn nil, errors.Errorf(\"failed to unmarshal server config: %w\", err)\n\t}\n\n\treturn config, nil\n}\n\ntype service struct {\n\tserver        *server.Server\n\tgrpcAddr      netip.AddrPort\n\thttpAddr      netip.AddrPort\n\tdatastore     storage.OpenFGADatastore\n\tauthenticator authn.Authenticator\n}\n\nfunc (s *service) Close(ctx context.Context) error {\n\ts.authenticator.Close()\n\n\treturn s.datastore.Close(ctx)\n}\n\nfunc (s *service) Run(ctx context.Context) error {\n\treturn s.server.Run(ctx)\n}\n\n// GetHTTPAddrPort returns the configured or auto-assigned port that the underlying HTTP service is running on.\nfunc (s *service) GetHTTPAddrPort() netip.AddrPort {\n\treturn s.httpAddr\n}\n\n// GetGRPCAddrPort returns the configured or auto-assigned port that the underlying grpc service is running on.\nfunc (s *service) GetGRPCAddrPort() netip.AddrPort {\n\treturn s.grpcAddr\n}\n\nfunc BuildService(config *Config, logger logger.Logger) (*service, error) {\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\ttokenEncoder := encoder.NewTokenEncoder(encrypter.NewNoopEncrypter(), encoder.NewBase64Encoder())\n\n\tvar datastore storage.OpenFGADatastore\n\tvar err error\n\tswitch config.Datastore.Engine {\n\tcase \"memory\":\n\t\tdatastore = memory.New(tracer, config.MaxTuplesPerWrite, config.MaxTypesPerAuthorizationModel)\n\tcase \"mysql\":\n\t\topts := []mysql.MySQLOption{\n\t\t\tmysql.WithLogger(logger),\n\t\t\tmysql.WithTracer(tracer),\n\t\t}\n\n\t\tdatastore, err = mysql.NewMySQLDatastore(config.Datastore.URI, opts...)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Errorf(\"failed to initialize mysql datastore: %v\", err)\n\t\t}\n\tcase \"postgres\":\n\t\topts := []postgres.PostgresOption{\n\t\t\tpostgres.WithLogger(logger),\n\t\t\tpostgres.WithTracer(tracer),\n\t\t}\n\n\t\tdatastore, err = postgres.NewPostgresDatastore(config.Datastore.URI, opts...)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Errorf(\"failed to initialize postgres datastore: %v\", err)\n\t\t}\n\tdefault:\n\t\treturn nil, errors.Errorf(\"storage engine '%s' is unsupported\", config.Datastore.Engine)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"using '%v' storage engine\", config.Datastore.Engine))\n\n\tvar grpcTLSConfig *server.TLSConfig\n\tif config.GRPC.TLS.Enabled {\n\t\tif config.GRPC.TLS.CertPath == \"\" || config.GRPC.TLS.KeyPath == \"\" {\n\t\t\treturn nil, ErrInvalidGRPCTLSConfig\n\t\t}\n\t\tgrpcTLSConfig = &server.TLSConfig{\n\t\t\tCertPath: config.GRPC.TLS.CertPath,\n\t\t\tKeyPath:  config.GRPC.TLS.KeyPath,\n\t\t}\n\t\tlogger.Info(\"grpc TLS is enabled, serving connections using the provided certificate\")\n\t} else {\n\t\tlogger.Warn(\"grpc TLS is disabled, serving connections using insecure plaintext\")\n\t}\n\n\tvar httpTLSConfig *server.TLSConfig\n\tif config.HTTP.TLS.Enabled {\n\t\tif config.HTTP.TLS.CertPath == \"\" || config.HTTP.TLS.KeyPath == \"\" {\n\t\t\treturn nil, ErrInvalidHTTPTLSConfig\n\t\t}\n\t\thttpTLSConfig = &server.TLSConfig{\n\t\t\tCertPath: config.HTTP.TLS.CertPath,\n\t\t\tKeyPath:  config.HTTP.TLS.KeyPath,\n\t\t}\n\t\tlogger.Info(\"HTTP TLS is enabled, serving HTTP connections using the provided certificate\")\n\t} else {\n\t\tlogger.Warn(\"HTTP TLS is disabled, serving connections using insecure plaintext\")\n\t}\n\n\tvar authenticator authn.Authenticator\n\tswitch config.Authn.Method {\n\tcase \"none\":\n\t\tlogger.Warn(\"authentication is disabled\")\n\t\tauthenticator = authn.NoopAuthenticator{}\n\tcase \"preshared\":\n\t\tlogger.Info(\"using 'preshared' authentication\")\n\t\tauthenticator, err = presharedkey.NewPresharedKeyAuthenticator(config.Authn.Keys)\n\tcase \"oidc\":\n\t\tlogger.Info(\"using 'oidc' authentication\")\n\t\tauthenticator, err = oidc.NewRemoteOidcAuthenticator(config.Authn.Issuer, config.Authn.Audience)\n\tdefault:\n\t\treturn nil, errors.Errorf(\"unsupported authentication method '%v'\", config.Authn.Method)\n\t}\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to initialize authenticator: %v\", err)\n\t}\n\n\tinterceptors := []grpc.UnaryServerInterceptor{\n\t\tgrpc_auth.UnaryServerInterceptor(middleware.AuthFunc(authenticator)),\n\t\tmiddleware.NewErrorLoggingInterceptor(logger),\n\t}\n\n\tgrpcHostAddr, grpcHostPort, err := net.SplitHostPort(config.GRPC.Addr)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"`grpc.addr` config must be in the form [host]:port\")\n\t}\n\n\tif grpcHostAddr == \"\" {\n\t\tgrpcHostAddr = \"0.0.0.0\"\n\t}\n\n\tgrpcAddr, err := netip.ParseAddrPort(fmt.Sprintf(\"%s:%s\", grpcHostAddr, grpcHostPort))\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to parse the 'grpc.addr' config: %v\", err)\n\t}\n\n\thttpHostAddr, httpHostPort, err := net.SplitHostPort(config.HTTP.Addr)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"`http.addr` config must be in the form [host]:port\")\n\t}\n\n\tif httpHostAddr == \"\" {\n\t\thttpHostAddr = \"0.0.0.0\"\n\t}\n\n\thttpAddr, err := netip.ParseAddrPort(fmt.Sprintf(\"%s:%s\", httpHostAddr, httpHostPort))\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to parse the 'http.addr' config: %v\", err)\n\t}\n\n\topenFgaServer, err := server.New(&server.Dependencies{\n\t\tDatastore:    caching.NewCachedOpenFGADatastore(datastore, config.Datastore.MaxCacheSize),\n\t\tTracer:       tracer,\n\t\tLogger:       logger,\n\t\tMeter:        meter,\n\t\tTokenEncoder: tokenEncoder,\n\t}, &server.Config{\n\t\tGRPCServer: server.GRPCServerConfig{\n\t\t\tAddr:      grpcAddr,\n\t\t\tTLSConfig: grpcTLSConfig,\n\t\t},\n\t\tHTTPServer: server.HTTPServerConfig{\n\t\t\tEnabled:            config.HTTP.Enabled,\n\t\t\tAddr:               httpAddr,\n\t\t\tTLSConfig:          httpTLSConfig,\n\t\t\tUpstreamTimeout:    config.HTTP.UpstreamTimeout,\n\t\t\tCORSAllowedOrigins: config.HTTP.CORSAllowedOrigins,\n\t\t\tCORSAllowedHeaders: config.HTTP.CORSAllowedHeaders,\n\t\t},\n\t\tResolveNodeLimit:       config.ResolveNodeLimit,\n\t\tChangelogHorizonOffset: config.ChangelogHorizonOffset,\n\t\tListObjectsDeadline:    config.ListObjectsDeadline,\n\t\tListObjectsMaxResults:  config.ListObjectsMaxResults,\n\t\tUnaryInterceptors:      interceptors,\n\t\tMuxOptions:             nil,\n\t})\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to initialize openfga server: %v\", err)\n\t}\n\n\treturn &service{\n\t\tserver:        openFgaServer,\n\t\tgrpcAddr:      grpcAddr,\n\t\thttpAddr:      httpAddr,\n\t\tdatastore:     datastore,\n\t\tauthenticator: authenticator,\n\t}, nil\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/go-errors/errors\"\n\t\"github.com/hashicorp/go-retryablehttp\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/server/authn/mocks\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/tidwall/gjson\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc\"\n\tgrpcbackoff \"google.golang.org/grpc/backoff\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\thealthv1pb \"google.golang.org/grpc/health/grpc_health_v1\"\n)\n\nfunc TestMain(m *testing.M) {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"../../..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tos.Exit(m.Run())\n}\n\nfunc ensureServiceUp(t *testing.T, s *service, transportCredentials credentials.TransportCredentials, httpHealthCheck bool) {\n\tt.Helper()\n\n\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tcreds := insecure.NewCredentials()\n\tif transportCredentials != nil {\n\t\tcreds = transportCredentials\n\t}\n\n\tdialOpts := []grpc.DialOption{\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithConnectParams(grpc.ConnectParams{Backoff: grpcbackoff.DefaultConfig}),\n\t}\n\n\tconn, err := grpc.DialContext(\n\t\ttimeoutCtx,\n\t\tfmt.Sprintf(\"localhost:%d\", s.GetGRPCAddrPort().Port()),\n\t\tdialOpts...,\n\t)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\n\tclient := healthv1pb.NewHealthClient(conn)\n\n\tpolicy := backoff.NewExponentialBackOff()\n\tpolicy.MaxElapsedTime = 10 * time.Second\n\n\terr = backoff.Retry(func() error {\n\t\tresp, err := client.Check(timeoutCtx, &healthv1pb.HealthCheckRequest{\n\t\t\tService: openfgapb.OpenFGAService_ServiceDesc.ServiceName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif resp.GetStatus() != healthv1pb.HealthCheckResponse_SERVING {\n\t\t\treturn errors.Errorf(\"not serving\")\n\t\t}\n\n\t\treturn nil\n\t}, policy)\n\trequire.NoError(t, err)\n\n\tif httpHealthCheck {\n\t\t_, err = retryablehttp.NewClient().Get(fmt.Sprintf(\"http://localhost:%d/healthz\", s.GetHTTPAddrPort().Port()))\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc genCert(t *testing.T, template, parent *x509.Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (*x509.Certificate, []byte) {\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)\n\trequire.NoError(t, err)\n\n\tcert, err := x509.ParseCertificate(certBytes)\n\trequire.NoError(t, err)\n\n\tblock := &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: certBytes,\n\t}\n\n\treturn cert, pem.EncodeToMemory(block)\n}\n\nfunc genCACert(t *testing.T) (*x509.Certificate, []byte, *rsa.PrivateKey) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\trequire.NoError(t, err)\n\n\tvar rootTemplate = &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(1),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t\tMaxPathLen:            2,\n\t\tNotBefore:             time.Now().Add(-time.Minute),\n\t\tNotAfter:              time.Now().Add(time.Hour),\n\t\tSubject: pkix.Name{\n\t\t\tCountry:      []string{\"Earth\"},\n\t\t\tOrganization: []string{\"Starfleet\"},\n\t\t},\n\t\tDNSNames: []string{\"localhost\"},\n\t}\n\n\trootCert, rootPEM := genCert(t, rootTemplate, rootTemplate, &priv.PublicKey, priv)\n\n\treturn rootCert, rootPEM, priv\n}\n\nfunc genServerCert(t *testing.T, caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, []byte, *rsa.PrivateKey) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\trequire.NoError(t, err)\n\n\tvar template = &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(1),\n\t\tKeyUsage:              x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  false,\n\t\tNotBefore:             time.Now().Add(-time.Minute),\n\t\tNotAfter:              time.Now().Add(time.Hour),\n\t\tSubject: pkix.Name{\n\t\t\tCountry:      []string{\"Earth\"},\n\t\t\tOrganization: []string{\"Starfleet\"},\n\t\t},\n\t\tDNSNames: []string{\"localhost\"},\n\t}\n\n\tserverCert, serverPEM := genCert(t, template, caCert, &priv.PublicKey, caKey)\n\n\treturn serverCert, serverPEM, priv\n}\n\nfunc writeToTempFile(t *testing.T, data []byte) *os.File {\n\tfile, err := os.CreateTemp(\"\", \"openfga_tls_test\")\n\trequire.NoError(t, err)\n\n\t_, err = file.Write(data)\n\trequire.NoError(t, err)\n\n\treturn file\n}\n\ntype certHandle struct {\n\tcaCert         *x509.Certificate\n\tserverCertFile string\n\tserverKeyFile  string\n}\n\nfunc (c certHandle) Clean() {\n\tos.Remove(c.serverCertFile)\n\tos.Remove(c.serverKeyFile)\n}\n\n// createCertsAndKeys generates a self-signed root CA certificate and a server certificate and server key. It will write\n// the PEM encoded server certificate and server key to temporary files. It is the responsibility of the caller\n// to delete these files by calling `Clean` on the returned `certHandle`.\nfunc createCertsAndKeys(t *testing.T) certHandle {\n\tcaCert, _, caKey := genCACert(t)\n\t_, serverPEM, serverKey := genServerCert(t, caCert, caKey)\n\tserverCertFile := writeToTempFile(t, serverPEM)\n\tserverKeyFile := writeToTempFile(t, pem.EncodeToMemory(\n\t\t&pem.Block{\n\t\t\tType:  \"RSA PRIVATE KEY\",\n\t\t\tBytes: x509.MarshalPKCS1PrivateKey(serverKey),\n\t\t},\n\t))\n\n\treturn certHandle{\n\t\tcaCert:         caCert,\n\t\tserverCertFile: serverCertFile.Name(),\n\t\tserverKeyFile:  serverKeyFile.Name(),\n\t}\n}\n\ntype authTest struct {\n\t_name         string\n\tauthHeader    string\n\texpectedError string\n}\n\nfunc TestBuildServiceWithNoAuth(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err, \"Failed to build server and/or datastore\")\n\tservice.Close(context.Background())\n}\n\nfunc TestBuildServiceWithPresharedKeyAuthenticationFailsIfZeroKeys(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{}\n\n\t_, err = BuildService(config, logger.NewNoopLogger())\n\trequire.EqualError(t, err, \"failed to initialize authenticator: invalid auth configuration, please specify at least one key\")\n}\n\nfunc TestBuildServiceWithPresharedKeyAuthentication(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{\n\t\tKeys: []string{\"KEYONE\", \"KEYTWO\"},\n\t}\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttests := []authTest{{\n\t\t_name:         \"Header with incorrect key fails\",\n\t\tauthHeader:    \"Bearer incorrectkey\",\n\t\texpectedError: \"unauthenticated\",\n\t}, {\n\t\t_name:         \"Missing header fails\",\n\t\tauthHeader:    \"\",\n\t\texpectedError: \"missing bearer token\",\n\t}, {\n\t\t_name:         \"Correct key one succeeds\",\n\t\tauthHeader:    \"Bearer KEYONE\",\n\t\texpectedError: \"\",\n\t}, {\n\t\t_name:         \"Correct key two succeeds\",\n\t\tauthHeader:    \"Bearer KEYTWO\",\n\t\texpectedError: \"\",\n\t}}\n\n\tretryClient := retryablehttp.NewClient()\n\tfor _, test := range tests {\n\t\tt.Run(test._name, func(t *testing.T) {\n\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n\t\t\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treq.Header.Set(\"authorization\", test.authHeader)\n\n\t\t\tres, err := retryClient.Do(req)\n\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n\n\t\t\tdefer res.Body.Close()\n\t\t\tbody, err := io.ReadAll(res.Body)\n\t\t\trequire.NoError(t, err, \"Failed to read response\")\n\n\t\t\tstringBody := string(body)\n\n\t\t\tif test.expectedError == \"\" && strings.Contains(stringBody, \"code\") {\n\t\t\t\tt.Fatalf(\"Expected no error but got '%v'\", stringBody)\n\t\t\t}\n\n\t\t\tif !strings.Contains(stringBody, test.expectedError) && test.expectedError != \"\" {\n\t\t\t\tt.Fatalf(\"Expected '%v' to contain '%v'\", stringBody, test.expectedError)\n\t\t\t}\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, service.Close(ctx))\n\trequire.NoError(t, g.Wait())\n}\n\nfunc TestHTTPServerWithCORS(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{\n\t\tKeys: []string{\"KEYONE\", \"KEYTWO\"},\n\t}\n\tconfig.HTTP.CORSAllowedOrigins = []string{\"http://openfga.dev\", \"http://localhost\"}\n\tconfig.HTTP.CORSAllowedHeaders = []string{\"Origin\", \"Accept\", \"Content-Type\", \"X-Requested-With\", \"Authorization\", \"X-Custom-Header\"}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttype args struct {\n\t\torigin string\n\t\theader string\n\t}\n\ttype want struct {\n\t\torigin string\n\t\theader string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"Good Origin\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Authorization, X-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Authorization, X-Custom-Header\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Bad Origin\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://openfga.example\",\n\t\t\t\theader: \"X-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"\",\n\t\t\t\theader: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Bad Header\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Bad-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"\",\n\t\t\t\theader: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tclient := retryablehttp.NewClient()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n\t\t\treq, err := retryablehttp.NewRequest(\"OPTIONS\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treq.Header.Set(\"Origin\", test.args.origin)\n\t\t\treq.Header.Set(\"Access-Control-Request-Method\", \"OPTIONS\")\n\t\t\treq.Header.Set(\"Access-Control-Request-Headers\", test.args.header)\n\n\t\t\tres, err := client.Do(req)\n\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n\t\t\tdefer res.Body.Close()\n\n\t\t\torigin := res.Header.Get(\"Access-Control-Allow-Origin\")\n\t\t\tacceptedHeader := res.Header.Get(\"Access-Control-Allow-Headers\")\n\t\t\trequire.Equal(t, test.want.origin, origin)\n\n\t\t\trequire.Equal(t, test.want.header, acceptedHeader)\n\n\t\t\t_, err = io.ReadAll(res.Body)\n\t\t\trequire.NoError(t, err, \"Failed to read response\")\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, g.Wait())\n\trequire.NoError(t, service.Close(ctx))\n\n}\n\nfunc TestBuildServerWithOIDCAuthentication(t *testing.T) {\n\tconst localOIDCServerURL = \"http://localhost:8083\"\n\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"oidc\"\n\tconfig.Authn.AuthnOIDCConfig = &AuthnOIDCConfig{\n\t\tAudience: \"openfga.dev\",\n\t\tIssuer:   localOIDCServerURL,\n\t}\n\n\ttrustedIssuerServer, err := mocks.NewMockOidcServer(localOIDCServerURL)\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttrustedToken, err := trustedIssuerServer.GetToken(\"openfga.dev\", \"some-user\")\n\trequire.NoError(t, err)\n\n\ttests := []authTest{{\n\t\t_name:         \"Header with invalid token fails\",\n\t\tauthHeader:    \"Bearer incorrecttoken\",\n\t\texpectedError: \"invalid bearer token\",\n\t}, {\n\t\t_name:         \"Missing header fails\",\n\t\tauthHeader:    \"\",\n\t\texpectedError: \"missing bearer token\",\n\t}, {\n\t\t_name:         \"Correct token succeeds\",\n\t\tauthHeader:    \"Bearer \" + trustedToken,\n\t\texpectedError: \"\",\n\t}}\n\n\tretryClient := retryablehttp.NewClient()\n\tfor _, test := range tests {\n\t\tt.Run(test._name, func(t *testing.T) {\n\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n\t\t\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treq.Header.Set(\"authorization\", test.authHeader)\n\n\t\t\tres, err := retryClient.Do(req)\n\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n\n\t\t\tdefer res.Body.Close()\n\t\t\tbody, err := io.ReadAll(res.Body)\n\t\t\trequire.NoError(t, err, \"Failed to read response\")\n\n\t\t\tstringBody := string(body)\n\t\t\tif test.expectedError == \"\" && strings.Contains(stringBody, \"code\") {\n\t\t\t\tt.Fatalf(\"Expected no error but got %v\", stringBody)\n\t\t\t}\n\n\t\t\tif !strings.Contains(stringBody, test.expectedError) && test.expectedError != \"\" {\n\t\t\t\tt.Fatalf(\"Expected %v to contain %v\", stringBody, test.expectedError)\n\t\t\t}\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, service.Close(ctx))\n\trequire.NoError(t, g.Wait())\n}\n\nfunc TestTLSFailureSettings(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"failing to set http cert path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled: true,\n\t\t\tKeyPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidHTTPTLSConfig)\n\t})\n\n\tt.Run(\"failing to set grpc cert path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled: true,\n\t\t\tKeyPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidGRPCTLSConfig)\n\t})\n\n\tt.Run(\"failing to set http key path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidHTTPTLSConfig)\n\t})\n\n\tt.Run(\"failing to set grpc key path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidGRPCTLSConfig)\n\t})\n}\n\nfunc TestHTTPServingTLS(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"enable HTTP TLS is false, even with keys set, will serve plaintext\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, true)\n\n\t\tcancel()\n\t\trequire.NoError(t, g.Wait())\n\t\trequire.NoError(t, service.Close(ctx))\n\t})\n\n\tt.Run(\"enable HTTP TLS is true will serve HTTP TLS\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, false)\n\n\t\tcertPool := x509.NewCertPool()\n\t\tcertPool.AddCert(certsAndKeys.caCert)\n\t\tclient := retryablehttp.NewClient()\n\t\tclient.HTTPClient.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tRootCAs: certPool,\n\t\t\t},\n\t\t}\n\n\t\t_, err = client.Get(fmt.Sprintf(\"https://localhost:%d/healthz\", service.GetHTTPAddrPort().Port()))\n\t\trequire.NoError(t, err)\n\n\t\tcancel()\n\t\trequire.NoError(t, g.Wait())\n\t\trequire.NoError(t, service.Close(ctx))\n\t})\n\n}\n\nfunc TestGRPCServingTLS(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"enable grpc TLS is false, even with keys set, will serve plaintext\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\t\tconfig.HTTP.Enabled = false\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, false)\n\n\t\tcancel()\n\t\trequire.NoError(t, service.Close(ctx))\n\t\trequire.NoError(t, g.Wait())\n\t})\n\n\tt.Run(\"enable grpc TLS is true will serve grpc TLS\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\t\tconfig.HTTP.Enabled = false\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tcertPool := x509.NewCertPool()\n\t\tcertPool.AddCert(certsAndKeys.caCert)\n\t\tcreds := credentials.NewClientTLSFromCert(certPool, \"\")\n\n\t\tensureServiceUp(t, service, creds, false)\n\n\t\tcancel()\n\t\trequire.NoError(t, service.Close(ctx))\n\t\trequire.NoError(t, g.Wait())\n\t})\n}\n\nfunc TestHTTPServerDisabled(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.HTTP.Enabled = false\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, false)\n\n\t_, err = http.Get(\"http://localhost:8080/healthz\")\n\trequire.Error(t, err)\n\trequire.ErrorContains(t, err, \"dial tcp [::1]:8080: connect: connection refused\")\n\n\tcancel()\n}\n\nfunc TestHTTPServerEnabled(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.HTTP.Enabled = true\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\tcancel()\n}\n\nfunc TestDefaultConfig(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tjsonSchema, err := os.ReadFile(\".config-schema.json\")\n\trequire.NoError(t, err)\n\n\tres := gjson.ParseBytes(jsonSchema)\n\n\tval := res.Get(\"properties.datastore.properties.engine.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Datastore.Engine)\n\n\tval = res.Get(\"properties.datastore.properties.maxCacheSize.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.Datastore.MaxCacheSize)\n\n\tval = res.Get(\"properties.grpc.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.GRPC.Addr)\n\n\tval = res.Get(\"properties.http.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.HTTP.Enabled)\n\n\tval = res.Get(\"properties.http.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.HTTP.Addr)\n\n\tval = res.Get(\"properties.playground.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.Playground.Enabled)\n\n\tval = res.Get(\"properties.playground.properties.port.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.Playground.Port)\n\n\tval = res.Get(\"properties.profiler.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.Profiler.Enabled)\n\n\tval = res.Get(\"properties.profiler.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Profiler.Addr)\n\n\tval = res.Get(\"properties.authn.properties.method.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Authn.Method)\n\n\tval = res.Get(\"properties.log.properties.format.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Log.Format)\n\n\tval = res.Get(\"properties.maxTuplesPerWrite.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.MaxTuplesPerWrite)\n\n\tval = res.Get(\"properties.maxTypesPerAuthorizationModel.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.MaxTypesPerAuthorizationModel)\n\n\tval = res.Get(\"properties.changelogHorizonOffset.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ChangelogHorizonOffset)\n\n\tval = res.Get(\"properties.resolveNodeLimit.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ResolveNodeLimit)\n\n\tval = res.Get(\"properties.grpc.properties.tls.$ref\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, \"#/definitions/tls\", val.String())\n\n\tval = res.Get(\"properties.http.properties.tls.$ref\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, \"#/definitions/tls\", val.String())\n\n\tval = res.Get(\"definitions.tls.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.GRPC.TLS.Enabled)\n\trequire.Equal(t, val.Bool(), config.HTTP.TLS.Enabled)\n\n\tval = res.Get(\"properties.listObjectsDeadline.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.ListObjectsDeadline.String())\n\n\tval = res.Get(\"properties.listObjectsMaxResults.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ListObjectsMaxResults)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc NewErrorLoggingInterceptor(logger logger.Logger) grpc.UnaryServerInterceptor {\n\treturn func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\tresp, err := handler(ctx, req)\n\t\tif err != nil {\n\t\t\tvar e error\n\t\t\tif internalError, ok := err.(serverErrors.InternalError); ok {\n\t\t\t\te = internalError.Internal()\n\t\t\t}\n\t\t\tlogger.Error(\"grpc_error\", zap.Error(e), zap.String(\"public_error\", err.Error()))\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn resp, nil\n\t}\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/netip\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/go-errors/errors\"\n\tgrpc_validator \"github.com/grpc-ecosystem/go-grpc-middleware/validator\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\thttpmiddleware \"github.com/openfga/openfga/internal/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/gateway\"\n\t\"github.com/openfga/openfga/server/health\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/rs/cors\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\thealthv1pb \"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/grpc/status\"\n)\n\nconst (\n\tAuthorizationModelIDHeader = \"openfga-authorization-model-id\"\n)\n\nvar (\n\tErrNilTokenEncoder = errors.Errorf(\"tokenEncoder must be a non-nil interface value\")\n\tErrNilTransport    = errors.Errorf(\"transport must be a non-nil interface value\")\n)\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgapb.UnimplementedOpenFGAServiceServer\n\n\ttracer    trace.Tracer\n\tmeter     metric.Meter\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n\tencoder   encoder.Encoder\n\tconfig    *Config\n\ttransport gateway.Transport\n\n\tdefaultServeMuxOpts []runtime.ServeMuxOption\n}\n\ntype Dependencies struct {\n\tDatastore storage.OpenFGADatastore\n\tTracer    trace.Tracer\n\tMeter     metric.Meter\n\tLogger    logger.Logger\n\tTransport gateway.Transport\n\n\t// TokenEncoder is the encoder used to encode continuation tokens for paginated views.\n\t// Defaults to a base64 encoder if none is provided.\n\tTokenEncoder encoder.Encoder\n}\n\ntype Config struct {\n\tGRPCServer             GRPCServerConfig\n\tHTTPServer             HTTPServerConfig\n\tResolveNodeLimit       uint32\n\tChangelogHorizonOffset int\n\tListObjectsDeadline    time.Duration\n\tListObjectsMaxResults  uint32\n\tUnaryInterceptors      []grpc.UnaryServerInterceptor\n\tMuxOptions             []runtime.ServeMuxOption\n}\n\ntype GRPCServerConfig struct {\n\tAddr      netip.AddrPort\n\tTLSConfig *TLSConfig\n}\n\ntype HTTPServerConfig struct {\n\tEnabled            bool\n\tAddr               netip.AddrPort\n\tUpstreamTimeout    time.Duration\n\tTLSConfig          *TLSConfig\n\tCORSAllowedOrigins []string\n\tCORSAllowedHeaders []string\n}\n\ntype TLSConfig struct {\n\tCertPath string\n\tKeyPath  string\n}\n\n// New creates a new Server which uses the supplied backends\n// for managing data.\nfunc New(dependencies *Dependencies, config *Config) (*Server, error) {\n\ttokenEncoder := dependencies.TokenEncoder\n\tif tokenEncoder == nil {\n\t\ttokenEncoder = encoder.NewBase64Encoder()\n\t} else {\n\t\tt := reflect.TypeOf(tokenEncoder)\n\t\tif reflect.ValueOf(tokenEncoder) == reflect.Zero(t) {\n\t\t\treturn nil, ErrNilTokenEncoder\n\t\t}\n\t}\n\n\ttransport := dependencies.Transport\n\tif transport == nil {\n\t\ttransport = gateway.NewRPCTransport(dependencies.Logger)\n\t} else {\n\t\tt := reflect.TypeOf(transport)\n\t\tif reflect.ValueOf(transport) == reflect.Zero(t) {\n\t\t\treturn nil, ErrNilTransport\n\t\t}\n\t}\n\n\tserver := &Server{\n\t\ttracer:    dependencies.Tracer,\n\t\tmeter:     dependencies.Meter,\n\t\tlogger:    dependencies.Logger,\n\t\tdatastore: dependencies.Datastore,\n\t\tencoder:   tokenEncoder,\n\t\ttransport: transport,\n\t\tconfig:    config,\n\t\tdefaultServeMuxOpts: []runtime.ServeMuxOption{\n\t\t\truntime.WithForwardResponseOption(httpmiddleware.HTTPResponseModifier),\n\t\t\truntime.WithErrorHandler(func(c context.Context, sr *runtime.ServeMux, mm runtime.Marshaler, w http.ResponseWriter, r *http.Request, e error) {\n\t\t\t\tintCode := serverErrors.ConvertToEncodedErrorCode(status.Convert(e))\n\t\t\t\thttpmiddleware.CustomHTTPErrorHandler(c, w, r, serverErrors.NewEncodedError(intCode, e.Error()))\n\t\t\t}),\n\t\t\truntime.WithStreamErrorHandler(func(ctx context.Context, e error) *status.Status {\n\t\t\t\tintCode := serverErrors.ConvertToEncodedErrorCode(status.Convert(e))\n\t\t\t\tencodedErr := serverErrors.NewEncodedError(intCode, e.Error())\n\t\t\t\treturn status.Convert(&encodedErr)\n\t\t\t}),\n\t\t},\n\t}\n\n\terrors.MaxStackDepth = logger.MaxDepthBacktraceStack\n\n\treturn server, nil\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequest) (*openfgapb.ListObjectsResponse, error) {\n\tstoreID := req.GetStoreId()\n\ttargetObjectType := req.GetType()\n\n\tctx, span := s.tracer.Start(ctx, \"listObjects\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"objectType\", Value: attribute.StringValue(targetObjectType)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tTracer:                s.tracer,\n\t\tMeter:                 s.meter,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treturn q.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 targetObjectType,\n\t\tRelation:             req.Relation,\n\t\tUser:                 req.User,\n\t})\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest, srv openfgapb.OpenFGAService_StreamedListObjectsServer) error {\n\tstoreID := req.GetStoreId()\n\tctx := context.Background()\n\tctx, span := s.tracer.Start(ctx, \"streamedListObjects\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"objectType\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tTracer:                s.tracer,\n\t\tMeter:                 s.meter,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treq.AuthorizationModelId = modelID\n\treturn q.ExecuteStreamed(ctx, req, srv)\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgapb.ReadRequest) (*openfgapb.ReadResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewReadQuery(s.datastore, s.tracer, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgapb.ReadRequest{\n\t\tStoreId:              store,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t\tPageSize:             req.GetPageSize(),\n\t\tContinuationToken:    req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) ReadTuples(ctx context.Context, req *openfgapb.ReadTuplesRequest) (*openfgapb.ReadTuplesResponse, error) {\n\n\tctx, span := s.tracer.Start(ctx, \"readTuples\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadTuplesQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgapb.WriteRequest) (*openfgapb.WriteResponse, error) {\n\tstore := req.GetStoreId()\n\tctx, span := s.tracer.Start(ctx, \"write\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.tracer, s.logger)\n\treturn cmd.Execute(ctx, &openfgapb.WriteRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewCheckQuery(s.datastore, s.tracer, s.meter, s.logger, s.config.ResolveNodeLimit)\n\n\tres, err := q.Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tTupleKey:             tk,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tTrace:                req.GetTrace(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewExpandQuery(s.datastore, s.tracer, s.logger)\n\treturn q.Execute(ctx, &openfgapb.ExpandRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgapb.ReadAuthorizationModelRequest) (*openfgapb.ReadAuthorizationModelResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"writeAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgapb.ReadAuthorizationModelsRequest) (*openfgapb.ReadAuthorizationModelsResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAuthorizationModels\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgapb.WriteAssertionsRequest) (*openfgapb.WriteAssertionsResponse, error) {\n\tstore := req.GetStoreId()\n\tctx, span := s.tracer.Start(ctx, \"writeAssertions\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgapb.WriteAssertionsRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgapb.ReadAssertionsRequest) (*openfgapb.ReadAssertionsResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAssertions\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgapb.ReadChangesRequest) (*openfgapb.ReadChangesResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.tracer, s.logger, s.encoder, s.config.ChangelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgapb.CreateStoreRequest) (*openfgapb.CreateStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"createStore\")\n\tdefer span.End()\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgapb.DeleteStoreRequest) (*openfgapb.DeleteStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"deleteStore\")\n\tdefer span.End()\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgapb.GetStoreRequest) (*openfgapb.GetStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"getStore\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgapb.ListStoresRequest) (*openfgapb.ListStoresResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"listStores\")\n\tdefer span.End()\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// Run starts server execution, and blocks until complete, returning any server errors. To close the\n// server cancel the provided ctx.\nfunc (s *Server) Run(ctx context.Context) error {\n\n\tinterceptors := []grpc.UnaryServerInterceptor{\n\t\tgrpc_validator.UnaryServerInterceptor(),\n\t}\n\tinterceptors = append(interceptors, s.config.UnaryInterceptors...)\n\n\topts := []grpc.ServerOption{\n\t\tgrpc.ChainUnaryInterceptor(interceptors...),\n\t}\n\n\tif s.config.GRPCServer.TLSConfig != nil {\n\t\tcreds, err := credentials.NewServerTLSFromFile(s.config.GRPCServer.TLSConfig.CertPath, s.config.GRPCServer.TLSConfig.KeyPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\t// nosemgrep: grpc-server-insecure-connection\n\tgrpcServer := grpc.NewServer(opts...)\n\topenfgapb.RegisterOpenFGAServiceServer(grpcServer, s)\n\thealthServer := &health.Checker{TargetService: s, TargetServiceName: openfgapb.OpenFGAService_ServiceDesc.ServiceName}\n\thealthv1pb.RegisterHealthServer(grpcServer, healthServer)\n\treflection.Register(grpcServer)\n\n\trpcAddr := s.config.GRPCServer.Addr\n\tlis, err := net.Listen(\"tcp\", rpcAddr.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\ts.logger.Error(\"failed to start grpc server\", logger.Error(err))\n\t\t}\n\t}()\n\n\ts.logger.Info(fmt.Sprintf(\"grpc server listening on '%s'...\", rpcAddr))\n\n\tvar httpServer *http.Server\n\tif s.config.HTTPServer.Enabled {\n\t\t// Set a request timeout.\n\t\truntime.DefaultContextTimeout = s.config.HTTPServer.UpstreamTimeout\n\n\t\tdialOpts := []grpc.DialOption{\n\t\t\tgrpc.WithBlock(),\n\t\t\tgrpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),\n\t\t}\n\t\tif s.config.GRPCServer.TLSConfig != nil {\n\t\t\tcreds, err := credentials.NewClientTLSFromFile(s.config.GRPCServer.TLSConfig.CertPath, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))\n\t\t} else {\n\t\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t\t}\n\n\t\ttimeoutCtx, cancel := context.WithTimeout(ctx, 3*time.Second)\n\t\tdefer cancel()\n\n\t\tconn, err := grpc.DialContext(timeoutCtx, rpcAddr.String(), dialOpts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer conn.Close()\n\n\t\thealthClient := healthv1pb.NewHealthClient(conn)\n\n\t\tmuxOpts := []runtime.ServeMuxOption{\n\t\t\truntime.WithHealthzEndpoint(healthClient),\n\t\t}\n\t\tmuxOpts = append(muxOpts, s.defaultServeMuxOpts...) // register the defaults first\n\t\tmuxOpts = append(muxOpts, s.config.MuxOptions...)   // any provided options override defaults if they are duplicates\n\n\t\tmux := runtime.NewServeMux(muxOpts...)\n\n\t\tif err := openfgapb.RegisterOpenFGAServiceHandler(ctx, mux, conn); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thttpServer = &http.Server{\n\t\t\tAddr: s.config.HTTPServer.Addr.String(),\n\t\t\tHandler: cors.New(cors.Options{\n\t\t\t\tAllowedOrigins:   s.config.HTTPServer.CORSAllowedOrigins,\n\t\t\t\tAllowCredentials: true,\n\t\t\t\tAllowedHeaders:   s.config.HTTPServer.CORSAllowedHeaders,\n\t\t\t\tAllowedMethods: []string{http.MethodGet, http.MethodPost,\n\t\t\t\t\thttp.MethodHead, http.MethodPatch, http.MethodDelete, http.MethodPut},\n\t\t\t}).Handler(mux),\n\t\t}\n\n\t\tgo func() {\n\t\t\ts.logger.Info(fmt.Sprintf(\"HTTP server listening on '%s'...\", httpServer.Addr))\n\n\t\t\tvar err error\n\t\t\tif s.config.HTTPServer.TLSConfig != nil {\n\t\t\t\terr = httpServer.ListenAndServeTLS(s.config.HTTPServer.TLSConfig.CertPath, s.config.HTTPServer.TLSConfig.KeyPath)\n\t\t\t} else {\n\t\t\t\terr = httpServer.ListenAndServe()\n\t\t\t}\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\ts.logger.ErrorWithContext(ctx, \"HTTP server closed with unexpected error\", logger.Error(err))\n\t\t\t}\n\t\t}()\n\t}\n\n\t<-ctx.Done()\n\ts.logger.InfoWithContext(ctx, \"Termination signal received! Gracefully shutting down\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif httpServer != nil {\n\t\tif err := httpServer.Shutdown(ctx); err != nil {\n\t\t\ts.logger.ErrorWithContext(ctx, \"HTTP server shutdown failed\", logger.Error(err))\n\t\t\treturn err\n\t\t}\n\t}\n\n\tgrpcServer.GracefulStop()\n\n\treturn nil\n}\n\n// Util to find the latest authorization model ID to be used through all the request lifecycle.\n// This allows caching of types. If the user inserts a new authorization model and doesn't\n// provide this field (which should be rate limited more aggressively) the in-flight requests won't be\n// affected and newer calls will use the updated authorization model.\nfunc (s *Server) resolveAuthorizationModelID(ctx context.Context, store, modelID string) (string, error) {\n\tctx, span := s.tracer.Start(ctx, \"resolveAuthorizationModelID\")\n\tdefer span.End()\n\n\tvar err error\n\tif modelID != \"\" {\n\t\tif !id.IsValid(modelID) {\n\t\t\treturn \"\", serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\t} else {\n\t\tif modelID, err = s.datastore.FindLatestAuthorizationModelID(ctx, store); err != nil {\n\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\treturn \"\", serverErrors.LatestAuthorizationModelNotFound(store)\n\t\t\t}\n\t\t\treturn \"\", serverErrors.HandleError(\"\", err)\n\t\t}\n\t}\n\n\ts.transport.SetHeader(ctx, AuthorizationModelIDHeader, modelID)\n\n\treturn modelID, nil\n}\n"], "fixing_code": ["package service\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-errors/errors\"\n\tgrpc_auth \"github.com/grpc-ecosystem/go-grpc-middleware/auth\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/encrypter\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/server\"\n\t\"github.com/openfga/openfga/server/authn\"\n\t\"github.com/openfga/openfga/server/authn/oidc\"\n\t\"github.com/openfga/openfga/server/authn/presharedkey\"\n\t\"github.com/openfga/openfga/server/middleware\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/openfga/openfga/storage/caching\"\n\t\"github.com/openfga/openfga/storage/memory\"\n\t\"github.com/openfga/openfga/storage/mysql\"\n\t\"github.com/openfga/openfga/storage/postgres\"\n\t\"github.com/spf13/viper\"\n\t\"google.golang.org/grpc\"\n)\n\nvar (\n\tErrInvalidGRPCTLSConfig = errors.New(\"'grpc.tls.cert' and 'grpc.tls.key' configs must be set\")\n\tErrInvalidHTTPTLSConfig = errors.New(\"'http.tls.cert' and 'http.tls.key' configs must be set\")\n)\n\n// DatastoreConfig defines OpenFGA server configurations for datastore specific settings.\ntype DatastoreConfig struct {\n\n\t// Engine is the datastore engine to use (e.g. 'memory', 'postgres', 'mysql')\n\tEngine string\n\tURI    string\n\n\t// MaxCacheSize is the maximum number of cache keys that the storage cache can store before evicting\n\t// old keys. The storage cache is used to cache query results for various static resources\n\t// such as type definitions.\n\tMaxCacheSize int\n}\n\n// GRPCConfig defines OpenFGA server configurations for grpc server specific settings.\ntype GRPCConfig struct {\n\tAddr string\n\tTLS  TLSConfig\n}\n\n// HTTPConfig defines OpenFGA server configurations for HTTP server specific settings.\ntype HTTPConfig struct {\n\tEnabled bool\n\tAddr    string\n\tTLS     TLSConfig\n\n\t// UpstreamTimeout is the timeout duration for proxying HTTP requests upstream\n\t// to the grpc endpoint.\n\tUpstreamTimeout time.Duration\n\n\tCORSAllowedOrigins []string `default:\"*\" split_words:\"true\"`\n\tCORSAllowedHeaders []string `default:\"*\" split_words:\"true\"`\n}\n\n// TLSConfig defines configuration specific to Transport Layer Security (TLS) settings.\ntype TLSConfig struct {\n\tEnabled  bool\n\tCertPath string `mapstructure:\"cert\"`\n\tKeyPath  string `mapstructure:\"key\"`\n}\n\n// AuthnConfig defines OpenFGA server configurations for authentication specific settings.\ntype AuthnConfig struct {\n\n\t// Method is the authentication method that should be enforced (e.g. 'none', 'preshared', 'oidc')\n\tMethod                   string\n\t*AuthnOIDCConfig         `mapstructure:\"oidc\"`\n\t*AuthnPresharedKeyConfig `mapstructure:\"preshared\"`\n}\n\n// AuthnOIDCConfig defines configurations for the 'oidc' method of authentication.\ntype AuthnOIDCConfig struct {\n\tIssuer   string\n\tAudience string\n}\n\n// AuthnPresharedKeyConfig defines configurations for the 'preshared' method of authentication.\ntype AuthnPresharedKeyConfig struct {\n\n\t// Keys define the preshared keys to verify authn tokens against.\n\tKeys []string\n}\n\n// LogConfig defines OpenFGA server configurations for log specific settings. For production we\n// recommend using the 'json' log format.\ntype LogConfig struct {\n\n\t// Format is the log format to use in the log output (e.g. 'text' or 'json')\n\tFormat string\n}\n\n// PlaygroundConfig defines OpenFGA server configurations for the Playground specific settings.\ntype PlaygroundConfig struct {\n\tEnabled bool\n\tPort    int\n}\n\n// ProfilerConfig defines server configurations specific to pprof profiling.\ntype ProfilerConfig struct {\n\tEnabled bool\n\tAddr    string\n}\n\ntype Config struct {\n\t// If you change any of these settings, please update the documentation at https://github.com/openfga/openfga.dev/blob/main/docs/content/intro/setup-openfga.mdx\n\n\t// ListObjectsDeadline defines the maximum amount of time to accumulate ListObjects results\n\t// before the server will respond. This is to protect the server from misuse of the\n\t// ListObjects endpoints.\n\tListObjectsDeadline time.Duration\n\n\t// ListObjectsMaxResults defines the maximum number of ListObjects results to accumulate\n\t// before the server will respond. This is to protect the server from misuse of the\n\t// ListObjects endpoints.\n\tListObjectsMaxResults uint32\n\n\t// MaxTuplesPerWrite defines the maximum number of tuples per Write endpoint.\n\tMaxTuplesPerWrite int\n\n\t// MaxTypesPerAuthorizationModel defines the maximum number of type definitions per authorization model for the WriteAuthorizationModel endpoint.\n\tMaxTypesPerAuthorizationModel int\n\n\t// ChangelogHorizonOffset is an offset in minutes from the current time. Changes that occur after this offset will not be included in the response of ReadChanges.\n\tChangelogHorizonOffset int\n\n\t// ResolveNodeLimit indicates how deeply nested an authorization model can be.\n\tResolveNodeLimit uint32\n\n\tDatastore  DatastoreConfig\n\tGRPC       GRPCConfig\n\tHTTP       HTTPConfig\n\tAuthn      AuthnConfig\n\tLog        LogConfig\n\tPlayground PlaygroundConfig\n\tProfiler   ProfilerConfig\n}\n\nfunc DefaultConfigWithRandomPorts() (*Config, error) {\n\tconfig := DefaultConfig()\n\n\tl, err := net.Listen(\"tcp\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.Close()\n\thttpPort := l.Addr().(*net.TCPAddr).Port\n\n\tl, err = net.Listen(\"tcp\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer l.Close()\n\tgrpcPort := l.Addr().(*net.TCPAddr).Port\n\n\tconfig.GRPC.Addr = fmt.Sprintf(\"0.0.0.0:%d\", grpcPort)\n\tconfig.HTTP.Addr = fmt.Sprintf(\"0.0.0.0:%d\", httpPort)\n\n\treturn config, nil\n}\n\n// DefaultConfig returns the OpenFGA server default configurations.\nfunc DefaultConfig() *Config {\n\treturn &Config{\n\t\tMaxTuplesPerWrite:             100,\n\t\tMaxTypesPerAuthorizationModel: 100,\n\t\tChangelogHorizonOffset:        0,\n\t\tResolveNodeLimit:              25,\n\t\tListObjectsDeadline:           3 * time.Second, // there is a 3-second timeout elsewhere\n\t\tListObjectsMaxResults:         1000,\n\t\tDatastore: DatastoreConfig{\n\t\t\tEngine:       \"memory\",\n\t\t\tMaxCacheSize: 100000,\n\t\t},\n\t\tGRPC: GRPCConfig{\n\t\t\tAddr: \"0.0.0.0:8081\",\n\t\t\tTLS:  TLSConfig{Enabled: false},\n\t\t},\n\t\tHTTP: HTTPConfig{\n\t\t\tEnabled:            true,\n\t\t\tAddr:               \"0.0.0.0:8080\",\n\t\t\tTLS:                TLSConfig{Enabled: false},\n\t\t\tUpstreamTimeout:    5 * time.Second,\n\t\t\tCORSAllowedOrigins: []string{\"*\"},\n\t\t\tCORSAllowedHeaders: []string{\"*\"},\n\t\t},\n\t\tAuthn: AuthnConfig{\n\t\t\tMethod:                  \"none\",\n\t\t\tAuthnPresharedKeyConfig: &AuthnPresharedKeyConfig{},\n\t\t\tAuthnOIDCConfig:         &AuthnOIDCConfig{},\n\t\t},\n\t\tLog: LogConfig{\n\t\t\tFormat: \"text\",\n\t\t},\n\t\tPlayground: PlaygroundConfig{\n\t\t\tEnabled: true,\n\t\t\tPort:    3000,\n\t\t},\n\t\tProfiler: ProfilerConfig{\n\t\t\tEnabled: false,\n\t\t\tAddr:    \":3001\",\n\t\t},\n\t}\n}\n\n// GetServiceConfig returns the OpenFGA server configuration based on the values provided in the server's 'config.yaml' file.\n// The 'config.yaml' file is loaded from '/etc/openfga', '$HOME/.openfga', or the current working directory. If no configuration\n// file is present, the default values are returned.\nfunc GetServiceConfig() (*Config, error) {\n\n\tconfig := DefaultConfig()\n\n\tviper.SetConfigName(\"config\")\n\tviper.SetConfigType(\"yaml\")\n\n\tconfigPaths := []string{\"/etc/openfga\", \"$HOME/.openfga\", \".\"}\n\tfor _, path := range configPaths {\n\t\tviper.AddConfigPath(path)\n\t}\n\tviper.SetEnvPrefix(\"OPENFGA\")\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\tviper.AutomaticEnv()\n\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\t_, ok := err.(viper.ConfigFileNotFoundError)\n\t\tif !ok {\n\t\t\treturn nil, errors.Errorf(\"failed to load server config: %w\", err)\n\t\t}\n\t}\n\n\tif err := viper.Unmarshal(config); err != nil {\n\t\treturn nil, errors.Errorf(\"failed to unmarshal server config: %w\", err)\n\t}\n\n\treturn config, nil\n}\n\ntype service struct {\n\tserver        *server.Server\n\tgrpcAddr      netip.AddrPort\n\thttpAddr      netip.AddrPort\n\tdatastore     storage.OpenFGADatastore\n\tauthenticator authn.Authenticator\n}\n\nfunc (s *service) Close(ctx context.Context) error {\n\ts.authenticator.Close()\n\n\treturn s.datastore.Close(ctx)\n}\n\nfunc (s *service) Run(ctx context.Context) error {\n\treturn s.server.Run(ctx)\n}\n\n// GetHTTPAddrPort returns the configured or auto-assigned port that the underlying HTTP service is running on.\nfunc (s *service) GetHTTPAddrPort() netip.AddrPort {\n\treturn s.httpAddr\n}\n\n// GetGRPCAddrPort returns the configured or auto-assigned port that the underlying grpc service is running on.\nfunc (s *service) GetGRPCAddrPort() netip.AddrPort {\n\treturn s.grpcAddr\n}\n\nfunc BuildService(config *Config, logger logger.Logger) (*service, error) {\n\ttracer := telemetry.NewNoopTracer()\n\tmeter := telemetry.NewNoopMeter()\n\ttokenEncoder := encoder.NewTokenEncoder(encrypter.NewNoopEncrypter(), encoder.NewBase64Encoder())\n\n\tvar datastore storage.OpenFGADatastore\n\tvar err error\n\tswitch config.Datastore.Engine {\n\tcase \"memory\":\n\t\tdatastore = memory.New(tracer, config.MaxTuplesPerWrite, config.MaxTypesPerAuthorizationModel)\n\tcase \"mysql\":\n\t\topts := []mysql.MySQLOption{\n\t\t\tmysql.WithLogger(logger),\n\t\t\tmysql.WithTracer(tracer),\n\t\t}\n\n\t\tdatastore, err = mysql.NewMySQLDatastore(config.Datastore.URI, opts...)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Errorf(\"failed to initialize mysql datastore: %v\", err)\n\t\t}\n\tcase \"postgres\":\n\t\topts := []postgres.PostgresOption{\n\t\t\tpostgres.WithLogger(logger),\n\t\t\tpostgres.WithTracer(tracer),\n\t\t}\n\n\t\tdatastore, err = postgres.NewPostgresDatastore(config.Datastore.URI, opts...)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Errorf(\"failed to initialize postgres datastore: %v\", err)\n\t\t}\n\tdefault:\n\t\treturn nil, errors.Errorf(\"storage engine '%s' is unsupported\", config.Datastore.Engine)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"using '%v' storage engine\", config.Datastore.Engine))\n\n\tvar grpcTLSConfig *server.TLSConfig\n\tif config.GRPC.TLS.Enabled {\n\t\tif config.GRPC.TLS.CertPath == \"\" || config.GRPC.TLS.KeyPath == \"\" {\n\t\t\treturn nil, ErrInvalidGRPCTLSConfig\n\t\t}\n\t\tgrpcTLSConfig = &server.TLSConfig{\n\t\t\tCertPath: config.GRPC.TLS.CertPath,\n\t\t\tKeyPath:  config.GRPC.TLS.KeyPath,\n\t\t}\n\t\tlogger.Info(\"grpc TLS is enabled, serving connections using the provided certificate\")\n\t} else {\n\t\tlogger.Warn(\"grpc TLS is disabled, serving connections using insecure plaintext\")\n\t}\n\n\tvar httpTLSConfig *server.TLSConfig\n\tif config.HTTP.TLS.Enabled {\n\t\tif config.HTTP.TLS.CertPath == \"\" || config.HTTP.TLS.KeyPath == \"\" {\n\t\t\treturn nil, ErrInvalidHTTPTLSConfig\n\t\t}\n\t\thttpTLSConfig = &server.TLSConfig{\n\t\t\tCertPath: config.HTTP.TLS.CertPath,\n\t\t\tKeyPath:  config.HTTP.TLS.KeyPath,\n\t\t}\n\t\tlogger.Info(\"HTTP TLS is enabled, serving HTTP connections using the provided certificate\")\n\t} else {\n\t\tlogger.Warn(\"HTTP TLS is disabled, serving connections using insecure plaintext\")\n\t}\n\n\tvar authenticator authn.Authenticator\n\tswitch config.Authn.Method {\n\tcase \"none\":\n\t\tlogger.Warn(\"authentication is disabled\")\n\t\tauthenticator = authn.NoopAuthenticator{}\n\tcase \"preshared\":\n\t\tlogger.Info(\"using 'preshared' authentication\")\n\t\tauthenticator, err = presharedkey.NewPresharedKeyAuthenticator(config.Authn.Keys)\n\tcase \"oidc\":\n\t\tlogger.Info(\"using 'oidc' authentication\")\n\t\tauthenticator, err = oidc.NewRemoteOidcAuthenticator(config.Authn.Issuer, config.Authn.Audience)\n\tdefault:\n\t\treturn nil, errors.Errorf(\"unsupported authentication method '%v'\", config.Authn.Method)\n\t}\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to initialize authenticator: %v\", err)\n\t}\n\n\tunaryServerInterceptors := []grpc.UnaryServerInterceptor{\n\t\tgrpc_auth.UnaryServerInterceptor(middleware.AuthFunc(authenticator)),\n\t\tmiddleware.NewErrorLoggingInterceptor(logger),\n\t}\n\n\tstreamingServerInterceptors := []grpc.StreamServerInterceptor{\n\t\tgrpc_auth.StreamServerInterceptor(middleware.AuthFunc(authenticator)),\n\t\tmiddleware.NewStreamingErrorLoggingInterceptor(logger),\n\t}\n\n\tgrpcHostAddr, grpcHostPort, err := net.SplitHostPort(config.GRPC.Addr)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"`grpc.addr` config must be in the form [host]:port\")\n\t}\n\n\tif grpcHostAddr == \"\" {\n\t\tgrpcHostAddr = \"0.0.0.0\"\n\t}\n\n\tgrpcAddr, err := netip.ParseAddrPort(fmt.Sprintf(\"%s:%s\", grpcHostAddr, grpcHostPort))\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to parse the 'grpc.addr' config: %v\", err)\n\t}\n\n\thttpHostAddr, httpHostPort, err := net.SplitHostPort(config.HTTP.Addr)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"`http.addr` config must be in the form [host]:port\")\n\t}\n\n\tif httpHostAddr == \"\" {\n\t\thttpHostAddr = \"0.0.0.0\"\n\t}\n\n\thttpAddr, err := netip.ParseAddrPort(fmt.Sprintf(\"%s:%s\", httpHostAddr, httpHostPort))\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to parse the 'http.addr' config: %v\", err)\n\t}\n\n\topenFgaServer, err := server.New(&server.Dependencies{\n\t\tDatastore:    caching.NewCachedOpenFGADatastore(datastore, config.Datastore.MaxCacheSize),\n\t\tTracer:       tracer,\n\t\tLogger:       logger,\n\t\tMeter:        meter,\n\t\tTokenEncoder: tokenEncoder,\n\t}, &server.Config{\n\t\tGRPCServer: server.GRPCServerConfig{\n\t\t\tAddr:      grpcAddr,\n\t\t\tTLSConfig: grpcTLSConfig,\n\t\t},\n\t\tHTTPServer: server.HTTPServerConfig{\n\t\t\tEnabled:            config.HTTP.Enabled,\n\t\t\tAddr:               httpAddr,\n\t\t\tTLSConfig:          httpTLSConfig,\n\t\t\tUpstreamTimeout:    config.HTTP.UpstreamTimeout,\n\t\t\tCORSAllowedOrigins: config.HTTP.CORSAllowedOrigins,\n\t\t\tCORSAllowedHeaders: config.HTTP.CORSAllowedHeaders,\n\t\t},\n\t\tResolveNodeLimit:       config.ResolveNodeLimit,\n\t\tChangelogHorizonOffset: config.ChangelogHorizonOffset,\n\t\tListObjectsDeadline:    config.ListObjectsDeadline,\n\t\tListObjectsMaxResults:  config.ListObjectsMaxResults,\n\t\tUnaryInterceptors:      unaryServerInterceptors,\n\t\tStreamingInterceptors:  streamingServerInterceptors,\n\t\tMuxOptions:             nil,\n\t})\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"failed to initialize openfga server: %v\", err)\n\t}\n\n\treturn &service{\n\t\tserver:        openFgaServer,\n\t\tgrpcAddr:      grpcAddr,\n\t\thttpAddr:      httpAddr,\n\t\tdatastore:     datastore,\n\t\tauthenticator: authenticator,\n\t}, nil\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/go-errors/errors\"\n\t\"github.com/hashicorp/go-retryablehttp\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/server/authn/mocks\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/tidwall/gjson\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc\"\n\tgrpcbackoff \"google.golang.org/grpc/backoff\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\thealthv1pb \"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n)\n\nfunc TestMain(m *testing.M) {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"../../..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tos.Exit(m.Run())\n}\n\nfunc ensureServiceUp(t *testing.T, s *service, transportCredentials credentials.TransportCredentials, httpHealthCheck bool) {\n\tt.Helper()\n\n\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tcreds := insecure.NewCredentials()\n\tif transportCredentials != nil {\n\t\tcreds = transportCredentials\n\t}\n\n\tdialOpts := []grpc.DialOption{\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTransportCredentials(creds),\n\t\tgrpc.WithConnectParams(grpc.ConnectParams{Backoff: grpcbackoff.DefaultConfig}),\n\t}\n\n\tconn, err := grpc.DialContext(\n\t\ttimeoutCtx,\n\t\tfmt.Sprintf(\"localhost:%d\", s.GetGRPCAddrPort().Port()),\n\t\tdialOpts...,\n\t)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\n\tclient := healthv1pb.NewHealthClient(conn)\n\n\tpolicy := backoff.NewExponentialBackOff()\n\tpolicy.MaxElapsedTime = 10 * time.Second\n\n\terr = backoff.Retry(func() error {\n\t\tresp, err := client.Check(timeoutCtx, &healthv1pb.HealthCheckRequest{\n\t\t\tService: openfgapb.OpenFGAService_ServiceDesc.ServiceName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif resp.GetStatus() != healthv1pb.HealthCheckResponse_SERVING {\n\t\t\treturn errors.Errorf(\"not serving\")\n\t\t}\n\n\t\treturn nil\n\t}, policy)\n\trequire.NoError(t, err)\n\n\tif httpHealthCheck {\n\t\t_, err = retryablehttp.NewClient().Get(fmt.Sprintf(\"http://localhost:%d/healthz\", s.GetHTTPAddrPort().Port()))\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc genCert(t *testing.T, template, parent *x509.Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (*x509.Certificate, []byte) {\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)\n\trequire.NoError(t, err)\n\n\tcert, err := x509.ParseCertificate(certBytes)\n\trequire.NoError(t, err)\n\n\tblock := &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: certBytes,\n\t}\n\n\treturn cert, pem.EncodeToMemory(block)\n}\n\nfunc genCACert(t *testing.T) (*x509.Certificate, []byte, *rsa.PrivateKey) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\trequire.NoError(t, err)\n\n\tvar rootTemplate = &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(1),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t\tMaxPathLen:            2,\n\t\tNotBefore:             time.Now().Add(-time.Minute),\n\t\tNotAfter:              time.Now().Add(time.Hour),\n\t\tSubject: pkix.Name{\n\t\t\tCountry:      []string{\"Earth\"},\n\t\t\tOrganization: []string{\"Starfleet\"},\n\t\t},\n\t\tDNSNames: []string{\"localhost\"},\n\t}\n\n\trootCert, rootPEM := genCert(t, rootTemplate, rootTemplate, &priv.PublicKey, priv)\n\n\treturn rootCert, rootPEM, priv\n}\n\nfunc genServerCert(t *testing.T, caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, []byte, *rsa.PrivateKey) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\trequire.NoError(t, err)\n\n\tvar template = &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(1),\n\t\tKeyUsage:              x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  false,\n\t\tNotBefore:             time.Now().Add(-time.Minute),\n\t\tNotAfter:              time.Now().Add(time.Hour),\n\t\tSubject: pkix.Name{\n\t\t\tCountry:      []string{\"Earth\"},\n\t\t\tOrganization: []string{\"Starfleet\"},\n\t\t},\n\t\tDNSNames: []string{\"localhost\"},\n\t}\n\n\tserverCert, serverPEM := genCert(t, template, caCert, &priv.PublicKey, caKey)\n\n\treturn serverCert, serverPEM, priv\n}\n\nfunc writeToTempFile(t *testing.T, data []byte) *os.File {\n\tfile, err := os.CreateTemp(\"\", \"openfga_tls_test\")\n\trequire.NoError(t, err)\n\n\t_, err = file.Write(data)\n\trequire.NoError(t, err)\n\n\treturn file\n}\n\ntype certHandle struct {\n\tcaCert         *x509.Certificate\n\tserverCertFile string\n\tserverKeyFile  string\n}\n\nfunc (c certHandle) Clean() {\n\tos.Remove(c.serverCertFile)\n\tos.Remove(c.serverKeyFile)\n}\n\n// createCertsAndKeys generates a self-signed root CA certificate and a server certificate and server key. It will write\n// the PEM encoded server certificate and server key to temporary files. It is the responsibility of the caller\n// to delete these files by calling `Clean` on the returned `certHandle`.\nfunc createCertsAndKeys(t *testing.T) certHandle {\n\tcaCert, _, caKey := genCACert(t)\n\t_, serverPEM, serverKey := genServerCert(t, caCert, caKey)\n\tserverCertFile := writeToTempFile(t, serverPEM)\n\tserverKeyFile := writeToTempFile(t, pem.EncodeToMemory(\n\t\t&pem.Block{\n\t\t\tType:  \"RSA PRIVATE KEY\",\n\t\t\tBytes: x509.MarshalPKCS1PrivateKey(serverKey),\n\t\t},\n\t))\n\n\treturn certHandle{\n\t\tcaCert:         caCert,\n\t\tserverCertFile: serverCertFile.Name(),\n\t\tserverKeyFile:  serverKeyFile.Name(),\n\t}\n}\n\ntype authTest struct {\n\t_name                 string\n\tauthHeader            string\n\texpectedErrorResponse *serverErrors.ErrorResponse\n\texpectedStatusCode    int\n}\n\nfunc TestBuildServiceWithNoAuth(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err, \"Failed to build server and/or datastore\")\n\tservice.Close(context.Background())\n}\n\nfunc TestBuildServiceWithPresharedKeyAuthenticationFailsIfZeroKeys(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{}\n\n\t_, err = BuildService(config, logger.NewNoopLogger())\n\trequire.EqualError(t, err, \"failed to initialize authenticator: invalid auth configuration, please specify at least one key\")\n}\n\nfunc TestBuildServiceWithPresharedKeyAuthentication(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{\n\t\tKeys: []string{\"KEYONE\", \"KEYTWO\"},\n\t}\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttests := []authTest{{\n\t\t_name:      \"Header with incorrect key fails\",\n\t\tauthHeader: \"Bearer incorrectkey\",\n\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n\t\t\tCode:    \"unauthenticated\",\n\t\t\tMessage: \"unauthenticated\",\n\t\t},\n\t\texpectedStatusCode: 401,\n\t}, {\n\t\t_name:      \"Missing header fails\",\n\t\tauthHeader: \"\",\n\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n\t\t\tCode:    \"bearer_token_missing\",\n\t\t\tMessage: \"missing bearer token\",\n\t\t},\n\t\texpectedStatusCode: 401,\n\t}, {\n\t\t_name:              \"Correct key one succeeds\",\n\t\tauthHeader:         fmt.Sprintf(\"Bearer %s\", config.Authn.AuthnPresharedKeyConfig.Keys[0]),\n\t\texpectedStatusCode: 200,\n\t}, {\n\t\t_name:              \"Correct key two succeeds\",\n\t\tauthHeader:         fmt.Sprintf(\"Bearer %s\", config.Authn.AuthnPresharedKeyConfig.Keys[1]),\n\t\texpectedStatusCode: 200,\n\t}}\n\n\tretryClient := retryablehttp.NewClient()\n\tfor _, test := range tests {\n\t\tt.Run(test._name, func(t *testing.T) {\n\t\t\ttryGetStores(t, test, service, retryClient)\n\t\t})\n\n\t\tt.Run(test._name+\"/streaming\", func(t *testing.T) {\n\t\t\ttryStreamingListObjects(t, test, service, retryClient, config.Authn.AuthnPresharedKeyConfig.Keys[0])\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, service.Close(ctx))\n\trequire.NoError(t, g.Wait())\n}\n\nfunc tryStreamingListObjects(t *testing.T, test authTest, service *service, retryClient *retryablehttp.Client, validToken string) {\n\t// create a store\n\tcreateStorePayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), createStorePayload)\n\trequire.NoError(t, err, \"Failed to construct create store request\")\n\treq.Header.Set(\"content-type\", \"application/json\")\n\treq.Header.Set(\"authorization\", fmt.Sprintf(\"Bearer %s\", validToken))\n\tres, err := retryClient.Do(req)\n\trequire.NoError(t, err, \"Failed to execute create store request\")\n\tdefer res.Body.Close()\n\tbody, err := io.ReadAll(res.Body)\n\trequire.NoError(t, err, \"Failed to read create store response\")\n\tvar createStoreResponse openfgapb.CreateStoreResponse\n\terr = protojson.Unmarshal(body, &createStoreResponse)\n\trequire.NoError(t, err, \"Failed to unmarshal create store response\")\n\n\t// create an authorization model\n\tauthModelPayload := strings.NewReader(`{\"type_definitions\":[{\"type\":\"document\",\"relations\":{\"owner\":{\"this\":{}}}}]}`)\n\treq, err = retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores/%s/authorization-models\", service.GetHTTPAddrPort().Port(), createStoreResponse.Id), authModelPayload)\n\trequire.NoError(t, err, \"Failed to construct create authorization model request\")\n\treq.Header.Set(\"content-type\", \"application/json\")\n\treq.Header.Set(\"authorization\", fmt.Sprintf(\"Bearer %s\", validToken))\n\t_, err = retryClient.Do(req)\n\trequire.NoError(t, err, \"Failed to execute create authorization model request\")\n\n\t// call one streaming endpoint\n\tlistObjectsPayload := strings.NewReader(`{\"type\": \"document\", \"user\": \"anne\", \"relation\": \"owner\"}`)\n\treq, err = retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores/%s/streamed-list-objects\", service.GetHTTPAddrPort().Port(), createStoreResponse.Id), listObjectsPayload)\n\trequire.NoError(t, err, \"Failed to construct request\")\n\treq.Header.Set(\"content-type\", \"application/json\")\n\treq.Header.Set(\"authorization\", test.authHeader)\n\n\tres, err = retryClient.Do(req)\n\trequire.Equal(t, test.expectedStatusCode, res.StatusCode)\n\trequire.NoError(t, err, \"Failed to execute streaming request\")\n\n\tdefer res.Body.Close()\n\tbody, err = io.ReadAll(res.Body)\n\trequire.NoError(t, err, \"Failed to read response\")\n\n\tif test.expectedErrorResponse != nil {\n\t\trequire.Contains(t, string(body), fmt.Sprintf(\",\\\"message\\\":\\\"%s\\\"\", test.expectedErrorResponse.Message))\n\t}\n}\n\nfunc tryGetStores(t *testing.T, test authTest, service *service, retryClient *retryablehttp.Client) {\n\treq, err := retryablehttp.NewRequest(\"GET\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), nil)\n\trequire.NoError(t, err, \"Failed to construct request\")\n\treq.Header.Set(\"content-type\", \"application/json\")\n\treq.Header.Set(\"authorization\", test.authHeader)\n\n\tres, err := retryClient.Do(req)\n\trequire.NoError(t, err, \"Failed to execute request\")\n\trequire.Equal(t, test.expectedStatusCode, res.StatusCode)\n\n\tdefer res.Body.Close()\n\tbody, err := io.ReadAll(res.Body)\n\trequire.NoError(t, err, \"Failed to read response\")\n\n\tif test.expectedErrorResponse != nil {\n\t\tvar actualErrorResponse serverErrors.ErrorResponse\n\t\terr = json.Unmarshal(body, &actualErrorResponse)\n\n\t\trequire.NoError(t, err, \"Failed to unmarshal response\")\n\n\t\trequire.Equal(t, test.expectedErrorResponse, &actualErrorResponse)\n\t}\n}\n\nfunc TestHTTPServerWithCORS(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"preshared\"\n\tconfig.Authn.AuthnPresharedKeyConfig = &AuthnPresharedKeyConfig{\n\t\tKeys: []string{\"KEYONE\", \"KEYTWO\"},\n\t}\n\tconfig.HTTP.CORSAllowedOrigins = []string{\"http://openfga.dev\", \"http://localhost\"}\n\tconfig.HTTP.CORSAllowedHeaders = []string{\"Origin\", \"Accept\", \"Content-Type\", \"X-Requested-With\", \"Authorization\", \"X-Custom-Header\"}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttype args struct {\n\t\torigin string\n\t\theader string\n\t}\n\ttype want struct {\n\t\torigin string\n\t\theader string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant want\n\t}{\n\t\t{\n\t\t\tname: \"Good Origin\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Authorization, X-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Authorization, X-Custom-Header\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Bad Origin\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://openfga.example\",\n\t\t\t\theader: \"X-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"\",\n\t\t\t\theader: \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Bad Header\",\n\t\t\targs: args{\n\t\t\t\torigin: \"http://localhost\",\n\t\t\t\theader: \"Bad-Custom-Header\",\n\t\t\t},\n\t\t\twant: want{\n\t\t\t\torigin: \"\",\n\t\t\t\theader: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tclient := retryablehttp.NewClient()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n\t\t\treq, err := retryablehttp.NewRequest(\"OPTIONS\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treq.Header.Set(\"Origin\", test.args.origin)\n\t\t\treq.Header.Set(\"Access-Control-Request-Method\", \"OPTIONS\")\n\t\t\treq.Header.Set(\"Access-Control-Request-Headers\", test.args.header)\n\n\t\t\tres, err := client.Do(req)\n\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n\t\t\tdefer res.Body.Close()\n\n\t\t\torigin := res.Header.Get(\"Access-Control-Allow-Origin\")\n\t\t\tacceptedHeader := res.Header.Get(\"Access-Control-Allow-Headers\")\n\t\t\trequire.Equal(t, test.want.origin, origin)\n\n\t\t\trequire.Equal(t, test.want.header, acceptedHeader)\n\n\t\t\t_, err = io.ReadAll(res.Body)\n\t\t\trequire.NoError(t, err, \"Failed to read response\")\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, g.Wait())\n\trequire.NoError(t, service.Close(ctx))\n\n}\n\nfunc TestBuildServerWithOIDCAuthentication(t *testing.T) {\n\tconst localOIDCServerURL = \"http://localhost:8083\"\n\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.Authn.Method = \"oidc\"\n\tconfig.Authn.AuthnOIDCConfig = &AuthnOIDCConfig{\n\t\tAudience: \"openfga.dev\",\n\t\tIssuer:   localOIDCServerURL,\n\t}\n\n\ttrustedIssuerServer, err := mocks.NewMockOidcServer(localOIDCServerURL)\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\ttrustedToken, err := trustedIssuerServer.GetToken(\"openfga.dev\", \"some-user\")\n\trequire.NoError(t, err)\n\n\ttests := []authTest{{\n\t\t_name:      \"Header with invalid token fails\",\n\t\tauthHeader: \"Bearer incorrecttoken\",\n\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n\t\t\tCode:    \"auth_failed_invalid_bearer_token\",\n\t\t\tMessage: \"invalid bearer token\",\n\t\t},\n\t\texpectedStatusCode: 401,\n\t}, {\n\t\t_name:      \"Missing header fails\",\n\t\tauthHeader: \"\",\n\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n\t\t\tCode:    \"bearer_token_missing\",\n\t\t\tMessage: \"missing bearer token\",\n\t\t},\n\t\texpectedStatusCode: 401,\n\t}, {\n\t\t_name:              \"Correct token succeeds\",\n\t\tauthHeader:         \"Bearer \" + trustedToken,\n\t\texpectedStatusCode: 200,\n\t}}\n\n\tretryClient := retryablehttp.NewClient()\n\tfor _, test := range tests {\n\t\tt.Run(test._name, func(t *testing.T) {\n\t\t\ttryGetStores(t, test, service, retryClient)\n\t\t})\n\n\t\tt.Run(test._name+\"/streaming\", func(t *testing.T) {\n\t\t\ttryStreamingListObjects(t, test, service, retryClient, trustedToken)\n\t\t})\n\t}\n\n\tcancel()\n\trequire.NoError(t, service.Close(ctx))\n\trequire.NoError(t, g.Wait())\n}\n\nfunc TestTLSFailureSettings(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"failing to set http cert path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled: true,\n\t\t\tKeyPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidHTTPTLSConfig)\n\t})\n\n\tt.Run(\"failing to set grpc cert path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled: true,\n\t\t\tKeyPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidGRPCTLSConfig)\n\t})\n\n\tt.Run(\"failing to set http key path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidHTTPTLSConfig)\n\t})\n\n\tt.Run(\"failing to set grpc key path will not allow server to start\", func(t *testing.T) {\n\t\tconfig, err := GetServiceConfig()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: \"some/path\",\n\t\t}\n\n\t\t_, err = BuildService(config, logger)\n\t\trequire.ErrorIs(t, err, ErrInvalidGRPCTLSConfig)\n\t})\n}\n\nfunc TestHTTPServingTLS(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"enable HTTP TLS is false, even with keys set, will serve plaintext\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, true)\n\n\t\tcancel()\n\t\trequire.NoError(t, g.Wait())\n\t\trequire.NoError(t, service.Close(ctx))\n\t})\n\n\tt.Run(\"enable HTTP TLS is true will serve HTTP TLS\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.HTTP.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, false)\n\n\t\tcertPool := x509.NewCertPool()\n\t\tcertPool.AddCert(certsAndKeys.caCert)\n\t\tclient := retryablehttp.NewClient()\n\t\tclient.HTTPClient.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tRootCAs: certPool,\n\t\t\t},\n\t\t}\n\n\t\t_, err = client.Get(fmt.Sprintf(\"https://localhost:%d/healthz\", service.GetHTTPAddrPort().Port()))\n\t\trequire.NoError(t, err)\n\n\t\tcancel()\n\t\trequire.NoError(t, g.Wait())\n\t\trequire.NoError(t, service.Close(ctx))\n\t})\n\n}\n\nfunc TestGRPCServingTLS(t *testing.T) {\n\tlogger := logger.NewNoopLogger()\n\n\tt.Run(\"enable grpc TLS is false, even with keys set, will serve plaintext\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\t\tconfig.HTTP.Enabled = false\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tensureServiceUp(t, service, nil, false)\n\n\t\tcancel()\n\t\trequire.NoError(t, service.Close(ctx))\n\t\trequire.NoError(t, g.Wait())\n\t})\n\n\tt.Run(\"enable grpc TLS is true will serve grpc TLS\", func(t *testing.T) {\n\t\tcertsAndKeys := createCertsAndKeys(t)\n\t\tdefer certsAndKeys.Clean()\n\n\t\tconfig, err := DefaultConfigWithRandomPorts()\n\t\trequire.NoError(t, err)\n\n\t\tconfig.GRPC.TLS = TLSConfig{\n\t\t\tEnabled:  true,\n\t\t\tCertPath: certsAndKeys.serverCertFile,\n\t\t\tKeyPath:  certsAndKeys.serverKeyFile,\n\t\t}\n\t\tconfig.HTTP.Enabled = false\n\n\t\tservice, err := BuildService(config, logger)\n\t\trequire.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tg := new(errgroup.Group)\n\t\tg.Go(func() error {\n\t\t\treturn service.Run(ctx)\n\t\t})\n\n\t\tcertPool := x509.NewCertPool()\n\t\tcertPool.AddCert(certsAndKeys.caCert)\n\t\tcreds := credentials.NewClientTLSFromCert(certPool, \"\")\n\n\t\tensureServiceUp(t, service, creds, false)\n\n\t\tcancel()\n\t\trequire.NoError(t, service.Close(ctx))\n\t\trequire.NoError(t, g.Wait())\n\t})\n}\n\nfunc TestHTTPServerDisabled(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.HTTP.Enabled = false\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, false)\n\n\t_, err = http.Get(\"http://localhost:8080/healthz\")\n\trequire.Error(t, err)\n\trequire.ErrorContains(t, err, \"dial tcp [::1]:8080: connect: connection refused\")\n\n\tcancel()\n}\n\nfunc TestHTTPServerEnabled(t *testing.T) {\n\tconfig, err := DefaultConfigWithRandomPorts()\n\trequire.NoError(t, err)\n\n\tconfig.HTTP.Enabled = true\n\n\tservice, err := BuildService(config, logger.NewNoopLogger())\n\trequire.NoError(t, err)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tg := new(errgroup.Group)\n\tg.Go(func() error {\n\t\treturn service.Run(ctx)\n\t})\n\n\tensureServiceUp(t, service, nil, true)\n\n\tcancel()\n}\n\nfunc TestDefaultConfig(t *testing.T) {\n\tconfig, err := GetServiceConfig()\n\trequire.NoError(t, err)\n\n\tjsonSchema, err := os.ReadFile(\".config-schema.json\")\n\trequire.NoError(t, err)\n\n\tres := gjson.ParseBytes(jsonSchema)\n\n\tval := res.Get(\"properties.datastore.properties.engine.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Datastore.Engine)\n\n\tval = res.Get(\"properties.datastore.properties.maxCacheSize.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.Datastore.MaxCacheSize)\n\n\tval = res.Get(\"properties.grpc.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.GRPC.Addr)\n\n\tval = res.Get(\"properties.http.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.HTTP.Enabled)\n\n\tval = res.Get(\"properties.http.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.HTTP.Addr)\n\n\tval = res.Get(\"properties.playground.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.Playground.Enabled)\n\n\tval = res.Get(\"properties.playground.properties.port.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.Playground.Port)\n\n\tval = res.Get(\"properties.profiler.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.Profiler.Enabled)\n\n\tval = res.Get(\"properties.profiler.properties.addr.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Profiler.Addr)\n\n\tval = res.Get(\"properties.authn.properties.method.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Authn.Method)\n\n\tval = res.Get(\"properties.log.properties.format.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.Log.Format)\n\n\tval = res.Get(\"properties.maxTuplesPerWrite.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.MaxTuplesPerWrite)\n\n\tval = res.Get(\"properties.maxTypesPerAuthorizationModel.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.MaxTypesPerAuthorizationModel)\n\n\tval = res.Get(\"properties.changelogHorizonOffset.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ChangelogHorizonOffset)\n\n\tval = res.Get(\"properties.resolveNodeLimit.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ResolveNodeLimit)\n\n\tval = res.Get(\"properties.grpc.properties.tls.$ref\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, \"#/definitions/tls\", val.String())\n\n\tval = res.Get(\"properties.http.properties.tls.$ref\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, \"#/definitions/tls\", val.String())\n\n\tval = res.Get(\"definitions.tls.properties.enabled.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.Bool(), config.GRPC.TLS.Enabled)\n\trequire.Equal(t, val.Bool(), config.HTTP.TLS.Enabled)\n\n\tval = res.Get(\"properties.listObjectsDeadline.default\")\n\trequire.True(t, val.Exists())\n\trequire.Equal(t, val.String(), config.ListObjectsDeadline.String())\n\n\tval = res.Get(\"properties.listObjectsMaxResults.default\")\n\trequire.True(t, val.Exists())\n\trequire.EqualValues(t, val.Int(), config.ListObjectsMaxResults)\n}\n", "package middleware\n\nimport (\n\t\"context\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"go.uber.org/zap\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc NewErrorLoggingInterceptor(logger logger.Logger) grpc.UnaryServerInterceptor {\n\treturn func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n\t\tresp, err := handler(ctx, req)\n\t\tif err != nil {\n\t\t\tvar e error\n\t\t\tif internalError, ok := err.(serverErrors.InternalError); ok {\n\t\t\t\te = internalError.Internal()\n\t\t\t}\n\t\t\tlogger.Error(\"grpc_error\", zap.Error(e), zap.String(\"public_error\", err.Error()))\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn resp, nil\n\t}\n}\n\nfunc NewStreamingErrorLoggingInterceptor(logger logger.Logger) grpc.StreamServerInterceptor {\n\treturn func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n\t\terr := handler(srv, stream)\n\t\tif err != nil {\n\t\t\tvar e error\n\t\t\tif internalError, ok := err.(serverErrors.InternalError); ok {\n\t\t\t\te = internalError.Internal()\n\t\t\t}\n\t\t\tlogger.Error(\"grpc_error\", zap.Error(e), zap.String(\"public_error\", err.Error()))\n\t\t}\n\n\t\treturn err\n\t}\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/netip\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/go-errors/errors\"\n\tgrpc_validator \"github.com/grpc-ecosystem/go-grpc-middleware/validator\"\n\t\"github.com/grpc-ecosystem/grpc-gateway/v2/runtime\"\n\thttpmiddleware \"github.com/openfga/openfga/internal/middleware/http\"\n\t\"github.com/openfga/openfga/pkg/encoder\"\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/server/gateway\"\n\t\"github.com/openfga/openfga/server/health\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/rs/cors\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n\t\"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/metric\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\thealthv1pb \"google.golang.org/grpc/health/grpc_health_v1\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"google.golang.org/grpc/status\"\n)\n\nconst (\n\tAuthorizationModelIDHeader = \"openfga-authorization-model-id\"\n)\n\nvar (\n\tErrNilTokenEncoder = errors.Errorf(\"tokenEncoder must be a non-nil interface value\")\n\tErrNilTransport    = errors.Errorf(\"transport must be a non-nil interface value\")\n)\n\n// A Server implements the OpenFGA service backend as both\n// a GRPC and HTTP server.\ntype Server struct {\n\topenfgapb.UnimplementedOpenFGAServiceServer\n\n\ttracer    trace.Tracer\n\tmeter     metric.Meter\n\tlogger    logger.Logger\n\tdatastore storage.OpenFGADatastore\n\tencoder   encoder.Encoder\n\tconfig    *Config\n\ttransport gateway.Transport\n\n\tdefaultServeMuxOpts []runtime.ServeMuxOption\n}\n\ntype Dependencies struct {\n\tDatastore storage.OpenFGADatastore\n\tTracer    trace.Tracer\n\tMeter     metric.Meter\n\tLogger    logger.Logger\n\tTransport gateway.Transport\n\n\t// TokenEncoder is the encoder used to encode continuation tokens for paginated views.\n\t// Defaults to a base64 encoder if none is provided.\n\tTokenEncoder encoder.Encoder\n}\n\ntype Config struct {\n\tGRPCServer             GRPCServerConfig\n\tHTTPServer             HTTPServerConfig\n\tResolveNodeLimit       uint32\n\tChangelogHorizonOffset int\n\tListObjectsDeadline    time.Duration\n\tListObjectsMaxResults  uint32\n\tUnaryInterceptors      []grpc.UnaryServerInterceptor\n\tStreamingInterceptors  []grpc.StreamServerInterceptor\n\tMuxOptions             []runtime.ServeMuxOption\n}\n\ntype GRPCServerConfig struct {\n\tAddr      netip.AddrPort\n\tTLSConfig *TLSConfig\n}\n\ntype HTTPServerConfig struct {\n\tEnabled            bool\n\tAddr               netip.AddrPort\n\tUpstreamTimeout    time.Duration\n\tTLSConfig          *TLSConfig\n\tCORSAllowedOrigins []string\n\tCORSAllowedHeaders []string\n}\n\ntype TLSConfig struct {\n\tCertPath string\n\tKeyPath  string\n}\n\n// New creates a new Server which uses the supplied backends\n// for managing data.\nfunc New(dependencies *Dependencies, config *Config) (*Server, error) {\n\ttokenEncoder := dependencies.TokenEncoder\n\tif tokenEncoder == nil {\n\t\ttokenEncoder = encoder.NewBase64Encoder()\n\t} else {\n\t\tt := reflect.TypeOf(tokenEncoder)\n\t\tif reflect.ValueOf(tokenEncoder) == reflect.Zero(t) {\n\t\t\treturn nil, ErrNilTokenEncoder\n\t\t}\n\t}\n\n\ttransport := dependencies.Transport\n\tif transport == nil {\n\t\ttransport = gateway.NewRPCTransport(dependencies.Logger)\n\t} else {\n\t\tt := reflect.TypeOf(transport)\n\t\tif reflect.ValueOf(transport) == reflect.Zero(t) {\n\t\t\treturn nil, ErrNilTransport\n\t\t}\n\t}\n\n\tserver := &Server{\n\t\ttracer:    dependencies.Tracer,\n\t\tmeter:     dependencies.Meter,\n\t\tlogger:    dependencies.Logger,\n\t\tdatastore: dependencies.Datastore,\n\t\tencoder:   tokenEncoder,\n\t\ttransport: transport,\n\t\tconfig:    config,\n\t\tdefaultServeMuxOpts: []runtime.ServeMuxOption{\n\t\t\truntime.WithForwardResponseOption(httpmiddleware.HTTPResponseModifier),\n\t\t\truntime.WithErrorHandler(func(c context.Context, sr *runtime.ServeMux, mm runtime.Marshaler, w http.ResponseWriter, r *http.Request, e error) {\n\t\t\t\tintCode := serverErrors.ConvertToEncodedErrorCode(status.Convert(e))\n\t\t\t\thttpmiddleware.CustomHTTPErrorHandler(c, w, r, serverErrors.NewEncodedError(intCode, e.Error()))\n\t\t\t}),\n\t\t\truntime.WithStreamErrorHandler(func(ctx context.Context, e error) *status.Status {\n\t\t\t\tintCode := serverErrors.ConvertToEncodedErrorCode(status.Convert(e))\n\t\t\t\tencodedErr := serverErrors.NewEncodedError(intCode, e.Error())\n\t\t\t\treturn status.Convert(&encodedErr)\n\t\t\t}),\n\t\t},\n\t}\n\n\terrors.MaxStackDepth = logger.MaxDepthBacktraceStack\n\n\treturn server, nil\n}\n\nfunc (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequest) (*openfgapb.ListObjectsResponse, error) {\n\tstoreID := req.GetStoreId()\n\ttargetObjectType := req.GetType()\n\n\tctx, span := s.tracer.Start(ctx, \"listObjects\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"objectType\", Value: attribute.StringValue(targetObjectType)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tTracer:                s.tracer,\n\t\tMeter:                 s.meter,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treturn q.Execute(ctx, &openfgapb.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 targetObjectType,\n\t\tRelation:             req.Relation,\n\t\tUser:                 req.User,\n\t})\n}\n\nfunc (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest, srv openfgapb.OpenFGAService_StreamedListObjectsServer) error {\n\tstoreID := req.GetStoreId()\n\tctx := context.Background()\n\tctx, span := s.tracer.Start(ctx, \"streamedListObjects\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"objectType\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, storeID, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn err\n\t}\n\tq := &commands.ListObjectsQuery{\n\t\tDatastore:             s.datastore,\n\t\tLogger:                s.logger,\n\t\tTracer:                s.tracer,\n\t\tMeter:                 s.meter,\n\t\tListObjectsDeadline:   s.config.ListObjectsDeadline,\n\t\tListObjectsMaxResults: s.config.ListObjectsMaxResults,\n\t\tResolveNodeLimit:      s.config.ResolveNodeLimit,\n\t}\n\n\treq.AuthorizationModelId = modelID\n\treturn q.ExecuteStreamed(ctx, req, srv)\n}\n\nfunc (s *Server) Read(ctx context.Context, req *openfgapb.ReadRequest) (*openfgapb.ReadResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"read\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewReadQuery(s.datastore, s.tracer, s.logger, s.encoder)\n\treturn q.Execute(ctx, &openfgapb.ReadRequest{\n\t\tStoreId:              store,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t\tPageSize:             req.GetPageSize(),\n\t\tContinuationToken:    req.GetContinuationToken(),\n\t})\n}\n\nfunc (s *Server) ReadTuples(ctx context.Context, req *openfgapb.ReadTuplesRequest) (*openfgapb.ReadTuplesResponse, error) {\n\n\tctx, span := s.tracer.Start(ctx, \"readTuples\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadTuplesQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) Write(ctx context.Context, req *openfgapb.WriteRequest) (*openfgapb.WriteResponse, error) {\n\tstore := req.GetStoreId()\n\tctx, span := s.tracer.Start(ctx, \"write\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := commands.NewWriteCommand(s.datastore, s.tracer, s.logger)\n\treturn cmd.Execute(ctx, &openfgapb.WriteRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites:               req.GetWrites(),\n\t\tDeletes:              req.GetDeletes(),\n\t})\n}\n\nfunc (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openfgapb.CheckResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"check\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewCheckQuery(s.datastore, s.tracer, s.meter, s.logger, s.config.ResolveNodeLimit)\n\n\tres, err := q.Execute(ctx, &openfgapb.CheckRequest{\n\t\tStoreId:              store,\n\t\tTupleKey:             tk,\n\t\tContextualTuples:     req.GetContextualTuples(),\n\t\tAuthorizationModelId: modelID,\n\t\tTrace:                req.GetTrace(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tspan.SetAttributes(attribute.KeyValue{Key: \"allowed\", Value: attribute.BoolValue(res.GetAllowed())})\n\treturn res, nil\n}\n\nfunc (s *Server) Expand(ctx context.Context, req *openfgapb.ExpandRequest) (*openfgapb.ExpandResponse, error) {\n\tstore := req.GetStoreId()\n\ttk := req.GetTupleKey()\n\tctx, span := s.tracer.Start(ctx, \"expand\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t\tattribute.KeyValue{Key: \"object\", Value: attribute.StringValue(tk.GetObject())},\n\t\tattribute.KeyValue{Key: \"relation\", Value: attribute.StringValue(tk.GetRelation())},\n\t\tattribute.KeyValue{Key: \"user\", Value: attribute.StringValue(tk.GetUser())},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tq := commands.NewExpandQuery(s.datastore, s.tracer, s.logger)\n\treturn q.Execute(ctx, &openfgapb.ExpandRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tk,\n\t})\n}\n\nfunc (s *Server) ReadAuthorizationModel(ctx context.Context, req *openfgapb.ReadAuthorizationModelRequest) (*openfgapb.ReadAuthorizationModelResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(req.GetId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadAuthorizationModelQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAuthorizationModel(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"writeAuthorizationModel\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tc := commands.NewWriteAuthorizationModelCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAuthorizationModels(ctx context.Context, req *openfgapb.ReadAuthorizationModelsRequest) (*openfgapb.ReadAuthorizationModelsResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAuthorizationModels\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tc := commands.NewReadAuthorizationModelsQuery(s.datastore, s.logger, s.encoder)\n\treturn c.Execute(ctx, req)\n}\n\nfunc (s *Server) WriteAssertions(ctx context.Context, req *openfgapb.WriteAssertionsRequest) (*openfgapb.WriteAssertionsResponse, error) {\n\tstore := req.GetStoreId()\n\tctx, span := s.tracer.Start(ctx, \"writeAssertions\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(store)},\n\t))\n\tdefer span.End()\n\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, store, req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\n\tc := commands.NewWriteAssertionsCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, &openfgapb.WriteAssertionsRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tAssertions:           req.GetAssertions(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) ReadAssertions(ctx context.Context, req *openfgapb.ReadAssertionsRequest) (*openfgapb.ReadAssertionsResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"readAssertions\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\tmodelID, err := s.resolveAuthorizationModelID(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspan.SetAttributes(attribute.KeyValue{Key: \"authorization-model-id\", Value: attribute.StringValue(modelID)})\n\tq := commands.NewReadAssertionsQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req.GetStoreId(), req.GetAuthorizationModelId())\n}\n\nfunc (s *Server) ReadChanges(ctx context.Context, req *openfgapb.ReadChangesRequest) (*openfgapb.ReadChangesResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"ReadChangesQuery\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t\tattribute.KeyValue{Key: \"type\", Value: attribute.StringValue(req.GetType())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewReadChangesQuery(s.datastore, s.tracer, s.logger, s.encoder, s.config.ChangelogHorizonOffset)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) CreateStore(ctx context.Context, req *openfgapb.CreateStoreRequest) (*openfgapb.CreateStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"createStore\")\n\tdefer span.End()\n\n\tc := commands.NewCreateStoreCommand(s.datastore, s.logger)\n\tres, err := c.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusCreated))\n\n\treturn res, nil\n}\n\nfunc (s *Server) DeleteStore(ctx context.Context, req *openfgapb.DeleteStoreRequest) (*openfgapb.DeleteStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"deleteStore\")\n\tdefer span.End()\n\n\tcmd := commands.NewDeleteStoreCommand(s.datastore, s.logger)\n\tres, err := cmd.Execute(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.transport.SetHeader(ctx, httpmiddleware.XHttpCode, strconv.Itoa(http.StatusNoContent))\n\n\treturn res, nil\n}\n\nfunc (s *Server) GetStore(ctx context.Context, req *openfgapb.GetStoreRequest) (*openfgapb.GetStoreResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"getStore\", trace.WithAttributes(\n\t\tattribute.KeyValue{Key: \"store\", Value: attribute.StringValue(req.GetStoreId())},\n\t))\n\tdefer span.End()\n\n\tq := commands.NewGetStoreQuery(s.datastore, s.logger)\n\treturn q.Execute(ctx, req)\n}\n\nfunc (s *Server) ListStores(ctx context.Context, req *openfgapb.ListStoresRequest) (*openfgapb.ListStoresResponse, error) {\n\tctx, span := s.tracer.Start(ctx, \"listStores\")\n\tdefer span.End()\n\n\tq := commands.NewListStoresQuery(s.datastore, s.logger, s.encoder)\n\treturn q.Execute(ctx, req)\n}\n\n// IsReady reports whether this OpenFGA server instance is ready to accept\n// traffic.\nfunc (s *Server) IsReady(ctx context.Context) (bool, error) {\n\n\t// for now we only depend on the datastore being ready, but in the future\n\t// server readiness may also depend on other criteria in addition to the\n\t// datastore being ready.\n\treturn s.datastore.IsReady(ctx)\n}\n\n// Run starts server execution, and blocks until complete, returning any server errors. To close the\n// server cancel the provided ctx.\nfunc (s *Server) Run(ctx context.Context) error {\n\n\tunaryServerInterceptors := []grpc.UnaryServerInterceptor{\n\t\tgrpc_validator.UnaryServerInterceptor(),\n\t}\n\tunaryServerInterceptors = append(unaryServerInterceptors, s.config.UnaryInterceptors...)\n\n\tstreamingInterceptors := []grpc.StreamServerInterceptor{\n\t\tgrpc_validator.StreamServerInterceptor(),\n\t}\n\tstreamingInterceptors = append(streamingInterceptors, s.config.StreamingInterceptors...)\n\n\topts := []grpc.ServerOption{\n\t\tgrpc.ChainUnaryInterceptor(unaryServerInterceptors...),\n\t\tgrpc.ChainStreamInterceptor(streamingInterceptors...),\n\t}\n\n\tif s.config.GRPCServer.TLSConfig != nil {\n\t\tcreds, err := credentials.NewServerTLSFromFile(s.config.GRPCServer.TLSConfig.CertPath, s.config.GRPCServer.TLSConfig.KeyPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topts = append(opts, grpc.Creds(creds))\n\t}\n\t// nosemgrep: grpc-server-insecure-connection\n\tgrpcServer := grpc.NewServer(opts...)\n\topenfgapb.RegisterOpenFGAServiceServer(grpcServer, s)\n\thealthServer := &health.Checker{TargetService: s, TargetServiceName: openfgapb.OpenFGAService_ServiceDesc.ServiceName}\n\thealthv1pb.RegisterHealthServer(grpcServer, healthServer)\n\treflection.Register(grpcServer)\n\n\trpcAddr := s.config.GRPCServer.Addr\n\tlis, err := net.Listen(\"tcp\", rpcAddr.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo func() {\n\t\tif err := grpcServer.Serve(lis); err != nil {\n\t\t\ts.logger.Error(\"failed to start grpc server\", logger.Error(err))\n\t\t}\n\t}()\n\n\ts.logger.Info(fmt.Sprintf(\"grpc server listening on '%s'...\", rpcAddr))\n\n\tvar httpServer *http.Server\n\tif s.config.HTTPServer.Enabled {\n\t\t// Set a request timeout.\n\t\truntime.DefaultContextTimeout = s.config.HTTPServer.UpstreamTimeout\n\n\t\tdialOpts := []grpc.DialOption{\n\t\t\tgrpc.WithBlock(),\n\t\t\tgrpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),\n\t\t}\n\t\tif s.config.GRPCServer.TLSConfig != nil {\n\t\t\tcreds, err := credentials.NewClientTLSFromFile(s.config.GRPCServer.TLSConfig.CertPath, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))\n\t\t} else {\n\t\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\t\t}\n\n\t\ttimeoutCtx, cancel := context.WithTimeout(ctx, 3*time.Second)\n\t\tdefer cancel()\n\n\t\tconn, err := grpc.DialContext(timeoutCtx, rpcAddr.String(), dialOpts...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer conn.Close()\n\n\t\thealthClient := healthv1pb.NewHealthClient(conn)\n\n\t\tmuxOpts := []runtime.ServeMuxOption{\n\t\t\truntime.WithHealthzEndpoint(healthClient),\n\t\t}\n\t\tmuxOpts = append(muxOpts, s.defaultServeMuxOpts...) // register the defaults first\n\t\tmuxOpts = append(muxOpts, s.config.MuxOptions...)   // any provided options override defaults if they are duplicates\n\n\t\tmux := runtime.NewServeMux(muxOpts...)\n\n\t\tif err := openfgapb.RegisterOpenFGAServiceHandler(ctx, mux, conn); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thttpServer = &http.Server{\n\t\t\tAddr: s.config.HTTPServer.Addr.String(),\n\t\t\tHandler: cors.New(cors.Options{\n\t\t\t\tAllowedOrigins:   s.config.HTTPServer.CORSAllowedOrigins,\n\t\t\t\tAllowCredentials: true,\n\t\t\t\tAllowedHeaders:   s.config.HTTPServer.CORSAllowedHeaders,\n\t\t\t\tAllowedMethods: []string{http.MethodGet, http.MethodPost,\n\t\t\t\t\thttp.MethodHead, http.MethodPatch, http.MethodDelete, http.MethodPut},\n\t\t\t}).Handler(mux),\n\t\t}\n\n\t\tgo func() {\n\t\t\ts.logger.Info(fmt.Sprintf(\"HTTP server listening on '%s'...\", httpServer.Addr))\n\n\t\t\tvar err error\n\t\t\tif s.config.HTTPServer.TLSConfig != nil {\n\t\t\t\terr = httpServer.ListenAndServeTLS(s.config.HTTPServer.TLSConfig.CertPath, s.config.HTTPServer.TLSConfig.KeyPath)\n\t\t\t} else {\n\t\t\t\terr = httpServer.ListenAndServe()\n\t\t\t}\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\ts.logger.ErrorWithContext(ctx, \"HTTP server closed with unexpected error\", logger.Error(err))\n\t\t\t}\n\t\t}()\n\t}\n\n\t<-ctx.Done()\n\ts.logger.InfoWithContext(ctx, \"Termination signal received! Gracefully shutting down\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif httpServer != nil {\n\t\tif err := httpServer.Shutdown(ctx); err != nil {\n\t\t\ts.logger.ErrorWithContext(ctx, \"HTTP server shutdown failed\", logger.Error(err))\n\t\t\treturn err\n\t\t}\n\t}\n\n\tgrpcServer.GracefulStop()\n\n\treturn nil\n}\n\n// Util to find the latest authorization model ID to be used through all the request lifecycle.\n// This allows caching of types. If the user inserts a new authorization model and doesn't\n// provide this field (which should be rate limited more aggressively) the in-flight requests won't be\n// affected and newer calls will use the updated authorization model.\nfunc (s *Server) resolveAuthorizationModelID(ctx context.Context, store, modelID string) (string, error) {\n\tctx, span := s.tracer.Start(ctx, \"resolveAuthorizationModelID\")\n\tdefer span.End()\n\n\tvar err error\n\tif modelID != \"\" {\n\t\tif !id.IsValid(modelID) {\n\t\t\treturn \"\", serverErrors.AuthorizationModelNotFound(modelID)\n\t\t}\n\t} else {\n\t\tif modelID, err = s.datastore.FindLatestAuthorizationModelID(ctx, store); err != nil {\n\t\t\tif errors.Is(err, storage.ErrNotFound) {\n\t\t\t\treturn \"\", serverErrors.LatestAuthorizationModelNotFound(store)\n\t\t\t}\n\t\t\treturn \"\", serverErrors.HandleError(\"\", err)\n\t\t}\n\t}\n\n\ts.transport.SetHeader(ctx, AuthorizationModelIDHeader, modelID)\n\n\treturn modelID, nil\n}\n"], "filenames": ["pkg/cmd/service/service.go", "pkg/cmd/service/service_test.go", "server/middleware/logging.go", "server/server.go"], "buggy_code_start_loc": [362, 9, 27, 83], "buggy_code_end_loc": [419, 476, 27, 496], "fixing_code_start_loc": [362, 10, 28, 84], "fixing_code_end_loc": [425, 532, 43, 503], "type": "CWE-863", "message": "OpenFGA is an authorization/permission engine. Prior to version 0.2.4, the `streamed-list-objects` endpoint was not validating the authorization header, resulting in disclosure of objects in the store. Users `openfga/openfga` versions 0.2.3 and prior who are exposing the OpenFGA service to the internet are vulnerable. Version 0.2.4 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-39340", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-25T17:15:56.213", "lastModified": "2022-10-26T00:51:04.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenFGA is an authorization/permission engine. Prior to version 0.2.4, the `streamed-list-objects` endpoint was not validating the authorization header, resulting in disclosure of objects in the store. Users `openfga/openfga` versions 0.2.3 and prior who are exposing the OpenFGA service to the internet are vulnerable. Version 0.2.4 contains a patch for this issue."}, {"lang": "es", "value": "OpenFGA es un motor de autorizaci\u00f3n/permiso. versiones anteriores a 0.2.4, el endpoint \"streamed-list-objects\" no estaba comprendiendo el encabezado de autorizaci\u00f3n, resultando en una divulgaci\u00f3n de objetos en el almac\u00e9n. Los usuarios de versiones 0.2.3 y anteriores de \"openfga/openfga\" que exponen el servicio OpenFGA a Internet son vulnerables. La versi\u00f3n 0.2.4 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.4", "matchCriteriaId": "6C8497C4-6109-40A8-AA89-E20BF94EB4C2"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/779d73d4b6d067ee042ec9b59fec707eed71e42f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/releases/tag/v0.2.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-95x7-mh78-7w2r", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/779d73d4b6d067ee042ec9b59fec707eed71e42f"}}