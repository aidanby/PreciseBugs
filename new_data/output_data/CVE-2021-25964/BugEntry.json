{"buggy_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import division, print_function, unicode_literals\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\n\n# Improve this to check if scholarly is available in a global way, like other pythonic libraries\nhave_scholar = True\ntry:\n    from scholarly import scholarly\nexcept ImportError:\n    have_scholar = False\n    pass\n\n\nfrom babel import Locale as LC\nfrom babel.core import UnknownLocaleError\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\n\neditbook = Blueprint('editbook', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                # if inp_element == type_elements:\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if a element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        # if new_element is None:\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            changed = True\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element.replace('|', ',')\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n@editbook.route(\"/ajax/delete/<int:book_id>\")\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book(book_id, \"\", True), mimetype='application/json')\n\n\n@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"})\n@editbook.route(\"/delete/<int:book_id>/<string:book_format>\")\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.Custom_Columns). \\\n        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, jsonResponse, warning, book_id):\n    if book_format:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('editbook.edit_book', book_id=book_id))\n    else:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book(book_id, book_format, jsonResponse):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if jsonResponse:\n                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                           \"type\": \"danger\",\n                                           \"format\": \"\",\n                                           \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('editbook.edit_book', book_id=book_id))\n                if error:\n                    if jsonResponse:\n                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                                \"type\": \"warning\",\n                                                \"format\": \"\",\n                                                \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                calibre_db.session.rollback()\n                if jsonResponse:\n                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n    return render_delete_book_result(book_format, jsonResponse, warning, book_id)\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book = calibre_db.order_authors(book)\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats=list()\n    allowed_conversion_formats = list()\n    kepub_possible=None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modif_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if book.series_index != series_index:\n        book.series_index = series_index\n        modif_date = True\n    return modif_date\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modif_date = False\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = comments\n            modif_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(text=comments, book=book.id))\n            modif_date = True\n    return modif_date\n\n\ndef edit_book_languages(languages, book, upload=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for l in unknown_languages:\n        log.error('%s is not a valid language', l)\n        if isinstance(invalid, list):\n            invalid.append(l)\n        else:\n            flash(_(u\"%(langname)s is not a valid language\", langname=l), category=\"warning\")\n    # ToDo: Not working correct\n    if upload and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:        \n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\n\ndef edit_cc_data(book_id, book, to_save):\n    changed = False\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\ndef upload_single_file(request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in request.files:\n        requested_file = request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error('Database error: %s', e)\n                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=book.title)\n            WorkerThread.add(current_user.name, TaskUpload(\n                \"<a href=\\\"\" + url_for('web.show_book', book_id=book.id) + \"\\\">\" + uploadText + \"</a>\"))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(request, book):\n    if 'btn-upload-cover' in request.files:\n        requested_file = request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change\n\n\n@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modif_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.debug_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modif_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modif_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = False\n        if edited_books_id:\n            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        return \"\", (403)\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modif_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modif_date |= modification\n            # Handle book tags\n            modif_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modif_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modif_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modif_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modif_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modif_date |= edit_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except Exception as ex:\n        log.debug_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author\n\n\ndef create_book_on_upload(modif_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title)\n    author_dir = helper.get_valid_filename(db_author.name)\n\n    # combine path and normalize path from windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                         'author')\n\n    # Add series_index to book\n    modif_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    modif_date |= edit_book_languages(meta.languages, db_book, upload=True)\n\n    # handle tags\n    modif_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modif_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modif_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")\n    try:\n        copyfile(coverfile, new_coverpath)\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@editbook.route(\"/upload\", methods=[\"GET\", \"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modif_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)\n\n                # Comments needs book id therefore only possible after flush\n                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n\n                error = helper.update_dir_structure_file(book_id,\n                                                   config.config_calibre_dir,\n                                                   input_authors[0],\n                                                   meta.file_path,\n                                                   title_dir + meta.extension.lower())\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                uploadText=_(u\"File %(file)s uploaded\", file=title)\n                WorkerThread.add(current_user.name, TaskUpload(\n                    \"<a href=\\\"\" + url_for('web.show_book', book_id=book_id) + \"\\\">\" + uploadText + \"</a>\"))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                    book_format=book_format_to),\n                    category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n@editbook.route(\"/scholarsearch/<query>\",methods=['GET'])\n@login_required_if_no_ano\n@edit_required\ndef scholar_search(query):\n    if have_scholar:\n        scholar_gen = scholarly.search_pubs(' '.join(query.split('+')))\n        i=0\n        result = []\n        for publication in scholar_gen:\n            del publication['source']\n            result.append(publication)\n            i+=1\n            if(i>=10):\n                break\n        return Response(json.dumps(result),mimetype='application/json')\n    else:\n        return \"[]\"\n\n@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    ret = \"\"\n    if param =='series_index':\n        edit_book_series_index(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n    elif param =='tags':\n        edit_book_tags(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                       mimetype='application/json')\n    elif param =='series':\n        edit_book_series(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                       mimetype='application/json')\n    elif param =='publishers':\n        edit_book_publisher(vals['value'], book)\n        ret =  Response(json.dumps({'success': True,\n                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                       mimetype='application/json')\n    elif param =='languages':\n        invalid = list()\n        edit_book_languages(vals['value'], book, invalid=invalid)\n        if invalid:\n            ret = Response(json.dumps({'success': False,\n                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                           mimetype='application/json')\n        else:\n            lang_names = list()\n            for lang in book.languages:\n                try:\n                    lang_names.append(LC.parse(lang.lang_code).get_language_name(get_locale()))\n                except UnknownLocaleError:\n                    lang_names.append(_(isoLanguages.get(part3=lang.lang_code).name))\n            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                            mimetype='application/json')\n    elif param =='author_sort':\n        book.author_sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                       mimetype='application/json')\n    elif param == 'title':\n        sort = book.sort\n        handle_title_on_edit(book, vals.get('value', \"\"))\n        helper.update_dir_stucture(book.id, config.config_calibre_dir)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                       mimetype='application/json')\n    elif param =='sort':\n        book.sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                       mimetype='application/json')\n    elif param =='authors':\n        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])\n        ret = Response(json.dumps({'success': True,\n                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),\n                       mimetype='application/json')\n    book.last_modified = datetime.utcnow()\n    try:\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error(\"Database error: %s\", e)\n    return ret\n\n\n@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            for book_id in vals:\n                from_book = []\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@editbook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\\n                      helper.get_valid_filename(to_book.authors[0].name)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book(from_book.id,\"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n@editbook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    if vals:\n        for val in vals:\n            modif_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            entries = calibre_db.order_authors(book)\n            author_names = []\n            for authr in entries.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modif_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n# custom jinja filters\n\nfrom __future__ import division, print_function, unicode_literals\nimport datetime\nimport mimetypes\nfrom uuid import uuid4\n\nfrom babel.dates import format_date\nfrom flask import Blueprint, request, url_for\nfrom flask_babel import get_locale\nfrom flask_login import current_user\n\nfrom . import logger\n\n\njinjia = Blueprint('jinjia', __name__)\nlog = logger.create()\n\n\n# pagination links in jinja\n@jinjia.app_template_filter('url_for_other_page')\ndef url_for_other_page(page):\n    args = request.view_args.copy()\n    args['page'] = page\n    for get, val in request.args.items():\n        args[get] = val\n    return url_for(request.endpoint, **args)\n\n\n# shortentitles to at longest nchar, shorten longer words if necessary\n@jinjia.app_template_filter('shortentitle')\ndef shortentitle_filter(s, nchar=20):\n    text = s.split()\n    res = \"\"  # result\n    suml = 0  # overall length\n    for line in text:\n        if suml >= 60:\n            res += '...'\n            break\n        # if word longer than 20 chars truncate line and append '...', otherwise add whole word to result\n        # string, and summarize total length to stop at chars given by nchar\n        if len(line) > nchar:\n            res += line[:(nchar-3)] + '[..] '\n            suml += nchar+3\n        else:\n            res += line + ' '\n            suml += len(line) + 1\n    return res.strip()\n\n\n@jinjia.app_template_filter('mimetype')\ndef mimetype_filter(val):\n    return mimetypes.types_map.get('.' + val, 'application/octet-stream')\n\n\n@jinjia.app_template_filter('formatdate')\ndef formatdate_filter(val):\n    try:\n        return format_date(val, format='medium', locale=get_locale())\n    except AttributeError as e:\n        log.error('Babel error: %s, Current user locale: %s, Current User: %s', e,\n                  current_user.locale,\n                  current_user.name\n                  )\n        return val\n\n\n@jinjia.app_template_filter('formatdateinput')\ndef format_date_input(val):\n    input_date = val.isoformat().split('T', 1)[0]  # Hack to support dates <1900\n    return '' if input_date == \"0101-01-01\" else input_date\n\n\n@jinjia.app_template_filter('strftime')\ndef timestamptodate(date, fmt=None):\n    date = datetime.datetime.fromtimestamp(\n        int(date)/1000\n    )\n    native = date.replace(tzinfo=None)\n    if fmt:\n        time_format = fmt\n    else:\n        time_format = '%d %m %Y - %H:%S'\n    return native.strftime(time_format)\n\n\n@jinjia.app_template_filter('yesno')\ndef yesno(value, yes, no):\n    return yes if value else no\n\n\n@jinjia.app_template_filter('formatfloat')\ndef formatfloat(value, decimals=1):\n    value = 0 if not value else value\n    return ('{0:.' + str(decimals) + 'f}').format(value).rstrip('0').rstrip('.')\n\n\n@jinjia.app_template_filter('formatseriesindex')\ndef formatseriesindex_filter(series_index):\n    if series_index:\n        try:\n            if int(series_index) - series_index == 0:\n                return int(series_index)\n            else:\n                return series_index\n        except ValueError:\n            return series_index\n    return 0\n\n@jinjia.app_template_filter('uuidfilter')\ndef uuidfilter(var):\n    return uuid4()\n\n\n", "{% extends is_xhr|yesno(\"fragment.html\", \"layout.html\") %}\n{% block body %}\n<div class=\"single\">\n  <div class=\"row\">\n    <div class=\"col-sm-3 col-lg-3 col-xs-5\">\n      <div class=\"cover\">\n          <img id=\"detailcover\" title=\"{{entry.title}}\" src=\"{{ url_for('web.get_cover', book_id=entry.id, edit=1|uuidfilter) }}\" alt=\"{{ entry.title }}\" />\n      </div>\n    </div>\n    <div class=\"col-sm-9 col-lg-9 book-meta\">\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Download, send to Kindle, reading\">\n          {% if g.user.role_download() %}\n            {% if entry.data|length %}\n            <div class=\"btn-group\" role=\"group\">\n                {% if entry.data|length < 2 %}\n                  <button id=\"Download\" type=\"button\" class=\"btn btn-primary\">\n                    {{_('Download')}} :\n                  </button>\n                  {% for format in entry.data %}\n                  <a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\" id=\"btnGroupDrop1{{format.format|lower}}\" class=\"btn btn-primary\" role=\"button\">\n                    <span class=\"glyphicon glyphicon-download\"></span>{{format.format}} ({{ format.uncompressed_size|filesizeformat }})\n                  </a>\n                  {% endfor %}\n                {% else %}\n                  <button id=\"btnGroupDrop1\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-download\"></span> {{_('Download')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"btnGroupDrop1\">\n                  {% for format in entry.data %}\n                    <li><a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\">{{format.format}} ({{ format.uncompressed_size|filesizeformat }})</a></li>\n                  {% endfor %}\n                  </ul>\n                {% endif %}\n            </div>\n            {% endif %}\n          {% endif %}\n            {% if g.user.kindle_mail and kindle_list %}\n              {% if kindle_list.__len__() == 1 %}\n                <a href=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=kindle_list[0]['format'], convert=kindle_list[0]['convert'])}}\" id=\"sendbtn\" data-text=\"{{_('Send to Kindle')}}\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-send\"></span> {{kindle_list[0]['text']}}</a>\n              {% else %}\n                <div class=\"btn-group\" role=\"group\">\n                  <button id=\"sendbtn2\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-send\"></span>{{_('Send to Kindle')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"send-to-kindle\">\n                    {% for format in kindle_list %}\n                      <li><a href=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=format['format'], convert=format['convert'])}}\">{{format['text']}}</a></li>\n                    {%endfor%}\n                    </ul>\n                </div>\n              {% endif %}\n            {% endif %}\n          {% if reader_list and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if reader_list|length > 1 %}\n                <button id=\"read-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"read-in-browser\">\n                    {% for format in reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=reader_list[0])}}\" id=\"readbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}} - {{reader_list[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n            {% if audioentries|length > 0 and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if audioentries|length > 1 %}\n                <button id=\"listen-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n                    {% for format in reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n\n              {% for format in entry.data %}\n                  {% if format.format|lower in audioentries %}\n                    <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format.format|lower) }}\">{{format.format|lower }}</a></li>\n                    {% endif %}\n              {% endfor %}\n                  </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=audioentries[0])}}\" id=\"listenbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}} - {{audioentries[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n        </div>\n      </div>\n      <h2 id=\"title\">{{entry.title}}</h2>\n      <p class=\"author\">\n          {% for author in entry.authors %}\n            <a href=\"{{url_for('web.books_list',  data='author', sort_param='stored', book_id=author.id ) }}\">{{author.name.replace('|',',')}}</a>\n            {% if not loop.last %}\n              &amp;\n            {% endif %}\n          {% endfor %}\n        </p>\n      {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n        <p>\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </p>\n        </div>\n      {% endif %}\n\n      {% if entry.series|length > 0 %}\n        <p>{{_(\"Book %(index)s of %(range)s\", index=entry.series_index|formatfloat(2), range=(\"<a href='\" + url_for('web.books_list', data='series', sort_param='stored', book_id=entry.series[0].id) + \"'>\" + entry.series[0].name + \"</a>\")|safe) }}</p>\n\n      {% endif %}\n\n      {% if entry.languages.__len__() > 0 %}\n       <div class=\"languages\">\n       <p>\n      <span class=\"label label-default\">{{_('Language')}}: {% for language in entry.languages %}{{language.language_name}}{% if not loop.last %}, {% endif %}{% endfor %}</span>\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.identifiers|length > 0 %}\n      <div class=\"identifiers\">\n        <p>\n        <span class=\"glyphicon glyphicon-link\"></span>\n        {% for identifier in entry.identifiers %}\n          <a href=\"{{identifier}}\" target=\"_blank\" class=\"btn btn-xs btn-success\" role=\"button\">{{identifier.formatType()}}</a>\n        {%endfor%}\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.tags|length > 0 %}\n\n      <div class=\"tags\">\n      <p>\n        <span class=\"glyphicon glyphicon-tags\"></span>\n\n        {% for tag in entry.tags %}\n          <a href=\"{{ url_for('web.books_list', data='category', sort_param='stored', book_id=tag.id) }}\" class=\"btn btn-xs btn-info\" role=\"button\">{{tag.name}}</a>\n        {%endfor%}\n      </p>\n\n      </div>\n      {% endif %}\n\n      {% if entry.publishers|length > 0 %}\n      <div class=\"publishers\">\n        <p>\n          <span>{{_('Publisher')}}:\n              <a href=\"{{url_for('web.books_list', data='publisher', sort_param='stored', book_id=entry.publishers[0].id ) }}\">{{entry.publishers[0].name}}</a>\n          </span>\n        </p>\n      </div>\n      {% endif %}\n\n      {% if (entry.pubdate|string)[:10] != '0101-01-01' %}\n      <div class=\"publishing-date\">\n        <p>{{_('Published')}}: {{entry.pubdate|formatdate}} </p>\n      </div>\n      {% endif %}\n      {% if cc|length > 0 %}\n\n\n        {% for c in cc %}\n        <div class=\"real_custom_columns\">\n          {% if entry['custom_column_' ~ c.id]|length > 0 %}\n            {{ c.name }}:\n            {% for column in entry['custom_column_' ~ c.id] %}\n              {% if c.datatype == 'rating' %}\n                {{ (column.value / 2)|formatfloat }}\n              {% else %}\n                {% if c.datatype == 'bool' %}\n                  {% if column.value == true %}\n                    <span class=\"glyphicon glyphicon-ok\"></span>\n                  {% else %}\n                    <span class=\"glyphicon glyphicon-remove\"></span>\n                  {% endif %}\n                {% else %}\n                {% if c.datatype == 'float' %}\n                  {{ column.value|formatfloat(2) }}\n                {% elif c.datatype == 'datetime' %}\n                  {{ column.value|formatdate }}\n                {% elif c.datatype == 'comments' %}\n                  {{column.value|safe}}\n                {% elif c.datatype == 'series' %}\n                  {{ '%s [%s]' % (column.value, column.extra|formatfloat(2)) }}\n                {% else %}\n                  {{ column.value }}\n                {% endif %}\n                {% endif %}\n              {% endif %}\n            {% endfor %}\n          {% endif %}\n        </div>\n        {% endfor %}\n      {% endif %}\n      {% if not g.user.is_anonymous %}\n\n        <div class=\"custom_columns\">\n          <p>\n          <form id=\"have_read_form\" action=\"{{ url_for('web.toggle_read', book_id=entry.id)}}\" method=\"POST\">\n            <label class=\"block-label\">\n              <input id=\"have_read_cb\" data-checked=\"{{_('Mark As Unread')}}\" data-unchecked=\"{{_('Mark As Read')}}\" type=\"checkbox\" {% if have_read %}checked{% endif %} >\n              <span>{{_('Read')}}</span>\n            </label>\n          </form>\n          </p>\n          {% if g.user.check_visibility(32768) %}\n          <p>\n            <form id=\"archived_form\" action=\"{{ url_for('web.toggle_archived', book_id=entry.id)}}\" method=\"POST\">\n              <label class=\"block-label\">\n                <input id=\"archived_cb\" data-checked=\"{{_('Restore from archive')}}\" data-unchecked=\"{{_('Add to archive')}}\" type=\"checkbox\" {% if is_archived %}checked{% endif %} >\n                <span>{{_('Archived')}}</span>\n              </label>\n            </form>\n          </p>\n          {% endif %}\n        </div>\n      {% endif %}\n\n\n      {% if entry.comments|length > 0 and entry.comments[0].text|length > 0%}\n        <div class=\"comments\">\n            <h3 id=\"decription\">{{_('Description:')}}</h3>\n            {{entry.comments[0].text|safe}}\n        </div>\n      {% endif %}\n\n\n      <div class=\"more-stuff\">\n\n      {% if g.user.is_authenticated %}\n      {% if g.user.shelf.all() or g.shelves_access %}\n      <div id=\"shelf-actions\" class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Add to shelves\">\n          <button id=\"add-to-shelf\" type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"glyphicon glyphicon-list\"></span> {{_('Add to shelf')}}\n            <span class=\"caret\"></span>\n          </button>\n          <ul id=\"add-to-shelves\" class=\"dropdown-menu\" aria-labelledby=\"add-to-shelf\">\n            {% for shelf in g.shelves_access %}\n              {% if not shelf.id in books_shelfs and ( not shelf.is_public or g.user.role_edit_shelfs() ) %}\n                <li>\n                  <a href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-remove-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-shelf-action=\"add\"\n                  >\n                    {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                  </a>\n                </li>\n              {% endif %}\n            {%endfor%}\n          </ul>\n        </div>\n        <div id=\"remove-from-shelves\" class=\"btn-group\" role=\"group\" aria-label=\"Remove from shelves\">\n          {% if books_shelfs %}\n            {% for shelf in g.shelves_access %}\n              {% if shelf.id in books_shelfs %}\n                <a href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   data-add-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   class=\"btn btn-sm btn-default\" role=\"button\" data-shelf-action=\"remove\"\n                >\n                  <span {% if not shelf.is_public or g.user.role_edit_shelfs() %}\n                        class=\"glyphicon glyphicon-remove\"\n                        {% endif %}></span> {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                </a>\n              {% endif %}\n            {%endfor%}\n          {% endif %}\n        </div>\n        <div id=\"shelf-action-errors\" class=\"pull-left\" role=\"alert\"></div>\n      </div>\n      {% endif %}\n\n      {% endif %}\n      {% if g.user.role_edit() %}\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Edit/Delete book\">\n          <a href=\"{{ url_for('editbook.edit_book', book_id=entry.id) }}\" class=\"btn btn-sm btn-primary\" id=\"edit_book\" role=\"button\"><span class=\"glyphicon glyphicon-edit\"></span> {{_('Edit Metadata')}}</a>\n        </div>\n      </div>\n      {% endif %}\n      </div>\n\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-shelf-add\">\n  <li>\n    <a href=\"<%= add %>\" data-remove-href=\"<%= remove %>\" data-shelf-action=\"add\">\n      <%= content %>\n    </a>\n  </li>\n</script>\n<script type=\"text/template\" id=\"template-shelf-remove\">\n  <a href=\"<%= remove %>\" data-add-href=\"<%= add %>\" class=\"btn btn-sm btn-default\" data-shelf-action=\"remove\">\n    <span class=\"glyphicon glyphicon-remove\"></span> <%= content %>\n  </a>\n</script>\n<script src=\"{{ url_for('static', filename='js/details.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n", "{% extends \"layout.html\" %}\n{% block body %}\n{% if g.user.show_detail_random() %}\n<div class=\"discover random-books\">\n  <h2 class=\"random-books\">{{_('Discover (Random Books)')}}</h2>\n  <div class=\"row display-flex\">\n   {% for entry in random %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\" id=\"books_rand\">\n      <div class=\"cover\">\n          <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n              <span class=\"img\">\n                <img title=\"{{ entry.title }}\" src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\" />\n                {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n              </span>\n          </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{entry.title}}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  </div>\n</div>\n{% endif %}\n<div class=\"discover load-more\">\n  <h2 class=\"{{title}}\">{{_(title)}}</h2>\n    <div class=\"filterheader hidden-xs hidden-sm\">\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, newest first')}}\" id=\"new\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='new')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, oldest first')}}\" id=\"old\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='old')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort title in alphabetical order')}}\" id=\"asc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='abc')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort title in reverse alphabetical order')}}\" id=\"desc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='zyx')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in alphabetical order')}}\" id=\"auth_az\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='authaz')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in reverse alphabetical order')}}\" id=\"auth_za\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='authza')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, newest first')}}\" id=\"pub_new\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='pubnew')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, oldest first')}}\" id=\"pub_old\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='pubold')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      {% if page == 'series' %}\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort ascending according to series index')}}\" id=\"series_asc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='seriesasc')}}\"><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort descending according to series index')}}\" id=\"series_desc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='seriesdesc')}}\"><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      {% endif %}\n    </div>\n\n  <div class=\"row display-flex\">\n    {% if entries[0] %}\n    {% for entry in entries %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\" id=\"books\">\n      <div class=\"cover\">\n          <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n            <span class=\"img\">\n              <img title=\"{{ entry.title }}\" src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\"/>\n              {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n            </span>\n          </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{ entry.title }}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list', data='author', book_id=author.id, sort_param='new') }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list', data='author', book_id=author.id, sort_param='new') }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n          {% for format in entry.data %}\n            {% if format.format|lower in g.constants.EXTENSIONS_AUDIO %}\n            <span class=\"glyphicon glyphicon-music\"></span>\n            {% endif %}\n          {%endfor%}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  {% endif %}\n  </div>\n</div>\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 mutschler, jkrehm, cervinko, janeczku, OzzieIsaacs, csitko\n#                            ok11, issmirnov, idalin\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import division, print_function, unicode_literals\nimport os\nimport sys\nimport datetime\nimport itertools\nimport uuid\nfrom flask import session as flask_session\nfrom binascii import hexlify\n\nfrom flask_login import AnonymousUserMixin, current_user\nfrom flask_login import user_logged_in\nfrom contextlib import contextmanager\n\ntry:\n    from flask_dance.consumer.backend.sqla import OAuthConsumerMixin\n    oauth_support = True\nexcept ImportError as e:\n    # fails on flask-dance >1.3, due to renaming\n    try:\n        from flask_dance.consumer.storage.sqla import OAuthConsumerMixin\n        oauth_support = True\n    except ImportError as e:\n        oauth_support = False\nfrom sqlalchemy import create_engine, exc, exists, event, text\nfrom sqlalchemy import Column, ForeignKey\nfrom sqlalchemy import String, Integer, SmallInteger, Boolean, DateTime, Float, JSON\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.expression import func\ntry:\n    # Compatibility with sqlalchemy 2.0\n    from sqlalchemy.orm import declarative_base\nexcept ImportError:\n    from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import backref, relationship, sessionmaker, Session, scoped_session\nfrom werkzeug.security import generate_password_hash\n\nfrom . import constants, logger, cli\n\nlog = logger.create()\n\nsession = None\napp_DB_path = None\nBase = declarative_base()\nsearched_ids = {}\n\n\ndef signal_store_user_session(object, user):\n    store_user_session()\n\ndef store_user_session():\n    if flask_session.get('_user_id', \"\"):\n        try:\n            if not check_user_session(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\")):\n                user_session = User_Sessions(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\"))\n                session.add(user_session)\n                session.commit()\n                log.info(\"Login and store session : \" + flask_session.get('_id', \"\"))\n            else:\n                log.info(\"Found stored session : \" + flask_session.get('_id', \"\"))\n        except (exc.OperationalError, exc.InvalidRequestError) as e:\n            session.rollback()\n            log.exception(e)\n    else:\n        log.error(\"No user id in session\")\n\ndef delete_user_session(user_id, session_key):\n    try:\n        log.info(\"Deleted session_key : \" + session_key)\n        session.query(User_Sessions).filter(User_Sessions.user_id==user_id,\n                                            User_Sessions.session_key==session_key).delete()\n        session.commit()\n    except (exc.OperationalError, exc.InvalidRequestError):\n        session.rollback()\n        log.exception(e)\n\n\ndef check_user_session(user_id, session_key):\n    try:\n        return bool(session.query(User_Sessions).filter(User_Sessions.user_id==user_id,\n                                                       User_Sessions.session_key==session_key).one_or_none())\n    except (exc.OperationalError, exc.InvalidRequestError):\n        session.rollback()\n        log.exception(e)\n\n\nuser_logged_in.connect(signal_store_user_session)\n\ndef store_ids(result):\n    ids = list()\n    for element in result:\n        ids.append(element.id)\n    searched_ids[current_user.id] = ids\n\n\nclass UserBase:\n\n    @property\n    def is_authenticated(self):\n        return self.is_active\n\n    def _has_role(self, role_flag):\n        return constants.has_flag(self.role, role_flag)\n\n    def role_admin(self):\n        return self._has_role(constants.ROLE_ADMIN)\n\n    def role_download(self):\n        return self._has_role(constants.ROLE_DOWNLOAD)\n\n    def role_upload(self):\n        return self._has_role(constants.ROLE_UPLOAD)\n\n    def role_edit(self):\n        return self._has_role(constants.ROLE_EDIT)\n\n    def role_passwd(self):\n        return self._has_role(constants.ROLE_PASSWD)\n\n    def role_anonymous(self):\n        return self._has_role(constants.ROLE_ANONYMOUS)\n\n    def role_edit_shelfs(self):\n        return self._has_role(constants.ROLE_EDIT_SHELFS)\n\n    def role_delete_books(self):\n        return self._has_role(constants.ROLE_DELETE_BOOKS)\n\n    def role_viewer(self):\n        return self._has_role(constants.ROLE_VIEWER)\n\n    @property\n    def is_active(self):\n        return True\n\n    @property\n    def is_anonymous(self):\n        return self.role_anonymous()\n\n    def get_id(self):\n        return str(self.id)\n\n    def filter_language(self):\n        return self.default_language\n\n    def check_visibility(self, value):\n        if value == constants.SIDEBAR_RECENT:\n            return True\n        return constants.has_flag(self.sidebar_view, value)\n\n    def show_detail_random(self):\n        return self.check_visibility(constants.DETAIL_RANDOM)\n\n    def list_denied_tags(self):\n        mct = self.denied_tags or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_allowed_tags(self):\n        mct = self.allowed_tags or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_denied_column_values(self):\n        mct = self.denied_column_value or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_allowed_column_values(self):\n        mct = self.allowed_column_value or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def get_view_property(self, page, prop):\n        if not self.view_settings.get(page):\n            return None\n        return self.view_settings[page].get(prop)\n\n    def set_view_property(self, page, prop, value):\n        if not self.view_settings.get(page):\n            self.view_settings[page] = dict()\n        self.view_settings[page][prop] = value\n        try:\n            flag_modified(self, \"view_settings\")\n        except AttributeError:\n            pass\n        try:\n            session.commit()\n        except (exc.OperationalError, exc.InvalidRequestError):\n            session.rollback()\n            # ToDo: Error message\n\n    def __repr__(self):\n        return '<User %r>' % self.name\n\n\n# Baseclass for Users in Calibre-Web, settings which are depending on certain users are stored here. It is derived from\n# User Base (all access methods are declared there)\nclass User(UserBase, Base):\n    __tablename__ = 'user'\n    __table_args__ = {'sqlite_autoincrement': True}\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64), unique=True)\n    email = Column(String(120), unique=True, default=\"\")\n    role = Column(SmallInteger, default=constants.ROLE_USER)\n    password = Column(String)\n    kindle_mail = Column(String(120), default=\"\")\n    shelf = relationship('Shelf', backref='user', lazy='dynamic', order_by='Shelf.name')\n    downloads = relationship('Downloads', backref='user', lazy='dynamic')\n    locale = Column(String(2), default=\"en\")\n    sidebar_view = Column(Integer, default=1)\n    default_language = Column(String(3), default=\"all\")\n    denied_tags = Column(String, default=\"\")\n    allowed_tags = Column(String, default=\"\")\n    denied_column_value = Column(String, default=\"\")\n    allowed_column_value = Column(String, default=\"\")\n    remote_auth_token = relationship('RemoteAuthToken', backref='user', lazy='dynamic')\n    view_settings = Column(JSON, default={})\n    kobo_only_shelves_sync = Column(Integer, default=0)\n\n\nif oauth_support:\n    class OAuth(OAuthConsumerMixin, Base):\n        provider_user_id = Column(String(256))\n        user_id = Column(Integer, ForeignKey(User.id))\n        user = relationship(User)\n\n\nclass OAuthProvider(Base):\n    __tablename__ = 'oauthProvider'\n\n    id = Column(Integer, primary_key=True)\n    provider_name = Column(String)\n    oauth_client_id = Column(String)\n    oauth_client_secret = Column(String)\n    active = Column(Boolean)\n\n\n# Class for anonymous user is derived from User base and completly overrides methods and properties for the\n# anonymous user\nclass Anonymous(AnonymousUserMixin, UserBase):\n    def __init__(self):\n        self.loadSettings()\n\n    def loadSettings(self):\n        data = session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS)\\\n            .first()  # type: User\n        self.name = data.name\n        self.role = data.role\n        self.id=data.id\n        self.sidebar_view = data.sidebar_view\n        self.default_language = data.default_language\n        self.locale = data.locale\n        self.kindle_mail = data.kindle_mail\n        self.denied_tags = data.denied_tags\n        self.allowed_tags = data.allowed_tags\n        self.denied_column_value = data.denied_column_value\n        self.allowed_column_value = data.allowed_column_value\n        self.view_settings = data.view_settings\n        self.kobo_only_shelves_sync = data.kobo_only_shelves_sync\n\n\n    def role_admin(self):\n        return False\n\n    @property\n    def is_active(self):\n        return False\n\n    @property\n    def is_anonymous(self):\n        return True\n\n    @property\n    def is_authenticated(self):\n        return False\n\n    def get_view_property(self, page, prop):\n        if 'view' in flask_session:\n            if not flask_session['view'].get(page):\n                return None\n            return flask_session['view'][page].get(prop)\n        return None\n\n    def set_view_property(self, page, prop, value):\n        if 'view' in flask_session:\n            if not flask_session['view'].get(page):\n                flask_session['view'][page] = dict()\n            flask_session['view'][page][prop] = value\n        return None\n\nclass User_Sessions(Base):\n    __tablename__ = 'user_session'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    session_key = Column(String, default=\"\")\n\n    def __init__(self, user_id, session_key):\n        self.user_id = user_id\n        self.session_key = session_key\n\n\n# Baseclass representing Shelfs in calibre-web in app.db\nclass Shelf(Base):\n    __tablename__ = 'shelf'\n\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String, default=lambda: str(uuid.uuid4()))\n    name = Column(String)\n    is_public = Column(Integer, default=0)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    kobo_sync = Column(Boolean, default=False)\n    books = relationship(\"BookShelf\", backref=\"ub_shelf\", cascade=\"all, delete-orphan\", lazy=\"dynamic\")\n    created = Column(DateTime, default=datetime.datetime.utcnow)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n\n    def __repr__(self):\n        return '<Shelf %d:%r>' % (self.id, self.name)\n\n\n# Baseclass representing Relationship between books and Shelfs in Calibre-Web in app.db (N:M)\nclass BookShelf(Base):\n    __tablename__ = 'book_shelf_link'\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer)\n    order = Column(Integer)\n    shelf = Column(Integer, ForeignKey('shelf.id'))\n    date_added = Column(DateTime, default=datetime.datetime.utcnow)\n\n    def __repr__(self):\n        return '<Book %r>' % self.id\n\n\n# This table keeps track of deleted Shelves so that deletes can be propagated to any paired Kobo device.\nclass ShelfArchive(Base):\n    __tablename__ = 'shelf_archive'\n\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow)\n\n\nclass ReadBook(Base):\n    __tablename__ = 'book_read_link'\n\n    STATUS_UNREAD = 0\n    STATUS_FINISHED = 1\n    STATUS_IN_PROGRESS = 2\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer, unique=False)\n    user_id = Column(Integer, ForeignKey('user.id'), unique=False)\n    read_status = Column(Integer, unique=False, default=STATUS_UNREAD, nullable=False)\n    kobo_reading_state = relationship(\"KoboReadingState\", uselist=False,\n                                      primaryjoin=\"and_(ReadBook.user_id == foreign(KoboReadingState.user_id), \"\n                                                  \"ReadBook.book_id == foreign(KoboReadingState.book_id))\",\n                                      cascade=\"all\",\n                                      backref=backref(\"book_read_link\",\n                                                      uselist=False))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    last_time_started_reading = Column(DateTime, nullable=True)\n    times_started_reading = Column(Integer, default=0, nullable=False)\n\n\nclass Bookmark(Base):\n    __tablename__ = 'bookmark'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    format = Column(String(collation='NOCASE'))\n    bookmark_key = Column(String)\n\n\n# Baseclass representing books that are archived on the user's Kobo device.\nclass ArchivedBook(Base):\n    __tablename__ = 'archived_book'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    is_archived = Column(Boolean, unique=False)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow)\n\n\n# The Kobo ReadingState API keeps track of 4 timestamped entities:\n#   ReadingState, StatusInfo, Statistics, CurrentBookmark\n# Which we map to the following 4 tables:\n#   KoboReadingState, ReadBook, KoboStatistics and KoboBookmark\nclass KoboReadingState(Base):\n    __tablename__ = 'kobo_reading_state'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    priority_timestamp = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    current_bookmark = relationship(\"KoboBookmark\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all\")\n    statistics = relationship(\"KoboStatistics\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all\")\n\n\nclass KoboBookmark(Base):\n    __tablename__ = 'kobo_bookmark'\n\n    id = Column(Integer, primary_key=True)\n    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    location_source = Column(String)\n    location_type = Column(String)\n    location_value = Column(String)\n    progress_percent = Column(Float)\n    content_source_progress_percent = Column(Float)\n\n\nclass KoboStatistics(Base):\n    __tablename__ = 'kobo_statistics'\n\n    id = Column(Integer, primary_key=True)\n    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    remaining_time_minutes = Column(Integer)\n    spent_reading_minutes = Column(Integer)\n\n\n# Updates the last_modified timestamp in the KoboReadingState table if any of its children tables are modified.\n@event.listens_for(Session, 'before_flush')\ndef receive_before_flush(session, flush_context, instances):\n    for change in itertools.chain(session.new, session.dirty):\n        if isinstance(change, (ReadBook, KoboStatistics, KoboBookmark)):\n            if change.kobo_reading_state:\n                change.kobo_reading_state.last_modified = datetime.datetime.utcnow()\n    # Maintain the last_modified bit for the Shelf table.\n    for change in itertools.chain(session.new, session.deleted):\n        if isinstance(change, BookShelf):\n            change.ub_shelf.last_modified = datetime.datetime.utcnow()\n\n\n# Baseclass representing Downloads from calibre-web in app.db\nclass Downloads(Base):\n    __tablename__ = 'downloads'\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer)\n    user_id = Column(Integer, ForeignKey('user.id'))\n\n    def __repr__(self):\n        return '<Download %r' % self.book_id\n\n\n# Baseclass representing allowed domains for registration\nclass Registration(Base):\n    __tablename__ = 'registration'\n\n    id = Column(Integer, primary_key=True)\n    domain = Column(String)\n    allow = Column(Integer)\n\n    def __repr__(self):\n        return u\"<Registration('{0}')>\".format(self.domain)\n\n\nclass RemoteAuthToken(Base):\n    __tablename__ = 'remote_auth_token'\n\n    id = Column(Integer, primary_key=True)\n    auth_token = Column(String, unique=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    verified = Column(Boolean, default=False)\n    expiration = Column(DateTime)\n    token_type = Column(Integer, default=0)\n\n    def __init__(self):\n        self.auth_token = (hexlify(os.urandom(4))).decode('utf-8')\n        self.expiration = datetime.datetime.now() + datetime.timedelta(minutes=10)  # 10 min from now\n\n    def __repr__(self):\n        return '<Token %r>' % self.id\n\n\n# Add missing tables during migration of database\ndef add_missing_tables(engine, session):\n    if not engine.dialect.has_table(engine.connect(), \"book_read_link\"):\n        ReadBook.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"bookmark\"):\n        Bookmark.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_reading_state\"):\n        KoboReadingState.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_bookmark\"):\n        KoboBookmark.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_statistics\"):\n        KoboStatistics.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"archived_book\"):\n        ArchivedBook.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"registration\"):\n        Registration.__table__.create(bind=engine)\n        with engine.connect() as conn:\n            conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")\n        session.commit()\n\n\n# migrate all settings missing in registration table\ndef migrate_registration_table(engine, session):\n    try:\n        session.query(exists().where(Registration.allow)).scalar()\n        session.commit()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE registration ADD column 'allow' INTEGER\")\n            conn.execute(\"update registration set 'allow' = 1\")\n        session.commit()\n    try:\n        # Handle table exists, but no content\n        cnt = session.query(Registration).count()\n        if not cnt:\n            with engine.connect() as conn:\n                conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")\n            session.commit()\n    except exc.OperationalError:  # Database is not writeable\n        print('Settings database is not writeable. Exiting...')\n        sys.exit(2)\n\n\n# Remove login capability of user Guest\ndef migrate_guest_password(engine):\n    try:\n        with engine.connect() as conn:\n            trans = conn.begin()\n            conn.execute(text(\"UPDATE user SET password='' where name = 'Guest' and password !=''\"))\n            trans.commit()\n    except exc.OperationalError:\n        print('Settings database is not writeable. Exiting...')\n        sys.exit(2)\n\n\ndef migrate_shelfs(engine, session):\n    try:\n        session.query(exists().where(Shelf.uuid)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE shelf ADD column 'uuid' STRING\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'created' DATETIME\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'last_modified' DATETIME\")\n            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'date_added' DATETIME\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")\n        for shelf in session.query(Shelf).all():\n            shelf.uuid = str(uuid.uuid4())\n            shelf.created = datetime.datetime.now()\n            shelf.last_modified = datetime.datetime.now()\n        for book_shelf in session.query(BookShelf).all():\n            book_shelf.date_added = datetime.datetime.now()\n        session.commit()\n\n    try:\n        session.query(exists().where(Shelf.kobo_sync)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n\n            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")\n        session.commit()\n\n    try:\n        session.query(exists().where(BookShelf.order)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'order' INTEGER DEFAULT 1\")\n        session.commit()\n\n\ndef migrate_readBook(engine, session):\n    try:\n        session.query(exists().where(ReadBook.read_status)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'read_status' INTEGER DEFAULT 0\")\n            conn.execute(\"UPDATE book_read_link SET 'read_status' = 1 WHERE is_read\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_modified' DATETIME\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_time_started_reading' DATETIME\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'times_started_reading' INTEGER DEFAULT 0\")\n        session.commit()\n    test = session.query(ReadBook).filter(ReadBook.last_modified == None).all()\n    for book in test:\n        book.last_modified = datetime.datetime.utcnow()\n    session.commit()\n\n\ndef migrate_remoteAuthToken(engine, session):\n    try:\n        session.query(exists().where(RemoteAuthToken.token_type)).scalar()\n        session.commit()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE remote_auth_token ADD column 'token_type' INTEGER DEFAULT 0\")\n            conn.execute(\"update remote_auth_token set 'token_type' = 0\")\n        session.commit()\n\n# Migrate database to current version, has to be updated after every database change. Currently migration from\n# everywhere to current should work. Migration is done by checking if relevant columns are existing, and than adding\n# rows with SQL commands\ndef migrate_Database(session):\n    engine = session.bind\n    add_missing_tables(engine, session)\n    migrate_registration_table(engine, session)\n    migrate_readBook(engine, session)\n    migrate_remoteAuthToken(engine, session)\n    migrate_shelfs(engine, session)\n    try:\n        create = False\n        session.query(exists().where(User.sidebar_view)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `sidebar_view` Integer DEFAULT 1\")\n        session.commit()\n        create = True\n    try:\n        if create:\n            with engine.connect() as conn:\n                conn.execute(\"SELECT language_books FROM user\")\n            session.commit()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"UPDATE user SET 'sidebar_view' = (random_books* :side_random + language_books * :side_lang \"\n                     \"+ series_books * :side_series + category_books * :side_category + hot_books * \"\n                     \":side_hot + :side_autor + :detail_random)\",\n                     {'side_random': constants.SIDEBAR_RANDOM, 'side_lang': constants.SIDEBAR_LANGUAGE,\n                      'side_series': constants.SIDEBAR_SERIES, 'side_category': constants.SIDEBAR_CATEGORY,\n                      'side_hot': constants.SIDEBAR_HOT, 'side_autor': constants.SIDEBAR_AUTHOR,\n                      'detail_random': constants.DETAIL_RANDOM})\n        session.commit()\n    try:\n        session.query(exists().where(User.denied_tags)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `denied_tags` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `allowed_tags` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `denied_column_value` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `allowed_column_value` String DEFAULT ''\")\n        session.commit()\n    try:\n        session.query(exists().where(User.view_settings)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `view_settings` VARCHAR(10) DEFAULT '{}'\")\n        session.commit()\n    try:\n        session.query(exists().where(User.kobo_only_shelves_sync)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `kobo_only_shelves_sync` SMALLINT DEFAULT 0\")\n        session.commit()\n\n    try:\n        # check if name is in User table instead of nickname\n        session.query(exists().where(User.name)).scalar()\n    except exc.OperationalError:\n        # Create new table user_id and copy contents of table user into it\n        with engine.connect() as conn:\n            conn.execute(text(\"CREATE TABLE user_id (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\"\n                     \"name VARCHAR(64),\"\n                     \"email VARCHAR(120),\"\n                     \"role SMALLINT,\"\n                     \"password VARCHAR,\"\n                     \"kindle_mail VARCHAR(120),\"\n                     \"locale VARCHAR(2),\"\n                     \"sidebar_view INTEGER,\"\n                     \"default_language VARCHAR(3),\"                     \n                     \"denied_tags VARCHAR,\"\n                     \"allowed_tags VARCHAR,\"\n                     \"denied_column_value VARCHAR,\"\n                     \"allowed_column_value VARCHAR,\"\n                     \"view_settings JSON,\"\n                     \"kobo_only_shelves_sync SMALLINT,\"                              \n                     \"UNIQUE (name),\"\n                     \"UNIQUE (email))\"))\n            conn.execute(text(\"INSERT INTO user_id(id, name, email, role, password, kindle_mail,locale,\"\n                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"\n                     \"allowed_column_value, view_settings, kobo_only_shelves_sync)\"\n                     \"SELECT id, nickname, email, role, password, kindle_mail, locale,\"\n                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"\n                     \"allowed_column_value, view_settings, kobo_only_shelves_sync FROM user\"))\n            # delete old user table and rename new user_id table to user:\n            conn.execute(text(\"DROP TABLE user\"))\n            conn.execute(text(\"ALTER TABLE user_id RENAME TO user\"))\n        session.commit()\n    if session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS).first() \\\n       is None:\n        create_anonymous_user(session)\n\n    migrate_guest_password(engine)\n\n\ndef clean_database(session):\n    # Remove expired remote login tokens\n    now = datetime.datetime.now()\n    session.query(RemoteAuthToken).filter(now > RemoteAuthToken.expiration).\\\n        filter(RemoteAuthToken.token_type != 1).delete()\n    session.commit()\n\n\n# Save downloaded books per user in calibre-web's own database\ndef update_download(book_id, user_id):\n    check = session.query(Downloads).filter(Downloads.user_id == user_id).filter(Downloads.book_id == book_id).first()\n\n    if not check:\n        new_download = Downloads(user_id=user_id, book_id=book_id)\n        session.add(new_download)\n        try:\n            session.commit()\n        except exc.OperationalError:\n            session.rollback()\n\n\n# Delete non exisiting downloaded books in calibre-web's own database\ndef delete_download(book_id):\n    session.query(Downloads).filter(book_id == Downloads.book_id).delete()\n    try:\n        session.commit()\n    except exc.OperationalError:\n        session.rollback()\n\n# Generate user Guest (translated text), as anonymous user, no rights\ndef create_anonymous_user(session):\n    user = User()\n    user.name = \"Guest\"\n    user.email = 'no@email'\n    user.role = constants.ROLE_ANONYMOUS\n    user.password = ''\n\n    session.add(user)\n    try:\n        session.commit()\n    except Exception:\n        session.rollback()\n\n\n# Generate User admin with admin123 password, and access to everything\ndef create_admin_user(session):\n    user = User()\n    user.name = \"admin\"\n    user.role = constants.ADMIN_USER_ROLES\n    user.sidebar_view = constants.ADMIN_USER_SIDEBAR\n\n    user.password = generate_password_hash(constants.DEFAULT_PASSWORD)\n\n    session.add(user)\n    try:\n        session.commit()\n    except Exception:\n        session.rollback()\n\n\ndef init_db(app_db_path):\n    # Open session for database connection\n    global session\n    global app_DB_path\n\n    app_DB_path = app_db_path\n    engine = create_engine(u'sqlite:///{0}'.format(app_db_path), echo=False)\n\n    Session = scoped_session(sessionmaker())\n    Session.configure(bind=engine)\n    session = Session()\n\n    if os.path.exists(app_db_path):\n        Base.metadata.create_all(engine)\n        migrate_Database(session)\n        clean_database(session)\n    else:\n        Base.metadata.create_all(engine)\n        create_admin_user(session)\n        create_anonymous_user(session)\n\n    if cli.user_credentials:\n        username, password = cli.user_credentials.split(':', 1)\n        user = session.query(User).filter(func.lower(User.name) == username.lower()).first()\n        if user:\n            if not password:\n                print(\"Empty password is not allowed\")\n                sys.exit(4)\n            user.password = generate_password_hash(password)\n            if session_commit() == \"\":\n                print(\"Password for user '{}' changed\".format(username))\n                sys.exit(0)\n            else:\n                print(\"Failed changing password\")\n                sys.exit(3)\n        else:\n            print(\"Username '{}' not valid, can't change password\".format(username))\n            sys.exit(3)\n\n\ndef dispose():\n    global session\n\n    old_session = session\n    session = None\n    if old_session:\n        try:\n            old_session.close()\n        except Exception:\n            pass\n        if old_session.bind:\n            try:\n                old_session.bind.dispose()\n            except Exception:\n                pass\n\ndef session_commit(success=None):\n    try:\n        session.commit()\n        if success:\n            log.info(success)\n    except (exc.OperationalError, exc.InvalidRequestError) as e:\n        session.rollback()\n        log.debug_or_exception(e)\n    return \"\"\n", "# GDrive Integration\ngevent>20.6.0,<21.2.0\ngreenlet>=0.4.17,<1.2.0\nhttplib2>=0.9.2,<0.20.0\noauth2client>=4.0.0,<4.1.4\nuritemplate>=3.0.0,<3.1.0\npyasn1-modules>=0.0.8,<0.3.0\npyasn1>=0.1.9,<0.5.0\nPyDrive2>=1.3.1,<1.9.0\nPyYAML>=3.12\nrsa>=3.4.2,<4.8.0\nsix>=1.10.0,<1.17.0\n\n# Gdrive and Gmail integration\ngoogle-api-python-client>=1.7.11,<2.1.0\n\n# Gmail\ngoogle-auth-oauthlib>=0.4.3,<0.5.0\n\n# goodreads\ngoodreads>=0.3.2,<0.4.0\npython-Levenshtein>=0.12.0,<0.13.0\n\n# ldap login\npython-ldap>=3.0.0,<3.4.0\nFlask-SimpleLDAP>=1.4.0,<1.5.0\n\n#oauth\nFlask-Dance>=2.0.0,<5.1.0\nSQLAlchemy-Utils>=0.33.5,<0.38.0\n\n# extracting metadata\nlxml>=3.8.0,<4.7.0\nrarfile>=2.7\nscholarly>=1.2.0, <1.3\n\n# other\nnatsort>=2.2.0,<7.2.0\ncomicapi>= 2.2.0,<2.3.0\n\n#Kobo integration\njsonschema>=3.2.0,<3.3.0\n", "Babel>=1.3, <3.0\nFlask-Babel>=0.11.1,<2.1.0\nFlask-Login>=0.3.2,<0.5.1\nFlask-Principal>=0.3.2,<0.5.1\nbackports_abc>=0.4\nFlask>=1.0.2,<2.1.0\niso-639>=0.4.5,<0.5.0\nPyPDF3>=1.0.0,<1.0.4\npytz>=2016.10\nrequests>=2.11.1,<2.25.0\nSQLAlchemy>=1.3.0,<1.5.0\ntornado>=4.1,<6.2\nWand>=0.4.4,<0.7.0\nunidecode>=0.04.19,<1.3.0\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import division, print_function, unicode_literals\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\nfrom lxml.html.clean import clean_html\n\n# Improve this to check if scholarly is available in a global way, like other pythonic libraries\ntry:\n    from scholarly import scholarly\n    have_scholar = True\nexcept ImportError:\n    have_scholar = False\n\nfrom babel import Locale as LC\nfrom babel.core import UnknownLocaleError\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\n\n\n\neditbook = Blueprint('editbook', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                # if inp_element == type_elements:\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if a element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        # if new_element is None:\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            changed = True\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element.replace('|', ',')\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n@editbook.route(\"/ajax/delete/<int:book_id>\")\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book(book_id, \"\", True), mimetype='application/json')\n\n\n@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"})\n@editbook.route(\"/delete/<int:book_id>/<string:book_format>\")\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.Custom_Columns). \\\n        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, jsonResponse, warning, book_id):\n    if book_format:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('editbook.edit_book', book_id=book_id))\n    else:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book(book_id, book_format, jsonResponse):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if jsonResponse:\n                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                           \"type\": \"danger\",\n                                           \"format\": \"\",\n                                           \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('editbook.edit_book', book_id=book_id))\n                if error:\n                    if jsonResponse:\n                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                                \"type\": \"warning\",\n                                                \"format\": \"\",\n                                                \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                calibre_db.session.rollback()\n                if jsonResponse:\n                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n    return render_delete_book_result(book_format, jsonResponse, warning, book_id)\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book = calibre_db.order_authors(book)\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats=list()\n    allowed_conversion_formats = list()\n    kepub_possible=None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modif_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if book.series_index != series_index:\n        book.series_index = series_index\n        modif_date = True\n    return modif_date\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modif_date = False\n    if comments:\n        comments = clean_html(comments)\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = clean_html(comments)\n            modif_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(text=comments, book=book.id))\n            modif_date = True\n    return modif_date\n\n\ndef edit_book_languages(languages, book, upload=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for l in unknown_languages:\n        log.error('%s is not a valid language', l)\n        if isinstance(invalid, list):\n            invalid.append(l)\n        else:\n            flash(_(u\"%(langname)s is not a valid language\", langname=l), category=\"warning\")\n    # ToDo: Not working correct\n    if upload and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:        \n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n        if to_save[cc_string]:\n            to_save[cc_string] = clean_html(to_save[cc_string])\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\n\ndef edit_cc_data(book_id, book, to_save):\n    changed = False\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\ndef upload_single_file(request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in request.files:\n        requested_file = request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error('Database error: %s', e)\n                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=book.title)\n            WorkerThread.add(current_user.name, TaskUpload(\n                \"<a href=\\\"\" + url_for('web.show_book', book_id=book.id) + \"\\\">\" + uploadText + \"</a>\"))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(request, book):\n    if 'btn-upload-cover' in request.files:\n        requested_file = request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change\n\n\n@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modif_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.debug_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modif_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modif_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = False\n        if edited_books_id:\n            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        return \"\", (403)\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modif_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modif_date |= modification\n            # Handle book tags\n            modif_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modif_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modif_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modif_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modif_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modif_date |= edit_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except Exception as ex:\n        log.debug_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author\n\n\ndef create_book_on_upload(modif_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title)\n    author_dir = helper.get_valid_filename(db_author.name)\n\n    # combine path and normalize path from windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                         'author')\n\n    # Add series_index to book\n    modif_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    modif_date |= edit_book_languages(meta.languages, db_book, upload=True)\n\n    # handle tags\n    modif_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modif_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modif_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")\n    try:\n        copyfile(coverfile, new_coverpath)\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@editbook.route(\"/upload\", methods=[\"GET\", \"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modif_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)\n\n                # Comments needs book id therefore only possible after flush\n                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n\n                error = helper.update_dir_structure_file(book_id,\n                                                   config.config_calibre_dir,\n                                                   input_authors[0],\n                                                   meta.file_path,\n                                                   title_dir + meta.extension.lower())\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                uploadText=_(u\"File %(file)s uploaded\", file=title)\n                WorkerThread.add(current_user.name, TaskUpload(\n                    \"<a href=\\\"\" + url_for('web.show_book', book_id=book_id) + \"\\\">\" + uploadText + \"</a>\"))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                    book_format=book_format_to),\n                    category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n@editbook.route(\"/scholarsearch/<query>\",methods=['GET'])\n@login_required_if_no_ano\n@edit_required\ndef scholar_search(query):\n    if have_scholar:\n        scholar_gen = scholarly.search_pubs(' '.join(query.split('+')))\n        i=0\n        result = []\n        for publication in scholar_gen:\n            del publication['source']\n            result.append(publication)\n            i+=1\n            if(i>=10):\n                break\n        return Response(json.dumps(result),mimetype='application/json')\n    else:\n        return \"[]\"\n\n@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    ret = \"\"\n    if param =='series_index':\n        edit_book_series_index(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n    elif param =='tags':\n        edit_book_tags(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                       mimetype='application/json')\n    elif param =='series':\n        edit_book_series(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                       mimetype='application/json')\n    elif param =='publishers':\n        edit_book_publisher(vals['value'], book)\n        ret =  Response(json.dumps({'success': True,\n                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                       mimetype='application/json')\n    elif param =='languages':\n        invalid = list()\n        edit_book_languages(vals['value'], book, invalid=invalid)\n        if invalid:\n            ret = Response(json.dumps({'success': False,\n                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                           mimetype='application/json')\n        else:\n            lang_names = list()\n            for lang in book.languages:\n                try:\n                    lang_names.append(LC.parse(lang.lang_code).get_language_name(get_locale()))\n                except UnknownLocaleError:\n                    lang_names.append(_(isoLanguages.get(part3=lang.lang_code).name))\n            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                            mimetype='application/json')\n    elif param =='author_sort':\n        book.author_sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                       mimetype='application/json')\n    elif param == 'title':\n        sort = book.sort\n        handle_title_on_edit(book, vals.get('value', \"\"))\n        helper.update_dir_stucture(book.id, config.config_calibre_dir)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                       mimetype='application/json')\n    elif param =='sort':\n        book.sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                       mimetype='application/json')\n    elif param =='authors':\n        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])\n        ret = Response(json.dumps({'success': True,\n                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),\n                       mimetype='application/json')\n    book.last_modified = datetime.utcnow()\n    try:\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error(\"Database error: %s\", e)\n    return ret\n\n\n@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            for book_id in vals:\n                from_book = []\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@editbook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\\n                      helper.get_valid_filename(to_book.authors[0].name)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book(from_book.id,\"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n@editbook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    if vals:\n        for val in vals:\n            modif_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            entries = calibre_db.order_authors(book)\n            author_names = []\n            for authr in entries.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modif_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n# custom jinja filters\n\nfrom __future__ import division, print_function, unicode_literals\nimport datetime\nimport mimetypes\nfrom uuid import uuid4\n\nfrom babel.dates import format_date\nfrom flask_babel import gettext as _\nfrom flask import Blueprint, request, url_for\nfrom flask_babel import get_locale\nfrom flask_login import current_user\nfrom markupsafe import escape\nfrom . import logger\n\n\njinjia = Blueprint('jinjia', __name__)\nlog = logger.create()\n\n\n# pagination links in jinja\n@jinjia.app_template_filter('url_for_other_page')\ndef url_for_other_page(page):\n    args = request.view_args.copy()\n    args['page'] = page\n    for get, val in request.args.items():\n        args[get] = val\n    return url_for(request.endpoint, **args)\n\n\n# shortentitles to at longest nchar, shorten longer words if necessary\n@jinjia.app_template_filter('shortentitle')\ndef shortentitle_filter(s, nchar=20):\n    text = s.split()\n    res = \"\"  # result\n    suml = 0  # overall length\n    for line in text:\n        if suml >= 60:\n            res += '...'\n            break\n        # if word longer than 20 chars truncate line and append '...', otherwise add whole word to result\n        # string, and summarize total length to stop at chars given by nchar\n        if len(line) > nchar:\n            res += line[:(nchar-3)] + '[..] '\n            suml += nchar+3\n        else:\n            res += line + ' '\n            suml += len(line) + 1\n    return res.strip()\n\n\n@jinjia.app_template_filter('mimetype')\ndef mimetype_filter(val):\n    return mimetypes.types_map.get('.' + val, 'application/octet-stream')\n\n\n@jinjia.app_template_filter('formatdate')\ndef formatdate_filter(val):\n    try:\n        return format_date(val, format='medium', locale=get_locale())\n    except AttributeError as e:\n        log.error('Babel error: %s, Current user locale: %s, Current User: %s', e,\n                  current_user.locale,\n                  current_user.name\n                  )\n        return val\n\n\n@jinjia.app_template_filter('formatdateinput')\ndef format_date_input(val):\n    input_date = val.isoformat().split('T', 1)[0]  # Hack to support dates <1900\n    return '' if input_date == \"0101-01-01\" else input_date\n\n\n@jinjia.app_template_filter('strftime')\ndef timestamptodate(date, fmt=None):\n    date = datetime.datetime.fromtimestamp(\n        int(date)/1000\n    )\n    native = date.replace(tzinfo=None)\n    if fmt:\n        time_format = fmt\n    else:\n        time_format = '%d %m %Y - %H:%S'\n    return native.strftime(time_format)\n\n\n@jinjia.app_template_filter('yesno')\ndef yesno(value, yes, no):\n    return yes if value else no\n\n\n@jinjia.app_template_filter('formatfloat')\ndef formatfloat(value, decimals=1):\n    value = 0 if not value else value\n    return ('{0:.' + str(decimals) + 'f}').format(value).rstrip('0').rstrip('.')\n\n\n@jinjia.app_template_filter('formatseriesindex')\ndef formatseriesindex_filter(series_index):\n    if series_index:\n        try:\n            if int(series_index) - series_index == 0:\n                return int(series_index)\n            else:\n                return series_index\n        except ValueError:\n            return series_index\n    return 0\n\n@jinjia.app_template_filter('escapedlink')\ndef escapedlink_filter(url, text):\n    return \"<a href='{}'>{}</a>\".format(url, escape(text))\n\n@jinjia.app_template_filter('uuidfilter')\ndef uuidfilter(var):\n    return uuid4()\n\n\n", "{% extends is_xhr|yesno(\"fragment.html\", \"layout.html\") %}\n{% block body %}\n<div class=\"single\">\n  <div class=\"row\">\n    <div class=\"col-sm-3 col-lg-3 col-xs-5\">\n      <div class=\"cover\">\n          <img id=\"detailcover\" title=\"{{entry.title}}\" src=\"{{ url_for('web.get_cover', book_id=entry.id, edit=1|uuidfilter) }}\" alt=\"{{ entry.title }}\" />\n      </div>\n    </div>\n    <div class=\"col-sm-9 col-lg-9 book-meta\">\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Download, send to Kindle, reading\">\n          {% if g.user.role_download() %}\n            {% if entry.data|length %}\n            <div class=\"btn-group\" role=\"group\">\n                {% if entry.data|length < 2 %}\n                  <button id=\"Download\" type=\"button\" class=\"btn btn-primary\">\n                    {{_('Download')}} :\n                  </button>\n                  {% for format in entry.data %}\n                  <a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\" id=\"btnGroupDrop1{{format.format|lower}}\" class=\"btn btn-primary\" role=\"button\">\n                    <span class=\"glyphicon glyphicon-download\"></span>{{format.format}} ({{ format.uncompressed_size|filesizeformat }})\n                  </a>\n                  {% endfor %}\n                {% else %}\n                  <button id=\"btnGroupDrop1\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-download\"></span> {{_('Download')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"btnGroupDrop1\">\n                  {% for format in entry.data %}\n                    <li><a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\">{{format.format}} ({{ format.uncompressed_size|filesizeformat }})</a></li>\n                  {% endfor %}\n                  </ul>\n                {% endif %}\n            </div>\n            {% endif %}\n          {% endif %}\n            {% if g.user.kindle_mail and kindle_list %}\n              {% if kindle_list.__len__() == 1 %}\n                <a href=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=kindle_list[0]['format'], convert=kindle_list[0]['convert'])}}\" id=\"sendbtn\" data-text=\"{{_('Send to Kindle')}}\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-send\"></span> {{kindle_list[0]['text']}}</a>\n              {% else %}\n                <div class=\"btn-group\" role=\"group\">\n                  <button id=\"sendbtn2\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-send\"></span>{{_('Send to Kindle')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"send-to-kindle\">\n                    {% for format in kindle_list %}\n                      <li><a href=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=format['format'], convert=format['convert'])}}\">{{format['text']}}</a></li>\n                    {%endfor%}\n                    </ul>\n                </div>\n              {% endif %}\n            {% endif %}\n          {% if reader_list and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if reader_list|length > 1 %}\n                <button id=\"read-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"read-in-browser\">\n                    {% for format in reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=reader_list[0])}}\" id=\"readbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}} - {{reader_list[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n            {% if audioentries|length > 0 and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if audioentries|length > 1 %}\n                <button id=\"listen-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n                    {% for format in reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n\n              {% for format in entry.data %}\n                  {% if format.format|lower in audioentries %}\n                    <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format.format|lower) }}\">{{format.format|lower }}</a></li>\n                    {% endif %}\n              {% endfor %}\n                  </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=audioentries[0])}}\" id=\"listenbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}} - {{audioentries[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n        </div>\n      </div>\n      <h2 id=\"title\">{{entry.title}}</h2>\n      <p class=\"author\">\n          {% for author in entry.authors %}\n            <a href=\"{{url_for('web.books_list',  data='author', sort_param='stored', book_id=author.id ) }}\">{{author.name.replace('|',',')}}</a>\n            {% if not loop.last %}\n              &amp;\n            {% endif %}\n          {% endfor %}\n        </p>\n      {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n        <p>\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </p>\n        </div>\n      {% endif %}\n      {% if entry.series|length > 0 %}\n          <p>{{_(\"Book %(index)s of %(range)s\", index=entry.series_index | formatfloat(2), range=(url_for('web.books_list', data='series', sort_param='stored', book_id=entry.series[0].id)|escapedlink(entry.series[0].name))|safe)}}</p>\n\n      {% endif %}\n\n      {% if entry.languages.__len__() > 0 %}\n       <div class=\"languages\">\n       <p>\n      <span class=\"label label-default\">{{_('Language')}}: {% for language in entry.languages %}{{language.language_name}}{% if not loop.last %}, {% endif %}{% endfor %}</span>\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.identifiers|length > 0 %}\n      <div class=\"identifiers\">\n        <p>\n        <span class=\"glyphicon glyphicon-link\"></span>\n        {% for identifier in entry.identifiers %}\n          <a href=\"{{identifier}}\" target=\"_blank\" class=\"btn btn-xs btn-success\" role=\"button\">{{identifier.formatType()}}</a>\n        {%endfor%}\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.tags|length > 0 %}\n\n      <div class=\"tags\">\n      <p>\n        <span class=\"glyphicon glyphicon-tags\"></span>\n\n        {% for tag in entry.tags %}\n          <a href=\"{{ url_for('web.books_list', data='category', sort_param='stored', book_id=tag.id) }}\" class=\"btn btn-xs btn-info\" role=\"button\">{{tag.name}}</a>\n        {%endfor%}\n      </p>\n\n      </div>\n      {% endif %}\n\n      {% if entry.publishers|length > 0 %}\n      <div class=\"publishers\">\n        <p>\n          <span>{{_('Publisher')}}:\n              <a href=\"{{url_for('web.books_list', data='publisher', sort_param='stored', book_id=entry.publishers[0].id ) }}\">{{entry.publishers[0].name}}</a>\n          </span>\n        </p>\n      </div>\n      {% endif %}\n\n      {% if (entry.pubdate|string)[:10] != '0101-01-01' %}\n      <div class=\"publishing-date\">\n        <p>{{_('Published')}}: {{entry.pubdate|formatdate}} </p>\n      </div>\n      {% endif %}\n      {% if cc|length > 0 %}\n\n\n        {% for c in cc %}\n        <div class=\"real_custom_columns\">\n          {% if entry['custom_column_' ~ c.id]|length > 0 %}\n            {{ c.name }}:\n            {% for column in entry['custom_column_' ~ c.id] %}\n              {% if c.datatype == 'rating' %}\n                {{ (column.value / 2)|formatfloat }}\n              {% else %}\n                {% if c.datatype == 'bool' %}\n                  {% if column.value == true %}\n                    <span class=\"glyphicon glyphicon-ok\"></span>\n                  {% else %}\n                    <span class=\"glyphicon glyphicon-remove\"></span>\n                  {% endif %}\n                {% else %}\n                {% if c.datatype == 'float' %}\n                  {{ column.value|formatfloat(2) }}\n                {% elif c.datatype == 'datetime' %}\n                  {{ column.value|formatdate }}\n                {% elif c.datatype == 'comments' %}\n                  {{column.value|safe}}\n                {% elif c.datatype == 'series' %}\n                  {{ '%s [%s]' % (column.value, column.extra|formatfloat(2)) }}\n                {% else %}\n                  {{ column.value }}\n                {% endif %}\n                {% endif %}\n              {% endif %}\n            {% endfor %}\n          {% endif %}\n        </div>\n        {% endfor %}\n      {% endif %}\n      {% if not g.user.is_anonymous %}\n\n        <div class=\"custom_columns\">\n          <p>\n          <form id=\"have_read_form\" action=\"{{ url_for('web.toggle_read', book_id=entry.id)}}\" method=\"POST\">\n            <label class=\"block-label\">\n              <input id=\"have_read_cb\" data-checked=\"{{_('Mark As Unread')}}\" data-unchecked=\"{{_('Mark As Read')}}\" type=\"checkbox\" {% if have_read %}checked{% endif %} >\n              <span>{{_('Read')}}</span>\n            </label>\n          </form>\n          </p>\n          {% if g.user.check_visibility(32768) %}\n          <p>\n            <form id=\"archived_form\" action=\"{{ url_for('web.toggle_archived', book_id=entry.id)}}\" method=\"POST\">\n              <label class=\"block-label\">\n                <input id=\"archived_cb\" data-checked=\"{{_('Restore from archive')}}\" data-unchecked=\"{{_('Add to archive')}}\" type=\"checkbox\" {% if is_archived %}checked{% endif %} >\n                <span>{{_('Archived')}}</span>\n              </label>\n            </form>\n          </p>\n          {% endif %}\n        </div>\n      {% endif %}\n\n\n      {% if entry.comments|length > 0 and entry.comments[0].text|length > 0%}\n        <div class=\"comments\">\n            <h3 id=\"decription\">{{_('Description:')}}</h3>\n            {{entry.comments[0].text|safe}}\n        </div>\n      {% endif %}\n\n\n      <div class=\"more-stuff\">\n\n      {% if g.user.is_authenticated %}\n      {% if g.user.shelf.all() or g.shelves_access %}\n      <div id=\"shelf-actions\" class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Add to shelves\">\n          <button id=\"add-to-shelf\" type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"glyphicon glyphicon-list\"></span> {{_('Add to shelf')}}\n            <span class=\"caret\"></span>\n          </button>\n          <ul id=\"add-to-shelves\" class=\"dropdown-menu\" aria-labelledby=\"add-to-shelf\">\n            {% for shelf in g.shelves_access %}\n              {% if not shelf.id in books_shelfs and ( not shelf.is_public or g.user.role_edit_shelfs() ) %}\n                <li>\n                  <a href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-remove-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-shelf-action=\"add\"\n                  >\n                    {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                  </a>\n                </li>\n              {% endif %}\n            {%endfor%}\n          </ul>\n        </div>\n        <div id=\"remove-from-shelves\" class=\"btn-group\" role=\"group\" aria-label=\"Remove from shelves\">\n          {% if books_shelfs %}\n            {% for shelf in g.shelves_access %}\n              {% if shelf.id in books_shelfs %}\n                <a href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   data-add-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   class=\"btn btn-sm btn-default\" role=\"button\" data-shelf-action=\"remove\"\n                >\n                  <span {% if not shelf.is_public or g.user.role_edit_shelfs() %}\n                        class=\"glyphicon glyphicon-remove\"\n                        {% endif %}></span> {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                </a>\n              {% endif %}\n            {%endfor%}\n          {% endif %}\n        </div>\n        <div id=\"shelf-action-errors\" class=\"pull-left\" role=\"alert\"></div>\n      </div>\n      {% endif %}\n\n      {% endif %}\n      {% if g.user.role_edit() %}\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Edit/Delete book\">\n          <a href=\"{{ url_for('editbook.edit_book', book_id=entry.id) }}\" class=\"btn btn-sm btn-primary\" id=\"edit_book\" role=\"button\"><span class=\"glyphicon glyphicon-edit\"></span> {{_('Edit Metadata')}}</a>\n        </div>\n      </div>\n      {% endif %}\n      </div>\n\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-shelf-add\">\n  <li>\n    <a href=\"<%= add %>\" data-remove-href=\"<%= remove %>\" data-shelf-action=\"add\">\n      <%= content %>\n    </a>\n  </li>\n</script>\n<script type=\"text/template\" id=\"template-shelf-remove\">\n  <a href=\"<%= remove %>\" data-add-href=\"<%= add %>\" class=\"btn btn-sm btn-default\" data-shelf-action=\"remove\">\n    <span class=\"glyphicon glyphicon-remove\"></span> <%= content %>\n  </a>\n</script>\n<script src=\"{{ url_for('static', filename='js/details.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n", "{% extends \"layout.html\" %}\n{% block body %}\n{% if g.user.show_detail_random() %}\n<div class=\"discover random-books\">\n  <h2 class=\"random-books\">{{_('Discover (Random Books)')}}</h2>\n  <div class=\"row display-flex\">\n   {% for entry in random %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\" id=\"books_rand\">\n      <div class=\"cover\">\n          <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n              <span class=\"img\">\n                <img title=\"{{ entry.title }}\" src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\" />\n                {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n              </span>\n          </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{entry.title}}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  </div>\n</div>\n{% endif %}\n<div class=\"discover load-more\">\n  <h2 class=\"{{title}}\">{{title}}</h2>\n    <div class=\"filterheader hidden-xs hidden-sm\">\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, newest first')}}\" id=\"new\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='new')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, oldest first')}}\" id=\"old\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='old')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort title in alphabetical order')}}\" id=\"asc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='abc')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort title in reverse alphabetical order')}}\" id=\"desc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='zyx')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in alphabetical order')}}\" id=\"auth_az\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='authaz')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in reverse alphabetical order')}}\" id=\"auth_za\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='authza')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, newest first')}}\" id=\"pub_new\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='pubnew')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, oldest first')}}\" id=\"pub_old\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='pubold')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      {% if page == 'series' %}\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort ascending according to series index')}}\" id=\"series_asc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='seriesasc')}}\"><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n      <a data-toggle=\"tooltip\" title=\"{{_('Sort descending according to series index')}}\" id=\"series_desc\" class=\"btn btn-primary\" href=\"{{url_for('web.books_list', data=page, book_id=id, sort_param='seriesdesc')}}\"><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n      {% endif %}\n    </div>\n\n  <div class=\"row display-flex\">\n    {% if entries[0] %}\n    {% for entry in entries %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\" id=\"books\">\n      <div class=\"cover\">\n          <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n            <span class=\"img\">\n              <img title=\"{{ entry.title }}\" src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\"/>\n              {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n            </span>\n          </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{ entry.title }}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list', data='author', book_id=author.id, sort_param='new') }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list', data='author', book_id=author.id, sort_param='new') }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n          {% for format in entry.data %}\n            {% if format.format|lower in g.constants.EXTENSIONS_AUDIO %}\n            <span class=\"glyphicon glyphicon-music\"></span>\n            {% endif %}\n          {%endfor%}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  {% endif %}\n  </div>\n</div>\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 mutschler, jkrehm, cervinko, janeczku, OzzieIsaacs, csitko\n#                            ok11, issmirnov, idalin\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import division, print_function, unicode_literals\nimport os\nimport sys\nimport datetime\nimport itertools\nimport uuid\nfrom flask import session as flask_session\nfrom binascii import hexlify\n\nfrom flask_login import AnonymousUserMixin, current_user\nfrom flask_login import user_logged_in\nfrom contextlib import contextmanager\n\ntry:\n    from flask_dance.consumer.backend.sqla import OAuthConsumerMixin\n    oauth_support = True\nexcept ImportError as e:\n    # fails on flask-dance >1.3, due to renaming\n    try:\n        from flask_dance.consumer.storage.sqla import OAuthConsumerMixin\n        oauth_support = True\n    except ImportError as e:\n        oauth_support = False\nfrom sqlalchemy import create_engine, exc, exists, event, text\nfrom sqlalchemy import Column, ForeignKey\nfrom sqlalchemy import String, Integer, SmallInteger, Boolean, DateTime, Float, JSON\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.expression import func\ntry:\n    # Compatibility with sqlalchemy 2.0\n    from sqlalchemy.orm import declarative_base\nexcept ImportError:\n    from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import backref, relationship, sessionmaker, Session, scoped_session\nfrom werkzeug.security import generate_password_hash\n\nfrom . import constants, logger, cli\n\nlog = logger.create()\n\nsession = None\napp_DB_path = None\nBase = declarative_base()\nsearched_ids = {}\n\n\ndef signal_store_user_session(object, user):\n    store_user_session()\n\ndef store_user_session():\n    if flask_session.get('_user_id', \"\"):\n        try:\n            if not check_user_session(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\")):\n                user_session = User_Sessions(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\"))\n                session.add(user_session)\n                session.commit()\n                log.debug(\"Login and store session : \" + flask_session.get('_id', \"\"))\n            else:\n                log.debug(\"Found stored session: \" + flask_session.get('_id', \"\"))\n        except (exc.OperationalError, exc.InvalidRequestError) as e:\n            session.rollback()\n            log.exception(e)\n    else:\n        log.error(\"No user id in session\")\n\ndef delete_user_session(user_id, session_key):\n    try:\n        log.debug(\"Deleted session_key: \" + session_key)\n        session.query(User_Sessions).filter(User_Sessions.user_id==user_id,\n                                            User_Sessions.session_key==session_key).delete()\n        session.commit()\n    except (exc.OperationalError, exc.InvalidRequestError):\n        session.rollback()\n        log.exception(e)\n\n\ndef check_user_session(user_id, session_key):\n    try:\n        return bool(session.query(User_Sessions).filter(User_Sessions.user_id==user_id,\n                                                       User_Sessions.session_key==session_key).one_or_none())\n    except (exc.OperationalError, exc.InvalidRequestError):\n        session.rollback()\n        log.exception(e)\n\n\nuser_logged_in.connect(signal_store_user_session)\n\ndef store_ids(result):\n    ids = list()\n    for element in result:\n        ids.append(element.id)\n    searched_ids[current_user.id] = ids\n\n\nclass UserBase:\n\n    @property\n    def is_authenticated(self):\n        return self.is_active\n\n    def _has_role(self, role_flag):\n        return constants.has_flag(self.role, role_flag)\n\n    def role_admin(self):\n        return self._has_role(constants.ROLE_ADMIN)\n\n    def role_download(self):\n        return self._has_role(constants.ROLE_DOWNLOAD)\n\n    def role_upload(self):\n        return self._has_role(constants.ROLE_UPLOAD)\n\n    def role_edit(self):\n        return self._has_role(constants.ROLE_EDIT)\n\n    def role_passwd(self):\n        return self._has_role(constants.ROLE_PASSWD)\n\n    def role_anonymous(self):\n        return self._has_role(constants.ROLE_ANONYMOUS)\n\n    def role_edit_shelfs(self):\n        return self._has_role(constants.ROLE_EDIT_SHELFS)\n\n    def role_delete_books(self):\n        return self._has_role(constants.ROLE_DELETE_BOOKS)\n\n    def role_viewer(self):\n        return self._has_role(constants.ROLE_VIEWER)\n\n    @property\n    def is_active(self):\n        return True\n\n    @property\n    def is_anonymous(self):\n        return self.role_anonymous()\n\n    def get_id(self):\n        return str(self.id)\n\n    def filter_language(self):\n        return self.default_language\n\n    def check_visibility(self, value):\n        if value == constants.SIDEBAR_RECENT:\n            return True\n        return constants.has_flag(self.sidebar_view, value)\n\n    def show_detail_random(self):\n        return self.check_visibility(constants.DETAIL_RANDOM)\n\n    def list_denied_tags(self):\n        mct = self.denied_tags or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_allowed_tags(self):\n        mct = self.allowed_tags or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_denied_column_values(self):\n        mct = self.denied_column_value or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def list_allowed_column_values(self):\n        mct = self.allowed_column_value or \"\"\n        return [t.strip() for t in mct.split(\",\")]\n\n    def get_view_property(self, page, prop):\n        if not self.view_settings.get(page):\n            return None\n        return self.view_settings[page].get(prop)\n\n    def set_view_property(self, page, prop, value):\n        if not self.view_settings.get(page):\n            self.view_settings[page] = dict()\n        self.view_settings[page][prop] = value\n        try:\n            flag_modified(self, \"view_settings\")\n        except AttributeError:\n            pass\n        try:\n            session.commit()\n        except (exc.OperationalError, exc.InvalidRequestError):\n            session.rollback()\n            # ToDo: Error message\n\n    def __repr__(self):\n        return '<User %r>' % self.name\n\n\n# Baseclass for Users in Calibre-Web, settings which are depending on certain users are stored here. It is derived from\n# User Base (all access methods are declared there)\nclass User(UserBase, Base):\n    __tablename__ = 'user'\n    __table_args__ = {'sqlite_autoincrement': True}\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64), unique=True)\n    email = Column(String(120), unique=True, default=\"\")\n    role = Column(SmallInteger, default=constants.ROLE_USER)\n    password = Column(String)\n    kindle_mail = Column(String(120), default=\"\")\n    shelf = relationship('Shelf', backref='user', lazy='dynamic', order_by='Shelf.name')\n    downloads = relationship('Downloads', backref='user', lazy='dynamic')\n    locale = Column(String(2), default=\"en\")\n    sidebar_view = Column(Integer, default=1)\n    default_language = Column(String(3), default=\"all\")\n    denied_tags = Column(String, default=\"\")\n    allowed_tags = Column(String, default=\"\")\n    denied_column_value = Column(String, default=\"\")\n    allowed_column_value = Column(String, default=\"\")\n    remote_auth_token = relationship('RemoteAuthToken', backref='user', lazy='dynamic')\n    view_settings = Column(JSON, default={})\n    kobo_only_shelves_sync = Column(Integer, default=0)\n\n\nif oauth_support:\n    class OAuth(OAuthConsumerMixin, Base):\n        provider_user_id = Column(String(256))\n        user_id = Column(Integer, ForeignKey(User.id))\n        user = relationship(User)\n\n\nclass OAuthProvider(Base):\n    __tablename__ = 'oauthProvider'\n\n    id = Column(Integer, primary_key=True)\n    provider_name = Column(String)\n    oauth_client_id = Column(String)\n    oauth_client_secret = Column(String)\n    active = Column(Boolean)\n\n\n# Class for anonymous user is derived from User base and completly overrides methods and properties for the\n# anonymous user\nclass Anonymous(AnonymousUserMixin, UserBase):\n    def __init__(self):\n        self.loadSettings()\n\n    def loadSettings(self):\n        data = session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS)\\\n            .first()  # type: User\n        self.name = data.name\n        self.role = data.role\n        self.id=data.id\n        self.sidebar_view = data.sidebar_view\n        self.default_language = data.default_language\n        self.locale = data.locale\n        self.kindle_mail = data.kindle_mail\n        self.denied_tags = data.denied_tags\n        self.allowed_tags = data.allowed_tags\n        self.denied_column_value = data.denied_column_value\n        self.allowed_column_value = data.allowed_column_value\n        self.view_settings = data.view_settings\n        self.kobo_only_shelves_sync = data.kobo_only_shelves_sync\n\n\n    def role_admin(self):\n        return False\n\n    @property\n    def is_active(self):\n        return False\n\n    @property\n    def is_anonymous(self):\n        return True\n\n    @property\n    def is_authenticated(self):\n        return False\n\n    def get_view_property(self, page, prop):\n        if 'view' in flask_session:\n            if not flask_session['view'].get(page):\n                return None\n            return flask_session['view'][page].get(prop)\n        return None\n\n    def set_view_property(self, page, prop, value):\n        if 'view' in flask_session:\n            if not flask_session['view'].get(page):\n                flask_session['view'][page] = dict()\n            flask_session['view'][page][prop] = value\n        return None\n\nclass User_Sessions(Base):\n    __tablename__ = 'user_session'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    session_key = Column(String, default=\"\")\n\n    def __init__(self, user_id, session_key):\n        self.user_id = user_id\n        self.session_key = session_key\n\n\n# Baseclass representing Shelfs in calibre-web in app.db\nclass Shelf(Base):\n    __tablename__ = 'shelf'\n\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String, default=lambda: str(uuid.uuid4()))\n    name = Column(String)\n    is_public = Column(Integer, default=0)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    kobo_sync = Column(Boolean, default=False)\n    books = relationship(\"BookShelf\", backref=\"ub_shelf\", cascade=\"all, delete-orphan\", lazy=\"dynamic\")\n    created = Column(DateTime, default=datetime.datetime.utcnow)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n\n    def __repr__(self):\n        return '<Shelf %d:%r>' % (self.id, self.name)\n\n\n# Baseclass representing Relationship between books and Shelfs in Calibre-Web in app.db (N:M)\nclass BookShelf(Base):\n    __tablename__ = 'book_shelf_link'\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer)\n    order = Column(Integer)\n    shelf = Column(Integer, ForeignKey('shelf.id'))\n    date_added = Column(DateTime, default=datetime.datetime.utcnow)\n\n    def __repr__(self):\n        return '<Book %r>' % self.id\n\n\n# This table keeps track of deleted Shelves so that deletes can be propagated to any paired Kobo device.\nclass ShelfArchive(Base):\n    __tablename__ = 'shelf_archive'\n\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow)\n\n\nclass ReadBook(Base):\n    __tablename__ = 'book_read_link'\n\n    STATUS_UNREAD = 0\n    STATUS_FINISHED = 1\n    STATUS_IN_PROGRESS = 2\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer, unique=False)\n    user_id = Column(Integer, ForeignKey('user.id'), unique=False)\n    read_status = Column(Integer, unique=False, default=STATUS_UNREAD, nullable=False)\n    kobo_reading_state = relationship(\"KoboReadingState\", uselist=False,\n                                      primaryjoin=\"and_(ReadBook.user_id == foreign(KoboReadingState.user_id), \"\n                                                  \"ReadBook.book_id == foreign(KoboReadingState.book_id))\",\n                                      cascade=\"all\",\n                                      backref=backref(\"book_read_link\",\n                                                      uselist=False))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    last_time_started_reading = Column(DateTime, nullable=True)\n    times_started_reading = Column(Integer, default=0, nullable=False)\n\n\nclass Bookmark(Base):\n    __tablename__ = 'bookmark'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    format = Column(String(collation='NOCASE'))\n    bookmark_key = Column(String)\n\n\n# Baseclass representing books that are archived on the user's Kobo device.\nclass ArchivedBook(Base):\n    __tablename__ = 'archived_book'\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    is_archived = Column(Boolean, unique=False)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow)\n\n\n# The Kobo ReadingState API keeps track of 4 timestamped entities:\n#   ReadingState, StatusInfo, Statistics, CurrentBookmark\n# Which we map to the following 4 tables:\n#   KoboReadingState, ReadBook, KoboStatistics and KoboBookmark\nclass KoboReadingState(Base):\n    __tablename__ = 'kobo_reading_state'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    book_id = Column(Integer)\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    priority_timestamp = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    current_bookmark = relationship(\"KoboBookmark\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all\")\n    statistics = relationship(\"KoboStatistics\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all\")\n\n\nclass KoboBookmark(Base):\n    __tablename__ = 'kobo_bookmark'\n\n    id = Column(Integer, primary_key=True)\n    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    location_source = Column(String)\n    location_type = Column(String)\n    location_value = Column(String)\n    progress_percent = Column(Float)\n    content_source_progress_percent = Column(Float)\n\n\nclass KoboStatistics(Base):\n    __tablename__ = 'kobo_statistics'\n\n    id = Column(Integer, primary_key=True)\n    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))\n    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)\n    remaining_time_minutes = Column(Integer)\n    spent_reading_minutes = Column(Integer)\n\n\n# Updates the last_modified timestamp in the KoboReadingState table if any of its children tables are modified.\n@event.listens_for(Session, 'before_flush')\ndef receive_before_flush(session, flush_context, instances):\n    for change in itertools.chain(session.new, session.dirty):\n        if isinstance(change, (ReadBook, KoboStatistics, KoboBookmark)):\n            if change.kobo_reading_state:\n                change.kobo_reading_state.last_modified = datetime.datetime.utcnow()\n    # Maintain the last_modified bit for the Shelf table.\n    for change in itertools.chain(session.new, session.deleted):\n        if isinstance(change, BookShelf):\n            change.ub_shelf.last_modified = datetime.datetime.utcnow()\n\n\n# Baseclass representing Downloads from calibre-web in app.db\nclass Downloads(Base):\n    __tablename__ = 'downloads'\n\n    id = Column(Integer, primary_key=True)\n    book_id = Column(Integer)\n    user_id = Column(Integer, ForeignKey('user.id'))\n\n    def __repr__(self):\n        return '<Download %r' % self.book_id\n\n\n# Baseclass representing allowed domains for registration\nclass Registration(Base):\n    __tablename__ = 'registration'\n\n    id = Column(Integer, primary_key=True)\n    domain = Column(String)\n    allow = Column(Integer)\n\n    def __repr__(self):\n        return u\"<Registration('{0}')>\".format(self.domain)\n\n\nclass RemoteAuthToken(Base):\n    __tablename__ = 'remote_auth_token'\n\n    id = Column(Integer, primary_key=True)\n    auth_token = Column(String, unique=True)\n    user_id = Column(Integer, ForeignKey('user.id'))\n    verified = Column(Boolean, default=False)\n    expiration = Column(DateTime)\n    token_type = Column(Integer, default=0)\n\n    def __init__(self):\n        self.auth_token = (hexlify(os.urandom(4))).decode('utf-8')\n        self.expiration = datetime.datetime.now() + datetime.timedelta(minutes=10)  # 10 min from now\n\n    def __repr__(self):\n        return '<Token %r>' % self.id\n\n\n# Add missing tables during migration of database\ndef add_missing_tables(engine, session):\n    if not engine.dialect.has_table(engine.connect(), \"book_read_link\"):\n        ReadBook.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"bookmark\"):\n        Bookmark.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_reading_state\"):\n        KoboReadingState.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_bookmark\"):\n        KoboBookmark.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"kobo_statistics\"):\n        KoboStatistics.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"archived_book\"):\n        ArchivedBook.__table__.create(bind=engine)\n    if not engine.dialect.has_table(engine.connect(), \"registration\"):\n        Registration.__table__.create(bind=engine)\n        with engine.connect() as conn:\n            conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")\n        session.commit()\n\n\n# migrate all settings missing in registration table\ndef migrate_registration_table(engine, session):\n    try:\n        session.query(exists().where(Registration.allow)).scalar()\n        session.commit()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE registration ADD column 'allow' INTEGER\")\n            conn.execute(\"update registration set 'allow' = 1\")\n        session.commit()\n    try:\n        # Handle table exists, but no content\n        cnt = session.query(Registration).count()\n        if not cnt:\n            with engine.connect() as conn:\n                conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")\n            session.commit()\n    except exc.OperationalError:  # Database is not writeable\n        print('Settings database is not writeable. Exiting...')\n        sys.exit(2)\n\n\n# Remove login capability of user Guest\ndef migrate_guest_password(engine):\n    try:\n        with engine.connect() as conn:\n            trans = conn.begin()\n            conn.execute(text(\"UPDATE user SET password='' where name = 'Guest' and password !=''\"))\n            trans.commit()\n    except exc.OperationalError:\n        print('Settings database is not writeable. Exiting...')\n        sys.exit(2)\n\n\ndef migrate_shelfs(engine, session):\n    try:\n        session.query(exists().where(Shelf.uuid)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE shelf ADD column 'uuid' STRING\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'created' DATETIME\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'last_modified' DATETIME\")\n            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'date_added' DATETIME\")\n            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")\n        for shelf in session.query(Shelf).all():\n            shelf.uuid = str(uuid.uuid4())\n            shelf.created = datetime.datetime.now()\n            shelf.last_modified = datetime.datetime.now()\n        for book_shelf in session.query(BookShelf).all():\n            book_shelf.date_added = datetime.datetime.now()\n        session.commit()\n\n    try:\n        session.query(exists().where(Shelf.kobo_sync)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n\n            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")\n        session.commit()\n\n    try:\n        session.query(exists().where(BookShelf.order)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'order' INTEGER DEFAULT 1\")\n        session.commit()\n\n\ndef migrate_readBook(engine, session):\n    try:\n        session.query(exists().where(ReadBook.read_status)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'read_status' INTEGER DEFAULT 0\")\n            conn.execute(\"UPDATE book_read_link SET 'read_status' = 1 WHERE is_read\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_modified' DATETIME\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_time_started_reading' DATETIME\")\n            conn.execute(\"ALTER TABLE book_read_link ADD column 'times_started_reading' INTEGER DEFAULT 0\")\n        session.commit()\n    test = session.query(ReadBook).filter(ReadBook.last_modified == None).all()\n    for book in test:\n        book.last_modified = datetime.datetime.utcnow()\n    session.commit()\n\n\ndef migrate_remoteAuthToken(engine, session):\n    try:\n        session.query(exists().where(RemoteAuthToken.token_type)).scalar()\n        session.commit()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE remote_auth_token ADD column 'token_type' INTEGER DEFAULT 0\")\n            conn.execute(\"update remote_auth_token set 'token_type' = 0\")\n        session.commit()\n\n# Migrate database to current version, has to be updated after every database change. Currently migration from\n# everywhere to current should work. Migration is done by checking if relevant columns are existing, and than adding\n# rows with SQL commands\ndef migrate_Database(session):\n    engine = session.bind\n    add_missing_tables(engine, session)\n    migrate_registration_table(engine, session)\n    migrate_readBook(engine, session)\n    migrate_remoteAuthToken(engine, session)\n    migrate_shelfs(engine, session)\n    try:\n        create = False\n        session.query(exists().where(User.sidebar_view)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `sidebar_view` Integer DEFAULT 1\")\n        session.commit()\n        create = True\n    try:\n        if create:\n            with engine.connect() as conn:\n                conn.execute(\"SELECT language_books FROM user\")\n            session.commit()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"UPDATE user SET 'sidebar_view' = (random_books* :side_random + language_books * :side_lang \"\n                     \"+ series_books * :side_series + category_books * :side_category + hot_books * \"\n                     \":side_hot + :side_autor + :detail_random)\",\n                     {'side_random': constants.SIDEBAR_RANDOM, 'side_lang': constants.SIDEBAR_LANGUAGE,\n                      'side_series': constants.SIDEBAR_SERIES, 'side_category': constants.SIDEBAR_CATEGORY,\n                      'side_hot': constants.SIDEBAR_HOT, 'side_autor': constants.SIDEBAR_AUTHOR,\n                      'detail_random': constants.DETAIL_RANDOM})\n        session.commit()\n    try:\n        session.query(exists().where(User.denied_tags)).scalar()\n    except exc.OperationalError:  # Database is not compatible, some columns are missing\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `denied_tags` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `allowed_tags` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `denied_column_value` String DEFAULT ''\")\n            conn.execute(\"ALTER TABLE user ADD column `allowed_column_value` String DEFAULT ''\")\n        session.commit()\n    try:\n        session.query(exists().where(User.view_settings)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `view_settings` VARCHAR(10) DEFAULT '{}'\")\n        session.commit()\n    try:\n        session.query(exists().where(User.kobo_only_shelves_sync)).scalar()\n    except exc.OperationalError:\n        with engine.connect() as conn:\n            conn.execute(\"ALTER TABLE user ADD column `kobo_only_shelves_sync` SMALLINT DEFAULT 0\")\n        session.commit()\n\n    try:\n        # check if name is in User table instead of nickname\n        session.query(exists().where(User.name)).scalar()\n    except exc.OperationalError:\n        # Create new table user_id and copy contents of table user into it\n        with engine.connect() as conn:\n            conn.execute(text(\"CREATE TABLE user_id (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\"\n                     \"name VARCHAR(64),\"\n                     \"email VARCHAR(120),\"\n                     \"role SMALLINT,\"\n                     \"password VARCHAR,\"\n                     \"kindle_mail VARCHAR(120),\"\n                     \"locale VARCHAR(2),\"\n                     \"sidebar_view INTEGER,\"\n                     \"default_language VARCHAR(3),\"                     \n                     \"denied_tags VARCHAR,\"\n                     \"allowed_tags VARCHAR,\"\n                     \"denied_column_value VARCHAR,\"\n                     \"allowed_column_value VARCHAR,\"\n                     \"view_settings JSON,\"\n                     \"kobo_only_shelves_sync SMALLINT,\"                              \n                     \"UNIQUE (name),\"\n                     \"UNIQUE (email))\"))\n            conn.execute(text(\"INSERT INTO user_id(id, name, email, role, password, kindle_mail,locale,\"\n                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"\n                     \"allowed_column_value, view_settings, kobo_only_shelves_sync)\"\n                     \"SELECT id, nickname, email, role, password, kindle_mail, locale,\"\n                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"\n                     \"allowed_column_value, view_settings, kobo_only_shelves_sync FROM user\"))\n            # delete old user table and rename new user_id table to user:\n            conn.execute(text(\"DROP TABLE user\"))\n            conn.execute(text(\"ALTER TABLE user_id RENAME TO user\"))\n        session.commit()\n    if session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS).first() \\\n       is None:\n        create_anonymous_user(session)\n\n    migrate_guest_password(engine)\n\n\ndef clean_database(session):\n    # Remove expired remote login tokens\n    now = datetime.datetime.now()\n    session.query(RemoteAuthToken).filter(now > RemoteAuthToken.expiration).\\\n        filter(RemoteAuthToken.token_type != 1).delete()\n    session.commit()\n\n\n# Save downloaded books per user in calibre-web's own database\ndef update_download(book_id, user_id):\n    check = session.query(Downloads).filter(Downloads.user_id == user_id).filter(Downloads.book_id == book_id).first()\n\n    if not check:\n        new_download = Downloads(user_id=user_id, book_id=book_id)\n        session.add(new_download)\n        try:\n            session.commit()\n        except exc.OperationalError:\n            session.rollback()\n\n\n# Delete non exisiting downloaded books in calibre-web's own database\ndef delete_download(book_id):\n    session.query(Downloads).filter(book_id == Downloads.book_id).delete()\n    try:\n        session.commit()\n    except exc.OperationalError:\n        session.rollback()\n\n# Generate user Guest (translated text), as anonymous user, no rights\ndef create_anonymous_user(session):\n    user = User()\n    user.name = \"Guest\"\n    user.email = 'no@email'\n    user.role = constants.ROLE_ANONYMOUS\n    user.password = ''\n\n    session.add(user)\n    try:\n        session.commit()\n    except Exception:\n        session.rollback()\n\n\n# Generate User admin with admin123 password, and access to everything\ndef create_admin_user(session):\n    user = User()\n    user.name = \"admin\"\n    user.role = constants.ADMIN_USER_ROLES\n    user.sidebar_view = constants.ADMIN_USER_SIDEBAR\n\n    user.password = generate_password_hash(constants.DEFAULT_PASSWORD)\n\n    session.add(user)\n    try:\n        session.commit()\n    except Exception:\n        session.rollback()\n\n\ndef init_db(app_db_path):\n    # Open session for database connection\n    global session\n    global app_DB_path\n\n    app_DB_path = app_db_path\n    engine = create_engine(u'sqlite:///{0}'.format(app_db_path), echo=False)\n\n    Session = scoped_session(sessionmaker())\n    Session.configure(bind=engine)\n    session = Session()\n\n    if os.path.exists(app_db_path):\n        Base.metadata.create_all(engine)\n        migrate_Database(session)\n        clean_database(session)\n    else:\n        Base.metadata.create_all(engine)\n        create_admin_user(session)\n        create_anonymous_user(session)\n\n    if cli.user_credentials:\n        username, password = cli.user_credentials.split(':', 1)\n        user = session.query(User).filter(func.lower(User.name) == username.lower()).first()\n        if user:\n            if not password:\n                print(\"Empty password is not allowed\")\n                sys.exit(4)\n            user.password = generate_password_hash(password)\n            if session_commit() == \"\":\n                print(\"Password for user '{}' changed\".format(username))\n                sys.exit(0)\n            else:\n                print(\"Failed changing password\")\n                sys.exit(3)\n        else:\n            print(\"Username '{}' not valid, can't change password\".format(username))\n            sys.exit(3)\n\n\ndef dispose():\n    global session\n\n    old_session = session\n    session = None\n    if old_session:\n        try:\n            old_session.close()\n        except Exception:\n            pass\n        if old_session.bind:\n            try:\n                old_session.bind.dispose()\n            except Exception:\n                pass\n\ndef session_commit(success=None):\n    try:\n        session.commit()\n        if success:\n            log.info(success)\n    except (exc.OperationalError, exc.InvalidRequestError) as e:\n        session.rollback()\n        log.debug_or_exception(e)\n    return \"\"\n", "# GDrive Integration\ngevent>20.6.0,<21.2.0\ngreenlet>=0.4.17,<1.2.0\nhttplib2>=0.9.2,<0.20.0\noauth2client>=4.0.0,<4.1.4\nuritemplate>=3.0.0,<3.1.0\npyasn1-modules>=0.0.8,<0.3.0\npyasn1>=0.1.9,<0.5.0\nPyDrive2>=1.3.1,<1.9.0\nPyYAML>=3.12\nrsa>=3.4.2,<4.8.0\nsix>=1.10.0,<1.17.0\n\n# Gdrive and Gmail integration\ngoogle-api-python-client>=1.7.11,<2.1.0\n\n# Gmail\ngoogle-auth-oauthlib>=0.4.3,<0.5.0\n\n# goodreads\ngoodreads>=0.3.2,<0.4.0\npython-Levenshtein>=0.12.0,<0.13.0\n\n# ldap login\npython-ldap>=3.0.0,<3.4.0\nFlask-SimpleLDAP>=1.4.0,<1.5.0\n\n#oauth\nFlask-Dance>=2.0.0,<5.1.0\nSQLAlchemy-Utils>=0.33.5,<0.38.0\n\n# extracting metadata\nrarfile>=2.7\nscholarly>=1.2.0, <1.3\n\n# other\nnatsort>=2.2.0,<7.2.0\ncomicapi>= 2.2.0,<2.3.0\n\n#Kobo integration\njsonschema>=3.2.0,<3.3.0\n", "Babel>=1.3, <3.0\nFlask-Babel>=0.11.1,<2.1.0\nFlask-Login>=0.3.2,<0.5.1\nFlask-Principal>=0.3.2,<0.5.1\nbackports_abc>=0.4\nFlask>=1.0.2,<2.1.0\niso-639>=0.4.5,<0.5.0\nPyPDF3>=1.0.0,<1.0.4\npytz>=2016.10\nrequests>=2.11.1,<2.25.0\nSQLAlchemy>=1.3.0,<1.5.0\ntornado>=4.1,<6.2\nWand>=0.4.4,<0.7.0\nunidecode>=0.04.19,<1.3.0\nlxml>=3.8.0,<4.7.0\n"], "filenames": ["cps/editbooks.py", "cps/jinjia.py", "cps/templates/detail.html", "cps/templates/index.html", "cps/ub.py", "optional-requirements.txt", "requirements.txt"], "buggy_code_start_loc": [28, 30, 123, 66, 76, 33, 14], "buggy_code_end_loc": [517, 131, 126, 67, 88, 34, 14], "fixing_code_start_loc": [29, 31, 122, 66, 76, 32, 15], "fixing_code_end_loc": [523, 137, 125, 67, 88, 32, 16], "type": "CWE-79", "message": "In \u201cCalibre-web\u201d application, v0.6.0 to v0.6.12, are vulnerable to Stored XSS in \u201cMetadata\u201d. An attacker that has access to edit the metadata information, can inject JavaScript payload in the description field. When a victim tries to open the file, XSS will be triggered.", "other": {"cve": {"id": "CVE-2021-25964", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-10-04T15:15:07.310", "lastModified": "2021-10-08T16:54:25.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In \u201cCalibre-web\u201d application, v0.6.0 to v0.6.12, are vulnerable to Stored XSS in \u201cMetadata\u201d. An attacker that has access to edit the metadata information, can inject JavaScript payload in the description field. When a victim tries to open the file, XSS will be triggered."}, {"lang": "es", "value": "En la aplicaci\u00f3n \"Calibre-web\", versiones v0.6.0 a v0.6.12, son vulnerables a un ataque de tipo XSS almacenado en \"Metadata\". Un atacante que tenga acceso a editar la informaci\u00f3n de los metadatos, puede inyectar una carga \u00fatil de JavaScript en el campo description. Cuando una v\u00edctima intente abrir el archivo, el ataque de tipo XSS ser\u00e1 desencadenado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.6.0", "versionEndExcluding": "0.6.12", "matchCriteriaId": "6FF6EA1D-D6C6-4A33-877E-F29514871A6D"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/32e27712f0f71fdec646add20cd78b4ce75acfce", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25964", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/32e27712f0f71fdec646add20cd78b4ce75acfce"}}