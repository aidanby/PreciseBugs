{"buggy_code": ["{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE StrictData #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Wire.API.User.Client\n  ( -- * UserClients\n    UserClientMap (..),\n    QualifiedUserClientMap (..),\n    UserClients (..),\n    QualifiedUserClients (..),\n    filterClients,\n\n    -- * Client\n    Client (..),\n    PubClient (..),\n    ClientType (..),\n    ClientClass (..),\n\n    -- * New/Update/Remove Client\n    NewClient (..),\n    newClient,\n    UpdateClient (..),\n    RmClient (..),\n\n    -- * re-exports\n    Location,\n    location,\n    latitude,\n    longitude,\n    Latitude (..),\n    Longitude (..),\n\n    -- * Swagger\n    modelOtrClientMap,\n    modelUserClients,\n    modelNewClient,\n    modelUpdateClient,\n    modelDeleteClient,\n    modelClient,\n    modelSigkeys,\n    modelLocation, -- re-export from types-common\n    modelPubClient,\n  )\nwhere\n\nimport Control.Lens ((?~), (^.))\nimport Data.Aeson\nimport Data.Domain (Domain)\nimport qualified Data.HashMap.Strict as HashMap\nimport Data.Id\nimport Data.Json.Util\nimport qualified Data.Map.Strict as Map\nimport Data.Misc (Latitude (..), Location, Longitude (..), PlainTextPassword (..), latitude, location, longitude, modelLocation)\nimport Data.Proxy (Proxy (..))\nimport Data.Swagger (HasExample (example), NamedSchema (..), ToSchema (..), declareSchema)\nimport qualified Data.Swagger as Swagger\nimport qualified Data.Swagger.Build.Api as Doc\nimport Data.Swagger.Schema (toSchema)\nimport qualified Data.Text as Text\nimport qualified Data.Text.Encoding as Text.E\nimport Data.Typeable (typeRep)\nimport Data.UUID (toASCIIBytes)\nimport Deriving.Swagger (CamelToSnake, ConstructorTagModifier, CustomSwagger, FieldLabelModifier, LabelMapping ((:->)), LabelMappings, LowerCase, StripPrefix, StripSuffix)\nimport Imports\nimport Wire.API.Arbitrary (Arbitrary (arbitrary), GenericUniform (..), generateExample, mapOf', setOf')\nimport Wire.API.User.Auth (CookieLabel)\nimport Wire.API.User.Client.Prekey as Prekey\n\n--------------------------------------------------------------------------------\n-- UserClientMap\n\nnewtype UserClientMap a = UserClientMap\n  { userClientMap :: Map UserId (Map ClientId a)\n  }\n  deriving stock (Eq, Show, Functor, Foldable, Traversable)\n  deriving newtype (Semigroup, Monoid)\n\n-- FUTUREWORK: Remove when 'NewOtrMessage' has ToSchema\nmodelOtrClientMap :: Doc.Model\nmodelOtrClientMap = Doc.defineModel \"OtrClientMap\" $ do\n  Doc.description \"Map of client IDs to OTR content.\"\n  Doc.property \"\" Doc.bytes' $\n    Doc.description \"Mapping from client IDs to OTR content (Base64 in JSON).\"\n\ninstance ToJSON a => ToJSON (UserClientMap a) where\n  toJSON = toJSON . Map.foldrWithKey' f Map.empty . userClientMap\n    where\n      f (Id u) clients m =\n        let key = Text.E.decodeLatin1 (toASCIIBytes u)\n            val = Map.foldrWithKey' g Map.empty clients\n         in Map.insert key val m\n      g (ClientId c) a = Map.insert c (toJSON a)\n\ninstance FromJSON a => FromJSON (UserClientMap a) where\n  parseJSON = withObject \"user-client-map\" $ \\o ->\n    UserClientMap <$> foldrM f Map.empty (HashMap.toList o)\n    where\n      f (k, v) m = do\n        u <- parseJSON (String k)\n        flip (withObject \"client-value-map\") v $ \\c -> do\n          e <- foldrM g Map.empty (HashMap.toList c)\n          return (Map.insert u e m)\n      g (k, v) m = do\n        c <- parseJSON (String k)\n        t <- parseJSON v\n        return (Map.insert c t m)\n\ninstance Arbitrary a => Arbitrary (UserClientMap a) where\n  arbitrary = UserClientMap <$> mapOf' arbitrary (mapOf' arbitrary arbitrary)\n\ninstance ToSchema (UserClientMap (Maybe Prekey)) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Map ClientId (Maybe Prekey))))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @(Maybe Prekey)\n    return $\n      NamedSchema (Just $ \"UserClientMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & example\n            ?~ toJSON\n              ( Map.singleton\n                  (generateExample @UserId)\n                  ( Map.singleton\n                      (newClientId 4940483633899001999)\n                      (Just (Prekey (PrekeyId 1) \"pQABAQECoQBYIOjl7hw0D8YRNq...\"))\n                  )\n              )\n\nnewtype QualifiedUserClientMap a = QualifiedUserClientMap\n  { qualifiedUserClientMap :: Map Domain (UserClientMap a)\n  }\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON)\n\ninstance Arbitrary a => Arbitrary (QualifiedUserClientMap a) where\n  arbitrary = QualifiedUserClientMap <$> mapOf' arbitrary arbitrary\n\ninstance (Typeable a, ToSchema (UserClientMap a)) => ToSchema (QualifiedUserClientMap a) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map Domain (UserClientMap a)))\n    let userMapSchema = toSchema (Proxy @(UserClientMap a))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @a\n    return $\n      NamedSchema (Just $ \"QualifiedUserClientMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & Swagger.description ?~ \"Map of Domain to (UserMap (\" <> valueTypeName <> \")).\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userMapSchema ^. example))\n\n--------------------------------------------------------------------------------\n-- UserClients\n\n-- TODO: check if example generated by swagger look okay (probably not)\nnewtype UserClients = UserClients\n  { userClients :: Map UserId (Set ClientId)\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Semigroup, Monoid)\n\ninstance ToSchema UserClients where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Set ClientId)))\n    return $\n      NamedSchema (Just \"UserClients\") $\n        mapSch\n          & Swagger.description ?~ \"Map of user id to list of client ids.\"\n          & example\n            ?~ toJSON\n              ( Map.fromList\n                  [ (generateExample @UserId, [newClientId 1684636986166846496, newClientId 4940483633899001999]),\n                    (generateExample @UserId, [newClientId 6987438498444556166, newClientId 7940473633839002939])\n                  ]\n              )\n\n-- FUTUREWORK: Remove when 'NewOtrMessage' has ToSchema\nmodelUserClients :: Doc.Model\nmodelUserClients =\n  Doc.defineModel \"UserClients\" $\n    Doc.property \"\" (Doc.unique $ Doc.array Doc.bytes') $\n      Doc.description \"Map of user IDs to sets of client IDs ({ UserId: [ClientId] }).\"\n\ninstance ToJSON UserClients where\n  toJSON =\n    toJSON . Map.foldrWithKey' fn Map.empty . userClients\n    where\n      fn u c m =\n        let k = Text.E.decodeLatin1 (toASCIIBytes (toUUID u))\n         in Map.insert k c m\n\ninstance FromJSON UserClients where\n  parseJSON =\n    withObject \"UserClients\" (fmap UserClients . foldrM fn Map.empty . HashMap.toList)\n    where\n      fn (k, v) m = Map.insert <$> parseJSON (String k) <*> parseJSON v <*> pure m\n\ninstance Arbitrary UserClients where\n  arbitrary = UserClients <$> mapOf' arbitrary (setOf' arbitrary)\n\nfilterClients :: (Set ClientId -> Bool) -> UserClients -> UserClients\nfilterClients p (UserClients c) = UserClients $ Map.filter p c\n\nnewtype QualifiedUserClients = QualifiedUserClients\n  { qualifiedUserClients :: Map Domain UserClients\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Semigroup, Monoid, FromJSON, ToJSON)\n\ninstance Arbitrary QualifiedUserClients where\n  arbitrary = QualifiedUserClients <$> mapOf' arbitrary arbitrary\n\ninstance ToSchema QualifiedUserClients where\n  declareNamedSchema _ = do\n    schema <- declareSchema (Proxy @(Map Domain UserClients))\n    userClientsSchema <- declareSchema (Proxy @UserClients)\n    return $\n      NamedSchema (Just \"QualifiedUserClients\") $\n        schema\n          & Swagger.description ?~ \"Map of Domain to UserClients\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userClientsSchema ^. example))\n\n--------------------------------------------------------------------------------\n-- Client\n\ndata Client = Client\n  { clientId :: ClientId,\n    clientType :: ClientType,\n    clientTime :: UTCTimeMillis,\n    clientClass :: Maybe ClientClass,\n    clientLabel :: Maybe Text,\n    clientCookie :: Maybe CookieLabel,\n    clientLocation :: Maybe Location,\n    clientModel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic, Ord)\n  deriving (Arbitrary) via (GenericUniform Client)\n  deriving (ToSchema) via (CustomSwagger '[FieldLabelModifier (StripPrefix \"client\", LowerCase)] Client)\n\nmodelClient :: Doc.Model\nmodelClient = Doc.defineModel \"Client\" $ do\n  Doc.description \"A registered client.\"\n  Doc.property \"type\" typeClientType $\n    Doc.description \"The client type.\"\n  Doc.property \"id\" Doc.string' $\n    Doc.description \"The client ID.\"\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"An optional label associated with the client.\"\n    Doc.optional\n  Doc.property \"time\" Doc.dateTime' $\n    Doc.description \"The date and time when this client was registered.\"\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to.\"\n  Doc.property \"cookie\" Doc.string' $\n    Doc.description \"The cookie label of this client.\"\n  Doc.property \"address\" Doc.string' $ do\n    Doc.description \"IP address from which this client has been registered\"\n    Doc.optional\n  Doc.property \"location\" (Doc.ref modelLocation) $ do\n    Doc.description \"Location from which this client has been registered.\"\n    Doc.optional\n  Doc.property \"model\" Doc.string' $ do\n    Doc.description \"Optional model information of this client\"\n    Doc.optional\n\ninstance ToJSON Client where\n  toJSON c =\n    object $\n      \"id\" .= clientId c\n        # \"type\" .= clientType c\n        # \"label\" .= clientLabel c\n        # \"class\" .= clientClass c\n        # \"time\" .= clientTime c\n        # \"cookie\" .= clientCookie c\n        # \"location\" .= clientLocation c\n        # \"model\" .= clientModel c\n        # []\n\ninstance FromJSON Client where\n  parseJSON = withObject \"Client\" $ \\o ->\n    Client\n      <$> o .: \"id\"\n      <*> o .: \"type\"\n      <*> o .: \"time\"\n      <*> o .:? \"class\"\n      <*> o .:? \"label\"\n      <*> o .:? \"cookie\"\n      <*> o .:? \"location\"\n      <*> o .:? \"model\"\n\n--------------------------------------------------------------------------------\n-- PubClient\n\ndata PubClient = PubClient\n  { pubClientId :: ClientId,\n    pubClientClass :: Maybe ClientClass\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform PubClient)\n\nmodelPubClient :: Doc.Model\nmodelPubClient = Doc.defineModel \"PubClient\" $ do\n  Doc.description \"A client as seen by other users.\"\n  Doc.property \"id\" Doc.string' $\n    Doc.description \"The client ID.\"\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to. Either 'phone', 'tablet', or 'desktop'.\"\n\ninstance ToJSON PubClient where\n  toJSON c =\n    object $\n      \"id\" .= pubClientId c\n        # \"class\" .= pubClientClass c\n        # []\n\ninstance FromJSON PubClient where\n  parseJSON = withObject \"PubClient\" $ \\o ->\n    PubClient\n      <$> o .: \"id\"\n      <*> o .:? \"class\"\n\n--------------------------------------------------------------------------------\n-- Client Type/Class\n\n-- [Note: LegalHold]\n--\n-- Short feature description:\n-- LegalHold is an enterprise feature, enabled on a per-team basis, and within a\n-- team on a per-user basis\n\n-- * A LegalHoldClient is a client outside that user's control (but under the\n\n--   control of that team's business)\n\n-- * Users need to click \"accept\" before a LegalHoldClient is added to their\n\n--   account.\n\n-- * Any user interacting with a user which has a LegalHoldClient will upon\n\n--   first interaction receive a warning, have the option of cancelling the\n--   interaction, and on an ongoing basis see a visual indication in all\n--   conversations where such a device is active.\n\n-- | Strategy to translate enums in this module to schema.\ntype EnumToSchemaStrategy suffix ty =\n  ( CustomSwagger\n      '[ ConstructorTagModifier\n           ( StripSuffix suffix,\n             CamelToSnake,\n             LabelMappings '[\"legal_hold\" ':-> \"legalhold\"]\n           )\n       ]\n      ty\n  )\n\ndata ClientType\n  = TemporaryClientType\n  | PermanentClientType\n  | LegalHoldClientType -- see Note [LegalHold]\n  deriving stock (Eq, Ord, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform ClientType)\n  deriving (ToSchema) via EnumToSchemaStrategy \"ClientType\" ClientType\n\ntypeClientType :: Doc.DataType\ntypeClientType =\n  Doc.string $\n    Doc.enum\n      [ \"permanent\",\n        \"temporary\",\n        \"legalhold\"\n      ]\n\ninstance ToJSON ClientType where\n  toJSON TemporaryClientType = String \"temporary\"\n  toJSON PermanentClientType = String \"permanent\"\n  toJSON LegalHoldClientType = String \"legalhold\"\n\ninstance FromJSON ClientType where\n  parseJSON = withText \"ClientType\" $ \\txt -> case txt of\n    \"temporary\" -> return TemporaryClientType\n    \"permanent\" -> return PermanentClientType\n    \"legalhold\" -> return LegalHoldClientType\n    _ -> fail \"Must be one of {'temporary', 'permanent', 'legalhold'}.\"\n\ndata ClientClass\n  = PhoneClient\n  | TabletClient\n  | DesktopClient\n  | LegalHoldClient -- see Note [LegalHold]\n  deriving stock (Eq, Ord, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform ClientClass)\n  deriving (ToSchema) via EnumToSchemaStrategy \"Client\" ClientClass\n\ntypeClientClass :: Doc.DataType\ntypeClientClass =\n  Doc.string $\n    Doc.enum\n      [ \"phone\",\n        \"tablet\",\n        \"desktop\",\n        \"legalhold\"\n      ]\n\ninstance ToJSON ClientClass where\n  toJSON PhoneClient = String \"phone\"\n  toJSON TabletClient = String \"tablet\"\n  toJSON DesktopClient = String \"desktop\"\n  toJSON LegalHoldClient = String \"legalhold\"\n\ninstance FromJSON ClientClass where\n  parseJSON = withText \"ClientClass\" $ \\txt -> case txt of\n    \"phone\" -> return PhoneClient\n    \"tablet\" -> return TabletClient\n    \"desktop\" -> return DesktopClient\n    \"legalhold\" -> return LegalHoldClient\n    _ -> fail \"Must be one of {'phone', 'tablet', 'desktop', 'legalhold'}.\"\n\n--------------------------------------------------------------------------------\n-- NewClient\n\ndata NewClient = NewClient\n  { newClientPrekeys :: [Prekey],\n    newClientLastKey :: LastPrekey,\n    newClientType :: ClientType,\n    newClientLabel :: Maybe Text,\n    newClientClass :: Maybe ClientClass,\n    newClientCookie :: Maybe CookieLabel,\n    newClientPassword :: Maybe PlainTextPassword,\n    newClientModel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform NewClient)\n\nmodelNewClient :: Doc.Model\nmodelNewClient = Doc.defineModel \"NewClient\" $ do\n  Doc.description \"The registration data for a new client.\"\n  Doc.property \"type\" typeClientType $\n    Doc.description\n      \"The type of client to register. A user may have no more than \\\n      \\7 (seven) permanent clients and 1 (one) temporary client. When the \\\n      \\limit of permanent clients is reached, an error is returned. \\\n      \\When a temporary client already exists, it is replaced.\"\n  Doc.property \"password\" Doc.string' $ do\n    Doc.description\n      \"The password of the authenticated user for verification. \\\n      \\Note: Required for registration of the 2nd, 3rd, ... client.\"\n    Doc.optional\n  Doc.property \"prekeys\" (Doc.array (Doc.ref modelPrekey)) $\n    Doc.description \"Prekeys for other clients to establish OTR sessions.\"\n  Doc.property \"lastkey\" (Doc.ref modelPrekey) $\n    Doc.description\n      \"The last resort prekey for other clients to establish OTR sessions. \\\n      \\This key must have the ID 0xFFFF and is never deleted.\"\n  -- FUTUREWORK: sigkeys don't seem to be used anymore\n  Doc.property \"sigkeys\" (Doc.ref modelSigkeys) $\n    Doc.description\n      \"The signaling keys to use for encryption and signing of OTR native push \\\n      \\notifications (APNS, GCM).\"\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"An optional label to associate with the client.\"\n    Doc.optional\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to. Either 'phone', 'tablet', or 'desktop'.\"\n  Doc.property \"cookie\" Doc.string' $\n    Doc.description \"The cookie label, i.e. the label used when logging in.\"\n  Doc.property \"model\" Doc.string' $ do\n    Doc.description \"Optional model information of this client\"\n    Doc.optional\n\nnewClient :: ClientType -> LastPrekey -> NewClient\nnewClient t k =\n  NewClient\n    { newClientPrekeys = [],\n      newClientLastKey = k,\n      newClientType = t,\n      newClientLabel = Nothing,\n      newClientClass = if t == LegalHoldClientType then Just LegalHoldClient else Nothing,\n      newClientCookie = Nothing,\n      newClientPassword = Nothing,\n      newClientModel = Nothing\n    }\n\ninstance ToJSON NewClient where\n  toJSON c =\n    object $\n      \"type\" .= newClientType c\n        # \"prekeys\" .= newClientPrekeys c\n        # \"lastkey\" .= newClientLastKey c\n        # \"label\" .= newClientLabel c\n        # \"class\" .= newClientClass c\n        # \"cookie\" .= newClientCookie c\n        # \"password\" .= newClientPassword c\n        # \"model\" .= newClientModel c\n        # []\n\ninstance FromJSON NewClient where\n  parseJSON = withObject \"NewClient\" $ \\o ->\n    NewClient\n      <$> o .: \"prekeys\"\n      <*> o .: \"lastkey\"\n      <*> o .: \"type\"\n      <*> o .:? \"label\"\n      <*> o .:? \"class\"\n      <*> o .:? \"cookie\"\n      <*> o .:? \"password\"\n      <*> o .:? \"model\"\n\n--------------------------------------------------------------------------------\n-- UpdateClient\n\ndata UpdateClient = UpdateClient\n  { updateClientPrekeys :: [Prekey],\n    updateClientLastKey :: Maybe LastPrekey,\n    updateClientLabel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform UpdateClient)\n\nmodelUpdateClient :: Doc.Model\nmodelUpdateClient = Doc.defineModel \"UpdateClient\" $ do\n  Doc.description \"The new data for the registered client.\"\n  Doc.property \"prekeys\" (Doc.array (Doc.ref modelPrekey)) $ do\n    Doc.description \"New prekeys for other clients to establish OTR sessions.\"\n    Doc.optional\n  Doc.property \"lastkey\" (Doc.ref modelPrekey) $ do\n    Doc.description \"New last-resort prekey.\"\n    Doc.optional\n  -- FUTUREWORK: sigkeys don't seem to be used anymore, remove?\n  Doc.property \"sigkeys\" (Doc.ref modelSigkeys) $ do\n    Doc.description\n      \"New signaling keys to use for encryption and signing of OTR native push \\\n      \\notifications (APNS, GCM).\"\n    Doc.optional\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"A new name for this client.\"\n    Doc.optional\n\ninstance ToJSON UpdateClient where\n  toJSON c =\n    object $\n      \"prekeys\" .= updateClientPrekeys c\n        # \"lastkey\" .= updateClientLastKey c\n        # \"label\" .= updateClientLabel c\n        # []\n\ninstance FromJSON UpdateClient where\n  parseJSON = withObject \"RefreshClient\" $ \\o ->\n    UpdateClient\n      <$> o .:? \"prekeys\" .!= []\n      <*> o .:? \"lastkey\"\n      <*> o .:? \"label\"\n\n--------------------------------------------------------------------------------\n-- RmClient\n\nnewtype RmClient = RmClient\n  { rmPassword :: Maybe PlainTextPassword\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Arbitrary)\n\nmodelDeleteClient :: Doc.Model\nmodelDeleteClient = Doc.defineModel \"DeleteClient\" $ do\n  Doc.description \"Required information for client deletion.\"\n  Doc.property \"password\" Doc.string' $ do\n    Doc.description\n      \"The password of the authenticated user for verification. \\\n      \\The password is not required for deleting temporary clients.\"\n    Doc.optional\n\ninstance ToJSON RmClient where\n  toJSON (RmClient pw) = object [\"password\" .= pw]\n\ninstance FromJSON RmClient where\n  parseJSON = withObject \"RmClient\" $ \\o ->\n    RmClient <$> o .:? \"password\"\n\n--------------------------------------------------------------------------------\n-- other models\n\nmodelSigkeys :: Doc.Model\nmodelSigkeys = Doc.defineModel \"SignalingKeys\" $ do\n  Doc.description \"Signaling keys for encryption and signing of native push notifications (APNS, GCM).\"\n  Doc.property \"enckey\" Doc.bytes' $\n    Doc.description \"The base64-encoded, 256 bit encryption key.\"\n  Doc.property \"mackey\" Doc.bytes' $\n    Doc.description \"The base64-encoded, 256 bit MAC key.\"\n", "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Wire.API.UserMap where\n\nimport Control.Lens ((?~), (^.))\nimport Data.Aeson (FromJSON, ToJSON (toJSON))\nimport Data.Domain (Domain)\nimport Data.Id (UserId)\nimport qualified Data.Map as Map\nimport Data.Proxy (Proxy (..))\nimport qualified Data.Set as Set\nimport Data.Swagger (HasDescription (description), HasExample (example), NamedSchema (..), ToSchema (..), declareSchema, toSchema)\nimport qualified Data.Text as Text\nimport Data.Typeable (typeRep)\nimport Imports\nimport Test.QuickCheck (Arbitrary (..))\nimport Wire.API.Arbitrary (generateExample, mapOf')\nimport Wire.API.User.Client (Client)\n\nnewtype UserMap a = UserMap {userMap :: Map UserId a}\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON)\n\ninstance Arbitrary a => Arbitrary (UserMap a) where\n  arbitrary = UserMap <$> mapOf' arbitrary arbitrary\n\nnewtype QualifiedUserMap a = QualifiedUserMap\n  { qualifiedUserMap :: Map Domain (UserMap a)\n  }\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON)\n\ninstance Arbitrary a => Arbitrary (QualifiedUserMap a) where\n  arbitrary = QualifiedUserMap <$> mapOf' arbitrary arbitrary\n\ninstance ToSchema (UserMap (Set Client)) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Set Client)))\n    return $\n      NamedSchema (Just \"UserMap (Set Client)\") $\n        mapSch\n          & description ?~ \"Map of UserId to (Set Client)\"\n          & example ?~ toJSON (Map.singleton (generateExample @UserId) (Set.singleton (generateExample @Client)))\n\ninstance (Typeable a, ToSchema (UserMap a)) => ToSchema (QualifiedUserMap a) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map Domain (UserMap a)))\n    let userMapSchema = toSchema (Proxy @(UserMap a))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @a\n    return $\n      NamedSchema (Just $ \"QualifiedUserMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & description ?~ \"Map of Domain to (UserMap (\" <> valueTypeName <> \")).\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userMapSchema ^. example))\n", "-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Test.Wire.API.Swagger (tests) where\n\nimport Data.Aeson (ToJSON)\nimport Data.Swagger (ToSchema, validatePrettyToJSON)\nimport Imports\nimport qualified Test.Tasty as T\nimport Test.Tasty.QuickCheck (Arbitrary, counterexample, testProperty)\nimport Type.Reflection (typeRep)\nimport qualified Wire.API.User as User\nimport qualified Wire.API.User.Client as Client\nimport qualified Wire.API.User.Client.Prekey as Prekey\nimport qualified Wire.API.User.Handle as Handle\nimport qualified Wire.API.UserMap as UserMap\n\ntests :: T.TestTree\ntests =\n  T.localOption (T.Timeout (60 * 1000000) \"60s\") . T.testGroup \"JSON roundtrip tests\" $\n    [ testToJSON @User.UserProfile,\n      testToJSON @User.User,\n      testToJSON @User.SelfProfile,\n      testToJSON @Handle.UserHandleInfo,\n      testToJSON @Client.Client,\n      testToJSON @(Client.UserClientMap (Maybe Prekey.Prekey)),\n      testToJSON @Client.UserClients,\n      testToJSON @(UserMap.UserMap (Set Client.Client)),\n      testToJSON @(UserMap.QualifiedUserMap (Set Client.Client)),\n      testToJSON @Prekey.Prekey,\n      testToJSON @Prekey.PrekeyBundle,\n      testToJSON @Prekey.ClientPrekey,\n      testToJSON @(Client.QualifiedUserClientMap (Maybe Prekey.Prekey)),\n      testToJSON @Client.QualifiedUserClients\n    ]\n\ntestToJSON :: forall a. (Arbitrary a, Typeable a, ToJSON a, ToSchema a, Show a) => T.TestTree\ntestToJSON = testProperty msg trip\n  where\n    msg = show (typeRep @a)\n    trip (v :: a) =\n      counterexample\n        ( fromMaybe \"Schema validation failed, but there were no errors. This looks like a bug in swagger2!\" $\n            validatePrettyToJSON v\n        )\n        $ isNothing (validatePrettyToJSON v)\n", "{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Brig.API.Public\n  ( sitemap,\n    apiDocs,\n    servantSitemap,\n    swaggerDocsAPI,\n    ServantAPI,\n    SwaggerDocsAPI,\n  )\nwhere\n\nimport qualified Brig.API.Client as API\nimport qualified Brig.API.Connection as API\nimport Brig.API.Error\nimport Brig.API.Handler\nimport Brig.API.IdMapping (resolveOpaqueUserId)\nimport qualified Brig.API.Properties as API\nimport Brig.API.Types\nimport qualified Brig.API.User as API\nimport Brig.API.Util\nimport qualified Brig.API.Util as API\nimport Brig.App\nimport qualified Brig.Calling.API as Calling\nimport qualified Brig.Data.User as Data\nimport Brig.Federation.Client as Federation\nimport Brig.Options hiding (internalEvents, sesQueue)\nimport qualified Brig.Provider.API as Provider\nimport qualified Brig.Team.API as Team\nimport qualified Brig.Team.Email as Team\nimport Brig.Types.Activation (ActivationPair)\nimport Brig.Types.Intra (AccountStatus (Ephemeral), UserAccount (UserAccount, accountUser))\nimport Brig.Types.User (HavePendingInvitations (..), User (userId))\nimport qualified Brig.User.API.Auth as Auth\nimport qualified Brig.User.API.Search as Search\nimport qualified Brig.User.Auth.Cookie as Auth\nimport Brig.User.Email\nimport Brig.User.Phone\nimport Control.Error hiding (bool)\nimport Control.Lens (view, (.~), (<>~), (?~), (^.))\nimport Control.Monad.Catch (throwM)\nimport Data.Aeson hiding (json)\nimport Data.ByteString.Conversion\nimport qualified Data.ByteString.Lazy as Lazy\nimport Data.CommaSeparatedList (CommaSeparatedList (fromCommaSeparatedList))\nimport Data.Domain\nimport Data.Handle (Handle, parseHandle)\nimport qualified Data.HashMap.Strict.InsOrd as InsOrdHashMap\nimport Data.Id as Id\nimport Data.IdMapping (MappedOrLocalId (Local))\nimport qualified Data.Map.Strict as Map\nimport Data.Misc (IpAddr (..))\nimport Data.Qualified (Qualified (..), partitionRemoteOrLocalIds)\nimport Data.Range\nimport Data.Swagger\n  ( ApiKeyLocation (..),\n    ApiKeyParams (..),\n    HasInfo (info),\n    HasSchema (..),\n    HasSecurity (security),\n    HasSecurityDefinitions (securityDefinitions),\n    HasTitle (title),\n    SecurityRequirement (..),\n    SecurityScheme (..),\n    SecuritySchemeType (SecuritySchemeApiKey),\n    Swagger,\n    ToSchema (..),\n    description,\n  )\nimport qualified Data.Swagger.Build.Api as Doc\nimport qualified Data.Text as Text\nimport qualified Data.Text.Ascii as Ascii\nimport Data.Text.Encoding (decodeLatin1)\nimport Data.Text.Lazy (pack)\nimport qualified Data.ZAuth.Token as ZAuth\nimport Imports hiding (head)\nimport Network.HTTP.Types.Status\nimport Network.Wai (Response, lazyRequestBody)\nimport Network.Wai.Predicate hiding (result, setStatus)\nimport Network.Wai.Routing\nimport Network.Wai.Utilities as Utilities\nimport Network.Wai.Utilities.Swagger (document, mkSwaggerApi)\nimport qualified Network.Wai.Utilities.Swagger as Doc\nimport Network.Wai.Utilities.ZAuth (zauthConnId, zauthUserId)\nimport Servant hiding (Handler, JSON, addHeader, respond)\nimport qualified Servant\nimport Servant.Swagger (HasSwagger (toSwagger))\nimport Servant.Swagger.Internal.Orphans ()\nimport Servant.Swagger.UI\nimport qualified System.Logger.Class as Log\nimport Util.Logging (logFunction, logHandle, logTeam, logUser)\nimport qualified Wire.API.Connection as Public\nimport qualified Wire.API.Properties as Public\nimport qualified Wire.API.Swagger as Public.Swagger (models)\nimport qualified Wire.API.Team as Public\nimport qualified Wire.API.User as Public\nimport qualified Wire.API.User.Activation as Public\nimport qualified Wire.API.User.Auth as Public\nimport qualified Wire.API.User.Client as Public\nimport qualified Wire.API.User.Client.Prekey as Public\nimport qualified Wire.API.User.Handle as Public\nimport qualified Wire.API.User.Password as Public\nimport qualified Wire.API.User.RichInfo as Public\nimport qualified Wire.API.UserMap as Public\n\n---------------------------------------------------------------------------\n-- Sitemap\n\n-- | This type exists for the special 'HasSwagger' and 'HasServer' instances. It\n-- shows the \"Authorization\" header in the swagger docs, but expects the\n-- \"Z-Auth\" header in the server. This helps keep the swagger docs usable\n-- through nginz.\ndata ZAuthServant\n\ntype InternalAuth = Header' '[Servant.Required, Servant.Strict] \"Z-User\" UserId\n\ninstance HasSwagger api => HasSwagger (ZAuthServant :> api) where\n  toSwagger _ =\n    toSwagger (Proxy @api)\n      & securityDefinitions <>~ InsOrdHashMap.singleton \"ZAuth\" secScheme\n      & security <>~ [SecurityRequirement $ InsOrdHashMap.singleton \"ZAuth\" []]\n    where\n      secScheme =\n        SecurityScheme\n          { _securitySchemeType = SecuritySchemeApiKey (ApiKeyParams \"Authorization\" ApiKeyHeader),\n            _securitySchemeDescription = Just \"Must be a token retrieved by calling 'POST /login' or 'POST /access'. It must be presented in this format: 'Bearer \\\\<token\\\\>'.\"\n          }\n\ninstance\n  ( HasContextEntry (ctx .++ DefaultErrorFormatters) ErrorFormatters,\n    HasServer api ctx\n  ) =>\n  HasServer (ZAuthServant :> api) ctx\n  where\n  type ServerT (ZAuthServant :> api) m = ServerT (InternalAuth :> api) m\n\n  route _ = Servant.route (Proxy @(InternalAuth :> api))\n  hoistServerWithContext _ pc nt s =\n    Servant.hoistServerWithContext (Proxy @(InternalAuth :> api)) pc nt s\n\ntype CaptureUserId name = Capture' '[Description \"User Id\"] name UserId\n\ntype CaptureClientId name = Capture' '[Description \"ClientId\"] name ClientId\n\n-- User API -----------------------------------------------------------\n\ndata Empty200 = Empty200\n  deriving (Generic)\n  deriving (HasStatus) via (WithStatus 200 Empty200)\n\ninstance ToSchema Empty200 where\n  declareNamedSchema _ = declareNamedSchema (Proxy @Text)\n\ninstance ToJSON Empty200 where\n  toJSON _ = toJSON (\"\" :: Text)\n\ndata Empty404 = Empty404\n  deriving (Generic)\n  deriving (HasStatus) via (WithStatus 404 Empty404)\n\ninstance ToJSON Empty404 where\n  toJSON _ = toJSON (\"\" :: Text)\n\ninstance ToSchema Empty404 where\n  declareNamedSchema _ =\n    declareNamedSchema (Proxy @Text) <&> (schema . description ?~ \"user not found\")\n\ntype CheckUserExistsResponse = [Empty200, Empty404]\n\n-- Note [document responses]\n--\n-- Ideally we want to document responses with UVerb and swagger, but this is\n-- currently not possible due to this issue:\n-- https://github.com/haskell-servant/servant/issues/1369\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User exists\" Doc.end\n--   Doc.errorResponse userNotFound\ntype CheckUserExistsUnqualified =\n  Summary \"Check if a user ID exists (deprecated)\"\n    :> ZAuthServant\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> UVerb 'HEAD '[Servant.JSON] CheckUserExistsResponse\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User exists\" Doc.end\n--   Doc.errorResponse userNotFound\ntype CheckUserExistsQualified =\n  Summary \"Check if a user ID exists\"\n    :> ZAuthServant\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> UVerb 'HEAD '[Servant.JSON] CheckUserExistsResponse\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User\" Doc.end\n--   Doc.errorResponse userNotFound\ntype GetUserUnqualified =\n  Summary \"Get a user by UserId (deprecated)\"\n    :> ZAuthServant\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> Get '[Servant.JSON] Public.UserProfile\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User\" Doc.end\n--   Doc.errorResponse userNotFound\ntype GetUserQualified =\n  Summary \"Get a user by Domain and UserId\"\n    :> ZAuthServant\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> Get '[Servant.JSON] Public.UserProfile\n\ntype GetSelf =\n  Summary \"Get your own profile\"\n    :> ZAuthServant\n    :> \"self\"\n    :> Get '[Servant.JSON] Public.SelfProfile\n\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.returns (Doc.ref Public.modelUserHandleInfo)\n--   Doc.response 200 \"Handle info\" Doc.end\n--   Doc.errorResponse handleNotFound\ntype GetHandleInfoUnqualified =\n  Summary \"Get information on a user handle\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"handles\"\n    :> Capture' '[Description \"The user handle\"] \"handle\" Handle\n    :> Get '[Servant.JSON] Public.UserHandleInfo\n\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.returns (Doc.ref Public.modelUserHandleInfo)\n--   Doc.response 200 \"Handle info\" Doc.end\n--   Doc.errorResponse handleNotFound\ntype GetHandleInfoQualified =\n  Summary \"Get information on a user handle\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"handles\"\n    :> Capture \"domain\" Domain\n    :> Capture' '[Description \"The user handle\"] \"handle\" Handle\n    :> Get '[Servant.JSON] Public.UserHandleInfo\n\n-- See Note [ephemeral user sideeffect]\ntype ListUsersByUnqualifiedIdsOrHandles =\n  Summary \"List users (deprecated)\"\n    :> Description \"The 'ids' and 'handles' parameters are mutually exclusive.\"\n    :> ZAuthServant\n    :> \"users\"\n    :> QueryParam' [Optional, Strict, Description \"User IDs of users to fetch\"] \"ids\" (CommaSeparatedList UserId)\n    :> QueryParam' [Optional, Strict, Description \"Handles of users to fetch, min 1 and max 4 (the check for handles is rather expensive)\"] \"handles\" (Range 1 4 (CommaSeparatedList Handle))\n    :> Get '[Servant.JSON] [Public.UserProfile]\n\n-- See Note [ephemeral user sideeffect]\ntype ListUsersByIdsOrHandles =\n  Summary \"List users\"\n    :> Description \"The 'qualified_ids' and 'qualified_handles' parameters are mutually exclusive.\"\n    :> ZAuthServant\n    :> \"list-users\"\n    :> Servant.ReqBody '[Servant.JSON] Public.ListUsersQuery\n    :> Post '[Servant.JSON] [Public.UserProfile]\n\ntype MaxUsersForListClientsBulk = 500\n\ntype ListClientsBulk =\n  Summary \"List all clients for a set of user ids\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"list-clients\"\n    :> Servant.ReqBody '[Servant.JSON] (Range 1 MaxUsersForListClientsBulk [Qualified UserId])\n    :> Post '[Servant.JSON] (Public.QualifiedUserMap (Set Public.Client))\n\ntype GetUsersPrekeysClientUnqualified =\n  Summary \"(deprecated) Get a prekey for a specific client of a user.\"\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> CaptureClientId \"client\"\n    :> Get '[Servant.JSON] Public.ClientPrekey\n\ntype GetUsersPrekeysClientQualified =\n  Summary \"Get a prekey for a specific client of a user.\"\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> CaptureClientId \"client\"\n    :> Get '[Servant.JSON] Public.ClientPrekey\n\ntype GetUsersPrekeyBundleUnqualified =\n  Summary \"(deprecated) Get a prekey for each client of a user.\"\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> Get '[Servant.JSON] Public.PrekeyBundle\n\ntype GetUsersPrekeyBundleQualified =\n  Summary \"Get a prekey for each client of a user.\"\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> Get '[Servant.JSON] Public.PrekeyBundle\n\ntype GetMultiUserPrekeyBundleUnqualified =\n  Summary\n    \"(deprecated)  Given a map of user IDs to client IDs return a \\\n    \\prekey for each one. You can't request information for more users than \\\n    \\maximum conversation size.\"\n    :> \"users\"\n    :> \"prekeys\"\n    :> Servant.ReqBody '[Servant.JSON] Public.UserClients\n    :> Post '[Servant.JSON] (Public.UserClientMap (Maybe Public.Prekey))\n\ntype GetMultiUserPrekeyBundleQualified =\n  Summary\n    \"Given a map of user IDs to client IDs return a \\\n    \\prekey for each one. You can't request information for more users than \\\n    \\maximum conversation size.\"\n    :> \"users\"\n    :> \"list-prekeys\"\n    :> Servant.ReqBody '[Servant.JSON] Public.QualifiedUserClients\n    :> Post '[Servant.JSON] (Public.QualifiedUserClientMap (Maybe Public.Prekey))\n\ntype OutsideWorldAPI =\n  CheckUserExistsUnqualified\n    :<|> CheckUserExistsQualified\n    :<|> GetUserUnqualified\n    :<|> GetUserQualified\n    :<|> GetSelf\n    :<|> GetHandleInfoUnqualified\n    :<|> GetHandleInfoQualified\n    :<|> ListUsersByUnqualifiedIdsOrHandles\n    :<|> ListUsersByIdsOrHandles\n    :<|> ListClientsBulk\n    :<|> GetUsersPrekeysClientUnqualified\n    :<|> GetUsersPrekeysClientQualified\n    :<|> GetUsersPrekeyBundleUnqualified\n    :<|> GetUsersPrekeyBundleQualified\n    :<|> GetMultiUserPrekeyBundleUnqualified\n    :<|> GetMultiUserPrekeyBundleQualified\n\ntype SwaggerDocsAPI = \"api\" :> SwaggerSchemaUI \"swagger-ui\" \"swagger.json\"\n\ntype ServantAPI = OutsideWorldAPI\n\n-- FUTUREWORK: At the moment this only shows endpoints from brig, but we should\n-- combine the swagger 2.0 endpoints here as well from other services (e.g. spar)\nswaggerDoc :: Swagger\nswaggerDoc =\n  toSwagger (Proxy @OutsideWorldAPI)\n    & info . title .~ \"Wire-Server API as Swagger 2.0 \"\n    & info . description ?~ \"NOTE: only a few endpoints are visible here at the moment, more will come as we migrate them to Swagger 2.0. In the meantime please also look at the old swagger docs link for the not-yet-migrated endpoints. See https://docs.wire.com/understand/api-client-perspective/swagger.html for the old endpoints.\"\n\nswaggerDocsAPI :: Servant.Server SwaggerDocsAPI\nswaggerDocsAPI = swaggerSchemaUIServer swaggerDoc\n\nservantSitemap :: ServerT ServantAPI Handler\nservantSitemap =\n  checkUserExistsUnqualifiedH\n    :<|> checkUserExistsH\n    :<|> getUserUnqualifiedH\n    :<|> getUserH\n    :<|> getSelf\n    :<|> getHandleInfoUnqualifiedH\n    :<|> getHandleInfoH\n    :<|> listUsersByUnqualifiedIdsOrHandles\n    :<|> listUsersByIdsOrHandles\n    :<|> listClientsBulk\n    :<|> getPrekeyUnqualifiedH\n    :<|> getPrekeyH\n    :<|> getPrekeyBundleUnqualifiedH\n    :<|> getPrekeyBundleH\n    :<|> getMultiUserPrekeyBundleUnqualifiedH\n    :<|> getMultiUserPrekeyBundleH\n\n-- Note [ephemeral user sideeffect]\n-- If the user is ephemeral and expired, it will be removed upon calling\n-- CheckUserExists[Un]Qualified, see 'Brig.API.User.userGC'.\n-- This leads to the following events being sent:\n-- - UserDeleted event to contacts of the user\n-- - MemberLeave event to members for all conversations the user was in (via galley)\n\nsitemap :: Opts -> Routes Doc.ApiBuilder Handler ()\nsitemap o = do\n  -- User Handle API ----------------------------------------------------\n\n  post \"/users/handles\" (continue checkHandlesH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. jsonRequest @Public.CheckHandles\n  document \"POST\" \"checkUserHandles\" $ do\n    Doc.summary \"Check availability of user handles\"\n    Doc.body (Doc.ref Public.modelCheckHandles) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of free handles\" Doc.end\n\n  head \"/users/handles/:handle\" (continue checkHandleH) $\n    zauthUserId\n      .&. capture \"handle\"\n  document \"HEAD\" \"checkUserHandle\" $ do\n    Doc.summary \"Check whether a user handle can be taken\"\n    Doc.parameter Doc.Path \"handle\" Doc.bytes' $\n      Doc.description \"Handle to check\"\n    Doc.response 200 \"Handle is taken\" Doc.end\n    Doc.errorResponse invalidHandle\n    Doc.errorResponse handleNotFound\n\n  -- some APIs moved to servant\n  -- end User Handle API\n\n  -- User Client API ----------------------------------------------------\n\n  get \"/users/:uid/clients\" (continue getUserClientsH) $\n    capture \"uid\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getUserClients\" $ do\n    Doc.summary \"Get all of a user's clients.\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.array (Doc.ref Public.modelPubClient))\n    Doc.response 200 \"List of clients\" Doc.end\n\n  get \"/users/:uid/clients/:client\" (continue getUserClientH) $\n    capture \"uid\"\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getUserClient\" $ do\n    Doc.summary \"Get a specific client of a user.\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.ref Public.modelPubClient)\n    Doc.response 200 \"Client\" Doc.end\n\n  -- end User Client API\n\n  get \"/users/:uid/rich-info\" (continue getRichInfoH) $\n    zauthUserId\n      .&. capture \"uid\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getRichInfo\" $ do\n    Doc.summary \"Get user's rich info\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.ref Public.modelRichInfo)\n    Doc.response 200 \"RichInfo\" Doc.end\n    Doc.errorResponse insufficientTeamPermissions\n\n  -- User Self API ------------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserUpdated event to contacts of self\n  put \"/self\" (continue updateUserH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.UserUpdate\n  document \"PUT\" \"updateSelf\" $ do\n    Doc.summary \"Update your profile\"\n    Doc.body (Doc.ref Public.modelUserUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Update successful.\" Doc.end\n\n  get \"/self/name\" (continue getUserDisplayNameH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n  document \"GET\" \"selfName\" $ do\n    Doc.summary \"Get your profile name\"\n    Doc.returns (Doc.ref Public.modelUserDisplayName)\n    Doc.response 200 \"Profile name found.\" Doc.end\n\n  put \"/self/email\" (continue changeSelfEmailH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.EmailUpdate\n  document \"PUT\" \"changeEmail\" $ do\n    Doc.summary \"Change your email address\"\n    Doc.body (Doc.ref Public.modelEmailUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Update accepted and pending activation of the new email.\" Doc.end\n    Doc.response 204 \"No update, current and new email address are the same.\" Doc.end\n    Doc.errorResponse invalidEmail\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n\n  put \"/self/phone\" (continue changePhoneH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.PhoneUpdate\n  document \"PUT\" \"changePhone\" $ do\n    Doc.summary \"Change your phone number\"\n    Doc.body (Doc.ref Public.modelPhoneUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Update accepted and pending activation of the new phone number.\" Doc.end\n    Doc.errorResponse userKeyExists\n\n  head \"/self/password\" (continue checkPasswordExistsH) $\n    zauthUserId\n  document \"HEAD\" \"checkPassword\" $ do\n    Doc.summary \"Check that your password is set\"\n    Doc.response 200 \"Password is set.\" Doc.end\n    Doc.response 404 \"Password is not set.\" Doc.end\n\n  put \"/self/password\" (continue changePasswordH) $\n    zauthUserId\n      .&. jsonRequest @Public.PasswordChange\n  document \"PUT\" \"changePassword\" $ do\n    Doc.summary \"Change your password\"\n    Doc.body (Doc.ref Public.modelChangePassword) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Password changed.\" Doc.end\n    Doc.errorResponse badCredentials\n    Doc.errorResponse (noIdentity 4)\n\n  put \"/self/locale\" (continue changeLocaleH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.LocaleUpdate\n  document \"PUT\" \"changeLocale\" $ do\n    Doc.summary \"Change your locale\"\n    Doc.body (Doc.ref Public.modelChangeLocale) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Locale changed.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserUpdated event to contacts of self\n  put \"/self/handle\" (continue changeHandleH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.HandleUpdate\n  document \"PUT\" \"changeHandle\" $ do\n    Doc.summary \"Change your handle\"\n    Doc.body (Doc.ref Public.modelChangeHandle) $\n      Doc.description \"JSON body\"\n    Doc.errorResponse handleExists\n    Doc.errorResponse invalidHandle\n    Doc.response 200 \"Handle changed.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserIdentityRemoved event to self\n  delete \"/self/phone\" (continue removePhoneH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"removePhone\" $ do\n    Doc.summary \"Remove your phone number.\"\n    Doc.notes\n      \"Your phone number can only be removed if you also have an \\\n      \\email address and a password.\"\n    Doc.response 200 \"Phone number removed.\" Doc.end\n    Doc.errorResponse lastIdentity\n    Doc.errorResponse noPassword\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserIdentityRemoved event to self\n  delete \"/self/email\" (continue removeEmailH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"removeEmail\" $ do\n    Doc.summary \"Remove your email address.\"\n    Doc.notes\n      \"Your email address can only be removed if you also have a \\\n      \\phone number.\"\n    Doc.response 200 \"Email address removed.\" Doc.end\n    Doc.errorResponse lastIdentity\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserDeleted event to contacts of self\n  -- - MemberLeave event to members for all conversations the user was in (via galley)\n  delete \"/self\" (continue deleteUserH) $\n    zauthUserId\n      .&. jsonRequest @Public.DeleteUser\n      .&. accept \"application\" \"json\"\n  document \"DELETE\" \"deleteUser\" $ do\n    Doc.summary \"Initiate account deletion.\"\n    Doc.notes\n      \"If the account has a verified identity, a verification \\\n      \\code is sent and needs to be confirmed to authorise the \\\n      \\deletion. If the account has no verified identity but a \\\n      \\password, it must be provided. If password is correct, or if neither \\\n      \\a verified identity nor a password exists, account deletion \\\n      \\is scheduled immediately.\"\n    Doc.body (Doc.ref Public.modelDelete) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Deletion is pending verification with a code.\" Doc.end\n    Doc.response 200 \"Deletion is initiated.\" Doc.end\n    Doc.errorResponse badCredentials\n    Doc.errorResponse missingAuthError\n\n  -- TODO put  where?\n\n  -- This endpoint can lead to the following events being sent:\n  -- UserDeleted event to contacts of deleted user\n  -- MemberLeave event to members for all conversations the user was in (via galley)\n  post \"/delete\" (continue verifyDeleteUserH) $\n    jsonRequest @Public.VerifyDeleteUser\n      .&. accept \"application\" \"json\"\n  document \"POST\" \"verifyDeleteUser\" $ do\n    Doc.summary \"Verify account deletion with a code.\"\n    Doc.body (Doc.ref Public.modelVerifyDelete) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Deletion is initiated.\" Doc.end\n    Doc.errorResponse invalidCode\n\n  -- Connection API -----------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ConnectionUpdated event to self and other, if any side's connection state changes\n  -- - MemberJoin event to self and other, if joining an existing connect conversation (via galley)\n  -- - ConvCreate event to self, if creating a connect conversation (via galley)\n  -- - ConvConnect event to self, in some cases (via galley),\n  --   for details see 'Galley.API.Create.createConnectConversation'\n  post \"/connections\" (continue createConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.ConnectionRequest\n  document \"POST\" \"createConnection\" $ do\n    Doc.summary \"Create a connection to another user.\"\n    Doc.notes $\n      \"You can have no more than \"\n        <> Text.pack (show (setUserMaxConnections $ optSettings o))\n        <> \" connections in accepted or sent state.\"\n    Doc.body (Doc.ref Public.modelConnectionRequest) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"The connection exists.\" Doc.end\n    Doc.response 201 \"The connection was created.\" Doc.end\n    Doc.errorResponse connectionLimitReached\n    Doc.errorResponse invalidUser\n    Doc.errorResponse (noIdentity 5)\n\n  get \"/connections\" (continue listConnectionsH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. opt (query \"start\")\n      .&. def (unsafeRange 100) (query \"size\")\n  document \"GET\" \"connections\" $ do\n    Doc.summary \"List the connections to other users.\"\n    Doc.parameter Doc.Query \"start\" Doc.string' $ do\n      Doc.description \"User ID to start from\"\n      Doc.optional\n    Doc.parameter Doc.Query \"size\" Doc.int32' $ do\n      Doc.description \"Number of results to return (default 100, max 500).\"\n      Doc.optional\n    Doc.returns (Doc.ref Public.modelConnectionList)\n    Doc.response 200 \"List of connections\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ConnectionUpdated event to self and other, if their connection states change\n  --\n  -- When changing the connection state to Sent or Accepted, this can cause events to be sent\n  -- when joining the connect conversation:\n  -- - MemberJoin event to self and other (via galley)\n  put \"/connections/:id\" (continue updateConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. capture \"id\"\n      .&. jsonRequest @Public.ConnectionUpdate\n  document \"PUT\" \"updateConnection\" $ do\n    Doc.summary \"Update a connection.\"\n    Doc.parameter Doc.Path \"id\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.body (Doc.ref Public.modelConnectionUpdate) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"Connection updated.\" Doc.end\n    Doc.response 204 \"No change.\" Doc.end\n    Doc.errorResponse connectionLimitReached\n    Doc.errorResponse invalidTransition\n    Doc.errorResponse notConnected\n    Doc.errorResponse invalidUser\n\n  get \"/connections/:id\" (continue getConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. capture \"id\"\n  document \"GET\" \"connection\" $ do\n    Doc.summary \"Get an existing connection to another user.\"\n    Doc.parameter Doc.Path \"id\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"Connection\" Doc.end\n\n  -- User Client API ----------------------------------------------------\n  -- TODO: another one?\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ClientAdded event to self\n  -- - ClientRemoved event to self, if removing old clients due to max number\n  post \"/clients\" (continue addClientH) $\n    jsonRequest @Public.NewClient\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. opt (header \"X-Forwarded-For\")\n      .&. accept \"application\" \"json\"\n  document \"POST\" \"registerClient\" $ do\n    Doc.summary \"Register a new client.\"\n    Doc.body (Doc.ref Public.modelNewClient) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelClient)\n    Doc.response 200 \"Client\" Doc.end\n    Doc.errorResponse tooManyClients\n    Doc.errorResponse missingAuthError\n    Doc.errorResponse malformedPrekeys\n\n  put \"/clients/:client\" (continue updateClientH) $\n    jsonRequest @Public.UpdateClient\n      .&. zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"PUT\" \"updateClient\" $ do\n    Doc.summary \"Update a registered client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.body (Doc.ref Public.modelUpdateClient) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Client updated.\" Doc.end\n    Doc.errorResponse malformedPrekeys\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ClientRemoved event to self\n  delete \"/clients/:client\" (continue rmClientH) $\n    jsonRequest @Public.RmClient\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"DELETE\" \"deleteClient\" $ do\n    Doc.summary \"Delete an existing client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.body (Doc.ref Public.modelDeleteClient) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Client deleted.\" Doc.end\n\n  get \"/clients\" (continue listClientsH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listClients\" $ do\n    Doc.summary \"List the registered clients.\"\n    Doc.returns (Doc.array (Doc.ref Public.modelClient))\n    Doc.response 200 \"List of clients\" Doc.end\n\n  get \"/clients/:client\" (continue getClientH) $\n    zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getClients\" $ do\n    Doc.summary \"Get a registered client by ID.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.ref Public.modelClient)\n    Doc.response 200 \"Client\" Doc.end\n\n  get \"/clients/:client/prekeys\" (continue listPrekeyIdsH) $\n    zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPrekeyIds\" $ do\n    Doc.summary \"List the remaining prekey IDs of a client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of remaining prekey IDs.\" Doc.end\n\n  -- Properties API -----------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertySet event to self\n  put \"/properties/:key\" (continue setPropertyH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. capture \"key\"\n      .&. jsonRequest @Public.PropertyValue\n  document \"PUT\" \"setProperty\" $ do\n    Doc.summary \"Set a user property.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.body (Doc.ref Public.modelPropertyValue) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Property set.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertyDeleted event to self\n  delete \"/properties/:key\" (continue deletePropertyH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. capture \"key\"\n  document \"DELETE\" \"deleteProperty\" $ do\n    Doc.summary \"Delete a property.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.response 200 \"Property deleted.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertiesCleared event to self\n  delete \"/properties\" (continue clearPropertiesH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"clearProperties\" $ do\n    Doc.summary \"Clear all properties.\"\n    Doc.response 200 \"Properties cleared.\" Doc.end\n\n  get \"/properties/:key\" (continue getPropertyH) $\n    zauthUserId\n      .&. capture \"key\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getProperty\" $ do\n    Doc.summary \"Get a property value.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.returns (Doc.ref Public.modelPropertyValue)\n    Doc.response 200 \"The property value.\" Doc.end\n\n  get \"/properties\" (continue listPropertyKeysH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPropertyKeys\" $ do\n    Doc.summary \"List all property keys.\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of property keys.\" Doc.end\n\n  get \"/properties-values\" (continue listPropertyKeysAndValuesH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPropertyKeysAndValues\" $ do\n    Doc.summary \"List all properties with key and value.\"\n    Doc.returns (Doc.ref Public.modelPropertyDictionary)\n    Doc.response 200 \"Object with properties as attributes.\" Doc.end\n\n  -- TODO: put delete here, too?\n  -- /register, /activate, /password-reset ----------------------------------\n\n  -- docs/reference/user/registration.md {#RefRegistration}\n  --\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to created user, if it is a team invitation or user has an SSO ID\n  -- - UserIdentityUpdated event to created user, if email code or phone code is provided\n  post \"/register\" (continue createUserH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.NewUserPublic\n  document \"POST\" \"register\" $ do\n    Doc.summary \"Register a new user.\"\n    Doc.notes\n      \"If the environment where the registration takes \\\n      \\place is private and a registered email address or phone \\\n      \\number is not whitelisted, a 403 error is returned.\"\n    Doc.body (Doc.ref Public.modelNewUser) $\n      Doc.description \"JSON body\"\n    -- FUTUREWORK: I think this should be 'Doc.self' instead of 'user'\n    Doc.returns (Doc.ref Public.modelUser)\n    Doc.response 201 \"User created and pending activation.\" Doc.end\n    Doc.errorResponse whitelistError\n    Doc.errorResponse invalidInvitationCode\n    Doc.errorResponse missingIdentity\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse activationCodeNotFound\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to the user, if account gets activated\n  -- - UserIdentityUpdated event to the user, if email or phone get activated\n  get \"/activate\" (continue activateH) $\n    query \"key\"\n      .&. query \"code\"\n  document \"GET\" \"activate\" $ do\n    Doc.summary \"Activate (i.e. confirm) an email address or phone number.\"\n    Doc.notes \"See also 'POST /activate' which has a larger feature set.\"\n    Doc.parameter Doc.Query \"key\" Doc.bytes' $\n      Doc.description \"Activation key\"\n    Doc.parameter Doc.Query \"code\" Doc.bytes' $\n      Doc.description \"Activation code\"\n    Doc.returns (Doc.ref Public.modelActivationResponse)\n    Doc.response 200 \"Activation successful.\" Doc.end\n    Doc.response 204 \"A recent activation was already successful.\" Doc.end\n    Doc.errorResponse activationCodeNotFound\n\n  -- docs/reference/user/activation.md {#RefActivationSubmit}\n  --\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to the user, if account gets activated\n  -- - UserIdentityUpdated event to the user, if email or phone get activated\n  post \"/activate\" (continue activateKeyH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.Activate\n  document \"POST\" \"activate\" $ do\n    Doc.summary \"Activate (i.e. confirm) an email address or phone number.\"\n    Doc.notes\n      \"Activation only succeeds once and the number of \\\n      \\failed attempts for a valid key is limited.\"\n    Doc.body (Doc.ref Public.modelActivate) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelActivationResponse)\n    Doc.response 200 \"Activation successful.\" Doc.end\n    Doc.response 204 \"A recent activation was already successful.\" Doc.end\n    Doc.errorResponse activationCodeNotFound\n\n  -- docs/reference/user/activation.md {#RefActivationRequest}\n  post \"/activate/send\" (continue sendActivationCodeH) $\n    jsonRequest @Public.SendActivationCode\n  document \"POST\" \"sendActivationCode\" $ do\n    Doc.summary \"Send (or resend) an email or phone activation code.\"\n    Doc.body (Doc.ref Public.modelSendActivationCode) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Activation code sent.\" Doc.end\n    Doc.errorResponse invalidEmail\n    Doc.errorResponse invalidPhone\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n    Doc.errorResponse (customerExtensionBlockedDomain (either undefined id $ mkDomain \"example.com\"))\n\n  post \"/password-reset\" (continue beginPasswordResetH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.NewPasswordReset\n  document \"POST\" \"beginPasswordReset\" $ do\n    Doc.summary \"Initiate a password reset.\"\n    Doc.body (Doc.ref Public.modelNewPasswordReset) $\n      Doc.description \"JSON body\"\n    Doc.response 201 \"Password reset code created and sent by email.\" Doc.end\n    Doc.errorResponse invalidPwResetKey\n    Doc.errorResponse duplicatePwResetCode\n\n  post \"/password-reset/complete\" (continue completePasswordResetH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.CompletePasswordReset\n  document \"POST\" \"completePasswordReset\" $ do\n    Doc.summary \"Complete a password reset.\"\n    Doc.body (Doc.ref Public.modelCompletePasswordReset) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Password reset successful.\" Doc.end\n    Doc.errorResponse invalidPwResetCode\n\n  post \"/password-reset/:key\" (continue deprecatedCompletePasswordResetH) $\n    accept \"application\" \"json\"\n      .&. capture \"key\"\n      .&. jsonRequest @Public.PasswordReset\n  document \"POST\" \"deprecatedCompletePasswordReset\" $ do\n    Doc.deprecated\n    Doc.summary \"Complete a password reset.\"\n    Doc.notes \"DEPRECATED: Use 'POST /password-reset/complete'.\"\n\n  post \"/onboarding/v3\" (continue deprecatedOnboardingH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. jsonRequest @Value\n  document \"POST\" \"onboardingV3\" $ do\n    Doc.deprecated\n    Doc.summary \"Upload contacts and invoke matching.\"\n    Doc.notes\n      \"DEPRECATED: the feature has been turned off, the end-point does \\\n      \\nothing and always returns '{\\\"results\\\":[],\\\"auto-connects\\\":[]}'.\"\n\n  Provider.routesPublic\n  Auth.routesPublic\n  Search.routesPublic\n  Team.routesPublic\n  Calling.routesPublic\n\napiDocs :: Opts -> Routes Doc.ApiBuilder Handler ()\napiDocs o = do\n  get\n    \"/users/api-docs\"\n    ( \\(_ ::: url) k ->\n        let doc = mkSwaggerApi (decodeLatin1 url) Public.Swagger.models (sitemap o)\n         in k $ json doc\n    )\n    $ accept \"application\" \"json\"\n      .&. query \"base_url\"\n\n---------------------------------------------------------------------------\n-- Handlers\n\nsetPropertyH :: UserId ::: ConnId ::: Public.PropertyKey ::: JsonRequest Public.PropertyValue -> Handler Response\nsetPropertyH (u ::: c ::: k ::: req) = do\n  propkey <- safeParsePropertyKey k\n  propval <- safeParsePropertyValue (lazyRequestBody (fromJsonRequest req))\n  empty <$ setProperty u c propkey propval\n\nsetProperty :: UserId -> ConnId -> Public.PropertyKey -> Public.PropertyValue -> Handler ()\nsetProperty u c propkey propval = do\n  API.setProperty u c propkey propval !>> propDataError\n\nsafeParsePropertyKey :: Public.PropertyKey -> Handler Public.PropertyKey\nsafeParsePropertyKey k = do\n  maxKeyLen <- fromMaybe defMaxKeyLen <$> view (settings . propertyMaxKeyLen)\n  let keyText = Ascii.toText (Public.propertyKeyName k)\n  when (Text.compareLength keyText (fromIntegral maxKeyLen) == GT) $\n    throwStd propertyKeyTooLarge\n  pure k\n\n-- | Parse a 'PropertyValue' from a bytestring.  This is different from 'FromJSON' in that\n-- checks the byte size of the input, and fails *without consuming all of it* if that size\n-- exceeds the settings.\nsafeParsePropertyValue :: IO Lazy.ByteString -> Handler Public.PropertyValue\nsafeParsePropertyValue lreqbody = do\n  maxValueLen <- fromMaybe defMaxValueLen <$> view (settings . propertyMaxValueLen)\n  lbs <- Lazy.take (maxValueLen + 1) <$> liftIO lreqbody\n  unless (Lazy.length lbs <= maxValueLen) $\n    throwStd propertyValueTooLarge\n  hoistEither $ fmapL (StdError . badRequest . pack) (eitherDecode lbs)\n\ndeletePropertyH :: UserId ::: ConnId ::: Public.PropertyKey -> Handler Response\ndeletePropertyH (u ::: c ::: k) = lift (API.deleteProperty u c k) >> return empty\n\nclearPropertiesH :: UserId ::: ConnId -> Handler Response\nclearPropertiesH (u ::: c) = lift (API.clearProperties u c) >> return empty\n\ngetPropertyH :: UserId ::: Public.PropertyKey ::: JSON -> Handler Response\ngetPropertyH (u ::: k ::: _) = do\n  val <- lift $ API.lookupProperty u k\n  return $ case val of\n    Nothing -> setStatus status404 empty\n    Just v -> json (v :: Public.PropertyValue)\n\nlistPropertyKeysH :: UserId ::: JSON -> Handler Response\nlistPropertyKeysH (u ::: _) = do\n  keys <- lift (API.lookupPropertyKeys u)\n  pure $ json (keys :: [Public.PropertyKey])\n\nlistPropertyKeysAndValuesH :: UserId ::: JSON -> Handler Response\nlistPropertyKeysAndValuesH (u ::: _) = do\n  keysAndVals <- lift (API.lookupPropertyKeysAndValues u)\n  pure $ json (keysAndVals :: Public.PropertyKeysAndValues)\n\ngetPrekeyUnqualifiedH :: UserId -> ClientId -> Handler Public.ClientPrekey\ngetPrekeyUnqualifiedH user client = do\n  domain <- viewFederationDomain\n  ifNothing (notFound \"prekey not found\") =<< lift (API.claimPrekey user domain client)\n\ngetPrekeyH :: Domain -> UserId -> ClientId -> Handler Public.ClientPrekey\ngetPrekeyH domain user client = do\n  ifNothing (notFound \"prekey not found\") =<< lift (API.claimPrekey user domain client)\n\ngetPrekeyBundleUnqualifiedH :: UserId -> Handler Public.PrekeyBundle\ngetPrekeyBundleUnqualifiedH uid = do\n  domain <- viewFederationDomain\n  API.claimPrekeyBundle domain uid !>> clientError\n\ngetPrekeyBundleH :: Domain -> UserId -> Handler Public.PrekeyBundle\ngetPrekeyBundleH domain uid =\n  API.claimPrekeyBundle domain uid !>> clientError\n\ngetMultiUserPrekeyBundleUnqualifiedH :: Public.UserClients -> Handler (Public.UserClientMap (Maybe Public.Prekey))\ngetMultiUserPrekeyBundleUnqualifiedH userClients = do\n  maxSize <- fromIntegral . setMaxConvSize <$> view settings\n  when (Map.size (Public.userClients userClients) > maxSize) $\n    throwStd tooManyClients\n  API.claimMultiPrekeyBundlesLocal userClients !>> clientError\n\ngetMultiUserPrekeyBundleH :: Public.QualifiedUserClients -> Handler (Public.QualifiedUserClientMap (Maybe Public.Prekey))\ngetMultiUserPrekeyBundleH qualUserClients = do\n  maxSize <- fromIntegral . setMaxConvSize <$> view settings\n  let Sum (size :: Int) =\n        Map.foldMapWithKey\n          (\\_ v -> Sum . Map.size . Public.userClients $ v)\n          (Public.qualifiedUserClients qualUserClients)\n  when (size > maxSize) $\n    throwStd tooManyClients\n  API.claimMultiPrekeyBundles qualUserClients !>> clientError\n\naddClientH :: JsonRequest Public.NewClient ::: UserId ::: ConnId ::: Maybe IpAddr ::: JSON -> Handler Response\naddClientH (req ::: usr ::: con ::: ip ::: _) = do\n  new <- parseJsonBody req\n  clt <- addClient new usr con ip\n  let loc = toByteString' $ Public.clientId clt\n  pure . setStatus status201 . addHeader \"Location\" loc . json $ clt\n\naddClient :: Public.NewClient -> UserId -> ConnId -> Maybe IpAddr -> Handler Public.Client\naddClient new usr con ip = do\n  -- Users can't add legal hold clients\n  when (Public.newClientType new == Public.LegalHoldClientType) $\n    throwE (clientError ClientLegalHoldCannotBeAdded)\n  API.addClient usr (Just con) (ipAddr <$> ip) new !>> clientError\n\nrmClientH :: JsonRequest Public.RmClient ::: UserId ::: ConnId ::: ClientId ::: JSON -> Handler Response\nrmClientH (req ::: usr ::: con ::: clt ::: _) = do\n  body <- parseJsonBody req\n  empty <$ rmClient body usr con clt\n\nrmClient :: Public.RmClient -> UserId -> ConnId -> ClientId -> Handler ()\nrmClient body usr con clt = do\n  API.rmClient usr con clt (Public.rmPassword body) !>> clientError\n\nupdateClientH :: JsonRequest Public.UpdateClient ::: UserId ::: ClientId ::: JSON -> Handler Response\nupdateClientH (req ::: usr ::: clt ::: _) = do\n  body <- parseJsonBody req\n  empty <$ updateClient body usr clt\n\nupdateClient :: Public.UpdateClient -> UserId -> ClientId -> Handler ()\nupdateClient body usr clt = do\n  API.updateClient usr clt body !>> clientError\n\nlistClientsH :: UserId ::: JSON -> Handler Response\nlistClientsH (zusr ::: _) =\n  json <$> listClients zusr\n\nlistClients :: UserId -> Handler [Public.Client]\nlistClients zusr = do\n  API.lookupClients (Local zusr) !>> clientError\n\ngetClientH :: UserId ::: ClientId ::: JSON -> Handler Response\ngetClientH (zusr ::: clt ::: _) =\n  getClient zusr clt <&> \\case\n    Just c -> json c\n    Nothing -> setStatus status404 empty\n\nlistClientsBulk :: UserId -> Range 1 MaxUsersForListClientsBulk [Qualified UserId] -> Handler (Public.QualifiedUserMap (Set Public.Client))\nlistClientsBulk _zusr limitedUids =\n  API.lookupClientsBulk (fromRange limitedUids) !>> clientError\n\ngetClient :: UserId -> ClientId -> Handler (Maybe Public.Client)\ngetClient zusr clientId = do\n  API.lookupClient (Local zusr) clientId !>> clientError\n\ngetUserClientsH :: OpaqueUserId ::: JSON -> Handler Response\ngetUserClientsH (user ::: _) =\n  json <$> getUserClients user\n\ngetUserClients :: OpaqueUserId -> Handler [Public.PubClient]\ngetUserClients opaqueUserId = do\n  resolvedUserId <- lift $ resolveOpaqueUserId opaqueUserId\n  API.pubClient <$$> API.lookupClients resolvedUserId !>> clientError\n\ngetUserClientH :: OpaqueUserId ::: ClientId ::: JSON -> Handler Response\ngetUserClientH (user ::: cid ::: _) = do\n  maybe (setStatus status404 empty) json <$> getUserClient user cid\n\ngetUserClient :: OpaqueUserId -> ClientId -> Handler (Maybe Public.PubClient)\ngetUserClient opaqueUserId clientId = do\n  resolvedUserId <- lift $ resolveOpaqueUserId opaqueUserId\n  API.pubClient <$$> API.lookupClient resolvedUserId clientId !>> clientError\n\ngetRichInfoH :: UserId ::: UserId ::: JSON -> Handler Response\ngetRichInfoH (self ::: user ::: _) = do\n  json <$> getRichInfo self user\n\ngetRichInfo :: UserId -> UserId -> Handler Public.RichInfoAssocList\ngetRichInfo self user = do\n  -- Check that both users exist and the requesting user is allowed to see rich info of the\n  -- other user\n  selfUser <- ifNothing userNotFound =<< lift (Data.lookupUser NoPendingInvitations self)\n  otherUser <- ifNothing userNotFound =<< lift (Data.lookupUser NoPendingInvitations user)\n  case (Public.userTeam selfUser, Public.userTeam otherUser) of\n    (Just t1, Just t2) | t1 == t2 -> pure ()\n    _ -> throwStd insufficientTeamPermissions\n  -- Query rich info\n  fromMaybe Public.emptyRichInfoAssocList <$> lift (API.lookupRichInfo user)\n\nlistPrekeyIdsH :: UserId ::: ClientId ::: JSON -> Handler Response\nlistPrekeyIdsH (usr ::: clt ::: _) = do\n  prekeyIds <- lift (API.lookupPrekeyIds usr clt)\n  pure $ json (prekeyIds :: [Public.PrekeyId])\n\n-- docs/reference/user/registration.md {#RefRegistration}\ncreateUserH :: JSON ::: JsonRequest Public.NewUserPublic -> Handler Response\ncreateUserH (_ ::: req) = do\n  CreateUserResponse cok loc prof <- createUser =<< parseJsonBody req\n  lift . Auth.setResponseCookie cok\n    . setStatus status201\n    . addHeader \"Location\" (toByteString' loc)\n    $ json prof\n\ndata CreateUserResponse\n  = CreateUserResponse (Public.Cookie (ZAuth.Token ZAuth.User)) UserId Public.SelfProfile\n\ncreateUser :: Public.NewUserPublic -> Handler CreateUserResponse\ncreateUser (Public.NewUserPublic new) = do\n  API.checkRestrictedUserCreation new !>> newUserError\n  for_ (Public.newUserEmail new) $ checkWhitelist . Left\n  for_ (Public.newUserPhone new) $ checkWhitelist . Right\n  result <- API.createUser new !>> newUserError\n  let acc = createdAccount result\n\n  let eac = createdEmailActivation result\n  let pac = createdPhoneActivation result\n  let epair = (,) <$> (activationKey <$> eac) <*> (activationCode <$> eac)\n  let ppair = (,) <$> (activationKey <$> pac) <*> (activationCode <$> pac)\n  let newUserLabel = Public.newUserLabel new\n  let newUserTeam = Public.newUserTeam new\n  let usr = accountUser acc\n\n  let context =\n        let invitationCode = case Public.newUserTeam new of\n              (Just (Public.NewTeamMember code)) -> Just code\n              _ -> Nothing\n         in ( logFunction \"Brig.API.Public.createUser\"\n                . logUser (Public.userId usr)\n                . maybe id logHandle (Public.userHandle usr)\n                . maybe id logTeam (Public.userTeam usr)\n                . maybe id logEmail (Public.userEmail usr)\n                . maybe id logInvitationCode invitationCode\n            )\n  Log.info $ context . Log.msg @Text \"Sucessfully created user\"\n\n  let Public.User {userLocale, userDisplayName, userId} = usr\n  let userEmail = Public.userEmail usr\n  let userPhone = Public.userPhone usr\n  lift $ do\n    for_ (liftM2 (,) userEmail epair) $ \\(e, p) ->\n      sendActivationEmail e userDisplayName p (Just userLocale) newUserTeam\n    for_ (liftM2 (,) userPhone ppair) $ \\(p, c) ->\n      sendActivationSms p c (Just userLocale)\n    for_ (liftM3 (,,) userEmail (createdUserTeam result) newUserTeam) $ \\(e, ct, ut) ->\n      sendWelcomeEmail e ct ut (Just userLocale)\n  cok <- case acc of\n    UserAccount _ Ephemeral -> lift $ Auth.newCookie @ZAuth.User userId Public.SessionCookie newUserLabel\n    UserAccount _ _ -> lift $ Auth.newCookie @ZAuth.User userId Public.PersistentCookie newUserLabel\n  pure $ CreateUserResponse cok userId (Public.SelfProfile usr)\n  where\n    sendActivationEmail :: Public.Email -> Public.Name -> ActivationPair -> Maybe Public.Locale -> Maybe Public.NewTeamUser -> AppIO ()\n    sendActivationEmail e u p l mTeamUser\n      | Just teamUser <- mTeamUser,\n        Public.NewTeamCreator creator <- teamUser,\n        let Public.BindingNewTeamUser (Public.BindingNewTeam team) _ = creator =\n        sendTeamActivationMail e u p l (fromRange $ team ^. Public.newTeamName)\n      | otherwise =\n        sendActivationMail e u p l Nothing\n\n    sendWelcomeEmail :: Public.Email -> CreateUserTeam -> Public.NewTeamUser -> Maybe Public.Locale -> AppIO ()\n    -- NOTE: Welcome e-mails for the team creator are not dealt by brig anymore\n    sendWelcomeEmail e (CreateUserTeam t n) newUser l = case newUser of\n      Public.NewTeamCreator _ ->\n        return ()\n      Public.NewTeamMember _ ->\n        Team.sendMemberWelcomeMail e t n l\n      Public.NewTeamMemberSSO _ ->\n        Team.sendMemberWelcomeMail e t n l\n\ncheckUserExistsUnqualifiedH :: UserId -> UserId -> Handler (Union CheckUserExistsResponse)\ncheckUserExistsUnqualifiedH self uid = do\n  domain <- viewFederationDomain\n  checkUserExistsH self domain uid\n\ncheckUserExistsH :: UserId -> Domain -> UserId -> Handler (Union CheckUserExistsResponse)\ncheckUserExistsH self domain uid = do\n  exists <- checkUserExists self (Qualified uid domain)\n  if exists\n    then Servant.respond Empty200\n    else Servant.respond Empty404\n\ncheckUserExists :: UserId -> Qualified UserId -> Handler Bool\ncheckUserExists self qualifiedUserId =\n  isJust <$> getUser self qualifiedUserId\n\ngetSelf :: UserId -> Handler Public.SelfProfile\ngetSelf self = do\n  lift (API.lookupSelfProfile self) >>= ifNothing userNotFound\n\ngetUserUnqualifiedH :: UserId -> UserId -> Handler Public.UserProfile\ngetUserUnqualifiedH self uid = do\n  domain <- viewFederationDomain\n  getUserH self domain uid\n\ngetUserH :: UserId -> Domain -> UserId -> Handler Public.UserProfile\ngetUserH self domain uid =\n  ifNothing userNotFound =<< getUser self (Qualified uid domain)\n\ngetUser :: UserId -> Qualified UserId -> Handler (Maybe Public.UserProfile)\ngetUser self qualifiedUserId = do\n  lift $ API.lookupProfile self qualifiedUserId\n\ngetUserDisplayNameH :: JSON ::: UserId -> Handler Response\ngetUserDisplayNameH (_ ::: self) = do\n  name :: Maybe Public.Name <- lift $ API.lookupName self\n  return $ case name of\n    Just n -> json $ object [\"name\" .= n]\n    Nothing -> setStatus status404 empty\n\n-- FUTUREWORK: Make servant understand that at least one of these is required\nlistUsersByUnqualifiedIdsOrHandles :: UserId -> Maybe (CommaSeparatedList UserId) -> Maybe (Range 1 4 (CommaSeparatedList Handle)) -> Handler [Public.UserProfile]\nlistUsersByUnqualifiedIdsOrHandles self mUids mHandles = do\n  domain <- viewFederationDomain\n  case (mUids, mHandles) of\n    (Just uids, _) -> listUsersByIdsOrHandles self (Public.ListUsersByIds ((`Qualified` domain) <$> fromCommaSeparatedList uids))\n    (_, Just handles) ->\n      let normalRangedList = fromCommaSeparatedList $ fromRange handles\n          qualifiedList = (`Qualified` domain) <$> normalRangedList\n          -- Use of unsafeRange here is ok only because we know that 'handles'\n          -- is valid for 'Range 1 4'. However, we must not forget to keep this\n          -- annotation here otherwise a change in 'Public.ListUsersByHandles'\n          -- could cause this code to break.\n          qualifiedRangedList :: Range 1 4 [Qualified Handle] = unsafeRange qualifiedList\n       in listUsersByIdsOrHandles self (Public.ListUsersByHandles qualifiedRangedList)\n    (Nothing, Nothing) -> throwStd $ badRequest \"at least one ids or handles must be provided\"\n\nlistUsersByIdsOrHandles :: UserId -> Public.ListUsersQuery -> Handler [Public.UserProfile]\nlistUsersByIdsOrHandles self q = do\n  foundUsers <- case q of\n    Public.ListUsersByIds us ->\n      byIds us\n    Public.ListUsersByHandles hs -> do\n      domain <- viewFederationDomain\n      let (_remoteHandles, localHandles) = partitionRemoteOrLocalIds domain (fromRange hs)\n      us <- getIds localHandles\n      filterHandleResults self =<< byIds us\n  case foundUsers of\n    [] -> throwStd $ notFound \"None of the specified ids or handles match any users\"\n    _ -> pure foundUsers\n  where\n    getIds :: [Handle] -> Handler [Qualified UserId]\n    getIds localHandles = do\n      localUsers <- catMaybes <$> traverse (lift . API.lookupHandle) localHandles\n      -- FUTUREWORK(federation, #1268): resolve qualified handles, too\n      domain <- viewFederationDomain\n      pure $ map (`Qualified` domain) localUsers\n    byIds :: [Qualified UserId] -> Handler [Public.UserProfile]\n    byIds uids =\n      lift $ API.lookupProfiles self uids\n\nnewtype GetActivationCodeResp\n  = GetActivationCodeResp (Public.ActivationKey, Public.ActivationCode)\n\ninstance ToJSON GetActivationCodeResp where\n  toJSON (GetActivationCodeResp (k, c)) = object [\"key\" .= k, \"code\" .= c]\n\nupdateUserH :: UserId ::: ConnId ::: JsonRequest Public.UserUpdate -> Handler Response\nupdateUserH (uid ::: conn ::: req) = do\n  uu <- parseJsonBody req\n  API.updateUser uid (Just conn) uu API.ForbidSCIMUpdates !>> updateProfileError\n  return empty\n\nchangePhoneH :: UserId ::: ConnId ::: JsonRequest Public.PhoneUpdate -> Handler Response\nchangePhoneH (u ::: c ::: req) = do\n  setStatus status202 empty <$ (changePhone u c =<< parseJsonBody req)\n\nchangePhone :: UserId -> ConnId -> Public.PhoneUpdate -> Handler ()\nchangePhone u _ (Public.puPhone -> phone) = do\n  (adata, pn) <- API.changePhone u phone !>> changePhoneError\n  loc <- lift $ API.lookupLocale u\n  let apair = (activationKey adata, activationCode adata)\n  lift $ sendActivationSms pn apair loc\n\nremovePhoneH :: UserId ::: ConnId -> Handler Response\nremovePhoneH (self ::: conn) = do\n  API.removePhone self conn !>> idtError\n  return empty\n\nremoveEmailH :: UserId ::: ConnId -> Handler Response\nremoveEmailH (self ::: conn) = do\n  API.removeEmail self conn !>> idtError\n  return empty\n\ncheckPasswordExistsH :: UserId -> Handler Response\ncheckPasswordExistsH self = do\n  exists <- lift $ isJust <$> API.lookupPassword self\n  return $ if exists then empty else setStatus status404 empty\n\nchangePasswordH :: UserId ::: JsonRequest Public.PasswordChange -> Handler Response\nchangePasswordH (u ::: req) = do\n  cp <- parseJsonBody req\n  API.changePassword u cp !>> changePwError\n  return empty\n\nchangeLocaleH :: UserId ::: ConnId ::: JsonRequest Public.LocaleUpdate -> Handler Response\nchangeLocaleH (u ::: conn ::: req) = do\n  l <- parseJsonBody req\n  lift $ API.changeLocale u conn l\n  return empty\n\n-- | (zusr is ignored by this handler, ie. checking handles is allowed as long as you have\n-- *any* account.)\ncheckHandleH :: UserId ::: Text -> Handler Response\ncheckHandleH (_uid ::: hndl) = do\n  API.checkHandle hndl >>= \\case\n    API.CheckHandleInvalid -> throwE (StdError invalidHandle)\n    API.CheckHandleFound -> pure $ setStatus status200 empty\n    API.CheckHandleNotFound -> pure $ setStatus status404 empty\n\ncheckHandlesH :: JSON ::: UserId ::: JsonRequest Public.CheckHandles -> Handler Response\ncheckHandlesH (_ ::: _ ::: req) = do\n  Public.CheckHandles hs num <- parseJsonBody req\n  let handles = mapMaybe parseHandle (fromRange hs)\n  free <- lift $ API.checkHandles handles (fromRange num)\n  return $ json (free :: [Handle])\n\ngetHandleInfoUnqualifiedH :: UserId -> Handle -> Handler Public.UserHandleInfo\ngetHandleInfoUnqualifiedH self handle = do\n  domain <- viewFederationDomain\n  getHandleInfoH self domain handle\n\ngetHandleInfoH :: UserId -> Domain -> Handle -> Handler Public.UserHandleInfo\ngetHandleInfoH self domain handle =\n  ifNothing (notFound \"handle not found\")\n    =<< getHandleInfo self (Qualified handle domain)\n\n-- FUTUREWORK: use 'runMaybeT' to simplify this.\ngetHandleInfo :: UserId -> Qualified Handle -> Handler (Maybe Public.UserHandleInfo)\ngetHandleInfo self handle = do\n  domain <- viewFederationDomain\n  if qDomain handle == domain\n    then getLocalHandleInfo domain\n    else getRemoteHandleInfo\n  where\n    getLocalHandleInfo domain = do\n      Log.info $ Log.msg $ Log.val \"getHandleInfo - local lookup\"\n      maybeOwnerId <- lift $ API.lookupHandle (qUnqualified handle)\n      case maybeOwnerId of\n        Nothing -> return Nothing\n        Just ownerId -> do\n          ownerProfile <- lift $ API.lookupProfile self (Qualified ownerId domain)\n          owner <- filterHandleResults self (maybeToList ownerProfile)\n          return $ Public.UserHandleInfo . Public.profileQualifiedId <$> listToMaybe owner\n    getRemoteHandleInfo = do\n      Log.info $ (Log.msg $ Log.val \"getHandleInfo - remote lookup\") Log.~~ Log.field \"domain\" (show (qDomain handle))\n      Federation.getUserHandleInfo handle\n\nchangeHandleH :: UserId ::: ConnId ::: JsonRequest Public.HandleUpdate -> Handler Response\nchangeHandleH (u ::: conn ::: req) = do\n  empty <$ (changeHandle u conn =<< parseJsonBody req)\n\nchangeHandle :: UserId -> ConnId -> Public.HandleUpdate -> Handler ()\nchangeHandle u conn (Public.HandleUpdate h) = do\n  handle <- API.validateHandle h\n  -- TODO check here\n  API.changeHandle u (Just conn) handle API.ForbidSCIMUpdates !>> changeHandleError\n\nbeginPasswordResetH :: JSON ::: JsonRequest Public.NewPasswordReset -> Handler Response\nbeginPasswordResetH (_ ::: req) = do\n  setStatus status201 empty <$ (beginPasswordReset =<< parseJsonBody req)\n\nbeginPasswordReset :: Public.NewPasswordReset -> Handler ()\nbeginPasswordReset (Public.NewPasswordReset target) = do\n  checkWhitelist target\n  (u, pair) <- API.beginPasswordReset target !>> pwResetError\n  loc <- lift $ API.lookupLocale u\n  lift $ case target of\n    Left email -> sendPasswordResetMail email pair loc\n    Right phone -> sendPasswordResetSms phone pair loc\n\ncompletePasswordResetH :: JSON ::: JsonRequest Public.CompletePasswordReset -> Handler Response\ncompletePasswordResetH (_ ::: req) = do\n  Public.CompletePasswordReset {..} <- parseJsonBody req\n  API.completePasswordReset cpwrIdent cpwrCode cpwrPassword !>> pwResetError\n  return empty\n\nsendActivationCodeH :: JsonRequest Public.SendActivationCode -> Handler Response\nsendActivationCodeH req = do\n  empty <$ (sendActivationCode =<< parseJsonBody req)\n\n-- docs/reference/user/activation.md {#RefActivationRequest}\n-- docs/reference/user/registration.md {#RefRegistration}\nsendActivationCode :: Public.SendActivationCode -> Handler ()\nsendActivationCode Public.SendActivationCode {..} = do\n  checkWhitelist saUserKey\n  either customerExtensionCheckBlockedDomains (\\_ -> pure ()) saUserKey\n  API.sendActivationCode saUserKey saLocale saCall !>> sendActCodeError\n\n-- | If the user presents an email address from a blocked domain, throw an error.\n--\n-- The tautological constraint in the type signature is added so that once we remove the\n-- feature, ghc will guide us here.\ncustomerExtensionCheckBlockedDomains :: (DomainsBlockedForRegistration ~ DomainsBlockedForRegistration) => Public.Email -> Handler ()\ncustomerExtensionCheckBlockedDomains email = do\n  mBlockedDomains <- asks (fmap domainsBlockedForRegistration . setCustomerExtensions . view settings)\n  for_ mBlockedDomains $ \\(DomainsBlockedForRegistration blockedDomains) -> do\n    case mkDomain (Public.emailDomain email) of\n      Left _ ->\n        pure () -- if it doesn't fit the syntax of blocked domains, it is not blocked\n      Right domain ->\n        when (domain `elem` blockedDomains) $ do\n          throwM $ customerExtensionBlockedDomain domain\n\nchangeSelfEmailH :: UserId ::: ConnId ::: JsonRequest Public.EmailUpdate -> Handler Response\nchangeSelfEmailH (u ::: _ ::: req) = do\n  email <- Public.euEmail <$> parseJsonBody req\n  API.changeSelfEmail u email API.ForbidSCIMUpdates >>= \\case\n    ChangeEmailResponseIdempotent -> pure (setStatus status204 empty)\n    ChangeEmailResponseNeedsActivation -> pure (setStatus status202 empty)\n\ncreateConnectionH :: JSON ::: UserId ::: ConnId ::: JsonRequest Public.ConnectionRequest -> Handler Response\ncreateConnectionH (_ ::: self ::: conn ::: req) = do\n  cr <- parseJsonBody req\n  rs <- API.createConnection self cr conn !>> connError\n  return $ case rs of\n    ConnectionCreated c -> setStatus status201 $ json (c :: Public.UserConnection)\n    ConnectionExists c -> json (c :: Public.UserConnection)\n\nupdateConnectionH :: JSON ::: UserId ::: ConnId ::: UserId ::: JsonRequest Public.ConnectionUpdate -> Handler Response\nupdateConnectionH (_ ::: self ::: conn ::: other ::: req) = do\n  newStatus <- Public.cuStatus <$> parseJsonBody req\n  mc <- API.updateConnection self other newStatus (Just conn) !>> connError\n  return $ case mc of\n    Just c -> json (c :: Public.UserConnection)\n    Nothing -> setStatus status204 empty\n\nlistConnectionsH :: JSON ::: UserId ::: Maybe UserId ::: Range 1 500 Int32 -> Handler Response\nlistConnectionsH (_ ::: uid ::: start ::: size) =\n  json @Public.UserConnectionList\n    <$> lift (API.lookupConnections uid start size)\n\ngetConnectionH :: JSON ::: UserId ::: UserId -> Handler Response\ngetConnectionH (_ ::: uid ::: uid') = lift $ do\n  conn <- API.lookupConnection uid uid'\n  return $ case conn of\n    Just c -> json (c :: Public.UserConnection)\n    Nothing -> setStatus status404 empty\n\ndeleteUserH :: UserId ::: JsonRequest Public.DeleteUser ::: JSON -> Handler Response\ndeleteUserH (u ::: r ::: _) = do\n  body <- parseJsonBody r\n  res <- API.deleteUser u (Public.deleteUserPassword body) !>> deleteUserError\n  return $ case res of\n    Nothing -> setStatus status200 empty\n    Just ttl -> setStatus status202 (json (Public.DeletionCodeTimeout ttl))\n\nverifyDeleteUserH :: JsonRequest Public.VerifyDeleteUser ::: JSON -> Handler Response\nverifyDeleteUserH (r ::: _) = do\n  body <- parseJsonBody r\n  API.verifyDeleteUser body !>> deleteUserError\n  return (setStatus status200 empty)\n\n-- activation\n\ndata ActivationRespWithStatus\n  = ActivationResp Public.ActivationResponse\n  | ActivationRespDryRun\n  | ActivationRespPass\n  | ActivationRespSuccessNoIdent\n\nrespFromActivationRespWithStatus :: ActivationRespWithStatus -> Response\nrespFromActivationRespWithStatus = \\case\n  ActivationResp aresp -> json aresp\n  ActivationRespDryRun -> empty\n  ActivationRespPass -> setStatus status204 empty\n  ActivationRespSuccessNoIdent -> empty\n\n-- docs/reference/user/activation.md {#RefActivationSubmit}\nactivateKeyH :: JSON ::: JsonRequest Public.Activate -> Handler Response\nactivateKeyH (_ ::: req) = do\n  activationRequest <- parseJsonBody req\n  respFromActivationRespWithStatus <$> activate activationRequest\n\nactivateH :: Public.ActivationKey ::: Public.ActivationCode -> Handler Response\nactivateH (k ::: c) = do\n  let activationRequest = Public.Activate (Public.ActivateKey k) c False\n  respFromActivationRespWithStatus <$> activate activationRequest\n\nactivate :: Public.Activate -> Handler ActivationRespWithStatus\nactivate (Public.Activate tgt code dryrun)\n  | dryrun = do\n    API.preverify tgt code !>> actError\n    return $ ActivationRespDryRun\n  | otherwise = do\n    result <- API.activate tgt code Nothing !>> actError\n    return $ case result of\n      ActivationSuccess ident first -> respond ident first\n      ActivationPass -> ActivationRespPass\n  where\n    respond (Just ident) first = ActivationResp $ Public.ActivationResponse ident first\n    respond Nothing _ = ActivationRespSuccessNoIdent\n\n-- Deprecated\n\ndeprecatedOnboardingH :: JSON ::: UserId ::: JsonRequest Value -> Handler Response\ndeprecatedOnboardingH (_ ::: _ ::: _) = pure $ json DeprecatedMatchingResult\n\ndata DeprecatedMatchingResult = DeprecatedMatchingResult\n\ninstance ToJSON DeprecatedMatchingResult where\n  toJSON DeprecatedMatchingResult =\n    object\n      [ \"results\" .= ([] :: [()]),\n        \"auto-connects\" .= ([] :: [()])\n      ]\n\ndeprecatedCompletePasswordResetH :: JSON ::: Public.PasswordResetKey ::: JsonRequest Public.PasswordReset -> Handler Response\ndeprecatedCompletePasswordResetH (_ ::: k ::: req) = do\n  pwr <- parseJsonBody req\n  API.completePasswordReset\n    (Public.PasswordResetIdentityKey k)\n    (Public.pwrCode pwr)\n    (Public.pwrPassword pwr)\n    !>> pwResetError\n  return empty\n\n-- Utilities\n\nifNothing :: Utilities.Error -> Maybe a -> Handler a\nifNothing e = maybe (throwStd e) return\n\n-- | Checks search permissions and filters accordingly\nfilterHandleResults :: UserId -> [Public.UserProfile] -> Handler [Public.UserProfile]\nfilterHandleResults searchingUser us = do\n  sameTeamSearchOnly <- fromMaybe False <$> view (settings . searchSameTeamOnly)\n  if sameTeamSearchOnly\n    then do\n      fromTeam <- lift $ Data.lookupUserTeam searchingUser\n      return $ case fromTeam of\n        Just team -> filter (\\x -> Public.profileTeam x == Just team) us\n        Nothing -> us\n    else return us\n", "{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule API.User.Client\n  ( tests,\n  )\nwhere\n\nimport API.User.Util\nimport Bilge hiding (accept, head, timeout)\nimport Bilge.Assert\nimport qualified Brig.Options as Opt\nimport Brig.Types\nimport Brig.Types.User.Auth hiding (user)\nimport Control.Lens hiding ((#))\nimport Data.Aeson\nimport Data.Aeson.Lens\nimport Data.ByteString.Conversion\nimport Data.Id hiding (client)\nimport qualified Data.List1 as List1\nimport qualified Data.Map as Map\nimport Data.Qualified (Qualified (..))\nimport qualified Data.Set as Set\nimport qualified Data.Vector as Vec\nimport Gundeck.Types.Notification\nimport Imports\nimport qualified Network.Wai.Utilities.Error as Error\nimport Test.Tasty hiding (Timeout)\nimport Test.Tasty.Cannon hiding (Cannon)\nimport qualified Test.Tasty.Cannon as WS\nimport Test.Tasty.HUnit\nimport UnliftIO (mapConcurrently)\nimport Util\nimport Wire.API.User.Client (QualifiedUserClientMap (..), QualifiedUserClients (..), UserClientMap (..), UserClients (..))\nimport Wire.API.UserMap (QualifiedUserMap (..), UserMap (..))\n\ntests :: ConnectionLimit -> Opt.Timeout -> Opt.Opts -> Manager -> Brig -> Cannon -> Galley -> TestTree\ntests _cl _at opts p b c g =\n  testGroup\n    \"client\"\n    [ test p \"delete /clients/:client 403 - can't delete legalhold clients\" $\n        testCan'tDeleteLegalHoldClient b,\n      test p \"post /clients 400 - can't add legalhold clients manually\" $\n        testCan'tAddLegalHoldClient b,\n      test p \"get /users/:uid/prekeys - 200\" $ testGetUserPrekeys b,\n      test p \"get /users/<localdomain>/:uid/prekeys - 200\" $ testGetUserPrekeysQualified b opts,\n      test p \"get /users/:uid/prekeys/:client - 200\" $ testGetClientPrekey b,\n      test p \"get /users/<localdomain>/:uid/prekeys/:client - 200\" $ testGetClientPrekeyQualified b opts,\n      test p \"post /users/prekeys\" $ testMultiUserGetPrekeys b,\n      test p \"post /users/list-prekeys\" $ testMultiUserGetPrekeysQualified b opts,\n      test p \"post /users/list-clients - 200\" $ testListClientsBulk opts b,\n      test p \"post /clients - 201 (pwd)\" $ testAddGetClient True b c,\n      test p \"post /clients - 201 (no pwd)\" $ testAddGetClient False b c,\n      test p \"post /clients - 403\" $ testClientReauthentication b,\n      test p \"get /clients - 200\" $ testListClients b,\n      test p \"get /clients/:client/prekeys - 200\" $ testListPrekeyIds b,\n      test p \"post /clients - 400\" $ testTooManyClients opts b,\n      test p \"delete /clients/:client - 200 (pwd)\" $ testRemoveClient True b c,\n      test p \"delete /clients/:client - 200 (no pwd)\" $ testRemoveClient False b c,\n      test p \"put /clients/:client - 200\" $ testUpdateClient b,\n      test p \"post /clients - 200 multiple temporary\" $ testAddMultipleTemporary b g,\n      test p \"client/prekeys/race\" $ testPreKeyRace b\n    ]\n\ntestAddGetClient :: Bool -> Brig -> Cannon -> Http ()\ntestAddGetClient hasPwd brig cannon = do\n  uid <- userId <$> randomUser' hasPwd brig\n  let rq =\n        addClientReq brig uid (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          . header \"X-Forwarded-For\" \"127.0.0.1\" -- Fake IP to test IpAddr parsing.\n  c <- WS.bracketR cannon uid $ \\ws -> do\n    c <-\n      responseJsonError\n        =<< ( post rq <!! do\n                const 201 === statusCode\n                const True === isJust . getHeader \"Location\"\n            )\n    void . liftIO . WS.assertMatch (5 # Second) ws $ \\n -> do\n      let j = Object $ List1.head (ntfPayload n)\n      let etype = j ^? key \"type\" . _String\n      let eclient = j ^? key \"client\"\n      etype @?= Just \"user.client-add\"\n      fmap fromJSON eclient @?= Just (Success c)\n    return c\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just c) === responseJsonMaybe\n\ntestClientReauthentication :: Brig -> Http ()\ntestClientReauthentication brig = do\n  let (pk1, lk1) = (somePrekeys !! 0, someLastPrekeys !! 0)\n  let (pk2, lk2) = (somePrekeys !! 1, someLastPrekeys !! 1)\n  let (pk3, lk3) = (somePrekeys !! 2, someLastPrekeys !! 2)\n  let payload1 =\n        (defNewClient PermanentClientType [pk1] lk1)\n          { newClientPassword = Nothing\n          }\n  let payload2 =\n        (defNewClient PermanentClientType [pk2] lk2)\n          { newClientPassword = Nothing\n          }\n  let payload3 =\n        (defNewClient TemporaryClientType [pk3] lk3)\n          { newClientPassword = Nothing\n          }\n  -- User with password\n  uid <- userId <$> randomUser brig\n  -- The first client never requires authentication\n  c <- responseJsonError =<< (addClient brig uid payload1 <!! const 201 === statusCode)\n  -- Adding a second client requires reauthentication, if a password is set.\n  addClient brig uid payload2 !!! do\n    const 403 === statusCode\n    const (Just \"missing-auth\") === (fmap Error.label . responseJsonMaybe)\n  -- Removing a client requires reauthentication, if a password is set.\n  deleteClient brig uid (clientId c) Nothing !!! const 403 === statusCode\n  -- User without a password\n  uid2 <- userId <$> createAnonUser \"Mr. X\" brig\n  c2 <- responseJsonError =<< (addClient brig uid2 payload1 <!! const 201 === statusCode)\n  c3 <- responseJsonError =<< (addClient brig uid2 payload2 <!! const 201 === statusCode)\n  deleteClient brig uid2 (clientId c2) Nothing !!! const 200 === statusCode\n  deleteClient brig uid2 (clientId c3) Nothing !!! const 200 === statusCode\n  -- Temporary client can always be deleted without a password\n  c4 <- responseJsonError =<< addClient brig uid payload3\n  deleteClient brig uid (clientId c4) Nothing !!! const 200 === statusCode\n  c5 <- responseJsonError =<< addClient brig uid2 payload3\n  deleteClient brig uid2 (clientId c5) Nothing !!! const 200 === statusCode\n\ntestListClients :: Brig -> Http ()\ntestListClients brig = do\n  uid <- userId <$> randomUser brig\n  let (pk1, lk1) = (somePrekeys !! 0, (someLastPrekeys !! 0))\n  let (pk2, lk2) = (somePrekeys !! 1, (someLastPrekeys !! 1))\n  let (pk3, lk3) = (somePrekeys !! 2, (someLastPrekeys !! 2))\n  c1 <- responseJsonMaybe <$> addClient brig uid (defNewClient PermanentClientType [pk1] lk1)\n  c2 <- responseJsonMaybe <$> addClient brig uid (defNewClient PermanentClientType [pk2] lk2)\n  c3 <- responseJsonMaybe <$> addClient brig uid (defNewClient TemporaryClientType [pk3] lk3)\n  let cs = sortBy (compare `on` clientId) $ catMaybes [c1, c2, c3]\n  get\n    ( brig\n        . path \"clients\"\n        . zUser uid\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just cs) === responseJsonMaybe\n\ntestListClientsBulk :: Opt.Opts -> Brig -> Http ()\ntestListClientsBulk opts brig = do\n  uid1 <- userId <$> randomUser brig\n  let (pk11, lk11) = (somePrekeys !! 0, (someLastPrekeys !! 0))\n  let (pk12, lk12) = (somePrekeys !! 1, (someLastPrekeys !! 1))\n  let (pk13, lk13) = (somePrekeys !! 2, (someLastPrekeys !! 2))\n  c11 <- responseJsonError =<< addClient brig uid1 (defNewClient PermanentClientType [pk11] lk11)\n  c12 <- responseJsonError =<< addClient brig uid1 (defNewClient PermanentClientType [pk12] lk12)\n  c13 <- responseJsonError =<< addClient brig uid1 (defNewClient TemporaryClientType [pk13] lk13)\n\n  uid2 <- userId <$> randomUser brig\n  let (pk21, lk21) = (somePrekeys !! 3, (someLastPrekeys !! 3))\n  let (pk22, lk22) = (somePrekeys !! 4, (someLastPrekeys !! 4))\n  c21 <- responseJsonError =<< addClient brig uid2 (defNewClient PermanentClientType [pk21] lk21)\n  c22 <- responseJsonError =<< addClient brig uid2 (defNewClient PermanentClientType [pk22] lk22)\n\n  let domain = Opt.setFederationDomain $ Opt.optSettings opts\n  uid3 <- userId <$> randomUser brig\n  let expectedResponse :: QualifiedUserMap (Set Client) =\n        QualifiedUserMap $\n          Map.singleton\n            domain\n            ( UserMap $\n                Map.fromList [(uid1, Set.fromList [c11, c12, c13]), (uid2, Set.fromList [c21, c22])]\n            )\n  post\n    ( brig\n        . paths [\"users\", \"list-clients\"]\n        . zUser uid3\n        . contentJson\n        . body (RequestBodyLBS $ encode [Qualified uid1 domain, Qualified uid2 domain])\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just expectedResponse) === responseJsonMaybe\n\ntestListPrekeyIds :: Brig -> Http ()\ntestListPrekeyIds brig = do\n  uid <- userId <$> randomUser brig\n  let new = defNewClient PermanentClientType [somePrekeys !! 0] (someLastPrekeys !! 0)\n  c <- responseJsonError =<< addClient brig uid new\n  let pks = [PrekeyId 1, lastPrekeyId]\n  get\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c), \"prekeys\"]\n        . zUser uid\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just pks) === fmap sort . responseJsonMaybe\n\ngenerateClients :: Int -> Brig -> Http [(UserId, Client, ClientPrekey, ClientPrekey)]\ngenerateClients n brig = do\n  for [1 .. n] $ \\i -> do\n    uid <- userId <$> randomUser brig\n    let new = defNewClient TemporaryClientType [somePrekeys !! i] (someLastPrekeys !! i)\n    c <- responseJsonError =<< addClient brig uid new\n    let cpk = ClientPrekey (clientId c) (somePrekeys !! i)\n    let lpk = ClientPrekey (clientId c) (unpackLastPrekey (someLastPrekeys !! i))\n    pure (uid, c, lpk, cpk)\n\ntestGetUserPrekeys :: Brig -> Http ()\ntestGetUserPrekeys brig = do\n  [(uid, _c, lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\"]) !!! do\n    const 200 === statusCode\n    const (Just $ PrekeyBundle uid [cpk]) === responseJsonMaybe\n  -- prekeys are deleted when retrieved, except the last one\n  replicateM_ 2 $\n    get (brig . paths [\"users\", toByteString' uid, \"prekeys\"]) !!! do\n      const 200 === statusCode\n      const (Just $ PrekeyBundle uid [lpk]) === responseJsonMaybe\n\ntestGetUserPrekeysQualified :: Brig -> Opt.Opts -> Http ()\ntestGetUserPrekeysQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n  [(uid, _c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' domain, toByteString' uid, \"prekeys\"]) !!! do\n    const 200 === statusCode\n    const (Just $ PrekeyBundle uid [cpk]) === responseJsonMaybe\n\ntestGetClientPrekey :: Brig -> Http ()\ntestGetClientPrekey brig = do\n  [(uid, c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ cpk) === responseJsonMaybe\n\ntestGetClientPrekeyQualified :: Brig -> Opt.Opts -> Http ()\ntestGetClientPrekeyQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n  [(uid, c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' domain, toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ cpk) === responseJsonMaybe\n\ntestMultiUserGetPrekeys :: Brig -> Http ()\ntestMultiUserGetPrekeys brig = do\n  xs <- generateClients 3 brig\n  let userClients =\n        UserClients $\n          Map.fromList $\n            xs <&> \\(uid, c, _lpk, _cpk) ->\n              (uid, Set.fromList [clientId c])\n\n  let expectedUserClientMap =\n        UserClientMap $\n          Map.fromList $\n            xs <&> \\(uid, c, _lpk, cpk) ->\n              (uid, Map.singleton (clientId c) (Just (prekeyData cpk)))\n\n  post\n    ( brig\n        . paths [\"users\", \"prekeys\"]\n        . contentJson\n        . body (RequestBodyLBS $ encode userClients)\n    )\n    !!! do\n      const 200 === statusCode\n      const (Right $ expectedUserClientMap) === responseJsonEither\n\ntestMultiUserGetPrekeysQualified :: Brig -> Opt.Opts -> Http ()\ntestMultiUserGetPrekeysQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n\n  xs <- generateClients 3 brig\n  let userClients =\n        QualifiedUserClients $\n          Map.singleton domain $\n            UserClients $\n              Map.fromList $\n                xs <&> \\(uid, c, _lpk, _cpk) ->\n                  (uid, Set.fromList [clientId c])\n\n  let expectedUserClientMap =\n        QualifiedUserClientMap $\n          Map.singleton domain $\n            UserClientMap $\n              Map.fromList $\n                xs <&> \\(uid, c, _lpk, cpk) ->\n                  (uid, Map.singleton (clientId c) (Just (prekeyData cpk)))\n\n  post\n    ( brig\n        . paths [\"users\", \"list-prekeys\"]\n        . contentJson\n        . body (RequestBodyLBS $ encode userClients)\n    )\n    !!! do\n      const 200 === statusCode\n      const (Right $ expectedUserClientMap) === responseJsonEither\n\ntestTooManyClients :: Opt.Opts -> Brig -> Http ()\ntestTooManyClients opts brig = do\n  uid <- userId <$> randomUser brig\n  -- We can always change the permanent client limit\n  let newOpts = opts & Opt.optionSettings . Opt.userMaxPermClients .~ Just 1\n  withSettingsOverrides newOpts $ do\n    -- There is only one temporary client, adding a new one\n    -- replaces the previous one.\n    forM_ [0 .. (3 :: Int)] $ \\i ->\n      let pk = somePrekeys !! i\n          lk = someLastPrekeys !! i\n       in addClient brig uid (defNewClient TemporaryClientType [pk] lk) !!! const 201 === statusCode\n    -- We can't add more permanent clients than configured\n    addClient brig uid (defNewClient PermanentClientType [somePrekeys !! 10] (someLastPrekeys !! 10)) !!! do\n      const 201 === statusCode\n    addClient brig uid (defNewClient PermanentClientType [somePrekeys !! 11] (someLastPrekeys !! 11)) !!! do\n      const 403 === statusCode\n      const (Just \"too-many-clients\") === fmap Error.label . responseJsonMaybe\n\ntestRemoveClient :: Bool -> Brig -> Cannon -> Http ()\ntestRemoveClient hasPwd brig cannon = do\n  u <- randomUser' hasPwd brig\n  let uid = userId u\n  let Just email = userEmail u\n  -- Permanent client with attached cookie\n  when hasPwd $ do\n    login brig (defEmailLogin email) PersistentCookie\n      !!! const 200 === statusCode\n    numCookies <- countCookies brig uid defCookieLabel\n    liftIO $ Just 1 @=? numCookies\n  c <- responseJsonError =<< addClient brig uid (client PermanentClientType (someLastPrekeys !! 10))\n  when hasPwd $ do\n    -- Missing password\n    deleteClient brig uid (clientId c) Nothing !!! const 403 === statusCode\n  -- Success\n  WS.bracketR cannon uid $ \\ws -> do\n    deleteClient brig uid (clientId c) (if hasPwd then Just defPassword else Nothing)\n      !!! const 200 === statusCode\n    void . liftIO . WS.assertMatch (5 # Second) ws $ \\n -> do\n      let j = Object $ List1.head (ntfPayload n)\n      let etype = j ^? key \"type\" . _String\n      let eclient = j ^? key \"client\" . key \"id\" . _String\n      etype @?= Just \"user.client-remove\"\n      fmap ClientId eclient @?= Just (clientId c)\n  -- Not found on retry\n  deleteClient brig uid (clientId c) Nothing !!! const 404 === statusCode\n  -- Prekeys are gone\n  getPreKey brig uid (clientId c) !!! const 404 === statusCode\n  -- Cookies are gone\n  numCookies' <- countCookies brig (userId u) defCookieLabel\n  liftIO $ Just 0 @=? numCookies'\n  where\n    client ty lk =\n      (defNewClient ty [somePrekeys !! 0] lk)\n        { newClientLabel = Just \"Nexus 5x\",\n          newClientCookie = Just defCookieLabel\n        }\n\ntestUpdateClient :: Brig -> Http ()\ntestUpdateClient brig = do\n  uid <- userId <$> randomUser brig\n  let clt =\n        (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone\"\n          }\n  c <- responseJsonError =<< addClient brig uid clt\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ ClientPrekey (clientId c) (somePrekeys !! 0)) === responseJsonMaybe\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"Test Device\") === (clientLabel <=< responseJsonMaybe)\n    const (Just PhoneClient) === (clientClass <=< responseJsonMaybe)\n    const (Just \"featurephone\") === (clientModel <=< responseJsonMaybe)\n  let newPrekey = somePrekeys !! 2\n  let update = UpdateClient [newPrekey] Nothing (Just \"label\")\n  put\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c)]\n        . zUser uid\n        . contentJson\n        . body (RequestBodyLBS $ encode update)\n    )\n    !!! const 200\n    === statusCode\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ ClientPrekey (clientId c) newPrekey) === responseJsonMaybe\n  -- check if label has been updated\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"label\") === (clientLabel <=< responseJsonMaybe)\n  -- via `/users/:uid/clients/:client`, only `id` and `class` are visible:\n  get (brig . paths [\"users\", toByteString' uid, \"clients\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ clientId c) === (fmap pubClientId . responseJsonMaybe)\n    const (Just PhoneClient) === (pubClientClass <=< responseJsonMaybe)\n    const Nothing === (preview (key \"label\") <=< responseJsonMaybe @Value)\n  let update' = UpdateClient [] Nothing Nothing\n  -- empty update should be a no-op\n  put\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c)]\n        . zUser uid\n        . contentJson\n        . body (RequestBodyLBS $ encode update')\n    )\n    !!! const 200\n    === statusCode\n  -- check if label is still present\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"label\") === (clientLabel <=< responseJsonMaybe)\n\n-- Legacy (galley)\ntestAddMultipleTemporary :: Brig -> Galley -> Http ()\ntestAddMultipleTemporary brig galley = do\n  uid <- userId <$> randomUser brig\n  let clt1 =\n        (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone1\"\n          }\n  _ <- addClient brig uid clt1\n  brigClients1 <- numOfBrigClients uid\n  galleyClients1 <- numOfGalleyClients uid\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) brigClients1\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) galleyClients1\n  let clt2 =\n        (defNewClient TemporaryClientType [somePrekeys !! 1] (someLastPrekeys !! 1))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone2\"\n          }\n  _ <- addClient brig uid clt2\n  brigClients2 <- numOfBrigClients uid\n  galleyClients2 <- numOfGalleyClients uid\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) brigClients2\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) galleyClients2\n  where\n    numOfBrigClients u = do\n      r <-\n        get $\n          brig\n            . path \"clients\"\n            . zUser u\n      return $ Vec.length <$> (preview _Array =<< responseJsonMaybe @Value r)\n    numOfGalleyClients u = do\n      r <-\n        get $\n          galley\n            . path \"i/test/clients\"\n            . zUser u\n      return $ Vec.length <$> (preview _Array =<< responseJsonMaybe @Value r)\n\ntestPreKeyRace :: Brig -> Http ()\ntestPreKeyRace brig = do\n  uid <- userId <$> randomUser brig\n  let pks = map (\\i -> somePrekeys !! i) [1 .. 10]\n  c <- responseJsonError =<< addClient brig uid (defNewClient PermanentClientType pks (someLastPrekeys !! 0))\n  pks' <- flip mapConcurrently pks $ \\_ -> do\n    rs <- getPreKey brig uid (clientId c) <!! const 200 === statusCode\n    return $ prekeyId . prekeyData <$> responseJsonMaybe rs\n  -- We should not hand out regular prekeys more than once (i.e. at most once).\n  let actual = catMaybes pks'\n  liftIO $ assertEqual \"insufficient prekeys\" (length pks) (length actual)\n  let regular = filter (/= lastPrekeyId) actual\n  liftIO $ assertEqual \"duplicate prekeys\" (length regular) (length (nub regular))\n  deleteClient brig uid (clientId c) (Just defPassword) !!! const 200 === statusCode\n\ntestCan'tDeleteLegalHoldClient :: Brig -> Http ()\ntestCan'tDeleteLegalHoldClient brig = do\n  let hasPassword = False\n  user <- randomUser' hasPassword brig\n  let uid = userId user\n  let pk = head somePrekeys\n  let lk = head someLastPrekeys\n  resp <-\n    addClientInternal brig uid (defNewClient LegalHoldClientType [pk] lk)\n      <!! const 201 === statusCode\n  lhClientId <- clientId <$> responseJsonError resp\n  deleteClient brig uid lhClientId Nothing !!! const 400 === statusCode\n\ntestCan'tAddLegalHoldClient :: Brig -> Http ()\ntestCan'tAddLegalHoldClient brig = do\n  let hasPassword = False\n  user <- randomUser' hasPassword brig\n  let uid = userId user\n  let pk = head somePrekeys\n  let lk = head someLastPrekeys\n  -- Regular users cannot add legalhold clients\n  addClient brig uid (defNewClient LegalHoldClientType [pk] lk) !!! const 400 === statusCode\n"], "fixing_code": ["{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE StrictData #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Wire.API.User.Client\n  ( -- * UserClients\n    UserClientMap (..),\n    QualifiedUserClientMap (..),\n    UserClients (..),\n    QualifiedUserClients (..),\n    filterClients,\n\n    -- * Client\n    Client (..),\n    PubClient (..),\n    ClientType (..),\n    ClientClass (..),\n\n    -- * New/Update/Remove Client\n    NewClient (..),\n    newClient,\n    UpdateClient (..),\n    RmClient (..),\n\n    -- * re-exports\n    Location,\n    location,\n    latitude,\n    longitude,\n    Latitude (..),\n    Longitude (..),\n\n    -- * Swagger\n    modelOtrClientMap,\n    modelUserClients,\n    modelNewClient,\n    modelUpdateClient,\n    modelDeleteClient,\n    modelClient,\n    modelSigkeys,\n    modelLocation, -- re-export from types-common\n    modelPubClient,\n  )\nwhere\n\nimport Control.Lens ((?~), (^.))\nimport Data.Aeson\nimport Data.Domain (Domain)\nimport qualified Data.HashMap.Strict as HashMap\nimport Data.Id\nimport Data.Json.Util\nimport qualified Data.Map.Strict as Map\nimport Data.Misc (Latitude (..), Location, Longitude (..), PlainTextPassword (..), latitude, location, longitude, modelLocation)\nimport Data.Proxy (Proxy (..))\nimport Data.Swagger (HasExample (example), NamedSchema (..), ToSchema (..), declareSchema)\nimport qualified Data.Swagger as Swagger\nimport qualified Data.Swagger.Build.Api as Doc\nimport Data.Swagger.Schema (toSchema)\nimport qualified Data.Text as Text\nimport qualified Data.Text.Encoding as Text.E\nimport Data.Typeable (typeRep)\nimport Data.UUID (toASCIIBytes)\nimport Deriving.Swagger (CamelToSnake, ConstructorTagModifier, CustomSwagger, FieldLabelModifier, LabelMapping ((:->)), LabelMappings, LowerCase, StripPrefix, StripSuffix)\nimport Imports\nimport Wire.API.Arbitrary (Arbitrary (arbitrary), GenericUniform (..), generateExample, mapOf', setOf')\nimport Wire.API.User.Auth (CookieLabel)\nimport Wire.API.User.Client.Prekey as Prekey\n\n--------------------------------------------------------------------------------\n-- UserClientMap\n\nnewtype UserClientMap a = UserClientMap\n  { userClientMap :: Map UserId (Map ClientId a)\n  }\n  deriving stock (Eq, Show, Functor, Foldable, Traversable)\n  deriving newtype (Semigroup, Monoid)\n\n-- FUTUREWORK: Remove when 'NewOtrMessage' has ToSchema\nmodelOtrClientMap :: Doc.Model\nmodelOtrClientMap = Doc.defineModel \"OtrClientMap\" $ do\n  Doc.description \"Map of client IDs to OTR content.\"\n  Doc.property \"\" Doc.bytes' $\n    Doc.description \"Mapping from client IDs to OTR content (Base64 in JSON).\"\n\ninstance ToJSON a => ToJSON (UserClientMap a) where\n  toJSON = toJSON . Map.foldrWithKey' f Map.empty . userClientMap\n    where\n      f (Id u) clients m =\n        let key = Text.E.decodeLatin1 (toASCIIBytes u)\n            val = Map.foldrWithKey' g Map.empty clients\n         in Map.insert key val m\n      g (ClientId c) a = Map.insert c (toJSON a)\n\ninstance FromJSON a => FromJSON (UserClientMap a) where\n  parseJSON = withObject \"user-client-map\" $ \\o ->\n    UserClientMap <$> foldrM f Map.empty (HashMap.toList o)\n    where\n      f (k, v) m = do\n        u <- parseJSON (String k)\n        flip (withObject \"client-value-map\") v $ \\c -> do\n          e <- foldrM g Map.empty (HashMap.toList c)\n          return (Map.insert u e m)\n      g (k, v) m = do\n        c <- parseJSON (String k)\n        t <- parseJSON v\n        return (Map.insert c t m)\n\ninstance Arbitrary a => Arbitrary (UserClientMap a) where\n  arbitrary = UserClientMap <$> mapOf' arbitrary (mapOf' arbitrary arbitrary)\n\ninstance ToSchema (UserClientMap (Maybe Prekey)) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Map ClientId (Maybe Prekey))))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @(Maybe Prekey)\n    return $\n      NamedSchema (Just $ \"UserClientMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & example\n            ?~ toJSON\n              ( Map.singleton\n                  (generateExample @UserId)\n                  ( Map.singleton\n                      (newClientId 4940483633899001999)\n                      (Just (Prekey (PrekeyId 1) \"pQABAQECoQBYIOjl7hw0D8YRNq...\"))\n                  )\n              )\n\nnewtype QualifiedUserClientMap a = QualifiedUserClientMap\n  { qualifiedUserClientMap :: Map Domain (UserClientMap a)\n  }\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON)\n\ninstance Arbitrary a => Arbitrary (QualifiedUserClientMap a) where\n  arbitrary = QualifiedUserClientMap <$> mapOf' arbitrary arbitrary\n\ninstance (Typeable a, ToSchema (UserClientMap a)) => ToSchema (QualifiedUserClientMap a) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map Domain (UserClientMap a)))\n    let userMapSchema = toSchema (Proxy @(UserClientMap a))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @a\n    return $\n      NamedSchema (Just $ \"QualifiedUserClientMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & Swagger.description ?~ \"Map of Domain to (UserMap (\" <> valueTypeName <> \")).\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userMapSchema ^. example))\n\n--------------------------------------------------------------------------------\n-- UserClients\n\n-- TODO: check if example generated by swagger look okay (probably not)\nnewtype UserClients = UserClients\n  { userClients :: Map UserId (Set ClientId)\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Semigroup, Monoid)\n\ninstance ToSchema UserClients where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Set ClientId)))\n    return $\n      NamedSchema (Just \"UserClients\") $\n        mapSch\n          & Swagger.description ?~ \"Map of user id to list of client ids.\"\n          & example\n            ?~ toJSON\n              ( Map.fromList\n                  [ (generateExample @UserId, [newClientId 1684636986166846496, newClientId 4940483633899001999]),\n                    (generateExample @UserId, [newClientId 6987438498444556166, newClientId 7940473633839002939])\n                  ]\n              )\n\n-- FUTUREWORK: Remove when 'NewOtrMessage' has ToSchema\nmodelUserClients :: Doc.Model\nmodelUserClients =\n  Doc.defineModel \"UserClients\" $\n    Doc.property \"\" (Doc.unique $ Doc.array Doc.bytes') $\n      Doc.description \"Map of user IDs to sets of client IDs ({ UserId: [ClientId] }).\"\n\ninstance ToJSON UserClients where\n  toJSON =\n    toJSON . Map.foldrWithKey' fn Map.empty . userClients\n    where\n      fn u c m =\n        let k = Text.E.decodeLatin1 (toASCIIBytes (toUUID u))\n         in Map.insert k c m\n\ninstance FromJSON UserClients where\n  parseJSON =\n    withObject \"UserClients\" (fmap UserClients . foldrM fn Map.empty . HashMap.toList)\n    where\n      fn (k, v) m = Map.insert <$> parseJSON (String k) <*> parseJSON v <*> pure m\n\ninstance Arbitrary UserClients where\n  arbitrary = UserClients <$> mapOf' arbitrary (setOf' arbitrary)\n\nfilterClients :: (Set ClientId -> Bool) -> UserClients -> UserClients\nfilterClients p (UserClients c) = UserClients $ Map.filter p c\n\nnewtype QualifiedUserClients = QualifiedUserClients\n  { qualifiedUserClients :: Map Domain UserClients\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Semigroup, Monoid, FromJSON, ToJSON)\n\ninstance Arbitrary QualifiedUserClients where\n  arbitrary = QualifiedUserClients <$> mapOf' arbitrary arbitrary\n\ninstance ToSchema QualifiedUserClients where\n  declareNamedSchema _ = do\n    schema <- declareSchema (Proxy @(Map Domain UserClients))\n    userClientsSchema <- declareSchema (Proxy @UserClients)\n    return $\n      NamedSchema (Just \"QualifiedUserClients\") $\n        schema\n          & Swagger.description ?~ \"Map of Domain to UserClients\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userClientsSchema ^. example))\n\n--------------------------------------------------------------------------------\n-- Client\n\ndata Client = Client\n  { clientId :: ClientId,\n    clientType :: ClientType,\n    clientTime :: UTCTimeMillis,\n    clientClass :: Maybe ClientClass,\n    clientLabel :: Maybe Text,\n    clientCookie :: Maybe CookieLabel,\n    clientLocation :: Maybe Location,\n    clientModel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic, Ord)\n  deriving (Arbitrary) via (GenericUniform Client)\n  deriving (ToSchema) via (CustomSwagger '[FieldLabelModifier (StripPrefix \"client\", LowerCase)] Client)\n\nmodelClient :: Doc.Model\nmodelClient = Doc.defineModel \"Client\" $ do\n  Doc.description \"A registered client.\"\n  Doc.property \"type\" typeClientType $\n    Doc.description \"The client type.\"\n  Doc.property \"id\" Doc.string' $\n    Doc.description \"The client ID.\"\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"An optional label associated with the client.\"\n    Doc.optional\n  Doc.property \"time\" Doc.dateTime' $\n    Doc.description \"The date and time when this client was registered.\"\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to.\"\n  Doc.property \"cookie\" Doc.string' $\n    Doc.description \"The cookie label of this client.\"\n  Doc.property \"address\" Doc.string' $ do\n    Doc.description \"IP address from which this client has been registered\"\n    Doc.optional\n  Doc.property \"location\" (Doc.ref modelLocation) $ do\n    Doc.description \"Location from which this client has been registered.\"\n    Doc.optional\n  Doc.property \"model\" Doc.string' $ do\n    Doc.description \"Optional model information of this client\"\n    Doc.optional\n\ninstance ToJSON Client where\n  toJSON c =\n    object $\n      \"id\" .= clientId c\n        # \"type\" .= clientType c\n        # \"label\" .= clientLabel c\n        # \"class\" .= clientClass c\n        # \"time\" .= clientTime c\n        # \"cookie\" .= clientCookie c\n        # \"location\" .= clientLocation c\n        # \"model\" .= clientModel c\n        # []\n\ninstance FromJSON Client where\n  parseJSON = withObject \"Client\" $ \\o ->\n    Client\n      <$> o .: \"id\"\n      <*> o .: \"type\"\n      <*> o .: \"time\"\n      <*> o .:? \"class\"\n      <*> o .:? \"label\"\n      <*> o .:? \"cookie\"\n      <*> o .:? \"location\"\n      <*> o .:? \"model\"\n\n--------------------------------------------------------------------------------\n-- PubClient\n\ndata PubClient = PubClient\n  { pubClientId :: ClientId,\n    pubClientClass :: Maybe ClientClass\n  }\n  deriving stock (Eq, Show, Generic, Ord)\n  deriving (Arbitrary) via (GenericUniform PubClient)\n  deriving (ToSchema) via (CustomSwagger '[FieldLabelModifier (StripPrefix \"pubClient\", LowerCase)] PubClient)\n\nmodelPubClient :: Doc.Model\nmodelPubClient = Doc.defineModel \"PubClient\" $ do\n  Doc.description \"A client as seen by other users.\"\n  Doc.property \"id\" Doc.string' $\n    Doc.description \"The client ID.\"\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to. Either 'phone', 'tablet', or 'desktop'.\"\n\ninstance ToJSON PubClient where\n  toJSON c =\n    object $\n      \"id\" .= pubClientId c\n        # \"class\" .= pubClientClass c\n        # []\n\ninstance FromJSON PubClient where\n  parseJSON = withObject \"PubClient\" $ \\o ->\n    PubClient\n      <$> o .: \"id\"\n      <*> o .:? \"class\"\n\n--------------------------------------------------------------------------------\n-- Client Type/Class\n\n-- [Note: LegalHold]\n--\n-- Short feature description:\n-- LegalHold is an enterprise feature, enabled on a per-team basis, and within a\n-- team on a per-user basis\n\n-- * A LegalHoldClient is a client outside that user's control (but under the\n\n--   control of that team's business)\n\n-- * Users need to click \"accept\" before a LegalHoldClient is added to their\n\n--   account.\n\n-- * Any user interacting with a user which has a LegalHoldClient will upon\n\n--   first interaction receive a warning, have the option of cancelling the\n--   interaction, and on an ongoing basis see a visual indication in all\n--   conversations where such a device is active.\n\n-- | Strategy to translate enums in this module to schema.\ntype EnumToSchemaStrategy suffix ty =\n  ( CustomSwagger\n      '[ ConstructorTagModifier\n           ( StripSuffix suffix,\n             CamelToSnake,\n             LabelMappings '[\"legal_hold\" ':-> \"legalhold\"]\n           )\n       ]\n      ty\n  )\n\ndata ClientType\n  = TemporaryClientType\n  | PermanentClientType\n  | LegalHoldClientType -- see Note [LegalHold]\n  deriving stock (Eq, Ord, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform ClientType)\n  deriving (ToSchema) via EnumToSchemaStrategy \"ClientType\" ClientType\n\ntypeClientType :: Doc.DataType\ntypeClientType =\n  Doc.string $\n    Doc.enum\n      [ \"permanent\",\n        \"temporary\",\n        \"legalhold\"\n      ]\n\ninstance ToJSON ClientType where\n  toJSON TemporaryClientType = String \"temporary\"\n  toJSON PermanentClientType = String \"permanent\"\n  toJSON LegalHoldClientType = String \"legalhold\"\n\ninstance FromJSON ClientType where\n  parseJSON = withText \"ClientType\" $ \\txt -> case txt of\n    \"temporary\" -> return TemporaryClientType\n    \"permanent\" -> return PermanentClientType\n    \"legalhold\" -> return LegalHoldClientType\n    _ -> fail \"Must be one of {'temporary', 'permanent', 'legalhold'}.\"\n\ndata ClientClass\n  = PhoneClient\n  | TabletClient\n  | DesktopClient\n  | LegalHoldClient -- see Note [LegalHold]\n  deriving stock (Eq, Ord, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform ClientClass)\n  deriving (ToSchema) via EnumToSchemaStrategy \"Client\" ClientClass\n\ntypeClientClass :: Doc.DataType\ntypeClientClass =\n  Doc.string $\n    Doc.enum\n      [ \"phone\",\n        \"tablet\",\n        \"desktop\",\n        \"legalhold\"\n      ]\n\ninstance ToJSON ClientClass where\n  toJSON PhoneClient = String \"phone\"\n  toJSON TabletClient = String \"tablet\"\n  toJSON DesktopClient = String \"desktop\"\n  toJSON LegalHoldClient = String \"legalhold\"\n\ninstance FromJSON ClientClass where\n  parseJSON = withText \"ClientClass\" $ \\txt -> case txt of\n    \"phone\" -> return PhoneClient\n    \"tablet\" -> return TabletClient\n    \"desktop\" -> return DesktopClient\n    \"legalhold\" -> return LegalHoldClient\n    _ -> fail \"Must be one of {'phone', 'tablet', 'desktop', 'legalhold'}.\"\n\n--------------------------------------------------------------------------------\n-- NewClient\n\ndata NewClient = NewClient\n  { newClientPrekeys :: [Prekey],\n    newClientLastKey :: LastPrekey,\n    newClientType :: ClientType,\n    newClientLabel :: Maybe Text,\n    newClientClass :: Maybe ClientClass,\n    newClientCookie :: Maybe CookieLabel,\n    newClientPassword :: Maybe PlainTextPassword,\n    newClientModel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform NewClient)\n\nmodelNewClient :: Doc.Model\nmodelNewClient = Doc.defineModel \"NewClient\" $ do\n  Doc.description \"The registration data for a new client.\"\n  Doc.property \"type\" typeClientType $\n    Doc.description\n      \"The type of client to register. A user may have no more than \\\n      \\7 (seven) permanent clients and 1 (one) temporary client. When the \\\n      \\limit of permanent clients is reached, an error is returned. \\\n      \\When a temporary client already exists, it is replaced.\"\n  Doc.property \"password\" Doc.string' $ do\n    Doc.description\n      \"The password of the authenticated user for verification. \\\n      \\Note: Required for registration of the 2nd, 3rd, ... client.\"\n    Doc.optional\n  Doc.property \"prekeys\" (Doc.array (Doc.ref modelPrekey)) $\n    Doc.description \"Prekeys for other clients to establish OTR sessions.\"\n  Doc.property \"lastkey\" (Doc.ref modelPrekey) $\n    Doc.description\n      \"The last resort prekey for other clients to establish OTR sessions. \\\n      \\This key must have the ID 0xFFFF and is never deleted.\"\n  -- FUTUREWORK: sigkeys don't seem to be used anymore\n  Doc.property \"sigkeys\" (Doc.ref modelSigkeys) $\n    Doc.description\n      \"The signaling keys to use for encryption and signing of OTR native push \\\n      \\notifications (APNS, GCM).\"\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"An optional label to associate with the client.\"\n    Doc.optional\n  Doc.property \"class\" typeClientClass $\n    Doc.description \"The device class this client belongs to. Either 'phone', 'tablet', or 'desktop'.\"\n  Doc.property \"cookie\" Doc.string' $\n    Doc.description \"The cookie label, i.e. the label used when logging in.\"\n  Doc.property \"model\" Doc.string' $ do\n    Doc.description \"Optional model information of this client\"\n    Doc.optional\n\nnewClient :: ClientType -> LastPrekey -> NewClient\nnewClient t k =\n  NewClient\n    { newClientPrekeys = [],\n      newClientLastKey = k,\n      newClientType = t,\n      newClientLabel = Nothing,\n      newClientClass = if t == LegalHoldClientType then Just LegalHoldClient else Nothing,\n      newClientCookie = Nothing,\n      newClientPassword = Nothing,\n      newClientModel = Nothing\n    }\n\ninstance ToJSON NewClient where\n  toJSON c =\n    object $\n      \"type\" .= newClientType c\n        # \"prekeys\" .= newClientPrekeys c\n        # \"lastkey\" .= newClientLastKey c\n        # \"label\" .= newClientLabel c\n        # \"class\" .= newClientClass c\n        # \"cookie\" .= newClientCookie c\n        # \"password\" .= newClientPassword c\n        # \"model\" .= newClientModel c\n        # []\n\ninstance FromJSON NewClient where\n  parseJSON = withObject \"NewClient\" $ \\o ->\n    NewClient\n      <$> o .: \"prekeys\"\n      <*> o .: \"lastkey\"\n      <*> o .: \"type\"\n      <*> o .:? \"label\"\n      <*> o .:? \"class\"\n      <*> o .:? \"cookie\"\n      <*> o .:? \"password\"\n      <*> o .:? \"model\"\n\n--------------------------------------------------------------------------------\n-- UpdateClient\n\ndata UpdateClient = UpdateClient\n  { updateClientPrekeys :: [Prekey],\n    updateClientLastKey :: Maybe LastPrekey,\n    updateClientLabel :: Maybe Text\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving (Arbitrary) via (GenericUniform UpdateClient)\n\nmodelUpdateClient :: Doc.Model\nmodelUpdateClient = Doc.defineModel \"UpdateClient\" $ do\n  Doc.description \"The new data for the registered client.\"\n  Doc.property \"prekeys\" (Doc.array (Doc.ref modelPrekey)) $ do\n    Doc.description \"New prekeys for other clients to establish OTR sessions.\"\n    Doc.optional\n  Doc.property \"lastkey\" (Doc.ref modelPrekey) $ do\n    Doc.description \"New last-resort prekey.\"\n    Doc.optional\n  -- FUTUREWORK: sigkeys don't seem to be used anymore, remove?\n  Doc.property \"sigkeys\" (Doc.ref modelSigkeys) $ do\n    Doc.description\n      \"New signaling keys to use for encryption and signing of OTR native push \\\n      \\notifications (APNS, GCM).\"\n    Doc.optional\n  Doc.property \"label\" Doc.string' $ do\n    Doc.description \"A new name for this client.\"\n    Doc.optional\n\ninstance ToJSON UpdateClient where\n  toJSON c =\n    object $\n      \"prekeys\" .= updateClientPrekeys c\n        # \"lastkey\" .= updateClientLastKey c\n        # \"label\" .= updateClientLabel c\n        # []\n\ninstance FromJSON UpdateClient where\n  parseJSON = withObject \"RefreshClient\" $ \\o ->\n    UpdateClient\n      <$> o .:? \"prekeys\" .!= []\n      <*> o .:? \"lastkey\"\n      <*> o .:? \"label\"\n\n--------------------------------------------------------------------------------\n-- RmClient\n\nnewtype RmClient = RmClient\n  { rmPassword :: Maybe PlainTextPassword\n  }\n  deriving stock (Eq, Show, Generic)\n  deriving newtype (Arbitrary)\n\nmodelDeleteClient :: Doc.Model\nmodelDeleteClient = Doc.defineModel \"DeleteClient\" $ do\n  Doc.description \"Required information for client deletion.\"\n  Doc.property \"password\" Doc.string' $ do\n    Doc.description\n      \"The password of the authenticated user for verification. \\\n      \\The password is not required for deleting temporary clients.\"\n    Doc.optional\n\ninstance ToJSON RmClient where\n  toJSON (RmClient pw) = object [\"password\" .= pw]\n\ninstance FromJSON RmClient where\n  parseJSON = withObject \"RmClient\" $ \\o ->\n    RmClient <$> o .:? \"password\"\n\n--------------------------------------------------------------------------------\n-- other models\n\nmodelSigkeys :: Doc.Model\nmodelSigkeys = Doc.defineModel \"SignalingKeys\" $ do\n  Doc.description \"Signaling keys for encryption and signing of native push notifications (APNS, GCM).\"\n  Doc.property \"enckey\" Doc.bytes' $\n    Doc.description \"The base64-encoded, 256 bit encryption key.\"\n  Doc.property \"mackey\" Doc.bytes' $\n    Doc.description \"The base64-encoded, 256 bit MAC key.\"\n", "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Wire.API.UserMap where\n\nimport Control.Lens ((?~), (^.))\nimport Data.Aeson (FromJSON, ToJSON (toJSON))\nimport Data.Domain (Domain)\nimport Data.Id (UserId)\nimport qualified Data.Map as Map\nimport Data.Proxy (Proxy (..))\nimport qualified Data.Set as Set\nimport Data.Swagger (HasDescription (description), HasExample (example), NamedSchema (..), ToSchema (..), declareSchema, toSchema)\nimport qualified Data.Text as Text\nimport Data.Typeable (typeRep)\nimport Imports\nimport Test.QuickCheck (Arbitrary (..))\nimport Wire.API.Arbitrary (generateExample, mapOf')\n\nnewtype UserMap a = UserMap {userMap :: Map UserId a}\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON, Functor)\n\ninstance Arbitrary a => Arbitrary (UserMap a) where\n  arbitrary = UserMap <$> mapOf' arbitrary arbitrary\n\nnewtype QualifiedUserMap a = QualifiedUserMap\n  { qualifiedUserMap :: Map Domain (UserMap a)\n  }\n  deriving stock (Eq, Show)\n  deriving newtype (Semigroup, Monoid, ToJSON, FromJSON)\n\ninstance Functor QualifiedUserMap where\n  fmap f (QualifiedUserMap qMap) =\n    QualifiedUserMap $ f <$$> qMap\n\ninstance Arbitrary a => Arbitrary (QualifiedUserMap a) where\n  arbitrary = QualifiedUserMap <$> mapOf' arbitrary arbitrary\n\ninstance (Typeable a, ToSchema a, ToJSON a, Arbitrary a) => ToSchema (UserMap (Set a)) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map UserId (Set a)))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @a\n    return $\n      NamedSchema (Just $ \"UserMap (Set \" <> valueTypeName <> \")\") $\n        mapSch\n          & description ?~ \"Map of UserId to (Set \" <> valueTypeName <> \")\"\n          & example ?~ toJSON (Map.singleton (generateExample @UserId) (Set.singleton (generateExample @a)))\n\ninstance (Typeable a, ToSchema (UserMap a)) => ToSchema (QualifiedUserMap a) where\n  declareNamedSchema _ = do\n    mapSch <- declareSchema (Proxy @(Map Domain (UserMap a)))\n    let userMapSchema = toSchema (Proxy @(UserMap a))\n    let valueTypeName = Text.pack $ show $ typeRep $ Proxy @a\n    return $\n      NamedSchema (Just $ \"QualifiedUserMap (\" <> valueTypeName <> \")\") $\n        mapSch\n          & description ?~ \"Map of Domain to (UserMap (\" <> valueTypeName <> \")).\"\n          & example\n            ?~ toJSON\n              (Map.singleton (\"domain1.example.com\" :: Text) (userMapSchema ^. example))\n", "-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Test.Wire.API.Swagger (tests) where\n\nimport Data.Aeson (ToJSON)\nimport Data.Swagger (ToSchema, validatePrettyToJSON)\nimport Imports\nimport qualified Test.Tasty as T\nimport Test.Tasty.QuickCheck (Arbitrary, counterexample, testProperty)\nimport Type.Reflection (typeRep)\nimport qualified Wire.API.User as User\nimport qualified Wire.API.User.Client as Client\nimport qualified Wire.API.User.Client.Prekey as Prekey\nimport qualified Wire.API.User.Handle as Handle\nimport qualified Wire.API.UserMap as UserMap\n\ntests :: T.TestTree\ntests =\n  T.localOption (T.Timeout (60 * 1000000) \"60s\") . T.testGroup \"JSON roundtrip tests\" $\n    [ testToJSON @User.UserProfile,\n      testToJSON @User.User,\n      testToJSON @User.SelfProfile,\n      testToJSON @Handle.UserHandleInfo,\n      testToJSON @Client.Client,\n      testToJSON @Client.PubClient,\n      testToJSON @(UserMap.UserMap (Set Client.Client)),\n      testToJSON @(UserMap.UserMap (Set Client.PubClient)),\n      testToJSON @(UserMap.QualifiedUserMap (Set Client.Client)),\n      testToJSON @(Client.UserClientMap (Maybe Prekey.Prekey)),\n      testToJSON @Client.UserClients,\n      testToJSON @Prekey.Prekey,\n      testToJSON @Prekey.PrekeyBundle,\n      testToJSON @Prekey.ClientPrekey,\n      testToJSON @(Client.QualifiedUserClientMap (Maybe Prekey.Prekey)),\n      testToJSON @Client.QualifiedUserClients\n    ]\n\ntestToJSON :: forall a. (Arbitrary a, Typeable a, ToJSON a, ToSchema a, Show a) => T.TestTree\ntestToJSON = testProperty msg trip\n  where\n    msg = show (typeRep @a)\n    trip (v :: a) =\n      counterexample\n        ( fromMaybe \"Schema validation failed, but there were no errors. This looks like a bug in swagger2!\" $\n            validatePrettyToJSON v\n        )\n        $ isNothing (validatePrettyToJSON v)\n", "{-# LANGUAGE DerivingVia #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule Brig.API.Public\n  ( sitemap,\n    apiDocs,\n    servantSitemap,\n    swaggerDocsAPI,\n    ServantAPI,\n    SwaggerDocsAPI,\n  )\nwhere\n\nimport qualified Brig.API.Client as API\nimport qualified Brig.API.Connection as API\nimport Brig.API.Error\nimport Brig.API.Handler\nimport Brig.API.IdMapping (resolveOpaqueUserId)\nimport qualified Brig.API.Properties as API\nimport Brig.API.Types\nimport qualified Brig.API.User as API\nimport Brig.API.Util\nimport qualified Brig.API.Util as API\nimport Brig.App\nimport qualified Brig.Calling.API as Calling\nimport qualified Brig.Data.User as Data\nimport Brig.Federation.Client as Federation\nimport Brig.Options hiding (internalEvents, sesQueue)\nimport qualified Brig.Provider.API as Provider\nimport qualified Brig.Team.API as Team\nimport qualified Brig.Team.Email as Team\nimport Brig.Types.Activation (ActivationPair)\nimport Brig.Types.Intra (AccountStatus (Ephemeral), UserAccount (UserAccount, accountUser))\nimport Brig.Types.User (HavePendingInvitations (..), User (userId))\nimport qualified Brig.User.API.Auth as Auth\nimport qualified Brig.User.API.Search as Search\nimport qualified Brig.User.Auth.Cookie as Auth\nimport Brig.User.Email\nimport Brig.User.Phone\nimport Control.Error hiding (bool)\nimport Control.Lens (view, (.~), (<>~), (?~), (^.))\nimport Control.Monad.Catch (throwM)\nimport Data.Aeson hiding (json)\nimport Data.ByteString.Conversion\nimport qualified Data.ByteString.Lazy as Lazy\nimport Data.CommaSeparatedList (CommaSeparatedList (fromCommaSeparatedList))\nimport Data.Domain\nimport Data.Handle (Handle, parseHandle)\nimport qualified Data.HashMap.Strict.InsOrd as InsOrdHashMap\nimport Data.Id as Id\nimport Data.IdMapping (MappedOrLocalId (Local))\nimport qualified Data.Map.Strict as Map\nimport Data.Misc (IpAddr (..))\nimport Data.Qualified (Qualified (..), partitionRemoteOrLocalIds)\nimport Data.Range\nimport qualified Data.Set as Set\nimport Data.Swagger\n  ( ApiKeyLocation (..),\n    ApiKeyParams (..),\n    HasInfo (info),\n    HasSchema (..),\n    HasSecurity (security),\n    HasSecurityDefinitions (securityDefinitions),\n    HasTitle (title),\n    SecurityRequirement (..),\n    SecurityScheme (..),\n    SecuritySchemeType (SecuritySchemeApiKey),\n    Swagger,\n    ToSchema (..),\n    description,\n  )\nimport qualified Data.Swagger.Build.Api as Doc\nimport qualified Data.Text as Text\nimport qualified Data.Text.Ascii as Ascii\nimport Data.Text.Encoding (decodeLatin1)\nimport Data.Text.Lazy (pack)\nimport qualified Data.ZAuth.Token as ZAuth\nimport Imports hiding (head)\nimport Network.HTTP.Types.Status\nimport Network.Wai (Response, lazyRequestBody)\nimport Network.Wai.Predicate hiding (result, setStatus)\nimport Network.Wai.Routing\nimport Network.Wai.Utilities as Utilities\nimport Network.Wai.Utilities.Swagger (document, mkSwaggerApi)\nimport qualified Network.Wai.Utilities.Swagger as Doc\nimport Network.Wai.Utilities.ZAuth (zauthConnId, zauthUserId)\nimport Servant hiding (Handler, JSON, addHeader, respond)\nimport qualified Servant\nimport Servant.Swagger (HasSwagger (toSwagger))\nimport Servant.Swagger.Internal.Orphans ()\nimport Servant.Swagger.UI\nimport qualified System.Logger.Class as Log\nimport Util.Logging (logFunction, logHandle, logTeam, logUser)\nimport qualified Wire.API.Connection as Public\nimport qualified Wire.API.Properties as Public\nimport qualified Wire.API.Swagger as Public.Swagger (models)\nimport qualified Wire.API.Team as Public\nimport qualified Wire.API.User as Public\nimport qualified Wire.API.User.Activation as Public\nimport qualified Wire.API.User.Auth as Public\nimport qualified Wire.API.User.Client as Public\nimport qualified Wire.API.User.Client.Prekey as Public\nimport qualified Wire.API.User.Handle as Public\nimport qualified Wire.API.User.Password as Public\nimport qualified Wire.API.User.RichInfo as Public\nimport qualified Wire.API.UserMap as Public\n\n---------------------------------------------------------------------------\n-- Sitemap\n\n-- | This type exists for the special 'HasSwagger' and 'HasServer' instances. It\n-- shows the \"Authorization\" header in the swagger docs, but expects the\n-- \"Z-Auth\" header in the server. This helps keep the swagger docs usable\n-- through nginz.\ndata ZAuthServant\n\ntype InternalAuth = Header' '[Servant.Required, Servant.Strict] \"Z-User\" UserId\n\ninstance HasSwagger api => HasSwagger (ZAuthServant :> api) where\n  toSwagger _ =\n    toSwagger (Proxy @api)\n      & securityDefinitions <>~ InsOrdHashMap.singleton \"ZAuth\" secScheme\n      & security <>~ [SecurityRequirement $ InsOrdHashMap.singleton \"ZAuth\" []]\n    where\n      secScheme =\n        SecurityScheme\n          { _securitySchemeType = SecuritySchemeApiKey (ApiKeyParams \"Authorization\" ApiKeyHeader),\n            _securitySchemeDescription = Just \"Must be a token retrieved by calling 'POST /login' or 'POST /access'. It must be presented in this format: 'Bearer \\\\<token\\\\>'.\"\n          }\n\ninstance\n  ( HasContextEntry (ctx .++ DefaultErrorFormatters) ErrorFormatters,\n    HasServer api ctx\n  ) =>\n  HasServer (ZAuthServant :> api) ctx\n  where\n  type ServerT (ZAuthServant :> api) m = ServerT (InternalAuth :> api) m\n\n  route _ = Servant.route (Proxy @(InternalAuth :> api))\n  hoistServerWithContext _ pc nt s =\n    Servant.hoistServerWithContext (Proxy @(InternalAuth :> api)) pc nt s\n\ntype CaptureUserId name = Capture' '[Description \"User Id\"] name UserId\n\ntype CaptureClientId name = Capture' '[Description \"ClientId\"] name ClientId\n\n-- User API -----------------------------------------------------------\n\ndata Empty200 = Empty200\n  deriving (Generic)\n  deriving (HasStatus) via (WithStatus 200 Empty200)\n\ninstance ToSchema Empty200 where\n  declareNamedSchema _ = declareNamedSchema (Proxy @Text)\n\ninstance ToJSON Empty200 where\n  toJSON _ = toJSON (\"\" :: Text)\n\ndata Empty404 = Empty404\n  deriving (Generic)\n  deriving (HasStatus) via (WithStatus 404 Empty404)\n\ninstance ToJSON Empty404 where\n  toJSON _ = toJSON (\"\" :: Text)\n\ninstance ToSchema Empty404 where\n  declareNamedSchema _ =\n    declareNamedSchema (Proxy @Text) <&> (schema . description ?~ \"user not found\")\n\ntype CheckUserExistsResponse = [Empty200, Empty404]\n\n-- Note [document responses]\n--\n-- Ideally we want to document responses with UVerb and swagger, but this is\n-- currently not possible due to this issue:\n-- https://github.com/haskell-servant/servant/issues/1369\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User exists\" Doc.end\n--   Doc.errorResponse userNotFound\ntype CheckUserExistsUnqualified =\n  Summary \"Check if a user ID exists (deprecated)\"\n    :> ZAuthServant\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> UVerb 'HEAD '[Servant.JSON] CheckUserExistsResponse\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User exists\" Doc.end\n--   Doc.errorResponse userNotFound\ntype CheckUserExistsQualified =\n  Summary \"Check if a user ID exists\"\n    :> ZAuthServant\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> UVerb 'HEAD '[Servant.JSON] CheckUserExistsResponse\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User\" Doc.end\n--   Doc.errorResponse userNotFound\ntype GetUserUnqualified =\n  Summary \"Get a user by UserId (deprecated)\"\n    :> ZAuthServant\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> Get '[Servant.JSON] Public.UserProfile\n\n-- See Note [ephemeral user sideeffect]\n--\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.response 200 \"User\" Doc.end\n--   Doc.errorResponse userNotFound\ntype GetUserQualified =\n  Summary \"Get a user by Domain and UserId\"\n    :> ZAuthServant\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> Get '[Servant.JSON] Public.UserProfile\n\ntype GetSelf =\n  Summary \"Get your own profile\"\n    :> ZAuthServant\n    :> \"self\"\n    :> Get '[Servant.JSON] Public.SelfProfile\n\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.returns (Doc.ref Public.modelUserHandleInfo)\n--   Doc.response 200 \"Handle info\" Doc.end\n--   Doc.errorResponse handleNotFound\ntype GetHandleInfoUnqualified =\n  Summary \"Get information on a user handle\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"handles\"\n    :> Capture' '[Description \"The user handle\"] \"handle\" Handle\n    :> Get '[Servant.JSON] Public.UserHandleInfo\n\n-- See Note [document responses]\n-- The responses looked like this:\n--   Doc.returns (Doc.ref Public.modelUserHandleInfo)\n--   Doc.response 200 \"Handle info\" Doc.end\n--   Doc.errorResponse handleNotFound\ntype GetHandleInfoQualified =\n  Summary \"Get information on a user handle\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"handles\"\n    :> Capture \"domain\" Domain\n    :> Capture' '[Description \"The user handle\"] \"handle\" Handle\n    :> Get '[Servant.JSON] Public.UserHandleInfo\n\n-- See Note [ephemeral user sideeffect]\ntype ListUsersByUnqualifiedIdsOrHandles =\n  Summary \"List users (deprecated)\"\n    :> Description \"The 'ids' and 'handles' parameters are mutually exclusive.\"\n    :> ZAuthServant\n    :> \"users\"\n    :> QueryParam' [Optional, Strict, Description \"User IDs of users to fetch\"] \"ids\" (CommaSeparatedList UserId)\n    :> QueryParam' [Optional, Strict, Description \"Handles of users to fetch, min 1 and max 4 (the check for handles is rather expensive)\"] \"handles\" (Range 1 4 (CommaSeparatedList Handle))\n    :> Get '[Servant.JSON] [Public.UserProfile]\n\n-- See Note [ephemeral user sideeffect]\ntype ListUsersByIdsOrHandles =\n  Summary \"List users\"\n    :> Description \"The 'qualified_ids' and 'qualified_handles' parameters are mutually exclusive.\"\n    :> ZAuthServant\n    :> \"list-users\"\n    :> Servant.ReqBody '[Servant.JSON] Public.ListUsersQuery\n    :> Post '[Servant.JSON] [Public.UserProfile]\n\ntype MaxUsersForListClientsBulk = 500\n\ntype ListClientsBulk =\n  Summary \"List all clients for a set of user ids\"\n    :> ZAuthServant\n    :> \"users\"\n    :> \"list-clients\"\n    :> Servant.ReqBody '[Servant.JSON] (Range 1 MaxUsersForListClientsBulk [Qualified UserId])\n    :> Post '[Servant.JSON] (Public.QualifiedUserMap (Set Public.PubClient))\n\ntype GetUsersPrekeysClientUnqualified =\n  Summary \"(deprecated) Get a prekey for a specific client of a user.\"\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> CaptureClientId \"client\"\n    :> Get '[Servant.JSON] Public.ClientPrekey\n\ntype GetUsersPrekeysClientQualified =\n  Summary \"Get a prekey for a specific client of a user.\"\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> CaptureClientId \"client\"\n    :> Get '[Servant.JSON] Public.ClientPrekey\n\ntype GetUsersPrekeyBundleUnqualified =\n  Summary \"(deprecated) Get a prekey for each client of a user.\"\n    :> \"users\"\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> Get '[Servant.JSON] Public.PrekeyBundle\n\ntype GetUsersPrekeyBundleQualified =\n  Summary \"Get a prekey for each client of a user.\"\n    :> \"users\"\n    :> Capture \"domain\" Domain\n    :> CaptureUserId \"uid\"\n    :> \"prekeys\"\n    :> Get '[Servant.JSON] Public.PrekeyBundle\n\ntype GetMultiUserPrekeyBundleUnqualified =\n  Summary\n    \"(deprecated)  Given a map of user IDs to client IDs return a \\\n    \\prekey for each one. You can't request information for more users than \\\n    \\maximum conversation size.\"\n    :> \"users\"\n    :> \"prekeys\"\n    :> Servant.ReqBody '[Servant.JSON] Public.UserClients\n    :> Post '[Servant.JSON] (Public.UserClientMap (Maybe Public.Prekey))\n\ntype GetMultiUserPrekeyBundleQualified =\n  Summary\n    \"Given a map of user IDs to client IDs return a \\\n    \\prekey for each one. You can't request information for more users than \\\n    \\maximum conversation size.\"\n    :> \"users\"\n    :> \"list-prekeys\"\n    :> Servant.ReqBody '[Servant.JSON] Public.QualifiedUserClients\n    :> Post '[Servant.JSON] (Public.QualifiedUserClientMap (Maybe Public.Prekey))\n\ntype OutsideWorldAPI =\n  CheckUserExistsUnqualified\n    :<|> CheckUserExistsQualified\n    :<|> GetUserUnqualified\n    :<|> GetUserQualified\n    :<|> GetSelf\n    :<|> GetHandleInfoUnqualified\n    :<|> GetHandleInfoQualified\n    :<|> ListUsersByUnqualifiedIdsOrHandles\n    :<|> ListUsersByIdsOrHandles\n    :<|> ListClientsBulk\n    :<|> GetUsersPrekeysClientUnqualified\n    :<|> GetUsersPrekeysClientQualified\n    :<|> GetUsersPrekeyBundleUnqualified\n    :<|> GetUsersPrekeyBundleQualified\n    :<|> GetMultiUserPrekeyBundleUnqualified\n    :<|> GetMultiUserPrekeyBundleQualified\n\ntype SwaggerDocsAPI = \"api\" :> SwaggerSchemaUI \"swagger-ui\" \"swagger.json\"\n\ntype ServantAPI = OutsideWorldAPI\n\n-- FUTUREWORK: At the moment this only shows endpoints from brig, but we should\n-- combine the swagger 2.0 endpoints here as well from other services (e.g. spar)\nswaggerDoc :: Swagger\nswaggerDoc =\n  toSwagger (Proxy @OutsideWorldAPI)\n    & info . title .~ \"Wire-Server API as Swagger 2.0 \"\n    & info . description ?~ \"NOTE: only a few endpoints are visible here at the moment, more will come as we migrate them to Swagger 2.0. In the meantime please also look at the old swagger docs link for the not-yet-migrated endpoints. See https://docs.wire.com/understand/api-client-perspective/swagger.html for the old endpoints.\"\n\nswaggerDocsAPI :: Servant.Server SwaggerDocsAPI\nswaggerDocsAPI = swaggerSchemaUIServer swaggerDoc\n\nservantSitemap :: ServerT ServantAPI Handler\nservantSitemap =\n  checkUserExistsUnqualifiedH\n    :<|> checkUserExistsH\n    :<|> getUserUnqualifiedH\n    :<|> getUserH\n    :<|> getSelf\n    :<|> getHandleInfoUnqualifiedH\n    :<|> getHandleInfoH\n    :<|> listUsersByUnqualifiedIdsOrHandles\n    :<|> listUsersByIdsOrHandles\n    :<|> listClientsBulk\n    :<|> getPrekeyUnqualifiedH\n    :<|> getPrekeyH\n    :<|> getPrekeyBundleUnqualifiedH\n    :<|> getPrekeyBundleH\n    :<|> getMultiUserPrekeyBundleUnqualifiedH\n    :<|> getMultiUserPrekeyBundleH\n\n-- Note [ephemeral user sideeffect]\n-- If the user is ephemeral and expired, it will be removed upon calling\n-- CheckUserExists[Un]Qualified, see 'Brig.API.User.userGC'.\n-- This leads to the following events being sent:\n-- - UserDeleted event to contacts of the user\n-- - MemberLeave event to members for all conversations the user was in (via galley)\n\nsitemap :: Opts -> Routes Doc.ApiBuilder Handler ()\nsitemap o = do\n  -- User Handle API ----------------------------------------------------\n\n  post \"/users/handles\" (continue checkHandlesH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. jsonRequest @Public.CheckHandles\n  document \"POST\" \"checkUserHandles\" $ do\n    Doc.summary \"Check availability of user handles\"\n    Doc.body (Doc.ref Public.modelCheckHandles) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of free handles\" Doc.end\n\n  head \"/users/handles/:handle\" (continue checkHandleH) $\n    zauthUserId\n      .&. capture \"handle\"\n  document \"HEAD\" \"checkUserHandle\" $ do\n    Doc.summary \"Check whether a user handle can be taken\"\n    Doc.parameter Doc.Path \"handle\" Doc.bytes' $\n      Doc.description \"Handle to check\"\n    Doc.response 200 \"Handle is taken\" Doc.end\n    Doc.errorResponse invalidHandle\n    Doc.errorResponse handleNotFound\n\n  -- some APIs moved to servant\n  -- end User Handle API\n\n  -- User Client API ----------------------------------------------------\n\n  get \"/users/:uid/clients\" (continue getUserClientsH) $\n    capture \"uid\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getUserClients\" $ do\n    Doc.summary \"Get all of a user's clients.\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.array (Doc.ref Public.modelPubClient))\n    Doc.response 200 \"List of clients\" Doc.end\n\n  get \"/users/:uid/clients/:client\" (continue getUserClientH) $\n    capture \"uid\"\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getUserClient\" $ do\n    Doc.summary \"Get a specific client of a user.\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.ref Public.modelPubClient)\n    Doc.response 200 \"Client\" Doc.end\n\n  -- end User Client API\n\n  get \"/users/:uid/rich-info\" (continue getRichInfoH) $\n    zauthUserId\n      .&. capture \"uid\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getRichInfo\" $ do\n    Doc.summary \"Get user's rich info\"\n    Doc.parameter Doc.Path \"uid\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.ref Public.modelRichInfo)\n    Doc.response 200 \"RichInfo\" Doc.end\n    Doc.errorResponse insufficientTeamPermissions\n\n  -- User Self API ------------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserUpdated event to contacts of self\n  put \"/self\" (continue updateUserH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.UserUpdate\n  document \"PUT\" \"updateSelf\" $ do\n    Doc.summary \"Update your profile\"\n    Doc.body (Doc.ref Public.modelUserUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Update successful.\" Doc.end\n\n  get \"/self/name\" (continue getUserDisplayNameH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n  document \"GET\" \"selfName\" $ do\n    Doc.summary \"Get your profile name\"\n    Doc.returns (Doc.ref Public.modelUserDisplayName)\n    Doc.response 200 \"Profile name found.\" Doc.end\n\n  put \"/self/email\" (continue changeSelfEmailH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.EmailUpdate\n  document \"PUT\" \"changeEmail\" $ do\n    Doc.summary \"Change your email address\"\n    Doc.body (Doc.ref Public.modelEmailUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Update accepted and pending activation of the new email.\" Doc.end\n    Doc.response 204 \"No update, current and new email address are the same.\" Doc.end\n    Doc.errorResponse invalidEmail\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n\n  put \"/self/phone\" (continue changePhoneH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.PhoneUpdate\n  document \"PUT\" \"changePhone\" $ do\n    Doc.summary \"Change your phone number\"\n    Doc.body (Doc.ref Public.modelPhoneUpdate) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Update accepted and pending activation of the new phone number.\" Doc.end\n    Doc.errorResponse userKeyExists\n\n  head \"/self/password\" (continue checkPasswordExistsH) $\n    zauthUserId\n  document \"HEAD\" \"checkPassword\" $ do\n    Doc.summary \"Check that your password is set\"\n    Doc.response 200 \"Password is set.\" Doc.end\n    Doc.response 404 \"Password is not set.\" Doc.end\n\n  put \"/self/password\" (continue changePasswordH) $\n    zauthUserId\n      .&. jsonRequest @Public.PasswordChange\n  document \"PUT\" \"changePassword\" $ do\n    Doc.summary \"Change your password\"\n    Doc.body (Doc.ref Public.modelChangePassword) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Password changed.\" Doc.end\n    Doc.errorResponse badCredentials\n    Doc.errorResponse (noIdentity 4)\n\n  put \"/self/locale\" (continue changeLocaleH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.LocaleUpdate\n  document \"PUT\" \"changeLocale\" $ do\n    Doc.summary \"Change your locale\"\n    Doc.body (Doc.ref Public.modelChangeLocale) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Locale changed.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserUpdated event to contacts of self\n  put \"/self/handle\" (continue changeHandleH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.HandleUpdate\n  document \"PUT\" \"changeHandle\" $ do\n    Doc.summary \"Change your handle\"\n    Doc.body (Doc.ref Public.modelChangeHandle) $\n      Doc.description \"JSON body\"\n    Doc.errorResponse handleExists\n    Doc.errorResponse invalidHandle\n    Doc.response 200 \"Handle changed.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserIdentityRemoved event to self\n  delete \"/self/phone\" (continue removePhoneH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"removePhone\" $ do\n    Doc.summary \"Remove your phone number.\"\n    Doc.notes\n      \"Your phone number can only be removed if you also have an \\\n      \\email address and a password.\"\n    Doc.response 200 \"Phone number removed.\" Doc.end\n    Doc.errorResponse lastIdentity\n    Doc.errorResponse noPassword\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserIdentityRemoved event to self\n  delete \"/self/email\" (continue removeEmailH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"removeEmail\" $ do\n    Doc.summary \"Remove your email address.\"\n    Doc.notes\n      \"Your email address can only be removed if you also have a \\\n      \\phone number.\"\n    Doc.response 200 \"Email address removed.\" Doc.end\n    Doc.errorResponse lastIdentity\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserDeleted event to contacts of self\n  -- - MemberLeave event to members for all conversations the user was in (via galley)\n  delete \"/self\" (continue deleteUserH) $\n    zauthUserId\n      .&. jsonRequest @Public.DeleteUser\n      .&. accept \"application\" \"json\"\n  document \"DELETE\" \"deleteUser\" $ do\n    Doc.summary \"Initiate account deletion.\"\n    Doc.notes\n      \"If the account has a verified identity, a verification \\\n      \\code is sent and needs to be confirmed to authorise the \\\n      \\deletion. If the account has no verified identity but a \\\n      \\password, it must be provided. If password is correct, or if neither \\\n      \\a verified identity nor a password exists, account deletion \\\n      \\is scheduled immediately.\"\n    Doc.body (Doc.ref Public.modelDelete) $\n      Doc.description \"JSON body\"\n    Doc.response 202 \"Deletion is pending verification with a code.\" Doc.end\n    Doc.response 200 \"Deletion is initiated.\" Doc.end\n    Doc.errorResponse badCredentials\n    Doc.errorResponse missingAuthError\n\n  -- TODO put  where?\n\n  -- This endpoint can lead to the following events being sent:\n  -- UserDeleted event to contacts of deleted user\n  -- MemberLeave event to members for all conversations the user was in (via galley)\n  post \"/delete\" (continue verifyDeleteUserH) $\n    jsonRequest @Public.VerifyDeleteUser\n      .&. accept \"application\" \"json\"\n  document \"POST\" \"verifyDeleteUser\" $ do\n    Doc.summary \"Verify account deletion with a code.\"\n    Doc.body (Doc.ref Public.modelVerifyDelete) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Deletion is initiated.\" Doc.end\n    Doc.errorResponse invalidCode\n\n  -- Connection API -----------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ConnectionUpdated event to self and other, if any side's connection state changes\n  -- - MemberJoin event to self and other, if joining an existing connect conversation (via galley)\n  -- - ConvCreate event to self, if creating a connect conversation (via galley)\n  -- - ConvConnect event to self, in some cases (via galley),\n  --   for details see 'Galley.API.Create.createConnectConversation'\n  post \"/connections\" (continue createConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. jsonRequest @Public.ConnectionRequest\n  document \"POST\" \"createConnection\" $ do\n    Doc.summary \"Create a connection to another user.\"\n    Doc.notes $\n      \"You can have no more than \"\n        <> Text.pack (show (setUserMaxConnections $ optSettings o))\n        <> \" connections in accepted or sent state.\"\n    Doc.body (Doc.ref Public.modelConnectionRequest) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"The connection exists.\" Doc.end\n    Doc.response 201 \"The connection was created.\" Doc.end\n    Doc.errorResponse connectionLimitReached\n    Doc.errorResponse invalidUser\n    Doc.errorResponse (noIdentity 5)\n\n  get \"/connections\" (continue listConnectionsH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. opt (query \"start\")\n      .&. def (unsafeRange 100) (query \"size\")\n  document \"GET\" \"connections\" $ do\n    Doc.summary \"List the connections to other users.\"\n    Doc.parameter Doc.Query \"start\" Doc.string' $ do\n      Doc.description \"User ID to start from\"\n      Doc.optional\n    Doc.parameter Doc.Query \"size\" Doc.int32' $ do\n      Doc.description \"Number of results to return (default 100, max 500).\"\n      Doc.optional\n    Doc.returns (Doc.ref Public.modelConnectionList)\n    Doc.response 200 \"List of connections\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ConnectionUpdated event to self and other, if their connection states change\n  --\n  -- When changing the connection state to Sent or Accepted, this can cause events to be sent\n  -- when joining the connect conversation:\n  -- - MemberJoin event to self and other (via galley)\n  put \"/connections/:id\" (continue updateConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. capture \"id\"\n      .&. jsonRequest @Public.ConnectionUpdate\n  document \"PUT\" \"updateConnection\" $ do\n    Doc.summary \"Update a connection.\"\n    Doc.parameter Doc.Path \"id\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.body (Doc.ref Public.modelConnectionUpdate) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"Connection updated.\" Doc.end\n    Doc.response 204 \"No change.\" Doc.end\n    Doc.errorResponse connectionLimitReached\n    Doc.errorResponse invalidTransition\n    Doc.errorResponse notConnected\n    Doc.errorResponse invalidUser\n\n  get \"/connections/:id\" (continue getConnectionH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. capture \"id\"\n  document \"GET\" \"connection\" $ do\n    Doc.summary \"Get an existing connection to another user.\"\n    Doc.parameter Doc.Path \"id\" Doc.bytes' $\n      Doc.description \"User ID\"\n    Doc.returns (Doc.ref Public.modelConnection)\n    Doc.response 200 \"Connection\" Doc.end\n\n  -- User Client API ----------------------------------------------------\n  -- TODO: another one?\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ClientAdded event to self\n  -- - ClientRemoved event to self, if removing old clients due to max number\n  post \"/clients\" (continue addClientH) $\n    jsonRequest @Public.NewClient\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. opt (header \"X-Forwarded-For\")\n      .&. accept \"application\" \"json\"\n  document \"POST\" \"registerClient\" $ do\n    Doc.summary \"Register a new client.\"\n    Doc.body (Doc.ref Public.modelNewClient) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelClient)\n    Doc.response 200 \"Client\" Doc.end\n    Doc.errorResponse tooManyClients\n    Doc.errorResponse missingAuthError\n    Doc.errorResponse malformedPrekeys\n\n  put \"/clients/:client\" (continue updateClientH) $\n    jsonRequest @Public.UpdateClient\n      .&. zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"PUT\" \"updateClient\" $ do\n    Doc.summary \"Update a registered client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.body (Doc.ref Public.modelUpdateClient) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Client updated.\" Doc.end\n    Doc.errorResponse malformedPrekeys\n\n  -- This endpoint can lead to the following events being sent:\n  -- - ClientRemoved event to self\n  delete \"/clients/:client\" (continue rmClientH) $\n    jsonRequest @Public.RmClient\n      .&. zauthUserId\n      .&. zauthConnId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"DELETE\" \"deleteClient\" $ do\n    Doc.summary \"Delete an existing client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.body (Doc.ref Public.modelDeleteClient) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Client deleted.\" Doc.end\n\n  get \"/clients\" (continue listClientsH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listClients\" $ do\n    Doc.summary \"List the registered clients.\"\n    Doc.returns (Doc.array (Doc.ref Public.modelClient))\n    Doc.response 200 \"List of clients\" Doc.end\n\n  get \"/clients/:client\" (continue getClientH) $\n    zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getClients\" $ do\n    Doc.summary \"Get a registered client by ID.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.ref Public.modelClient)\n    Doc.response 200 \"Client\" Doc.end\n\n  get \"/clients/:client/prekeys\" (continue listPrekeyIdsH) $\n    zauthUserId\n      .&. capture \"client\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPrekeyIds\" $ do\n    Doc.summary \"List the remaining prekey IDs of a client.\"\n    Doc.parameter Doc.Path \"client\" Doc.bytes' $\n      Doc.description \"Client ID\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of remaining prekey IDs.\" Doc.end\n\n  -- Properties API -----------------------------------------------------\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertySet event to self\n  put \"/properties/:key\" (continue setPropertyH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. capture \"key\"\n      .&. jsonRequest @Public.PropertyValue\n  document \"PUT\" \"setProperty\" $ do\n    Doc.summary \"Set a user property.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.body (Doc.ref Public.modelPropertyValue) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Property set.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertyDeleted event to self\n  delete \"/properties/:key\" (continue deletePropertyH) $\n    zauthUserId\n      .&. zauthConnId\n      .&. capture \"key\"\n  document \"DELETE\" \"deleteProperty\" $ do\n    Doc.summary \"Delete a property.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.response 200 \"Property deleted.\" Doc.end\n\n  -- This endpoint can lead to the following events being sent:\n  -- - PropertiesCleared event to self\n  delete \"/properties\" (continue clearPropertiesH) $\n    zauthUserId\n      .&. zauthConnId\n  document \"DELETE\" \"clearProperties\" $ do\n    Doc.summary \"Clear all properties.\"\n    Doc.response 200 \"Properties cleared.\" Doc.end\n\n  get \"/properties/:key\" (continue getPropertyH) $\n    zauthUserId\n      .&. capture \"key\"\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"getProperty\" $ do\n    Doc.summary \"Get a property value.\"\n    Doc.parameter Doc.Path \"key\" Doc.string' $\n      Doc.description \"Property key\"\n    Doc.returns (Doc.ref Public.modelPropertyValue)\n    Doc.response 200 \"The property value.\" Doc.end\n\n  get \"/properties\" (continue listPropertyKeysH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPropertyKeys\" $ do\n    Doc.summary \"List all property keys.\"\n    Doc.returns (Doc.array Doc.string')\n    Doc.response 200 \"List of property keys.\" Doc.end\n\n  get \"/properties-values\" (continue listPropertyKeysAndValuesH) $\n    zauthUserId\n      .&. accept \"application\" \"json\"\n  document \"GET\" \"listPropertyKeysAndValues\" $ do\n    Doc.summary \"List all properties with key and value.\"\n    Doc.returns (Doc.ref Public.modelPropertyDictionary)\n    Doc.response 200 \"Object with properties as attributes.\" Doc.end\n\n  -- TODO: put delete here, too?\n  -- /register, /activate, /password-reset ----------------------------------\n\n  -- docs/reference/user/registration.md {#RefRegistration}\n  --\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to created user, if it is a team invitation or user has an SSO ID\n  -- - UserIdentityUpdated event to created user, if email code or phone code is provided\n  post \"/register\" (continue createUserH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.NewUserPublic\n  document \"POST\" \"register\" $ do\n    Doc.summary \"Register a new user.\"\n    Doc.notes\n      \"If the environment where the registration takes \\\n      \\place is private and a registered email address or phone \\\n      \\number is not whitelisted, a 403 error is returned.\"\n    Doc.body (Doc.ref Public.modelNewUser) $\n      Doc.description \"JSON body\"\n    -- FUTUREWORK: I think this should be 'Doc.self' instead of 'user'\n    Doc.returns (Doc.ref Public.modelUser)\n    Doc.response 201 \"User created and pending activation.\" Doc.end\n    Doc.errorResponse whitelistError\n    Doc.errorResponse invalidInvitationCode\n    Doc.errorResponse missingIdentity\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse activationCodeNotFound\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to the user, if account gets activated\n  -- - UserIdentityUpdated event to the user, if email or phone get activated\n  get \"/activate\" (continue activateH) $\n    query \"key\"\n      .&. query \"code\"\n  document \"GET\" \"activate\" $ do\n    Doc.summary \"Activate (i.e. confirm) an email address or phone number.\"\n    Doc.notes \"See also 'POST /activate' which has a larger feature set.\"\n    Doc.parameter Doc.Query \"key\" Doc.bytes' $\n      Doc.description \"Activation key\"\n    Doc.parameter Doc.Query \"code\" Doc.bytes' $\n      Doc.description \"Activation code\"\n    Doc.returns (Doc.ref Public.modelActivationResponse)\n    Doc.response 200 \"Activation successful.\" Doc.end\n    Doc.response 204 \"A recent activation was already successful.\" Doc.end\n    Doc.errorResponse activationCodeNotFound\n\n  -- docs/reference/user/activation.md {#RefActivationSubmit}\n  --\n  -- This endpoint can lead to the following events being sent:\n  -- - UserActivated event to the user, if account gets activated\n  -- - UserIdentityUpdated event to the user, if email or phone get activated\n  post \"/activate\" (continue activateKeyH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.Activate\n  document \"POST\" \"activate\" $ do\n    Doc.summary \"Activate (i.e. confirm) an email address or phone number.\"\n    Doc.notes\n      \"Activation only succeeds once and the number of \\\n      \\failed attempts for a valid key is limited.\"\n    Doc.body (Doc.ref Public.modelActivate) $\n      Doc.description \"JSON body\"\n    Doc.returns (Doc.ref Public.modelActivationResponse)\n    Doc.response 200 \"Activation successful.\" Doc.end\n    Doc.response 204 \"A recent activation was already successful.\" Doc.end\n    Doc.errorResponse activationCodeNotFound\n\n  -- docs/reference/user/activation.md {#RefActivationRequest}\n  post \"/activate/send\" (continue sendActivationCodeH) $\n    jsonRequest @Public.SendActivationCode\n  document \"POST\" \"sendActivationCode\" $ do\n    Doc.summary \"Send (or resend) an email or phone activation code.\"\n    Doc.body (Doc.ref Public.modelSendActivationCode) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Activation code sent.\" Doc.end\n    Doc.errorResponse invalidEmail\n    Doc.errorResponse invalidPhone\n    Doc.errorResponse userKeyExists\n    Doc.errorResponse blacklistedEmail\n    Doc.errorResponse blacklistedPhone\n    Doc.errorResponse (customerExtensionBlockedDomain (either undefined id $ mkDomain \"example.com\"))\n\n  post \"/password-reset\" (continue beginPasswordResetH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.NewPasswordReset\n  document \"POST\" \"beginPasswordReset\" $ do\n    Doc.summary \"Initiate a password reset.\"\n    Doc.body (Doc.ref Public.modelNewPasswordReset) $\n      Doc.description \"JSON body\"\n    Doc.response 201 \"Password reset code created and sent by email.\" Doc.end\n    Doc.errorResponse invalidPwResetKey\n    Doc.errorResponse duplicatePwResetCode\n\n  post \"/password-reset/complete\" (continue completePasswordResetH) $\n    accept \"application\" \"json\"\n      .&. jsonRequest @Public.CompletePasswordReset\n  document \"POST\" \"completePasswordReset\" $ do\n    Doc.summary \"Complete a password reset.\"\n    Doc.body (Doc.ref Public.modelCompletePasswordReset) $\n      Doc.description \"JSON body\"\n    Doc.response 200 \"Password reset successful.\" Doc.end\n    Doc.errorResponse invalidPwResetCode\n\n  post \"/password-reset/:key\" (continue deprecatedCompletePasswordResetH) $\n    accept \"application\" \"json\"\n      .&. capture \"key\"\n      .&. jsonRequest @Public.PasswordReset\n  document \"POST\" \"deprecatedCompletePasswordReset\" $ do\n    Doc.deprecated\n    Doc.summary \"Complete a password reset.\"\n    Doc.notes \"DEPRECATED: Use 'POST /password-reset/complete'.\"\n\n  post \"/onboarding/v3\" (continue deprecatedOnboardingH) $\n    accept \"application\" \"json\"\n      .&. zauthUserId\n      .&. jsonRequest @Value\n  document \"POST\" \"onboardingV3\" $ do\n    Doc.deprecated\n    Doc.summary \"Upload contacts and invoke matching.\"\n    Doc.notes\n      \"DEPRECATED: the feature has been turned off, the end-point does \\\n      \\nothing and always returns '{\\\"results\\\":[],\\\"auto-connects\\\":[]}'.\"\n\n  Provider.routesPublic\n  Auth.routesPublic\n  Search.routesPublic\n  Team.routesPublic\n  Calling.routesPublic\n\napiDocs :: Opts -> Routes Doc.ApiBuilder Handler ()\napiDocs o = do\n  get\n    \"/users/api-docs\"\n    ( \\(_ ::: url) k ->\n        let doc = mkSwaggerApi (decodeLatin1 url) Public.Swagger.models (sitemap o)\n         in k $ json doc\n    )\n    $ accept \"application\" \"json\"\n      .&. query \"base_url\"\n\n---------------------------------------------------------------------------\n-- Handlers\n\nsetPropertyH :: UserId ::: ConnId ::: Public.PropertyKey ::: JsonRequest Public.PropertyValue -> Handler Response\nsetPropertyH (u ::: c ::: k ::: req) = do\n  propkey <- safeParsePropertyKey k\n  propval <- safeParsePropertyValue (lazyRequestBody (fromJsonRequest req))\n  empty <$ setProperty u c propkey propval\n\nsetProperty :: UserId -> ConnId -> Public.PropertyKey -> Public.PropertyValue -> Handler ()\nsetProperty u c propkey propval = do\n  API.setProperty u c propkey propval !>> propDataError\n\nsafeParsePropertyKey :: Public.PropertyKey -> Handler Public.PropertyKey\nsafeParsePropertyKey k = do\n  maxKeyLen <- fromMaybe defMaxKeyLen <$> view (settings . propertyMaxKeyLen)\n  let keyText = Ascii.toText (Public.propertyKeyName k)\n  when (Text.compareLength keyText (fromIntegral maxKeyLen) == GT) $\n    throwStd propertyKeyTooLarge\n  pure k\n\n-- | Parse a 'PropertyValue' from a bytestring.  This is different from 'FromJSON' in that\n-- checks the byte size of the input, and fails *without consuming all of it* if that size\n-- exceeds the settings.\nsafeParsePropertyValue :: IO Lazy.ByteString -> Handler Public.PropertyValue\nsafeParsePropertyValue lreqbody = do\n  maxValueLen <- fromMaybe defMaxValueLen <$> view (settings . propertyMaxValueLen)\n  lbs <- Lazy.take (maxValueLen + 1) <$> liftIO lreqbody\n  unless (Lazy.length lbs <= maxValueLen) $\n    throwStd propertyValueTooLarge\n  hoistEither $ fmapL (StdError . badRequest . pack) (eitherDecode lbs)\n\ndeletePropertyH :: UserId ::: ConnId ::: Public.PropertyKey -> Handler Response\ndeletePropertyH (u ::: c ::: k) = lift (API.deleteProperty u c k) >> return empty\n\nclearPropertiesH :: UserId ::: ConnId -> Handler Response\nclearPropertiesH (u ::: c) = lift (API.clearProperties u c) >> return empty\n\ngetPropertyH :: UserId ::: Public.PropertyKey ::: JSON -> Handler Response\ngetPropertyH (u ::: k ::: _) = do\n  val <- lift $ API.lookupProperty u k\n  return $ case val of\n    Nothing -> setStatus status404 empty\n    Just v -> json (v :: Public.PropertyValue)\n\nlistPropertyKeysH :: UserId ::: JSON -> Handler Response\nlistPropertyKeysH (u ::: _) = do\n  keys <- lift (API.lookupPropertyKeys u)\n  pure $ json (keys :: [Public.PropertyKey])\n\nlistPropertyKeysAndValuesH :: UserId ::: JSON -> Handler Response\nlistPropertyKeysAndValuesH (u ::: _) = do\n  keysAndVals <- lift (API.lookupPropertyKeysAndValues u)\n  pure $ json (keysAndVals :: Public.PropertyKeysAndValues)\n\ngetPrekeyUnqualifiedH :: UserId -> ClientId -> Handler Public.ClientPrekey\ngetPrekeyUnqualifiedH user client = do\n  domain <- viewFederationDomain\n  ifNothing (notFound \"prekey not found\") =<< lift (API.claimPrekey user domain client)\n\ngetPrekeyH :: Domain -> UserId -> ClientId -> Handler Public.ClientPrekey\ngetPrekeyH domain user client = do\n  ifNothing (notFound \"prekey not found\") =<< lift (API.claimPrekey user domain client)\n\ngetPrekeyBundleUnqualifiedH :: UserId -> Handler Public.PrekeyBundle\ngetPrekeyBundleUnqualifiedH uid = do\n  domain <- viewFederationDomain\n  API.claimPrekeyBundle domain uid !>> clientError\n\ngetPrekeyBundleH :: Domain -> UserId -> Handler Public.PrekeyBundle\ngetPrekeyBundleH domain uid =\n  API.claimPrekeyBundle domain uid !>> clientError\n\ngetMultiUserPrekeyBundleUnqualifiedH :: Public.UserClients -> Handler (Public.UserClientMap (Maybe Public.Prekey))\ngetMultiUserPrekeyBundleUnqualifiedH userClients = do\n  maxSize <- fromIntegral . setMaxConvSize <$> view settings\n  when (Map.size (Public.userClients userClients) > maxSize) $\n    throwStd tooManyClients\n  API.claimMultiPrekeyBundlesLocal userClients !>> clientError\n\ngetMultiUserPrekeyBundleH :: Public.QualifiedUserClients -> Handler (Public.QualifiedUserClientMap (Maybe Public.Prekey))\ngetMultiUserPrekeyBundleH qualUserClients = do\n  maxSize <- fromIntegral . setMaxConvSize <$> view settings\n  let Sum (size :: Int) =\n        Map.foldMapWithKey\n          (\\_ v -> Sum . Map.size . Public.userClients $ v)\n          (Public.qualifiedUserClients qualUserClients)\n  when (size > maxSize) $\n    throwStd tooManyClients\n  API.claimMultiPrekeyBundles qualUserClients !>> clientError\n\naddClientH :: JsonRequest Public.NewClient ::: UserId ::: ConnId ::: Maybe IpAddr ::: JSON -> Handler Response\naddClientH (req ::: usr ::: con ::: ip ::: _) = do\n  new <- parseJsonBody req\n  clt <- addClient new usr con ip\n  let loc = toByteString' $ Public.clientId clt\n  pure . setStatus status201 . addHeader \"Location\" loc . json $ clt\n\naddClient :: Public.NewClient -> UserId -> ConnId -> Maybe IpAddr -> Handler Public.Client\naddClient new usr con ip = do\n  -- Users can't add legal hold clients\n  when (Public.newClientType new == Public.LegalHoldClientType) $\n    throwE (clientError ClientLegalHoldCannotBeAdded)\n  API.addClient usr (Just con) (ipAddr <$> ip) new !>> clientError\n\nrmClientH :: JsonRequest Public.RmClient ::: UserId ::: ConnId ::: ClientId ::: JSON -> Handler Response\nrmClientH (req ::: usr ::: con ::: clt ::: _) = do\n  body <- parseJsonBody req\n  empty <$ rmClient body usr con clt\n\nrmClient :: Public.RmClient -> UserId -> ConnId -> ClientId -> Handler ()\nrmClient body usr con clt = do\n  API.rmClient usr con clt (Public.rmPassword body) !>> clientError\n\nupdateClientH :: JsonRequest Public.UpdateClient ::: UserId ::: ClientId ::: JSON -> Handler Response\nupdateClientH (req ::: usr ::: clt ::: _) = do\n  body <- parseJsonBody req\n  empty <$ updateClient body usr clt\n\nupdateClient :: Public.UpdateClient -> UserId -> ClientId -> Handler ()\nupdateClient body usr clt = do\n  API.updateClient usr clt body !>> clientError\n\nlistClientsH :: UserId ::: JSON -> Handler Response\nlistClientsH (zusr ::: _) =\n  json <$> listClients zusr\n\nlistClients :: UserId -> Handler [Public.Client]\nlistClients zusr = do\n  API.lookupClients (Local zusr) !>> clientError\n\ngetClientH :: UserId ::: ClientId ::: JSON -> Handler Response\ngetClientH (zusr ::: clt ::: _) =\n  getClient zusr clt <&> \\case\n    Just c -> json c\n    Nothing -> setStatus status404 empty\n\nlistClientsBulk :: UserId -> Range 1 MaxUsersForListClientsBulk [Qualified UserId] -> Handler (Public.QualifiedUserMap (Set Public.PubClient))\nlistClientsBulk _zusr limitedUids = do\n  Set.map API.pubClient <$$> API.lookupClientsBulk (fromRange limitedUids) !>> clientError\n\ngetClient :: UserId -> ClientId -> Handler (Maybe Public.Client)\ngetClient zusr clientId = do\n  API.lookupClient (Local zusr) clientId !>> clientError\n\ngetUserClientsH :: OpaqueUserId ::: JSON -> Handler Response\ngetUserClientsH (user ::: _) =\n  json <$> getUserClients user\n\ngetUserClients :: OpaqueUserId -> Handler [Public.PubClient]\ngetUserClients opaqueUserId = do\n  resolvedUserId <- lift $ resolveOpaqueUserId opaqueUserId\n  API.pubClient <$$> API.lookupClients resolvedUserId !>> clientError\n\ngetUserClientH :: OpaqueUserId ::: ClientId ::: JSON -> Handler Response\ngetUserClientH (user ::: cid ::: _) = do\n  maybe (setStatus status404 empty) json <$> getUserClient user cid\n\ngetUserClient :: OpaqueUserId -> ClientId -> Handler (Maybe Public.PubClient)\ngetUserClient opaqueUserId clientId = do\n  resolvedUserId <- lift $ resolveOpaqueUserId opaqueUserId\n  API.pubClient <$$> API.lookupClient resolvedUserId clientId !>> clientError\n\ngetRichInfoH :: UserId ::: UserId ::: JSON -> Handler Response\ngetRichInfoH (self ::: user ::: _) = do\n  json <$> getRichInfo self user\n\ngetRichInfo :: UserId -> UserId -> Handler Public.RichInfoAssocList\ngetRichInfo self user = do\n  -- Check that both users exist and the requesting user is allowed to see rich info of the\n  -- other user\n  selfUser <- ifNothing userNotFound =<< lift (Data.lookupUser NoPendingInvitations self)\n  otherUser <- ifNothing userNotFound =<< lift (Data.lookupUser NoPendingInvitations user)\n  case (Public.userTeam selfUser, Public.userTeam otherUser) of\n    (Just t1, Just t2) | t1 == t2 -> pure ()\n    _ -> throwStd insufficientTeamPermissions\n  -- Query rich info\n  fromMaybe Public.emptyRichInfoAssocList <$> lift (API.lookupRichInfo user)\n\nlistPrekeyIdsH :: UserId ::: ClientId ::: JSON -> Handler Response\nlistPrekeyIdsH (usr ::: clt ::: _) = do\n  prekeyIds <- lift (API.lookupPrekeyIds usr clt)\n  pure $ json (prekeyIds :: [Public.PrekeyId])\n\n-- docs/reference/user/registration.md {#RefRegistration}\ncreateUserH :: JSON ::: JsonRequest Public.NewUserPublic -> Handler Response\ncreateUserH (_ ::: req) = do\n  CreateUserResponse cok loc prof <- createUser =<< parseJsonBody req\n  lift . Auth.setResponseCookie cok\n    . setStatus status201\n    . addHeader \"Location\" (toByteString' loc)\n    $ json prof\n\ndata CreateUserResponse\n  = CreateUserResponse (Public.Cookie (ZAuth.Token ZAuth.User)) UserId Public.SelfProfile\n\ncreateUser :: Public.NewUserPublic -> Handler CreateUserResponse\ncreateUser (Public.NewUserPublic new) = do\n  API.checkRestrictedUserCreation new !>> newUserError\n  for_ (Public.newUserEmail new) $ checkWhitelist . Left\n  for_ (Public.newUserPhone new) $ checkWhitelist . Right\n  result <- API.createUser new !>> newUserError\n  let acc = createdAccount result\n\n  let eac = createdEmailActivation result\n  let pac = createdPhoneActivation result\n  let epair = (,) <$> (activationKey <$> eac) <*> (activationCode <$> eac)\n  let ppair = (,) <$> (activationKey <$> pac) <*> (activationCode <$> pac)\n  let newUserLabel = Public.newUserLabel new\n  let newUserTeam = Public.newUserTeam new\n  let usr = accountUser acc\n\n  let context =\n        let invitationCode = case Public.newUserTeam new of\n              (Just (Public.NewTeamMember code)) -> Just code\n              _ -> Nothing\n         in ( logFunction \"Brig.API.Public.createUser\"\n                . logUser (Public.userId usr)\n                . maybe id logHandle (Public.userHandle usr)\n                . maybe id logTeam (Public.userTeam usr)\n                . maybe id logEmail (Public.userEmail usr)\n                . maybe id logInvitationCode invitationCode\n            )\n  Log.info $ context . Log.msg @Text \"Sucessfully created user\"\n\n  let Public.User {userLocale, userDisplayName, userId} = usr\n  let userEmail = Public.userEmail usr\n  let userPhone = Public.userPhone usr\n  lift $ do\n    for_ (liftM2 (,) userEmail epair) $ \\(e, p) ->\n      sendActivationEmail e userDisplayName p (Just userLocale) newUserTeam\n    for_ (liftM2 (,) userPhone ppair) $ \\(p, c) ->\n      sendActivationSms p c (Just userLocale)\n    for_ (liftM3 (,,) userEmail (createdUserTeam result) newUserTeam) $ \\(e, ct, ut) ->\n      sendWelcomeEmail e ct ut (Just userLocale)\n  cok <- case acc of\n    UserAccount _ Ephemeral -> lift $ Auth.newCookie @ZAuth.User userId Public.SessionCookie newUserLabel\n    UserAccount _ _ -> lift $ Auth.newCookie @ZAuth.User userId Public.PersistentCookie newUserLabel\n  pure $ CreateUserResponse cok userId (Public.SelfProfile usr)\n  where\n    sendActivationEmail :: Public.Email -> Public.Name -> ActivationPair -> Maybe Public.Locale -> Maybe Public.NewTeamUser -> AppIO ()\n    sendActivationEmail e u p l mTeamUser\n      | Just teamUser <- mTeamUser,\n        Public.NewTeamCreator creator <- teamUser,\n        let Public.BindingNewTeamUser (Public.BindingNewTeam team) _ = creator =\n        sendTeamActivationMail e u p l (fromRange $ team ^. Public.newTeamName)\n      | otherwise =\n        sendActivationMail e u p l Nothing\n\n    sendWelcomeEmail :: Public.Email -> CreateUserTeam -> Public.NewTeamUser -> Maybe Public.Locale -> AppIO ()\n    -- NOTE: Welcome e-mails for the team creator are not dealt by brig anymore\n    sendWelcomeEmail e (CreateUserTeam t n) newUser l = case newUser of\n      Public.NewTeamCreator _ ->\n        return ()\n      Public.NewTeamMember _ ->\n        Team.sendMemberWelcomeMail e t n l\n      Public.NewTeamMemberSSO _ ->\n        Team.sendMemberWelcomeMail e t n l\n\ncheckUserExistsUnqualifiedH :: UserId -> UserId -> Handler (Union CheckUserExistsResponse)\ncheckUserExistsUnqualifiedH self uid = do\n  domain <- viewFederationDomain\n  checkUserExistsH self domain uid\n\ncheckUserExistsH :: UserId -> Domain -> UserId -> Handler (Union CheckUserExistsResponse)\ncheckUserExistsH self domain uid = do\n  exists <- checkUserExists self (Qualified uid domain)\n  if exists\n    then Servant.respond Empty200\n    else Servant.respond Empty404\n\ncheckUserExists :: UserId -> Qualified UserId -> Handler Bool\ncheckUserExists self qualifiedUserId =\n  isJust <$> getUser self qualifiedUserId\n\ngetSelf :: UserId -> Handler Public.SelfProfile\ngetSelf self = do\n  lift (API.lookupSelfProfile self) >>= ifNothing userNotFound\n\ngetUserUnqualifiedH :: UserId -> UserId -> Handler Public.UserProfile\ngetUserUnqualifiedH self uid = do\n  domain <- viewFederationDomain\n  getUserH self domain uid\n\ngetUserH :: UserId -> Domain -> UserId -> Handler Public.UserProfile\ngetUserH self domain uid =\n  ifNothing userNotFound =<< getUser self (Qualified uid domain)\n\ngetUser :: UserId -> Qualified UserId -> Handler (Maybe Public.UserProfile)\ngetUser self qualifiedUserId = do\n  lift $ API.lookupProfile self qualifiedUserId\n\ngetUserDisplayNameH :: JSON ::: UserId -> Handler Response\ngetUserDisplayNameH (_ ::: self) = do\n  name :: Maybe Public.Name <- lift $ API.lookupName self\n  return $ case name of\n    Just n -> json $ object [\"name\" .= n]\n    Nothing -> setStatus status404 empty\n\n-- FUTUREWORK: Make servant understand that at least one of these is required\nlistUsersByUnqualifiedIdsOrHandles :: UserId -> Maybe (CommaSeparatedList UserId) -> Maybe (Range 1 4 (CommaSeparatedList Handle)) -> Handler [Public.UserProfile]\nlistUsersByUnqualifiedIdsOrHandles self mUids mHandles = do\n  domain <- viewFederationDomain\n  case (mUids, mHandles) of\n    (Just uids, _) -> listUsersByIdsOrHandles self (Public.ListUsersByIds ((`Qualified` domain) <$> fromCommaSeparatedList uids))\n    (_, Just handles) ->\n      let normalRangedList = fromCommaSeparatedList $ fromRange handles\n          qualifiedList = (`Qualified` domain) <$> normalRangedList\n          -- Use of unsafeRange here is ok only because we know that 'handles'\n          -- is valid for 'Range 1 4'. However, we must not forget to keep this\n          -- annotation here otherwise a change in 'Public.ListUsersByHandles'\n          -- could cause this code to break.\n          qualifiedRangedList :: Range 1 4 [Qualified Handle] = unsafeRange qualifiedList\n       in listUsersByIdsOrHandles self (Public.ListUsersByHandles qualifiedRangedList)\n    (Nothing, Nothing) -> throwStd $ badRequest \"at least one ids or handles must be provided\"\n\nlistUsersByIdsOrHandles :: UserId -> Public.ListUsersQuery -> Handler [Public.UserProfile]\nlistUsersByIdsOrHandles self q = do\n  foundUsers <- case q of\n    Public.ListUsersByIds us ->\n      byIds us\n    Public.ListUsersByHandles hs -> do\n      domain <- viewFederationDomain\n      let (_remoteHandles, localHandles) = partitionRemoteOrLocalIds domain (fromRange hs)\n      us <- getIds localHandles\n      filterHandleResults self =<< byIds us\n  case foundUsers of\n    [] -> throwStd $ notFound \"None of the specified ids or handles match any users\"\n    _ -> pure foundUsers\n  where\n    getIds :: [Handle] -> Handler [Qualified UserId]\n    getIds localHandles = do\n      localUsers <- catMaybes <$> traverse (lift . API.lookupHandle) localHandles\n      -- FUTUREWORK(federation, #1268): resolve qualified handles, too\n      domain <- viewFederationDomain\n      pure $ map (`Qualified` domain) localUsers\n    byIds :: [Qualified UserId] -> Handler [Public.UserProfile]\n    byIds uids =\n      lift $ API.lookupProfiles self uids\n\nnewtype GetActivationCodeResp\n  = GetActivationCodeResp (Public.ActivationKey, Public.ActivationCode)\n\ninstance ToJSON GetActivationCodeResp where\n  toJSON (GetActivationCodeResp (k, c)) = object [\"key\" .= k, \"code\" .= c]\n\nupdateUserH :: UserId ::: ConnId ::: JsonRequest Public.UserUpdate -> Handler Response\nupdateUserH (uid ::: conn ::: req) = do\n  uu <- parseJsonBody req\n  API.updateUser uid (Just conn) uu API.ForbidSCIMUpdates !>> updateProfileError\n  return empty\n\nchangePhoneH :: UserId ::: ConnId ::: JsonRequest Public.PhoneUpdate -> Handler Response\nchangePhoneH (u ::: c ::: req) = do\n  setStatus status202 empty <$ (changePhone u c =<< parseJsonBody req)\n\nchangePhone :: UserId -> ConnId -> Public.PhoneUpdate -> Handler ()\nchangePhone u _ (Public.puPhone -> phone) = do\n  (adata, pn) <- API.changePhone u phone !>> changePhoneError\n  loc <- lift $ API.lookupLocale u\n  let apair = (activationKey adata, activationCode adata)\n  lift $ sendActivationSms pn apair loc\n\nremovePhoneH :: UserId ::: ConnId -> Handler Response\nremovePhoneH (self ::: conn) = do\n  API.removePhone self conn !>> idtError\n  return empty\n\nremoveEmailH :: UserId ::: ConnId -> Handler Response\nremoveEmailH (self ::: conn) = do\n  API.removeEmail self conn !>> idtError\n  return empty\n\ncheckPasswordExistsH :: UserId -> Handler Response\ncheckPasswordExistsH self = do\n  exists <- lift $ isJust <$> API.lookupPassword self\n  return $ if exists then empty else setStatus status404 empty\n\nchangePasswordH :: UserId ::: JsonRequest Public.PasswordChange -> Handler Response\nchangePasswordH (u ::: req) = do\n  cp <- parseJsonBody req\n  API.changePassword u cp !>> changePwError\n  return empty\n\nchangeLocaleH :: UserId ::: ConnId ::: JsonRequest Public.LocaleUpdate -> Handler Response\nchangeLocaleH (u ::: conn ::: req) = do\n  l <- parseJsonBody req\n  lift $ API.changeLocale u conn l\n  return empty\n\n-- | (zusr is ignored by this handler, ie. checking handles is allowed as long as you have\n-- *any* account.)\ncheckHandleH :: UserId ::: Text -> Handler Response\ncheckHandleH (_uid ::: hndl) = do\n  API.checkHandle hndl >>= \\case\n    API.CheckHandleInvalid -> throwE (StdError invalidHandle)\n    API.CheckHandleFound -> pure $ setStatus status200 empty\n    API.CheckHandleNotFound -> pure $ setStatus status404 empty\n\ncheckHandlesH :: JSON ::: UserId ::: JsonRequest Public.CheckHandles -> Handler Response\ncheckHandlesH (_ ::: _ ::: req) = do\n  Public.CheckHandles hs num <- parseJsonBody req\n  let handles = mapMaybe parseHandle (fromRange hs)\n  free <- lift $ API.checkHandles handles (fromRange num)\n  return $ json (free :: [Handle])\n\ngetHandleInfoUnqualifiedH :: UserId -> Handle -> Handler Public.UserHandleInfo\ngetHandleInfoUnqualifiedH self handle = do\n  domain <- viewFederationDomain\n  getHandleInfoH self domain handle\n\ngetHandleInfoH :: UserId -> Domain -> Handle -> Handler Public.UserHandleInfo\ngetHandleInfoH self domain handle =\n  ifNothing (notFound \"handle not found\")\n    =<< getHandleInfo self (Qualified handle domain)\n\n-- FUTUREWORK: use 'runMaybeT' to simplify this.\ngetHandleInfo :: UserId -> Qualified Handle -> Handler (Maybe Public.UserHandleInfo)\ngetHandleInfo self handle = do\n  domain <- viewFederationDomain\n  if qDomain handle == domain\n    then getLocalHandleInfo domain\n    else getRemoteHandleInfo\n  where\n    getLocalHandleInfo domain = do\n      Log.info $ Log.msg $ Log.val \"getHandleInfo - local lookup\"\n      maybeOwnerId <- lift $ API.lookupHandle (qUnqualified handle)\n      case maybeOwnerId of\n        Nothing -> return Nothing\n        Just ownerId -> do\n          ownerProfile <- lift $ API.lookupProfile self (Qualified ownerId domain)\n          owner <- filterHandleResults self (maybeToList ownerProfile)\n          return $ Public.UserHandleInfo . Public.profileQualifiedId <$> listToMaybe owner\n    getRemoteHandleInfo = do\n      Log.info $ (Log.msg $ Log.val \"getHandleInfo - remote lookup\") Log.~~ Log.field \"domain\" (show (qDomain handle))\n      Federation.getUserHandleInfo handle\n\nchangeHandleH :: UserId ::: ConnId ::: JsonRequest Public.HandleUpdate -> Handler Response\nchangeHandleH (u ::: conn ::: req) = do\n  empty <$ (changeHandle u conn =<< parseJsonBody req)\n\nchangeHandle :: UserId -> ConnId -> Public.HandleUpdate -> Handler ()\nchangeHandle u conn (Public.HandleUpdate h) = do\n  handle <- API.validateHandle h\n  -- TODO check here\n  API.changeHandle u (Just conn) handle API.ForbidSCIMUpdates !>> changeHandleError\n\nbeginPasswordResetH :: JSON ::: JsonRequest Public.NewPasswordReset -> Handler Response\nbeginPasswordResetH (_ ::: req) = do\n  setStatus status201 empty <$ (beginPasswordReset =<< parseJsonBody req)\n\nbeginPasswordReset :: Public.NewPasswordReset -> Handler ()\nbeginPasswordReset (Public.NewPasswordReset target) = do\n  checkWhitelist target\n  (u, pair) <- API.beginPasswordReset target !>> pwResetError\n  loc <- lift $ API.lookupLocale u\n  lift $ case target of\n    Left email -> sendPasswordResetMail email pair loc\n    Right phone -> sendPasswordResetSms phone pair loc\n\ncompletePasswordResetH :: JSON ::: JsonRequest Public.CompletePasswordReset -> Handler Response\ncompletePasswordResetH (_ ::: req) = do\n  Public.CompletePasswordReset {..} <- parseJsonBody req\n  API.completePasswordReset cpwrIdent cpwrCode cpwrPassword !>> pwResetError\n  return empty\n\nsendActivationCodeH :: JsonRequest Public.SendActivationCode -> Handler Response\nsendActivationCodeH req = do\n  empty <$ (sendActivationCode =<< parseJsonBody req)\n\n-- docs/reference/user/activation.md {#RefActivationRequest}\n-- docs/reference/user/registration.md {#RefRegistration}\nsendActivationCode :: Public.SendActivationCode -> Handler ()\nsendActivationCode Public.SendActivationCode {..} = do\n  checkWhitelist saUserKey\n  either customerExtensionCheckBlockedDomains (\\_ -> pure ()) saUserKey\n  API.sendActivationCode saUserKey saLocale saCall !>> sendActCodeError\n\n-- | If the user presents an email address from a blocked domain, throw an error.\n--\n-- The tautological constraint in the type signature is added so that once we remove the\n-- feature, ghc will guide us here.\ncustomerExtensionCheckBlockedDomains :: (DomainsBlockedForRegistration ~ DomainsBlockedForRegistration) => Public.Email -> Handler ()\ncustomerExtensionCheckBlockedDomains email = do\n  mBlockedDomains <- asks (fmap domainsBlockedForRegistration . setCustomerExtensions . view settings)\n  for_ mBlockedDomains $ \\(DomainsBlockedForRegistration blockedDomains) -> do\n    case mkDomain (Public.emailDomain email) of\n      Left _ ->\n        pure () -- if it doesn't fit the syntax of blocked domains, it is not blocked\n      Right domain ->\n        when (domain `elem` blockedDomains) $ do\n          throwM $ customerExtensionBlockedDomain domain\n\nchangeSelfEmailH :: UserId ::: ConnId ::: JsonRequest Public.EmailUpdate -> Handler Response\nchangeSelfEmailH (u ::: _ ::: req) = do\n  email <- Public.euEmail <$> parseJsonBody req\n  API.changeSelfEmail u email API.ForbidSCIMUpdates >>= \\case\n    ChangeEmailResponseIdempotent -> pure (setStatus status204 empty)\n    ChangeEmailResponseNeedsActivation -> pure (setStatus status202 empty)\n\ncreateConnectionH :: JSON ::: UserId ::: ConnId ::: JsonRequest Public.ConnectionRequest -> Handler Response\ncreateConnectionH (_ ::: self ::: conn ::: req) = do\n  cr <- parseJsonBody req\n  rs <- API.createConnection self cr conn !>> connError\n  return $ case rs of\n    ConnectionCreated c -> setStatus status201 $ json (c :: Public.UserConnection)\n    ConnectionExists c -> json (c :: Public.UserConnection)\n\nupdateConnectionH :: JSON ::: UserId ::: ConnId ::: UserId ::: JsonRequest Public.ConnectionUpdate -> Handler Response\nupdateConnectionH (_ ::: self ::: conn ::: other ::: req) = do\n  newStatus <- Public.cuStatus <$> parseJsonBody req\n  mc <- API.updateConnection self other newStatus (Just conn) !>> connError\n  return $ case mc of\n    Just c -> json (c :: Public.UserConnection)\n    Nothing -> setStatus status204 empty\n\nlistConnectionsH :: JSON ::: UserId ::: Maybe UserId ::: Range 1 500 Int32 -> Handler Response\nlistConnectionsH (_ ::: uid ::: start ::: size) =\n  json @Public.UserConnectionList\n    <$> lift (API.lookupConnections uid start size)\n\ngetConnectionH :: JSON ::: UserId ::: UserId -> Handler Response\ngetConnectionH (_ ::: uid ::: uid') = lift $ do\n  conn <- API.lookupConnection uid uid'\n  return $ case conn of\n    Just c -> json (c :: Public.UserConnection)\n    Nothing -> setStatus status404 empty\n\ndeleteUserH :: UserId ::: JsonRequest Public.DeleteUser ::: JSON -> Handler Response\ndeleteUserH (u ::: r ::: _) = do\n  body <- parseJsonBody r\n  res <- API.deleteUser u (Public.deleteUserPassword body) !>> deleteUserError\n  return $ case res of\n    Nothing -> setStatus status200 empty\n    Just ttl -> setStatus status202 (json (Public.DeletionCodeTimeout ttl))\n\nverifyDeleteUserH :: JsonRequest Public.VerifyDeleteUser ::: JSON -> Handler Response\nverifyDeleteUserH (r ::: _) = do\n  body <- parseJsonBody r\n  API.verifyDeleteUser body !>> deleteUserError\n  return (setStatus status200 empty)\n\n-- activation\n\ndata ActivationRespWithStatus\n  = ActivationResp Public.ActivationResponse\n  | ActivationRespDryRun\n  | ActivationRespPass\n  | ActivationRespSuccessNoIdent\n\nrespFromActivationRespWithStatus :: ActivationRespWithStatus -> Response\nrespFromActivationRespWithStatus = \\case\n  ActivationResp aresp -> json aresp\n  ActivationRespDryRun -> empty\n  ActivationRespPass -> setStatus status204 empty\n  ActivationRespSuccessNoIdent -> empty\n\n-- docs/reference/user/activation.md {#RefActivationSubmit}\nactivateKeyH :: JSON ::: JsonRequest Public.Activate -> Handler Response\nactivateKeyH (_ ::: req) = do\n  activationRequest <- parseJsonBody req\n  respFromActivationRespWithStatus <$> activate activationRequest\n\nactivateH :: Public.ActivationKey ::: Public.ActivationCode -> Handler Response\nactivateH (k ::: c) = do\n  let activationRequest = Public.Activate (Public.ActivateKey k) c False\n  respFromActivationRespWithStatus <$> activate activationRequest\n\nactivate :: Public.Activate -> Handler ActivationRespWithStatus\nactivate (Public.Activate tgt code dryrun)\n  | dryrun = do\n    API.preverify tgt code !>> actError\n    return $ ActivationRespDryRun\n  | otherwise = do\n    result <- API.activate tgt code Nothing !>> actError\n    return $ case result of\n      ActivationSuccess ident first -> respond ident first\n      ActivationPass -> ActivationRespPass\n  where\n    respond (Just ident) first = ActivationResp $ Public.ActivationResponse ident first\n    respond Nothing _ = ActivationRespSuccessNoIdent\n\n-- Deprecated\n\ndeprecatedOnboardingH :: JSON ::: UserId ::: JsonRequest Value -> Handler Response\ndeprecatedOnboardingH (_ ::: _ ::: _) = pure $ json DeprecatedMatchingResult\n\ndata DeprecatedMatchingResult = DeprecatedMatchingResult\n\ninstance ToJSON DeprecatedMatchingResult where\n  toJSON DeprecatedMatchingResult =\n    object\n      [ \"results\" .= ([] :: [()]),\n        \"auto-connects\" .= ([] :: [()])\n      ]\n\ndeprecatedCompletePasswordResetH :: JSON ::: Public.PasswordResetKey ::: JsonRequest Public.PasswordReset -> Handler Response\ndeprecatedCompletePasswordResetH (_ ::: k ::: req) = do\n  pwr <- parseJsonBody req\n  API.completePasswordReset\n    (Public.PasswordResetIdentityKey k)\n    (Public.pwrCode pwr)\n    (Public.pwrPassword pwr)\n    !>> pwResetError\n  return empty\n\n-- Utilities\n\nifNothing :: Utilities.Error -> Maybe a -> Handler a\nifNothing e = maybe (throwStd e) return\n\n-- | Checks search permissions and filters accordingly\nfilterHandleResults :: UserId -> [Public.UserProfile] -> Handler [Public.UserProfile]\nfilterHandleResults searchingUser us = do\n  sameTeamSearchOnly <- fromMaybe False <$> view (settings . searchSameTeamOnly)\n  if sameTeamSearchOnly\n    then do\n      fromTeam <- lift $ Data.lookupUserTeam searchingUser\n      return $ case fromTeam of\n        Just team -> filter (\\x -> Public.profileTeam x == Just team) us\n        Nothing -> us\n    else return us\n", "{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}\n\n-- This file is part of the Wire Server implementation.\n--\n-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>\n--\n-- This program is free software: you can redistribute it and/or modify it under\n-- the terms of the GNU Affero General Public License as published by the Free\n-- Software Foundation, either version 3 of the License, or (at your option) any\n-- later version.\n--\n-- This program is distributed in the hope that it will be useful, but WITHOUT\n-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n-- details.\n--\n-- You should have received a copy of the GNU Affero General Public License along\n-- with this program. If not, see <https://www.gnu.org/licenses/>.\n\nmodule API.User.Client\n  ( tests,\n  )\nwhere\n\nimport API.User.Util\nimport Bilge hiding (accept, head, timeout)\nimport Bilge.Assert\nimport qualified Brig.Options as Opt\nimport Brig.Types\nimport Brig.Types.User.Auth hiding (user)\nimport Control.Lens hiding ((#))\nimport Data.Aeson\nimport Data.Aeson.Lens\nimport Data.ByteString.Conversion\nimport Data.Id hiding (client)\nimport qualified Data.List1 as List1\nimport qualified Data.Map as Map\nimport Data.Qualified (Qualified (..))\nimport qualified Data.Set as Set\nimport qualified Data.Vector as Vec\nimport Gundeck.Types.Notification\nimport Imports\nimport qualified Network.Wai.Utilities.Error as Error\nimport Test.Tasty hiding (Timeout)\nimport Test.Tasty.Cannon hiding (Cannon)\nimport qualified Test.Tasty.Cannon as WS\nimport Test.Tasty.HUnit\nimport UnliftIO (mapConcurrently)\nimport Util\nimport Wire.API.User.Client (QualifiedUserClientMap (..), QualifiedUserClients (..), UserClientMap (..), UserClients (..))\nimport Wire.API.UserMap (QualifiedUserMap (..), UserMap (..))\n\ntests :: ConnectionLimit -> Opt.Timeout -> Opt.Opts -> Manager -> Brig -> Cannon -> Galley -> TestTree\ntests _cl _at opts p b c g =\n  testGroup\n    \"client\"\n    [ test p \"delete /clients/:client 403 - can't delete legalhold clients\" $\n        testCan'tDeleteLegalHoldClient b,\n      test p \"post /clients 400 - can't add legalhold clients manually\" $\n        testCan'tAddLegalHoldClient b,\n      test p \"get /users/:uid/prekeys - 200\" $ testGetUserPrekeys b,\n      test p \"get /users/<localdomain>/:uid/prekeys - 200\" $ testGetUserPrekeysQualified b opts,\n      test p \"get /users/:uid/prekeys/:client - 200\" $ testGetClientPrekey b,\n      test p \"get /users/<localdomain>/:uid/prekeys/:client - 200\" $ testGetClientPrekeyQualified b opts,\n      test p \"post /users/prekeys\" $ testMultiUserGetPrekeys b,\n      test p \"post /users/list-prekeys\" $ testMultiUserGetPrekeysQualified b opts,\n      test p \"post /users/list-clients - 200\" $ testListClientsBulk opts b,\n      test p \"post /clients - 201 (pwd)\" $ testAddGetClient True b c,\n      test p \"post /clients - 201 (no pwd)\" $ testAddGetClient False b c,\n      test p \"post /clients - 403\" $ testClientReauthentication b,\n      test p \"get /clients - 200\" $ testListClients b,\n      test p \"get /clients/:client/prekeys - 200\" $ testListPrekeyIds b,\n      test p \"post /clients - 400\" $ testTooManyClients opts b,\n      test p \"delete /clients/:client - 200 (pwd)\" $ testRemoveClient True b c,\n      test p \"delete /clients/:client - 200 (no pwd)\" $ testRemoveClient False b c,\n      test p \"put /clients/:client - 200\" $ testUpdateClient b,\n      test p \"post /clients - 200 multiple temporary\" $ testAddMultipleTemporary b g,\n      test p \"client/prekeys/race\" $ testPreKeyRace b\n    ]\n\ntestAddGetClient :: Bool -> Brig -> Cannon -> Http ()\ntestAddGetClient hasPwd brig cannon = do\n  uid <- userId <$> randomUser' hasPwd brig\n  let rq =\n        addClientReq brig uid (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          . header \"X-Forwarded-For\" \"127.0.0.1\" -- Fake IP to test IpAddr parsing.\n  c <- WS.bracketR cannon uid $ \\ws -> do\n    c <-\n      responseJsonError\n        =<< ( post rq <!! do\n                const 201 === statusCode\n                const True === isJust . getHeader \"Location\"\n            )\n    void . liftIO . WS.assertMatch (5 # Second) ws $ \\n -> do\n      let j = Object $ List1.head (ntfPayload n)\n      let etype = j ^? key \"type\" . _String\n      let eclient = j ^? key \"client\"\n      etype @?= Just \"user.client-add\"\n      fmap fromJSON eclient @?= Just (Success c)\n    return c\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just c) === responseJsonMaybe\n\ntestClientReauthentication :: Brig -> Http ()\ntestClientReauthentication brig = do\n  let (pk1, lk1) = (somePrekeys !! 0, someLastPrekeys !! 0)\n  let (pk2, lk2) = (somePrekeys !! 1, someLastPrekeys !! 1)\n  let (pk3, lk3) = (somePrekeys !! 2, someLastPrekeys !! 2)\n  let payload1 =\n        (defNewClient PermanentClientType [pk1] lk1)\n          { newClientPassword = Nothing\n          }\n  let payload2 =\n        (defNewClient PermanentClientType [pk2] lk2)\n          { newClientPassword = Nothing\n          }\n  let payload3 =\n        (defNewClient TemporaryClientType [pk3] lk3)\n          { newClientPassword = Nothing\n          }\n  -- User with password\n  uid <- userId <$> randomUser brig\n  -- The first client never requires authentication\n  c <- responseJsonError =<< (addClient brig uid payload1 <!! const 201 === statusCode)\n  -- Adding a second client requires reauthentication, if a password is set.\n  addClient brig uid payload2 !!! do\n    const 403 === statusCode\n    const (Just \"missing-auth\") === (fmap Error.label . responseJsonMaybe)\n  -- Removing a client requires reauthentication, if a password is set.\n  deleteClient brig uid (clientId c) Nothing !!! const 403 === statusCode\n  -- User without a password\n  uid2 <- userId <$> createAnonUser \"Mr. X\" brig\n  c2 <- responseJsonError =<< (addClient brig uid2 payload1 <!! const 201 === statusCode)\n  c3 <- responseJsonError =<< (addClient brig uid2 payload2 <!! const 201 === statusCode)\n  deleteClient brig uid2 (clientId c2) Nothing !!! const 200 === statusCode\n  deleteClient brig uid2 (clientId c3) Nothing !!! const 200 === statusCode\n  -- Temporary client can always be deleted without a password\n  c4 <- responseJsonError =<< addClient brig uid payload3\n  deleteClient brig uid (clientId c4) Nothing !!! const 200 === statusCode\n  c5 <- responseJsonError =<< addClient brig uid2 payload3\n  deleteClient brig uid2 (clientId c5) Nothing !!! const 200 === statusCode\n\ntestListClients :: Brig -> Http ()\ntestListClients brig = do\n  uid <- userId <$> randomUser brig\n  let (pk1, lk1) = (somePrekeys !! 0, (someLastPrekeys !! 0))\n  let (pk2, lk2) = (somePrekeys !! 1, (someLastPrekeys !! 1))\n  let (pk3, lk3) = (somePrekeys !! 2, (someLastPrekeys !! 2))\n  c1 <- responseJsonMaybe <$> addClient brig uid (defNewClient PermanentClientType [pk1] lk1)\n  c2 <- responseJsonMaybe <$> addClient brig uid (defNewClient PermanentClientType [pk2] lk2)\n  c3 <- responseJsonMaybe <$> addClient brig uid (defNewClient TemporaryClientType [pk3] lk3)\n  let cs = sortBy (compare `on` clientId) $ catMaybes [c1, c2, c3]\n  get\n    ( brig\n        . path \"clients\"\n        . zUser uid\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just cs) === responseJsonMaybe\n\ntestListClientsBulk :: Opt.Opts -> Brig -> Http ()\ntestListClientsBulk opts brig = do\n  uid1 <- userId <$> randomUser brig\n  let (pk11, lk11) = (somePrekeys !! 0, (someLastPrekeys !! 0))\n  let (pk12, lk12) = (somePrekeys !! 1, (someLastPrekeys !! 1))\n  let (pk13, lk13) = (somePrekeys !! 2, (someLastPrekeys !! 2))\n  c11 <- responseJsonError =<< addClient brig uid1 (defNewClient PermanentClientType [pk11] lk11)\n  c12 <- responseJsonError =<< addClient brig uid1 (defNewClient PermanentClientType [pk12] lk12)\n  c13 <- responseJsonError =<< addClient brig uid1 (defNewClient TemporaryClientType [pk13] lk13)\n\n  uid2 <- userId <$> randomUser brig\n  let (pk21, lk21) = (somePrekeys !! 3, (someLastPrekeys !! 3))\n  let (pk22, lk22) = (somePrekeys !! 4, (someLastPrekeys !! 4))\n  c21 <- responseJsonError =<< addClient brig uid2 (defNewClient PermanentClientType [pk21] lk21)\n  c22 <- responseJsonError =<< addClient brig uid2 (defNewClient PermanentClientType [pk22] lk22)\n\n  let domain = Opt.setFederationDomain $ Opt.optSettings opts\n  uid3 <- userId <$> randomUser brig\n  let mkPubClient cl = PubClient (clientId cl) (clientClass cl)\n  let expectedResponse :: QualifiedUserMap (Set PubClient) =\n        QualifiedUserMap $\n          Map.singleton\n            domain\n            ( UserMap $\n                Map.fromList\n                  [ (uid1, Set.fromList $ mkPubClient <$> [c11, c12, c13]),\n                    (uid2, Set.fromList $ mkPubClient <$> [c21, c22])\n                  ]\n            )\n  post\n    ( brig\n        . paths [\"users\", \"list-clients\"]\n        . zUser uid3\n        . contentJson\n        . body (RequestBodyLBS $ encode [Qualified uid1 domain, Qualified uid2 domain])\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just expectedResponse) === responseJsonMaybe\n\ntestListPrekeyIds :: Brig -> Http ()\ntestListPrekeyIds brig = do\n  uid <- userId <$> randomUser brig\n  let new = defNewClient PermanentClientType [somePrekeys !! 0] (someLastPrekeys !! 0)\n  c <- responseJsonError =<< addClient brig uid new\n  let pks = [PrekeyId 1, lastPrekeyId]\n  get\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c), \"prekeys\"]\n        . zUser uid\n    )\n    !!! do\n      const 200 === statusCode\n      const (Just pks) === fmap sort . responseJsonMaybe\n\ngenerateClients :: Int -> Brig -> Http [(UserId, Client, ClientPrekey, ClientPrekey)]\ngenerateClients n brig = do\n  for [1 .. n] $ \\i -> do\n    uid <- userId <$> randomUser brig\n    let new = defNewClient TemporaryClientType [somePrekeys !! i] (someLastPrekeys !! i)\n    c <- responseJsonError =<< addClient brig uid new\n    let cpk = ClientPrekey (clientId c) (somePrekeys !! i)\n    let lpk = ClientPrekey (clientId c) (unpackLastPrekey (someLastPrekeys !! i))\n    pure (uid, c, lpk, cpk)\n\ntestGetUserPrekeys :: Brig -> Http ()\ntestGetUserPrekeys brig = do\n  [(uid, _c, lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\"]) !!! do\n    const 200 === statusCode\n    const (Just $ PrekeyBundle uid [cpk]) === responseJsonMaybe\n  -- prekeys are deleted when retrieved, except the last one\n  replicateM_ 2 $\n    get (brig . paths [\"users\", toByteString' uid, \"prekeys\"]) !!! do\n      const 200 === statusCode\n      const (Just $ PrekeyBundle uid [lpk]) === responseJsonMaybe\n\ntestGetUserPrekeysQualified :: Brig -> Opt.Opts -> Http ()\ntestGetUserPrekeysQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n  [(uid, _c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' domain, toByteString' uid, \"prekeys\"]) !!! do\n    const 200 === statusCode\n    const (Just $ PrekeyBundle uid [cpk]) === responseJsonMaybe\n\ntestGetClientPrekey :: Brig -> Http ()\ntestGetClientPrekey brig = do\n  [(uid, c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ cpk) === responseJsonMaybe\n\ntestGetClientPrekeyQualified :: Brig -> Opt.Opts -> Http ()\ntestGetClientPrekeyQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n  [(uid, c, _lpk, cpk)] <- generateClients 1 brig\n  get (brig . paths [\"users\", toByteString' domain, toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ cpk) === responseJsonMaybe\n\ntestMultiUserGetPrekeys :: Brig -> Http ()\ntestMultiUserGetPrekeys brig = do\n  xs <- generateClients 3 brig\n  let userClients =\n        UserClients $\n          Map.fromList $\n            xs <&> \\(uid, c, _lpk, _cpk) ->\n              (uid, Set.fromList [clientId c])\n\n  let expectedUserClientMap =\n        UserClientMap $\n          Map.fromList $\n            xs <&> \\(uid, c, _lpk, cpk) ->\n              (uid, Map.singleton (clientId c) (Just (prekeyData cpk)))\n\n  post\n    ( brig\n        . paths [\"users\", \"prekeys\"]\n        . contentJson\n        . body (RequestBodyLBS $ encode userClients)\n    )\n    !!! do\n      const 200 === statusCode\n      const (Right $ expectedUserClientMap) === responseJsonEither\n\ntestMultiUserGetPrekeysQualified :: Brig -> Opt.Opts -> Http ()\ntestMultiUserGetPrekeysQualified brig opts = do\n  let domain = opts ^. Opt.optionSettings & Opt.setFederationDomain\n\n  xs <- generateClients 3 brig\n  let userClients =\n        QualifiedUserClients $\n          Map.singleton domain $\n            UserClients $\n              Map.fromList $\n                xs <&> \\(uid, c, _lpk, _cpk) ->\n                  (uid, Set.fromList [clientId c])\n\n  let expectedUserClientMap =\n        QualifiedUserClientMap $\n          Map.singleton domain $\n            UserClientMap $\n              Map.fromList $\n                xs <&> \\(uid, c, _lpk, cpk) ->\n                  (uid, Map.singleton (clientId c) (Just (prekeyData cpk)))\n\n  post\n    ( brig\n        . paths [\"users\", \"list-prekeys\"]\n        . contentJson\n        . body (RequestBodyLBS $ encode userClients)\n    )\n    !!! do\n      const 200 === statusCode\n      const (Right $ expectedUserClientMap) === responseJsonEither\n\ntestTooManyClients :: Opt.Opts -> Brig -> Http ()\ntestTooManyClients opts brig = do\n  uid <- userId <$> randomUser brig\n  -- We can always change the permanent client limit\n  let newOpts = opts & Opt.optionSettings . Opt.userMaxPermClients .~ Just 1\n  withSettingsOverrides newOpts $ do\n    -- There is only one temporary client, adding a new one\n    -- replaces the previous one.\n    forM_ [0 .. (3 :: Int)] $ \\i ->\n      let pk = somePrekeys !! i\n          lk = someLastPrekeys !! i\n       in addClient brig uid (defNewClient TemporaryClientType [pk] lk) !!! const 201 === statusCode\n    -- We can't add more permanent clients than configured\n    addClient brig uid (defNewClient PermanentClientType [somePrekeys !! 10] (someLastPrekeys !! 10)) !!! do\n      const 201 === statusCode\n    addClient brig uid (defNewClient PermanentClientType [somePrekeys !! 11] (someLastPrekeys !! 11)) !!! do\n      const 403 === statusCode\n      const (Just \"too-many-clients\") === fmap Error.label . responseJsonMaybe\n\ntestRemoveClient :: Bool -> Brig -> Cannon -> Http ()\ntestRemoveClient hasPwd brig cannon = do\n  u <- randomUser' hasPwd brig\n  let uid = userId u\n  let Just email = userEmail u\n  -- Permanent client with attached cookie\n  when hasPwd $ do\n    login brig (defEmailLogin email) PersistentCookie\n      !!! const 200 === statusCode\n    numCookies <- countCookies brig uid defCookieLabel\n    liftIO $ Just 1 @=? numCookies\n  c <- responseJsonError =<< addClient brig uid (client PermanentClientType (someLastPrekeys !! 10))\n  when hasPwd $ do\n    -- Missing password\n    deleteClient brig uid (clientId c) Nothing !!! const 403 === statusCode\n  -- Success\n  WS.bracketR cannon uid $ \\ws -> do\n    deleteClient brig uid (clientId c) (if hasPwd then Just defPassword else Nothing)\n      !!! const 200 === statusCode\n    void . liftIO . WS.assertMatch (5 # Second) ws $ \\n -> do\n      let j = Object $ List1.head (ntfPayload n)\n      let etype = j ^? key \"type\" . _String\n      let eclient = j ^? key \"client\" . key \"id\" . _String\n      etype @?= Just \"user.client-remove\"\n      fmap ClientId eclient @?= Just (clientId c)\n  -- Not found on retry\n  deleteClient brig uid (clientId c) Nothing !!! const 404 === statusCode\n  -- Prekeys are gone\n  getPreKey brig uid (clientId c) !!! const 404 === statusCode\n  -- Cookies are gone\n  numCookies' <- countCookies brig (userId u) defCookieLabel\n  liftIO $ Just 0 @=? numCookies'\n  where\n    client ty lk =\n      (defNewClient ty [somePrekeys !! 0] lk)\n        { newClientLabel = Just \"Nexus 5x\",\n          newClientCookie = Just defCookieLabel\n        }\n\ntestUpdateClient :: Brig -> Http ()\ntestUpdateClient brig = do\n  uid <- userId <$> randomUser brig\n  let clt =\n        (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone\"\n          }\n  c <- responseJsonError =<< addClient brig uid clt\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ ClientPrekey (clientId c) (somePrekeys !! 0)) === responseJsonMaybe\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"Test Device\") === (clientLabel <=< responseJsonMaybe)\n    const (Just PhoneClient) === (clientClass <=< responseJsonMaybe)\n    const (Just \"featurephone\") === (clientModel <=< responseJsonMaybe)\n  let newPrekey = somePrekeys !! 2\n  let update = UpdateClient [newPrekey] Nothing (Just \"label\")\n  put\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c)]\n        . zUser uid\n        . contentJson\n        . body (RequestBodyLBS $ encode update)\n    )\n    !!! const 200\n    === statusCode\n  get (brig . paths [\"users\", toByteString' uid, \"prekeys\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ ClientPrekey (clientId c) newPrekey) === responseJsonMaybe\n  -- check if label has been updated\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"label\") === (clientLabel <=< responseJsonMaybe)\n  -- via `/users/:uid/clients/:client`, only `id` and `class` are visible:\n  get (brig . paths [\"users\", toByteString' uid, \"clients\", toByteString' (clientId c)]) !!! do\n    const 200 === statusCode\n    const (Just $ clientId c) === (fmap pubClientId . responseJsonMaybe)\n    const (Just PhoneClient) === (pubClientClass <=< responseJsonMaybe)\n    const Nothing === (preview (key \"label\") <=< responseJsonMaybe @Value)\n  let update' = UpdateClient [] Nothing Nothing\n  -- empty update should be a no-op\n  put\n    ( brig\n        . paths [\"clients\", toByteString' (clientId c)]\n        . zUser uid\n        . contentJson\n        . body (RequestBodyLBS $ encode update')\n    )\n    !!! const 200\n    === statusCode\n  -- check if label is still present\n  getClient brig uid (clientId c) !!! do\n    const 200 === statusCode\n    const (Just \"label\") === (clientLabel <=< responseJsonMaybe)\n\n-- Legacy (galley)\ntestAddMultipleTemporary :: Brig -> Galley -> Http ()\ntestAddMultipleTemporary brig galley = do\n  uid <- userId <$> randomUser brig\n  let clt1 =\n        (defNewClient TemporaryClientType [somePrekeys !! 0] (someLastPrekeys !! 0))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone1\"\n          }\n  _ <- addClient brig uid clt1\n  brigClients1 <- numOfBrigClients uid\n  galleyClients1 <- numOfGalleyClients uid\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) brigClients1\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) galleyClients1\n  let clt2 =\n        (defNewClient TemporaryClientType [somePrekeys !! 1] (someLastPrekeys !! 1))\n          { newClientClass = Just PhoneClient,\n            newClientModel = Just \"featurephone2\"\n          }\n  _ <- addClient brig uid clt2\n  brigClients2 <- numOfBrigClients uid\n  galleyClients2 <- numOfGalleyClients uid\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) brigClients2\n  liftIO $ assertEqual \"Too many clients found\" (Just 1) galleyClients2\n  where\n    numOfBrigClients u = do\n      r <-\n        get $\n          brig\n            . path \"clients\"\n            . zUser u\n      return $ Vec.length <$> (preview _Array =<< responseJsonMaybe @Value r)\n    numOfGalleyClients u = do\n      r <-\n        get $\n          galley\n            . path \"i/test/clients\"\n            . zUser u\n      return $ Vec.length <$> (preview _Array =<< responseJsonMaybe @Value r)\n\ntestPreKeyRace :: Brig -> Http ()\ntestPreKeyRace brig = do\n  uid <- userId <$> randomUser brig\n  let pks = map (\\i -> somePrekeys !! i) [1 .. 10]\n  c <- responseJsonError =<< addClient brig uid (defNewClient PermanentClientType pks (someLastPrekeys !! 0))\n  pks' <- flip mapConcurrently pks $ \\_ -> do\n    rs <- getPreKey brig uid (clientId c) <!! const 200 === statusCode\n    return $ prekeyId . prekeyData <$> responseJsonMaybe rs\n  -- We should not hand out regular prekeys more than once (i.e. at most once).\n  let actual = catMaybes pks'\n  liftIO $ assertEqual \"insufficient prekeys\" (length pks) (length actual)\n  let regular = filter (/= lastPrekeyId) actual\n  liftIO $ assertEqual \"duplicate prekeys\" (length regular) (length (nub regular))\n  deleteClient brig uid (clientId c) (Just defPassword) !!! const 200 === statusCode\n\ntestCan'tDeleteLegalHoldClient :: Brig -> Http ()\ntestCan'tDeleteLegalHoldClient brig = do\n  let hasPassword = False\n  user <- randomUser' hasPassword brig\n  let uid = userId user\n  let pk = head somePrekeys\n  let lk = head someLastPrekeys\n  resp <-\n    addClientInternal brig uid (defNewClient LegalHoldClientType [pk] lk)\n      <!! const 201 === statusCode\n  lhClientId <- clientId <$> responseJsonError resp\n  deleteClient brig uid lhClientId Nothing !!! const 400 === statusCode\n\ntestCan'tAddLegalHoldClient :: Brig -> Http ()\ntestCan'tAddLegalHoldClient brig = do\n  let hasPassword = False\n  user <- randomUser' hasPassword brig\n  let uid = userId user\n  let pk = head somePrekeys\n  let lk = head someLastPrekeys\n  -- Regular users cannot add legalhold clients\n  addClient brig uid (defNewClient LegalHoldClientType [pk] lk) !!! const 400 === statusCode\n"], "filenames": ["libs/wire-api/src/Wire/API/User/Client.hs", "libs/wire-api/src/Wire/API/UserMap.hs", "libs/wire-api/test/unit/Test/Wire/API/Swagger.hs", "services/brig/src/Brig/API/Public.hs", "services/brig/test/integration/API/User/Client.hs"], "buggy_code_start_loc": [315, 18, 39, 73, 181], "buggy_code_end_loc": [316, 44, 44, 1154, 187], "fixing_code_start_loc": [315, 17, 40, 74, 181], "fixing_code_end_loc": [318, 48, 45, 1155, 191], "type": "CWE-200", "message": "wire-server is an open-source back end for Wire, a secure collaboration platform. In wire-server from version 2021-02-16 and before version 2021-03-02, the client metadata of all users was exposed in the `GET /users/list-clients` endpoint. The endpoint could be used by any logged in user who could request client details of any other user (no connection required) as far as they can find their User ID. The exposed metadata included id, class, type, location, time, and cookie. A user on a Wire backend could use this endpoint to find registration time and location for each device for a given list of users. As a workaround, remove `/list-clients` from nginx config. This has been fixed in version 2021-03-02.", "other": {"cve": {"id": "CVE-2021-21396", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-26T22:15:12.947", "lastModified": "2021-08-27T15:05:47.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wire-server is an open-source back end for Wire, a secure collaboration platform. In wire-server from version 2021-02-16 and before version 2021-03-02, the client metadata of all users was exposed in the `GET /users/list-clients` endpoint. The endpoint could be used by any logged in user who could request client details of any other user (no connection required) as far as they can find their User ID. The exposed metadata included id, class, type, location, time, and cookie. A user on a Wire backend could use this endpoint to find registration time and location for each device for a given list of users. As a workaround, remove `/list-clients` from nginx config. This has been fixed in version 2021-03-02."}, {"lang": "es", "value": "wire-server es un back-end de c\u00f3digo abierto para Wire, una plataforma de colaboraci\u00f3n segura.&#xa0;En wire-server desde la versi\u00f3n 16-02-2021 y versiones anteriores a 02-03-2021, los metadatos del cliente de todos los usuarios estaban expuestos en el endpoint \"GET/users/list-clients\".&#xa0;El endpoint puede ser usado por cualquier usuario con inicio de sesi\u00f3n y que pueda pedir los detalles del cliente de cualquier otro usuario (no se requiere conexi\u00f3n) en la medida en que pueda encontrar su ID de usuario.&#xa0;Los metadatos expuestos inclu\u00edan id, clase, tipo, ubicaci\u00f3n, hora y cookie.&#xa0;Un usuario en un backend Wire podr\u00eda usar este endpoint para encontrar la hora y la ubicaci\u00f3n de registro para cada dispositivo para una lista determinada de usuarios.&#xa0;Como soluci\u00f3n alternativa, elimine \"/list-clients\" de la configuraci\u00f3n de nginx.&#xa0;Esto ha sido corregido en la versi\u00f3n 02-03-2021."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "2021-02-16", "versionEndExcluding": "2021-03-02", "matchCriteriaId": "A94419C1-B8CA-4FC7-9DE7-A7E672A524D4"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-server/commit/7ba2bf4140282557cf215e0b2c354d4d08cd3421", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-server/releases/tag/v2021-03-02", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-server/security/advisories/GHSA-qx8q-rhq2-rg4j", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-server/commit/7ba2bf4140282557cf215e0b2c354d4d08cd3421"}}