{"buggy_code": ["\n/*\n * Copyright (C) Xiaozhe Wang (chaoslawful)\n * Copyright (C) Yichun Zhang (agentzh)\n */\n\n\n#ifndef DDEBUG\n#define DDEBUG 0\n#endif\n#include \"ddebug.h\"\n\n\n#include \"ngx_http_lua_subrequest.h\"\n#include \"ngx_http_lua_util.h\"\n#include \"ngx_http_lua_ctx.h\"\n#include \"ngx_http_lua_contentby.h\"\n#include \"ngx_http_lua_headers_in.h\"\n#if defined(NGX_DTRACE) && NGX_DTRACE\n#include \"ngx_http_probe.h\"\n#endif\n\n\n#define NGX_HTTP_LUA_SHARE_ALL_VARS     0x01\n#define NGX_HTTP_LUA_COPY_ALL_VARS      0x02\n\n\n#define ngx_http_lua_method_name(m) { sizeof(m) - 1, (u_char *) m \" \" }\n\n\nngx_str_t  ngx_http_lua_get_method = ngx_http_lua_method_name(\"GET\");\nngx_str_t  ngx_http_lua_put_method = ngx_http_lua_method_name(\"PUT\");\nngx_str_t  ngx_http_lua_post_method = ngx_http_lua_method_name(\"POST\");\nngx_str_t  ngx_http_lua_head_method = ngx_http_lua_method_name(\"HEAD\");\nngx_str_t  ngx_http_lua_delete_method =\n        ngx_http_lua_method_name(\"DELETE\");\nngx_str_t  ngx_http_lua_options_method =\n        ngx_http_lua_method_name(\"OPTIONS\");\nngx_str_t  ngx_http_lua_copy_method = ngx_http_lua_method_name(\"COPY\");\nngx_str_t  ngx_http_lua_move_method = ngx_http_lua_method_name(\"MOVE\");\nngx_str_t  ngx_http_lua_lock_method = ngx_http_lua_method_name(\"LOCK\");\nngx_str_t  ngx_http_lua_mkcol_method =\n        ngx_http_lua_method_name(\"MKCOL\");\nngx_str_t  ngx_http_lua_propfind_method =\n        ngx_http_lua_method_name(\"PROPFIND\");\nngx_str_t  ngx_http_lua_proppatch_method =\n        ngx_http_lua_method_name(\"PROPPATCH\");\nngx_str_t  ngx_http_lua_unlock_method =\n        ngx_http_lua_method_name(\"UNLOCK\");\nngx_str_t  ngx_http_lua_patch_method =\n        ngx_http_lua_method_name(\"PATCH\");\nngx_str_t  ngx_http_lua_trace_method =\n        ngx_http_lua_method_name(\"TRACE\");\n\n\nstatic ngx_str_t  ngx_http_lua_content_length_header_key =\n    ngx_string(\"Content-Length\");\n\n\nstatic ngx_int_t ngx_http_lua_set_content_length_header(ngx_http_request_t *r,\n    off_t len);\nstatic ngx_int_t ngx_http_lua_adjust_subrequest(ngx_http_request_t *sr,\n    ngx_uint_t method, int forward_body,\n    ngx_http_request_body_t *body, unsigned vars_action,\n    ngx_array_t *extra_vars);\nstatic int ngx_http_lua_ngx_location_capture(lua_State *L);\nstatic int ngx_http_lua_ngx_location_capture_multi(lua_State *L);\nstatic void ngx_http_lua_process_vars_option(ngx_http_request_t *r,\n    lua_State *L, int table, ngx_array_t **varsp);\nstatic ngx_int_t ngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *r,\n    ngx_array_t *extra_vars);\nstatic ngx_int_t ngx_http_lua_subrequest(ngx_http_request_t *r,\n    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n    ngx_http_post_subrequest_t *ps, ngx_uint_t flags);\nstatic ngx_int_t ngx_http_lua_subrequest_resume(ngx_http_request_t *r);\nstatic void ngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,\n    ngx_http_lua_ctx_t *ctx);\nstatic void ngx_http_lua_cancel_subreq(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_post_request_to_head(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *r);\n\n\nenum {\n    NGX_HTTP_LUA_SUBREQ_TRUNCATED = 1,\n};\n\n\n/* ngx.location.capture is just a thin wrapper around\n * ngx.location.capture_multi */\nstatic int\nngx_http_lua_ngx_location_capture(lua_State *L)\n{\n    int                 n;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting one or two arguments\");\n    }\n\n    lua_createtable(L, n, 0); /* uri opts? table  */\n    lua_insert(L, 1); /* table uri opts? */\n    if (n == 1) { /* table uri */\n        lua_rawseti(L, 1, 1); /* table */\n\n    } else { /* table uri opts */\n        lua_rawseti(L, 1, 2); /* table uri */\n        lua_rawseti(L, 1, 1); /* table */\n    }\n\n    lua_createtable(L, 1, 0); /* table table' */\n    lua_insert(L, 1);   /* table' table */\n    lua_rawseti(L, 1, 1); /* table' */\n\n    return ngx_http_lua_ngx_location_capture_multi(L);\n}\n\n\nstatic int\nngx_http_lua_ngx_location_capture_multi(lua_State *L)\n{\n    ngx_http_request_t              *r;\n    ngx_http_request_t              *sr = NULL; /* subrequest object */\n    ngx_http_post_subrequest_t      *psr;\n    ngx_http_lua_ctx_t              *sr_ctx;\n    ngx_http_lua_ctx_t              *ctx;\n    ngx_array_t                     *extra_vars;\n    ngx_str_t                        uri;\n    ngx_str_t                        args;\n    ngx_str_t                        extra_args;\n    ngx_uint_t                       flags;\n    u_char                          *p;\n    u_char                          *q;\n    size_t                           len;\n    size_t                           nargs;\n    int                              rc;\n    int                              n;\n    int                              always_forward_body = 0;\n    ngx_uint_t                       method;\n    ngx_http_request_body_t         *body;\n    int                              type;\n    ngx_buf_t                       *b;\n    unsigned                         vars_action;\n    ngx_uint_t                       nsubreqs;\n    ngx_uint_t                       index;\n    size_t                           sr_statuses_len;\n    size_t                           sr_headers_len;\n    size_t                           sr_bodies_len;\n    size_t                           sr_flags_len;\n    size_t                           ofs1, ofs2;\n    unsigned                         custom_ctx;\n    ngx_http_lua_co_ctx_t           *coctx;\n\n    ngx_http_lua_post_subrequest_data_t      *psr_data;\n\n    n = lua_gettop(L);\n    if (n != 1) {\n        return luaL_error(L, \"only one argument is expected, but got %d\", n);\n    }\n\n    luaL_checktype(L, 1, LUA_TTABLE);\n\n    nsubreqs = lua_objlen(L, 1);\n    if (nsubreqs == 0) {\n        return luaL_error(L, \"at least one subrequest should be specified\");\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request object found\");\n    }\n\n#if (NGX_HTTP_V2)\n    if (r->main->stream) {\n        return luaL_error(L, \"http2 requests not supported yet\");\n    }\n#endif\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return luaL_error(L, \"no ctx found\");\n    }\n\n    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE\n                               | NGX_HTTP_LUA_CONTEXT_ACCESS\n                               | NGX_HTTP_LUA_CONTEXT_CONTENT);\n\n    coctx = ctx->cur_co_ctx;\n    if (coctx == NULL) {\n        return luaL_error(L, \"no co ctx found\");\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua location capture, uri:\\\"%V\\\" c:%ud\", &r->uri,\n                   r->main->count);\n\n    sr_statuses_len = nsubreqs * sizeof(ngx_int_t);\n    sr_headers_len  = nsubreqs * sizeof(ngx_http_headers_out_t *);\n    sr_bodies_len   = nsubreqs * sizeof(ngx_str_t);\n    sr_flags_len    = nsubreqs * sizeof(uint8_t);\n\n    p = ngx_pcalloc(r->pool, sr_statuses_len + sr_headers_len +\n                    sr_bodies_len + sr_flags_len);\n\n    if (p == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    coctx->sr_statuses = (void *) p;\n    p += sr_statuses_len;\n\n    coctx->sr_headers = (void *) p;\n    p += sr_headers_len;\n\n    coctx->sr_bodies = (void *) p;\n    p += sr_bodies_len;\n\n    coctx->sr_flags = (void *) p;\n\n    coctx->nsubreqs = nsubreqs;\n\n    coctx->pending_subreqs = 0;\n\n    extra_vars = NULL;\n\n    for (index = 0; index < nsubreqs; index++) {\n        coctx->pending_subreqs++;\n\n        lua_rawgeti(L, 1, index + 1);\n        if (lua_isnil(L, -1)) {\n            return luaL_error(L, \"only array-like tables are allowed\");\n        }\n\n        dd(\"queries query: top %d\", lua_gettop(L));\n\n        if (lua_type(L, -1) != LUA_TTABLE) {\n            return luaL_error(L, \"the query argument %d is not a table, \"\n                              \"but a %s\",\n                              index, lua_typename(L, lua_type(L, -1)));\n        }\n\n        nargs = lua_objlen(L, -1);\n\n        if (nargs != 1 && nargs != 2) {\n            return luaL_error(L, \"query argument %d expecting one or \"\n                              \"two arguments\", index);\n        }\n\n        lua_rawgeti(L, 2, 1); /* queries query uri */\n\n        dd(\"queries query uri: %d\", lua_gettop(L));\n\n        dd(\"first arg in first query: %s\", lua_typename(L, lua_type(L, -1)));\n\n        body = NULL;\n\n        ngx_str_null(&extra_args);\n\n        if (extra_vars != NULL) {\n            /* flush out existing elements in the array */\n            extra_vars->nelts = 0;\n        }\n\n        vars_action = 0;\n\n        custom_ctx = 0;\n\n        if (nargs == 2) {\n            /* check out the options table */\n\n            lua_rawgeti(L, 2, 2); /* queries query uri opts */\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            if (lua_type(L, 4) != LUA_TTABLE) {\n                return luaL_error(L, \"expecting table as the 2nd argument for \"\n                                  \"subrequest %d, but got %s\", index,\n                                  luaL_typename(L, 4));\n            }\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the args option */\n\n            lua_getfield(L, 4, \"args\");\n\n            type = lua_type(L, -1);\n\n            switch (type) {\n            case LUA_TTABLE:\n                ngx_http_lua_process_args_option(r, L, -1, &extra_args);\n                break;\n\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TNUMBER:\n            case LUA_TSTRING:\n                extra_args.data = (u_char *) lua_tolstring(L, -1, &len);\n                extra_args.len = len;\n\n                break;\n\n            default:\n                return luaL_error(L, \"Bad args option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the vars option */\n\n            lua_getfield(L, 4, \"vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TTABLE:\n                ngx_http_lua_process_vars_option(r, L, -1, &extra_vars);\n\n                dd(\"post process vars top: %d\", lua_gettop(L));\n                break;\n\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            default:\n                return luaL_error(L, \"Bad vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the share_all_vars option */\n\n            lua_getfield(L, 4, \"share_all_vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TBOOLEAN:\n                if (lua_toboolean(L, -1)) {\n                    vars_action |= NGX_HTTP_LUA_SHARE_ALL_VARS;\n                }\n                break;\n\n            default:\n                return luaL_error(L, \"Bad share_all_vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the copy_all_vars option */\n\n            lua_getfield(L, 4, \"copy_all_vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TBOOLEAN:\n                if (lua_toboolean(L, -1)) {\n                    vars_action |= NGX_HTTP_LUA_COPY_ALL_VARS;\n                }\n                break;\n\n            default:\n                return luaL_error(L, \"Bad copy_all_vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the \"forward_body\" option */\n\n            lua_getfield(L, 4, \"always_forward_body\");\n            always_forward_body = lua_toboolean(L, -1);\n            lua_pop(L, 1);\n\n            dd(\"always forward body: %d\", always_forward_body);\n\n            /* check the \"method\" option */\n\n            lua_getfield(L, 4, \"method\");\n\n            type = lua_type(L, -1);\n\n            if (type == LUA_TNIL) {\n                method = NGX_HTTP_GET;\n\n            } else {\n                if (type != LUA_TNUMBER) {\n                    return luaL_error(L, \"Bad http request method\");\n                }\n\n                method = (ngx_uint_t) lua_tonumber(L, -1);\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the \"ctx\" option */\n\n            lua_getfield(L, 4, \"ctx\");\n\n            type = lua_type(L, -1);\n\n            if (type != LUA_TNIL) {\n                if (type != LUA_TTABLE) {\n                    return luaL_error(L, \"Bad ctx option value type %s, \"\n                                      \"expected a Lua table\",\n                                      lua_typename(L, type));\n                }\n\n                custom_ctx = 1;\n\n            } else {\n                lua_pop(L, 1);\n            }\n\n            dd(\"queries query uri opts ctx?: %d\", lua_gettop(L));\n\n            /* check the \"body\" option */\n\n            lua_getfield(L, 4, \"body\");\n\n            type = lua_type(L, -1);\n\n            if (type != LUA_TNIL) {\n                if (type != LUA_TSTRING && type != LUA_TNUMBER) {\n                    return luaL_error(L, \"Bad http request body\");\n                }\n\n                body = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));\n\n                if (body == NULL) {\n                    return luaL_error(L, \"no memory\");\n                }\n\n                q = (u_char *) lua_tolstring(L, -1, &len);\n\n                dd(\"request body: [%.*s]\", (int) len, q);\n\n                if (len) {\n                    b = ngx_create_temp_buf(r->pool, len);\n                    if (b == NULL) {\n                        return luaL_error(L, \"no memory\");\n                    }\n\n                    b->last = ngx_copy(b->last, q, len);\n\n                    body->bufs = ngx_alloc_chain_link(r->pool);\n                    if (body->bufs == NULL) {\n                        return luaL_error(L, \"no memory\");\n                    }\n\n                    body->bufs->buf = b;\n                    body->bufs->next = NULL;\n\n                    body->buf = b;\n                }\n            }\n\n            lua_pop(L, 1); /* pop the body */\n\n            /* stack: queries query uri opts ctx? */\n\n            lua_remove(L, 4);\n\n            /* stack: queries query uri ctx? */\n\n            dd(\"queries query uri ctx?: %d\", lua_gettop(L));\n\n        } else {\n            method = NGX_HTTP_GET;\n        }\n\n        /* stack: queries query uri ctx? */\n\n        p = (u_char *) luaL_checklstring(L, 3, &len);\n\n        uri.data = ngx_palloc(r->pool, len);\n        if (uri.data == NULL) {\n            return luaL_error(L, \"memory allocation error\");\n        }\n\n        ngx_memcpy(uri.data, p, len);\n\n        uri.len = len;\n\n        ngx_str_null(&args);\n\n        flags = 0;\n\n        rc = ngx_http_parse_unsafe_uri(r, &uri, &args, &flags);\n        if (rc != NGX_OK) {\n            dd(\"rc = %d\", (int) rc);\n\n            return luaL_error(L, \"unsafe uri in argument #1: %s\", p);\n        }\n\n        if (args.len == 0) {\n            if (extra_args.len) {\n                p = ngx_palloc(r->pool, extra_args.len);\n                if (p == NULL) {\n                    return luaL_error(L, \"no memory\");\n                }\n\n                ngx_memcpy(p, extra_args.data, extra_args.len);\n\n                args.data = p;\n                args.len = extra_args.len;\n            }\n\n        } else if (extra_args.len) {\n            /* concatenate the two parts of args together */\n            len = args.len + (sizeof(\"&\") - 1) + extra_args.len;\n\n            p = ngx_palloc(r->pool, len);\n            if (p == NULL) {\n                return luaL_error(L, \"no memory\");\n            }\n\n            q = ngx_copy(p, args.data, args.len);\n            *q++ = '&';\n            ngx_memcpy(q, extra_args.data, extra_args.len);\n\n            args.data = p;\n            args.len = len;\n        }\n\n        ofs1 = ngx_align(sizeof(ngx_http_post_subrequest_t), sizeof(void *));\n        ofs2 = ngx_align(sizeof(ngx_http_lua_ctx_t), sizeof(void *));\n\n        p = ngx_palloc(r->pool, ofs1 + ofs2\n                       + sizeof(ngx_http_lua_post_subrequest_data_t));\n        if (p == NULL) {\n            return luaL_error(L, \"no memory\");\n        }\n\n        psr = (ngx_http_post_subrequest_t *) p;\n\n        p += ofs1;\n\n        sr_ctx = (ngx_http_lua_ctx_t *) p;\n\n        ngx_http_lua_assert((void *) sr_ctx == ngx_align_ptr(sr_ctx,\n                                                             sizeof(void *)));\n\n        p += ofs2;\n\n        psr_data = (ngx_http_lua_post_subrequest_data_t *) p;\n\n        ngx_http_lua_assert((void *) psr_data == ngx_align_ptr(psr_data,\n                                                               sizeof(void *)));\n\n        ngx_memzero(sr_ctx, sizeof(ngx_http_lua_ctx_t));\n\n        /* set by ngx_memzero:\n         *      sr_ctx->run_post_subrequest = 0\n         *      sr_ctx->free = NULL\n         *      sr_ctx->body = NULL\n         */\n\n        psr_data->ctx = sr_ctx;\n        psr_data->pr_co_ctx = coctx;\n\n        psr->handler = ngx_http_lua_post_subrequest;\n        psr->data = psr_data;\n\n        rc = ngx_http_lua_subrequest(r, &uri, &args, &sr, psr, 0);\n\n        if (rc != NGX_OK) {\n            return luaL_error(L, \"failed to issue subrequest: %d\", (int) rc);\n        }\n\n        ngx_http_lua_init_ctx(sr, sr_ctx);\n\n        sr_ctx->capture = 1;\n        sr_ctx->index = index;\n        sr_ctx->last_body = &sr_ctx->body;\n        sr_ctx->vm_state = ctx->vm_state;\n\n        ngx_http_set_ctx(sr, sr_ctx, ngx_http_lua_module);\n\n        rc = ngx_http_lua_adjust_subrequest(sr, method, always_forward_body,\n                                            body, vars_action, extra_vars);\n\n        if (rc != NGX_OK) {\n            ngx_http_lua_cancel_subreq(sr);\n            return luaL_error(L, \"failed to adjust the subrequest: %d\",\n                              (int) rc);\n        }\n\n        dd(\"queries query uri opts ctx? %d\", lua_gettop(L));\n\n        /* stack: queries query uri ctx? */\n\n        if (custom_ctx) {\n            ngx_http_lua_ngx_set_ctx_helper(L, sr, sr_ctx, -1);\n            lua_pop(L, 3);\n\n        } else {\n            lua_pop(L, 2);\n        }\n\n        /* stack: queries */\n    }\n\n    if (extra_vars) {\n        ngx_array_destroy(extra_vars);\n    }\n\n    ctx->no_abort = 1;\n\n    return lua_yield(L, 0);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_int_t                    rc;\n    ngx_http_core_main_conf_t   *cmcf;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n        rc = ngx_http_lua_set_content_length_header(sr,\n                                                    body->buf\n                                                    ? ngx_buf_size(body->buf)\n                                                    : 0);\n\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        rc = ngx_http_lua_set_content_length_header(sr, 0);\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n#if 1\n        sr->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (sr->request_body) {\n\n            /* deep-copy the request body */\n\n            if (sr->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *sr,\n    ngx_array_t *extra_vars)\n{\n    ngx_http_core_main_conf_t   *cmcf;\n    ngx_http_variable_t         *v;\n    ngx_http_variable_value_t   *vv;\n    u_char                      *val;\n    u_char                      *p;\n    ngx_uint_t                   i, hash;\n    ngx_str_t                    name;\n    size_t                       len;\n    ngx_hash_t                  *variables_hash;\n    ngx_keyval_t                *var;\n\n    /* set any extra variables that were passed to the subrequest */\n\n    if (extra_vars == NULL || extra_vars->nelts == 0) {\n        return NGX_OK;\n    }\n\n    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n    variables_hash = &cmcf->variables_hash;\n\n    var = extra_vars->elts;\n\n    for (i = 0; i < extra_vars->nelts; i++, var++) {\n        /* copy the variable's name and value because they are allocated\n         * by the lua VM */\n\n        len = var->key.len + var->value.len;\n\n        p = ngx_pnalloc(sr->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        name.data = p;\n        name.len = var->key.len;\n\n        p = ngx_copy(p, var->key.data, var->key.len);\n\n        hash = ngx_hash_strlow(name.data, name.data, name.len);\n\n        val = p;\n        len = var->value.len;\n\n        ngx_memcpy(p, var->value.data, len);\n\n        v = ngx_hash_find(variables_hash, hash, name.data, name.len);\n\n        if (v) {\n            if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {\n                ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                              \"variable \\\"%V\\\" not changeable\", &name);\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            if (v->set_handler) {\n                vv = ngx_palloc(sr->pool, sizeof(ngx_http_variable_value_t));\n                if (vv == NULL) {\n                    return NGX_ERROR;\n                }\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                v->set_handler(sr, vv, v->data);\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\", &name,\n                               vv);\n\n                continue;\n            }\n\n            if (v->flags & NGX_HTTP_VAR_INDEXED) {\n                vv = &sr->variables[v->index];\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\",\n                               &name, vv);\n\n                continue;\n            }\n        }\n\n        ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                      \"variable \\\"%V\\\" cannot be assigned a value (maybe you \"\n                      \"forgot to define it first?) \", &name);\n\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_lua_process_vars_option(ngx_http_request_t *r, lua_State *L,\n    int table, ngx_array_t **varsp)\n{\n    ngx_array_t         *vars;\n    ngx_keyval_t        *var;\n\n    if (table < 0) {\n        table = lua_gettop(L) + table + 1;\n    }\n\n    vars = *varsp;\n\n    if (vars == NULL) {\n\n        vars = ngx_array_create(r->pool, 4, sizeof(ngx_keyval_t));\n        if (vars == NULL) {\n            dd(\"here\");\n            luaL_error(L, \"no memory\");\n            return;\n        }\n\n        *varsp = vars;\n    }\n\n    lua_pushnil(L);\n    while (lua_next(L, table) != 0) {\n\n        if (lua_type(L, -2) != LUA_TSTRING) {\n            luaL_error(L, \"attempt to use a non-string key in the \"\n                       \"\\\"vars\\\" option table\");\n            return;\n        }\n\n        if (!lua_isstring(L, -1)) {\n            luaL_error(L, \"attempt to use bad variable value type %s\",\n                       luaL_typename(L, -1));\n            return;\n        }\n\n        var = ngx_array_push(vars);\n        if (var == NULL) {\n            dd(\"here\");\n            luaL_error(L, \"no memory\");\n            return;\n        }\n\n        var->key.data = (u_char *) lua_tolstring(L, -2, &var->key.len);\n        var->value.data = (u_char *) lua_tolstring(L, -1, &var->value.len);\n\n        lua_pop(L, 1);\n    }\n}\n\n\nngx_int_t\nngx_http_lua_post_subrequest(ngx_http_request_t *r, void *data, ngx_int_t rc)\n{\n    ngx_http_request_t            *pr;\n    ngx_http_lua_ctx_t            *pr_ctx;\n    ngx_http_lua_ctx_t            *ctx; /* subrequest ctx */\n    ngx_http_lua_co_ctx_t         *pr_coctx;\n    size_t                         len;\n    ngx_str_t                     *body_str;\n    u_char                        *p;\n    ngx_chain_t                   *cl;\n\n    ngx_http_lua_post_subrequest_data_t    *psr_data = data;\n\n    ctx = psr_data->ctx;\n\n    if (ctx->run_post_subrequest) {\n        if (r != r->connection->data) {\n            r->connection->data = r;\n        }\n\n        return NGX_OK;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run post subrequest handler, rc:%i c:%ud\", rc,\n                   r->main->count);\n\n    ctx->run_post_subrequest = 1;\n\n    pr = r->parent;\n\n    pr_ctx = ngx_http_get_module_ctx(pr, ngx_http_lua_module);\n    if (pr_ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    pr_coctx = psr_data->pr_co_ctx;\n    pr_coctx->pending_subreqs--;\n\n    if (pr_coctx->pending_subreqs == 0) {\n        dd(\"all subrequests are done\");\n\n        pr_ctx->no_abort = 0;\n        pr_ctx->resume_handler = ngx_http_lua_subrequest_resume;\n        pr_ctx->cur_co_ctx = pr_coctx;\n    }\n\n    if (pr_ctx->entered_content_phase) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"lua restoring write event handler\");\n\n        pr->write_event_handler = ngx_http_lua_content_wev_handler;\n\n    } else {\n        pr->write_event_handler = ngx_http_core_run_phases;\n    }\n\n    dd(\"status rc = %d\", (int) rc);\n    dd(\"status headers_out.status = %d\", (int) r->headers_out.status);\n    dd(\"uri: %.*s\", (int) r->uri.len, r->uri.data);\n\n    /*  capture subrequest response status */\n\n    pr_coctx->sr_statuses[ctx->index] = r->headers_out.status;\n\n    if (pr_coctx->sr_statuses[ctx->index] == 0) {\n        if (rc == NGX_OK) {\n            rc = NGX_HTTP_OK;\n        }\n\n        if (rc == NGX_ERROR) {\n            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (rc >= 100) {\n            pr_coctx->sr_statuses[ctx->index] = rc;\n        }\n    }\n\n    if (!ctx->seen_last_for_subreq) {\n        pr_coctx->sr_flags[ctx->index] |= NGX_HTTP_LUA_SUBREQ_TRUNCATED;\n    }\n\n    dd(\"pr_coctx status: %d\", (int) pr_coctx->sr_statuses[ctx->index]);\n\n    /* copy subrequest response headers */\n    if (ctx->headers_set) {\n        rc = ngx_http_lua_set_content_type(r, ctx);\n        if (rc != NGX_OK) {\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"failed to set default content type: %i\", rc);\n            return NGX_ERROR;\n        }\n    }\n\n    pr_coctx->sr_headers[ctx->index] = &r->headers_out;\n\n    /* copy subrequest response body */\n\n    body_str = &pr_coctx->sr_bodies[ctx->index];\n\n    len = 0;\n    for (cl = ctx->body; cl; cl = cl->next) {\n        /*  ignore all non-memory buffers */\n        len += cl->buf->last - cl->buf->pos;\n    }\n\n    body_str->len = len;\n\n    if (len == 0) {\n        body_str->data = NULL;\n\n    } else {\n        p = ngx_palloc(r->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        body_str->data = p;\n\n        /* copy from and then free the data buffers */\n\n        for (cl = ctx->body; cl; cl = cl->next) {\n            p = ngx_copy(p, cl->buf->pos, cl->buf->last - cl->buf->pos);\n\n            cl->buf->last = cl->buf->pos;\n\n#if 0\n            dd(\"free body chain link buf ASAP\");\n            ngx_pfree(r->pool, cl->buf->start);\n#endif\n        }\n    }\n\n    if (ctx->body) {\n\n        ngx_chain_update_chains(r->pool,\n                                &pr_ctx->free_bufs, &pr_ctx->busy_bufs,\n                                &ctx->body,\n                                (ngx_buf_tag_t) &ngx_http_lua_module);\n\n        dd(\"free bufs: %p\", pr_ctx->free_bufs);\n    }\n\n    ngx_http_post_request_to_head(pr);\n\n    if (r != r->connection->data) {\n        r->connection->data = r;\n    }\n\n    if (rc == NGX_ERROR\n        || rc == NGX_HTTP_CREATED\n        || rc == NGX_HTTP_NO_CONTENT\n        || (rc >= NGX_HTTP_SPECIAL_RESPONSE\n            && rc != NGX_HTTP_CLOSE\n            && rc != NGX_HTTP_REQUEST_TIME_OUT\n            && rc != NGX_HTTP_CLIENT_CLOSED_REQUEST))\n    {\n        /* emulate ngx_http_special_response_handler */\n\n        if (rc > NGX_OK) {\n            r->err_status = rc;\n\n            r->expect_tested = 1;\n            r->headers_out.content_type.len = 0;\n            r->headers_out.content_length_n = 0;\n\n            ngx_http_clear_accept_ranges(r);\n            ngx_http_clear_last_modified(r);\n\n            rc = ngx_http_lua_send_header_if_needed(r, ctx);\n            if (rc == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n        }\n\n        return NGX_OK;\n    }\n\n    return rc;\n}\n\n\nstatic ngx_int_t\nngx_http_lua_set_content_length_header(ngx_http_request_t *r, off_t len)\n{\n    ngx_table_elt_t                 *h, *header;\n    u_char                          *p;\n    ngx_list_part_t                 *part;\n    ngx_http_request_t              *pr;\n    ngx_uint_t                       i;\n\n    r->headers_in.content_length_n = len;\n\n    if (ngx_list_init(&r->headers_in.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    h = ngx_list_push(&r->headers_in.headers);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    h->key = ngx_http_lua_content_length_header_key;\n    h->lowcase_key = ngx_pnalloc(r->pool, h->key.len);\n    if (h->lowcase_key == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_strlow(h->lowcase_key, h->key.data, h->key.len);\n\n    r->headers_in.content_length = h;\n\n    p = ngx_palloc(r->pool, NGX_OFF_T_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    h->value.data = p;\n\n    h->value.len = ngx_sprintf(h->value.data, \"%O\", len) - h->value.data;\n\n    h->hash = ngx_http_lua_content_length_hash;\n\n#if 0\n    dd(\"content length hash: %lu == %lu\", (unsigned long) h->hash,\n       ngx_hash_key_lc((u_char *) \"Content-Length\",\n                       sizeof(\"Content-Length\") - 1));\n#endif\n\n    dd(\"r content length: %.*s\",\n       (int) r->headers_in.content_length->value.len,\n       r->headers_in.content_length->value.data);\n\n    pr = r->parent;\n\n    if (pr == NULL) {\n        return NGX_OK;\n    }\n\n    /* forward the parent request's all other request headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        if (ngx_http_lua_set_input_header(r, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,\n    ngx_http_lua_ctx_t *ctx)\n{\n    ngx_uint_t                   i, count;\n    ngx_uint_t                   index;\n    lua_State                   *co;\n    ngx_str_t                   *body_str;\n    ngx_table_elt_t             *header;\n    ngx_list_part_t             *part;\n    ngx_http_headers_out_t      *sr_headers;\n    ngx_http_lua_co_ctx_t       *coctx;\n\n    u_char                  buf[sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\") - 1];\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua handle subrequest responses\");\n\n    coctx = ctx->cur_co_ctx;\n    co = coctx->co;\n\n    for (index = 0; index < coctx->nsubreqs; index++) {\n        dd(\"summary: reqs %d, subquery %d, pending %d, req %.*s\",\n           (int) coctx->nsubreqs,\n           (int) index,\n           (int) coctx->pending_subreqs,\n           (int) r->uri.len, r->uri.data);\n\n        /*  {{{ construct ret value */\n        lua_createtable(co, 0 /* narr */, 4 /* nrec */);\n\n        /*  copy captured status */\n        lua_pushinteger(co, coctx->sr_statuses[index]);\n        lua_setfield(co, -2, \"status\");\n\n        dd(\"captured subrequest flags: %d\", (int) coctx->sr_flags[index]);\n\n        /* set truncated flag if truncation happens */\n        if (coctx->sr_flags[index] & NGX_HTTP_LUA_SUBREQ_TRUNCATED) {\n            lua_pushboolean(co, 1);\n            lua_setfield(co, -2, \"truncated\");\n\n        } else {\n            lua_pushboolean(co, 0);\n            lua_setfield(co, -2, \"truncated\");\n        }\n\n        /*  copy captured body */\n\n        body_str = &coctx->sr_bodies[index];\n\n        lua_pushlstring(co, (char *) body_str->data, body_str->len);\n        lua_setfield(co, -2, \"body\");\n\n        if (body_str->data) {\n            dd(\"free body buffer ASAP\");\n            ngx_pfree(r->pool, body_str->data);\n        }\n\n        /* copy captured headers */\n\n        sr_headers = coctx->sr_headers[index];\n\n        part = &sr_headers->headers.part;\n        count = part->nelts;\n        while (part->next) {\n            part = part->next;\n            count += part->nelts;\n        }\n\n        lua_createtable(co, 0, count + 5); /* res.header */\n\n        dd(\"saving subrequest response headers\");\n\n        part = &sr_headers->headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            dd(\"checking sr header %.*s\", (int) header[i].key.len,\n               header[i].key.data);\n\n#if 1\n            if (header[i].hash == 0) {\n                continue;\n            }\n#endif\n\n            header[i].hash = 0;\n\n            dd(\"pushing sr header %.*s\", (int) header[i].key.len,\n               header[i].key.data);\n\n            lua_pushlstring(co, (char *) header[i].key.data,\n                            header[i].key.len); /* header key */\n            lua_pushvalue(co, -1); /* stack: table key key */\n\n            /* check if header already exists */\n            lua_rawget(co, -3); /* stack: table key value */\n\n            if (lua_isnil(co, -1)) {\n                lua_pop(co, 1); /* stack: table key */\n\n                lua_pushlstring(co, (char *) header[i].value.data,\n                                header[i].value.len);\n                    /* stack: table key value */\n\n                lua_rawset(co, -3); /* stack: table */\n\n            } else {\n\n                if (!lua_istable(co, -1)) { /* already inserted one value */\n                    lua_createtable(co, 4, 0);\n                        /* stack: table key value table */\n\n                    lua_insert(co, -2); /* stack: table key table value */\n                    lua_rawseti(co, -2, 1); /* stack: table key table */\n\n                    lua_pushlstring(co, (char *) header[i].value.data,\n                                    header[i].value.len);\n                        /* stack: table key table value */\n\n                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);\n                        /* stack: table key table */\n\n                    lua_rawset(co, -3); /* stack: table */\n\n                } else {\n                    lua_pushlstring(co, (char *) header[i].value.data,\n                                    header[i].value.len);\n                        /* stack: table key table value */\n\n                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);\n                        /* stack: table key table */\n\n                    lua_pop(co, 2); /* stack: table */\n                }\n            }\n        }\n\n        if (sr_headers->content_type.len) {\n            lua_pushliteral(co, \"Content-Type\"); /* header key */\n            lua_pushlstring(co, (char *) sr_headers->content_type.data,\n                            sr_headers->content_type.len); /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        if (sr_headers->content_length == NULL\n            && sr_headers->content_length_n >= 0)\n        {\n            lua_pushliteral(co, \"Content-Length\"); /* header key */\n\n            lua_pushnumber(co, (lua_Number) sr_headers->content_length_n);\n                /* head key value */\n\n            lua_rawset(co, -3); /* head */\n        }\n\n        /* to work-around an issue in ngx_http_static_module\n         * (github issue #41) */\n        if (sr_headers->location && sr_headers->location->value.len) {\n            lua_pushliteral(co, \"Location\"); /* header key */\n            lua_pushlstring(co, (char *) sr_headers->location->value.data,\n                            sr_headers->location->value.len);\n            /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        if (sr_headers->last_modified_time != -1) {\n            if (sr_headers->status != NGX_HTTP_OK\n                && sr_headers->status != NGX_HTTP_PARTIAL_CONTENT\n                && sr_headers->status != NGX_HTTP_NOT_MODIFIED\n                && sr_headers->status != NGX_HTTP_NO_CONTENT)\n            {\n                sr_headers->last_modified_time = -1;\n                sr_headers->last_modified = NULL;\n            }\n        }\n\n        if (sr_headers->last_modified == NULL\n            && sr_headers->last_modified_time != -1)\n        {\n            (void) ngx_http_time(buf, sr_headers->last_modified_time);\n\n            lua_pushliteral(co, \"Last-Modified\"); /* header key */\n            lua_pushlstring(co, (char *) buf, sizeof(buf)); /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        lua_setfield(co, -2, \"header\");\n\n        /*  }}} */\n    }\n}\n\n\nvoid\nngx_http_lua_inject_subrequest_api(lua_State *L)\n{\n    lua_createtable(L, 0 /* narr */, 2 /* nrec */); /* .location */\n\n    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture);\n    lua_setfield(L, -2, \"capture\");\n\n    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture_multi);\n    lua_setfield(L, -2, \"capture_multi\");\n\n    lua_setfield(L, -2, \"location\");\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest(ngx_http_request_t *r,\n    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n    ngx_http_post_subrequest_t *ps, ngx_uint_t flags)\n{\n    ngx_time_t                    *tp;\n    ngx_connection_t              *c;\n    ngx_http_request_t            *sr;\n    ngx_http_core_srv_conf_t      *cscf;\n\n#if (nginx_version >= 1009005)\n\n    if (r->subrequests == 0) {\n#if defined(NGX_DTRACE) && NGX_DTRACE\n        ngx_http_probe_subrequest_cycle(r, uri, args);\n#endif\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"lua subrequests cycle while processing \\\"%V\\\"\", uri);\n        return NGX_ERROR;\n    }\n\n#else  /* nginx_version <= 1009004 */\n\n    r->main->subrequests--;\n\n    if (r->main->subrequests == 0) {\n#if defined(NGX_DTRACE) && NGX_DTRACE\n        ngx_http_probe_subrequest_cycle(r, uri, args);\n#endif\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"lua subrequests cycle while processing \\\"%V\\\"\", uri);\n        r->main->subrequests = 1;\n        return NGX_ERROR;\n    }\n\n#endif\n\n    sr = ngx_pcalloc(r->pool, sizeof(ngx_http_request_t));\n    if (sr == NULL) {\n        return NGX_ERROR;\n    }\n\n    sr->signature = NGX_HTTP_MODULE;\n\n    c = r->connection;\n    sr->connection = c;\n\n    sr->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);\n    if (sr->ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_list_init(&sr->headers_out.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    sr->main_conf = cscf->ctx->main_conf;\n    sr->srv_conf = cscf->ctx->srv_conf;\n    sr->loc_conf = cscf->ctx->loc_conf;\n\n    sr->pool = r->pool;\n\n    sr->headers_in.content_length_n = -1;\n    sr->headers_in.keep_alive_n = -1;\n\n    ngx_http_clear_content_length(sr);\n    ngx_http_clear_accept_ranges(sr);\n    ngx_http_clear_last_modified(sr);\n\n    sr->request_body = r->request_body;\n\n#if (NGX_HTTP_SPDY)\n    sr->spdy_stream = r->spdy_stream;\n#endif\n\n#if (NGX_HTTP_V2)\n    sr->stream = r->stream;\n#endif\n\n#ifdef HAVE_ALLOW_REQUEST_BODY_UPDATING_PATCH\n    sr->content_length_n = -1;\n#endif\n\n    sr->method = NGX_HTTP_GET;\n    sr->http_version = r->http_version;\n\n    sr->request_line = r->request_line;\n    sr->uri = *uri;\n\n    if (args) {\n        sr->args = *args;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"lua http subrequest \\\"%V?%V\\\"\", uri, &sr->args);\n\n    sr->subrequest_in_memory = (flags & NGX_HTTP_SUBREQUEST_IN_MEMORY) != 0;\n    sr->waited = (flags & NGX_HTTP_SUBREQUEST_WAITED) != 0;\n\n    sr->unparsed_uri = r->unparsed_uri;\n    sr->method_name = ngx_http_core_get_method;\n    sr->http_protocol = r->http_protocol;\n\n    ngx_http_set_exten(sr);\n\n    sr->main = r->main;\n    sr->parent = r;\n    sr->post_subrequest = ps;\n    sr->read_event_handler = ngx_http_request_empty_handler;\n    sr->write_event_handler = ngx_http_handler;\n\n    sr->variables = r->variables;\n\n    sr->log_handler = r->log_handler;\n\n    sr->internal = 1;\n\n    sr->discard_body = r->discard_body;\n    sr->expect_tested = 1;\n    sr->main_filter_need_in_memory = r->main_filter_need_in_memory;\n\n    sr->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;\n\n#if (nginx_version >= 1009005)\n    sr->subrequests = r->subrequests - 1;\n#endif\n\n    tp = ngx_timeofday();\n    sr->start_sec = tp->sec;\n    sr->start_msec = tp->msec;\n\n    r->main->count++;\n\n    *psr = sr;\n\n#if defined(NGX_DTRACE) && NGX_DTRACE\n    ngx_http_probe_subrequest_start(sr);\n#endif\n\n    return ngx_http_post_request(sr, NULL);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest_resume(ngx_http_request_t *r)\n{\n    lua_State                   *vm;\n    ngx_int_t                    rc;\n    ngx_uint_t                   nreqs;\n    ngx_connection_t            *c;\n    ngx_http_lua_ctx_t          *ctx;\n    ngx_http_lua_co_ctx_t       *coctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ctx->resume_handler = ngx_http_lua_wev_handler;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run subrequests done, resuming lua thread\");\n\n    coctx = ctx->cur_co_ctx;\n\n    dd(\"nsubreqs: %d\", (int) coctx->nsubreqs);\n\n    ngx_http_lua_handle_subreq_responses(r, ctx);\n\n    dd(\"free sr_statues/headers/bodies memory ASAP\");\n\n#if 1\n    ngx_pfree(r->pool, coctx->sr_statuses);\n\n    coctx->sr_statuses = NULL;\n    coctx->sr_headers = NULL;\n    coctx->sr_bodies = NULL;\n    coctx->sr_flags = NULL;\n#endif\n\n    c = r->connection;\n    vm = ngx_http_lua_get_lua_vm(r, ctx);\n    nreqs = c->requests;\n\n    rc = ngx_http_lua_run_thread(vm, r, ctx, coctx->nsubreqs);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run thread returned %d\", rc);\n\n    if (rc == NGX_AGAIN) {\n        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);\n    }\n\n    if (rc == NGX_DONE) {\n        ngx_http_lua_finalize_request(r, NGX_DONE);\n        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);\n    }\n\n    /* rc == NGX_ERROR || rc >= NGX_OK */\n\n    if (ctx->entered_content_phase) {\n        ngx_http_lua_finalize_request(r, rc);\n        return NGX_DONE;\n    }\n\n    return rc;\n}\n\n\nstatic void\nngx_http_lua_cancel_subreq(ngx_http_request_t *r)\n{\n    ngx_http_posted_request_t   *pr;\n    ngx_http_posted_request_t  **p;\n\n#if 1\n    r->main->count--;\n    r->main->subrequests++;\n#endif\n\n    p = &r->main->posted_requests;\n    for (pr = r->main->posted_requests; pr->next; pr = pr->next) {\n        p = &pr->next;\n    }\n\n    *p = NULL;\n\n    r->connection->data = r->parent;\n}\n\n\nstatic ngx_int_t\nngx_http_post_request_to_head(ngx_http_request_t *r)\n{\n    ngx_http_posted_request_t  *pr;\n\n    pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));\n    if (pr == NULL) {\n        return NGX_ERROR;\n    }\n\n    pr->request = r;\n    pr->next = r->main->posted_requests;\n    r->main->posted_requests = pr;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r)\n{\n    ngx_temp_file_t     *tf;\n\n    ngx_http_request_body_t   *body;\n\n    tf = r->request_body->temp_file;\n\n    if (!tf->persistent || !tf->clean) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"the request body was not read by ngx_lua\");\n\n        return NGX_ERROR;\n    }\n\n    body = ngx_palloc(r->pool, sizeof(ngx_http_request_body_t));\n    if (body == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body, r->request_body, sizeof(ngx_http_request_body_t));\n\n    body->temp_file = ngx_palloc(r->pool, sizeof(ngx_temp_file_t));\n    if (body->temp_file == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body->temp_file, tf, sizeof(ngx_temp_file_t));\n    dd(\"file fd: %d\", body->temp_file->file.fd);\n\n    r->request_body = body;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}\n\n/* vi:set ft=c ts=4 sw=4 et fdm=marker: */\n", "# vim:set ft= ts=4 sw=4 et fdm=marker:\n\nuse Test::Nginx::Socket::Lua;\n\n#master_on();\n#workers(1);\n#worker_connections(1014);\n#log_level('warn');\n#master_process_enabled(1);\n\nno_root_location;\nrepeat_each(2);\n\nplan tests => repeat_each() * (blocks() * 3 + 23);\n\n$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;\n\n#no_diff();\nno_long_string();\n#no_shuffle();\n\nrun_tests();\n\n__DATA__\n\n=== TEST 1: DELETE\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nDELETE\n--- error_log\nlua http subrequest \"/other?\"\n--- no_error_log\n[error]\n\n\n\n=== TEST 2: DELETE (proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nDELETE\n--- no_error_log\n[error]\n\n\n\n=== TEST 3: POST (nobody, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /t\n--- response_body\nPOST\n--- no_error_log\n[error]\n\n\n\n=== TEST 4: HEAD\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_HEAD });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\n--- no_error_log\n[error]\n\n\n\n=== TEST 5: explicit GET\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 6: implicit GET\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\")\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 7: implicit GET (empty option table)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\", {})\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 8: PUT (nobody, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPUT\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 9: PUT (nobody, no proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        #echo_read_request_body;\n\n        echo $echo_request_method;\n        #echo $echo_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPUT\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 10: PUT (nobody, no proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        #echo_read_request_body;\n\n        echo $echo_request_method;\n        #echo $echo_request_body;\n        echo_request_body;\n        #echo \"[$http_content_length]\";\n        echo;\n    }\n\n    location /foo {\n        echo $echo_request_method;\n        echo -n \"[$http_content_length]\";\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n\n            res = ngx.location.capture(\"/foo\")\n            ngx.say(res.body)\n\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nPUT\nhello\nGET\n[]\n--- no_error_log\n[error]\n\n\n\n=== TEST 11: POST (with body, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPOST\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 12: POST (with body, memc method)\n--- config\n    location /flush {\n        set $memc_cmd flush_all;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /memc {\n        set $memc_key $echo_request_uri;\n        set $memc_exptime 600;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.location.capture(\"/flush\");\n\n            local res = ngx.location.capture(\"/memc\");\n            ngx.say(\"GET: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n            ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\");\n            ngx.say(\"cached: \" .. res.body);\n\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET: 404\nPUT: 201\ncached: hello\n--- no_error_log\n[error]\n\n\n\n=== TEST 13: POST (with body, memc method)\n--- config\n    location /flush {\n        set $memc_cmd flush_all;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /memc {\n        set $memc_cmd \"\";\n        set $memc_key $echo_request_uri;\n        set $memc_exptime 600;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.location.capture(\"/flush\",\n                { share_all_vars = true });\n\n            local res = ngx.location.capture(\"/memc\",\n                { share_all_vars = true });\n            ngx.say(\"GET: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello\", share_all_vars = true });\n            ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\", { share_all_vars = true });\n            ngx.say(\"cached: \" .. res.body);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET: 404\nPUT: 201\ncached: hello\n--- no_error_log\n[error]\n\n\n\n=== TEST 14: empty args option table\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = {} })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body eval: \"\\n\"\n--- no_error_log\n[error]\n\n\n\n=== TEST 15: non-empty args option table (1 pair)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [\"fo=\"] = \"=>\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nfo%3D=%3D%3E\n--- no_error_log\n[error]\n\n\n\n=== TEST 16: non-empty args option table (2 pairs)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [\"fo=\"] = \"=>\",\n                    [\"=\"] = \":\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^(?:fo%3D=%3D%3E\\&%3D=%3A|%3D=%3A\\&fo%3D=%3D%3E)$\n--- no_error_log\n[error]\n--- no_error_log\n[error]\n\n\n\n=== TEST 17: non-empty args option table (2 pairs, no special chars)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { foo = 3,\n                    bar = \"hello\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^(?:bar=hello\\&foo=3|foo=3\\&bar=hello)$\n--- no_error_log\n[error]\n\n\n\n=== TEST 18: non-empty args option table (number key)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [57] = \"hi\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like: 500 Internal Server Error\n--- error_code: 500\n--- error_log\nattempt to use a non-string key in the \"args\" option table\n\n\n\n=== TEST 19: non-empty args option table (plain arrays)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { \"hi\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like: 500 Internal Server Error\n--- error_code: 500\n--- error_log\nattempt to use a non-string key in the \"args\" option table\n\n\n\n=== TEST 20: more args\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo?a=3\",\n                { args = { b = 4 } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\na=3&b=4\n--- no_error_log\n[error]\n\n\n\n=== TEST 21: more args\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo?a=3\",\n                { args = \"b=4\" })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\na=3&b=4\n--- no_error_log\n[error]\n\n\n\n=== TEST 22: is_subrequest in main request\n--- config\n    location /lua {\n        content_by_lua '\n            if ngx.is_subrequest then\n                ngx.say(\"sub req\")\n            else\n                ngx.say(\"main req\")\n            end\n        ';\n    }\n--- request\n    GET /lua\n--- response_body\nmain req\n--- no_error_log\n[error]\n\n\n\n=== TEST 23: is_subrequest in sub request\n--- config\n    location /main {\n        echo_location /lua;\n    }\n\n    location /lua {\n        content_by_lua '\n            if ngx.is_subrequest then\n                ngx.say(\"sub req\")\n            else\n                ngx.say(\"main req\")\n            end\n        ';\n    }\n--- request\n    GET /main\n--- response_body\nsub req\n--- no_error_log\n[error]\n\n\n\n=== TEST 24: is_subrequest in sub request in set_by_lua\n--- config\n    location /main {\n        echo_location /lua;\n    }\n\n    location /lua {\n        set_by_lua $a '\n            if ngx.is_subrequest then\n                return \"sub req\"\n            else\n                return \"main req\"\n            end\n        ';\n        echo $a;\n    }\n--- request\n    GET /main\n--- response_body\nsub req\n--- no_error_log\n[error]\n\n\n\n=== TEST 25: header inheritance bug (without body) (github issue 38)\nhttps://github.com/chaoslawful/lua-nginx-module/issues/38\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo -n $http_foo;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_GET });\n            ngx.say(\"header foo: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- more_headers\nFoo: bar\n--- response_body\nheader foo: [bar]\n--- no_error_log\n[error]\n\n\n\n=== TEST 26: header inheritance bug (with body) (github issue 38)\nhttps://github.com/chaoslawful/lua-nginx-module/issues/38\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo -n $http_foo;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { body = \"abc\" });\n            ngx.say(\"header foo: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- more_headers\nFoo: bar\n--- response_body\nheader foo: [bar]\n--- no_error_log\n[error]\n\n\n\n=== TEST 27: lua calls lua via subrequests\n--- config\n    location /a {\n        content_by_lua '\n            ngx.say(\"hello, a\");\n        ';\n    }\n    location /b {\n        content_by_lua '\n            ngx.say(\"hello, b\");\n        ';\n    }\n    location /c {\n        content_by_lua '\n            ngx.say(\"hello, c\");\n        ';\n    }\n    location /main {\n        content_by_lua '\n            local res1, res2 = ngx.location.capture_multi({{\"/a\"}, {\"/b\"}})\n            local res3 = ngx.location.capture(\"/c\")\n            ngx.print(res1.body, res2.body, res3.body)\n        ';\n    }\n--- request\n    GET /main\n--- response_body\nhello, a\nhello, b\nhello, c\n--- error_log\nlua reuse free buf memory\n--- no_error_log\n[error]\n\n\n\n=== TEST 28: POST (with body, proxy method, main request is a POST too)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhi\n--- response_body chomp\nPOST\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 29: Last-Modified response header for static file subrequest\n--- config\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo.html\")\n\n            ngx.say(res.status)\n            ngx.say(res.header[\"Last-Modified\"])\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- user_files\n>>> foo.html\nhello, static file\n--- response_body_like chomp\n^200\n[A-Za-z]+, \\d{1,2} [A-Za-z]+ \\d{4} \\d{2}:\\d{2}:\\d{2} GMT\nhello, static file$\n--- no_error_log\n[error]\n\n\n\n=== TEST 30: custom ctx table for subrequest\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.ctx.foo = \"bar\";\n        ';\n    }\n    location /lua {\n        content_by_lua '\n            local ctx = {}\n            local res = ngx.location.capture(\"/sub\", { ctx = ctx })\n\n            ngx.say(ctx.foo);\n            ngx.say(ngx.ctx.foo);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nbar\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 31: share the ctx with the parent\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.ctx.foo = \"bar\";\n        ';\n    }\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\", { ctx = ngx.ctx })\n            ngx.say(ngx.ctx.foo);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nbar\n--- no_error_log\n[error]\n\n\n\n=== TEST 32: test memcached with subrequests\n--- http_config\n    upstream memc {\n        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n        keepalive 100;\n    }\n--- config\n    location /memc {\n        set $memc_key some_key;\n        set $memc_exptime 600;\n        memc_pass memc;\n    }\n\n    location /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello 1234\" });\n            -- ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\");\n            ngx.say(\"some_key: \" .. res.body);\n        ';\n    }\n--- request\nGET /t\n--- response_body\nsome_key: hello 1234\n--- error_log\nlua reuse free buf chain, but reallocate memory because\n--- no_error_log\n[error]\n\n\n\n=== TEST 33: main POST, sub GET (main does not read the body)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nGET\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 34: main POST, sub GET (main has read the body)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nGET\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 35: main POST, sub POST (inherit bodies directly)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nPOST\nhello, world\n--- no_error_log\n[error]\n\n\n\n=== TEST 36: main POST, sub PUT (inherit bodies directly)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_PUT });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nPUT\nhello, world\n--- no_error_log\n[error]\n\n\n\n=== TEST 37: recursive calls\n--- config\n    location /t {\n        content_by_lua '\n            ngx.location.capture(\"/t\")\n        ';\n    }\n--- request\n    GET /t\n--- ignore_response\n--- error_log\nlua subrequests cycle while processing \"/t\"\n\n\n\n=== TEST 38: OPTIONS\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_OPTIONS });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nOPTIONS\n--- no_error_log\n[error]\n\n\n\n=== TEST 39: OPTIONS with a body\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_OPTIONS, body = \"hello world\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chop\nOPTIONS\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 40: encode args table with a multi-value arg.\n--- config\n    location /t {\n        content_by_lua '\n            local args, err = ngx.req.get_uri_args()\n            if err then\n                ngx.say(\"err: \", err)\n            end\n\n            local res = ngx.location.capture(\"/sub\", { args = args })\n            ngx.print(res.body)\n        ';\n    }\n\n    location /sub {\n        echo $query_string;\n    }\n--- request\nGET /t?r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fjquery%2F1.7.2%2Fjquery.min.js&r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fdojo%2F1.7.2%2Fdojo%2Fdojo.js.uncompressed.js\n--- response_body\nr%5B%5D=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fjquery%2F1.7.2%2Fjquery.min.js&r%5B%5D=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fdojo%2F1.7.2%2Fdojo%2Fdojo.js.uncompressed.js\n--- no_error_log\n[error]\n\n\n\n=== TEST 41: subrequests finalized with NGX_ERROR\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.exit(ngx.ERROR)\n        ';\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- response_body\nstatus: 500\nbody: \n\n\n\n=== TEST 42: subrequests finalized with 500\n--- config\n    location /sub {\n        return 500;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- response_body\nstatus: 500\nbody: \n\n\n\n=== TEST 43: subrequests with an output body filter returning NGX_ERROR\n--- config\n    location /sub {\n        echo hello world;\n        body_filter_by_lua '\n            return ngx.ERROR\n        ';\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- stap2\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n--- response_body\n--- error_code\n--- no_error_log\n[error]\n\n\n\n=== TEST 44: subrequests truncated in its response body due to premature connection close (nonbuffered)\n--- config\n    server_tokens off;\n    location /memc {\n        internal;\n\n        set $memc_key 'foo';\n        #set $memc_exptime 300;\n        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19112\n--- tcp_query_len: 9\n--- tcp_reply eval\n\"VALUE foo 0 1024\\r\\nhello world\"\n\n--- stap2\nF(ngx_http_lua_capture_body_filter) {\n    if (pid() == target() && $r != $r->main) {\n        printf(\"lua capture body output: %s\\n\", ngx_chain_dump($in))\n        if ($in->buf->last_in_chain) {\n            print_ubacktrace()\n        }\n    }\n}\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 45: subrequests truncated in its response body due to upstream read timeout (nonbuffered)\n--- config\n    memc_read_timeout 100ms;\n    location /memc {\n        internal;\n\n        set $memc_key 'foo';\n        #set $memc_exptime 300;\n        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19112\n--- tcp_no_close\n--- tcp_reply eval\n\"VALUE foo 0 1024\\r\\nhello world\"\n\n--- stap2\nF(ngx_http_lua_capture_body_filter) {\n    if (pid() == target() && $r != $r->main) {\n        printf(\"lua capture body output: %s\\n\", ngx_chain_dump($in))\n        //if ($in->buf->last_in_chain) {\n            print_ubacktrace()\n        //}\n    }\n}\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=504\npost subreq: rc=0, status=200\n\n--- response_body_like chop\n^status: 200\nbody: [^\\n]*\ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 46: subrequests truncated in its response body due to premature connection close (buffered)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 47: subrequests truncated in its response body due to read timeout (buffered)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 48: subrequests truncated in its response body due to premature connection close (buffered, no content-length)\n--- config\n    server_tokens off;\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: false\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 49: subrequests truncated in its response body due to read timeout (buffered, no content-length)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 50: subrequests truncated in its response body due to premature connection close (nonbuffered, no content-length)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: false\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 51: subrequests truncated in its response body due to read timeout (nonbuffered, no content-length)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 500ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=504\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 52: forwarding in-memory request bodies to multiple subrequests\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n\n--- request eval\n\"POST /lua\n\" . \"hello world\"\n\n--- response_body\nhello world\nhello world\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 53: forwarding in-file request bodies to multiple subrequests (client_body_in_file_only)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    client_body_in_file_only on;\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n\n--- request eval\n\"POST /lua\n\" . \"hello world\"\n\n--- response_body\nhello world\nhello world\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 54: forwarding in-file request bodies to multiple subrequests (exceeding client_body_buffer_size)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        #client_body_in_file_only on;\n        client_body_buffer_size 1;\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n--- request eval\n\"POST /lua\n\" . (\"hello world\" x 100)\n\n--- stap2\nglobal valid = 0\nglobal fds\n\nF(ngx_http_handler) { valid = 1  }\n\nprobe syscall.open {\n    if (valid && pid() == target()) {\n        print(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.close {\n    if (valid && pid() == target() && fds[sprintf(\"%d\", $fd)]) {\n        println(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.unlink {\n    if (valid && pid() == target()) {\n        println(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.open.return {\n    if (valid && pid() == target()) {\n        println(\" = \", retstr)\n        fds[retstr] = 1\n    }\n}\n\nF(ngx_http_lua_subrequest) {\n    println(\"lua subrequest\")\n}\n\nF(ngx_output_chain) {\n    printf(\"output chain: %s\\n\", ngx_chain_dump($in))\n}\n\nF(ngx_pool_run_cleanup_file) {\n    println(\"clean up file: \", $fd)\n}\n\n--- response_body eval\n(\"hello world\" x 100) . \"\\n\"\n. (\"hello world\" x 100) . \"\\n\"\n\n--- no_error_log\n[error]\n--- error_log\na client request body is buffered to a temporary file\n\n\n\n=== TEST 55: subrequests truncated in its response body due to premature connection close (buffered + chunked)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_http_version 1.1;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 56: subrequests truncated in its response body due to premature connection close (nonbuffered + chunked)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 57: subrequests truncated in its response body due to read timeout (buffered + chunked)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 58: good chunked response (buffered)\n--- config\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\\n0\\r\\n\\r\\n\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=0 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello\ntruncated: false\n\n\n\n=== TEST 59: good chunked response (nonbuffered)\n--- config\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\\n0\\r\\n\\r\\n\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=0 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello\ntruncated: false\n\n\n\n=== TEST 60: subrequests truncated in its response body due to premature connection close (nonbuffered + proxy)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 61: WebDAV methods\n--- config\n    location /other {\n        echo \"method: $echo_request_method\";\n    }\n\n    location /lua {\n        content_by_lua '\n            local methods = {\n                ngx.HTTP_MKCOL,\n                ngx.HTTP_COPY,\n                ngx.HTTP_MOVE,\n                ngx.HTTP_PROPFIND,\n                ngx.HTTP_PROPPATCH,\n                ngx.HTTP_LOCK,\n                ngx.HTTP_UNLOCK,\n                ngx.HTTP_PATCH,\n                ngx.HTTP_TRACE,\n            }\n\n            for i, method in ipairs(methods) do\n                local res = ngx.location.capture(\"/other\",\n                    { method = method })\n                ngx.print(res.body)\n            end\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nmethod: MKCOL\nmethod: COPY\nmethod: MOVE\nmethod: PROPFIND\nmethod: PROPPATCH\nmethod: LOCK\nmethod: UNLOCK\nmethod: PATCH\nmethod: TRACE\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 62: by default DELETE subrequests don't forward request bodies\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- response_body\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 63: DELETE subrequests do forward request bodies when always_forward_body == true\n--- config\n    location = /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE, always_forward_body = true });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- response_body\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 64: DELETE subrequests do forward request bodies when always_forward_body == true (on disk)\n--- config\n    location = /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE, always_forward_body = true });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- stap2\nglobal c\nprobe process(\"$LIBLUA_PATH\").function(\"rehashtab\") {\n    c++\n    //print_ubacktrace()\n    printf(\"rehash: %d\\n\", c)\n}\n--- stap_out2\n--- response_body\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 65: DELETE\n--- config\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n        ';\n    }\n    location = /sub {\n        echo hello;\n        echo world;\n    }\n--- request\nGET /t\n--- response_body\nhello\nworld\n--- stap\nF(ngx_http_lua_capture_header_filter) {\n    println(\"capture header filter\")\n}\n\nF(ngx_http_lua_capture_body_filter) {\n    println(\"capture body filter\")\n}\n\n--- stap_out\ncapture header filter\ncapture body filter\ncapture body filter\ncapture body filter\ncapture header filter\ncapture body filter\ncapture body filter\n--- no_error_log\n[error]\n\n\n\n=== TEST 66: leafo test case 1 for assertion failures\n--- config\n    location = /t {\n        echo hello;\n    }\n\n    location /proxy {\n        internal;\n        rewrite_by_lua \"\n          local req = ngx.req\n          print(ngx.var._url)\n\n          for k,v in pairs(req.get_headers()) do\n            if k ~= 'content-length' then\n              req.clear_header(k)\n            end\n          end\n\n          if ngx.ctx.headers then\n            for k,v in pairs(ngx.ctx.headers) do\n              req.set_header(k, v)\n            end\n          end\n        \";\n\n        proxy_http_version 1.1;\n        proxy_pass $_url;\n    }\n\n    location /first {\n      set $_url \"\";\n      content_by_lua '\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"Content-type\"] = \"application/x-www-form-urlencoded\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"x-some-date\"] = \"Sun, 01 Dec 2013 11:47:41 GMT\",\n              [\"x-hello-world-header\"] = \"123412341234\",\n              [\"Authorization\"] = \"Hello\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n      ';\n    }\n--- request\nGET /first\n--- response_body\nhello\nhello\n--- no_error_log eval\n[\n\"[error]\",\nqr/Assertion .*? failed/\n]\n\n\n\n=== TEST 67: leafo test case 2 for assertion failures\n--- config\n    location = /t {\n        echo hello;\n    }\n\n    location /proxy {\n        internal;\n        rewrite_by_lua \"\n          local req = ngx.req\n          print(ngx.var._url)\n\n          for k,v in pairs(req.get_headers()) do\n            if k ~= 'content-length' then\n              req.clear_header(k)\n            end\n          end\n\n          if ngx.ctx.headers then\n            for k,v in pairs(ngx.ctx.headers) do\n              req.set_header(k, v)\n            end\n          end\n        \";\n\n        proxy_http_version 1.1;\n        proxy_pass $_url;\n    }\n\n    location /second {\n      set $_url \"\";\n      content_by_lua '\n        local res = ngx.location.capture(\"/proxy\", {\n          method = ngx.HTTP_POST,\n          body = (\"x\"):rep(600),\n          ctx = {\n            headers = {\n              [\"Content-type\"] = \"application/x-www-form-urlencoded\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"x-some-date\"] = \"Sun, 01 Dec 2013 11:47:41 GMT\",\n              [\"x-hello-world-header\"] = \"123412341234\",\n              [\"Authorization\"] = \"Hello\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n      ';\n    }\n--- request\nGET /second\n--- response_body\nhello\nhello\nhello\n--- no_error_log eval\n[\n\"[error]\",\nqr/Assertion .*? failed/\n]\n\n\n\n=== TEST 68: fetch subrequest's builtin request headers\n--- config\n    location = /sub {\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\n    GET /t\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: foo\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 69: modify subrequest's builtin request headers\n--- config\n    location = /sub {\n        rewrite_by_lua '\n            ngx.req.set_header(\"User-Agent\", \"bar\")\n        ';\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\n    GET /t\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: bar\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 70: modify subrequest's builtin request headers (main req is POST)\n--- config\n    location = /sub {\n        rewrite_by_lua '\n            ngx.req.set_header(\"User-Agent\", \"bar\")\n        ';\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\nPOST /t\nhello world\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: bar\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 71: duplicate request headers (main req is POST)\n--- config\n    location = /sub {\n        echo \"sr: Cookie: $http_cookie\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: Cookie: \", ngx.var.http_cookie)\n        ';\n    }\n--- request\nPOST /t\nhello world\n--- more_headers\nCookie: foo\nCookie: bar\n--- response_body\nsr: Cookie: foo; bar\npr: Cookie: foo; bar\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 72: duplicate request headers (main req is GET)\n--- config\n    location = /sub {\n        echo \"sr: Cookie: $http_cookie\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: Cookie: \", ngx.var.http_cookie)\n        ';\n    }\n--- request\nGET /t\n--- more_headers\nCookie: foo\nCookie: bar\n--- response_body\nsr: Cookie: foo; bar\npr: Cookie: foo; bar\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 73: HEAD subrequest (github #347)\n--- config\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/index.html\",\n                { method = ngx.HTTP_HEAD });\n            ngx.say(\"content-length: \", res.header[\"Content-Length\"])\n            ngx.say(\"body: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^content-length: \\d+\nbody: \\[\\]\n$\n--- no_error_log\n[error]\n\n\n\n=== TEST 74: image_filter + ngx.location.capture\nngx_http_image_filter_module's header filter intercepts\nthe header filter chain so the r->header_sent flag won't\nget set right after the header filter chain is first invoked.\n\n--- config\n\nlocation = /back {\n    empty_gif;\n}\n\nlocation = /t {\n    image_filter rotate 90;\n\n    content_by_lua '\n        local res = ngx.location.capture(\"/back\")\n        for k, v in pairs(res.header) do\n            ngx.header[k] = v\n        end\n        ngx.status = res.status\n        ngx.print(res.body)\n    ';\n}\n\n--- request\nGET /t\n--- response_body_like: .\n--- stap\nF(ngx_http_image_header_filter) {\n    println(\"image header filter\")\n}\n--- stap_out\nimage header filter\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 75: WebDAV + MOVE\n--- config\n    location = /t {\n        content_by_lua_block {\n            local file1 = \"/file1.txt\"\n            local file2 = \"/file2.txt\"\n            ngx.req.set_header( \"Destination\", file2 )\n            local res = ngx.location.capture(\n                file1, { method = ngx.HTTP_MOVE }\n            )\n\n            ngx.say(\n                \"MOVE \", file1, \" -> \", file2,\n                \", response status: \", res.status\n            )\n        }\n    }\n\n    location / {\n        dav_methods MOVE;\n    }\n\n--- user_files\n>>> file1.txt\nhello, world!\n\n--- request\nGET /t\n\n--- response_body\nMOVE /file1.txt -> /file2.txt, response status: 204\n\n--- no_error_log\n[error]\n--- error_code: 200\n\n\n\n=== TEST 76: WebDAV + DELETE\n--- config\n    location = /t {\n        content_by_lua_block {\n            local file = \"/file.txt\"\n            local res = ngx.location.capture(\n                file, { method = ngx.HTTP_DELETE }\n            )\n\n            ngx.say(\n                \"DELETE \", file,\n                \", response status: \", res.status\n            )\n        }\n    }\n\n    location / {\n        dav_methods DELETE;\n    }\n\n--- user_files\n>>> file.txt\nhello, world!\n\n--- request\nGET /t\n\n--- response_body\nDELETE /file.txt, response status: 204\n\n--- no_error_log\n[error]\n--- error_code: 200\n"], "fixing_code": ["\n/*\n * Copyright (C) Xiaozhe Wang (chaoslawful)\n * Copyright (C) Yichun Zhang (agentzh)\n */\n\n\n#ifndef DDEBUG\n#define DDEBUG 0\n#endif\n#include \"ddebug.h\"\n\n\n#include \"ngx_http_lua_subrequest.h\"\n#include \"ngx_http_lua_util.h\"\n#include \"ngx_http_lua_ctx.h\"\n#include \"ngx_http_lua_contentby.h\"\n#include \"ngx_http_lua_headers_in.h\"\n#if defined(NGX_DTRACE) && NGX_DTRACE\n#include \"ngx_http_probe.h\"\n#endif\n\n\n#define NGX_HTTP_LUA_SHARE_ALL_VARS     0x01\n#define NGX_HTTP_LUA_COPY_ALL_VARS      0x02\n\n\n#define ngx_http_lua_method_name(m) { sizeof(m) - 1, (u_char *) m \" \" }\n\n\nngx_str_t  ngx_http_lua_get_method = ngx_http_lua_method_name(\"GET\");\nngx_str_t  ngx_http_lua_put_method = ngx_http_lua_method_name(\"PUT\");\nngx_str_t  ngx_http_lua_post_method = ngx_http_lua_method_name(\"POST\");\nngx_str_t  ngx_http_lua_head_method = ngx_http_lua_method_name(\"HEAD\");\nngx_str_t  ngx_http_lua_delete_method =\n        ngx_http_lua_method_name(\"DELETE\");\nngx_str_t  ngx_http_lua_options_method =\n        ngx_http_lua_method_name(\"OPTIONS\");\nngx_str_t  ngx_http_lua_copy_method = ngx_http_lua_method_name(\"COPY\");\nngx_str_t  ngx_http_lua_move_method = ngx_http_lua_method_name(\"MOVE\");\nngx_str_t  ngx_http_lua_lock_method = ngx_http_lua_method_name(\"LOCK\");\nngx_str_t  ngx_http_lua_mkcol_method =\n        ngx_http_lua_method_name(\"MKCOL\");\nngx_str_t  ngx_http_lua_propfind_method =\n        ngx_http_lua_method_name(\"PROPFIND\");\nngx_str_t  ngx_http_lua_proppatch_method =\n        ngx_http_lua_method_name(\"PROPPATCH\");\nngx_str_t  ngx_http_lua_unlock_method =\n        ngx_http_lua_method_name(\"UNLOCK\");\nngx_str_t  ngx_http_lua_patch_method =\n        ngx_http_lua_method_name(\"PATCH\");\nngx_str_t  ngx_http_lua_trace_method =\n        ngx_http_lua_method_name(\"TRACE\");\n\n\nstatic ngx_str_t  ngx_http_lua_content_length_header_key =\n    ngx_string(\"Content-Length\");\n\n\nstatic ngx_int_t ngx_http_lua_adjust_subrequest(ngx_http_request_t *sr,\n    ngx_uint_t method, int forward_body,\n    ngx_http_request_body_t *body, unsigned vars_action,\n    ngx_array_t *extra_vars);\nstatic int ngx_http_lua_ngx_location_capture(lua_State *L);\nstatic int ngx_http_lua_ngx_location_capture_multi(lua_State *L);\nstatic void ngx_http_lua_process_vars_option(ngx_http_request_t *r,\n    lua_State *L, int table, ngx_array_t **varsp);\nstatic ngx_int_t ngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *r,\n    ngx_array_t *extra_vars);\nstatic ngx_int_t ngx_http_lua_subrequest(ngx_http_request_t *r,\n    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n    ngx_http_post_subrequest_t *ps, ngx_uint_t flags);\nstatic ngx_int_t ngx_http_lua_subrequest_resume(ngx_http_request_t *r);\nstatic void ngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,\n    ngx_http_lua_ctx_t *ctx);\nstatic void ngx_http_lua_cancel_subreq(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_post_request_to_head(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked);\n\n\nenum {\n    NGX_HTTP_LUA_SUBREQ_TRUNCATED = 1,\n};\n\n\n/* ngx.location.capture is just a thin wrapper around\n * ngx.location.capture_multi */\nstatic int\nngx_http_lua_ngx_location_capture(lua_State *L)\n{\n    int                 n;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting one or two arguments\");\n    }\n\n    lua_createtable(L, n, 0); /* uri opts? table  */\n    lua_insert(L, 1); /* table uri opts? */\n    if (n == 1) { /* table uri */\n        lua_rawseti(L, 1, 1); /* table */\n\n    } else { /* table uri opts */\n        lua_rawseti(L, 1, 2); /* table uri */\n        lua_rawseti(L, 1, 1); /* table */\n    }\n\n    lua_createtable(L, 1, 0); /* table table' */\n    lua_insert(L, 1);   /* table' table */\n    lua_rawseti(L, 1, 1); /* table' */\n\n    return ngx_http_lua_ngx_location_capture_multi(L);\n}\n\n\nstatic int\nngx_http_lua_ngx_location_capture_multi(lua_State *L)\n{\n    ngx_http_request_t              *r;\n    ngx_http_request_t              *sr = NULL; /* subrequest object */\n    ngx_http_post_subrequest_t      *psr;\n    ngx_http_lua_ctx_t              *sr_ctx;\n    ngx_http_lua_ctx_t              *ctx;\n    ngx_array_t                     *extra_vars;\n    ngx_str_t                        uri;\n    ngx_str_t                        args;\n    ngx_str_t                        extra_args;\n    ngx_uint_t                       flags;\n    u_char                          *p;\n    u_char                          *q;\n    size_t                           len;\n    size_t                           nargs;\n    int                              rc;\n    int                              n;\n    int                              always_forward_body = 0;\n    ngx_uint_t                       method;\n    ngx_http_request_body_t         *body;\n    int                              type;\n    ngx_buf_t                       *b;\n    unsigned                         vars_action;\n    ngx_uint_t                       nsubreqs;\n    ngx_uint_t                       index;\n    size_t                           sr_statuses_len;\n    size_t                           sr_headers_len;\n    size_t                           sr_bodies_len;\n    size_t                           sr_flags_len;\n    size_t                           ofs1, ofs2;\n    unsigned                         custom_ctx;\n    ngx_http_lua_co_ctx_t           *coctx;\n\n    ngx_http_lua_post_subrequest_data_t      *psr_data;\n\n    n = lua_gettop(L);\n    if (n != 1) {\n        return luaL_error(L, \"only one argument is expected, but got %d\", n);\n    }\n\n    luaL_checktype(L, 1, LUA_TTABLE);\n\n    nsubreqs = lua_objlen(L, 1);\n    if (nsubreqs == 0) {\n        return luaL_error(L, \"at least one subrequest should be specified\");\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request object found\");\n    }\n\n#if (NGX_HTTP_V2)\n    if (r->main->stream) {\n        return luaL_error(L, \"http2 requests not supported yet\");\n    }\n#endif\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return luaL_error(L, \"no ctx found\");\n    }\n\n    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE\n                               | NGX_HTTP_LUA_CONTEXT_ACCESS\n                               | NGX_HTTP_LUA_CONTEXT_CONTENT);\n\n    coctx = ctx->cur_co_ctx;\n    if (coctx == NULL) {\n        return luaL_error(L, \"no co ctx found\");\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua location capture, uri:\\\"%V\\\" c:%ud\", &r->uri,\n                   r->main->count);\n\n    sr_statuses_len = nsubreqs * sizeof(ngx_int_t);\n    sr_headers_len  = nsubreqs * sizeof(ngx_http_headers_out_t *);\n    sr_bodies_len   = nsubreqs * sizeof(ngx_str_t);\n    sr_flags_len    = nsubreqs * sizeof(uint8_t);\n\n    p = ngx_pcalloc(r->pool, sr_statuses_len + sr_headers_len +\n                    sr_bodies_len + sr_flags_len);\n\n    if (p == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    coctx->sr_statuses = (void *) p;\n    p += sr_statuses_len;\n\n    coctx->sr_headers = (void *) p;\n    p += sr_headers_len;\n\n    coctx->sr_bodies = (void *) p;\n    p += sr_bodies_len;\n\n    coctx->sr_flags = (void *) p;\n\n    coctx->nsubreqs = nsubreqs;\n\n    coctx->pending_subreqs = 0;\n\n    extra_vars = NULL;\n\n    for (index = 0; index < nsubreqs; index++) {\n        coctx->pending_subreqs++;\n\n        lua_rawgeti(L, 1, index + 1);\n        if (lua_isnil(L, -1)) {\n            return luaL_error(L, \"only array-like tables are allowed\");\n        }\n\n        dd(\"queries query: top %d\", lua_gettop(L));\n\n        if (lua_type(L, -1) != LUA_TTABLE) {\n            return luaL_error(L, \"the query argument %d is not a table, \"\n                              \"but a %s\",\n                              index, lua_typename(L, lua_type(L, -1)));\n        }\n\n        nargs = lua_objlen(L, -1);\n\n        if (nargs != 1 && nargs != 2) {\n            return luaL_error(L, \"query argument %d expecting one or \"\n                              \"two arguments\", index);\n        }\n\n        lua_rawgeti(L, 2, 1); /* queries query uri */\n\n        dd(\"queries query uri: %d\", lua_gettop(L));\n\n        dd(\"first arg in first query: %s\", lua_typename(L, lua_type(L, -1)));\n\n        body = NULL;\n\n        ngx_str_null(&extra_args);\n\n        if (extra_vars != NULL) {\n            /* flush out existing elements in the array */\n            extra_vars->nelts = 0;\n        }\n\n        vars_action = 0;\n\n        custom_ctx = 0;\n\n        if (nargs == 2) {\n            /* check out the options table */\n\n            lua_rawgeti(L, 2, 2); /* queries query uri opts */\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            if (lua_type(L, 4) != LUA_TTABLE) {\n                return luaL_error(L, \"expecting table as the 2nd argument for \"\n                                  \"subrequest %d, but got %s\", index,\n                                  luaL_typename(L, 4));\n            }\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the args option */\n\n            lua_getfield(L, 4, \"args\");\n\n            type = lua_type(L, -1);\n\n            switch (type) {\n            case LUA_TTABLE:\n                ngx_http_lua_process_args_option(r, L, -1, &extra_args);\n                break;\n\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TNUMBER:\n            case LUA_TSTRING:\n                extra_args.data = (u_char *) lua_tolstring(L, -1, &len);\n                extra_args.len = len;\n\n                break;\n\n            default:\n                return luaL_error(L, \"Bad args option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the vars option */\n\n            lua_getfield(L, 4, \"vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TTABLE:\n                ngx_http_lua_process_vars_option(r, L, -1, &extra_vars);\n\n                dd(\"post process vars top: %d\", lua_gettop(L));\n                break;\n\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            default:\n                return luaL_error(L, \"Bad vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the share_all_vars option */\n\n            lua_getfield(L, 4, \"share_all_vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TBOOLEAN:\n                if (lua_toboolean(L, -1)) {\n                    vars_action |= NGX_HTTP_LUA_SHARE_ALL_VARS;\n                }\n                break;\n\n            default:\n                return luaL_error(L, \"Bad share_all_vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the copy_all_vars option */\n\n            lua_getfield(L, 4, \"copy_all_vars\");\n\n            switch (lua_type(L, -1)) {\n            case LUA_TNIL:\n                /* do nothing */\n                break;\n\n            case LUA_TBOOLEAN:\n                if (lua_toboolean(L, -1)) {\n                    vars_action |= NGX_HTTP_LUA_COPY_ALL_VARS;\n                }\n                break;\n\n            default:\n                return luaL_error(L, \"Bad copy_all_vars option value\");\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the \"forward_body\" option */\n\n            lua_getfield(L, 4, \"always_forward_body\");\n            always_forward_body = lua_toboolean(L, -1);\n            lua_pop(L, 1);\n\n            dd(\"always forward body: %d\", always_forward_body);\n\n            /* check the \"method\" option */\n\n            lua_getfield(L, 4, \"method\");\n\n            type = lua_type(L, -1);\n\n            if (type == LUA_TNIL) {\n                method = NGX_HTTP_GET;\n\n            } else {\n                if (type != LUA_TNUMBER) {\n                    return luaL_error(L, \"Bad http request method\");\n                }\n\n                method = (ngx_uint_t) lua_tonumber(L, -1);\n            }\n\n            lua_pop(L, 1);\n\n            dd(\"queries query uri opts: %d\", lua_gettop(L));\n\n            /* check the \"ctx\" option */\n\n            lua_getfield(L, 4, \"ctx\");\n\n            type = lua_type(L, -1);\n\n            if (type != LUA_TNIL) {\n                if (type != LUA_TTABLE) {\n                    return luaL_error(L, \"Bad ctx option value type %s, \"\n                                      \"expected a Lua table\",\n                                      lua_typename(L, type));\n                }\n\n                custom_ctx = 1;\n\n            } else {\n                lua_pop(L, 1);\n            }\n\n            dd(\"queries query uri opts ctx?: %d\", lua_gettop(L));\n\n            /* check the \"body\" option */\n\n            lua_getfield(L, 4, \"body\");\n\n            type = lua_type(L, -1);\n\n            if (type != LUA_TNIL) {\n                if (type != LUA_TSTRING && type != LUA_TNUMBER) {\n                    return luaL_error(L, \"Bad http request body\");\n                }\n\n                body = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));\n\n                if (body == NULL) {\n                    return luaL_error(L, \"no memory\");\n                }\n\n                q = (u_char *) lua_tolstring(L, -1, &len);\n\n                dd(\"request body: [%.*s]\", (int) len, q);\n\n                if (len) {\n                    b = ngx_create_temp_buf(r->pool, len);\n                    if (b == NULL) {\n                        return luaL_error(L, \"no memory\");\n                    }\n\n                    b->last = ngx_copy(b->last, q, len);\n\n                    body->bufs = ngx_alloc_chain_link(r->pool);\n                    if (body->bufs == NULL) {\n                        return luaL_error(L, \"no memory\");\n                    }\n\n                    body->bufs->buf = b;\n                    body->bufs->next = NULL;\n\n                    body->buf = b;\n                }\n            }\n\n            lua_pop(L, 1); /* pop the body */\n\n            /* stack: queries query uri opts ctx? */\n\n            lua_remove(L, 4);\n\n            /* stack: queries query uri ctx? */\n\n            dd(\"queries query uri ctx?: %d\", lua_gettop(L));\n\n        } else {\n            method = NGX_HTTP_GET;\n        }\n\n        /* stack: queries query uri ctx? */\n\n        p = (u_char *) luaL_checklstring(L, 3, &len);\n\n        uri.data = ngx_palloc(r->pool, len);\n        if (uri.data == NULL) {\n            return luaL_error(L, \"memory allocation error\");\n        }\n\n        ngx_memcpy(uri.data, p, len);\n\n        uri.len = len;\n\n        ngx_str_null(&args);\n\n        flags = 0;\n\n        rc = ngx_http_parse_unsafe_uri(r, &uri, &args, &flags);\n        if (rc != NGX_OK) {\n            dd(\"rc = %d\", (int) rc);\n\n            return luaL_error(L, \"unsafe uri in argument #1: %s\", p);\n        }\n\n        if (args.len == 0) {\n            if (extra_args.len) {\n                p = ngx_palloc(r->pool, extra_args.len);\n                if (p == NULL) {\n                    return luaL_error(L, \"no memory\");\n                }\n\n                ngx_memcpy(p, extra_args.data, extra_args.len);\n\n                args.data = p;\n                args.len = extra_args.len;\n            }\n\n        } else if (extra_args.len) {\n            /* concatenate the two parts of args together */\n            len = args.len + (sizeof(\"&\") - 1) + extra_args.len;\n\n            p = ngx_palloc(r->pool, len);\n            if (p == NULL) {\n                return luaL_error(L, \"no memory\");\n            }\n\n            q = ngx_copy(p, args.data, args.len);\n            *q++ = '&';\n            ngx_memcpy(q, extra_args.data, extra_args.len);\n\n            args.data = p;\n            args.len = len;\n        }\n\n        ofs1 = ngx_align(sizeof(ngx_http_post_subrequest_t), sizeof(void *));\n        ofs2 = ngx_align(sizeof(ngx_http_lua_ctx_t), sizeof(void *));\n\n        p = ngx_palloc(r->pool, ofs1 + ofs2\n                       + sizeof(ngx_http_lua_post_subrequest_data_t));\n        if (p == NULL) {\n            return luaL_error(L, \"no memory\");\n        }\n\n        psr = (ngx_http_post_subrequest_t *) p;\n\n        p += ofs1;\n\n        sr_ctx = (ngx_http_lua_ctx_t *) p;\n\n        ngx_http_lua_assert((void *) sr_ctx == ngx_align_ptr(sr_ctx,\n                                                             sizeof(void *)));\n\n        p += ofs2;\n\n        psr_data = (ngx_http_lua_post_subrequest_data_t *) p;\n\n        ngx_http_lua_assert((void *) psr_data == ngx_align_ptr(psr_data,\n                                                               sizeof(void *)));\n\n        ngx_memzero(sr_ctx, sizeof(ngx_http_lua_ctx_t));\n\n        /* set by ngx_memzero:\n         *      sr_ctx->run_post_subrequest = 0\n         *      sr_ctx->free = NULL\n         *      sr_ctx->body = NULL\n         */\n\n        psr_data->ctx = sr_ctx;\n        psr_data->pr_co_ctx = coctx;\n\n        psr->handler = ngx_http_lua_post_subrequest;\n        psr->data = psr_data;\n\n        rc = ngx_http_lua_subrequest(r, &uri, &args, &sr, psr, 0);\n\n        if (rc != NGX_OK) {\n            return luaL_error(L, \"failed to issue subrequest: %d\", (int) rc);\n        }\n\n        ngx_http_lua_init_ctx(sr, sr_ctx);\n\n        sr_ctx->capture = 1;\n        sr_ctx->index = index;\n        sr_ctx->last_body = &sr_ctx->body;\n        sr_ctx->vm_state = ctx->vm_state;\n\n        ngx_http_set_ctx(sr, sr_ctx, ngx_http_lua_module);\n\n        rc = ngx_http_lua_adjust_subrequest(sr, method, always_forward_body,\n                                            body, vars_action, extra_vars);\n\n        if (rc != NGX_OK) {\n            ngx_http_lua_cancel_subreq(sr);\n            return luaL_error(L, \"failed to adjust the subrequest: %d\",\n                              (int) rc);\n        }\n\n        dd(\"queries query uri opts ctx? %d\", lua_gettop(L));\n\n        /* stack: queries query uri ctx? */\n\n        if (custom_ctx) {\n            ngx_http_lua_ngx_set_ctx_helper(L, sr, sr_ctx, -1);\n            lua_pop(L, 3);\n\n        } else {\n            lua_pop(L, 2);\n        }\n\n        /* stack: queries */\n    }\n\n    if (extra_vars) {\n        ngx_array_destroy(extra_vars);\n    }\n\n    ctx->no_abort = 1;\n\n    return lua_yield(L, 0);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_http_core_main_conf_t   *cmcf;\n    int                          pr_not_chunked = 0;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        sr->request_body = NULL;\n\n    } else {\n        if (!r->headers_in.chunked) {\n            pr_not_chunked = 1;\n        }\n\n        if (sr->request_body && sr->request_body->temp_file) {\n\n            /* deep-copy the request body */\n\n            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *sr,\n    ngx_array_t *extra_vars)\n{\n    ngx_http_core_main_conf_t   *cmcf;\n    ngx_http_variable_t         *v;\n    ngx_http_variable_value_t   *vv;\n    u_char                      *val;\n    u_char                      *p;\n    ngx_uint_t                   i, hash;\n    ngx_str_t                    name;\n    size_t                       len;\n    ngx_hash_t                  *variables_hash;\n    ngx_keyval_t                *var;\n\n    /* set any extra variables that were passed to the subrequest */\n\n    if (extra_vars == NULL || extra_vars->nelts == 0) {\n        return NGX_OK;\n    }\n\n    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n    variables_hash = &cmcf->variables_hash;\n\n    var = extra_vars->elts;\n\n    for (i = 0; i < extra_vars->nelts; i++, var++) {\n        /* copy the variable's name and value because they are allocated\n         * by the lua VM */\n\n        len = var->key.len + var->value.len;\n\n        p = ngx_pnalloc(sr->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        name.data = p;\n        name.len = var->key.len;\n\n        p = ngx_copy(p, var->key.data, var->key.len);\n\n        hash = ngx_hash_strlow(name.data, name.data, name.len);\n\n        val = p;\n        len = var->value.len;\n\n        ngx_memcpy(p, var->value.data, len);\n\n        v = ngx_hash_find(variables_hash, hash, name.data, name.len);\n\n        if (v) {\n            if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {\n                ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                              \"variable \\\"%V\\\" not changeable\", &name);\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            if (v->set_handler) {\n                vv = ngx_palloc(sr->pool, sizeof(ngx_http_variable_value_t));\n                if (vv == NULL) {\n                    return NGX_ERROR;\n                }\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                v->set_handler(sr, vv, v->data);\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\", &name,\n                               vv);\n\n                continue;\n            }\n\n            if (v->flags & NGX_HTTP_VAR_INDEXED) {\n                vv = &sr->variables[v->index];\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\",\n                               &name, vv);\n\n                continue;\n            }\n        }\n\n        ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                      \"variable \\\"%V\\\" cannot be assigned a value (maybe you \"\n                      \"forgot to define it first?) \", &name);\n\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_lua_process_vars_option(ngx_http_request_t *r, lua_State *L,\n    int table, ngx_array_t **varsp)\n{\n    ngx_array_t         *vars;\n    ngx_keyval_t        *var;\n\n    if (table < 0) {\n        table = lua_gettop(L) + table + 1;\n    }\n\n    vars = *varsp;\n\n    if (vars == NULL) {\n\n        vars = ngx_array_create(r->pool, 4, sizeof(ngx_keyval_t));\n        if (vars == NULL) {\n            dd(\"here\");\n            luaL_error(L, \"no memory\");\n            return;\n        }\n\n        *varsp = vars;\n    }\n\n    lua_pushnil(L);\n    while (lua_next(L, table) != 0) {\n\n        if (lua_type(L, -2) != LUA_TSTRING) {\n            luaL_error(L, \"attempt to use a non-string key in the \"\n                       \"\\\"vars\\\" option table\");\n            return;\n        }\n\n        if (!lua_isstring(L, -1)) {\n            luaL_error(L, \"attempt to use bad variable value type %s\",\n                       luaL_typename(L, -1));\n            return;\n        }\n\n        var = ngx_array_push(vars);\n        if (var == NULL) {\n            dd(\"here\");\n            luaL_error(L, \"no memory\");\n            return;\n        }\n\n        var->key.data = (u_char *) lua_tolstring(L, -2, &var->key.len);\n        var->value.data = (u_char *) lua_tolstring(L, -1, &var->value.len);\n\n        lua_pop(L, 1);\n    }\n}\n\n\nngx_int_t\nngx_http_lua_post_subrequest(ngx_http_request_t *r, void *data, ngx_int_t rc)\n{\n    ngx_http_request_t            *pr;\n    ngx_http_lua_ctx_t            *pr_ctx;\n    ngx_http_lua_ctx_t            *ctx; /* subrequest ctx */\n    ngx_http_lua_co_ctx_t         *pr_coctx;\n    size_t                         len;\n    ngx_str_t                     *body_str;\n    u_char                        *p;\n    ngx_chain_t                   *cl;\n\n    ngx_http_lua_post_subrequest_data_t    *psr_data = data;\n\n    ctx = psr_data->ctx;\n\n    if (ctx->run_post_subrequest) {\n        if (r != r->connection->data) {\n            r->connection->data = r;\n        }\n\n        return NGX_OK;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run post subrequest handler, rc:%i c:%ud\", rc,\n                   r->main->count);\n\n    ctx->run_post_subrequest = 1;\n\n    pr = r->parent;\n\n    pr_ctx = ngx_http_get_module_ctx(pr, ngx_http_lua_module);\n    if (pr_ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    pr_coctx = psr_data->pr_co_ctx;\n    pr_coctx->pending_subreqs--;\n\n    if (pr_coctx->pending_subreqs == 0) {\n        dd(\"all subrequests are done\");\n\n        pr_ctx->no_abort = 0;\n        pr_ctx->resume_handler = ngx_http_lua_subrequest_resume;\n        pr_ctx->cur_co_ctx = pr_coctx;\n    }\n\n    if (pr_ctx->entered_content_phase) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"lua restoring write event handler\");\n\n        pr->write_event_handler = ngx_http_lua_content_wev_handler;\n\n    } else {\n        pr->write_event_handler = ngx_http_core_run_phases;\n    }\n\n    dd(\"status rc = %d\", (int) rc);\n    dd(\"status headers_out.status = %d\", (int) r->headers_out.status);\n    dd(\"uri: %.*s\", (int) r->uri.len, r->uri.data);\n\n    /*  capture subrequest response status */\n\n    pr_coctx->sr_statuses[ctx->index] = r->headers_out.status;\n\n    if (pr_coctx->sr_statuses[ctx->index] == 0) {\n        if (rc == NGX_OK) {\n            rc = NGX_HTTP_OK;\n        }\n\n        if (rc == NGX_ERROR) {\n            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (rc >= 100) {\n            pr_coctx->sr_statuses[ctx->index] = rc;\n        }\n    }\n\n    if (!ctx->seen_last_for_subreq) {\n        pr_coctx->sr_flags[ctx->index] |= NGX_HTTP_LUA_SUBREQ_TRUNCATED;\n    }\n\n    dd(\"pr_coctx status: %d\", (int) pr_coctx->sr_statuses[ctx->index]);\n\n    /* copy subrequest response headers */\n    if (ctx->headers_set) {\n        rc = ngx_http_lua_set_content_type(r, ctx);\n        if (rc != NGX_OK) {\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"failed to set default content type: %i\", rc);\n            return NGX_ERROR;\n        }\n    }\n\n    pr_coctx->sr_headers[ctx->index] = &r->headers_out;\n\n    /* copy subrequest response body */\n\n    body_str = &pr_coctx->sr_bodies[ctx->index];\n\n    len = 0;\n    for (cl = ctx->body; cl; cl = cl->next) {\n        /*  ignore all non-memory buffers */\n        len += cl->buf->last - cl->buf->pos;\n    }\n\n    body_str->len = len;\n\n    if (len == 0) {\n        body_str->data = NULL;\n\n    } else {\n        p = ngx_palloc(r->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        body_str->data = p;\n\n        /* copy from and then free the data buffers */\n\n        for (cl = ctx->body; cl; cl = cl->next) {\n            p = ngx_copy(p, cl->buf->pos, cl->buf->last - cl->buf->pos);\n\n            cl->buf->last = cl->buf->pos;\n\n#if 0\n            dd(\"free body chain link buf ASAP\");\n            ngx_pfree(r->pool, cl->buf->start);\n#endif\n        }\n    }\n\n    if (ctx->body) {\n\n        ngx_chain_update_chains(r->pool,\n                                &pr_ctx->free_bufs, &pr_ctx->busy_bufs,\n                                &ctx->body,\n                                (ngx_buf_tag_t) &ngx_http_lua_module);\n\n        dd(\"free bufs: %p\", pr_ctx->free_bufs);\n    }\n\n    ngx_http_post_request_to_head(pr);\n\n    if (r != r->connection->data) {\n        r->connection->data = r;\n    }\n\n    if (rc == NGX_ERROR\n        || rc == NGX_HTTP_CREATED\n        || rc == NGX_HTTP_NO_CONTENT\n        || (rc >= NGX_HTTP_SPECIAL_RESPONSE\n            && rc != NGX_HTTP_CLOSE\n            && rc != NGX_HTTP_REQUEST_TIME_OUT\n            && rc != NGX_HTTP_CLIENT_CLOSED_REQUEST))\n    {\n        /* emulate ngx_http_special_response_handler */\n\n        if (rc > NGX_OK) {\n            r->err_status = rc;\n\n            r->expect_tested = 1;\n            r->headers_out.content_type.len = 0;\n            r->headers_out.content_length_n = 0;\n\n            ngx_http_clear_accept_ranges(r);\n            ngx_http_clear_last_modified(r);\n\n            rc = ngx_http_lua_send_header_if_needed(r, ctx);\n            if (rc == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n        }\n\n        return NGX_OK;\n    }\n\n    return rc;\n}\n\n\nstatic void\nngx_http_lua_handle_subreq_responses(ngx_http_request_t *r,\n    ngx_http_lua_ctx_t *ctx)\n{\n    ngx_uint_t                   i, count;\n    ngx_uint_t                   index;\n    lua_State                   *co;\n    ngx_str_t                   *body_str;\n    ngx_table_elt_t             *header;\n    ngx_list_part_t             *part;\n    ngx_http_headers_out_t      *sr_headers;\n    ngx_http_lua_co_ctx_t       *coctx;\n\n    u_char                  buf[sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\") - 1];\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua handle subrequest responses\");\n\n    coctx = ctx->cur_co_ctx;\n    co = coctx->co;\n\n    for (index = 0; index < coctx->nsubreqs; index++) {\n        dd(\"summary: reqs %d, subquery %d, pending %d, req %.*s\",\n           (int) coctx->nsubreqs,\n           (int) index,\n           (int) coctx->pending_subreqs,\n           (int) r->uri.len, r->uri.data);\n\n        /*  {{{ construct ret value */\n        lua_createtable(co, 0 /* narr */, 4 /* nrec */);\n\n        /*  copy captured status */\n        lua_pushinteger(co, coctx->sr_statuses[index]);\n        lua_setfield(co, -2, \"status\");\n\n        dd(\"captured subrequest flags: %d\", (int) coctx->sr_flags[index]);\n\n        /* set truncated flag if truncation happens */\n        if (coctx->sr_flags[index] & NGX_HTTP_LUA_SUBREQ_TRUNCATED) {\n            lua_pushboolean(co, 1);\n            lua_setfield(co, -2, \"truncated\");\n\n        } else {\n            lua_pushboolean(co, 0);\n            lua_setfield(co, -2, \"truncated\");\n        }\n\n        /*  copy captured body */\n\n        body_str = &coctx->sr_bodies[index];\n\n        lua_pushlstring(co, (char *) body_str->data, body_str->len);\n        lua_setfield(co, -2, \"body\");\n\n        if (body_str->data) {\n            dd(\"free body buffer ASAP\");\n            ngx_pfree(r->pool, body_str->data);\n        }\n\n        /* copy captured headers */\n\n        sr_headers = coctx->sr_headers[index];\n\n        part = &sr_headers->headers.part;\n        count = part->nelts;\n        while (part->next) {\n            part = part->next;\n            count += part->nelts;\n        }\n\n        lua_createtable(co, 0, count + 5); /* res.header */\n\n        dd(\"saving subrequest response headers\");\n\n        part = &sr_headers->headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            dd(\"checking sr header %.*s\", (int) header[i].key.len,\n               header[i].key.data);\n\n#if 1\n            if (header[i].hash == 0) {\n                continue;\n            }\n#endif\n\n            header[i].hash = 0;\n\n            dd(\"pushing sr header %.*s\", (int) header[i].key.len,\n               header[i].key.data);\n\n            lua_pushlstring(co, (char *) header[i].key.data,\n                            header[i].key.len); /* header key */\n            lua_pushvalue(co, -1); /* stack: table key key */\n\n            /* check if header already exists */\n            lua_rawget(co, -3); /* stack: table key value */\n\n            if (lua_isnil(co, -1)) {\n                lua_pop(co, 1); /* stack: table key */\n\n                lua_pushlstring(co, (char *) header[i].value.data,\n                                header[i].value.len);\n                    /* stack: table key value */\n\n                lua_rawset(co, -3); /* stack: table */\n\n            } else {\n\n                if (!lua_istable(co, -1)) { /* already inserted one value */\n                    lua_createtable(co, 4, 0);\n                        /* stack: table key value table */\n\n                    lua_insert(co, -2); /* stack: table key table value */\n                    lua_rawseti(co, -2, 1); /* stack: table key table */\n\n                    lua_pushlstring(co, (char *) header[i].value.data,\n                                    header[i].value.len);\n                        /* stack: table key table value */\n\n                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);\n                        /* stack: table key table */\n\n                    lua_rawset(co, -3); /* stack: table */\n\n                } else {\n                    lua_pushlstring(co, (char *) header[i].value.data,\n                                    header[i].value.len);\n                        /* stack: table key table value */\n\n                    lua_rawseti(co, -2, lua_objlen(co, -2) + 1);\n                        /* stack: table key table */\n\n                    lua_pop(co, 2); /* stack: table */\n                }\n            }\n        }\n\n        if (sr_headers->content_type.len) {\n            lua_pushliteral(co, \"Content-Type\"); /* header key */\n            lua_pushlstring(co, (char *) sr_headers->content_type.data,\n                            sr_headers->content_type.len); /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        if (sr_headers->content_length == NULL\n            && sr_headers->content_length_n >= 0)\n        {\n            lua_pushliteral(co, \"Content-Length\"); /* header key */\n\n            lua_pushnumber(co, (lua_Number) sr_headers->content_length_n);\n                /* head key value */\n\n            lua_rawset(co, -3); /* head */\n        }\n\n        /* to work-around an issue in ngx_http_static_module\n         * (github issue #41) */\n        if (sr_headers->location && sr_headers->location->value.len) {\n            lua_pushliteral(co, \"Location\"); /* header key */\n            lua_pushlstring(co, (char *) sr_headers->location->value.data,\n                            sr_headers->location->value.len);\n            /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        if (sr_headers->last_modified_time != -1) {\n            if (sr_headers->status != NGX_HTTP_OK\n                && sr_headers->status != NGX_HTTP_PARTIAL_CONTENT\n                && sr_headers->status != NGX_HTTP_NOT_MODIFIED\n                && sr_headers->status != NGX_HTTP_NO_CONTENT)\n            {\n                sr_headers->last_modified_time = -1;\n                sr_headers->last_modified = NULL;\n            }\n        }\n\n        if (sr_headers->last_modified == NULL\n            && sr_headers->last_modified_time != -1)\n        {\n            (void) ngx_http_time(buf, sr_headers->last_modified_time);\n\n            lua_pushliteral(co, \"Last-Modified\"); /* header key */\n            lua_pushlstring(co, (char *) buf, sizeof(buf)); /* head key value */\n            lua_rawset(co, -3); /* head */\n        }\n\n        lua_setfield(co, -2, \"header\");\n\n        /*  }}} */\n    }\n}\n\n\nvoid\nngx_http_lua_inject_subrequest_api(lua_State *L)\n{\n    lua_createtable(L, 0 /* narr */, 2 /* nrec */); /* .location */\n\n    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture);\n    lua_setfield(L, -2, \"capture\");\n\n    lua_pushcfunction(L, ngx_http_lua_ngx_location_capture_multi);\n    lua_setfield(L, -2, \"capture_multi\");\n\n    lua_setfield(L, -2, \"location\");\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest(ngx_http_request_t *r,\n    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n    ngx_http_post_subrequest_t *ps, ngx_uint_t flags)\n{\n    ngx_time_t                    *tp;\n    ngx_connection_t              *c;\n    ngx_http_request_t            *sr;\n    ngx_http_core_srv_conf_t      *cscf;\n\n#if (nginx_version >= 1009005)\n\n    if (r->subrequests == 0) {\n#if defined(NGX_DTRACE) && NGX_DTRACE\n        ngx_http_probe_subrequest_cycle(r, uri, args);\n#endif\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"lua subrequests cycle while processing \\\"%V\\\"\", uri);\n        return NGX_ERROR;\n    }\n\n#else  /* nginx_version <= 1009004 */\n\n    r->main->subrequests--;\n\n    if (r->main->subrequests == 0) {\n#if defined(NGX_DTRACE) && NGX_DTRACE\n        ngx_http_probe_subrequest_cycle(r, uri, args);\n#endif\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"lua subrequests cycle while processing \\\"%V\\\"\", uri);\n        r->main->subrequests = 1;\n        return NGX_ERROR;\n    }\n\n#endif\n\n    sr = ngx_pcalloc(r->pool, sizeof(ngx_http_request_t));\n    if (sr == NULL) {\n        return NGX_ERROR;\n    }\n\n    sr->signature = NGX_HTTP_MODULE;\n\n    c = r->connection;\n    sr->connection = c;\n\n    sr->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);\n    if (sr->ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_list_init(&sr->headers_out.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    sr->main_conf = cscf->ctx->main_conf;\n    sr->srv_conf = cscf->ctx->srv_conf;\n    sr->loc_conf = cscf->ctx->loc_conf;\n\n    sr->pool = r->pool;\n\n    sr->headers_in.content_length_n = -1;\n    sr->headers_in.keep_alive_n = -1;\n\n    ngx_http_clear_content_length(sr);\n    ngx_http_clear_accept_ranges(sr);\n    ngx_http_clear_last_modified(sr);\n\n    sr->request_body = r->request_body;\n\n#if (NGX_HTTP_SPDY)\n    sr->spdy_stream = r->spdy_stream;\n#endif\n\n#if (NGX_HTTP_V2)\n    sr->stream = r->stream;\n#endif\n\n#ifdef HAVE_ALLOW_REQUEST_BODY_UPDATING_PATCH\n    sr->content_length_n = -1;\n#endif\n\n    sr->method = NGX_HTTP_GET;\n    sr->http_version = r->http_version;\n\n    sr->request_line = r->request_line;\n    sr->uri = *uri;\n\n    if (args) {\n        sr->args = *args;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"lua http subrequest \\\"%V?%V\\\"\", uri, &sr->args);\n\n    sr->subrequest_in_memory = (flags & NGX_HTTP_SUBREQUEST_IN_MEMORY) != 0;\n    sr->waited = (flags & NGX_HTTP_SUBREQUEST_WAITED) != 0;\n\n    sr->unparsed_uri = r->unparsed_uri;\n    sr->method_name = ngx_http_core_get_method;\n    sr->http_protocol = r->http_protocol;\n\n    ngx_http_set_exten(sr);\n\n    sr->main = r->main;\n    sr->parent = r;\n    sr->post_subrequest = ps;\n    sr->read_event_handler = ngx_http_request_empty_handler;\n    sr->write_event_handler = ngx_http_handler;\n\n    sr->variables = r->variables;\n\n    sr->log_handler = r->log_handler;\n\n    sr->internal = 1;\n\n    sr->discard_body = r->discard_body;\n    sr->expect_tested = 1;\n    sr->main_filter_need_in_memory = r->main_filter_need_in_memory;\n\n    sr->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;\n\n#if (nginx_version >= 1009005)\n    sr->subrequests = r->subrequests - 1;\n#endif\n\n    tp = ngx_timeofday();\n    sr->start_sec = tp->sec;\n    sr->start_msec = tp->msec;\n\n    r->main->count++;\n\n    *psr = sr;\n\n#if defined(NGX_DTRACE) && NGX_DTRACE\n    ngx_http_probe_subrequest_start(sr);\n#endif\n\n    return ngx_http_post_request(sr, NULL);\n}\n\n\nstatic ngx_int_t\nngx_http_lua_subrequest_resume(ngx_http_request_t *r)\n{\n    lua_State                   *vm;\n    ngx_int_t                    rc;\n    ngx_uint_t                   nreqs;\n    ngx_connection_t            *c;\n    ngx_http_lua_ctx_t          *ctx;\n    ngx_http_lua_co_ctx_t       *coctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ctx->resume_handler = ngx_http_lua_wev_handler;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run subrequests done, resuming lua thread\");\n\n    coctx = ctx->cur_co_ctx;\n\n    dd(\"nsubreqs: %d\", (int) coctx->nsubreqs);\n\n    ngx_http_lua_handle_subreq_responses(r, ctx);\n\n    dd(\"free sr_statues/headers/bodies memory ASAP\");\n\n#if 1\n    ngx_pfree(r->pool, coctx->sr_statuses);\n\n    coctx->sr_statuses = NULL;\n    coctx->sr_headers = NULL;\n    coctx->sr_bodies = NULL;\n    coctx->sr_flags = NULL;\n#endif\n\n    c = r->connection;\n    vm = ngx_http_lua_get_lua_vm(r, ctx);\n    nreqs = c->requests;\n\n    rc = ngx_http_lua_run_thread(vm, r, ctx, coctx->nsubreqs);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua run thread returned %d\", rc);\n\n    if (rc == NGX_AGAIN) {\n        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);\n    }\n\n    if (rc == NGX_DONE) {\n        ngx_http_lua_finalize_request(r, NGX_DONE);\n        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);\n    }\n\n    /* rc == NGX_ERROR || rc >= NGX_OK */\n\n    if (ctx->entered_content_phase) {\n        ngx_http_lua_finalize_request(r, rc);\n        return NGX_DONE;\n    }\n\n    return rc;\n}\n\n\nstatic void\nngx_http_lua_cancel_subreq(ngx_http_request_t *r)\n{\n    ngx_http_posted_request_t   *pr;\n    ngx_http_posted_request_t  **p;\n\n#if 1\n    r->main->count--;\n    r->main->subrequests++;\n#endif\n\n    p = &r->main->posted_requests;\n    for (pr = r->main->posted_requests; pr->next; pr = pr->next) {\n        p = &pr->next;\n    }\n\n    *p = NULL;\n\n    r->connection->data = r->parent;\n}\n\n\nstatic ngx_int_t\nngx_http_post_request_to_head(ngx_http_request_t *r)\n{\n    ngx_http_posted_request_t  *pr;\n\n    pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));\n    if (pr == NULL) {\n        return NGX_ERROR;\n    }\n\n    pr->request = r;\n    pr->next = r->main->posted_requests;\n    r->main->posted_requests = pr;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r)\n{\n    ngx_temp_file_t     *tf;\n\n    ngx_http_request_body_t   *body;\n\n    tf = r->request_body->temp_file;\n\n    if (!tf->persistent || !tf->clean) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"the request body was not read by ngx_lua\");\n\n        return NGX_ERROR;\n    }\n\n    body = ngx_palloc(r->pool, sizeof(ngx_http_request_body_t));\n    if (body == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body, r->request_body, sizeof(ngx_http_request_body_t));\n\n    body->temp_file = ngx_palloc(r->pool, sizeof(ngx_temp_file_t));\n    if (body->temp_file == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body->temp_file, tf, sizeof(ngx_temp_file_t));\n    dd(\"file fd: %d\", body->temp_file->file.fd);\n\n    r->request_body = body;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}\n\n\n/* vi:set ft=c ts=4 sw=4 et fdm=marker: */\n", "# vim:set ft= ts=4 sw=4 et fdm=marker:\n\nuse Test::Nginx::Socket::Lua;\n\n#master_on();\n#workers(1);\n#worker_connections(1014);\n#log_level('warn');\n#master_process_enabled(1);\n\nno_root_location;\nrepeat_each(2);\n\nplan tests => repeat_each() * (blocks() * 3 + 23);\n\n$ENV{TEST_NGINX_MEMCACHED_PORT} ||= 11211;\n$ENV{TEST_NGINX_HTML_DIR} ||= html_dir();\n\n#no_diff();\nno_long_string();\n#no_shuffle();\n\nrun_tests();\n\n__DATA__\n\n=== TEST 1: DELETE\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nDELETE\n--- error_log\nlua http subrequest \"/other?\"\n--- no_error_log\n[error]\n\n\n\n=== TEST 2: DELETE (proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nDELETE\n--- no_error_log\n[error]\n\n\n\n=== TEST 3: POST (nobody, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /t\n--- response_body\nPOST\n--- no_error_log\n[error]\n\n\n\n=== TEST 4: HEAD\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_HEAD });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\n--- no_error_log\n[error]\n\n\n\n=== TEST 5: explicit GET\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 6: implicit GET\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\")\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 7: implicit GET (empty option table)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\", {})\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET\n--- no_error_log\n[error]\n\n\n\n=== TEST 8: PUT (with body, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPUT\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 9: PUT (with body, no proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        #echo_read_request_body;\n\n        echo $echo_request_method;\n        #echo $echo_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPUT\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 10: PUT (no body, no proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        #echo_read_request_body;\n\n        echo $echo_request_method;\n        #echo $echo_request_body;\n        echo_request_body;\n        #echo \"[$http_content_length]\";\n        echo;\n    }\n\n    location /foo {\n        echo $echo_request_method;\n        echo -n \"[$http_content_length]\";\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n\n            ngx.print(res.body)\n\n            res = ngx.location.capture(\"/foo\")\n            ngx.say(res.body)\n\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nPUT\nhello\nGET\n[]\n--- no_error_log\n[error]\n\n\n\n=== TEST 11: POST (with body, proxy method)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chomp\nPOST\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 12: POST (with body, memc method)\n--- config\n    location /flush {\n        set $memc_cmd flush_all;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /memc {\n        set $memc_key $echo_request_uri;\n        set $memc_exptime 600;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.location.capture(\"/flush\");\n\n            local res = ngx.location.capture(\"/memc\");\n            ngx.say(\"GET: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello\" });\n            ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\");\n            ngx.say(\"cached: \" .. res.body);\n\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET: 404\nPUT: 201\ncached: hello\n--- no_error_log\n[error]\n\n\n\n=== TEST 13: POST (with body, memc method)\n--- config\n    location /flush {\n        set $memc_cmd flush_all;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /memc {\n        set $memc_cmd \"\";\n        set $memc_key $echo_request_uri;\n        set $memc_exptime 600;\n        memc_pass 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.location.capture(\"/flush\",\n                { share_all_vars = true });\n\n            local res = ngx.location.capture(\"/memc\",\n                { share_all_vars = true });\n            ngx.say(\"GET: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello\", share_all_vars = true });\n            ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\", { share_all_vars = true });\n            ngx.say(\"cached: \" .. res.body);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nGET: 404\nPUT: 201\ncached: hello\n--- no_error_log\n[error]\n\n\n\n=== TEST 14: empty args option table\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = {} })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body eval: \"\\n\"\n--- no_error_log\n[error]\n\n\n\n=== TEST 15: non-empty args option table (1 pair)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [\"fo=\"] = \"=>\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nfo%3D=%3D%3E\n--- no_error_log\n[error]\n\n\n\n=== TEST 16: non-empty args option table (2 pairs)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [\"fo=\"] = \"=>\",\n                    [\"=\"] = \":\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^(?:fo%3D=%3D%3E\\&%3D=%3A|%3D=%3A\\&fo%3D=%3D%3E)$\n--- no_error_log\n[error]\n--- no_error_log\n[error]\n\n\n\n=== TEST 17: non-empty args option table (2 pairs, no special chars)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { foo = 3,\n                    bar = \"hello\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^(?:bar=hello\\&foo=3|foo=3\\&bar=hello)$\n--- no_error_log\n[error]\n\n\n\n=== TEST 18: non-empty args option table (number key)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { [57] = \"hi\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like: 500 Internal Server Error\n--- error_code: 500\n--- error_log\nattempt to use a non-string key in the \"args\" option table\n\n\n\n=== TEST 19: non-empty args option table (plain arrays)\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { args = { \"hi\" } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like: 500 Internal Server Error\n--- error_code: 500\n--- error_log\nattempt to use a non-string key in the \"args\" option table\n\n\n\n=== TEST 20: more args\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo?a=3\",\n                { args = { b = 4 } })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\na=3&b=4\n--- no_error_log\n[error]\n\n\n\n=== TEST 21: more args\n--- config\n    location /foo {\n        echo $query_string;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo?a=3\",\n                { args = \"b=4\" })\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\na=3&b=4\n--- no_error_log\n[error]\n\n\n\n=== TEST 22: is_subrequest in main request\n--- config\n    location /lua {\n        content_by_lua '\n            if ngx.is_subrequest then\n                ngx.say(\"sub req\")\n            else\n                ngx.say(\"main req\")\n            end\n        ';\n    }\n--- request\n    GET /lua\n--- response_body\nmain req\n--- no_error_log\n[error]\n\n\n\n=== TEST 23: is_subrequest in sub request\n--- config\n    location /main {\n        echo_location /lua;\n    }\n\n    location /lua {\n        content_by_lua '\n            if ngx.is_subrequest then\n                ngx.say(\"sub req\")\n            else\n                ngx.say(\"main req\")\n            end\n        ';\n    }\n--- request\n    GET /main\n--- response_body\nsub req\n--- no_error_log\n[error]\n\n\n\n=== TEST 24: is_subrequest in sub request in set_by_lua\n--- config\n    location /main {\n        echo_location /lua;\n    }\n\n    location /lua {\n        set_by_lua $a '\n            if ngx.is_subrequest then\n                return \"sub req\"\n            else\n                return \"main req\"\n            end\n        ';\n        echo $a;\n    }\n--- request\n    GET /main\n--- response_body\nsub req\n--- no_error_log\n[error]\n\n\n\n=== TEST 25: header inheritance bug (without body) (github issue 38)\nhttps://github.com/chaoslawful/lua-nginx-module/issues/38\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo -n $http_foo;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_GET });\n            ngx.say(\"header foo: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- more_headers\nFoo: bar\n--- response_body\nheader foo: [bar]\n--- no_error_log\n[error]\n\n\n\n=== TEST 26: header inheritance bug (with body) (github issue 38)\nhttps://github.com/chaoslawful/lua-nginx-module/issues/38\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo -n $http_foo;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { body = \"abc\" });\n            ngx.say(\"header foo: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- more_headers\nFoo: bar\n--- response_body\nheader foo: [bar]\n--- no_error_log\n[error]\n\n\n\n=== TEST 27: lua calls lua via subrequests\n--- config\n    location /a {\n        content_by_lua '\n            ngx.say(\"hello, a\");\n        ';\n    }\n    location /b {\n        content_by_lua '\n            ngx.say(\"hello, b\");\n        ';\n    }\n    location /c {\n        content_by_lua '\n            ngx.say(\"hello, c\");\n        ';\n    }\n    location /main {\n        content_by_lua '\n            local res1, res2 = ngx.location.capture_multi({{\"/a\"}, {\"/b\"}})\n            local res3 = ngx.location.capture(\"/c\")\n            ngx.print(res1.body, res2.body, res3.body)\n        ';\n    }\n--- request\n    GET /main\n--- response_body\nhello, a\nhello, b\nhello, c\n--- error_log\nlua reuse free buf memory\n--- no_error_log\n[error]\n\n\n\n=== TEST 28: POST (with body, proxy method, main request is a POST too)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo_read_request_body;\n\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST, body = \"hello\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhi\n--- response_body chomp\nPOST\nhello\n--- no_error_log\n[error]\n\n\n\n=== TEST 29: Last-Modified response header for static file subrequest\n--- config\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo.html\")\n\n            ngx.say(res.status)\n            ngx.say(res.header[\"Last-Modified\"])\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- user_files\n>>> foo.html\nhello, static file\n--- response_body_like chomp\n^200\n[A-Za-z]+, \\d{1,2} [A-Za-z]+ \\d{4} \\d{2}:\\d{2}:\\d{2} GMT\nhello, static file$\n--- no_error_log\n[error]\n\n\n\n=== TEST 30: custom ctx table for subrequest\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.ctx.foo = \"bar\";\n        ';\n    }\n    location /lua {\n        content_by_lua '\n            local ctx = {}\n            local res = ngx.location.capture(\"/sub\", { ctx = ctx })\n\n            ngx.say(ctx.foo);\n            ngx.say(ngx.ctx.foo);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nbar\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 31: share the ctx with the parent\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.ctx.foo = \"bar\";\n        ';\n    }\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\", { ctx = ngx.ctx })\n            ngx.say(ngx.ctx.foo);\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nbar\n--- no_error_log\n[error]\n\n\n\n=== TEST 32: test memcached with subrequests\n--- http_config\n    upstream memc {\n        server 127.0.0.1:$TEST_NGINX_MEMCACHED_PORT;\n        keepalive 100;\n    }\n--- config\n    location /memc {\n        set $memc_key some_key;\n        set $memc_exptime 600;\n        memc_pass memc;\n    }\n\n    location /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\",\n                { method = ngx.HTTP_PUT, body = \"hello 1234\" });\n            -- ngx.say(\"PUT: \" .. res.status);\n\n            res = ngx.location.capture(\"/memc\");\n            ngx.say(\"some_key: \" .. res.body);\n        ';\n    }\n--- request\nGET /t\n--- response_body\nsome_key: hello 1234\n--- error_log\nlua reuse free buf chain, but reallocate memory because\n--- no_error_log\n[error]\n\n\n\n=== TEST 33: main POST, sub GET (main does not read the body)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nGET\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 34: main POST, sub GET (main has read the body)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_GET });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nGET\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 35: main POST, sub POST (inherit bodies directly)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_POST });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nPOST\nhello, world\n--- no_error_log\n[error]\n\n\n\n=== TEST 36: main POST, sub PUT (inherit bodies directly)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.var.request_method)\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /foo {\n        proxy_pass http://127.0.0.1:$server_port/other;\n        #proxy_pass http://127.0.0.1:8892/other;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            local res = ngx.location.capture(\"/foo\",\n                { method = ngx.HTTP_PUT });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nPOST /lua\nhello, world\n--- response_body\nPUT\nhello, world\n--- no_error_log\n[error]\n\n\n\n=== TEST 37: recursive calls\n--- config\n    location /t {\n        content_by_lua '\n            ngx.location.capture(\"/t\")\n        ';\n    }\n--- request\n    GET /t\n--- ignore_response\n--- error_log\nlua subrequests cycle while processing \"/t\"\n\n\n\n=== TEST 38: OPTIONS\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_OPTIONS });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nOPTIONS\n--- no_error_log\n[error]\n\n\n\n=== TEST 39: OPTIONS with a body\n--- config\n    location /other {\n        default_type 'foo/bar';\n        echo $echo_request_method;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_OPTIONS, body = \"hello world\" });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nGET /lua\n--- response_body chop\nOPTIONS\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 40: encode args table with a multi-value arg.\n--- config\n    location /t {\n        content_by_lua '\n            local args, err = ngx.req.get_uri_args()\n            if err then\n                ngx.say(\"err: \", err)\n            end\n\n            local res = ngx.location.capture(\"/sub\", { args = args })\n            ngx.print(res.body)\n        ';\n    }\n\n    location /sub {\n        echo $query_string;\n    }\n--- request\nGET /t?r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fjquery%2F1.7.2%2Fjquery.min.js&r[]=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fdojo%2F1.7.2%2Fdojo%2Fdojo.js.uncompressed.js\n--- response_body\nr%5B%5D=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fjquery%2F1.7.2%2Fjquery.min.js&r%5B%5D=http%3A%2F%2Fajax.googleapis.com%3A80%2Fajax%2Flibs%2Fdojo%2F1.7.2%2Fdojo%2Fdojo.js.uncompressed.js\n--- no_error_log\n[error]\n\n\n\n=== TEST 41: subrequests finalized with NGX_ERROR\n--- config\n    location /sub {\n        content_by_lua '\n            ngx.exit(ngx.ERROR)\n        ';\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- response_body\nstatus: 500\nbody: \n\n\n\n=== TEST 42: subrequests finalized with 500\n--- config\n    location /sub {\n        return 500;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- response_body\nstatus: 500\nbody: \n\n\n\n=== TEST 43: subrequests with an output body filter returning NGX_ERROR\n--- config\n    location /sub {\n        echo hello world;\n        body_filter_by_lua '\n            return ngx.ERROR\n        ';\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n        ';\n    }\n--- request\nGET /main\n--- stap2\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n--- response_body\n--- error_code\n--- no_error_log\n[error]\n\n\n\n=== TEST 44: subrequests truncated in its response body due to premature connection close (nonbuffered)\n--- config\n    server_tokens off;\n    location /memc {\n        internal;\n\n        set $memc_key 'foo';\n        #set $memc_exptime 300;\n        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19112\n--- tcp_query_len: 9\n--- tcp_reply eval\n\"VALUE foo 0 1024\\r\\nhello world\"\n\n--- stap2\nF(ngx_http_lua_capture_body_filter) {\n    if (pid() == target() && $r != $r->main) {\n        printf(\"lua capture body output: %s\\n\", ngx_chain_dump($in))\n        if ($in->buf->last_in_chain) {\n            print_ubacktrace()\n        }\n    }\n}\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 45: subrequests truncated in its response body due to upstream read timeout (nonbuffered)\n--- config\n    memc_read_timeout 100ms;\n    location /memc {\n        internal;\n\n        set $memc_key 'foo';\n        #set $memc_exptime 300;\n        memc_pass 127.0.0.1:19112; #$TEST_NGINX_MEMCACHED_PORT;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/memc\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19112\n--- tcp_no_close\n--- tcp_reply eval\n\"VALUE foo 0 1024\\r\\nhello world\"\n\n--- stap2\nF(ngx_http_lua_capture_body_filter) {\n    if (pid() == target() && $r != $r->main) {\n        printf(\"lua capture body output: %s\\n\", ngx_chain_dump($in))\n        //if ($in->buf->last_in_chain) {\n            print_ubacktrace()\n        //}\n    }\n}\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=504\npost subreq: rc=0, status=200\n\n--- response_body_like chop\n^status: 200\nbody: [^\\n]*\ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 46: subrequests truncated in its response body due to premature connection close (buffered)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 47: subrequests truncated in its response body due to read timeout (buffered)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 48: subrequests truncated in its response body due to premature connection close (buffered, no content-length)\n--- config\n    server_tokens off;\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: false\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 49: subrequests truncated in its response body due to read timeout (buffered, no content-length)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 50: subrequests truncated in its response body due to premature connection close (nonbuffered, no content-length)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: false\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 51: subrequests truncated in its response body due to read timeout (nonbuffered, no content-length)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 500ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=504\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 52: forwarding in-memory request bodies to multiple subrequests\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n\n--- request eval\n\"POST /lua\n\" . \"hello world\"\n\n--- response_body\nhello world\nhello world\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 53: forwarding in-file request bodies to multiple subrequests (client_body_in_file_only)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    client_body_in_file_only on;\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n\n--- request eval\n\"POST /lua\n\" . \"hello world\"\n\n--- response_body\nhello world\nhello world\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 54: forwarding in-file request bodies to multiple subrequests (exceeding client_body_buffer_size)\n--- config\n    location /other {\n        default_type 'foo/bar';\n        proxy_pass http://127.0.0.1:$server_port/back;\n    }\n\n    location /back {\n        echo_read_request_body;\n        echo_request_body;\n    }\n\n    location /lua {\n        #client_body_in_file_only on;\n        client_body_buffer_size 1;\n        content_by_lua '\n            ngx.req.read_body()\n\n            for i = 1, 2 do\n                local res = ngx.location.capture(\"/other\",\n                    { method = ngx.HTTP_POST });\n\n                ngx.say(res.body)\n            end\n        ';\n    }\n--- request eval\n\"POST /lua\n\" . (\"hello world\" x 100)\n\n--- stap2\nglobal valid = 0\nglobal fds\n\nF(ngx_http_handler) { valid = 1  }\n\nprobe syscall.open {\n    if (valid && pid() == target()) {\n        print(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.close {\n    if (valid && pid() == target() && fds[sprintf(\"%d\", $fd)]) {\n        println(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.unlink {\n    if (valid && pid() == target()) {\n        println(name, \"(\", argstr, \")\")\n    }\n}\n\nprobe syscall.open.return {\n    if (valid && pid() == target()) {\n        println(\" = \", retstr)\n        fds[retstr] = 1\n    }\n}\n\nF(ngx_http_lua_subrequest) {\n    println(\"lua subrequest\")\n}\n\nF(ngx_output_chain) {\n    printf(\"output chain: %s\\n\", ngx_chain_dump($in))\n}\n\nF(ngx_pool_run_cleanup_file) {\n    println(\"clean up file: \", $fd)\n}\n\n--- response_body eval\n(\"hello world\" x 100) . \"\\n\"\n. (\"hello world\" x 100) . \"\\n\"\n\n--- no_error_log\n[error]\n--- error_log\na client request body is buffered to a temporary file\n\n\n\n=== TEST 55: subrequests truncated in its response body due to premature connection close (buffered + chunked)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_http_version 1.1;\n        proxy_buffering on;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 56: subrequests truncated in its response body due to premature connection close (nonbuffered + chunked)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 57: subrequests truncated in its response body due to read timeout (buffered + chunked)\n--- config\n    location /proxy {\n        internal;\n\n        proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nb\\r\\nhello world\\r\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nconn err: 110: upstream timed out\nupstream fin req: error=0 eof=0 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: \ntruncated: true\n\n--- error_log\nupstream timed out\n\n\n\n=== TEST 58: good chunked response (buffered)\n--- config\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering on;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\\n0\\r\\n\\r\\n\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=0 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello\ntruncated: false\n\n\n\n=== TEST 59: good chunked response (nonbuffered)\n--- config\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_http_version 1.1;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_no_close\n--- tcp_reply eval\n\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\\n0\\r\\n\\r\\n\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=0 rc=0\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello\ntruncated: false\n\n\n\n=== TEST 60: subrequests truncated in its response body due to premature connection close (nonbuffered + proxy)\n--- config\n    server_tokens off;\n\n    location /proxy {\n        internal;\n\n        #proxy_read_timeout 100ms;\n        proxy_buffering off;\n        proxy_pass http://127.0.0.1:19113;\n    }\n\n    location /main {\n        content_by_lua '\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.say(\"status: \", res.status)\n            ngx.say(\"body: \", res.body)\n            ngx.say(\"truncated: \", res.truncated)\n        ';\n    }\n--- request\nGET /main\n--- tcp_listen: 19113\n--- tcp_query_len: 65\n--- tcp_reply eval\n\"HTTP/1.0 200 OK\\r\\nContent-Length: 1024\\r\\n\\r\\nhello world\"\n\n--- stap\nF(ngx_http_upstream_finalize_request) {\n    printf(\"upstream fin req: error=%d eof=%d rc=%d\\n\",\n        $r->upstream->peer->connection->read->error,\n        $r->upstream->peer->connection->read->eof,\n        $rc)\n    #print_ubacktrace()\n}\nF(ngx_connection_error) {\n    printf(\"conn err: %d: %s\\n\", $err, user_string($text))\n    #print_ubacktrace()\n}\nF(ngx_http_lua_post_subrequest) {\n    printf(\"post subreq: rc=%d, status=%d\\n\", $rc, $r->headers_out->status)\n    #print_ubacktrace()\n}\n/*\nF(ngx_http_finalize_request) {\n    printf(\"finalize: %d\\n\", $rc)\n}\n*/\n--- stap_out\nupstream fin req: error=0 eof=1 rc=502\npost subreq: rc=0, status=200\n\n--- response_body\nstatus: 200\nbody: hello world\ntruncated: true\n\n--- error_log\nupstream prematurely closed connection\n\n\n\n=== TEST 61: WebDAV methods\n--- config\n    location /other {\n        echo \"method: $echo_request_method\";\n    }\n\n    location /lua {\n        content_by_lua '\n            local methods = {\n                ngx.HTTP_MKCOL,\n                ngx.HTTP_COPY,\n                ngx.HTTP_MOVE,\n                ngx.HTTP_PROPFIND,\n                ngx.HTTP_PROPPATCH,\n                ngx.HTTP_LOCK,\n                ngx.HTTP_UNLOCK,\n                ngx.HTTP_PATCH,\n                ngx.HTTP_TRACE,\n            }\n\n            for i, method in ipairs(methods) do\n                local res = ngx.location.capture(\"/other\",\n                    { method = method })\n                ngx.print(res.body)\n            end\n        ';\n    }\n--- request\nGET /lua\n--- response_body\nmethod: MKCOL\nmethod: COPY\nmethod: MOVE\nmethod: PROPFIND\nmethod: PROPPATCH\nmethod: LOCK\nmethod: UNLOCK\nmethod: PATCH\nmethod: TRACE\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 62: by default DELETE subrequests don't forward request bodies\n--- config\n    location /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- response_body\nnil\n--- no_error_log\n[error]\n\n\n\n=== TEST 63: DELETE subrequests do forward request bodies when always_forward_body == true\n--- config\n    location = /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE, always_forward_body = true });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- response_body\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 64: DELETE subrequests do forward request bodies when always_forward_body == true (on disk)\n--- config\n    location = /other {\n        default_type 'foo/bar';\n        content_by_lua '\n            ngx.req.read_body()\n            ngx.say(ngx.req.get_body_data())\n        ';\n    }\n\n    location /lua {\n        content_by_lua '\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/other\",\n                { method = ngx.HTTP_DELETE, always_forward_body = true });\n\n            ngx.print(res.body)\n        ';\n    }\n--- request\nDELETE /lua\nhello world\n--- stap2\nglobal c\nprobe process(\"$LIBLUA_PATH\").function(\"rehashtab\") {\n    c++\n    //print_ubacktrace()\n    printf(\"rehash: %d\\n\", c)\n}\n--- stap_out2\n--- response_body\nhello world\n--- no_error_log\n[error]\n\n\n\n=== TEST 65: DELETE\n--- config\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n        ';\n    }\n    location = /sub {\n        echo hello;\n        echo world;\n    }\n--- request\nGET /t\n--- response_body\nhello\nworld\n--- stap\nF(ngx_http_lua_capture_header_filter) {\n    println(\"capture header filter\")\n}\n\nF(ngx_http_lua_capture_body_filter) {\n    println(\"capture body filter\")\n}\n\n--- stap_out\ncapture header filter\ncapture body filter\ncapture body filter\ncapture body filter\ncapture header filter\ncapture body filter\ncapture body filter\n--- no_error_log\n[error]\n\n\n\n=== TEST 66: leafo test case 1 for assertion failures\n--- config\n    location = /t {\n        echo hello;\n    }\n\n    location /proxy {\n        internal;\n        rewrite_by_lua \"\n          local req = ngx.req\n          print(ngx.var._url)\n\n          for k,v in pairs(req.get_headers()) do\n            if k ~= 'content-length' then\n              req.clear_header(k)\n            end\n          end\n\n          if ngx.ctx.headers then\n            for k,v in pairs(ngx.ctx.headers) do\n              req.set_header(k, v)\n            end\n          end\n        \";\n\n        proxy_http_version 1.1;\n        proxy_pass $_url;\n    }\n\n    location /first {\n      set $_url \"\";\n      content_by_lua '\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"Content-type\"] = \"application/x-www-form-urlencoded\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"x-some-date\"] = \"Sun, 01 Dec 2013 11:47:41 GMT\",\n              [\"x-hello-world-header\"] = \"123412341234\",\n              [\"Authorization\"] = \"Hello\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n      ';\n    }\n--- request\nGET /first\n--- response_body\nhello\nhello\n--- no_error_log eval\n[\n\"[error]\",\nqr/Assertion .*? failed/\n]\n\n\n\n=== TEST 67: leafo test case 2 for assertion failures\n--- config\n    location = /t {\n        echo hello;\n    }\n\n    location /proxy {\n        internal;\n        rewrite_by_lua \"\n          local req = ngx.req\n          print(ngx.var._url)\n\n          for k,v in pairs(req.get_headers()) do\n            if k ~= 'content-length' then\n              req.clear_header(k)\n            end\n          end\n\n          if ngx.ctx.headers then\n            for k,v in pairs(ngx.ctx.headers) do\n              req.set_header(k, v)\n            end\n          end\n        \";\n\n        proxy_http_version 1.1;\n        proxy_pass $_url;\n    }\n\n    location /second {\n      set $_url \"\";\n      content_by_lua '\n        local res = ngx.location.capture(\"/proxy\", {\n          method = ngx.HTTP_POST,\n          body = (\"x\"):rep(600),\n          ctx = {\n            headers = {\n              [\"Content-type\"] = \"application/x-www-form-urlencoded\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          ctx = {\n            headers = {\n              [\"x-some-date\"] = \"Sun, 01 Dec 2013 11:47:41 GMT\",\n              [\"x-hello-world-header\"] = \"123412341234\",\n              [\"Authorization\"] = \"Hello\"\n            }\n          },\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n\n        local res = ngx.location.capture(\"/proxy\", {\n          vars = { _url = \"http://127.0.0.1:\" .. ngx.var.server_port .. \"/t\" }\n        })\n\n        ngx.print(res.body)\n      ';\n    }\n--- request\nGET /second\n--- response_body\nhello\nhello\nhello\n--- no_error_log eval\n[\n\"[error]\",\nqr/Assertion .*? failed/\n]\n\n\n\n=== TEST 68: fetch subrequest's builtin request headers\n--- config\n    location = /sub {\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\n    GET /t\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: foo\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 69: modify subrequest's builtin request headers\n--- config\n    location = /sub {\n        rewrite_by_lua '\n            ngx.req.set_header(\"User-Agent\", \"bar\")\n        ';\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\n    GET /t\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: bar\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 70: modify subrequest's builtin request headers (main req is POST)\n--- config\n    location = /sub {\n        rewrite_by_lua '\n            ngx.req.set_header(\"User-Agent\", \"bar\")\n        ';\n        echo \"sr: User-Agent: $http_user_agent\";\n        echo \"sr: Host: $http_host\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: User-Agent: \", ngx.var.http_user_agent)\n            ngx.say(\"pr: Host: \", ngx.var.http_host)\n        ';\n    }\n--- request\nPOST /t\nhello world\n--- more_headers\nUser-Agent: foo\n--- response_body\nsr: User-Agent: bar\nsr: Host: localhost\npr: User-Agent: foo\npr: Host: localhost\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 71: duplicate request headers (main req is POST)\n--- config\n    location = /sub {\n        echo \"sr: Cookie: $http_cookie\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: Cookie: \", ngx.var.http_cookie)\n        ';\n    }\n--- request\nPOST /t\nhello world\n--- more_headers\nCookie: foo\nCookie: bar\n--- response_body\nsr: Cookie: foo; bar\npr: Cookie: foo; bar\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 72: duplicate request headers (main req is GET)\n--- config\n    location = /sub {\n        echo \"sr: Cookie: $http_cookie\";\n    }\n\n    location = /t {\n        content_by_lua '\n            local res = ngx.location.capture(\"/sub\")\n            ngx.print(res.body)\n            ngx.say(\"pr: Cookie: \", ngx.var.http_cookie)\n        ';\n    }\n--- request\nGET /t\n--- more_headers\nCookie: foo\nCookie: bar\n--- response_body\nsr: Cookie: foo; bar\npr: Cookie: foo; bar\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 73: HEAD subrequest (github #347)\n--- config\n    location /lua {\n        content_by_lua '\n            local res = ngx.location.capture(\"/index.html\",\n                { method = ngx.HTTP_HEAD });\n            ngx.say(\"content-length: \", res.header[\"Content-Length\"])\n            ngx.say(\"body: [\", res.body, \"]\")\n        ';\n    }\n--- request\nGET /lua\n--- response_body_like chop\n^content-length: \\d+\nbody: \\[\\]\n$\n--- no_error_log\n[error]\n\n\n\n=== TEST 74: image_filter + ngx.location.capture\nngx_http_image_filter_module's header filter intercepts\nthe header filter chain so the r->header_sent flag won't\nget set right after the header filter chain is first invoked.\n\n--- config\n\nlocation = /back {\n    empty_gif;\n}\n\nlocation = /t {\n    image_filter rotate 90;\n\n    content_by_lua '\n        local res = ngx.location.capture(\"/back\")\n        for k, v in pairs(res.header) do\n            ngx.header[k] = v\n        end\n        ngx.status = res.status\n        ngx.print(res.body)\n    ';\n}\n\n--- request\nGET /t\n--- response_body_like: .\n--- stap\nF(ngx_http_image_header_filter) {\n    println(\"image header filter\")\n}\n--- stap_out\nimage header filter\n\n--- no_error_log\n[error]\n\n\n\n=== TEST 75: WebDAV + MOVE\n--- config\n    location = /t {\n        content_by_lua_block {\n            local file1 = \"/file1.txt\"\n            local file2 = \"/file2.txt\"\n            ngx.req.set_header( \"Destination\", file2 )\n            local res = ngx.location.capture(\n                file1, { method = ngx.HTTP_MOVE }\n            )\n\n            ngx.say(\n                \"MOVE \", file1, \" -> \", file2,\n                \", response status: \", res.status\n            )\n        }\n    }\n\n    location / {\n        dav_methods MOVE;\n    }\n\n--- user_files\n>>> file1.txt\nhello, world!\n\n--- request\nGET /t\n\n--- response_body\nMOVE /file1.txt -> /file2.txt, response status: 204\n\n--- no_error_log\n[error]\n--- error_code: 200\n\n\n\n=== TEST 76: WebDAV + DELETE\n--- config\n    location = /t {\n        content_by_lua_block {\n            local file = \"/file.txt\"\n            local res = ngx.location.capture(\n                file, { method = ngx.HTTP_DELETE }\n            )\n\n            ngx.say(\n                \"DELETE \", file,\n                \", response status: \", res.status\n            )\n        }\n    }\n\n    location / {\n        dav_methods DELETE;\n    }\n\n--- user_files\n>>> file.txt\nhello, world!\n\n--- request\nGET /t\n\n--- response_body\nDELETE /file.txt, response status: 204\n\n--- no_error_log\n[error]\n--- error_code: 200\n\n\n\n=== TEST 77: avoid request smuggling 1/4 (default capture + smuggle in header)\n--- http_config\n    upstream backend {\n        server unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n        keepalive 32;\n    }\n\n    server {\n        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n\n        location / {\n            content_by_lua_block {\n                ngx.say(\"method: \", ngx.var.request_method,\n                        \", uri: \", ngx.var.uri,\n                        \", X: \", ngx.var.http_x)\n            }\n        }\n    }\n--- config\n    location /proxy {\n        proxy_http_version 1.1;\n        proxy_set_header   Connection \"\";\n        proxy_pass         http://backend/foo;\n    }\n\n    location /capture {\n        server_tokens off;\n        more_clear_headers Date;\n\n        content_by_lua_block {\n            local res = ngx.location.capture(\"/proxy\")\n            ngx.print(res.body)\n        }\n    }\n\n    location /t {\n        content_by_lua_block {\n            local req = [[\nGET /capture HTTP/1.1\nHost: test.com\nContent-Length: 37\nTransfer-Encoding: chunked\n\n0\n\nGET /capture HTTP/1.1\nHost: test.com\nX: GET /bar HTTP/1.0\n\n]]\n\n            local sock = ngx.socket.tcp()\n            sock:settimeout(1000)\n\n            local ok, err = sock:connect(\"127.0.0.1\", $TEST_NGINX_SERVER_PORT)\n            if not ok then\n                ngx.say(\"failed to connect: \", err)\n                return\n            end\n\n            local bytes, err = sock:send(req)\n            if not bytes then\n                ngx.say(\"failed to send req: \", err)\n                return\n            end\n\n            ngx.say(\"req bytes: \", bytes)\n\n            local n_resp = 0\n\n            local reader = sock:receiveuntil(\"\\r\\n\")\n            while true do\n                local line, err = reader()\n                if line then\n                    ngx.say(line)\n                    if line == \"0\" then\n                        n_resp = n_resp + 1\n                    end\n\n                    if n_resp >= 2 then\n                        break\n                    end\n\n                else\n                    ngx.say(\"err: \", err)\n                    break\n                end\n            end\n\n            sock:close()\n        }\n    }\n--- request\nGET /t\n--- response_body\nreq bytes: 146\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n1f\nmethod: GET, uri: /foo, X: nil\n\n0\n\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n2d\nmethod: GET, uri: /foo, X: GET /bar HTTP/1.0\n\n0\n--- no_error_log\n[error]\n\n\n\n=== TEST 78: avoid request smuggling 2/4 (POST capture + smuggle in body)\n--- http_config\n    upstream backend {\n        server unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n        keepalive 32;\n    }\n\n    server {\n        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n\n        location / {\n            content_by_lua_block {\n                ngx.say(\"method: \", ngx.var.request_method,\n                        \", uri: \", ngx.var.uri)\n            }\n        }\n    }\n--- config\n    location /proxy {\n        proxy_http_version 1.1;\n        proxy_set_header   Connection \"\";\n        proxy_pass         http://backend/foo;\n    }\n\n    location /capture {\n        server_tokens off;\n        more_clear_headers Date;\n\n        content_by_lua_block {\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/proxy\", { method = ngx.HTTP_POST })\n            ngx.print(res.body)\n        }\n    }\n\n    location /t {\n        content_by_lua_block {\n            local req = [[\nGET /capture HTTP/1.1\nHost: test.com\nContent-Length: 57\nTransfer-Encoding: chunked\n\n0\n\nPOST /capture HTTP/1.1\nHost: test.com\nContent-Length: 60\n\nPOST /bar HTTP/1.1\nHost: test.com\nContent-Length: 5\n\nhello\n\n]]\n\n            local sock = ngx.socket.tcp()\n            sock:settimeout(1000)\n\n            local ok, err = sock:connect(\"127.0.0.1\", $TEST_NGINX_SERVER_PORT)\n            if not ok then\n                ngx.say(\"failed to connect: \", err)\n                return\n            end\n\n            local bytes, err = sock:send(req)\n            if not bytes then\n                ngx.say(\"failed to send req: \", err)\n                return\n            end\n\n            ngx.say(\"req bytes: \", bytes)\n\n            local n_resp = 0\n\n            local reader = sock:receiveuntil(\"\\r\\n\")\n            while true do\n                local line, err = reader()\n                if line then\n                    ngx.say(line)\n                    if line == \"0\" then\n                        n_resp = n_resp + 1\n                    end\n\n                    if n_resp >= 2 then\n                        break\n                    end\n\n                else\n                    ngx.say(\"err: \", err)\n                    break\n                end\n            end\n\n            sock:close()\n        }\n    }\n--- request\nGET /t\n--- response_body\nreq bytes: 205\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n--- no_error_log\n[error]\n\n\n\n=== TEST 79: avoid request smuggling 3/4 (POST capture w/ always_forward_body + smuggle in body)\n--- http_config\n    upstream backend {\n        server unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n        keepalive 32;\n    }\n\n    server {\n        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n\n        location / {\n            content_by_lua_block {\n                ngx.say(\"method: \", ngx.var.request_method,\n                        \", uri: \", ngx.var.uri)\n            }\n        }\n    }\n--- config\n    location /proxy {\n        proxy_http_version 1.1;\n        proxy_set_header   Connection \"\";\n        proxy_pass         http://backend/foo;\n    }\n\n    location /capture {\n        server_tokens off;\n        more_clear_headers Date;\n\n        content_by_lua_block {\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/proxy\", {\n                method = ngx.HTTP_POST,\n                always_forward_body = true\n            })\n            ngx.print(res.body)\n        }\n    }\n\n    location /t {\n        content_by_lua_block {\n            local req = [[\nGET /capture HTTP/1.1\nHost: test.com\nContent-Length: 57\nTransfer-Encoding: chunked\n\n0\n\nPOST /capture HTTP/1.1\nHost: test.com\nContent-Length: 60\n\nPOST /bar HTTP/1.1\nHost: test.com\nContent-Length: 5\n\nhello\n\n]]\n\n            local sock = ngx.socket.tcp()\n            sock:settimeout(1000)\n\n            local ok, err = sock:connect(\"127.0.0.1\", $TEST_NGINX_SERVER_PORT)\n            if not ok then\n                ngx.say(\"failed to connect: \", err)\n                return\n            end\n\n            local bytes, err = sock:send(req)\n            if not bytes then\n                ngx.say(\"failed to send req: \", err)\n                return\n            end\n\n            ngx.say(\"req bytes: \", bytes)\n\n            local n_resp = 0\n\n            local reader = sock:receiveuntil(\"\\r\\n\")\n            while true do\n                local line, err = reader()\n                if line then\n                    ngx.say(line)\n                    if line == \"0\" then\n                        n_resp = n_resp + 1\n                    end\n\n                    if n_resp >= 2 then\n                        break\n                    end\n\n                else\n                    ngx.say(\"err: \", err)\n                    break\n                end\n            end\n\n            sock:close()\n        }\n    }\n--- request\nGET /t\n--- response_body\nreq bytes: 205\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n--- no_error_log\n[error]\n\n\n\n=== TEST 80: avoid request smuggling 4/4 (POST capture w/ body + smuggle in body)\n--- http_config\n    upstream backend {\n        server unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n        keepalive 32;\n    }\n\n    server {\n        listen unix:$TEST_NGINX_HTML_DIR/nginx.sock;\n\n        location / {\n            content_by_lua_block {\n                ngx.say(\"method: \", ngx.var.request_method,\n                        \", uri: \", ngx.var.uri)\n            }\n        }\n    }\n--- config\n    location /proxy {\n        proxy_http_version 1.1;\n        proxy_set_header   Connection \"\";\n        proxy_pass         http://backend/foo;\n    }\n\n    location /capture {\n        server_tokens off;\n        more_clear_headers Date;\n\n        content_by_lua_block {\n            ngx.req.read_body()\n            local res = ngx.location.capture(\"/proxy\", {\n                method = ngx.HTTP_POST,\n                always_forward_body = true,\n                body = ngx.req.get_body_data()\n            })\n            ngx.print(res.body)\n        }\n    }\n\n    location /t {\n        content_by_lua_block {\n            local req = [[\nGET /capture HTTP/1.1\nHost: test.com\nContent-Length: 57\nTransfer-Encoding: chunked\n\n0\n\nPOST /capture HTTP/1.1\nHost: test.com\nContent-Length: 60\n\nPOST /bar HTTP/1.1\nHost: test.com\nContent-Length: 5\n\nhello\n\n]]\n\n            local sock = ngx.socket.tcp()\n            sock:settimeout(1000)\n\n            local ok, err = sock:connect(\"127.0.0.1\", $TEST_NGINX_SERVER_PORT)\n            if not ok then\n                ngx.say(\"failed to connect: \", err)\n                return\n            end\n\n            local bytes, err = sock:send(req)\n            if not bytes then\n                ngx.say(\"failed to send req: \", err)\n                return\n            end\n\n            ngx.say(\"req bytes: \", bytes)\n\n            local n_resp = 0\n\n            local reader = sock:receiveuntil(\"\\r\\n\")\n            while true do\n                local line, err = reader()\n                if line then\n                    ngx.say(line)\n                    if line == \"0\" then\n                        n_resp = n_resp + 1\n                    end\n\n                    if n_resp >= 2 then\n                        break\n                    end\n\n                else\n                    ngx.say(\"err: \", err)\n                    break\n                end\n            end\n\n            sock:close()\n        }\n    }\n--- request\nGET /t\n--- response_body\nreq bytes: 205\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n\nHTTP/1.1 200 OK\nServer: nginx\nContent-Type: text/plain\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n18\nmethod: POST, uri: /foo\n\n0\n--- no_error_log\n[error]\n"], "filenames": ["src/ngx_http_lua_subrequest.c", "t/020-subrequest.t"], "buggy_code_start_loc": [60, 16], "buggy_code_end_loc": [1791, 2879], "fixing_code_start_loc": [59, 17], "fixing_code_end_loc": [1732, 3394], "type": "CWE-444", "message": "An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API.", "other": {"cve": {"id": "CVE-2020-11724", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-12T21:15:10.317", "lastModified": "2021-01-29T16:33:01.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API."}, {"lang": "es", "value": "Se detect\u00f3 un problema en OpenResty versiones anteriores a 1.15.8.4. El archivo ngx_http_lua_subrequest.c permite un tr\u00e1fico no autorizado de peticiones HTTP, como es demostrado por la API ngx.location.capture."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openresty:openresty:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.15.8.4", "matchCriteriaId": "54204884-C4D1-4564-9CCE-18D2107A7ACD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openresty/openresty/blob/4e8b4c395f842a078e429c80dd063b2323999957/patches/ngx_http_lua-0.10.15-fix_location_capture_content_length_chunked.patch", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210129-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4750", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa"}}