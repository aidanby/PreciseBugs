{"buggy_code": ["/* radare - LGPL - Copyright 2010-2016 - pancake, nibble */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_list.h>\n#include <limits.h>\n\n#define DFLT_NINSTR 3\n\nR_API RAnalBlock *r_anal_bb_new() {\n\tRAnalBlock *bb = R_NEW0 (RAnalBlock);\n\tif (!bb) {\n\t\treturn NULL;\n\t}\n\tbb->addr = UT64_MAX;\n\tbb->jump = UT64_MAX;\n\tbb->fail = UT64_MAX;\n\tbb->switch_op = NULL;\n\tbb->type = R_ANAL_BB_TYPE_NULL;\n\tbb->cond = NULL;\n\tbb->fingerprint = NULL;\n\tbb->diff = NULL; //r_anal_diff_new ();\n\tbb->label = NULL;\n\tbb->op_pos = R_NEWS0 (ut16, DFLT_NINSTR);\n\tbb->op_pos_size = DFLT_NINSTR;\n\tbb->parent_reg_arena = NULL;\n\tbb->stackptr = 0;\n\tbb->parent_stackptr = INT_MAX;\n\treturn bb;\n}\n\nR_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}\n\nR_API RList *r_anal_bb_list_new() {\n\tRList *list = r_list_newf ((RListFree)r_anal_bb_free);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\treturn list;\n}\n\nR_API int r_anal_bb(RAnal *anal, RAnalBlock *bb, ut64 addr, ut8 *buf, ut64 len, int head) {\n\tRAnalOp *op = NULL;\n\tint oplen, idx = 0;\n\n\tif (bb->addr == -1) {\n\t\tbb->addr = addr;\n\t}\n\tlen -= 16; // XXX: hack to avoid segfault by x86im\n\twhile (idx < len) {\n\t\t// TODO: too slow object construction\n\t\tif (!(op = r_anal_op_new ())) {\n\t\t\teprintf (\"Error: new (op)\\n\");\n\t\t\treturn R_ANAL_RET_ERROR;\n\t\t}\n\t\tif ((oplen = r_anal_op (anal, op, addr + idx, buf + idx, len - idx, R_ANAL_OP_MASK_VAL)) == 0) {\n\t\t\tr_anal_op_free (op);\n\t\t\top = NULL;\n\t\t\tif (idx == 0) {\n\t\t\t\tVERBOSE_ANAL eprintf (\"Unknown opcode at 0x%08\"PFMT64x\"\\n\", addr+idx);\n\t\t\t\treturn R_ANAL_RET_END;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (oplen < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_anal_bb_set_offset (bb, bb->ninstr++, addr + idx - bb->addr);\n\t\tidx += oplen;\n\t\tbb->size += oplen;\n\t\tif (head) {\n\t\t\tbb->type = R_ANAL_BB_TYPE_HEAD;\n\t\t}\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tr_anal_cond_free (bb->cond);\n\t\t\tbb->cond = r_anal_cond_new_from_op (op);\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tif (bb->cond) {\n\t\t\t\t// TODO: get values from anal backend\n\t\t\t\tbb->cond->type = R_ANAL_COND_EQ;\n\t\t\t} else VERBOSE_ANAL eprintf (\"Unknown conditional for block 0x%\"PFMT64x\"\\n\", bb->addr);\n\t\t\tbb->conditional = 1;\n\t\t\tbb->fail = op->fail;\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->type |= R_ANAL_BB_TYPE_BODY;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->type |= R_ANAL_BB_TYPE_BODY;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\tbb->type |= R_ANAL_BB_TYPE_FOOT;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tbb->type |= R_ANAL_BB_TYPE_LAST;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t{\n\t\t\tRAnalValue *src = op->src[0];\n\t\t\tif (src && src->reg && anal->reg) {\n\t\t\t\tconst char *pc = anal->reg->name[R_REG_NAME_PC];\n\t\t\t\tRAnalValue *dst = op->dst;\n\t\t\t\tif (dst && dst->reg && !strcmp (src->reg->name, pc)) {\n\t\t\t\t\tint memref = anal->bits/8;\n\t\t\t\t\tut8 b[8];\n\t\t\t\t\tut64 ptr = idx+addr+src->delta;\n\t\t\t\t\tanal->iob.read_at (anal->iob.io, ptr, b, memref);\n\t\t\t\t\tr_anal_xrefs_set (anal, addr+idx-op->size, ptr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\n\treturn bb->size;\nbeach:\n\tr_anal_op_free (op);\n\treturn R_ANAL_RET_END;\n}\n\nR_API inline int r_anal_bb_is_in_offset (RAnalBlock *bb, ut64 off) {\n\treturn (off >= bb->addr && off < bb->addr + bb->size);\n}\n\nR_API RAnalBlock *r_anal_bb_from_offset(RAnal *anal, ut64 off) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *bb;\n\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\tr_list_foreach (fcn->bbs, iter2, bb) {\n\t\t\tif (r_anal_bb_is_in_offset (bb, off)) {\n\t\t\t\treturn bb;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_bb_get_jumpbb(RAnalFunction *fcn, RAnalBlock *bb) {\n\tif (bb->jump == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\treturn bb->jumpbb;\n\t}\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (b->addr == bb->jump) {\n\t\t\tbb->jumpbb = b;\n\t\t\tb->prev = bb;\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_bb_get_failbb(RAnalFunction *fcn, RAnalBlock *bb) {\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tif (bb->fail == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tif (bb->failbb) {\n\t\treturn bb->failbb;\n\t}\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (b->addr == bb->fail) {\n\t\t\tbb->failbb = b;\n\t\t\tb->prev = bb;\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* return the offset of the i-th instruction in the basicblock bb.\n * If the index of the instruction is not valid, it returns UT16_MAX */\nR_API ut16 r_anal_bb_offset_inst(RAnalBlock *bb, int i) {\n\tif (i < 0 || i >= bb->ninstr) {\n\t\treturn UT16_MAX;\n\t}\n\treturn (i > 0 && (i - 1) < bb->op_pos_size) ? bb->op_pos[i - 1] : 0;\n}\n\n/* set the offset of the i-th instruction in the basicblock bb */\nR_API bool r_anal_bb_set_offset(RAnalBlock *bb, int i, ut16 v) {\n\t// the offset 0 of the instruction 0 is not stored because always 0\n\tif (i > 0 && v > 0) {\n\t\tif (i >= bb->op_pos_size) {\n\t\t\tint new_pos_size = i * 2;\n\t\t\tut16 *tmp_op_pos = realloc (bb->op_pos, new_pos_size * sizeof (*bb->op_pos));\n\t\t\tif (!tmp_op_pos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbb->op_pos_size = new_pos_size;\n\t\t\tbb->op_pos = tmp_op_pos;\n\t\t}\n\t\tbb->op_pos[i - 1] = v;\n\t\treturn true;\n\t}\n\treturn true;\n}\n\n/* return the address of the instruction that occupy a given offset.\n * If the offset is not part of the given basicblock, UT64_MAX is returned. */\nR_API ut64 r_anal_bb_opaddr_at(RAnalBlock *bb, ut64 off) {\n\tut16 delta, delta_off, last_delta;\n\tint i;\n\n\tif (!r_anal_bb_is_in_offset (bb, off)) {\n\t\treturn UT64_MAX;\n\t}\n\tlast_delta = 0;\n\tdelta_off = off - bb->addr;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tdelta = r_anal_bb_offset_inst (bb, i);\n\t\tif (delta > delta_off) {\n\t\t\treturn bb->addr + last_delta;\n\t\t}\n\t\tlast_delta = delta;\n\t}\n\treturn UT64_MAX;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2016 - pancake, nibble */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_list.h>\n#include <limits.h>\n\n#define DFLT_NINSTR 3\n\nR_API RAnalBlock *r_anal_bb_new() {\n\tRAnalBlock *bb = R_NEW0 (RAnalBlock);\n\tif (!bb) {\n\t\treturn NULL;\n\t}\n\tbb->addr = UT64_MAX;\n\tbb->jump = UT64_MAX;\n\tbb->fail = UT64_MAX;\n\tbb->switch_op = NULL;\n\tbb->type = R_ANAL_BB_TYPE_NULL;\n\tbb->cond = NULL;\n\tbb->fingerprint = NULL;\n\tbb->diff = NULL; //r_anal_diff_new ();\n\tbb->label = NULL;\n\tbb->op_pos = R_NEWS0 (ut16, DFLT_NINSTR);\n\tbb->op_pos_size = DFLT_NINSTR;\n\tbb->parent_reg_arena = NULL;\n\tbb->stackptr = 0;\n\tbb->parent_stackptr = INT_MAX;\n\treturn bb;\n}\n\nR_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tif (bb->next) {\n\t\t// avoid double free\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); // double free\n}\n\nR_API RList *r_anal_bb_list_new() {\n\tRList *list = r_list_newf ((RListFree)r_anal_bb_free);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\treturn list;\n}\n\nR_API int r_anal_bb(RAnal *anal, RAnalBlock *bb, ut64 addr, ut8 *buf, ut64 len, int head) {\n\tRAnalOp *op = NULL;\n\tint oplen, idx = 0;\n\n\tif (bb->addr == -1) {\n\t\tbb->addr = addr;\n\t}\n\tlen -= 16; // XXX: hack to avoid segfault by x86im\n\twhile (idx < len) {\n\t\t// TODO: too slow object construction\n\t\tif (!(op = r_anal_op_new ())) {\n\t\t\teprintf (\"Error: new (op)\\n\");\n\t\t\treturn R_ANAL_RET_ERROR;\n\t\t}\n\t\tif ((oplen = r_anal_op (anal, op, addr + idx, buf + idx, len - idx, R_ANAL_OP_MASK_VAL)) == 0) {\n\t\t\tr_anal_op_free (op);\n\t\t\top = NULL;\n\t\t\tif (idx == 0) {\n\t\t\t\tVERBOSE_ANAL eprintf (\"Unknown opcode at 0x%08\"PFMT64x\"\\n\", addr+idx);\n\t\t\t\treturn R_ANAL_RET_END;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (oplen < 1) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_anal_bb_set_offset (bb, bb->ninstr++, addr + idx - bb->addr);\n\t\tidx += oplen;\n\t\tbb->size += oplen;\n\t\tif (head) {\n\t\t\tbb->type = R_ANAL_BB_TYPE_HEAD;\n\t\t}\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tr_anal_cond_free (bb->cond);\n\t\t\tbb->cond = r_anal_cond_new_from_op (op);\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tif (bb->cond) {\n\t\t\t\t// TODO: get values from anal backend\n\t\t\t\tbb->cond->type = R_ANAL_COND_EQ;\n\t\t\t} else VERBOSE_ANAL eprintf (\"Unknown conditional for block 0x%\"PFMT64x\"\\n\", bb->addr);\n\t\t\tbb->conditional = 1;\n\t\t\tbb->fail = op->fail;\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->type |= R_ANAL_BB_TYPE_BODY;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->type |= R_ANAL_BB_TYPE_BODY;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\tbb->type |= R_ANAL_BB_TYPE_FOOT;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tbb->type |= R_ANAL_BB_TYPE_LAST;\n\t\t\tgoto beach;\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t{\n\t\t\tRAnalValue *src = op->src[0];\n\t\t\tif (src && src->reg && anal->reg) {\n\t\t\t\tconst char *pc = anal->reg->name[R_REG_NAME_PC];\n\t\t\t\tRAnalValue *dst = op->dst;\n\t\t\t\tif (dst && dst->reg && !strcmp (src->reg->name, pc)) {\n\t\t\t\t\tint memref = anal->bits/8;\n\t\t\t\t\tut8 b[8];\n\t\t\t\t\tut64 ptr = idx+addr+src->delta;\n\t\t\t\t\tanal->iob.read_at (anal->iob.io, ptr, b, memref);\n\t\t\t\t\tr_anal_xrefs_set (anal, addr+idx-op->size, ptr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\n\treturn bb->size;\nbeach:\n\tr_anal_op_free (op);\n\treturn R_ANAL_RET_END;\n}\n\nR_API inline int r_anal_bb_is_in_offset (RAnalBlock *bb, ut64 off) {\n\treturn (off >= bb->addr && off < bb->addr + bb->size);\n}\n\nR_API RAnalBlock *r_anal_bb_from_offset(RAnal *anal, ut64 off) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *bb;\n\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\tr_list_foreach (fcn->bbs, iter2, bb) {\n\t\t\tif (r_anal_bb_is_in_offset (bb, off)) {\n\t\t\t\treturn bb;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_bb_get_jumpbb(RAnalFunction *fcn, RAnalBlock *bb) {\n\tif (bb->jump == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\treturn bb->jumpbb;\n\t}\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (b->addr == bb->jump) {\n\t\t\tbb->jumpbb = b;\n\t\t\tb->prev = bb;\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_bb_get_failbb(RAnalFunction *fcn, RAnalBlock *bb) {\n\tRListIter *iter;\n\tRAnalBlock *b;\n\tif (bb->fail == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tif (bb->failbb) {\n\t\treturn bb->failbb;\n\t}\n\tr_list_foreach (fcn->bbs, iter, b) {\n\t\tif (b->addr == bb->fail) {\n\t\t\tbb->failbb = b;\n\t\t\tb->prev = bb;\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* return the offset of the i-th instruction in the basicblock bb.\n * If the index of the instruction is not valid, it returns UT16_MAX */\nR_API ut16 r_anal_bb_offset_inst(RAnalBlock *bb, int i) {\n\tif (i < 0 || i >= bb->ninstr) {\n\t\treturn UT16_MAX;\n\t}\n\treturn (i > 0 && (i - 1) < bb->op_pos_size) ? bb->op_pos[i - 1] : 0;\n}\n\n/* set the offset of the i-th instruction in the basicblock bb */\nR_API bool r_anal_bb_set_offset(RAnalBlock *bb, int i, ut16 v) {\n\t// the offset 0 of the instruction 0 is not stored because always 0\n\tif (i > 0 && v > 0) {\n\t\tif (i >= bb->op_pos_size) {\n\t\t\tint new_pos_size = i * 2;\n\t\t\tut16 *tmp_op_pos = realloc (bb->op_pos, new_pos_size * sizeof (*bb->op_pos));\n\t\t\tif (!tmp_op_pos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbb->op_pos_size = new_pos_size;\n\t\t\tbb->op_pos = tmp_op_pos;\n\t\t}\n\t\tbb->op_pos[i - 1] = v;\n\t\treturn true;\n\t}\n\treturn true;\n}\n\n/* return the address of the instruction that occupy a given offset.\n * If the offset is not part of the given basicblock, UT64_MAX is returned. */\nR_API ut64 r_anal_bb_opaddr_at(RAnalBlock *bb, ut64 off) {\n\tut16 delta, delta_off, last_delta;\n\tint i;\n\n\tif (!r_anal_bb_is_in_offset (bb, off)) {\n\t\treturn UT64_MAX;\n\t}\n\tlast_delta = 0;\n\tdelta_off = off - bb->addr;\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tdelta = r_anal_bb_offset_inst (bb, i);\n\t\tif (delta > delta_off) {\n\t\t\treturn bb->addr + last_delta;\n\t\t}\n\t\tlast_delta = delta;\n\t}\n\treturn UT64_MAX;\n}\n"], "filenames": ["libr/anal/bb.c"], "buggy_code_start_loc": [65], "buggy_code_end_loc": [66], "fixing_code_start_loc": [65], "fixing_code_end_loc": [70], "type": "CWE-416", "message": "There is a use after free in radare2 2.6.0 in r_anal_bb_free() in libr/anal/bb.c via a crafted Java binary file.", "other": {"cve": {"id": "CVE-2018-12320", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-13T16:29:01.530", "lastModified": "2018-08-02T12:55:12.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a use after free in radare2 2.6.0 in r_anal_bb_free() in libr/anal/bb.c via a crafted Java binary file."}, {"lang": "es", "value": "Hay un uso de memoria previamente liberada en radare2 2.6.0 en r_anal_bb_free() en libr/anal/bb.c mediante un archivo binario de Java manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "ECF03BDC-4698-4552-A58C-67FD78902BED"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/90b71c017a7fa9732fe45fd21b245ee051b1f548", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/10293", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/90b71c017a7fa9732fe45fd21b245ee051b1f548"}}