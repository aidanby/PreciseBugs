{"buggy_code": ["/**\n * Add a data array to the table, creating DOM node etc. This is the parallel to\n * _fnGatherData, but for adding rows from a Javascript source, rather than a\n * DOM source.\n *  @param {object} oSettings dataTables settings object\n *  @param {array} aData data array to be added\n *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n *  @memberof DataTable#oApi\n */\nfunction _fnAddData ( oSettings, aDataIn, nTr, anTds )\n{\n\t/* Create the object for storing information about this new row */\n\tvar iRow = oSettings.aoData.length;\n\tvar oData = $.extend( true, {}, DataTable.models.oRow, {\n\t\tsrc: nTr ? 'dom' : 'data',\n\t\tidx: iRow\n\t} );\n\n\toData._aData = aDataIn;\n\toSettings.aoData.push( oData );\n\n\t/* Create the cells */\n\tvar nTd, sThisType;\n\tvar columns = oSettings.aoColumns;\n\n\t// Invalidate the column types as the new data needs to be revalidated\n\tfor ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n\t{\n\t\tcolumns[i].sType = null;\n\t}\n\n\t/* Add to the display array */\n\toSettings.aiDisplayMaster.push( iRow );\n\n\tvar id = oSettings.rowIdFn( aDataIn );\n\tif ( id !== undefined ) {\n\t\toSettings.aIds[ id ] = oData;\n\t}\n\n\t/* Create the DOM information, or register it if already present */\n\tif ( nTr || ! oSettings.oFeatures.bDeferRender )\n\t{\n\t\t_fnCreateTr( oSettings, iRow, nTr, anTds );\n\t}\n\n\treturn iRow;\n}\n\n\n/**\n * Add one or more TR elements to the table. Generally we'd expect to\n * use this for reading data from a DOM sourced table, but it could be\n * used for an TR element. Note that if a TR is given, it is used (i.e.\n * it is not cloned).\n *  @param {object} settings dataTables settings object\n *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n *  @returns {array} Array of indexes for the added rows\n *  @memberof DataTable#oApi\n */\nfunction _fnAddTr( settings, trs )\n{\n\tvar row;\n\n\t// Allow an individual node to be passed in\n\tif ( ! (trs instanceof $) ) {\n\t\ttrs = $(trs);\n\t}\n\n\treturn trs.map( function (i, el) {\n\t\trow = _fnGetRowElements( settings, el );\n\t\treturn _fnAddData( settings, row.data, el, row.cells );\n\t} );\n}\n\n\n/**\n * Take a TR element and convert it to an index in aoData\n *  @param {object} oSettings dataTables settings object\n *  @param {node} n the TR element to find\n *  @returns {int} index if the node is found, null if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToDataIndex( oSettings, n )\n{\n\treturn (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;\n}\n\n\n/**\n * Take a TD element and convert it into a column data index (not the visible index)\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iRow The row number the TD/TH can be found in\n *  @param {node} n The TD/TH element to find\n *  @returns {int} index if the node is found, -1 if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToColumnIndex( oSettings, iRow, n )\n{\n\treturn $.inArray( n, oSettings.aoData[ iRow ].anCells );\n}\n\n\n/**\n * Get the data for a given cell from the internal cache, taking into account data mapping\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n *  @returns {*} Cell data\n *  @memberof DataTable#oApi\n */\nfunction _fnGetCellData( settings, rowIdx, colIdx, type )\n{\n\tvar draw           = settings.iDraw;\n\tvar col            = settings.aoColumns[colIdx];\n\tvar rowData        = settings.aoData[rowIdx]._aData;\n\tvar defaultContent = col.sDefaultContent;\n\tvar cellData       = col.fnGetData( rowData, type, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t} );\n\n\tif ( cellData === undefined ) {\n\t\tif ( settings.iDrawError != draw && defaultContent === null ) {\n\t\t\t_fnLog( settings, 0, \"Requested unknown parameter \"+\n\t\t\t\t(typeof col.mData=='function' ? '{function}' : \"'\"+col.mData+\"'\")+\n\t\t\t\t\" for row \"+rowIdx+\", column \"+colIdx, 4 );\n\t\t\tsettings.iDrawError = draw;\n\t\t}\n\t\treturn defaultContent;\n\t}\n\n\t// When the data source is null and a specific data type is requested (i.e.\n\t// not the original data), we can use default column data\n\tif ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {\n\t\tcellData = defaultContent;\n\t}\n\telse if ( typeof cellData === 'function' ) {\n\t\t// If the data source is a function, then we run it and use the return,\n\t\t// executing in the scope of the data object (for instances)\n\t\treturn cellData.call( rowData );\n\t}\n\n\tif ( cellData === null && type == 'display' ) {\n\t\treturn '';\n\t}\n\treturn cellData;\n}\n\n\n/**\n * Set the value for a specific cell, into the internal data cache\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {*} val Value to set\n *  @memberof DataTable#oApi\n */\nfunction _fnSetCellData( settings, rowIdx, colIdx, val )\n{\n\tvar col     = settings.aoColumns[colIdx];\n\tvar rowData = settings.aoData[rowIdx]._aData;\n\n\tcol.fnSetData( rowData, val, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t}  );\n}\n\n\n// Private variable that is used to match action syntax in the data property object\nvar __reArray = /\\[.*?\\]$/;\nvar __reFn = /\\(\\)$/;\n\n/**\n * Split string on periods, taking into account escaped periods\n * @param  {string} str String to split\n * @return {array} Split string\n */\nfunction _fnSplitObjNotation( str )\n{\n\treturn $.map( str.match(/(\\\\.|[^\\.])+/g) || [''], function ( s ) {\n\t\treturn s.replace(/\\\\\\./g, '.');\n\t} );\n}\n\n\n/**\n * Return a function that can be used to get data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data get function\n *  @memberof DataTable#oApi\n */\nfunction _fnGetObjectDataFn( mSource )\n{\n\tif ( $.isPlainObject( mSource ) )\n\t{\n\t\t/* Build an object of get functions, and wrap them in a single call */\n\t\tvar o = {};\n\t\t$.each( mSource, function (key, val) {\n\t\t\tif ( val ) {\n\t\t\t\to[key] = _fnGetObjectDataFn( val );\n\t\t\t}\n\t\t} );\n\n\t\treturn function (data, type, row, meta) {\n\t\t\tvar t = o[type] || o._;\n\t\t\treturn t !== undefined ?\n\t\t\t\tt(data, type, row, meta) :\n\t\t\t\tdata;\n\t\t};\n\t}\n\telse if ( mSource === null )\n\t{\n\t\t/* Give an empty string for rendering / sorting etc */\n\t\treturn function (data) { // type, row and meta also passed, but not used\n\t\t\treturn data;\n\t\t};\n\t}\n\telse if ( typeof mSource === 'function' )\n\t{\n\t\treturn function (data, type, row, meta) {\n\t\t\treturn mSource( data, type, row, meta );\n\t\t};\n\t}\n\telse if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n\t\t      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n\t{\n\t\t/* If there is a . in the source string then the data source is in a\n\t\t * nested object so we loop over the data for each level to get the next\n\t\t * level down. On each loop we test for undefined, and if found immediately\n\t\t * return. This allows entire objects to be missing and sDefaultContent to\n\t\t * be used if defined, rather than throwing an error\n\t\t */\n\t\tvar fetchData = function (data, type, src) {\n\t\t\tvar arrayNotation, funcNotation, out, innerSrc;\n\n\t\t\tif ( src !== \"\" )\n\t\t\t{\n\t\t\t\tvar a = _fnSplitObjNotation( src );\n\n\t\t\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t\t\t\t{\n\t\t\t\t\t// Check if we are dealing with special notation\n\t\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\t\tfuncNotation = a[i].match(__reFn);\n\n\t\t\t\t\tif ( arrayNotation )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Array notation\n\t\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\n\t\t\t\t\t\t// Condition allows simply [] to be passed in\n\t\t\t\t\t\tif ( a[i] !== \"\" ) {\n\t\t\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout = [];\n\n\t\t\t\t\t\t// Get the remainder of the nested object to get\n\t\t\t\t\t\ta.splice( 0, i+1 );\n\t\t\t\t\t\tinnerSrc = a.join('.');\n\n\t\t\t\t\t\t// Traverse each entry in the array getting the properties requested\n\t\t\t\t\t\tif ( Array.isArray( data ) ) {\n\t\t\t\t\t\t\tfor ( var j=0, jLen=data.length ; j<jLen ; j++ ) {\n\t\t\t\t\t\t\t\tout.push( fetchData( data[j], type, innerSrc ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a string is given in between the array notation indicators, that\n\t\t\t\t\t\t// is used to join the strings together, otherwise an array is returned\n\t\t\t\t\t\tvar join = arrayNotation[0].substring(1, arrayNotation[0].length-1);\n\t\t\t\t\t\tdata = (join===\"\") ? out : out.join(join);\n\n\t\t\t\t\t\t// The inner call to fetchData has already traversed through the remainder\n\t\t\t\t\t\t// of the source requested, so we exit from the loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( funcNotation )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Function call\n\t\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\t\tdata = data[ a[i] ]();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data === null || data[ a[i] ] === undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\treturn fetchData( data, type, mSource );\n\t\t};\n\t}\n\telse\n\t{\n\t\t/* Array or flat object mapping */\n\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\treturn data[mSource];\n\t\t};\n\t}\n}\n\n\n/**\n * Return a function that can be used to set data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data set function\n *  @memberof DataTable#oApi\n */\nfunction _fnSetObjectDataFn( mSource )\n{\n\tif ( $.isPlainObject( mSource ) )\n\t{\n\t\t/* Unlike get, only the underscore (global) option is used for for\n\t\t * setting data since we don't know the type here. This is why an object\n\t\t * option is not documented for `mData` (which is read/write), but it is\n\t\t * for `mRender` which is read only.\n\t\t */\n\t\treturn _fnSetObjectDataFn( mSource._ );\n\t}\n\telse if ( mSource === null )\n\t{\n\t\t/* Nothing to do when the data source is null */\n\t\treturn function () {};\n\t}\n\telse if ( typeof mSource === 'function' )\n\t{\n\t\treturn function (data, val, meta) {\n\t\t\tmSource( data, 'set', val, meta );\n\t\t};\n\t}\n\telse if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n\t\t      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n\t{\n\t\t/* Like the get, we need to get data from a nested object */\n\t\tvar setData = function (data, val, src) {\n\t\t\tvar a = _fnSplitObjNotation( src ), b;\n\t\t\tvar aLast = a[a.length-1];\n\t\t\tvar arrayNotation, funcNotation, o, innerSrc;\n\n\t\t\tfor ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\t// Protect against prototype pollution\n\t\t\t\tif (a[i] === '__proto__') {\n\t\t\t\t\tthrow new Error('Cannot set prototype values');\n\t\t\t\t}\n\n\t\t\t\t// Check if we are dealing with an array notation request\n\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\tfuncNotation = a[i].match(__reFn);\n\n\t\t\t\tif ( arrayNotation )\n\t\t\t\t{\n\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\t\t\t\t\tdata[ a[i] ] = [];\n\n\t\t\t\t\t// Get the remainder of the nested object to set so we can recurse\n\t\t\t\t\tb = a.slice();\n\t\t\t\t\tb.splice( 0, i+1 );\n\t\t\t\t\tinnerSrc = b.join('.');\n\n\t\t\t\t\t// Traverse each entry in the array setting the properties requested\n\t\t\t\t\tif ( Array.isArray( val ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( var j=0, jLen=val.length ; j<jLen ; j++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\to = {};\n\t\t\t\t\t\t\tsetData( o, val[j], innerSrc );\n\t\t\t\t\t\t\tdata[ a[i] ].push( o );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// We've been asked to save data to an array, but it\n\t\t\t\t\t\t// isn't array data to be saved. Best that can be done\n\t\t\t\t\t\t// is to just save the value.\n\t\t\t\t\t\tdata[ a[i] ] = val;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The inner call to setData has already traversed through the remainder\n\t\t\t\t\t// of the source and has set the data, thus we can exit here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( funcNotation )\n\t\t\t\t{\n\t\t\t\t\t// Function call\n\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\tdata = data[ a[i] ]( val );\n\t\t\t\t}\n\n\t\t\t\t// If the nested object doesn't currently exist - since we are\n\t\t\t\t// trying to set the value - create it\n\t\t\t\tif ( data[ a[i] ] === null || data[ a[i] ] === undefined )\n\t\t\t\t{\n\t\t\t\t\tdata[ a[i] ] = {};\n\t\t\t\t}\n\t\t\t\tdata = data[ a[i] ];\n\t\t\t}\n\n\t\t\t// Last item in the input - i.e, the actual set\n\t\t\tif ( aLast.match(__reFn ) )\n\t\t\t{\n\t\t\t\t// Function call\n\t\t\t\tdata = data[ aLast.replace(__reFn, '') ]( val );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If array notation is used, we just want to strip it and use the property name\n\t\t\t\t// and assign the value. If it isn't used, then we get the result we want anyway\n\t\t\t\tdata[ aLast.replace(__reArray, '') ] = val;\n\t\t\t}\n\t\t};\n\n\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\treturn setData( data, val, mSource );\n\t\t};\n\t}\n\telse\n\t{\n\t\t/* Array or flat object mapping */\n\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\tdata[mSource] = val;\n\t\t};\n\t}\n}\n\n\n/**\n * Return an array with the full table data\n *  @param {object} oSettings dataTables settings object\n *  @returns array {array} aData Master data array\n *  @memberof DataTable#oApi\n */\nfunction _fnGetDataMaster ( settings )\n{\n\treturn _pluck( settings.aoData, '_aData' );\n}\n\n\n/**\n * Nuke the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnClearTable( settings )\n{\n\tsettings.aoData.length = 0;\n\tsettings.aiDisplayMaster.length = 0;\n\tsettings.aiDisplay.length = 0;\n\tsettings.aIds = {};\n}\n\n\n /**\n * Take an array of integers (index array) and remove a target integer (value - not\n * the key!)\n *  @param {array} a Index array to target\n *  @param {int} iTarget value to find\n *  @memberof DataTable#oApi\n */\nfunction _fnDeleteIndex( a, iTarget, splice )\n{\n\tvar iTargetIndex = -1;\n\n\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t{\n\t\tif ( a[i] == iTarget )\n\t\t{\n\t\t\tiTargetIndex = i;\n\t\t}\n\t\telse if ( a[i] > iTarget )\n\t\t{\n\t\t\ta[i]--;\n\t\t}\n\t}\n\n\tif ( iTargetIndex != -1 && splice === undefined )\n\t{\n\t\ta.splice( iTargetIndex, 1 );\n\t}\n}\n\n\n/**\n * Mark cached data as invalid such that a re-read of the data will occur when\n * the cached data is next requested. Also update from the data source object.\n *\n * @param {object} settings DataTables settings object\n * @param {int}    rowIdx   Row index to invalidate\n * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n *     or 'data'\n * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n *     row will be invalidated\n * @memberof DataTable#oApi\n *\n * @todo For the modularisation of v1.11 this will need to become a callback, so\n *   the sort and filter methods can subscribe to it. That will required\n *   initialisation options for sorting, which is why it is not already baked in\n */\nfunction _fnInvalidate( settings, rowIdx, src, colIdx )\n{\n\tvar row = settings.aoData[ rowIdx ];\n\tvar i, ien;\n\tvar cellWrite = function ( cell, col ) {\n\t\t// This is very frustrating, but in IE if you just write directly\n\t\t// to innerHTML, and elements that are overwritten are GC'ed,\n\t\t// even if there is a reference to them elsewhere\n\t\twhile ( cell.childNodes.length ) {\n\t\t\tcell.removeChild( cell.firstChild );\n\t\t}\n\n\t\tcell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );\n\t};\n\n\t// Are we reading last data from DOM or the data object?\n\tif ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {\n\t\t// Read the data from the DOM\n\t\trow._aData = _fnGetRowElements(\n\t\t\t\tsettings, row, colIdx, colIdx === undefined ? undefined : row._aData\n\t\t\t)\n\t\t\t.data;\n\t}\n\telse {\n\t\t// Reading from data object, update the DOM\n\t\tvar cells = row.anCells;\n\n\t\tif ( cells ) {\n\t\t\tif ( colIdx !== undefined ) {\n\t\t\t\tcellWrite( cells[colIdx], colIdx );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\t\t\t\tcellWrite( cells[i], i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// For both row and cell invalidation, the cached data for sorting and\n\t// filtering is nulled out\n\trow._aSortData = null;\n\trow._aFilterData = null;\n\n\t// Invalidate the type for a specific column (if given) or all columns since\n\t// the data might have changed\n\tvar cols = settings.aoColumns;\n\tif ( colIdx !== undefined ) {\n\t\tcols[ colIdx ].sType = null;\n\t}\n\telse {\n\t\tfor ( i=0, ien=cols.length ; i<ien ; i++ ) {\n\t\t\tcols[i].sType = null;\n\t\t}\n\n\t\t// Update DataTables special `DT_*` attributes for the row\n\t\t_fnRowAttributes( settings, row );\n\t}\n}\n\n\n/**\n * Build a data source object from an HTML row, reading the contents of the\n * cells that are in the row.\n *\n * @param {object} settings DataTables settings object\n * @param {node|object} TR element from which to read data or existing row\n *   object from which to re-read the data from the cells\n * @param {int} [colIdx] Optional column index\n * @param {array|object} [d] Data source object. If `colIdx` is given then this\n *   parameter should also be given and will be used to write the data into.\n *   Only the column in question will be written\n * @returns {object} Object with two parameters: `data` the data read, in\n *   document order, and `cells` and array of nodes (they can be useful to the\n *   caller, so rather than needing a second traversal to get them, just return\n *   them from here).\n * @memberof DataTable#oApi\n */\nfunction _fnGetRowElements( settings, row, colIdx, d )\n{\n\tvar\n\t\ttds = [],\n\t\ttd = row.firstChild,\n\t\tname, col, o, i=0, contents,\n\t\tcolumns = settings.aoColumns,\n\t\tobjectRead = settings._rowReadObject;\n\n\t// Allow the data object to be passed in, or construct\n\td = d !== undefined ?\n\t\td :\n\t\tobjectRead ?\n\t\t\t{} :\n\t\t\t[];\n\n\tvar attr = function ( str, td  ) {\n\t\tif ( typeof str === 'string' ) {\n\t\t\tvar idx = str.indexOf('@');\n\n\t\t\tif ( idx !== -1 ) {\n\t\t\t\tvar attr = str.substring( idx+1 );\n\t\t\t\tvar setter = _fnSetObjectDataFn( str );\n\t\t\t\tsetter( d, td.getAttribute( attr ) );\n\t\t\t}\n\t\t}\n\t};\n\n\t// Read data from a cell and store into the data object\n\tvar cellProcess = function ( cell ) {\n\t\tif ( colIdx === undefined || colIdx === i ) {\n\t\t\tcol = columns[i];\n\t\t\tcontents = (cell.innerHTML).trim();\n\n\t\t\tif ( col && col._bAttrSrc ) {\n\t\t\t\tvar setter = _fnSetObjectDataFn( col.mData._ );\n\t\t\t\tsetter( d, contents );\n\n\t\t\t\tattr( col.mData.sort, cell );\n\t\t\t\tattr( col.mData.type, cell );\n\t\t\t\tattr( col.mData.filter, cell );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Depending on the `data` option for the columns the data can\n\t\t\t\t// be read to either an object or an array.\n\t\t\t\tif ( objectRead ) {\n\t\t\t\t\tif ( ! col._setter ) {\n\t\t\t\t\t\t// Cache the setter function\n\t\t\t\t\t\tcol._setter = _fnSetObjectDataFn( col.mData );\n\t\t\t\t\t}\n\t\t\t\t\tcol._setter( d, contents );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i] = contents;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t};\n\n\tif ( td ) {\n\t\t// `tr` element was passed in\n\t\twhile ( td ) {\n\t\t\tname = td.nodeName.toUpperCase();\n\n\t\t\tif ( name == \"TD\" || name == \"TH\" ) {\n\t\t\t\tcellProcess( td );\n\t\t\t\ttds.push( td );\n\t\t\t}\n\n\t\t\ttd = td.nextSibling;\n\t\t}\n\t}\n\telse {\n\t\t// Existing row object passed in\n\t\ttds = row.anCells;\n\n\t\tfor ( var j=0, jen=tds.length ; j<jen ; j++ ) {\n\t\t\tcellProcess( tds[j] );\n\t\t}\n\t}\n\n\t// Read the ID from the DOM if present\n\tvar rowNode = row.firstChild ? row : row.nTr;\n\n\tif ( rowNode ) {\n\t\tvar id = rowNode.getAttribute( 'id' );\n\n\t\tif ( id ) {\n\t\t\t_fnSetObjectDataFn( settings.rowId )( d, id );\n\t\t}\n\t}\n\n\treturn {\n\t\tdata: d,\n\t\tcells: tds\n\t};\n}\n"], "fixing_code": ["/**\n * Add a data array to the table, creating DOM node etc. This is the parallel to\n * _fnGatherData, but for adding rows from a Javascript source, rather than a\n * DOM source.\n *  @param {object} oSettings dataTables settings object\n *  @param {array} aData data array to be added\n *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n *  @memberof DataTable#oApi\n */\nfunction _fnAddData ( oSettings, aDataIn, nTr, anTds )\n{\n\t/* Create the object for storing information about this new row */\n\tvar iRow = oSettings.aoData.length;\n\tvar oData = $.extend( true, {}, DataTable.models.oRow, {\n\t\tsrc: nTr ? 'dom' : 'data',\n\t\tidx: iRow\n\t} );\n\n\toData._aData = aDataIn;\n\toSettings.aoData.push( oData );\n\n\t/* Create the cells */\n\tvar nTd, sThisType;\n\tvar columns = oSettings.aoColumns;\n\n\t// Invalidate the column types as the new data needs to be revalidated\n\tfor ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n\t{\n\t\tcolumns[i].sType = null;\n\t}\n\n\t/* Add to the display array */\n\toSettings.aiDisplayMaster.push( iRow );\n\n\tvar id = oSettings.rowIdFn( aDataIn );\n\tif ( id !== undefined ) {\n\t\toSettings.aIds[ id ] = oData;\n\t}\n\n\t/* Create the DOM information, or register it if already present */\n\tif ( nTr || ! oSettings.oFeatures.bDeferRender )\n\t{\n\t\t_fnCreateTr( oSettings, iRow, nTr, anTds );\n\t}\n\n\treturn iRow;\n}\n\n\n/**\n * Add one or more TR elements to the table. Generally we'd expect to\n * use this for reading data from a DOM sourced table, but it could be\n * used for an TR element. Note that if a TR is given, it is used (i.e.\n * it is not cloned).\n *  @param {object} settings dataTables settings object\n *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n *  @returns {array} Array of indexes for the added rows\n *  @memberof DataTable#oApi\n */\nfunction _fnAddTr( settings, trs )\n{\n\tvar row;\n\n\t// Allow an individual node to be passed in\n\tif ( ! (trs instanceof $) ) {\n\t\ttrs = $(trs);\n\t}\n\n\treturn trs.map( function (i, el) {\n\t\trow = _fnGetRowElements( settings, el );\n\t\treturn _fnAddData( settings, row.data, el, row.cells );\n\t} );\n}\n\n\n/**\n * Take a TR element and convert it to an index in aoData\n *  @param {object} oSettings dataTables settings object\n *  @param {node} n the TR element to find\n *  @returns {int} index if the node is found, null if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToDataIndex( oSettings, n )\n{\n\treturn (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;\n}\n\n\n/**\n * Take a TD element and convert it into a column data index (not the visible index)\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iRow The row number the TD/TH can be found in\n *  @param {node} n The TD/TH element to find\n *  @returns {int} index if the node is found, -1 if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToColumnIndex( oSettings, iRow, n )\n{\n\treturn $.inArray( n, oSettings.aoData[ iRow ].anCells );\n}\n\n\n/**\n * Get the data for a given cell from the internal cache, taking into account data mapping\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n *  @returns {*} Cell data\n *  @memberof DataTable#oApi\n */\nfunction _fnGetCellData( settings, rowIdx, colIdx, type )\n{\n\tvar draw           = settings.iDraw;\n\tvar col            = settings.aoColumns[colIdx];\n\tvar rowData        = settings.aoData[rowIdx]._aData;\n\tvar defaultContent = col.sDefaultContent;\n\tvar cellData       = col.fnGetData( rowData, type, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t} );\n\n\tif ( cellData === undefined ) {\n\t\tif ( settings.iDrawError != draw && defaultContent === null ) {\n\t\t\t_fnLog( settings, 0, \"Requested unknown parameter \"+\n\t\t\t\t(typeof col.mData=='function' ? '{function}' : \"'\"+col.mData+\"'\")+\n\t\t\t\t\" for row \"+rowIdx+\", column \"+colIdx, 4 );\n\t\t\tsettings.iDrawError = draw;\n\t\t}\n\t\treturn defaultContent;\n\t}\n\n\t// When the data source is null and a specific data type is requested (i.e.\n\t// not the original data), we can use default column data\n\tif ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {\n\t\tcellData = defaultContent;\n\t}\n\telse if ( typeof cellData === 'function' ) {\n\t\t// If the data source is a function, then we run it and use the return,\n\t\t// executing in the scope of the data object (for instances)\n\t\treturn cellData.call( rowData );\n\t}\n\n\tif ( cellData === null && type == 'display' ) {\n\t\treturn '';\n\t}\n\treturn cellData;\n}\n\n\n/**\n * Set the value for a specific cell, into the internal data cache\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {*} val Value to set\n *  @memberof DataTable#oApi\n */\nfunction _fnSetCellData( settings, rowIdx, colIdx, val )\n{\n\tvar col     = settings.aoColumns[colIdx];\n\tvar rowData = settings.aoData[rowIdx]._aData;\n\n\tcol.fnSetData( rowData, val, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t}  );\n}\n\n\n// Private variable that is used to match action syntax in the data property object\nvar __reArray = /\\[.*?\\]$/;\nvar __reFn = /\\(\\)$/;\n\n/**\n * Split string on periods, taking into account escaped periods\n * @param  {string} str String to split\n * @return {array} Split string\n */\nfunction _fnSplitObjNotation( str )\n{\n\treturn $.map( str.match(/(\\\\.|[^\\.])+/g) || [''], function ( s ) {\n\t\treturn s.replace(/\\\\\\./g, '.');\n\t} );\n}\n\n\n/**\n * Return a function that can be used to get data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data get function\n *  @memberof DataTable#oApi\n */\nfunction _fnGetObjectDataFn( mSource )\n{\n\tif ( $.isPlainObject( mSource ) )\n\t{\n\t\t/* Build an object of get functions, and wrap them in a single call */\n\t\tvar o = {};\n\t\t$.each( mSource, function (key, val) {\n\t\t\tif ( val ) {\n\t\t\t\to[key] = _fnGetObjectDataFn( val );\n\t\t\t}\n\t\t} );\n\n\t\treturn function (data, type, row, meta) {\n\t\t\tvar t = o[type] || o._;\n\t\t\treturn t !== undefined ?\n\t\t\t\tt(data, type, row, meta) :\n\t\t\t\tdata;\n\t\t};\n\t}\n\telse if ( mSource === null )\n\t{\n\t\t/* Give an empty string for rendering / sorting etc */\n\t\treturn function (data) { // type, row and meta also passed, but not used\n\t\t\treturn data;\n\t\t};\n\t}\n\telse if ( typeof mSource === 'function' )\n\t{\n\t\treturn function (data, type, row, meta) {\n\t\t\treturn mSource( data, type, row, meta );\n\t\t};\n\t}\n\telse if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n\t\t      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n\t{\n\t\t/* If there is a . in the source string then the data source is in a\n\t\t * nested object so we loop over the data for each level to get the next\n\t\t * level down. On each loop we test for undefined, and if found immediately\n\t\t * return. This allows entire objects to be missing and sDefaultContent to\n\t\t * be used if defined, rather than throwing an error\n\t\t */\n\t\tvar fetchData = function (data, type, src) {\n\t\t\tvar arrayNotation, funcNotation, out, innerSrc;\n\n\t\t\tif ( src !== \"\" )\n\t\t\t{\n\t\t\t\tvar a = _fnSplitObjNotation( src );\n\n\t\t\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t\t\t\t{\n\t\t\t\t\t// Check if we are dealing with special notation\n\t\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\t\tfuncNotation = a[i].match(__reFn);\n\n\t\t\t\t\tif ( arrayNotation )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Array notation\n\t\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\n\t\t\t\t\t\t// Condition allows simply [] to be passed in\n\t\t\t\t\t\tif ( a[i] !== \"\" ) {\n\t\t\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout = [];\n\n\t\t\t\t\t\t// Get the remainder of the nested object to get\n\t\t\t\t\t\ta.splice( 0, i+1 );\n\t\t\t\t\t\tinnerSrc = a.join('.');\n\n\t\t\t\t\t\t// Traverse each entry in the array getting the properties requested\n\t\t\t\t\t\tif ( Array.isArray( data ) ) {\n\t\t\t\t\t\t\tfor ( var j=0, jLen=data.length ; j<jLen ; j++ ) {\n\t\t\t\t\t\t\t\tout.push( fetchData( data[j], type, innerSrc ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a string is given in between the array notation indicators, that\n\t\t\t\t\t\t// is used to join the strings together, otherwise an array is returned\n\t\t\t\t\t\tvar join = arrayNotation[0].substring(1, arrayNotation[0].length-1);\n\t\t\t\t\t\tdata = (join===\"\") ? out : out.join(join);\n\n\t\t\t\t\t\t// The inner call to fetchData has already traversed through the remainder\n\t\t\t\t\t\t// of the source requested, so we exit from the loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( funcNotation )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Function call\n\t\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\t\tdata = data[ a[i] ]();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data === null || data[ a[i] ] === undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\treturn fetchData( data, type, mSource );\n\t\t};\n\t}\n\telse\n\t{\n\t\t/* Array or flat object mapping */\n\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\treturn data[mSource];\n\t\t};\n\t}\n}\n\n\n/**\n * Return a function that can be used to set data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data set function\n *  @memberof DataTable#oApi\n */\nfunction _fnSetObjectDataFn( mSource )\n{\n\tif ( $.isPlainObject( mSource ) )\n\t{\n\t\t/* Unlike get, only the underscore (global) option is used for for\n\t\t * setting data since we don't know the type here. This is why an object\n\t\t * option is not documented for `mData` (which is read/write), but it is\n\t\t * for `mRender` which is read only.\n\t\t */\n\t\treturn _fnSetObjectDataFn( mSource._ );\n\t}\n\telse if ( mSource === null )\n\t{\n\t\t/* Nothing to do when the data source is null */\n\t\treturn function () {};\n\t}\n\telse if ( typeof mSource === 'function' )\n\t{\n\t\treturn function (data, val, meta) {\n\t\t\tmSource( data, 'set', val, meta );\n\t\t};\n\t}\n\telse if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n\t\t      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )\n\t{\n\t\t/* Like the get, we need to get data from a nested object */\n\t\tvar setData = function (data, val, src) {\n\t\t\tvar a = _fnSplitObjNotation( src ), b;\n\t\t\tvar aLast = a[a.length-1];\n\t\t\tvar arrayNotation, funcNotation, o, innerSrc;\n\n\t\t\tfor ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\t// Protect against prototype pollution\n\t\t\t\tif (a[i] === '__proto__' || a[i] === 'constructor') {\n\t\t\t\t\tthrow new Error('Cannot set prototype values');\n\t\t\t\t}\n\n\t\t\t\t// Check if we are dealing with an array notation request\n\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\tfuncNotation = a[i].match(__reFn);\n\n\t\t\t\tif ( arrayNotation )\n\t\t\t\t{\n\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\t\t\t\t\tdata[ a[i] ] = [];\n\n\t\t\t\t\t// Get the remainder of the nested object to set so we can recurse\n\t\t\t\t\tb = a.slice();\n\t\t\t\t\tb.splice( 0, i+1 );\n\t\t\t\t\tinnerSrc = b.join('.');\n\n\t\t\t\t\t// Traverse each entry in the array setting the properties requested\n\t\t\t\t\tif ( Array.isArray( val ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( var j=0, jLen=val.length ; j<jLen ; j++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\to = {};\n\t\t\t\t\t\t\tsetData( o, val[j], innerSrc );\n\t\t\t\t\t\t\tdata[ a[i] ].push( o );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// We've been asked to save data to an array, but it\n\t\t\t\t\t\t// isn't array data to be saved. Best that can be done\n\t\t\t\t\t\t// is to just save the value.\n\t\t\t\t\t\tdata[ a[i] ] = val;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The inner call to setData has already traversed through the remainder\n\t\t\t\t\t// of the source and has set the data, thus we can exit here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( funcNotation )\n\t\t\t\t{\n\t\t\t\t\t// Function call\n\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\tdata = data[ a[i] ]( val );\n\t\t\t\t}\n\n\t\t\t\t// If the nested object doesn't currently exist - since we are\n\t\t\t\t// trying to set the value - create it\n\t\t\t\tif ( data[ a[i] ] === null || data[ a[i] ] === undefined )\n\t\t\t\t{\n\t\t\t\t\tdata[ a[i] ] = {};\n\t\t\t\t}\n\t\t\t\tdata = data[ a[i] ];\n\t\t\t}\n\n\t\t\t// Last item in the input - i.e, the actual set\n\t\t\tif ( aLast.match(__reFn ) )\n\t\t\t{\n\t\t\t\t// Function call\n\t\t\t\tdata = data[ aLast.replace(__reFn, '') ]( val );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If array notation is used, we just want to strip it and use the property name\n\t\t\t\t// and assign the value. If it isn't used, then we get the result we want anyway\n\t\t\t\tdata[ aLast.replace(__reArray, '') ] = val;\n\t\t\t}\n\t\t};\n\n\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\treturn setData( data, val, mSource );\n\t\t};\n\t}\n\telse\n\t{\n\t\t/* Array or flat object mapping */\n\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\tdata[mSource] = val;\n\t\t};\n\t}\n}\n\n\n/**\n * Return an array with the full table data\n *  @param {object} oSettings dataTables settings object\n *  @returns array {array} aData Master data array\n *  @memberof DataTable#oApi\n */\nfunction _fnGetDataMaster ( settings )\n{\n\treturn _pluck( settings.aoData, '_aData' );\n}\n\n\n/**\n * Nuke the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnClearTable( settings )\n{\n\tsettings.aoData.length = 0;\n\tsettings.aiDisplayMaster.length = 0;\n\tsettings.aiDisplay.length = 0;\n\tsettings.aIds = {};\n}\n\n\n /**\n * Take an array of integers (index array) and remove a target integer (value - not\n * the key!)\n *  @param {array} a Index array to target\n *  @param {int} iTarget value to find\n *  @memberof DataTable#oApi\n */\nfunction _fnDeleteIndex( a, iTarget, splice )\n{\n\tvar iTargetIndex = -1;\n\n\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t{\n\t\tif ( a[i] == iTarget )\n\t\t{\n\t\t\tiTargetIndex = i;\n\t\t}\n\t\telse if ( a[i] > iTarget )\n\t\t{\n\t\t\ta[i]--;\n\t\t}\n\t}\n\n\tif ( iTargetIndex != -1 && splice === undefined )\n\t{\n\t\ta.splice( iTargetIndex, 1 );\n\t}\n}\n\n\n/**\n * Mark cached data as invalid such that a re-read of the data will occur when\n * the cached data is next requested. Also update from the data source object.\n *\n * @param {object} settings DataTables settings object\n * @param {int}    rowIdx   Row index to invalidate\n * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n *     or 'data'\n * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n *     row will be invalidated\n * @memberof DataTable#oApi\n *\n * @todo For the modularisation of v1.11 this will need to become a callback, so\n *   the sort and filter methods can subscribe to it. That will required\n *   initialisation options for sorting, which is why it is not already baked in\n */\nfunction _fnInvalidate( settings, rowIdx, src, colIdx )\n{\n\tvar row = settings.aoData[ rowIdx ];\n\tvar i, ien;\n\tvar cellWrite = function ( cell, col ) {\n\t\t// This is very frustrating, but in IE if you just write directly\n\t\t// to innerHTML, and elements that are overwritten are GC'ed,\n\t\t// even if there is a reference to them elsewhere\n\t\twhile ( cell.childNodes.length ) {\n\t\t\tcell.removeChild( cell.firstChild );\n\t\t}\n\n\t\tcell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );\n\t};\n\n\t// Are we reading last data from DOM or the data object?\n\tif ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {\n\t\t// Read the data from the DOM\n\t\trow._aData = _fnGetRowElements(\n\t\t\t\tsettings, row, colIdx, colIdx === undefined ? undefined : row._aData\n\t\t\t)\n\t\t\t.data;\n\t}\n\telse {\n\t\t// Reading from data object, update the DOM\n\t\tvar cells = row.anCells;\n\n\t\tif ( cells ) {\n\t\t\tif ( colIdx !== undefined ) {\n\t\t\t\tcellWrite( cells[colIdx], colIdx );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\t\t\t\tcellWrite( cells[i], i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// For both row and cell invalidation, the cached data for sorting and\n\t// filtering is nulled out\n\trow._aSortData = null;\n\trow._aFilterData = null;\n\n\t// Invalidate the type for a specific column (if given) or all columns since\n\t// the data might have changed\n\tvar cols = settings.aoColumns;\n\tif ( colIdx !== undefined ) {\n\t\tcols[ colIdx ].sType = null;\n\t}\n\telse {\n\t\tfor ( i=0, ien=cols.length ; i<ien ; i++ ) {\n\t\t\tcols[i].sType = null;\n\t\t}\n\n\t\t// Update DataTables special `DT_*` attributes for the row\n\t\t_fnRowAttributes( settings, row );\n\t}\n}\n\n\n/**\n * Build a data source object from an HTML row, reading the contents of the\n * cells that are in the row.\n *\n * @param {object} settings DataTables settings object\n * @param {node|object} TR element from which to read data or existing row\n *   object from which to re-read the data from the cells\n * @param {int} [colIdx] Optional column index\n * @param {array|object} [d] Data source object. If `colIdx` is given then this\n *   parameter should also be given and will be used to write the data into.\n *   Only the column in question will be written\n * @returns {object} Object with two parameters: `data` the data read, in\n *   document order, and `cells` and array of nodes (they can be useful to the\n *   caller, so rather than needing a second traversal to get them, just return\n *   them from here).\n * @memberof DataTable#oApi\n */\nfunction _fnGetRowElements( settings, row, colIdx, d )\n{\n\tvar\n\t\ttds = [],\n\t\ttd = row.firstChild,\n\t\tname, col, o, i=0, contents,\n\t\tcolumns = settings.aoColumns,\n\t\tobjectRead = settings._rowReadObject;\n\n\t// Allow the data object to be passed in, or construct\n\td = d !== undefined ?\n\t\td :\n\t\tobjectRead ?\n\t\t\t{} :\n\t\t\t[];\n\n\tvar attr = function ( str, td  ) {\n\t\tif ( typeof str === 'string' ) {\n\t\t\tvar idx = str.indexOf('@');\n\n\t\t\tif ( idx !== -1 ) {\n\t\t\t\tvar attr = str.substring( idx+1 );\n\t\t\t\tvar setter = _fnSetObjectDataFn( str );\n\t\t\t\tsetter( d, td.getAttribute( attr ) );\n\t\t\t}\n\t\t}\n\t};\n\n\t// Read data from a cell and store into the data object\n\tvar cellProcess = function ( cell ) {\n\t\tif ( colIdx === undefined || colIdx === i ) {\n\t\t\tcol = columns[i];\n\t\t\tcontents = (cell.innerHTML).trim();\n\n\t\t\tif ( col && col._bAttrSrc ) {\n\t\t\t\tvar setter = _fnSetObjectDataFn( col.mData._ );\n\t\t\t\tsetter( d, contents );\n\n\t\t\t\tattr( col.mData.sort, cell );\n\t\t\t\tattr( col.mData.type, cell );\n\t\t\t\tattr( col.mData.filter, cell );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Depending on the `data` option for the columns the data can\n\t\t\t\t// be read to either an object or an array.\n\t\t\t\tif ( objectRead ) {\n\t\t\t\t\tif ( ! col._setter ) {\n\t\t\t\t\t\t// Cache the setter function\n\t\t\t\t\t\tcol._setter = _fnSetObjectDataFn( col.mData );\n\t\t\t\t\t}\n\t\t\t\t\tcol._setter( d, contents );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i] = contents;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t};\n\n\tif ( td ) {\n\t\t// `tr` element was passed in\n\t\twhile ( td ) {\n\t\t\tname = td.nodeName.toUpperCase();\n\n\t\t\tif ( name == \"TD\" || name == \"TH\" ) {\n\t\t\t\tcellProcess( td );\n\t\t\t\ttds.push( td );\n\t\t\t}\n\n\t\t\ttd = td.nextSibling;\n\t\t}\n\t}\n\telse {\n\t\t// Existing row object passed in\n\t\ttds = row.anCells;\n\n\t\tfor ( var j=0, jen=tds.length ; j<jen ; j++ ) {\n\t\t\tcellProcess( tds[j] );\n\t\t}\n\t}\n\n\t// Read the ID from the DOM if present\n\tvar rowNode = row.firstChild ? row : row.nTr;\n\n\tif ( rowNode ) {\n\t\tvar id = rowNode.getAttribute( 'id' );\n\n\t\tif ( id ) {\n\t\t\t_fnSetObjectDataFn( settings.rowId )( d, id );\n\t\t}\n\t}\n\n\treturn {\n\t\tdata: d,\n\t\tcells: tds\n\t};\n}\n"], "filenames": ["js/core/core.data.js"], "buggy_code_start_loc": [360], "buggy_code_end_loc": [361], "fixing_code_start_loc": [360], "fixing_code_end_loc": [361], "type": "CWE-1321", "message": "All versions of package datatables.net are vulnerable to Prototype Pollution due to an incomplete fix for https://snyk.io/vuln/SNYK-JS-DATATABLESNET-598806.", "other": {"cve": {"id": "CVE-2020-28458", "sourceIdentifier": "report@snyk.io", "published": "2020-12-16T11:15:12.130", "lastModified": "2022-08-15T15:51:35.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "All versions of package datatables.net are vulnerable to Prototype Pollution due to an incomplete fix for https://snyk.io/vuln/SNYK-JS-DATATABLESNET-598806."}, {"lang": "es", "value": "Todas las versiones del paquete datatables.net son vulnerables a una contaminaci\u00f3n de prototipos debido a una correcci\u00f3n incompleta para https://snyk.io/vuln/SNYK-JS-DATATABLESNET-598806"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:datatables:datatables.net:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.10.23", "matchCriteriaId": "E9C31498-D6FB-4A18-86D6-10D48577C6EF"}]}]}], "references": [{"url": "https://github.com/DataTables/DataTablesSrc/commit/a51cbe99fd3d02aa5582f97d4af1615d11a1ea03", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DataTables/Dist-DataTables/blob/master/js/jquery.dataTables.js%23L2766", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1051961", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1051962", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-DATATABLESNET-1016402", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-DATATABLESNET-598806", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DataTables/DataTablesSrc/commit/a51cbe99fd3d02aa5582f97d4af1615d11a1ea03"}}