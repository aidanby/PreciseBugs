{"buggy_code": ["// This file is part of Deark.\n// Copyright (C) 2016 Jason Summers\n// See the file COPYING for terms of use.\n\n// This file is for format-specific functions that are used by multiple modules.\n\n#define DE_NOT_IN_MODULE\n#include \"deark-config.h\"\n#include \"deark-private.h\"\n#include \"deark-fmtutil.h\"\n\nvoid fmtutil_get_bmp_compression_name(u32 code, char *s, size_t s_len,\n\tint is_os2v2)\n{\n\tconst char *name1 = \"?\";\n\tswitch(code) {\n\tcase 0: name1 = \"BI_RGB, uncompressed\"; break;\n\tcase 1: name1 = \"BI_RLE8\"; break;\n\tcase 2: name1 = \"BI_RLE4\"; break;\n\tcase 3:\n\t\tif(is_os2v2)\n\t\t\tname1 = \"Huffman 1D\";\n\t\telse\n\t\t\tname1 = \"BI_BITFIELDS, uncompressed\";\n\t\tbreak;\n\tcase 4:\n\t\tif(is_os2v2)\n\t\t\tname1 = \"RLE24\";\n\t\telse\n\t\t\tname1 = \"BI_JPEG\";\n\t\tbreak;\n\tcase 5: name1 = \"BI_PNG\"; break;\n\t}\n\tde_strlcpy(s, name1, s_len);\n}\n\n// Gathers information about a DIB.\n// If DE_BMPINFO_HAS_FILEHEADER flag is set, pos points to the BITMAPFILEHEADER.\n// Otherwise, it points to the BITMAPINFOHEADER.\n// Caller allocates bi.\n// Returns 0 if BMP is invalid.\nint fmtutil_get_bmpinfo(deark *c, dbuf *f, struct de_bmpinfo *bi, i64 pos,\n\ti64 len, unsigned int flags)\n{\n\ti64 fhs; // file header size\n\ti64 bmih_pos;\n\tstruct de_fourcc cmpr4cc;\n\tchar cmprname_dbgstr[80];\n\n\tde_zeromem(bi, sizeof(struct de_bmpinfo));\n\tde_zeromem(&cmpr4cc, sizeof(struct de_fourcc));\n\n\tfhs = (flags & DE_BMPINFO_HAS_FILEHEADER) ? 14 : 0;\n\n\tif(fhs+len < 16) return 0;\n\n\tif(fhs) {\n\t\tif(flags & DE_BMPINFO_HAS_HOTSPOT) {\n\t\t\tbi->hotspot_x = (int)dbuf_getu16le(f, pos+6);\n\t\t\tbi->hotspot_y = (int)dbuf_getu16le(f, pos+8);\n\t\t\tde_dbg(c, \"hotspot: (%d,%d)\", bi->hotspot_x, bi->hotspot_y);\n\t\t}\n\n\t\tbi->bitsoffset = dbuf_getu32le(f, pos+10);\n\t\tde_dbg(c, \"bits offset: %d\", (int)bi->bitsoffset);\n\t}\n\n\tbmih_pos = pos + fhs;\n\n\tbi->infohdrsize = dbuf_getu32le(f, bmih_pos);\n\n\tif(bi->infohdrsize==0x474e5089 && (flags & DE_BMPINFO_ICO_FORMAT)) {\n\t\t// We don't examine PNG-formatted icons, but we can identify them.\n\t\tbi->infohdrsize = 0;\n\t\tbi->file_format = DE_BMPINFO_FMT_PNG;\n\t\treturn 1;\n\t}\n\n\tde_dbg(c, \"info header size: %d\", (int)bi->infohdrsize);\n\n\tif(bi->infohdrsize==12) {\n\t\tbi->bytes_per_pal_entry = 3;\n\t\tbi->width = dbuf_getu16le(f, bmih_pos+4);\n\t\tbi->height = dbuf_getu16le(f, bmih_pos+6);\n\t\tbi->bitcount = dbuf_getu16le(f, bmih_pos+10);\n\t}\n\telse if(bi->infohdrsize>=16 && bi->infohdrsize<=124) {\n\t\tbi->bytes_per_pal_entry = 4;\n\t\tbi->width = dbuf_getu32le(f, bmih_pos+4);\n\t\tbi->height = dbuf_geti32le(f, bmih_pos+8);\n\t\tif(bi->height<0) {\n\t\t\tbi->is_topdown = 1;\n\t\t\tbi->height = -bi->height;\n\t\t}\n\t\tbi->bitcount = dbuf_getu16le(f, bmih_pos+14);\n\t\tif(bi->infohdrsize>=20) {\n\t\t\tbi->compression_field = (u32)dbuf_getu32le(f, bmih_pos+16);\n\t\t\tif(flags & DE_BMPINFO_CMPR_IS_4CC) {\n\t\t\t\tdbuf_read_fourcc(f, bmih_pos+16, &cmpr4cc, 4, 0x0);\n\t\t\t}\n\t\t}\n\t\tif(bi->infohdrsize>=24) {\n\t\t\tbi->sizeImage_field = dbuf_getu32le(f, bmih_pos+20);\n\t\t}\n\t\tif(bi->infohdrsize>=36) {\n\t\t\tbi->pal_entries = dbuf_getu32le(f, bmih_pos+32);\n\t\t}\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\tif(flags & DE_BMPINFO_ICO_FORMAT) bi->height /= 2;\n\n\tif(bi->bitcount>=1 && bi->bitcount<=8) {\n\t\tif(bi->pal_entries==0) {\n\t\t\tbi->pal_entries = de_pow2(bi->bitcount);\n\t\t}\n\t\t// I think the NumColors field (in icons) is supposed to be the maximum number of\n\t\t// colors implied by the bit depth, not the number of colors in the palette.\n\t\tbi->num_colors = de_pow2(bi->bitcount);\n\t}\n\telse {\n\t\t// An arbitrary value. All that matters is that it's >=256.\n\t\tbi->num_colors = 16777216;\n\t}\n\n\tde_dbg_dimensions(c, bi->width, bi->height);\n\tde_dbg(c, \"bit count: %d\", (int)bi->bitcount);\n\n\tif((flags & DE_BMPINFO_CMPR_IS_4CC) && (bi->compression_field>0xffff)) {\n\t\tde_snprintf(cmprname_dbgstr, sizeof(cmprname_dbgstr), \"'%s'\", cmpr4cc.id_dbgstr);\n\t}\n\telse {\n\t\tfmtutil_get_bmp_compression_name(bi->compression_field,\n\t\t\tcmprname_dbgstr, sizeof(cmprname_dbgstr), 0);\n\t}\n\tde_dbg(c, \"compression: %u (%s)\", (unsigned int)bi->compression_field, cmprname_dbgstr);\n\n\tif(bi->sizeImage_field!=0) {\n\t\tde_dbg(c, \"sizeImage: %u\", (unsigned int)bi->sizeImage_field);\n\t}\n\n\tde_dbg(c, \"palette entries: %u\", (unsigned int)bi->pal_entries);\n\tif(bi->pal_entries>256 && bi->bitcount>8) {\n\t\tde_warn(c, \"Ignoring bad palette size (%u entries)\", (unsigned int)bi->pal_entries);\n\t\tbi->pal_entries = 0;\n\t}\n\n\tbi->pal_bytes = bi->bytes_per_pal_entry*bi->pal_entries;\n\tbi->size_of_headers_and_pal = fhs + bi->infohdrsize + bi->pal_bytes;\n\n\t// FIXME: cmpr type 3 doesn't always mean BITFIELDS\n\tif(bi->compression_field==3) {\n\t\tbi->size_of_headers_and_pal += 12; // BITFIELDS\n\t}\n\n\tbi->is_compressed = !((bi->compression_field==0) ||\n\t\t(bi->compression_field==3 && bi->bitcount>1));\n\n\tif(!de_good_image_dimensions(c, bi->width, bi->height)) {\n\t\treturn 0;\n\t}\n\n\t// TODO: This needs work, to decide how to handle compressed images.\n\t// TODO: What about BI_BITFIELDS images?\n\tif(bi->compression_field==0) {\n\t\t// Try to figure out the true size of the resource, minus any padding.\n\n\t\tbi->rowspan = ((bi->bitcount*bi->width +31)/32)*4;\n\t\tbi->foreground_size = bi->rowspan * bi->height;\n\t\tde_dbg(c, \"foreground size: %d\", (int)bi->foreground_size);\n\n\t\tif(flags & DE_BMPINFO_ICO_FORMAT) {\n\t\t\tbi->mask_rowspan = ((bi->width +31)/32)*4;\n\t\t\tbi->mask_size = bi->mask_rowspan * bi->height;\n\t\t\tde_dbg(c, \"mask size: %d\", (int)bi->mask_size);\n\t\t}\n\t\telse {\n\t\t\tbi->mask_size = 0;\n\t\t}\n\n\t\tbi->total_size = bi->size_of_headers_and_pal + bi->foreground_size + bi->mask_size;\n\t}\n\telse {\n\t\t// Don't try to figure out the true size of compressed or other unusual images.\n\t\tbi->total_size = len;\n\t}\n\n\treturn 1;\n}\n\n// TODO: Document and review whether the bi->total_size and\n// bi->size_of_headers_and_pal fields include the 14-byte fileheader.\nvoid fmtutil_generate_bmpfileheader(deark *c, dbuf *outf, const struct de_bmpinfo *bi,\n\ti64 file_size_override)\n{\n\ti64 file_size_to_write;\n\n\tdbuf_write(outf, (const u8*)\"BM\", 2);\n\n\tif(file_size_override)\n\t\tfile_size_to_write = file_size_override;\n\telse\n\t\tfile_size_to_write = 14 + bi->total_size;\n\tdbuf_writeu32le(outf, file_size_to_write);\n\n\tdbuf_write_zeroes(outf, 4);\n\tdbuf_writeu32le(outf, 14 + bi->size_of_headers_and_pal);\n}\n\n// Extracts Exif if extract_level>=2, or \"extractexif\" option is set.\n// Otherwise decodes.\nvoid fmtutil_handle_exif2(deark *c, i64 pos, i64 len,\n\tu32 *returned_flags, u32 *orientation, u32 *exifversion)\n{\n\tint user_opt;\n\tde_module_params *mparams = NULL;\n\n\tif(returned_flags) {\n\t\t*returned_flags = 0;\n\t}\n\n\tuser_opt = de_get_ext_option_bool(c, \"extractexif\", -1);\n\tif(user_opt==1 || (c->extract_level>=2 && user_opt!=0)) {\n\t\t// Writing raw Exif data isn't very useful, but do so if requested.\n\t\tdbuf_create_file_from_slice(c->infile, pos, len, \"exif.tif\", NULL, DE_CREATEFLAG_IS_AUX);\n\n\t\t// Caller will have to reprocess the Exif file to extract anything from it.\n\t\treturn;\n\t}\n\n\tmparams = de_malloc(c, sizeof(de_module_params));\n\tmparams->in_params.codes = \"E\";\n\n\tde_run_module_by_id_on_slice(c, \"tiff\", mparams, c->infile, pos, len);\n\tif(returned_flags) {\n\t\t// FIXME: It's an unfortunate bug that returned_flags does not work if\n\t\t// extract_level>=2, but for now there's no reasonable way to fix it.\n\t\t// We have to process -- not extract -- the Exif chunk if we want to\n\t\t// know what's in it.\n\t\t*returned_flags = mparams->out_params.flags;\n\t\tif((mparams->out_params.flags & 0x20) && orientation) {\n\t\t\t*orientation = mparams->out_params.uint1;\n\t\t}\n\n\t\tif((mparams->out_params.flags & 0x40) && exifversion) {\n\t\t\t*exifversion = mparams->out_params.uint2;\n\t\t}\n\t}\n\n\tde_free(c, mparams);\n}\n\nvoid fmtutil_handle_exif(deark *c, i64 pos, i64 len)\n{\n\tfmtutil_handle_exif2(c, pos, len, NULL, NULL, NULL);\n}\n\nstatic void wrap_in_tiff(deark *c, dbuf *f, i64 dpos, i64 dlen,\n\tconst char *swstring, unsigned int tag, const char *ext, unsigned int createflags);\n\n// Either extract IPTC-IIM data to a file, or drill down into it.\n// flags:\n//  0 = default behavior (currently: depends on c->extract_level and options)\n//  2 = this came from our TIFF-encapsulated format\nvoid fmtutil_handle_iptc(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags)\n{\n\tint should_decode;\n\tint should_extract;\n\tint user_opt;\n\tint extract_fmt = 1; // 0=raw, 1=TIFF-wrapped\n\n\tif(len<1) return;\n\n\tuser_opt = de_get_ext_option_bool(c, \"extractiptc\", -1);\n\n\tif(user_opt==1 || (c->extract_level>=2 && user_opt!=0)) {\n\t\tshould_decode = 0;\n\t\tshould_extract = 1;\n\t\tif(flags&0x2) {\n\t\t\t// Avoid \"extracting\" in a way that would just recreate the exact same file.\n\t\t\textract_fmt = 0;\n\t\t}\n\t}\n\telse {\n\t\tshould_decode = 1;\n\t\tshould_extract = 0;\n\t}\n\n\tif(should_decode) {\n\t\tde_run_module_by_id_on_slice(c, \"iptc\", NULL, f, pos, len);\n\t}\n\n\tif(should_extract && extract_fmt==0) {\n\t\tdbuf_create_file_from_slice(f, pos, len, \"iptc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse if(should_extract && extract_fmt==1) {\n\t\twrap_in_tiff(c, f, pos, len, \"Deark extracted IPTC\", 33723, \"iptctiff\",\n\t\t\tDE_CREATEFLAG_IS_AUX);\n\t}\n}\n\n// If oparams is not NULL, if must be initialized by the caller. If the data is\n// decoded, oparams will be used by the submodule, and values may be returned in\n// it.\n// flags:\n//  0 = default behavior (currently: always decode)\n//  1 = always write to file\n//  2 = this came from our TIFF-encapsulated format\nvoid fmtutil_handle_photoshop_rsrc2(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags, struct de_module_out_params *oparams)\n{\n\tint should_decode;\n\tint should_extract;\n\tint extract_fmt = 1; // 0=raw, 1=TIFF-wrapped\n\n\tif(flags&0x1) {\n\t\tshould_decode = 0;\n\t\tshould_extract = 1;\n\t}\n\telse if(de_get_ext_option_bool(c, \"extract8bim\", 0)) {\n\t\tshould_extract = 1;\n\t\tshould_decode = 0;\n\t\tif(flags&0x2) {\n\t\t\t// Avoid \"extracting\" in a way that would just recreate the exact same file.\n\t\t\textract_fmt = 0;\n\t\t}\n\t}\n\telse {\n\t\tshould_decode = 1;\n\t\tshould_extract = 0;\n\t}\n\n\tif(should_decode) {\n\t\tde_module_params *mparams = NULL;\n\n\t\tmparams = de_malloc(c, sizeof(de_module_params));\n\t\tmparams->in_params.codes = \"R\";\n\t\tif(oparams) {\n\t\t\t// Since mparams->out_params is an embedded struct, not a pointer,\n\t\t\t// we have to copy oparam's fields to and from it.\n\t\t\tmparams->out_params = *oparams; // struct copy\n\t\t}\n\t\tde_run_module_by_id_on_slice(c, \"psd\", mparams, f, pos, len);\n\t\tif(oparams) {\n\t\t\t*oparams = mparams->out_params; // struct copy\n\t\t}\n\t\tde_free(c, mparams);\n\t}\n\n\tif(should_extract && extract_fmt==0) {\n\t\tdbuf_create_file_from_slice(f, pos, len, \"8bim\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse if(should_extract && extract_fmt==1) {\n\t\twrap_in_tiff(c, f, pos, len, \"Deark extracted 8BIM\", 34377, \"8bimtiff\",\n\t\t\tDE_CREATEFLAG_IS_AUX);\n\t}\n}\n\nvoid fmtutil_handle_photoshop_rsrc(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags)\n{\n\tfmtutil_handle_photoshop_rsrc2(c, f, pos, len, flags, NULL);\n}\n\n// flags:\n//  0 = default behavior (currently: decode unless -opt extractplist was used)\nvoid fmtutil_handle_plist(deark *c, dbuf *f, i64 pos, i64 len,\n\tde_finfo *fi, unsigned int flags)\n{\n\tif(de_get_ext_option_bool(c, \"extractplist\", 0)) {\n\t\tdbuf_create_file_from_slice(f, pos, len,\n\t\t\tfi?NULL:\"plist\", fi, DE_CREATEFLAG_IS_AUX);\n\t\treturn;\n\t}\n\n\tde_run_module_by_id_on_slice(c, \"plist\", NULL, f, pos, len);\n}\n\n// Caller allocates sdd. It does not need to be initialized.\n// flags: 0x1 = Print a debug message if signature is found.\nint fmtutil_detect_SAUCE(deark *c, dbuf *f, struct de_SAUCE_detection_data *sdd,\n\tunsigned int flags)\n{\n\tde_zeromem(sdd, sizeof(struct de_SAUCE_detection_data));\n\tif(f->len<128) return 0;\n\tif(dbuf_memcmp(f, f->len-128, \"SAUCE00\", 7)) return 0;\n\tif(flags & 0x1) {\n\t\tde_dbg(c, \"SAUCE metadata, signature at %\"I64_FMT, f->len-128);\n\t}\n\tsdd->has_SAUCE = 1;\n\tsdd->data_type = dbuf_getbyte(f, f->len-128+94);\n\tsdd->file_type = dbuf_getbyte(f, f->len-128+95);\n\treturn (int)sdd->has_SAUCE;\n}\n\nvoid fmtutil_handle_SAUCE(deark *c, dbuf *f, struct de_SAUCE_info *si)\n{\n\tde_module_params mparams;\n\n\tde_zeromem(&mparams, sizeof(de_module_params));\n\tmparams.out_params.obj1 = (void*)si;\n\tde_run_module_by_id_on_slice(c, \"sauce\", &mparams, f, 0, f->len);\n}\n\nstruct de_SAUCE_info *fmtutil_create_SAUCE(deark *c)\n{\n\treturn de_malloc(c, sizeof(struct de_SAUCE_info));\n}\n\nvoid fmtutil_free_SAUCE(deark *c, struct de_SAUCE_info *si)\n{\n\tif(!si) return;\n\tucstring_destroy(si->title);\n\tucstring_destroy(si->artist);\n\tucstring_destroy(si->organization);\n\tucstring_destroy(si->comment);\n\tde_free(c, si);\n}\n\n// Helper functions for the \"boxes\" (or \"atoms\") format used by MP4, JPEG 2000, etc.\n\ndouble dbuf_fmtutil_read_fixed_16_16(dbuf *f, i64 pos)\n{\n\ti64 n;\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\nstatic void do_box_sequence(deark *c, struct de_boxesctx *bctx,\n\ti64 pos1, i64 len, i64 max_nboxes, int level);\n\n// Make a printable version of a UUID (or a big-endian GUID).\n// Caller supplies s.\nvoid fmtutil_render_uuid(deark *c, const u8 *uuid, char *s, size_t s_len)\n{\n\tde_snprintf(s, s_len, \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t\tuuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],\n\t\tuuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);\n}\n\n// Swap some bytes to convert a (little-endian) GUID to a UUID, in-place\nvoid fmtutil_guid_to_uuid(u8 *id)\n{\n\tu8 tmp[16];\n\tde_memcpy(tmp, id, 16);\n\tid[0] = tmp[3]; id[1] = tmp[2]; id[2] = tmp[1]; id[3] = tmp[0];\n\tid[4] = tmp[5]; id[5] = tmp[4];\n\tid[6] = tmp[7]; id[7] = tmp[6];\n}\n\n#define DE_BOX_uuid 0x75756964U\n\nstatic int do_box(deark *c, struct de_boxesctx *bctx, i64 pos, i64 len,\n\tint level, i64 *pbytes_consumed)\n{\n\ti64 size32, size64;\n\ti64 header_len; // Not including UUIDs\n\ti64 payload_len; // Including UUIDs\n\ti64 total_len;\n\tstruct de_fourcc box4cc;\n\tchar uuid_string[50];\n\tint ret;\n\tint retval = 0;\n\tstruct de_boxdata *parentbox;\n\tstruct de_boxdata *curbox;\n\n\tparentbox = bctx->curbox;\n\tbctx->curbox = de_malloc(c, sizeof(struct de_boxdata));\n\tcurbox = bctx->curbox;\n\tcurbox->parent = parentbox;\n\n\tif(len<8) {\n\t\tde_dbg(c, \"(ignoring %d extra bytes at %\"I64_FMT\")\", (int)len, pos);\n\t\tgoto done;\n\t}\n\n\tsize32 = dbuf_getu32be(bctx->f, pos);\n\tdbuf_read_fourcc(bctx->f, pos+4, &box4cc, 4, 0x0);\n\tcurbox->boxtype = box4cc.id;\n\n\tif(size32>=8) {\n\t\theader_len = 8;\n\t\tpayload_len = size32-8;\n\t}\n\telse if(size32==0) {\n\t\theader_len = 8;\n\t\tpayload_len = len-8;\n\t}\n\telse if(size32==1) {\n\t\tif(len<16) {\n\t\t\tde_dbg(c, \"(ignoring %d extra bytes at %\"I64_FMT\")\", (int)len, pos);\n\t\t\tgoto done;\n\t\t}\n\t\theader_len = 16;\n\t\tsize64 = dbuf_geti64be(bctx->f, pos+8);\n\t\tif(size64<16) goto done;\n\t\tpayload_len = size64-16;\n\t}\n\telse {\n\t\tde_err(c, \"Invalid or unsupported box format\");\n\t\tgoto done;\n\t}\n\n\ttotal_len = header_len + payload_len;\n\n\tif(curbox->boxtype==DE_BOX_uuid && payload_len>=16) {\n\t\tcurbox->is_uuid = 1;\n\t\tdbuf_read(bctx->f, curbox->uuid, pos+header_len, 16);\n\t}\n\n\tcurbox->level = level;\n\tcurbox->box_pos = pos;\n\tcurbox->box_len = total_len;\n\tcurbox->payload_pos = pos+header_len;\n\tcurbox->payload_len = payload_len;\n\tif(curbox->is_uuid) {\n\t\tcurbox->payload_pos += 16;\n\t\tcurbox->payload_len -= 16;\n\t}\n\n\tif(bctx->identify_box_fn) {\n\t\tbctx->identify_box_fn(c, bctx);\n\t}\n\n\tif(c->debug_level>0) {\n\t\tchar name_str[80];\n\n\t\tif(curbox->box_name) {\n\t\t\tde_snprintf(name_str, sizeof(name_str), \" (%s)\", curbox->box_name);\n\t\t}\n\t\telse {\n\t\t\tname_str[0] = '\\0';\n\t\t}\n\n\t\tif(curbox->is_uuid) {\n\t\t\tfmtutil_render_uuid(c, curbox->uuid, uuid_string, sizeof(uuid_string));\n\t\t\tde_dbg(c, \"box '%s'{%s}%s at %\"I64_FMT\", len=%\"I64_FMT,\n\t\t\t\tbox4cc.id_dbgstr, uuid_string, name_str,\n\t\t\t\tpos, total_len);\n\t\t}\n\t\telse {\n\t\t\tde_dbg(c, \"box '%s'%s at %\"I64_FMT\", len=%\"I64_FMT\", dlen=%\"I64_FMT,\n\t\t\t\tbox4cc.id_dbgstr, name_str, pos,\n\t\t\t\ttotal_len, payload_len);\n\t\t}\n\t}\n\n\tif(total_len > len) {\n\t\tde_err(c, \"Invalid oversized box, or unexpected end of file \"\n\t\t\t\"(box at %\"I64_FMT\" ends at %\"I64_FMT\", \"\n\t\t\t\"parent ends at %\"I64_FMT\")\",\n\t\t\tpos, pos+total_len, pos+len);\n\t\tgoto done;\n\t}\n\n\tde_dbg_indent(c, 1);\n\tret = bctx->handle_box_fn(c, bctx);\n\tde_dbg_indent(c, -1);\n\tif(!ret) goto done;\n\n\tif(curbox->is_superbox) {\n\t\ti64 children_pos, children_len;\n\t\ti64 max_nchildren;\n\n\t\tde_dbg_indent(c, 1);\n\t\tchildren_pos = curbox->payload_pos + curbox->extra_bytes_before_children;\n\t\tchildren_len = curbox->payload_len - curbox->extra_bytes_before_children;\n\t\tmax_nchildren = (curbox->num_children_is_known) ? curbox->num_children : -1;\n\t\tdo_box_sequence(c, bctx, children_pos, children_len, max_nchildren, level+1);\n\t\tde_dbg_indent(c, -1);\n\t}\n\n\t*pbytes_consumed = total_len;\n\tretval = 1;\n\ndone:\n\tde_free(c, bctx->curbox);\n\tbctx->curbox = parentbox; // Restore the curbox pointer\n\treturn retval;\n}\n\n// max_nboxes: -1 = no maximum\nstatic void do_box_sequence(deark *c, struct de_boxesctx *bctx,\n\ti64 pos1, i64 len, i64 max_nboxes, int level)\n{\n\ti64 pos;\n\ti64 box_len;\n\ti64 endpos;\n\tint ret;\n\ti64 box_count = 0;\n\n\tif(level >= 32) { // An arbitrary recursion limit.\n\t\treturn;\n\t}\n\n\tpos = pos1;\n\tendpos = pos1 + len;\n\n\twhile(pos < endpos) {\n\t\tif(max_nboxes>=0 && box_count>=max_nboxes) break;\n\t\tret = do_box(c, bctx, pos, endpos-pos, level, &box_len);\n\t\tif(!ret) break;\n\t\tbox_count++;\n\t\tpos += box_len;\n\t}\n}\n\n// Handle some box types that might be common to multiple formats.\n// This function should be called as needed by the client's box handler function.\n// TODO: A way to identify (name) the boxes that we handle here.\nint fmtutil_default_box_handler(deark *c, struct de_boxesctx *bctx)\n{\n\tstruct de_boxdata *curbox = bctx->curbox;\n\n\tif(curbox->is_uuid) {\n\t\tif(!de_memcmp(curbox->uuid, \"\\xb1\\x4b\\xf8\\xbd\\x08\\x3d\\x4b\\x43\\xa5\\xae\\x8c\\xd7\\xd5\\xa6\\xce\\x03\", 16)) {\n\t\t\tde_dbg(c, \"GeoTIFF data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tdbuf_create_file_from_slice(bctx->f, curbox->payload_pos, curbox->payload_len, \"geo.tif\", NULL, DE_CREATEFLAG_IS_AUX);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\", 16)) {\n\t\t\tde_dbg(c, \"XMP data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tdbuf_create_file_from_slice(bctx->f, curbox->payload_pos, curbox->payload_len, \"xmp\", NULL, DE_CREATEFLAG_IS_AUX);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\x2c\\x4c\\x01\\x00\\x85\\x04\\x40\\xb9\\xa0\\x3e\\x56\\x21\\x48\\xd6\\xdf\\xeb\", 16)) {\n\t\t\tde_dbg(c, \"Photoshop resources at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, 1);\n\t\t\tfmtutil_handle_photoshop_rsrc(c, bctx->f, curbox->payload_pos, curbox->payload_len, 0x0);\n\t\t\tde_dbg_indent(c, -1);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\x05\\x37\\xcd\\xab\\x9d\\x0c\\x44\\x31\\xa7\\x2a\\xfa\\x56\\x1f\\x2a\\x11\\x3e\", 16) ||\n\t\t\t!de_memcmp(curbox->uuid, \"JpgTiffExif->JP2\", 16))\n\t\t{\n\t\t\tde_dbg(c, \"Exif data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, 1);\n\t\t\tfmtutil_handle_exif(c, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, -1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid fmtutil_read_boxes_format(deark *c, struct de_boxesctx *bctx)\n{\n\tif(!bctx->f || !bctx->handle_box_fn) return; // Internal error\n\tif(bctx->curbox) return; // Internal error\n\tdo_box_sequence(c, bctx, 0, bctx->f->len, -1, 0);\n}\n\nstatic u8 scale_7_to_255(u8 x)\n{\n\treturn (u8)(0.5+(((double)x)*(255.0/7.0)));\n}\n\nstatic u8 scale_15_to_255(u8 x)\n{\n\treturn x*17;\n}\n\nvoid fmtutil_read_atari_palette(deark *c, dbuf *f, i64 pos,\n\tde_color *dstpal, i64 ncolors_to_read, i64 ncolors_used, unsigned int flags)\n{\n\ti64 i;\n\tunsigned int n;\n\tint pal_bits = 0; // 9, 12, or 15. 0 = not yet determined\n\tu8 cr, cg, cb;\n\tu8 cr1, cg1, cb1;\n\tchar cbuf[32];\n\tchar tmps[64];\n\tconst char *s;\n\n\ts = de_get_ext_option(c, \"atari:palbits\");\n\tif(s) {\n\t\tpal_bits = de_atoi(s);\n\t}\n\n\tif(pal_bits==0 && (flags&DE_FLAG_ATARI_15BIT_PAL)) {\n\t\tpal_bits = 15;\n\t}\n\n\tif(pal_bits==0) {\n\t\t// Pre-scan the palette, and try to guess whether Atari STE-style 12-bit\n\t\t// colors are used, instead of the usual 9-bit colors.\n\t\t// I don't know the best way to do this. Sometimes the 4th bit in each\n\t\t// nibble is used for extra color detail, and sometimes it just seems to\n\t\t// contain garbage. Maybe the logic should also depend on the file\n\t\t// format, or the number of colors.\n\t\tint bit_3_used = 0;\n\t\tint nibble_3_used = 0;\n\n\t\tfor(i=0; i<ncolors_to_read; i++) {\n\t\t\tn = (unsigned int)dbuf_getu16be(f, pos + i*2);\n\t\t\tif(n&0xf000) {\n\t\t\t\tnibble_3_used = 1;\n\t\t\t}\n\t\t\tif(n&0x0888) {\n\t\t\t\tbit_3_used = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(bit_3_used && !nibble_3_used) {\n\t\t\tde_dbg(c, \"12-bit palette colors detected\");\n\t\t\tpal_bits = 12;\n\t\t}\n\t}\n\n\tif(pal_bits<12) { // Default to 9 if <12\n\t\tpal_bits = 9;\n\t}\n\telse if(pal_bits<15) {\n\t\tpal_bits = 12;\n\t}\n\telse {\n\t\tpal_bits = 15;\n\t}\n\n\tfor(i=0; i<ncolors_to_read; i++) {\n\t\tn = (unsigned int)dbuf_getu16be(f, pos + 2*i);\n\n\t\tif(pal_bits==15) {\n\t\t\tcr1 = (u8)((n>>6)&0x1c);\n\t\t\tif(n&0x0800) cr1+=2;\n\t\t\tif(n&0x8000) cr1++;\n\t\t\tcg1 = (u8)((n>>2)&0x1c);\n\t\t\tif(n&0x0080) cg1+=2;\n\t\t\tif(n&0x4000) cg1++;\n\t\t\tcb1 = (u8)((n<<2)&0x1c);\n\t\t\tif(n&0x0008) cb1+=2;\n\t\t\tif(n&0x2000) cb1++;\n\t\t\tcr = de_scale_n_to_255(31, cr1);\n\t\t\tcg = de_scale_n_to_255(31, cg1);\n\t\t\tcb = de_scale_n_to_255(31, cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%2d,%2d,%2d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\t\telse if(pal_bits==12) {\n\t\t\tcr1 = (u8)((n>>7)&0x0e);\n\t\t\tif(n&0x800) cr1++;\n\t\t\tcg1 = (u8)((n>>3)&0x0e);\n\t\t\tif(n&0x080) cg1++;\n\t\t\tcb1 = (u8)((n<<1)&0x0e);\n\t\t\tif(n&0x008) cb1++;\n\t\t\tcr = scale_15_to_255(cr1);\n\t\t\tcg = scale_15_to_255(cg1);\n\t\t\tcb = scale_15_to_255(cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%2d,%2d,%2d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\t\telse {\n\t\t\tcr1 = (u8)((n>>8)&0x07);\n\t\t\tcg1 = (u8)((n>>4)&0x07);\n\t\t\tcb1 = (u8)(n&0x07);\n\t\t\tcr = scale_7_to_255(cr1);\n\t\t\tcg = scale_7_to_255(cg1);\n\t\t\tcb = scale_7_to_255(cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%d,%d,%d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\n\t\tdstpal[i] = DE_MAKE_RGB(cr, cg, cb);\n\t\tde_snprintf(tmps, sizeof(tmps), \"0x%04x (%s) \"DE_CHAR_RIGHTARROW\" \", n, cbuf);\n\t\tde_dbg_pal_entry2(c, i, dstpal[i], tmps, NULL,\n\t\t\t(i>=ncolors_used)?\" [unused]\":\"\");\n\t}\n}\n\n/*\n *  Given an x-coordinate and a color index, returns the corresponding\n *  Spectrum palette index.\n *\n *  by Steve Belczyk; placed in the public domain December, 1990.\n *  [Adapted for Deark.]\n */\nstatic unsigned int spectrum512_FindIndex(i64 x, unsigned int c)\n{\n\ti64 x1;\n\n\tx1 = 10 * (i64)c;\n\n\tif (c & 1)  /* If c is odd */\n\t\tx1 = x1 - 5;\n\telse        /* If c is even */\n\t\tx1 = x1 + 1;\n\n\tif (x >= x1 && x < x1+160)\n\t\tc = c + 16;\n\telse if (x >= x1+160)\n\t\tc = c + 32;\n\n\treturn c;\n}\n\nstatic int decode_atari_image_paletted(deark *c, struct atari_img_decode_data *adata)\n{\n\ti64 i, j;\n\ti64 plane;\n\ti64 rowspan;\n\tu8 b;\n\tu32 v;\n\ti64 planespan;\n\ti64 ncolors;\n\n\tplanespan = 2*((adata->w+15)/16);\n\trowspan = planespan*adata->bpp;\n\tif(adata->ncolors>0)\n\t\tncolors = adata->ncolors;\n\telse\n\t\tncolors = ((i64)1)<<adata->bpp;\n\n\tfor(j=0; j<adata->h; j++) {\n\t\tfor(i=0; i<adata->w; i++) {\n\t\t\tv = 0;\n\n\t\t\tfor(plane=0; plane<adata->bpp; plane++) {\n\t\t\t\tif(adata->was_compressed==0) {\n\t\t\t\t\t// TODO: Simplify this.\n\t\t\t\t\tif(adata->bpp==1) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1, j*rowspan, i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==2) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i/16)*2, i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==4) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i/2-(i/2)%16)+8*((i%32)/16), i%16);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==8) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i-i%16), i%16);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1, j*rowspan + plane*planespan, i);\n\t\t\t\t}\n\t\t\t\tif(b) v |= 1<<plane;\n\t\t\t}\n\n\t\t\tif(adata->is_spectrum512) {\n\t\t\t\tv = spectrum512_FindIndex(i, v);\n\t\t\t\tif(j>0) {\n\t\t\t\t\tv += (unsigned int)(48*(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v>=(unsigned int)ncolors) v=(unsigned int)(ncolors-1);\n\n\t\t\tde_bitmap_setpixel_rgb(adata->img, i, j, adata->pal[v]);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int decode_atari_image_16(deark *c, struct atari_img_decode_data *adata)\n{\n\ti64 i, j;\n\ti64 rowspan;\n\tu32 v;\n\n\trowspan = adata->w * 2;\n\n\tfor(j=0; j<adata->h; j++) {\n\t\tfor(i=0; i<adata->w; i++) {\n\t\t\tv = (u32)dbuf_getu16be(adata->unc_pixels, j*rowspan + 2*i);\n\t\t\tv = de_rgb565_to_888(v);\n\t\t\tde_bitmap_setpixel_rgb(adata->img, i, j,v);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint fmtutil_atari_decode_image(deark *c, struct atari_img_decode_data *adata)\n{\n\tswitch(adata->bpp) {\n\tcase 16:\n\t\treturn decode_atari_image_16(c, adata);\n\tcase 8: case 4: case 2: case 1:\n\t\treturn decode_atari_image_paletted(c, adata);\n\t}\n\n\tde_err(c, \"Unsupported bits/pixel (%d)\", (int)adata->bpp);\n\treturn 0;\n}\n\nvoid fmtutil_atari_set_standard_density(deark *c, struct atari_img_decode_data *adata,\n\tde_finfo *fi)\n{\n\tswitch(adata->bpp) {\n\tcase 4:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 240.0;\n\t\tfi->density.ydens = 200.0;\n\t\tbreak;\n\tcase 2:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 480.0;\n\t\tfi->density.ydens = 200.0;\n\t\tbreak;\n\tcase 1:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 480.0;\n\t\tfi->density.ydens = 400.0;\n\t\tbreak;\n\t}\n}\n\nvoid fmtutil_atari_help_palbits(deark *c)\n{\n\tde_msg(c, \"-opt atari:palbits=<9|12|15> : Numer of significant bits \"\n\t\t\"per palette color\");\n}\n\n#define CODE__c_   0x28632920U // \"(c) \"\n#define CODE_ANNO  0x414e4e4fU\n#define CODE_AUTH  0x41555448U\n#define CODE_NAME  0x4e414d45U\n#define CODE_TEXT  0x54455854U\n#define CODE_RIFF  0x52494646U\n\nstatic void do_iff_text_chunk(deark *c, struct de_iffctx *ictx, i64 dpos, i64 dlen,\n\tconst char *name)\n{\n\tde_ucstring *s = NULL;\n\n\tif(dlen<1) return;\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring_n(ictx->f,\n\t\tdpos, dlen, DE_DBG_MAX_STRLEN,\n\t\ts, DE_CONVFLAG_STOP_AT_NUL, ictx->input_encoding);\n\tde_dbg(c, \"%s: \\\"%s\\\"\", name, ucstring_getpsz(s));\n\tucstring_destroy(s);\n}\n\nstatic void do_iff_anno(deark *c, struct de_iffctx *ictx, i64 pos, i64 len)\n{\n\ti64 foundpos;\n\n\tif(len<1) return;\n\n\t// Some ANNO chunks seem to be padded with one or more NUL bytes. Probably\n\t// best not to save them.\n\tif(dbuf_search_byte(ictx->f, 0x00, pos, len, &foundpos)) {\n\t\tlen = foundpos - pos;\n\t}\n\tif(len<1) return;\n\tif(c->extract_level>=2) {\n\t\tdbuf_create_file_from_slice(ictx->f, pos, len, \"anno.txt\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse {\n\t\tde_ucstring *s = NULL;\n\t\ts = ucstring_create(c);\n\t\tdbuf_read_to_ucstring_n(ictx->f, pos, len, DE_DBG_MAX_STRLEN, s, 0, ictx->input_encoding);\n\t\tde_dbg(c, \"annotation: \\\"%s\\\"\", ucstring_getpsz(s));\n\t\tucstring_destroy(s);\n\t}\n}\n\nvoid fmtutil_default_iff_chunk_identify(deark *c, struct de_iffctx *ictx)\n{\n\tconst char *name = NULL;\n\n\tswitch(ictx->chunkctx->chunk4cc.id) {\n\tcase CODE__c_ : name=\"copyright\"; break;\n\tcase CODE_ANNO: name=\"annotation\"; break;\n\tcase CODE_AUTH: name=\"author\"; break;\n\t}\n\n\tif(name) {\n\t\tictx->chunkctx->chunk_name = name;\n\t}\n}\n\n// Note that some of these chunks are *not* defined in the generic IFF\n// specification.\n// They might be defined in the 8SVX specification. They seem to have\n// become unofficial standard chunks.\nstatic int de_fmtutil_default_iff_chunk_handler(deark *c, struct de_iffctx *ictx)\n{\n\ti64 dpos = ictx->chunkctx->dpos;\n\ti64 dlen = ictx->chunkctx->dlen;\n\tu32 chunktype = ictx->chunkctx->chunk4cc.id;\n\n\tswitch(chunktype) {\n\t\t// Note that chunks appearing here should also be listed below,\n\t\t// in de_fmtutil_is_standard_iff_chunk().\n\tcase CODE__c_:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"copyright\");\n\t\tbreak;\n\tcase CODE_ANNO:\n\t\tdo_iff_anno(c, ictx, dpos, dlen);\n\t\tbreak;\n\tcase CODE_AUTH:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"author\");\n\t\tbreak;\n\tcase CODE_NAME:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"name\");\n\t\tbreak;\n\tcase CODE_TEXT:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"text\");\n\t\tbreak;\n\t}\n\n\t// Note we do not set ictx->handled. The caller is responsible for that.\n\treturn 1;\n}\n\n// ictx can be NULL\nint fmtutil_is_standard_iff_chunk(deark *c, struct de_iffctx *ictx,\n\tu32 ct)\n{\n\tswitch(ct) {\n\tcase CODE__c_:\n\tcase CODE_ANNO:\n\tcase CODE_AUTH:\n\tcase CODE_NAME:\n\tcase CODE_TEXT:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void fourcc_clear(struct de_fourcc *fourcc)\n{\n\tde_zeromem(fourcc, sizeof(struct de_fourcc));\n}\n\nstatic int do_iff_chunk_sequence(deark *c, struct de_iffctx *ictx,\n\ti64 pos1, i64 len, int level);\n\n// Returns 0 if we can't continue\nstatic int do_iff_chunk(deark *c, struct de_iffctx *ictx, i64 pos, i64 bytes_avail,\n\tint level, i64 *pbytes_consumed)\n{\n\tint ret;\n\ti64 chunk_dlen_raw;\n\ti64 chunk_dlen_padded;\n\ti64 data_bytes_avail;\n\ti64 hdrsize;\n\tstruct de_iffchunkctx chunkctx;\n\tint saved_indent_level;\n\tint retval = 0;\n\tchar name_str[80];\n\n\tde_zeromem(&chunkctx, sizeof(struct de_iffchunkctx));\n\n\tde_dbg_indent_save(c, &saved_indent_level);\n\n\thdrsize = 4+ictx->sizeof_len;\n\tif(bytes_avail<hdrsize) {\n\t\tde_warn(c, \"Ignoring %\"I64_FMT\" bytes at %\"I64_FMT\"; too small \"\n\t\t\t\"to be a chunk\", bytes_avail, pos);\n\t\tgoto done;\n\t}\n\tdata_bytes_avail = bytes_avail-hdrsize;\n\n\tdbuf_read_fourcc(ictx->f, pos, &chunkctx.chunk4cc, 4,\n\t\tictx->reversed_4cc ? DE_4CCFLAG_REVERSED : 0x0);\n\tif(chunkctx.chunk4cc.id==0 && level==0) {\n\t\tde_warn(c, \"Chunk ID not found at %\"I64_FMT\"; assuming the data ends \"\n\t\t\t\"here\", pos);\n\t\tgoto done;\n\t}\n\n\tif(ictx->sizeof_len==2) {\n\t\tchunk_dlen_raw = dbuf_getu16x(ictx->f, pos+4, ictx->is_le);\n\t}\n\telse {\n\t\tchunk_dlen_raw = dbuf_getu32x(ictx->f, pos+4, ictx->is_le);\n\t}\n\tchunkctx.dlen = chunk_dlen_raw;\n\tchunkctx.dpos = pos+hdrsize;\n\n\t// TODO: Setting these fields (prior to the identify function) is enough\n\t// for now, but we should also set the other fields here if we can.\n\tictx->level = level;\n\tictx->chunkctx = &chunkctx;\n\n\tif(ictx->preprocess_chunk_fn) {\n\t\tictx->preprocess_chunk_fn(c, ictx);\n\t}\n\n\tif(chunkctx.chunk_name) {\n\t\tde_snprintf(name_str, sizeof(name_str), \" (%s)\", chunkctx.chunk_name);\n\t}\n\telse {\n\t\tname_str[0] = '\\0';\n\t}\n\n\tde_dbg(c, \"chunk '%s'%s at %\"I64_FMT\", dpos=%\"I64_FMT\", dlen=%\"I64_FMT,\n\t\tchunkctx.chunk4cc.id_dbgstr, name_str, pos,\n\t\tchunkctx.dpos, chunkctx.dlen);\n\tde_dbg_indent(c, 1);\n\n\tif(chunkctx.dlen > data_bytes_avail) {\n\t\tint should_warn = 1;\n\n\t\tif(chunkctx.chunk4cc.id==CODE_RIFF && pos==0 && bytes_avail==ictx->f->len) {\n\t\t\t// Hack:\n\t\t\t// This apparent error, in which the RIFF chunk's length field gives the\n\t\t\t// length of the entire file, is too common (particularly in .ani files)\n\t\t\t// to warn about.\n\t\t\tshould_warn = 0;\n\t\t}\n\n\t\tif(should_warn) {\n\t\t\tde_warn(c, \"Invalid oversized chunk, or unexpected end of file \"\n\t\t\t\t\"(chunk at %d ends at %\" I64_FMT \", \"\n\t\t\t\t\"parent ends at %\" I64_FMT \")\",\n\t\t\t\t(int)pos, chunkctx.dlen+chunkctx.dpos, pos+bytes_avail);\n\t\t}\n\n\t\tchunkctx.dlen = data_bytes_avail; // Try to continue\n\t\tde_dbg(c, \"adjusting chunk data len to %\"I64_FMT, chunkctx.dlen);\n\t}\n\n\tchunk_dlen_padded = de_pad_to_n(chunkctx.dlen, ictx->alignment);\n\t*pbytes_consumed = hdrsize + chunk_dlen_padded;\n\n\t// We've set *pbytes_consumed, so we can return \"success\"\n\tretval = 1;\n\n\t// Set ictx fields, prior to calling the handler\n\tchunkctx.pos = pos;\n\tchunkctx.len = bytes_avail;\n\tictx->handled = 0;\n\tictx->is_std_container = 0;\n\tictx->is_raw_container = 0;\n\n\tret = ictx->handle_chunk_fn(c, ictx);\n\tif(!ret) {\n\t\tretval = 0;\n\t\tgoto done;\n\t}\n\n\tif(ictx->is_std_container || ictx->is_raw_container) {\n\t\ti64 contents_dpos, contents_dlen;\n\n\t\tictx->chunkctx = NULL;\n\t\tictx->curr_container_fmt4cc = chunkctx.chunk4cc;\n\t\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\n\t\tif(ictx->is_std_container) {\n\t\t\tcontents_dpos = chunkctx.dpos+4;\n\t\t\tcontents_dlen = chunkctx.dlen-4;\n\n\t\t\t// First 4 bytes of payload are the \"contents type\" or \"FORM type\"\n\t\t\tdbuf_read_fourcc(ictx->f, chunkctx.dpos, &ictx->curr_container_contentstype4cc, 4,\n\t\t\t\tictx->reversed_4cc ? DE_4CCFLAG_REVERSED : 0);\n\n\t\t\tif(level==0) {\n\t\t\t\tictx->main_fmt4cc = ictx->curr_container_fmt4cc;\n\t\t\t\tictx->main_contentstype4cc = ictx->curr_container_contentstype4cc; // struct copy\n\t\t\t}\n\t\t\tde_dbg(c, \"contents type: '%s'\", ictx->curr_container_contentstype4cc.id_dbgstr);\n\n\t\t\tif(ictx->on_std_container_start_fn) {\n\t\t\t\t// Call only for standard-format containers.\n\t\t\t\tret = ictx->on_std_container_start_fn(c, ictx);\n\t\t\t\tif(!ret) goto done;\n\t\t\t}\n\t\t}\n\t\telse { // ictx->is_raw_container\n\t\t\tcontents_dpos = chunkctx.dpos;\n\t\t\tcontents_dlen = chunkctx.dlen;\n\t\t}\n\n\t\tret = do_iff_chunk_sequence(c, ictx, contents_dpos, contents_dlen, level+1);\n\t\tif(!ret) {\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif(ictx->on_container_end_fn) {\n\t\t\t// Call for all containers (not just standard-format containers).\n\n\t\t\t// TODO: Decide exactly what ictx->* fields to set here.\n\t\t\tictx->level = level;\n\n\t\t\tictx->chunkctx = NULL;\n\t\t\tret = ictx->on_container_end_fn(c, ictx);\n\t\t\tif(!ret) {\n\t\t\t\tretval = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(!ictx->handled) {\n\t\tde_fmtutil_default_iff_chunk_handler(c, ictx);\n\t}\n\ndone:\n\tfourcc_clear(&ictx->curr_container_fmt4cc);\n\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\n\tde_dbg_indent_restore(c, saved_indent_level);\n\treturn retval;\n}\n\nstatic int do_iff_chunk_sequence(deark *c, struct de_iffctx *ictx,\n\ti64 pos1, i64 len, int level)\n{\n\ti64 pos;\n\ti64 endpos;\n\ti64 chunk_len;\n\tstruct de_fourcc saved_container_fmt4cc;\n\tstruct de_fourcc saved_container_contentstype4cc;\n\tint ret;\n\n\tif(level >= 16) { // An arbitrary recursion limit.\n\t\treturn 0;\n\t}\n\n\tendpos = pos1+len;\n\tsaved_container_fmt4cc = ictx->curr_container_fmt4cc;\n\tsaved_container_contentstype4cc = ictx->curr_container_contentstype4cc;\n\n\tpos = pos1;\n\twhile(pos < endpos) {\n\t\tictx->curr_container_fmt4cc = saved_container_fmt4cc;\n\t\tictx->curr_container_contentstype4cc = saved_container_contentstype4cc;\n\n\t\tif(ictx->handle_nonchunk_data_fn) {\n\t\t\ti64 skip_len = 0;\n\t\t\tret = ictx->handle_nonchunk_data_fn(c, ictx, pos, &skip_len);\n\t\t\tif(ret && skip_len>0) {\n\t\t\t\tpos += de_pad_to_n(skip_len, ictx->alignment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = do_iff_chunk(c, ictx, pos, endpos-pos, level, &chunk_len);\n\t\tif(!ret) return 0;\n\t\tpos += chunk_len;\n\t}\n\n\tictx->curr_container_fmt4cc = saved_container_fmt4cc;\n\tictx->curr_container_contentstype4cc = saved_container_contentstype4cc;\n\n\treturn 1;\n}\n\nvoid fmtutil_read_iff_format(deark *c, struct de_iffctx *ictx,\n\ti64 pos, i64 len)\n{\n\tif(!ictx->f || !ictx->handle_chunk_fn) return; // Internal error\n\n\tictx->level = 0;\n\tfourcc_clear(&ictx->main_fmt4cc);\n\tfourcc_clear(&ictx->main_contentstype4cc);\n\tfourcc_clear(&ictx->curr_container_fmt4cc);\n\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\tif(ictx->alignment==0) {\n\t\tictx->alignment = 2;\n\t}\n\tif(ictx->sizeof_len==0) {\n\t\tictx->sizeof_len = 4;\n\t}\n\n\tif(ictx->input_encoding==DE_ENCODING_UNKNOWN) {\n\t\tictx->input_encoding = DE_ENCODING_ASCII;\n\t}\n\n\tdo_iff_chunk_sequence(c, ictx, pos, len, 0);\n}\n\nconst char *fmtutil_tiff_orientation_name(i64 n)\n{\n\tstatic const char *names[9] = {\n\t\t\"?\", \"top-left\", \"top-right\", \"bottom-right\", \"bottom-left\",\n\t\t\"left-top\", \"right-top\", \"right-bottom\", \"left-bottom\"\n\t};\n\tif(n>=1 && n<=8) return names[n];\n\treturn names[0];\n}\n\nconst char *fmtutil_get_windows_charset_name(u8 cs)\n{\n\tstruct csname_struct { u8 id; const char *name; };\n\tstatic const struct csname_struct csname_arr[] = {\n\t\t{0x00, \"ANSI\"},\n\t\t{0x01, \"default\"},\n\t\t{0x02, \"symbol\"},\n\t\t{0x4d, \"Mac\"},\n\t\t{0x80, \"Shift-JIS\"},\n\t\t{0x81, \"Hangul\"},\n\t\t{0x82, \"Johab\"},\n\t\t{0x86, \"GB2312\"},\n\t\t{0x88, \"BIG5\"},\n\t\t{0xa1, \"Greek\"},\n\t\t{0xa2, \"Turkish\"},\n\t\t{0xa3, \"Vietnamese\"},\n\t\t{0xb1, \"Hebrew\"},\n\t\t{0xb2, \"Arabic\"},\n\t\t{0xba, \"Baltic\"},\n\t\t{0xcc, \"Russian\"},\n\t\t{0xde, \"Thai\"},\n\t\t{0xee, \"Eastern Europe\"},\n\t\t{0xff, \"OEM\"}\n\t};\n\tsize_t i;\n\n\tfor(i=0; i<DE_ARRAYCOUNT(csname_arr); i++) {\n\t\tif(cs==csname_arr[i].id) return csname_arr[i].name;\n\t}\n\treturn \"?\";\n}\n\nconst char *fmtutil_get_windows_cb_data_type_name(unsigned int ty)\n{\n\tconst char *name = \"?\";\n\n\tswitch(ty) {\n\tcase 1: name=\"CF_TEXT\"; break;\n\tcase 2: name=\"CF_BITMAP\"; break;\n\tcase 3: name=\"CF_METAFILEPICT\"; break;\n\tcase 6: name=\"CF_TIFF\"; break;\n\tcase 7: name=\"CF_OEMTEXT\"; break;\n\tcase 8: name=\"CF_DIB\"; break;\n\tcase 11: name=\"CF_RIFF\"; break;\n\tcase 12: name=\"CF_WAVE\"; break;\n\tcase 13: name=\"CF_UNICODETEXT\"; break;\n\tcase 14: name=\"CF_ENHMETAFILE\"; break;\n\tcase 17: name=\"CF_DIBV5\"; break;\n\t}\n\treturn name;\n}\n\n// Search for the ZIP \"end of central directory\" object.\n// Also useful for detecting hybrid ZIP files, such as self-extracting EXE.\nint fmtutil_find_zip_eocd(deark *c, dbuf *f, i64 *foundpos)\n{\n\tu32 sig;\n\tu8 *buf = NULL;\n\tint retval = 0;\n\ti64 buf_offset;\n\ti64 buf_size;\n\ti64 i;\n\n\t*foundpos = 0;\n\tif(f->len < 22) goto done;\n\n\t// End-of-central-dir record usually starts 22 bytes from EOF. Try that first.\n\tsig = (u32)dbuf_getu32le(f, f->len - 22);\n\tif(sig == 0x06054b50U) {\n\t\t*foundpos = f->len - 22;\n\t\tretval = 1;\n\t\tgoto done;\n\t}\n\n\t// Search for the signature.\n\t// The end-of-central-directory record could theoretically appear anywhere\n\t// in the file. We'll follow Info-Zip/UnZip's lead and search the last 66000\n\t// bytes.\n#define MAX_ZIP_EOCD_SEARCH 66000\n\tbuf_size = f->len;\n\tif(buf_size > MAX_ZIP_EOCD_SEARCH) buf_size = MAX_ZIP_EOCD_SEARCH;\n\n\tbuf = de_malloc(c, buf_size);\n\tbuf_offset = f->len - buf_size;\n\tdbuf_read(f, buf, buf_offset, buf_size);\n\n\tfor(i=buf_size-22; i>=0; i--) {\n\t\tif(buf[i]=='P' && buf[i+1]=='K' && buf[i+2]==5 && buf[i+3]==6) {\n\t\t\t*foundpos = buf_offset + i;\n\t\t\tretval = 1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tde_free(c, buf);\n\treturn retval;\n}\n\n// Quick & dirty encoder that can wrap some formats in a TIFF container.\nstatic void wrap_in_tiff(deark *c, dbuf *f, i64 dpos, i64 dlen,\n\tconst char *swstring, unsigned int tag, const char *ext, unsigned int createflags)\n{\n\tdbuf *outf = NULL;\n\ti64 ifdoffs;\n\ti64 sw_len, sw_len_padded;\n\ti64 data_len_padded;\n\n\tsw_len = 1+(i64)de_strlen(swstring);\n\tif(sw_len<=4) return;\n\tsw_len_padded = de_pad_to_2(sw_len);\n\n\tif(dlen>4) {\n\t\tdata_len_padded = de_pad_to_2(dlen);\n\t}\n\telse {\n\t\tdata_len_padded = 0;\n\t}\n\n\toutf = dbuf_create_output_file(c, ext, NULL, 0);\n\tdbuf_write(outf, (const u8*)\"\\x4d\\x4d\\x00\\x2a\", 4);\n\tifdoffs = 8 + sw_len_padded + data_len_padded;\n\tdbuf_writeu32be(outf, ifdoffs);\n\tdbuf_write(outf, (const u8*)swstring, sw_len);\n\tif(sw_len%2) dbuf_writebyte(outf, 0);\n\tif(dlen>4) {\n\t\tdbuf_copy(f, dpos, dlen, outf);\n\t\tif(dlen%2) dbuf_writebyte(outf, 0);\n\t}\n\n\tdbuf_writeu16be(outf, 2); // number of dir entries;\n\n\tdbuf_writeu16be(outf, 305); // Software tag\n\tdbuf_writeu16be(outf, 2); // type=ASCII\n\tdbuf_writeu32be(outf, sw_len);\n\tdbuf_writeu32be(outf, 8); // offset\n\n\tdbuf_writeu16be(outf, (i64)tag);\n\tdbuf_writeu16be(outf, 1);\n\tdbuf_writeu32be(outf, dlen);\n\tif(dlen>4) {\n\t\tdbuf_writeu32be(outf, 8+sw_len_padded);\n\t}\n\telse {\n\t\tdbuf_copy(f, dpos, dlen, outf);\n\t\tdbuf_write_zeroes(outf, 4-dlen);\n\t}\n\n\tdbuf_writeu32be(outf, 0); // end of IFD\n\tdbuf_close(outf);\n}\n\n// Find ID3 tag data at the beginning and end of file, process it, and return\n// information about its location.\n// Caller allocates id3i.\nvoid fmtutil_handle_id3(deark *c, dbuf *f, struct de_id3info *id3i,\n\tunsigned int flags)\n{\n\ti64 id3v1pos = 0;\n\tint look_for_id3v1;\n\n\tde_zeromem(id3i, sizeof(struct de_id3info));\n\tid3i->main_start = 0;\n\tid3i->main_end = f->len;\n\n\tid3i->has_id3v2 = !dbuf_memcmp(f, 0, \"ID3\", 3);\n\tif(id3i->has_id3v2) {\n\t\tde_module_params id3v2mparams;\n\n\t\tde_dbg(c, \"ID3v2 data at %d\", 0);\n\t\tde_dbg_indent(c, 1);\n\t\tde_zeromem(&id3v2mparams, sizeof(de_module_params));\n\t\tid3v2mparams.in_params.codes = \"I\";\n\t\tde_run_module_by_id_on_slice(c, \"id3\", &id3v2mparams, f, 0, f->len);\n\t\tde_dbg_indent(c, -1);\n\t\tid3i->main_start += id3v2mparams.out_params.int64_1;\n\t}\n\n\tlook_for_id3v1 = 1;\n\tif(look_for_id3v1) {\n\t\tid3v1pos = f->len-128;\n\t\tif(!dbuf_memcmp(f, id3v1pos, \"TAG\", 3)) {\n\t\t\tid3i->has_id3v1 = 1;\n\t\t}\n\t}\n\n\tif(id3i->has_id3v1) {\n\t\tde_module_params id3v1mparams;\n\n\t\tde_dbg(c, \"ID3v1 data at %\"I64_FMT, id3v1pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_zeromem(&id3v1mparams, sizeof(de_module_params));\n\t\tid3v1mparams.in_params.codes = \"1\";\n\t\tde_run_module_by_id_on_slice(c, \"id3\", &id3v1mparams, f, id3v1pos, 128);\n\t\tde_dbg_indent(c, -1);\n\t\tid3i->main_end = id3v1pos;\n\t}\n}\n\nstatic void dbg_timestamp(deark *c, struct de_timestamp *ts, const char *name)\n{\n\tchar timestamp_buf[64];\n\n\tde_timestamp_to_string(ts, timestamp_buf, sizeof(timestamp_buf), 0);\n\tde_dbg(c, \"%s: %s\", name, timestamp_buf);\n}\n\nvoid fmtutil_riscos_read_load_exec(deark *c, dbuf *f, struct de_riscos_file_attrs *rfa, i64 pos1)\n{\n\ti64 pos = pos1;\n\n\trfa->load_addr = (u32)dbuf_getu32le_p(f, &pos);\n\trfa->exec_addr = (u32)dbuf_getu32le_p(f, &pos);\n\tde_dbg(c, \"load/exec addrs: 0x%08x, 0x%08x\", (unsigned int)rfa->load_addr,\n\t\t(unsigned int)rfa->exec_addr);\n\tde_dbg_indent(c, 1);\n\tif((rfa->load_addr&0xfff00000U)==0xfff00000U) {\n\t\trfa->file_type = (unsigned int)((rfa->load_addr&0xfff00)>>8);\n\t\trfa->file_type_known = 1;\n\t\tde_dbg(c, \"file type: %03X\", rfa->file_type);\n\n\t\tde_riscos_loadexec_to_timestamp(rfa->load_addr, rfa->exec_addr, &rfa->mod_time);\n\t\tdbg_timestamp(c, &rfa->mod_time, \"timestamp\");\n\t}\n\tde_dbg_indent(c, -1);\n}\n\nvoid fmtutil_riscos_read_attribs_field(deark *c, dbuf *f, struct de_riscos_file_attrs *rfa,\n\ti64 pos, unsigned int flags)\n{\n\trfa->attribs = (u32)dbuf_getu32le(f, pos);\n\tde_dbg(c, \"attribs: 0x%08x\", (unsigned int)rfa->attribs);\n\tde_dbg_indent(c, 1);\n\trfa->crc_from_attribs = rfa->attribs>>16;\n\tif(flags & DE_RISCOS_FLAG_HAS_CRC) {\n\t\tde_dbg(c, \"crc (reported): 0x%04x\", (unsigned int)rfa->crc_from_attribs);\n\t}\n\tif(flags & DE_RISCOS_FLAG_HAS_LZWMAXBITS) {\n\t\trfa->lzwmaxbits = (unsigned int)((rfa->attribs&0xff00)>>8);\n\t\tde_dbg(c, \"lzw maxbits: %u\", rfa->lzwmaxbits);\n\t}\n\tde_dbg_indent(c, -1);\n}\n\nstruct pict_rect {\n\ti64 t, l, b, r;\n};\n\n// Note: Code duplicated in pict.c\nstatic double pict_read_fixed(dbuf *f, i64 pos)\n{\n\ti64 n;\n\n\t// I think QuickDraw's \"Fixed point\" numbers are signed, but I don't know\n\t// how negative numbers are handled.\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\n// Read a QuickDraw Rectangle. Caller supplies rect struct.\n// Note: Code duplicated in pict.c\nstatic void pict_read_rect(dbuf *f, i64 pos,\n\tstruct pict_rect *rect, const char *dbgname)\n{\n\trect->t = dbuf_geti16be(f, pos);\n\trect->l = dbuf_geti16be(f, pos+2);\n\trect->b = dbuf_geti16be(f, pos+4);\n\trect->r = dbuf_geti16be(f, pos+6);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)-(%d,%d)\", dbgname, (int)rect->l, (int)rect->t,\n\t\t\t(int)rect->r, (int)rect->b);\n\t}\n}\n\n// Sometimes-present baseAddr field (4 bytes)\nvoid fmtutil_macbitmap_read_baseaddr(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\ti64 n;\n\tde_dbg(c, \"baseAddr part of PixMap, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tn = dbuf_getu32be(f, pos);\n\tde_dbg(c, \"baseAddr: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}\n\nvoid fmtutil_macbitmap_read_rowbytes_and_bounds(deark *c, dbuf *f,\n\tstruct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tstruct pict_rect tmprect;\n\ti64 rowbytes_code;\n\n\tde_dbg(c, \"rowBytes/bounds part of bitmap/PixMap header, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\trowbytes_code = dbuf_getu16be(f, pos);\n\tbi->rowbytes = rowbytes_code & 0x7fff;\n\tbi->pixmap_flag = (rowbytes_code & 0x8000)?1:0;\n\tde_dbg(c, \"rowBytes: %d\", (int)bi->rowbytes);\n\tde_dbg(c, \"pixmap flag: %d\", bi->pixmap_flag);\n\n\tpict_read_rect(f, pos+2, &tmprect, \"rect\");\n\tbi->npwidth = tmprect.r - tmprect.l;\n\tbi->pdwidth = bi->npwidth; // default\n\tbi->height = tmprect.b - tmprect.t;\n\n\tde_dbg_indent(c, -1);\n}\n\n// Pixmap fields that aren't read by read_baseaddr or read_rowbytes_and_bounds\n// (36 bytes)\nvoid fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\n\tde_dbg_indent(c, -1);\n}\n\nint fmtutil_macbitmap_read_colortable(deark *c, dbuf *f,\n\tstruct fmtutil_macbitmap_info *bi, i64 pos, i64 *bytes_used)\n{\n\ti64 ct_id;\n\tu32 ct_flags;\n\ti64 ct_size;\n\ti64 k, z;\n\tu32 s[4];\n\tu8 cr, cg, cb;\n\tu32 clr;\n\tchar tmps[64];\n\n\t*bytes_used = 0;\n\tde_dbg(c, \"color table at %\"I64_FMT, pos);\n\tde_dbg_indent(c, 1);\n\n\tct_id = dbuf_getu32be(f, pos);\n\tct_flags = (u32)dbuf_getu16be(f, pos+4); // a.k.a. transIndex\n\tct_size = dbuf_getu16be(f, pos+6);\n\tbi->num_pal_entries = ct_size+1;\n\tde_dbg(c, \"color table id=0x%08x, flags=0x%04x, colors=%d\", (unsigned int)ct_id,\n\t\t(unsigned int)ct_flags, (int)bi->num_pal_entries);\n\n\tfor(k=0; k<bi->num_pal_entries; k++) {\n\t\tfor(z=0; z<4; z++) {\n\t\t\ts[z] = (u32)dbuf_getu16be(f, pos+8+8*k+2*z);\n\t\t}\n\t\tcr = (u8)(s[1]>>8);\n\t\tcg = (u8)(s[2]>>8);\n\t\tcb = (u8)(s[3]>>8);\n\t\tclr = DE_MAKE_RGB(cr,cg,cb);\n\t\tde_snprintf(tmps, sizeof(tmps), \"(%5d,%5d,%5d,idx=%3d) \"DE_CHAR_RIGHTARROW\" \",\n\t\t\t(int)s[1], (int)s[2], (int)s[3], (int)s[0]);\n\t\tde_dbg_pal_entry2(c, k, clr, tmps, NULL, NULL);\n\n\t\t// Some files don't have the palette indices set. Most PICT decoders ignore\n\t\t// the indices if the \"device\" flag of ct_flags is set, and that seems to\n\t\t// work (though it's not clearly documented).\n\t\tif(ct_flags & 0x8000U) {\n\t\t\ts[0] = (u32)k;\n\t\t}\n\n\t\tif(s[0]<=255) {\n\t\t\tbi->pal[s[0]] = clr;\n\t\t}\n\t}\n\n\tde_dbg_indent(c, -1);\n\t*bytes_used = 8 + 8*bi->num_pal_entries;\n\treturn 1;\n}\n\n// \"compressed unsigned short\" - a variable-length integer format\n// TODO: This is duplicated in shg.c\ni64 fmtutil_hlp_get_cus_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = (i64)dbuf_getbyte_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two.\n\t\treturn x1>>1;\n\t}\n\t// If it's odd, divide by two, and add 128 times the value of\n\t// the next byte.\n\tx2 = (i64)dbuf_getbyte_p(f, ppos);\n\treturn (x1>>1) | (x2<<7);\n}\n\n// \"compressed signed short\"\ni64 fmtutil_hlp_get_css_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = (i64)dbuf_getbyte_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two, and subtract 64\n\t\treturn (x1>>1) - 64;\n\t}\n\t// If it's odd, divide by two, add 128 times the value of\n\t// the next byte, and subtract 16384.\n\tx1 >>= 1;\n\tx2 = (i64)dbuf_getbyte_p(f, ppos);\n\tx1 += x2 * 128;\n\tx1 -= 16384;\n\treturn x1;\n}\n\n// \"compressed unsigned long\"\ni64 fmtutil_hlp_get_cul_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\tx1 = dbuf_getu16le_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two.\n\t\treturn x1>>1;\n\t}\n\t// If it's odd, divide by two, and add 32768 times the value of\n\t// the next two bytes.\n\tx2 = dbuf_getu16le_p(f, ppos);\n\treturn (x1>>1) | (x2<<15);\n}\n\n// \"compressed signed long\"\ni64 fmtutil_hlp_get_csl_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = dbuf_getu16le_p(f, ppos);\n\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two, and subtract 16384\n\t\treturn (x1>>1) - 16384;\n\t}\n\t// If it's odd, divide by two, add 32768 times the value of\n\t// the next two bytes, and subtract 67108864.\n\tx1 >>= 1;\n\tx2 = dbuf_getu16le_p(f, ppos);\n\tx1 += x2*32768;\n\tx1 -= 67108864;\n\treturn x1;\n}\n"], "fixing_code": ["// This file is part of Deark.\n// Copyright (C) 2016 Jason Summers\n// See the file COPYING for terms of use.\n\n// This file is for format-specific functions that are used by multiple modules.\n\n#define DE_NOT_IN_MODULE\n#include \"deark-config.h\"\n#include \"deark-private.h\"\n#include \"deark-fmtutil.h\"\n\nvoid fmtutil_get_bmp_compression_name(u32 code, char *s, size_t s_len,\n\tint is_os2v2)\n{\n\tconst char *name1 = \"?\";\n\tswitch(code) {\n\tcase 0: name1 = \"BI_RGB, uncompressed\"; break;\n\tcase 1: name1 = \"BI_RLE8\"; break;\n\tcase 2: name1 = \"BI_RLE4\"; break;\n\tcase 3:\n\t\tif(is_os2v2)\n\t\t\tname1 = \"Huffman 1D\";\n\t\telse\n\t\t\tname1 = \"BI_BITFIELDS, uncompressed\";\n\t\tbreak;\n\tcase 4:\n\t\tif(is_os2v2)\n\t\t\tname1 = \"RLE24\";\n\t\telse\n\t\t\tname1 = \"BI_JPEG\";\n\t\tbreak;\n\tcase 5: name1 = \"BI_PNG\"; break;\n\t}\n\tde_strlcpy(s, name1, s_len);\n}\n\n// Gathers information about a DIB.\n// If DE_BMPINFO_HAS_FILEHEADER flag is set, pos points to the BITMAPFILEHEADER.\n// Otherwise, it points to the BITMAPINFOHEADER.\n// Caller allocates bi.\n// Returns 0 if BMP is invalid.\nint fmtutil_get_bmpinfo(deark *c, dbuf *f, struct de_bmpinfo *bi, i64 pos,\n\ti64 len, unsigned int flags)\n{\n\ti64 fhs; // file header size\n\ti64 bmih_pos;\n\tstruct de_fourcc cmpr4cc;\n\tchar cmprname_dbgstr[80];\n\n\tde_zeromem(bi, sizeof(struct de_bmpinfo));\n\tde_zeromem(&cmpr4cc, sizeof(struct de_fourcc));\n\n\tfhs = (flags & DE_BMPINFO_HAS_FILEHEADER) ? 14 : 0;\n\n\tif(fhs+len < 16) return 0;\n\n\tif(fhs) {\n\t\tif(flags & DE_BMPINFO_HAS_HOTSPOT) {\n\t\t\tbi->hotspot_x = (int)dbuf_getu16le(f, pos+6);\n\t\t\tbi->hotspot_y = (int)dbuf_getu16le(f, pos+8);\n\t\t\tde_dbg(c, \"hotspot: (%d,%d)\", bi->hotspot_x, bi->hotspot_y);\n\t\t}\n\n\t\tbi->bitsoffset = dbuf_getu32le(f, pos+10);\n\t\tde_dbg(c, \"bits offset: %d\", (int)bi->bitsoffset);\n\t}\n\n\tbmih_pos = pos + fhs;\n\n\tbi->infohdrsize = dbuf_getu32le(f, bmih_pos);\n\n\tif(bi->infohdrsize==0x474e5089 && (flags & DE_BMPINFO_ICO_FORMAT)) {\n\t\t// We don't examine PNG-formatted icons, but we can identify them.\n\t\tbi->infohdrsize = 0;\n\t\tbi->file_format = DE_BMPINFO_FMT_PNG;\n\t\treturn 1;\n\t}\n\n\tde_dbg(c, \"info header size: %d\", (int)bi->infohdrsize);\n\n\tif(bi->infohdrsize==12) {\n\t\tbi->bytes_per_pal_entry = 3;\n\t\tbi->width = dbuf_getu16le(f, bmih_pos+4);\n\t\tbi->height = dbuf_getu16le(f, bmih_pos+6);\n\t\tbi->bitcount = dbuf_getu16le(f, bmih_pos+10);\n\t}\n\telse if(bi->infohdrsize>=16 && bi->infohdrsize<=124) {\n\t\tbi->bytes_per_pal_entry = 4;\n\t\tbi->width = dbuf_getu32le(f, bmih_pos+4);\n\t\tbi->height = dbuf_geti32le(f, bmih_pos+8);\n\t\tif(bi->height<0) {\n\t\t\tbi->is_topdown = 1;\n\t\t\tbi->height = -bi->height;\n\t\t}\n\t\tbi->bitcount = dbuf_getu16le(f, bmih_pos+14);\n\t\tif(bi->infohdrsize>=20) {\n\t\t\tbi->compression_field = (u32)dbuf_getu32le(f, bmih_pos+16);\n\t\t\tif(flags & DE_BMPINFO_CMPR_IS_4CC) {\n\t\t\t\tdbuf_read_fourcc(f, bmih_pos+16, &cmpr4cc, 4, 0x0);\n\t\t\t}\n\t\t}\n\t\tif(bi->infohdrsize>=24) {\n\t\t\tbi->sizeImage_field = dbuf_getu32le(f, bmih_pos+20);\n\t\t}\n\t\tif(bi->infohdrsize>=36) {\n\t\t\tbi->pal_entries = dbuf_getu32le(f, bmih_pos+32);\n\t\t}\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\tif(flags & DE_BMPINFO_ICO_FORMAT) bi->height /= 2;\n\n\tif(bi->bitcount>=1 && bi->bitcount<=8) {\n\t\tif(bi->pal_entries==0) {\n\t\t\tbi->pal_entries = de_pow2(bi->bitcount);\n\t\t}\n\t\t// I think the NumColors field (in icons) is supposed to be the maximum number of\n\t\t// colors implied by the bit depth, not the number of colors in the palette.\n\t\tbi->num_colors = de_pow2(bi->bitcount);\n\t}\n\telse {\n\t\t// An arbitrary value. All that matters is that it's >=256.\n\t\tbi->num_colors = 16777216;\n\t}\n\n\tde_dbg_dimensions(c, bi->width, bi->height);\n\tde_dbg(c, \"bit count: %d\", (int)bi->bitcount);\n\n\tif((flags & DE_BMPINFO_CMPR_IS_4CC) && (bi->compression_field>0xffff)) {\n\t\tde_snprintf(cmprname_dbgstr, sizeof(cmprname_dbgstr), \"'%s'\", cmpr4cc.id_dbgstr);\n\t}\n\telse {\n\t\tfmtutil_get_bmp_compression_name(bi->compression_field,\n\t\t\tcmprname_dbgstr, sizeof(cmprname_dbgstr), 0);\n\t}\n\tde_dbg(c, \"compression: %u (%s)\", (unsigned int)bi->compression_field, cmprname_dbgstr);\n\n\tif(bi->sizeImage_field!=0) {\n\t\tde_dbg(c, \"sizeImage: %u\", (unsigned int)bi->sizeImage_field);\n\t}\n\n\tde_dbg(c, \"palette entries: %u\", (unsigned int)bi->pal_entries);\n\tif(bi->pal_entries>256 && bi->bitcount>8) {\n\t\tde_warn(c, \"Ignoring bad palette size (%u entries)\", (unsigned int)bi->pal_entries);\n\t\tbi->pal_entries = 0;\n\t}\n\n\tbi->pal_bytes = bi->bytes_per_pal_entry*bi->pal_entries;\n\tbi->size_of_headers_and_pal = fhs + bi->infohdrsize + bi->pal_bytes;\n\n\t// FIXME: cmpr type 3 doesn't always mean BITFIELDS\n\tif(bi->compression_field==3) {\n\t\tbi->size_of_headers_and_pal += 12; // BITFIELDS\n\t}\n\n\tbi->is_compressed = !((bi->compression_field==0) ||\n\t\t(bi->compression_field==3 && bi->bitcount>1));\n\n\tif(!de_good_image_dimensions(c, bi->width, bi->height)) {\n\t\treturn 0;\n\t}\n\n\t// TODO: This needs work, to decide how to handle compressed images.\n\t// TODO: What about BI_BITFIELDS images?\n\tif(bi->compression_field==0) {\n\t\t// Try to figure out the true size of the resource, minus any padding.\n\n\t\tbi->rowspan = ((bi->bitcount*bi->width +31)/32)*4;\n\t\tbi->foreground_size = bi->rowspan * bi->height;\n\t\tde_dbg(c, \"foreground size: %d\", (int)bi->foreground_size);\n\n\t\tif(flags & DE_BMPINFO_ICO_FORMAT) {\n\t\t\tbi->mask_rowspan = ((bi->width +31)/32)*4;\n\t\t\tbi->mask_size = bi->mask_rowspan * bi->height;\n\t\t\tde_dbg(c, \"mask size: %d\", (int)bi->mask_size);\n\t\t}\n\t\telse {\n\t\t\tbi->mask_size = 0;\n\t\t}\n\n\t\tbi->total_size = bi->size_of_headers_and_pal + bi->foreground_size + bi->mask_size;\n\t}\n\telse {\n\t\t// Don't try to figure out the true size of compressed or other unusual images.\n\t\tbi->total_size = len;\n\t}\n\n\treturn 1;\n}\n\n// TODO: Document and review whether the bi->total_size and\n// bi->size_of_headers_and_pal fields include the 14-byte fileheader.\nvoid fmtutil_generate_bmpfileheader(deark *c, dbuf *outf, const struct de_bmpinfo *bi,\n\ti64 file_size_override)\n{\n\ti64 file_size_to_write;\n\n\tdbuf_write(outf, (const u8*)\"BM\", 2);\n\n\tif(file_size_override)\n\t\tfile_size_to_write = file_size_override;\n\telse\n\t\tfile_size_to_write = 14 + bi->total_size;\n\tdbuf_writeu32le(outf, file_size_to_write);\n\n\tdbuf_write_zeroes(outf, 4);\n\tdbuf_writeu32le(outf, 14 + bi->size_of_headers_and_pal);\n}\n\n// Extracts Exif if extract_level>=2, or \"extractexif\" option is set.\n// Otherwise decodes.\nvoid fmtutil_handle_exif2(deark *c, i64 pos, i64 len,\n\tu32 *returned_flags, u32 *orientation, u32 *exifversion)\n{\n\tint user_opt;\n\tde_module_params *mparams = NULL;\n\n\tif(returned_flags) {\n\t\t*returned_flags = 0;\n\t}\n\n\tuser_opt = de_get_ext_option_bool(c, \"extractexif\", -1);\n\tif(user_opt==1 || (c->extract_level>=2 && user_opt!=0)) {\n\t\t// Writing raw Exif data isn't very useful, but do so if requested.\n\t\tdbuf_create_file_from_slice(c->infile, pos, len, \"exif.tif\", NULL, DE_CREATEFLAG_IS_AUX);\n\n\t\t// Caller will have to reprocess the Exif file to extract anything from it.\n\t\treturn;\n\t}\n\n\tmparams = de_malloc(c, sizeof(de_module_params));\n\tmparams->in_params.codes = \"E\";\n\n\tde_run_module_by_id_on_slice(c, \"tiff\", mparams, c->infile, pos, len);\n\tif(returned_flags) {\n\t\t// FIXME: It's an unfortunate bug that returned_flags does not work if\n\t\t// extract_level>=2, but for now there's no reasonable way to fix it.\n\t\t// We have to process -- not extract -- the Exif chunk if we want to\n\t\t// know what's in it.\n\t\t*returned_flags = mparams->out_params.flags;\n\t\tif((mparams->out_params.flags & 0x20) && orientation) {\n\t\t\t*orientation = mparams->out_params.uint1;\n\t\t}\n\n\t\tif((mparams->out_params.flags & 0x40) && exifversion) {\n\t\t\t*exifversion = mparams->out_params.uint2;\n\t\t}\n\t}\n\n\tde_free(c, mparams);\n}\n\nvoid fmtutil_handle_exif(deark *c, i64 pos, i64 len)\n{\n\tfmtutil_handle_exif2(c, pos, len, NULL, NULL, NULL);\n}\n\nstatic void wrap_in_tiff(deark *c, dbuf *f, i64 dpos, i64 dlen,\n\tconst char *swstring, unsigned int tag, const char *ext, unsigned int createflags);\n\n// Either extract IPTC-IIM data to a file, or drill down into it.\n// flags:\n//  0 = default behavior (currently: depends on c->extract_level and options)\n//  2 = this came from our TIFF-encapsulated format\nvoid fmtutil_handle_iptc(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags)\n{\n\tint should_decode;\n\tint should_extract;\n\tint user_opt;\n\tint extract_fmt = 1; // 0=raw, 1=TIFF-wrapped\n\n\tif(len<1) return;\n\n\tuser_opt = de_get_ext_option_bool(c, \"extractiptc\", -1);\n\n\tif(user_opt==1 || (c->extract_level>=2 && user_opt!=0)) {\n\t\tshould_decode = 0;\n\t\tshould_extract = 1;\n\t\tif(flags&0x2) {\n\t\t\t// Avoid \"extracting\" in a way that would just recreate the exact same file.\n\t\t\textract_fmt = 0;\n\t\t}\n\t}\n\telse {\n\t\tshould_decode = 1;\n\t\tshould_extract = 0;\n\t}\n\n\tif(should_decode) {\n\t\tde_run_module_by_id_on_slice(c, \"iptc\", NULL, f, pos, len);\n\t}\n\n\tif(should_extract && extract_fmt==0) {\n\t\tdbuf_create_file_from_slice(f, pos, len, \"iptc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse if(should_extract && extract_fmt==1) {\n\t\twrap_in_tiff(c, f, pos, len, \"Deark extracted IPTC\", 33723, \"iptctiff\",\n\t\t\tDE_CREATEFLAG_IS_AUX);\n\t}\n}\n\n// If oparams is not NULL, if must be initialized by the caller. If the data is\n// decoded, oparams will be used by the submodule, and values may be returned in\n// it.\n// flags:\n//  0 = default behavior (currently: always decode)\n//  1 = always write to file\n//  2 = this came from our TIFF-encapsulated format\nvoid fmtutil_handle_photoshop_rsrc2(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags, struct de_module_out_params *oparams)\n{\n\tint should_decode;\n\tint should_extract;\n\tint extract_fmt = 1; // 0=raw, 1=TIFF-wrapped\n\n\tif(flags&0x1) {\n\t\tshould_decode = 0;\n\t\tshould_extract = 1;\n\t}\n\telse if(de_get_ext_option_bool(c, \"extract8bim\", 0)) {\n\t\tshould_extract = 1;\n\t\tshould_decode = 0;\n\t\tif(flags&0x2) {\n\t\t\t// Avoid \"extracting\" in a way that would just recreate the exact same file.\n\t\t\textract_fmt = 0;\n\t\t}\n\t}\n\telse {\n\t\tshould_decode = 1;\n\t\tshould_extract = 0;\n\t}\n\n\tif(should_decode) {\n\t\tde_module_params *mparams = NULL;\n\n\t\tmparams = de_malloc(c, sizeof(de_module_params));\n\t\tmparams->in_params.codes = \"R\";\n\t\tif(oparams) {\n\t\t\t// Since mparams->out_params is an embedded struct, not a pointer,\n\t\t\t// we have to copy oparam's fields to and from it.\n\t\t\tmparams->out_params = *oparams; // struct copy\n\t\t}\n\t\tde_run_module_by_id_on_slice(c, \"psd\", mparams, f, pos, len);\n\t\tif(oparams) {\n\t\t\t*oparams = mparams->out_params; // struct copy\n\t\t}\n\t\tde_free(c, mparams);\n\t}\n\n\tif(should_extract && extract_fmt==0) {\n\t\tdbuf_create_file_from_slice(f, pos, len, \"8bim\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse if(should_extract && extract_fmt==1) {\n\t\twrap_in_tiff(c, f, pos, len, \"Deark extracted 8BIM\", 34377, \"8bimtiff\",\n\t\t\tDE_CREATEFLAG_IS_AUX);\n\t}\n}\n\nvoid fmtutil_handle_photoshop_rsrc(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags)\n{\n\tfmtutil_handle_photoshop_rsrc2(c, f, pos, len, flags, NULL);\n}\n\n// flags:\n//  0 = default behavior (currently: decode unless -opt extractplist was used)\nvoid fmtutil_handle_plist(deark *c, dbuf *f, i64 pos, i64 len,\n\tde_finfo *fi, unsigned int flags)\n{\n\tif(de_get_ext_option_bool(c, \"extractplist\", 0)) {\n\t\tdbuf_create_file_from_slice(f, pos, len,\n\t\t\tfi?NULL:\"plist\", fi, DE_CREATEFLAG_IS_AUX);\n\t\treturn;\n\t}\n\n\tde_run_module_by_id_on_slice(c, \"plist\", NULL, f, pos, len);\n}\n\n// Caller allocates sdd. It does not need to be initialized.\n// flags: 0x1 = Print a debug message if signature is found.\nint fmtutil_detect_SAUCE(deark *c, dbuf *f, struct de_SAUCE_detection_data *sdd,\n\tunsigned int flags)\n{\n\tde_zeromem(sdd, sizeof(struct de_SAUCE_detection_data));\n\tif(f->len<128) return 0;\n\tif(dbuf_memcmp(f, f->len-128, \"SAUCE00\", 7)) return 0;\n\tif(flags & 0x1) {\n\t\tde_dbg(c, \"SAUCE metadata, signature at %\"I64_FMT, f->len-128);\n\t}\n\tsdd->has_SAUCE = 1;\n\tsdd->data_type = dbuf_getbyte(f, f->len-128+94);\n\tsdd->file_type = dbuf_getbyte(f, f->len-128+95);\n\treturn (int)sdd->has_SAUCE;\n}\n\nvoid fmtutil_handle_SAUCE(deark *c, dbuf *f, struct de_SAUCE_info *si)\n{\n\tde_module_params mparams;\n\n\tde_zeromem(&mparams, sizeof(de_module_params));\n\tmparams.out_params.obj1 = (void*)si;\n\tde_run_module_by_id_on_slice(c, \"sauce\", &mparams, f, 0, f->len);\n}\n\nstruct de_SAUCE_info *fmtutil_create_SAUCE(deark *c)\n{\n\treturn de_malloc(c, sizeof(struct de_SAUCE_info));\n}\n\nvoid fmtutil_free_SAUCE(deark *c, struct de_SAUCE_info *si)\n{\n\tif(!si) return;\n\tucstring_destroy(si->title);\n\tucstring_destroy(si->artist);\n\tucstring_destroy(si->organization);\n\tucstring_destroy(si->comment);\n\tde_free(c, si);\n}\n\n// Helper functions for the \"boxes\" (or \"atoms\") format used by MP4, JPEG 2000, etc.\n\ndouble dbuf_fmtutil_read_fixed_16_16(dbuf *f, i64 pos)\n{\n\ti64 n;\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\nstatic void do_box_sequence(deark *c, struct de_boxesctx *bctx,\n\ti64 pos1, i64 len, i64 max_nboxes, int level);\n\n// Make a printable version of a UUID (or a big-endian GUID).\n// Caller supplies s.\nvoid fmtutil_render_uuid(deark *c, const u8 *uuid, char *s, size_t s_len)\n{\n\tde_snprintf(s, s_len, \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t\tuuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],\n\t\tuuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);\n}\n\n// Swap some bytes to convert a (little-endian) GUID to a UUID, in-place\nvoid fmtutil_guid_to_uuid(u8 *id)\n{\n\tu8 tmp[16];\n\tde_memcpy(tmp, id, 16);\n\tid[0] = tmp[3]; id[1] = tmp[2]; id[2] = tmp[1]; id[3] = tmp[0];\n\tid[4] = tmp[5]; id[5] = tmp[4];\n\tid[6] = tmp[7]; id[7] = tmp[6];\n}\n\n#define DE_BOX_uuid 0x75756964U\n\nstatic int do_box(deark *c, struct de_boxesctx *bctx, i64 pos, i64 len,\n\tint level, i64 *pbytes_consumed)\n{\n\ti64 size32, size64;\n\ti64 header_len; // Not including UUIDs\n\ti64 payload_len; // Including UUIDs\n\ti64 total_len;\n\tstruct de_fourcc box4cc;\n\tchar uuid_string[50];\n\tint ret;\n\tint retval = 0;\n\tstruct de_boxdata *parentbox;\n\tstruct de_boxdata *curbox;\n\n\tparentbox = bctx->curbox;\n\tbctx->curbox = de_malloc(c, sizeof(struct de_boxdata));\n\tcurbox = bctx->curbox;\n\tcurbox->parent = parentbox;\n\n\tif(len<8) {\n\t\tde_dbg(c, \"(ignoring %d extra bytes at %\"I64_FMT\")\", (int)len, pos);\n\t\tgoto done;\n\t}\n\n\tsize32 = dbuf_getu32be(bctx->f, pos);\n\tdbuf_read_fourcc(bctx->f, pos+4, &box4cc, 4, 0x0);\n\tcurbox->boxtype = box4cc.id;\n\n\tif(size32>=8) {\n\t\theader_len = 8;\n\t\tpayload_len = size32-8;\n\t}\n\telse if(size32==0) {\n\t\theader_len = 8;\n\t\tpayload_len = len-8;\n\t}\n\telse if(size32==1) {\n\t\tif(len<16) {\n\t\t\tde_dbg(c, \"(ignoring %d extra bytes at %\"I64_FMT\")\", (int)len, pos);\n\t\t\tgoto done;\n\t\t}\n\t\theader_len = 16;\n\t\tsize64 = dbuf_geti64be(bctx->f, pos+8);\n\t\tif(size64<16) goto done;\n\t\tpayload_len = size64-16;\n\t}\n\telse {\n\t\tde_err(c, \"Invalid or unsupported box format\");\n\t\tgoto done;\n\t}\n\n\ttotal_len = header_len + payload_len;\n\n\tif(curbox->boxtype==DE_BOX_uuid && payload_len>=16) {\n\t\tcurbox->is_uuid = 1;\n\t\tdbuf_read(bctx->f, curbox->uuid, pos+header_len, 16);\n\t}\n\n\tcurbox->level = level;\n\tcurbox->box_pos = pos;\n\tcurbox->box_len = total_len;\n\tcurbox->payload_pos = pos+header_len;\n\tcurbox->payload_len = payload_len;\n\tif(curbox->is_uuid) {\n\t\tcurbox->payload_pos += 16;\n\t\tcurbox->payload_len -= 16;\n\t}\n\n\tif(bctx->identify_box_fn) {\n\t\tbctx->identify_box_fn(c, bctx);\n\t}\n\n\tif(c->debug_level>0) {\n\t\tchar name_str[80];\n\n\t\tif(curbox->box_name) {\n\t\t\tde_snprintf(name_str, sizeof(name_str), \" (%s)\", curbox->box_name);\n\t\t}\n\t\telse {\n\t\t\tname_str[0] = '\\0';\n\t\t}\n\n\t\tif(curbox->is_uuid) {\n\t\t\tfmtutil_render_uuid(c, curbox->uuid, uuid_string, sizeof(uuid_string));\n\t\t\tde_dbg(c, \"box '%s'{%s}%s at %\"I64_FMT\", len=%\"I64_FMT,\n\t\t\t\tbox4cc.id_dbgstr, uuid_string, name_str,\n\t\t\t\tpos, total_len);\n\t\t}\n\t\telse {\n\t\t\tde_dbg(c, \"box '%s'%s at %\"I64_FMT\", len=%\"I64_FMT\", dlen=%\"I64_FMT,\n\t\t\t\tbox4cc.id_dbgstr, name_str, pos,\n\t\t\t\ttotal_len, payload_len);\n\t\t}\n\t}\n\n\tif(total_len > len) {\n\t\tde_err(c, \"Invalid oversized box, or unexpected end of file \"\n\t\t\t\"(box at %\"I64_FMT\" ends at %\"I64_FMT\", \"\n\t\t\t\"parent ends at %\"I64_FMT\")\",\n\t\t\tpos, pos+total_len, pos+len);\n\t\tgoto done;\n\t}\n\n\tde_dbg_indent(c, 1);\n\tret = bctx->handle_box_fn(c, bctx);\n\tde_dbg_indent(c, -1);\n\tif(!ret) goto done;\n\n\tif(curbox->is_superbox) {\n\t\ti64 children_pos, children_len;\n\t\ti64 max_nchildren;\n\n\t\tde_dbg_indent(c, 1);\n\t\tchildren_pos = curbox->payload_pos + curbox->extra_bytes_before_children;\n\t\tchildren_len = curbox->payload_len - curbox->extra_bytes_before_children;\n\t\tmax_nchildren = (curbox->num_children_is_known) ? curbox->num_children : -1;\n\t\tdo_box_sequence(c, bctx, children_pos, children_len, max_nchildren, level+1);\n\t\tde_dbg_indent(c, -1);\n\t}\n\n\t*pbytes_consumed = total_len;\n\tretval = 1;\n\ndone:\n\tde_free(c, bctx->curbox);\n\tbctx->curbox = parentbox; // Restore the curbox pointer\n\treturn retval;\n}\n\n// max_nboxes: -1 = no maximum\nstatic void do_box_sequence(deark *c, struct de_boxesctx *bctx,\n\ti64 pos1, i64 len, i64 max_nboxes, int level)\n{\n\ti64 pos;\n\ti64 box_len;\n\ti64 endpos;\n\tint ret;\n\ti64 box_count = 0;\n\n\tif(level >= 32) { // An arbitrary recursion limit.\n\t\treturn;\n\t}\n\n\tpos = pos1;\n\tendpos = pos1 + len;\n\n\twhile(pos < endpos) {\n\t\tif(max_nboxes>=0 && box_count>=max_nboxes) break;\n\t\tret = do_box(c, bctx, pos, endpos-pos, level, &box_len);\n\t\tif(!ret) break;\n\t\tbox_count++;\n\t\tpos += box_len;\n\t}\n}\n\n// Handle some box types that might be common to multiple formats.\n// This function should be called as needed by the client's box handler function.\n// TODO: A way to identify (name) the boxes that we handle here.\nint fmtutil_default_box_handler(deark *c, struct de_boxesctx *bctx)\n{\n\tstruct de_boxdata *curbox = bctx->curbox;\n\n\tif(curbox->is_uuid) {\n\t\tif(!de_memcmp(curbox->uuid, \"\\xb1\\x4b\\xf8\\xbd\\x08\\x3d\\x4b\\x43\\xa5\\xae\\x8c\\xd7\\xd5\\xa6\\xce\\x03\", 16)) {\n\t\t\tde_dbg(c, \"GeoTIFF data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tdbuf_create_file_from_slice(bctx->f, curbox->payload_pos, curbox->payload_len, \"geo.tif\", NULL, DE_CREATEFLAG_IS_AUX);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\xbe\\x7a\\xcf\\xcb\\x97\\xa9\\x42\\xe8\\x9c\\x71\\x99\\x94\\x91\\xe3\\xaf\\xac\", 16)) {\n\t\t\tde_dbg(c, \"XMP data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tdbuf_create_file_from_slice(bctx->f, curbox->payload_pos, curbox->payload_len, \"xmp\", NULL, DE_CREATEFLAG_IS_AUX);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\x2c\\x4c\\x01\\x00\\x85\\x04\\x40\\xb9\\xa0\\x3e\\x56\\x21\\x48\\xd6\\xdf\\xeb\", 16)) {\n\t\t\tde_dbg(c, \"Photoshop resources at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, 1);\n\t\t\tfmtutil_handle_photoshop_rsrc(c, bctx->f, curbox->payload_pos, curbox->payload_len, 0x0);\n\t\t\tde_dbg_indent(c, -1);\n\t\t}\n\t\telse if(!de_memcmp(curbox->uuid, \"\\x05\\x37\\xcd\\xab\\x9d\\x0c\\x44\\x31\\xa7\\x2a\\xfa\\x56\\x1f\\x2a\\x11\\x3e\", 16) ||\n\t\t\t!de_memcmp(curbox->uuid, \"JpgTiffExif->JP2\", 16))\n\t\t{\n\t\t\tde_dbg(c, \"Exif data at %\"I64_FMT\", len=%\"I64_FMT, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, 1);\n\t\t\tfmtutil_handle_exif(c, curbox->payload_pos, curbox->payload_len);\n\t\t\tde_dbg_indent(c, -1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid fmtutil_read_boxes_format(deark *c, struct de_boxesctx *bctx)\n{\n\tif(!bctx->f || !bctx->handle_box_fn) return; // Internal error\n\tif(bctx->curbox) return; // Internal error\n\tdo_box_sequence(c, bctx, 0, bctx->f->len, -1, 0);\n}\n\nstatic u8 scale_7_to_255(u8 x)\n{\n\treturn (u8)(0.5+(((double)x)*(255.0/7.0)));\n}\n\nstatic u8 scale_15_to_255(u8 x)\n{\n\treturn x*17;\n}\n\nvoid fmtutil_read_atari_palette(deark *c, dbuf *f, i64 pos,\n\tde_color *dstpal, i64 ncolors_to_read, i64 ncolors_used, unsigned int flags)\n{\n\ti64 i;\n\tunsigned int n;\n\tint pal_bits = 0; // 9, 12, or 15. 0 = not yet determined\n\tu8 cr, cg, cb;\n\tu8 cr1, cg1, cb1;\n\tchar cbuf[32];\n\tchar tmps[64];\n\tconst char *s;\n\n\ts = de_get_ext_option(c, \"atari:palbits\");\n\tif(s) {\n\t\tpal_bits = de_atoi(s);\n\t}\n\n\tif(pal_bits==0 && (flags&DE_FLAG_ATARI_15BIT_PAL)) {\n\t\tpal_bits = 15;\n\t}\n\n\tif(pal_bits==0) {\n\t\t// Pre-scan the palette, and try to guess whether Atari STE-style 12-bit\n\t\t// colors are used, instead of the usual 9-bit colors.\n\t\t// I don't know the best way to do this. Sometimes the 4th bit in each\n\t\t// nibble is used for extra color detail, and sometimes it just seems to\n\t\t// contain garbage. Maybe the logic should also depend on the file\n\t\t// format, or the number of colors.\n\t\tint bit_3_used = 0;\n\t\tint nibble_3_used = 0;\n\n\t\tfor(i=0; i<ncolors_to_read; i++) {\n\t\t\tn = (unsigned int)dbuf_getu16be(f, pos + i*2);\n\t\t\tif(n&0xf000) {\n\t\t\t\tnibble_3_used = 1;\n\t\t\t}\n\t\t\tif(n&0x0888) {\n\t\t\t\tbit_3_used = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(bit_3_used && !nibble_3_used) {\n\t\t\tde_dbg(c, \"12-bit palette colors detected\");\n\t\t\tpal_bits = 12;\n\t\t}\n\t}\n\n\tif(pal_bits<12) { // Default to 9 if <12\n\t\tpal_bits = 9;\n\t}\n\telse if(pal_bits<15) {\n\t\tpal_bits = 12;\n\t}\n\telse {\n\t\tpal_bits = 15;\n\t}\n\n\tfor(i=0; i<ncolors_to_read; i++) {\n\t\tn = (unsigned int)dbuf_getu16be(f, pos + 2*i);\n\n\t\tif(pal_bits==15) {\n\t\t\tcr1 = (u8)((n>>6)&0x1c);\n\t\t\tif(n&0x0800) cr1+=2;\n\t\t\tif(n&0x8000) cr1++;\n\t\t\tcg1 = (u8)((n>>2)&0x1c);\n\t\t\tif(n&0x0080) cg1+=2;\n\t\t\tif(n&0x4000) cg1++;\n\t\t\tcb1 = (u8)((n<<2)&0x1c);\n\t\t\tif(n&0x0008) cb1+=2;\n\t\t\tif(n&0x2000) cb1++;\n\t\t\tcr = de_scale_n_to_255(31, cr1);\n\t\t\tcg = de_scale_n_to_255(31, cg1);\n\t\t\tcb = de_scale_n_to_255(31, cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%2d,%2d,%2d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\t\telse if(pal_bits==12) {\n\t\t\tcr1 = (u8)((n>>7)&0x0e);\n\t\t\tif(n&0x800) cr1++;\n\t\t\tcg1 = (u8)((n>>3)&0x0e);\n\t\t\tif(n&0x080) cg1++;\n\t\t\tcb1 = (u8)((n<<1)&0x0e);\n\t\t\tif(n&0x008) cb1++;\n\t\t\tcr = scale_15_to_255(cr1);\n\t\t\tcg = scale_15_to_255(cg1);\n\t\t\tcb = scale_15_to_255(cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%2d,%2d,%2d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\t\telse {\n\t\t\tcr1 = (u8)((n>>8)&0x07);\n\t\t\tcg1 = (u8)((n>>4)&0x07);\n\t\t\tcb1 = (u8)(n&0x07);\n\t\t\tcr = scale_7_to_255(cr1);\n\t\t\tcg = scale_7_to_255(cg1);\n\t\t\tcb = scale_7_to_255(cb1);\n\t\t\tde_snprintf(cbuf, sizeof(cbuf), \"%d,%d,%d\",\n\t\t\t\t(int)cr1, (int)cg1, (int)cb1);\n\t\t}\n\n\t\tdstpal[i] = DE_MAKE_RGB(cr, cg, cb);\n\t\tde_snprintf(tmps, sizeof(tmps), \"0x%04x (%s) \"DE_CHAR_RIGHTARROW\" \", n, cbuf);\n\t\tde_dbg_pal_entry2(c, i, dstpal[i], tmps, NULL,\n\t\t\t(i>=ncolors_used)?\" [unused]\":\"\");\n\t}\n}\n\n/*\n *  Given an x-coordinate and a color index, returns the corresponding\n *  Spectrum palette index.\n *\n *  by Steve Belczyk; placed in the public domain December, 1990.\n *  [Adapted for Deark.]\n */\nstatic unsigned int spectrum512_FindIndex(i64 x, unsigned int c)\n{\n\ti64 x1;\n\n\tx1 = 10 * (i64)c;\n\n\tif (c & 1)  /* If c is odd */\n\t\tx1 = x1 - 5;\n\telse        /* If c is even */\n\t\tx1 = x1 + 1;\n\n\tif (x >= x1 && x < x1+160)\n\t\tc = c + 16;\n\telse if (x >= x1+160)\n\t\tc = c + 32;\n\n\treturn c;\n}\n\nstatic int decode_atari_image_paletted(deark *c, struct atari_img_decode_data *adata)\n{\n\ti64 i, j;\n\ti64 plane;\n\ti64 rowspan;\n\tu8 b;\n\tu32 v;\n\ti64 planespan;\n\ti64 ncolors;\n\n\tplanespan = 2*((adata->w+15)/16);\n\trowspan = planespan*adata->bpp;\n\tif(adata->ncolors>0)\n\t\tncolors = adata->ncolors;\n\telse\n\t\tncolors = ((i64)1)<<adata->bpp;\n\n\tfor(j=0; j<adata->h; j++) {\n\t\tfor(i=0; i<adata->w; i++) {\n\t\t\tv = 0;\n\n\t\t\tfor(plane=0; plane<adata->bpp; plane++) {\n\t\t\t\tif(adata->was_compressed==0) {\n\t\t\t\t\t// TODO: Simplify this.\n\t\t\t\t\tif(adata->bpp==1) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1, j*rowspan, i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==2) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i/16)*2, i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==4) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i/2-(i/2)%16)+8*((i%32)/16), i%16);\n\t\t\t\t\t}\n\t\t\t\t\telse if(adata->bpp==8) {\n\t\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1,\n\t\t\t\t\t\t\tj*rowspan + 2*plane + (i-i%16), i%16);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb = de_get_bits_symbol(adata->unc_pixels, 1, j*rowspan + plane*planespan, i);\n\t\t\t\t}\n\t\t\t\tif(b) v |= 1<<plane;\n\t\t\t}\n\n\t\t\tif(adata->is_spectrum512) {\n\t\t\t\tv = spectrum512_FindIndex(i, v);\n\t\t\t\tif(j>0) {\n\t\t\t\t\tv += (unsigned int)(48*(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v>=(unsigned int)ncolors) v=(unsigned int)(ncolors-1);\n\n\t\t\tde_bitmap_setpixel_rgb(adata->img, i, j, adata->pal[v]);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int decode_atari_image_16(deark *c, struct atari_img_decode_data *adata)\n{\n\ti64 i, j;\n\ti64 rowspan;\n\tu32 v;\n\n\trowspan = adata->w * 2;\n\n\tfor(j=0; j<adata->h; j++) {\n\t\tfor(i=0; i<adata->w; i++) {\n\t\t\tv = (u32)dbuf_getu16be(adata->unc_pixels, j*rowspan + 2*i);\n\t\t\tv = de_rgb565_to_888(v);\n\t\t\tde_bitmap_setpixel_rgb(adata->img, i, j,v);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint fmtutil_atari_decode_image(deark *c, struct atari_img_decode_data *adata)\n{\n\tswitch(adata->bpp) {\n\tcase 16:\n\t\treturn decode_atari_image_16(c, adata);\n\tcase 8: case 4: case 2: case 1:\n\t\treturn decode_atari_image_paletted(c, adata);\n\t}\n\n\tde_err(c, \"Unsupported bits/pixel (%d)\", (int)adata->bpp);\n\treturn 0;\n}\n\nvoid fmtutil_atari_set_standard_density(deark *c, struct atari_img_decode_data *adata,\n\tde_finfo *fi)\n{\n\tswitch(adata->bpp) {\n\tcase 4:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 240.0;\n\t\tfi->density.ydens = 200.0;\n\t\tbreak;\n\tcase 2:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 480.0;\n\t\tfi->density.ydens = 200.0;\n\t\tbreak;\n\tcase 1:\n\t\tfi->density.code = DE_DENSITY_UNK_UNITS;\n\t\tfi->density.xdens = 480.0;\n\t\tfi->density.ydens = 400.0;\n\t\tbreak;\n\t}\n}\n\nvoid fmtutil_atari_help_palbits(deark *c)\n{\n\tde_msg(c, \"-opt atari:palbits=<9|12|15> : Numer of significant bits \"\n\t\t\"per palette color\");\n}\n\n#define CODE__c_   0x28632920U // \"(c) \"\n#define CODE_ANNO  0x414e4e4fU\n#define CODE_AUTH  0x41555448U\n#define CODE_NAME  0x4e414d45U\n#define CODE_TEXT  0x54455854U\n#define CODE_RIFF  0x52494646U\n\nstatic void do_iff_text_chunk(deark *c, struct de_iffctx *ictx, i64 dpos, i64 dlen,\n\tconst char *name)\n{\n\tde_ucstring *s = NULL;\n\n\tif(dlen<1) return;\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring_n(ictx->f,\n\t\tdpos, dlen, DE_DBG_MAX_STRLEN,\n\t\ts, DE_CONVFLAG_STOP_AT_NUL, ictx->input_encoding);\n\tde_dbg(c, \"%s: \\\"%s\\\"\", name, ucstring_getpsz(s));\n\tucstring_destroy(s);\n}\n\nstatic void do_iff_anno(deark *c, struct de_iffctx *ictx, i64 pos, i64 len)\n{\n\ti64 foundpos;\n\n\tif(len<1) return;\n\n\t// Some ANNO chunks seem to be padded with one or more NUL bytes. Probably\n\t// best not to save them.\n\tif(dbuf_search_byte(ictx->f, 0x00, pos, len, &foundpos)) {\n\t\tlen = foundpos - pos;\n\t}\n\tif(len<1) return;\n\tif(c->extract_level>=2) {\n\t\tdbuf_create_file_from_slice(ictx->f, pos, len, \"anno.txt\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\telse {\n\t\tde_ucstring *s = NULL;\n\t\ts = ucstring_create(c);\n\t\tdbuf_read_to_ucstring_n(ictx->f, pos, len, DE_DBG_MAX_STRLEN, s, 0, ictx->input_encoding);\n\t\tde_dbg(c, \"annotation: \\\"%s\\\"\", ucstring_getpsz(s));\n\t\tucstring_destroy(s);\n\t}\n}\n\nvoid fmtutil_default_iff_chunk_identify(deark *c, struct de_iffctx *ictx)\n{\n\tconst char *name = NULL;\n\n\tswitch(ictx->chunkctx->chunk4cc.id) {\n\tcase CODE__c_ : name=\"copyright\"; break;\n\tcase CODE_ANNO: name=\"annotation\"; break;\n\tcase CODE_AUTH: name=\"author\"; break;\n\t}\n\n\tif(name) {\n\t\tictx->chunkctx->chunk_name = name;\n\t}\n}\n\n// Note that some of these chunks are *not* defined in the generic IFF\n// specification.\n// They might be defined in the 8SVX specification. They seem to have\n// become unofficial standard chunks.\nstatic int de_fmtutil_default_iff_chunk_handler(deark *c, struct de_iffctx *ictx)\n{\n\ti64 dpos = ictx->chunkctx->dpos;\n\ti64 dlen = ictx->chunkctx->dlen;\n\tu32 chunktype = ictx->chunkctx->chunk4cc.id;\n\n\tswitch(chunktype) {\n\t\t// Note that chunks appearing here should also be listed below,\n\t\t// in de_fmtutil_is_standard_iff_chunk().\n\tcase CODE__c_:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"copyright\");\n\t\tbreak;\n\tcase CODE_ANNO:\n\t\tdo_iff_anno(c, ictx, dpos, dlen);\n\t\tbreak;\n\tcase CODE_AUTH:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"author\");\n\t\tbreak;\n\tcase CODE_NAME:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"name\");\n\t\tbreak;\n\tcase CODE_TEXT:\n\t\tdo_iff_text_chunk(c, ictx, dpos, dlen, \"text\");\n\t\tbreak;\n\t}\n\n\t// Note we do not set ictx->handled. The caller is responsible for that.\n\treturn 1;\n}\n\n// ictx can be NULL\nint fmtutil_is_standard_iff_chunk(deark *c, struct de_iffctx *ictx,\n\tu32 ct)\n{\n\tswitch(ct) {\n\tcase CODE__c_:\n\tcase CODE_ANNO:\n\tcase CODE_AUTH:\n\tcase CODE_NAME:\n\tcase CODE_TEXT:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void fourcc_clear(struct de_fourcc *fourcc)\n{\n\tde_zeromem(fourcc, sizeof(struct de_fourcc));\n}\n\nstatic int do_iff_chunk_sequence(deark *c, struct de_iffctx *ictx,\n\ti64 pos1, i64 len, int level);\n\n// Returns 0 if we can't continue\nstatic int do_iff_chunk(deark *c, struct de_iffctx *ictx, i64 pos, i64 bytes_avail,\n\tint level, i64 *pbytes_consumed)\n{\n\tint ret;\n\ti64 chunk_dlen_raw;\n\ti64 chunk_dlen_padded;\n\ti64 data_bytes_avail;\n\ti64 hdrsize;\n\tstruct de_iffchunkctx chunkctx;\n\tint saved_indent_level;\n\tint retval = 0;\n\tchar name_str[80];\n\n\tde_zeromem(&chunkctx, sizeof(struct de_iffchunkctx));\n\n\tde_dbg_indent_save(c, &saved_indent_level);\n\n\thdrsize = 4+ictx->sizeof_len;\n\tif(bytes_avail<hdrsize) {\n\t\tde_warn(c, \"Ignoring %\"I64_FMT\" bytes at %\"I64_FMT\"; too small \"\n\t\t\t\"to be a chunk\", bytes_avail, pos);\n\t\tgoto done;\n\t}\n\tdata_bytes_avail = bytes_avail-hdrsize;\n\n\tdbuf_read_fourcc(ictx->f, pos, &chunkctx.chunk4cc, 4,\n\t\tictx->reversed_4cc ? DE_4CCFLAG_REVERSED : 0x0);\n\tif(chunkctx.chunk4cc.id==0 && level==0) {\n\t\tde_warn(c, \"Chunk ID not found at %\"I64_FMT\"; assuming the data ends \"\n\t\t\t\"here\", pos);\n\t\tgoto done;\n\t}\n\n\tif(ictx->sizeof_len==2) {\n\t\tchunk_dlen_raw = dbuf_getu16x(ictx->f, pos+4, ictx->is_le);\n\t}\n\telse {\n\t\tchunk_dlen_raw = dbuf_getu32x(ictx->f, pos+4, ictx->is_le);\n\t}\n\tchunkctx.dlen = chunk_dlen_raw;\n\tchunkctx.dpos = pos+hdrsize;\n\n\t// TODO: Setting these fields (prior to the identify function) is enough\n\t// for now, but we should also set the other fields here if we can.\n\tictx->level = level;\n\tictx->chunkctx = &chunkctx;\n\n\tif(ictx->preprocess_chunk_fn) {\n\t\tictx->preprocess_chunk_fn(c, ictx);\n\t}\n\n\tif(chunkctx.chunk_name) {\n\t\tde_snprintf(name_str, sizeof(name_str), \" (%s)\", chunkctx.chunk_name);\n\t}\n\telse {\n\t\tname_str[0] = '\\0';\n\t}\n\n\tde_dbg(c, \"chunk '%s'%s at %\"I64_FMT\", dpos=%\"I64_FMT\", dlen=%\"I64_FMT,\n\t\tchunkctx.chunk4cc.id_dbgstr, name_str, pos,\n\t\tchunkctx.dpos, chunkctx.dlen);\n\tde_dbg_indent(c, 1);\n\n\tif(chunkctx.dlen > data_bytes_avail) {\n\t\tint should_warn = 1;\n\n\t\tif(chunkctx.chunk4cc.id==CODE_RIFF && pos==0 && bytes_avail==ictx->f->len) {\n\t\t\t// Hack:\n\t\t\t// This apparent error, in which the RIFF chunk's length field gives the\n\t\t\t// length of the entire file, is too common (particularly in .ani files)\n\t\t\t// to warn about.\n\t\t\tshould_warn = 0;\n\t\t}\n\n\t\tif(should_warn) {\n\t\t\tde_warn(c, \"Invalid oversized chunk, or unexpected end of file \"\n\t\t\t\t\"(chunk at %d ends at %\" I64_FMT \", \"\n\t\t\t\t\"parent ends at %\" I64_FMT \")\",\n\t\t\t\t(int)pos, chunkctx.dlen+chunkctx.dpos, pos+bytes_avail);\n\t\t}\n\n\t\tchunkctx.dlen = data_bytes_avail; // Try to continue\n\t\tde_dbg(c, \"adjusting chunk data len to %\"I64_FMT, chunkctx.dlen);\n\t}\n\n\tchunk_dlen_padded = de_pad_to_n(chunkctx.dlen, ictx->alignment);\n\t*pbytes_consumed = hdrsize + chunk_dlen_padded;\n\n\t// We've set *pbytes_consumed, so we can return \"success\"\n\tretval = 1;\n\n\t// Set ictx fields, prior to calling the handler\n\tchunkctx.pos = pos;\n\tchunkctx.len = bytes_avail;\n\tictx->handled = 0;\n\tictx->is_std_container = 0;\n\tictx->is_raw_container = 0;\n\n\tret = ictx->handle_chunk_fn(c, ictx);\n\tif(!ret) {\n\t\tretval = 0;\n\t\tgoto done;\n\t}\n\n\tif(ictx->is_std_container || ictx->is_raw_container) {\n\t\ti64 contents_dpos, contents_dlen;\n\n\t\tictx->chunkctx = NULL;\n\t\tictx->curr_container_fmt4cc = chunkctx.chunk4cc;\n\t\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\n\t\tif(ictx->is_std_container) {\n\t\t\tcontents_dpos = chunkctx.dpos+4;\n\t\t\tcontents_dlen = chunkctx.dlen-4;\n\n\t\t\t// First 4 bytes of payload are the \"contents type\" or \"FORM type\"\n\t\t\tdbuf_read_fourcc(ictx->f, chunkctx.dpos, &ictx->curr_container_contentstype4cc, 4,\n\t\t\t\tictx->reversed_4cc ? DE_4CCFLAG_REVERSED : 0);\n\n\t\t\tif(level==0) {\n\t\t\t\tictx->main_fmt4cc = ictx->curr_container_fmt4cc;\n\t\t\t\tictx->main_contentstype4cc = ictx->curr_container_contentstype4cc; // struct copy\n\t\t\t}\n\t\t\tde_dbg(c, \"contents type: '%s'\", ictx->curr_container_contentstype4cc.id_dbgstr);\n\n\t\t\tif(ictx->on_std_container_start_fn) {\n\t\t\t\t// Call only for standard-format containers.\n\t\t\t\tret = ictx->on_std_container_start_fn(c, ictx);\n\t\t\t\tif(!ret) goto done;\n\t\t\t}\n\t\t}\n\t\telse { // ictx->is_raw_container\n\t\t\tcontents_dpos = chunkctx.dpos;\n\t\t\tcontents_dlen = chunkctx.dlen;\n\t\t}\n\n\t\tret = do_iff_chunk_sequence(c, ictx, contents_dpos, contents_dlen, level+1);\n\t\tif(!ret) {\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif(ictx->on_container_end_fn) {\n\t\t\t// Call for all containers (not just standard-format containers).\n\n\t\t\t// TODO: Decide exactly what ictx->* fields to set here.\n\t\t\tictx->level = level;\n\n\t\t\tictx->chunkctx = NULL;\n\t\t\tret = ictx->on_container_end_fn(c, ictx);\n\t\t\tif(!ret) {\n\t\t\t\tretval = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(!ictx->handled) {\n\t\tde_fmtutil_default_iff_chunk_handler(c, ictx);\n\t}\n\ndone:\n\tfourcc_clear(&ictx->curr_container_fmt4cc);\n\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\n\tde_dbg_indent_restore(c, saved_indent_level);\n\treturn retval;\n}\n\nstatic int do_iff_chunk_sequence(deark *c, struct de_iffctx *ictx,\n\ti64 pos1, i64 len, int level)\n{\n\ti64 pos;\n\ti64 endpos;\n\ti64 chunk_len;\n\tstruct de_fourcc saved_container_fmt4cc;\n\tstruct de_fourcc saved_container_contentstype4cc;\n\tint ret;\n\n\tif(level >= 16) { // An arbitrary recursion limit.\n\t\treturn 0;\n\t}\n\n\tendpos = pos1+len;\n\tsaved_container_fmt4cc = ictx->curr_container_fmt4cc;\n\tsaved_container_contentstype4cc = ictx->curr_container_contentstype4cc;\n\n\tpos = pos1;\n\twhile(pos < endpos) {\n\t\tictx->curr_container_fmt4cc = saved_container_fmt4cc;\n\t\tictx->curr_container_contentstype4cc = saved_container_contentstype4cc;\n\n\t\tif(ictx->handle_nonchunk_data_fn) {\n\t\t\ti64 skip_len = 0;\n\t\t\tret = ictx->handle_nonchunk_data_fn(c, ictx, pos, &skip_len);\n\t\t\tif(ret && skip_len>0) {\n\t\t\t\tpos += de_pad_to_n(skip_len, ictx->alignment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = do_iff_chunk(c, ictx, pos, endpos-pos, level, &chunk_len);\n\t\tif(!ret) return 0;\n\t\tpos += chunk_len;\n\t}\n\n\tictx->curr_container_fmt4cc = saved_container_fmt4cc;\n\tictx->curr_container_contentstype4cc = saved_container_contentstype4cc;\n\n\treturn 1;\n}\n\nvoid fmtutil_read_iff_format(deark *c, struct de_iffctx *ictx,\n\ti64 pos, i64 len)\n{\n\tif(!ictx->f || !ictx->handle_chunk_fn) return; // Internal error\n\n\tictx->level = 0;\n\tfourcc_clear(&ictx->main_fmt4cc);\n\tfourcc_clear(&ictx->main_contentstype4cc);\n\tfourcc_clear(&ictx->curr_container_fmt4cc);\n\tfourcc_clear(&ictx->curr_container_contentstype4cc);\n\tif(ictx->alignment==0) {\n\t\tictx->alignment = 2;\n\t}\n\tif(ictx->sizeof_len==0) {\n\t\tictx->sizeof_len = 4;\n\t}\n\n\tif(ictx->input_encoding==DE_ENCODING_UNKNOWN) {\n\t\tictx->input_encoding = DE_ENCODING_ASCII;\n\t}\n\n\tdo_iff_chunk_sequence(c, ictx, pos, len, 0);\n}\n\nconst char *fmtutil_tiff_orientation_name(i64 n)\n{\n\tstatic const char *names[9] = {\n\t\t\"?\", \"top-left\", \"top-right\", \"bottom-right\", \"bottom-left\",\n\t\t\"left-top\", \"right-top\", \"right-bottom\", \"left-bottom\"\n\t};\n\tif(n>=1 && n<=8) return names[n];\n\treturn names[0];\n}\n\nconst char *fmtutil_get_windows_charset_name(u8 cs)\n{\n\tstruct csname_struct { u8 id; const char *name; };\n\tstatic const struct csname_struct csname_arr[] = {\n\t\t{0x00, \"ANSI\"},\n\t\t{0x01, \"default\"},\n\t\t{0x02, \"symbol\"},\n\t\t{0x4d, \"Mac\"},\n\t\t{0x80, \"Shift-JIS\"},\n\t\t{0x81, \"Hangul\"},\n\t\t{0x82, \"Johab\"},\n\t\t{0x86, \"GB2312\"},\n\t\t{0x88, \"BIG5\"},\n\t\t{0xa1, \"Greek\"},\n\t\t{0xa2, \"Turkish\"},\n\t\t{0xa3, \"Vietnamese\"},\n\t\t{0xb1, \"Hebrew\"},\n\t\t{0xb2, \"Arabic\"},\n\t\t{0xba, \"Baltic\"},\n\t\t{0xcc, \"Russian\"},\n\t\t{0xde, \"Thai\"},\n\t\t{0xee, \"Eastern Europe\"},\n\t\t{0xff, \"OEM\"}\n\t};\n\tsize_t i;\n\n\tfor(i=0; i<DE_ARRAYCOUNT(csname_arr); i++) {\n\t\tif(cs==csname_arr[i].id) return csname_arr[i].name;\n\t}\n\treturn \"?\";\n}\n\nconst char *fmtutil_get_windows_cb_data_type_name(unsigned int ty)\n{\n\tconst char *name = \"?\";\n\n\tswitch(ty) {\n\tcase 1: name=\"CF_TEXT\"; break;\n\tcase 2: name=\"CF_BITMAP\"; break;\n\tcase 3: name=\"CF_METAFILEPICT\"; break;\n\tcase 6: name=\"CF_TIFF\"; break;\n\tcase 7: name=\"CF_OEMTEXT\"; break;\n\tcase 8: name=\"CF_DIB\"; break;\n\tcase 11: name=\"CF_RIFF\"; break;\n\tcase 12: name=\"CF_WAVE\"; break;\n\tcase 13: name=\"CF_UNICODETEXT\"; break;\n\tcase 14: name=\"CF_ENHMETAFILE\"; break;\n\tcase 17: name=\"CF_DIBV5\"; break;\n\t}\n\treturn name;\n}\n\n// Search for the ZIP \"end of central directory\" object.\n// Also useful for detecting hybrid ZIP files, such as self-extracting EXE.\nint fmtutil_find_zip_eocd(deark *c, dbuf *f, i64 *foundpos)\n{\n\tu32 sig;\n\tu8 *buf = NULL;\n\tint retval = 0;\n\ti64 buf_offset;\n\ti64 buf_size;\n\ti64 i;\n\n\t*foundpos = 0;\n\tif(f->len < 22) goto done;\n\n\t// End-of-central-dir record usually starts 22 bytes from EOF. Try that first.\n\tsig = (u32)dbuf_getu32le(f, f->len - 22);\n\tif(sig == 0x06054b50U) {\n\t\t*foundpos = f->len - 22;\n\t\tretval = 1;\n\t\tgoto done;\n\t}\n\n\t// Search for the signature.\n\t// The end-of-central-directory record could theoretically appear anywhere\n\t// in the file. We'll follow Info-Zip/UnZip's lead and search the last 66000\n\t// bytes.\n#define MAX_ZIP_EOCD_SEARCH 66000\n\tbuf_size = f->len;\n\tif(buf_size > MAX_ZIP_EOCD_SEARCH) buf_size = MAX_ZIP_EOCD_SEARCH;\n\n\tbuf = de_malloc(c, buf_size);\n\tbuf_offset = f->len - buf_size;\n\tdbuf_read(f, buf, buf_offset, buf_size);\n\n\tfor(i=buf_size-22; i>=0; i--) {\n\t\tif(buf[i]=='P' && buf[i+1]=='K' && buf[i+2]==5 && buf[i+3]==6) {\n\t\t\t*foundpos = buf_offset + i;\n\t\t\tretval = 1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tde_free(c, buf);\n\treturn retval;\n}\n\n// Quick & dirty encoder that can wrap some formats in a TIFF container.\nstatic void wrap_in_tiff(deark *c, dbuf *f, i64 dpos, i64 dlen,\n\tconst char *swstring, unsigned int tag, const char *ext, unsigned int createflags)\n{\n\tdbuf *outf = NULL;\n\ti64 ifdoffs;\n\ti64 sw_len, sw_len_padded;\n\ti64 data_len_padded;\n\n\tsw_len = 1+(i64)de_strlen(swstring);\n\tif(sw_len<=4) return;\n\tsw_len_padded = de_pad_to_2(sw_len);\n\n\tif(dlen>4) {\n\t\tdata_len_padded = de_pad_to_2(dlen);\n\t}\n\telse {\n\t\tdata_len_padded = 0;\n\t}\n\n\toutf = dbuf_create_output_file(c, ext, NULL, 0);\n\tdbuf_write(outf, (const u8*)\"\\x4d\\x4d\\x00\\x2a\", 4);\n\tifdoffs = 8 + sw_len_padded + data_len_padded;\n\tdbuf_writeu32be(outf, ifdoffs);\n\tdbuf_write(outf, (const u8*)swstring, sw_len);\n\tif(sw_len%2) dbuf_writebyte(outf, 0);\n\tif(dlen>4) {\n\t\tdbuf_copy(f, dpos, dlen, outf);\n\t\tif(dlen%2) dbuf_writebyte(outf, 0);\n\t}\n\n\tdbuf_writeu16be(outf, 2); // number of dir entries;\n\n\tdbuf_writeu16be(outf, 305); // Software tag\n\tdbuf_writeu16be(outf, 2); // type=ASCII\n\tdbuf_writeu32be(outf, sw_len);\n\tdbuf_writeu32be(outf, 8); // offset\n\n\tdbuf_writeu16be(outf, (i64)tag);\n\tdbuf_writeu16be(outf, 1);\n\tdbuf_writeu32be(outf, dlen);\n\tif(dlen>4) {\n\t\tdbuf_writeu32be(outf, 8+sw_len_padded);\n\t}\n\telse {\n\t\tdbuf_copy(f, dpos, dlen, outf);\n\t\tdbuf_write_zeroes(outf, 4-dlen);\n\t}\n\n\tdbuf_writeu32be(outf, 0); // end of IFD\n\tdbuf_close(outf);\n}\n\n// Find ID3 tag data at the beginning and end of file, process it, and return\n// information about its location.\n// Caller allocates id3i.\nvoid fmtutil_handle_id3(deark *c, dbuf *f, struct de_id3info *id3i,\n\tunsigned int flags)\n{\n\ti64 id3v1pos = 0;\n\tint look_for_id3v1;\n\n\tde_zeromem(id3i, sizeof(struct de_id3info));\n\tid3i->main_start = 0;\n\tid3i->main_end = f->len;\n\n\tid3i->has_id3v2 = !dbuf_memcmp(f, 0, \"ID3\", 3);\n\tif(id3i->has_id3v2) {\n\t\tde_module_params id3v2mparams;\n\n\t\tde_dbg(c, \"ID3v2 data at %d\", 0);\n\t\tde_dbg_indent(c, 1);\n\t\tde_zeromem(&id3v2mparams, sizeof(de_module_params));\n\t\tid3v2mparams.in_params.codes = \"I\";\n\t\tde_run_module_by_id_on_slice(c, \"id3\", &id3v2mparams, f, 0, f->len);\n\t\tde_dbg_indent(c, -1);\n\t\tid3i->main_start += id3v2mparams.out_params.int64_1;\n\t}\n\n\tlook_for_id3v1 = 1;\n\tif(look_for_id3v1) {\n\t\tid3v1pos = f->len-128;\n\t\tif(!dbuf_memcmp(f, id3v1pos, \"TAG\", 3)) {\n\t\t\tid3i->has_id3v1 = 1;\n\t\t}\n\t}\n\n\tif(id3i->has_id3v1) {\n\t\tde_module_params id3v1mparams;\n\n\t\tde_dbg(c, \"ID3v1 data at %\"I64_FMT, id3v1pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_zeromem(&id3v1mparams, sizeof(de_module_params));\n\t\tid3v1mparams.in_params.codes = \"1\";\n\t\tde_run_module_by_id_on_slice(c, \"id3\", &id3v1mparams, f, id3v1pos, 128);\n\t\tde_dbg_indent(c, -1);\n\t\tid3i->main_end = id3v1pos;\n\t}\n}\n\nstatic void dbg_timestamp(deark *c, struct de_timestamp *ts, const char *name)\n{\n\tchar timestamp_buf[64];\n\n\tde_timestamp_to_string(ts, timestamp_buf, sizeof(timestamp_buf), 0);\n\tde_dbg(c, \"%s: %s\", name, timestamp_buf);\n}\n\nvoid fmtutil_riscos_read_load_exec(deark *c, dbuf *f, struct de_riscos_file_attrs *rfa, i64 pos1)\n{\n\ti64 pos = pos1;\n\n\trfa->load_addr = (u32)dbuf_getu32le_p(f, &pos);\n\trfa->exec_addr = (u32)dbuf_getu32le_p(f, &pos);\n\tde_dbg(c, \"load/exec addrs: 0x%08x, 0x%08x\", (unsigned int)rfa->load_addr,\n\t\t(unsigned int)rfa->exec_addr);\n\tde_dbg_indent(c, 1);\n\tif((rfa->load_addr&0xfff00000U)==0xfff00000U) {\n\t\trfa->file_type = (unsigned int)((rfa->load_addr&0xfff00)>>8);\n\t\trfa->file_type_known = 1;\n\t\tde_dbg(c, \"file type: %03X\", rfa->file_type);\n\n\t\tde_riscos_loadexec_to_timestamp(rfa->load_addr, rfa->exec_addr, &rfa->mod_time);\n\t\tdbg_timestamp(c, &rfa->mod_time, \"timestamp\");\n\t}\n\tde_dbg_indent(c, -1);\n}\n\nvoid fmtutil_riscos_read_attribs_field(deark *c, dbuf *f, struct de_riscos_file_attrs *rfa,\n\ti64 pos, unsigned int flags)\n{\n\trfa->attribs = (u32)dbuf_getu32le(f, pos);\n\tde_dbg(c, \"attribs: 0x%08x\", (unsigned int)rfa->attribs);\n\tde_dbg_indent(c, 1);\n\trfa->crc_from_attribs = rfa->attribs>>16;\n\tif(flags & DE_RISCOS_FLAG_HAS_CRC) {\n\t\tde_dbg(c, \"crc (reported): 0x%04x\", (unsigned int)rfa->crc_from_attribs);\n\t}\n\tif(flags & DE_RISCOS_FLAG_HAS_LZWMAXBITS) {\n\t\trfa->lzwmaxbits = (unsigned int)((rfa->attribs&0xff00)>>8);\n\t\tde_dbg(c, \"lzw maxbits: %u\", rfa->lzwmaxbits);\n\t}\n\tde_dbg_indent(c, -1);\n}\n\nstruct pict_rect {\n\ti64 t, l, b, r;\n};\n\n// Note: Code duplicated in pict.c\nstatic double pict_read_fixed(dbuf *f, i64 pos)\n{\n\ti64 n;\n\n\t// I think QuickDraw's \"Fixed point\" numbers are signed, but I don't know\n\t// how negative numbers are handled.\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\n// Read a QuickDraw Rectangle. Caller supplies rect struct.\n// Note: Code duplicated in pict.c\nstatic void pict_read_rect(dbuf *f, i64 pos,\n\tstruct pict_rect *rect, const char *dbgname)\n{\n\trect->t = dbuf_geti16be(f, pos);\n\trect->l = dbuf_geti16be(f, pos+2);\n\trect->b = dbuf_geti16be(f, pos+4);\n\trect->r = dbuf_geti16be(f, pos+6);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)-(%d,%d)\", dbgname, (int)rect->l, (int)rect->t,\n\t\t\t(int)rect->r, (int)rect->b);\n\t}\n}\n\n// Sometimes-present baseAddr field (4 bytes)\nvoid fmtutil_macbitmap_read_baseaddr(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\ti64 n;\n\tde_dbg(c, \"baseAddr part of PixMap, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tn = dbuf_getu32be(f, pos);\n\tde_dbg(c, \"baseAddr: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}\n\nvoid fmtutil_macbitmap_read_rowbytes_and_bounds(deark *c, dbuf *f,\n\tstruct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tstruct pict_rect tmprect;\n\ti64 rowbytes_code;\n\n\tde_dbg(c, \"rowBytes/bounds part of bitmap/PixMap header, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\trowbytes_code = dbuf_getu16be(f, pos);\n\tbi->rowbytes = rowbytes_code & 0x7fff;\n\tbi->pixmap_flag = (rowbytes_code & 0x8000)?1:0;\n\tde_dbg(c, \"rowBytes: %d\", (int)bi->rowbytes);\n\tde_dbg(c, \"pixmap flag: %d\", bi->pixmap_flag);\n\n\tpict_read_rect(f, pos+2, &tmprect, \"rect\");\n\tbi->npwidth = tmprect.r - tmprect.l;\n\tbi->pdwidth = bi->npwidth; // default\n\tbi->height = tmprect.b - tmprect.t;\n\n\tde_dbg_indent(c, -1);\n}\n\n// Pixmap fields that aren't read by read_baseaddr or read_rowbytes_and_bounds\n// (36 bytes)\nvoid fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\t}\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\n\tde_dbg_indent(c, -1);\n}\n\nint fmtutil_macbitmap_read_colortable(deark *c, dbuf *f,\n\tstruct fmtutil_macbitmap_info *bi, i64 pos, i64 *bytes_used)\n{\n\ti64 ct_id;\n\tu32 ct_flags;\n\ti64 ct_size;\n\ti64 k, z;\n\tu32 s[4];\n\tu8 cr, cg, cb;\n\tu32 clr;\n\tchar tmps[64];\n\n\t*bytes_used = 0;\n\tde_dbg(c, \"color table at %\"I64_FMT, pos);\n\tde_dbg_indent(c, 1);\n\n\tct_id = dbuf_getu32be(f, pos);\n\tct_flags = (u32)dbuf_getu16be(f, pos+4); // a.k.a. transIndex\n\tct_size = dbuf_getu16be(f, pos+6);\n\tbi->num_pal_entries = ct_size+1;\n\tde_dbg(c, \"color table id=0x%08x, flags=0x%04x, colors=%d\", (unsigned int)ct_id,\n\t\t(unsigned int)ct_flags, (int)bi->num_pal_entries);\n\n\tfor(k=0; k<bi->num_pal_entries; k++) {\n\t\tfor(z=0; z<4; z++) {\n\t\t\ts[z] = (u32)dbuf_getu16be(f, pos+8+8*k+2*z);\n\t\t}\n\t\tcr = (u8)(s[1]>>8);\n\t\tcg = (u8)(s[2]>>8);\n\t\tcb = (u8)(s[3]>>8);\n\t\tclr = DE_MAKE_RGB(cr,cg,cb);\n\t\tde_snprintf(tmps, sizeof(tmps), \"(%5d,%5d,%5d,idx=%3d) \"DE_CHAR_RIGHTARROW\" \",\n\t\t\t(int)s[1], (int)s[2], (int)s[3], (int)s[0]);\n\t\tde_dbg_pal_entry2(c, k, clr, tmps, NULL, NULL);\n\n\t\t// Some files don't have the palette indices set. Most PICT decoders ignore\n\t\t// the indices if the \"device\" flag of ct_flags is set, and that seems to\n\t\t// work (though it's not clearly documented).\n\t\tif(ct_flags & 0x8000U) {\n\t\t\ts[0] = (u32)k;\n\t\t}\n\n\t\tif(s[0]<=255) {\n\t\t\tbi->pal[s[0]] = clr;\n\t\t}\n\t}\n\n\tde_dbg_indent(c, -1);\n\t*bytes_used = 8 + 8*bi->num_pal_entries;\n\treturn 1;\n}\n\n// \"compressed unsigned short\" - a variable-length integer format\n// TODO: This is duplicated in shg.c\ni64 fmtutil_hlp_get_cus_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = (i64)dbuf_getbyte_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two.\n\t\treturn x1>>1;\n\t}\n\t// If it's odd, divide by two, and add 128 times the value of\n\t// the next byte.\n\tx2 = (i64)dbuf_getbyte_p(f, ppos);\n\treturn (x1>>1) | (x2<<7);\n}\n\n// \"compressed signed short\"\ni64 fmtutil_hlp_get_css_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = (i64)dbuf_getbyte_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two, and subtract 64\n\t\treturn (x1>>1) - 64;\n\t}\n\t// If it's odd, divide by two, add 128 times the value of\n\t// the next byte, and subtract 16384.\n\tx1 >>= 1;\n\tx2 = (i64)dbuf_getbyte_p(f, ppos);\n\tx1 += x2 * 128;\n\tx1 -= 16384;\n\treturn x1;\n}\n\n// \"compressed unsigned long\"\ni64 fmtutil_hlp_get_cul_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\tx1 = dbuf_getu16le_p(f, ppos);\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two.\n\t\treturn x1>>1;\n\t}\n\t// If it's odd, divide by two, and add 32768 times the value of\n\t// the next two bytes.\n\tx2 = dbuf_getu16le_p(f, ppos);\n\treturn (x1>>1) | (x2<<15);\n}\n\n// \"compressed signed long\"\ni64 fmtutil_hlp_get_csl_p(dbuf *f, i64 *ppos)\n{\n\ti64 x1, x2;\n\n\tx1 = dbuf_getu16le_p(f, ppos);\n\n\tif(x1%2 == 0) {\n\t\t// If it's even, divide by two, and subtract 16384\n\t\treturn (x1>>1) - 16384;\n\t}\n\t// If it's odd, divide by two, add 32768 times the value of\n\t// the next two bytes, and subtract 67108864.\n\tx1 >>= 1;\n\tx2 = dbuf_getu16le_p(f, ppos);\n\tx1 += x2*32768;\n\tx1 -= 67108864;\n\treturn x1;\n}\n"], "filenames": ["src/fmtutil.c"], "buggy_code_start_loc": [1621], "buggy_code_end_loc": [1622], "fixing_code_start_loc": [1621], "fixing_code_end_loc": [1624], "type": "CWE-369", "message": "In Deark before v1.5.8, a specially crafted input file can cause a division by zero in (src/fmtutil.c) because of the value of pixelsize.", "other": {"cve": {"id": "CVE-2021-28856", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-14T17:15:14.427", "lastModified": "2021-04-21T19:03:46.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Deark before v1.5.8, a specially crafted input file can cause a division by zero in (src/fmtutil.c) because of the value of pixelsize."}, {"lang": "es", "value": "En Deark antes antes de la versi\u00f3n v1.5.8, un archivo de entrada especialmente dise\u00f1ado puede causar una divisi\u00f3n por cero en (src/fmtutil.c) debido al valor de pixelsize"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:deark:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.8", "matchCriteriaId": "DDEFD567-5B77-4505-9D83-F9A2EF0BBAB3"}]}]}], "references": [{"url": "https://fatihhcelik.github.io/posts/Division-By-Zero-Deark/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334"}}