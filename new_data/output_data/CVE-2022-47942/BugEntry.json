{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <linux/syscalls.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/ethtool.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n\n#include \"glob.h\"\n#include \"smbfsctl.h\"\n#include \"oplock.h\"\n#include \"smbacl.h\"\n\n#include \"auth.h\"\n#include \"asn1.h\"\n#include \"connection.h\"\n#include \"transport_ipc.h\"\n#include \"transport_rdma.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"misc.h\"\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/user_config.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"ndr.h\"\n\nstatic void __wbuf(struct ksmbd_work *work, void **req, void **rsp)\n{\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\t*req = ksmbd_req_buf_next(work);\n\t\t*rsp = ksmbd_resp_buf_next(work);\n\t} else {\n\t\t*req = smb2_get_msg(work->request_buf);\n\t\t*rsp = smb2_get_msg(work->response_buf);\n\t}\n}\n\n#define WORK_BUFFERS(w, rq, rs)\t__wbuf((w), (void **)&(rq), (void **)&(rs))\n\n/**\n * check_session_id() - check for valid session id in smb header\n * @conn:\tconnection instance\n * @id:\t\tsession id from smb header\n *\n * Return:      1 if valid session id, otherwise 0\n */\nstatic inline bool check_session_id(struct ksmbd_conn *conn, u64 id)\n{\n\tstruct ksmbd_session *sess;\n\n\tif (id == 0 || id == -1)\n\t\treturn false;\n\n\tsess = ksmbd_session_lookup_all(conn, id);\n\tif (sess)\n\t\treturn true;\n\tpr_err(\"Invalid user session id: %llu\\n\", id);\n\treturn false;\n}\n\nstruct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn *conn)\n{\n\tstruct channel *chann;\n\n\tlist_for_each_entry(chann, &sess->ksmbd_chann_list, chann_list) {\n\t\tif (chann->conn == conn)\n\t\t\treturn chann;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * smb2_get_ksmbd_tcon() - get tree connection information using a tree id.\n * @work:\tsmb work\n *\n * Return:\t0 if there is a tree connection matched or these are\n *\t\tskipable commands, otherwise error\n */\nint smb2_get_ksmbd_tcon(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tunsigned int cmd = le16_to_cpu(req_hdr->Command);\n\tint tree_id;\n\n\twork->tcon = NULL;\n\tif (cmd == SMB2_TREE_CONNECT_HE ||\n\t    cmd ==  SMB2_CANCEL_HE ||\n\t    cmd ==  SMB2_LOGOFF_HE) {\n\t\tksmbd_debug(SMB, \"skip to check tree connect request\\n\");\n\t\treturn 0;\n\t}\n\n\tif (xa_empty(&work->sess->tree_conns)) {\n\t\tksmbd_debug(SMB, \"NO tree connected\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\ttree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);\n\twork->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);\n\tif (!work->tcon) {\n\t\tpr_err(\"Invalid tid %d\\n\", tree_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_err_rsp() - set error response code on smb response\n * @work:\tsmb work containing response buffer\n */\nvoid smb2_set_err_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_err_rsp *err_rsp;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\terr_rsp = ksmbd_resp_buf_next(work);\n\telse\n\t\terr_rsp = smb2_get_msg(work->response_buf);\n\n\tif (err_rsp->hdr.Status != STATUS_STOPPED_ON_SYMLINK) {\n\t\terr_rsp->StructureSize = SMB2_ERROR_STRUCTURE_SIZE2_LE;\n\t\terr_rsp->ErrorContextCount = 0;\n\t\terr_rsp->Reserved = 0;\n\t\terr_rsp->ByteCount = 0;\n\t\terr_rsp->ErrorData[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, SMB2_ERROR_STRUCTURE_SIZE2);\n\t}\n}\n\n/**\n * is_smb2_neg_cmd() - is it smb2 negotiation command\n * @work:\tsmb work containing smb header\n *\n * Return:      true if smb2 negotiation command, otherwise false\n */\nbool is_smb2_neg_cmd(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is request not response message */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn false;\n\n\tif (hdr->Command != SMB2_NEGOTIATE)\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * is_smb2_rsp() - is it smb2 response\n * @work:\tsmb work containing smb response buffer\n *\n * Return:      true if smb2 response, otherwise false\n */\nbool is_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->response_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is response not request message */\n\tif (!(hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * get_smb2_cmd_val() - get smb command code from smb header\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      smb2 request command value\n */\nu16 get_smb2_cmd_val(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rcv_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trcv_hdr = ksmbd_req_buf_next(work);\n\telse\n\t\trcv_hdr = smb2_get_msg(work->request_buf);\n\treturn le16_to_cpu(rcv_hdr->Command);\n}\n\n/**\n * set_smb2_rsp_status() - set error response code on smb2 header\n * @work:\tsmb work containing response buffer\n * @err:\terror response code\n */\nvoid set_smb2_rsp_status(struct ksmbd_work *work, __le32 err)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp_hdr = ksmbd_resp_buf_next(work);\n\telse\n\t\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Status = err;\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * init_smb2_neg_rsp() - initialize smb2 response for negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * smb2 negotiate response is sent in reply of smb1 negotiate command for\n * dialect auto-negotiation.\n */\nint init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (conn->need_neg == false)\n\t\treturn -EINVAL;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(work));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\tAUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * smb2_set_rsp_credits() - set number of credits in response buffer\n * @work:\tsmb work containing smb response buffer\n */\nint smb2_set_rsp_credits(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = ksmbd_resp_buf_next(work);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned short credits_requested, aux_max;\n\tunsigned short credit_charge, credits_granted = 0;\n\n\tif (work->send_no_response)\n\t\treturn 0;\n\n\thdr->CreditCharge = req_hdr->CreditCharge;\n\n\tif (conn->total_credits > conn->vals->max_credits) {\n\t\thdr->CreditRequest = 0;\n\t\tpr_err(\"Total credits overflow: %d\\n\", conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tcredit_charge = max_t(unsigned short,\n\t\t\t      le16_to_cpu(req_hdr->CreditCharge), 1);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->total_credits -= credit_charge;\n\tconn->outstanding_credits -= credit_charge;\n\tcredits_requested = max_t(unsigned short,\n\t\t\t\t  le16_to_cpu(req_hdr->CreditRequest), 1);\n\n\t/* according to smb2.credits smbtorture, Windows server\n\t * 2016 or later grant up to 8192 credits at once.\n\t *\n\t * TODO: Need to adjuct CreditRequest value according to\n\t * current cpu load\n\t */\n\tif (hdr->Command == SMB2_NEGOTIATE)\n\t\taux_max = 1;\n\telse\n\t\taux_max = conn->vals->max_credits - credit_charge;\n\tcredits_granted = min_t(unsigned short, credits_requested, aux_max);\n\n\tif (conn->vals->max_credits - conn->total_credits < credits_granted)\n\t\tcredits_granted = conn->vals->max_credits -\n\t\t\tconn->total_credits;\n\n\tconn->total_credits += credits_granted;\n\twork->credits_granted += credits_granted;\n\n\tif (!req_hdr->NextCommand) {\n\t\t/* Update CreditRequest in last request */\n\t\thdr->CreditRequest = cpu_to_le16(work->credits_granted);\n\t}\n\tksmbd_debug(SMB,\n\t\t    \"credits: requested[%d] granted[%d] total_granted[%d]\\n\",\n\t\t    credits_requested, credits_granted,\n\t\t    conn->total_credits);\n\treturn 0;\n}\n\n/**\n * init_chained_smb2_rsp() - initialize smb2 chained response\n * @work:\tsmb work containing smb response buffer\n */\nstatic void init_chained_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *rsp = ksmbd_resp_buf_next(work);\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_hdr *rcv_hdr;\n\tint next_hdr_offset = 0;\n\tint len, new_len;\n\n\t/* Len of this response = updated RFC len - offset of previous cmd\n\t * in the compound rsp\n\t */\n\n\t/* Storing the current local FID which may be needed by subsequent\n\t * command in the compound request\n\t */\n\tif (req->Command == SMB2_CREATE && rsp->Status == STATUS_SUCCESS) {\n\t\twork->compound_fid = ((struct smb2_create_rsp *)rsp)->VolatileFileId;\n\t\twork->compound_pfid = ((struct smb2_create_rsp *)rsp)->PersistentFileId;\n\t\twork->compound_sid = le64_to_cpu(rsp->SessionId);\n\t}\n\n\tlen = get_rfc1002_len(work->response_buf) - work->next_smb2_rsp_hdr_off;\n\tnext_hdr_offset = le32_to_cpu(req->NextCommand);\n\n\tnew_len = ALIGN(len, 8);\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_hdr) + new_len - len);\n\trsp->NextCommand = cpu_to_le32(new_len);\n\n\twork->next_smb2_rcv_hdr_off += next_hdr_offset;\n\twork->next_smb2_rsp_hdr_off += new_len;\n\tksmbd_debug(SMB,\n\t\t    \"Compound req new_len = %d rcv off = %d rsp off = %d\\n\",\n\t\t    new_len, work->next_smb2_rcv_hdr_off,\n\t\t    work->next_smb2_rsp_hdr_off);\n\n\trsp_hdr = ksmbd_resp_buf_next(work);\n\trcv_hdr = ksmbd_req_buf_next(work);\n\n\tif (!(rcv_hdr->Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"related flag should be set\\n\");\n\t\twork->compound_fid = KSMBD_NO_FID;\n\t\twork->compound_pfid = KSMBD_NO_FID;\n\t}\n\tmemset((char *)rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR |\n\t\t\t\tSMB2_FLAGS_RELATED_OPERATIONS);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n}\n\n/**\n * is_chained_smb2_message() - check for chained command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      true if chained request, otherwise false\n */\nbool is_chained_smb2_message(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tunsigned int len, next_cmd;\n\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\thdr = ksmbd_req_buf_next(work);\n\tnext_cmd = le32_to_cpu(hdr->NextCommand);\n\tif (next_cmd > 0) {\n\t\tif ((u64)work->next_smb2_rcv_hdr_off + next_cmd +\n\t\t\t__SMB2_HEADER_STRUCTURE_SIZE >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"next command(%u) offset exceeds smb msg size\\n\",\n\t\t\t       next_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((u64)get_rfc1002_len(work->response_buf) + MAX_CIFS_SMALL_BUFFER_SIZE >\n\t\t    work->response_sz) {\n\t\t\tpr_err(\"next response offset exceeds response buffer size\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"got SMB2 chained command\\n\");\n\t\tinit_chained_smb2_rsp(work);\n\t\treturn true;\n\t} else if (work->next_smb2_rcv_hdr_off) {\n\t\t/*\n\t\t * This is last request in chained command,\n\t\t * align response to 8 byte\n\t\t */\n\t\tlen = ALIGN(get_rfc1002_len(work->response_buf), 8);\n\t\tlen = len - get_rfc1002_len(work->response_buf);\n\t\tif (len) {\n\t\t\tksmbd_debug(SMB, \"padding len %u\\n\", len);\n\t\t\tinc_rfc1001_len(work->response_buf, len);\n\t\t\tif (work->aux_payload_sz)\n\t\t\t\twork->aux_payload_sz += len;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * init_smb2_rsp_hdr() - initialize smb2 response\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint init_smb2_rsp_hdr(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr = smb2_get_msg(work->response_buf);\n\tstruct smb2_hdr *rcv_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\trsp_hdr->ProtocolId = rcv_hdr->ProtocolId;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n\n\twork->syncronous = true;\n\tif (work->async_id) {\n\t\tksmbd_release_id(&conn->async_ida, work->async_id);\n\t\twork->async_id = 0;\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_allocate_rsp_buf() - allocate smb2 response buffer\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise -ENOMEM\n */\nint smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\n\t/* allocate large response buf for chained commands */\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\n\twork->response_sz = sz;\n\treturn 0;\n}\n\n/**\n * smb2_check_user_session() - check for valid session for a user\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_check_user_session(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned int cmd = conn->ops->get_cmd_val(work);\n\tunsigned long long sess_id;\n\n\twork->sess = NULL;\n\t/*\n\t * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not\n\t * require a session id, so no need to validate user session's for\n\t * these commands.\n\t */\n\tif (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||\n\t    cmd == SMB2_SESSION_SETUP_HE)\n\t\treturn 0;\n\n\tif (!ksmbd_conn_good(work))\n\t\treturn -EINVAL;\n\n\tsess_id = le64_to_cpu(req_hdr->SessionId);\n\t/* Check for validity of user session */\n\twork->sess = ksmbd_session_lookup_all(conn, sess_id);\n\tif (work->sess)\n\t\treturn 1;\n\tksmbd_debug(SMB, \"Invalid user session, Uid %llu\\n\", sess_id);\n\treturn -EINVAL;\n}\n\nstatic void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\twrite_lock(&prev_sess->chann_lock);\n\tlist_for_each_entry(chann, &prev_sess->ksmbd_chann_list, chann_list)\n\t\tchann->conn->status = KSMBD_SESS_EXITING;\n\twrite_unlock(&prev_sess->chann_lock);\n}\n\n/**\n * smb2_get_name() - get filename string from on the wire smb format\n * @src:\tsource buffer\n * @maxlen:\tmaxlen of source string\n * @local_nls:\tnls_table pointer\n *\n * Return:      matching converted filename on success, otherwise error ptr\n */\nstatic char *\nsmb2_get_name(const char *src, const int maxlen, struct nls_table *local_nls)\n{\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(src, maxlen, 1, local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"failed to get name %ld\\n\", PTR_ERR(name));\n\t\treturn name;\n\t}\n\n\tksmbd_conv_path_to_unix(name);\n\tksmbd_strip_last_slash(name);\n\treturn name;\n}\n\nint setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint id;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;\n\n\tid = ksmbd_acquire_async_msg_id(&conn->async_ida);\n\tif (id < 0) {\n\t\tpr_err(\"Failed to alloc async message id\\n\");\n\t\treturn id;\n\t}\n\twork->syncronous = false;\n\twork->async_id = id;\n\trsp_hdr->Id.AsyncId = cpu_to_le64(id);\n\n\tksmbd_debug(SMB,\n\t\t    \"Send interim Response to inform async request id : %d\\n\",\n\t\t    work->async_id);\n\n\twork->cancel_fn = fn;\n\twork->cancel_argv = arg;\n\n\tif (list_empty(&work->async_request_entry)) {\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_add_tail(&work->async_request_entry, &conn->async_requests);\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tsmb2_set_err_rsp(work);\n\trsp_hdr->Status = status;\n\n\twork->multiRsp = 1;\n\tksmbd_conn_write(work);\n\trsp_hdr->Status = 0;\n\twork->multiRsp = 0;\n}\n\nstatic __le32 smb2_get_reparse_tag_special_file(umode_t mode)\n{\n\tif (S_ISDIR(mode) || S_ISREG(mode))\n\t\treturn 0;\n\n\tif (S_ISLNK(mode))\n\t\treturn IO_REPARSE_TAG_LX_SYMLINK_LE;\n\telse if (S_ISFIFO(mode))\n\t\treturn IO_REPARSE_TAG_LX_FIFO_LE;\n\telse if (S_ISSOCK(mode))\n\t\treturn IO_REPARSE_TAG_AF_UNIX_LE;\n\telse if (S_ISCHR(mode))\n\t\treturn IO_REPARSE_TAG_LX_CHR_LE;\n\telse if (S_ISBLK(mode))\n\t\treturn IO_REPARSE_TAG_LX_BLK_LE;\n\n\treturn 0;\n}\n\n/**\n * smb2_get_dos_mode() - get file mode in dos format from unix mode\n * @stat:\tkstat containing file mode\n * @attribute:\tattribute flags\n *\n * Return:      converted dos mode\n */\nstatic int smb2_get_dos_mode(struct kstat *stat, int attribute)\n{\n\tint attr = 0;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\tattr = FILE_ATTRIBUTE_DIRECTORY |\n\t\t\t(attribute & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));\n\t} else {\n\t\tattr = (attribute & 0x00005137) | FILE_ATTRIBUTE_ARCHIVE;\n\t\tattr &= ~(FILE_ATTRIBUTE_DIRECTORY);\n\t\tif (S_ISREG(stat->mode) && (server_conf.share_fake_fscaps &\n\t\t\t\tFILE_SUPPORTS_SPARSE_FILES))\n\t\t\tattr |= FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (smb2_get_reparse_tag_special_file(stat->mode))\n\t\t\tattr |= FILE_ATTRIBUTE_REPARSE_POINT;\n\t}\n\n\treturn attr;\n}\n\nstatic void build_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt,\n\t\t\t       __le16 hash_id)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = hash_id;\n}\n\nstatic void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t       __le16 cipher_type)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(4);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\tpneg_ctxt->Ciphers[0] = cipher_type;\n}\n\nstatic void build_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt,\n\t\t\t\t   __le16 comp_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Flags = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithms[0] = comp_algo;\n}\n\nstatic void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t__le16 sign_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_SIGNING_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16((sizeof(struct smb2_signing_capabilities) + 2)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SigningAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SigningAlgorithms[0] = sign_algo;\n}\n\nstatic void build_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void assemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_negotiate_rsp *rsp,\n\t\t\t\t  void *smb2_buf_len)\n{\n\tchar *pneg_ctxt = (char *)rsp +\n\t\t\tle32_to_cpu(rsp->NegotiateContextOffset);\n\tint neg_ctxt_cnt = 1;\n\tint ctxt_size;\n\n\tksmbd_debug(SMB,\n\t\t    \"assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,\n\t\t\t   conn->preauth_info->Preauth_HashId);\n\trsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);\n\tinc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);\n\tctxt_size = sizeof(struct smb2_preauth_neg_context);\n\t/* Round to 8 byte boundary */\n\tpneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);\n\n\tif (conn->cipher_type) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,\n\t\t\t\t   conn->cipher_type);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt +=\n\t\t\tround_up(sizeof(struct smb2_encryption_neg_context) + 2,\n\t\t\t\t 8);\n\t}\n\n\tif (conn->compress_algorithm) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t/* Temporarily set to SMB3_COMPRESS_NONE */\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)pneg_ctxt,\n\t\t\t\t       conn->compress_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_compression_capabilities_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_compression_capabilities_context) + 2,\n\t\t\t\t      8);\n\t}\n\n\tif (conn->posix_ext_supported) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_posix_neg_context);\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);\n\t}\n\n\tif (conn->signing_negotiated) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\tbuild_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,\n\t\t\t\t    conn->signing_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_signing_capabilities) + 2;\n\t}\n\n\tinc_rfc1001_len(smb2_buf_len, ctxt_size);\n}\n\nstatic __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\t__le32 err = STATUS_NO_PREAUTH_INTEGRITY_HASH_OVERLAP;\n\n\tif (pneg_ctxt->HashAlgorithms == SMB2_PREAUTH_INTEGRITY_SHA512) {\n\t\tconn->preauth_info->Preauth_HashId =\n\t\t\tSMB2_PREAUTH_INTEGRITY_SHA512;\n\t\terr = STATUS_SUCCESS;\n\t}\n\n\treturn err;\n}\n\nstatic void decode_encrypt_ctxt(struct ksmbd_conn *conn,\n\t\t\t\tstruct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t\tint len_of_ctxts)\n{\n\tint cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);\n\tint i, cphs_size = cph_cnt * sizeof(__le16);\n\n\tconn->cipher_type = 0;\n\n\tif (sizeof(struct smb2_encryption_neg_context) + cphs_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid cipher count(%d)\\n\", cph_cnt);\n\t\treturn;\n\t}\n\n\tif (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION))\n\t\treturn;\n\n\tfor (i = 0; i < cph_cnt; i++) {\n\t\tif (pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_GCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tksmbd_debug(SMB, \"Cipher ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->Ciphers[i]);\n\t\t\tconn->cipher_type = pneg_ctxt->Ciphers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * smb3_encryption_negotiated() - checks if server and client agreed on enabling encryption\n * @conn:\tsmb connection\n *\n * Return:\ttrue if connection should be encrypted, else false\n */\nstatic bool smb3_encryption_negotiated(struct ksmbd_conn *conn)\n{\n\tif (!conn->ops->generate_encryptionkey)\n\t\treturn false;\n\n\t/*\n\t * SMB 3.0 and 3.0.2 dialects use the SMB2_GLOBAL_CAP_ENCRYPTION flag.\n\t * SMB 3.1.1 uses the cipher_type field.\n\t */\n\treturn (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) ||\n\t    conn->cipher_type;\n}\n\nstatic void decode_compress_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tconn->compress_algorithm = SMB3_COMPRESS_NONE;\n}\n\nstatic void decode_sign_cap_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t int len_of_ctxts)\n{\n\tint sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);\n\tint i, sign_alos_size = sign_algo_cnt * sizeof(__le16);\n\n\tconn->signing_negotiated = false;\n\n\tif (sizeof(struct smb2_signing_capabilities) + sign_alos_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid signing algorithm count(%d)\\n\", sign_algo_cnt);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sign_algo_cnt; i++) {\n\t\tif (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256_LE ||\n\t\t    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC_LE) {\n\t\t\tksmbd_debug(SMB, \"Signing Algorithm ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->SigningAlgorithms[i]);\n\t\t\tconn->signing_negotiated = true;\n\t\t\tconn->signing_algorithm =\n\t\t\t\tpneg_ctxt->SigningAlgorithms[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen;\n\n\t\t/* check that offset is not beyond end of SMB */\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen + sizeof(struct smb2_neg_context) > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    len_of_ctxts);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     len_of_ctxts);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}\n\n/**\n * smb2_handle_negotiate() - handler for smb2 negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}\n\nstatic int alloc_preauth_hash(struct ksmbd_session *sess,\n\t\t\t      struct ksmbd_conn *conn)\n{\n\tif (sess->Preauth_HashValue)\n\t\treturn 0;\n\n\tsess->Preauth_HashValue = kmemdup(conn->preauth_info->Preauth_HashValue,\n\t\t\t\t\t  PREAUTH_HASHVALUE_SIZE, GFP_KERNEL);\n\tif (!sess->Preauth_HashValue)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int generate_preauth_hash(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tu8 *preauth_hash;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn 0;\n\n\tif (conn->binding) {\n\t\tstruct preauth_session *preauth_sess;\n\n\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\tif (!preauth_sess) {\n\t\t\tpreauth_sess = ksmbd_preauth_session_alloc(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpreauth_hash = preauth_sess->Preauth_HashValue;\n\t} else {\n\t\tif (!sess->Preauth_HashValue)\n\t\t\tif (alloc_preauth_hash(sess, conn))\n\t\t\t\treturn -ENOMEM;\n\t\tpreauth_hash = sess->Preauth_HashValue;\n\t}\n\n\tksmbd_gen_preauth_integrity_hash(conn, work->request_buf, preauth_hash);\n\treturn 0;\n}\n\nstatic int decode_negotiation_token(struct ksmbd_conn *conn,\n\t\t\t\t    struct negotiate_message *negblob,\n\t\t\t\t    size_t sz)\n{\n\tif (!conn->use_spnego)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_decode_negTokenInit((char *)negblob, sz, conn)) {\n\t\tif (ksmbd_decode_negTokenTarg((char *)negblob, sz, conn)) {\n\t\t\tconn->auth_mechs |= KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->preferred_auth_mech = KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->use_spnego = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ntlm_negotiate(struct ksmbd_work *work,\n\t\t\t  struct negotiate_message *negblob,\n\t\t\t  size_t negblob_len)\n{\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct challenge_message *chgblob;\n\tunsigned char *spnego_blob = NULL;\n\tu16 spnego_blob_len;\n\tchar *neg_blob;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"negotiate phase\\n\");\n\trc = ksmbd_decode_ntlmssp_neg_blob(negblob, negblob_len, work->conn);\n\tif (rc)\n\t\treturn rc;\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tchgblob =\n\t\t(struct challenge_message *)((char *)&rsp->hdr.ProtocolId + sz);\n\tmemset(chgblob, 0, sizeof(struct challenge_message));\n\n\tif (!work->conn->use_spnego) {\n\t\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\t\tif (sz < 0)\n\t\t\treturn -ENOMEM;\n\n\t\trsp->SecurityBufferLength = cpu_to_le16(sz);\n\t\treturn 0;\n\t}\n\n\tsz = sizeof(struct challenge_message);\n\tsz += (strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;\n\n\tneg_blob = kzalloc(sz, GFP_KERNEL);\n\tif (!neg_blob)\n\t\treturn -ENOMEM;\n\n\tchgblob = (struct challenge_message *)neg_blob;\n\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\tif (sz < 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_spnego_ntlmssp_neg_blob(&spnego_blob, &spnego_blob_len,\n\t\t\t\t\t   neg_blob, sz);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\nout:\n\tkfree(spnego_blob);\n\tkfree(neg_blob);\n\treturn rc;\n}\n\nstatic struct authenticate_message *user_authblob(struct ksmbd_conn *conn,\n\t\t\t\t\t\t  struct smb2_sess_setup_req *req)\n{\n\tint sz;\n\n\tif (conn->use_spnego && conn->mechToken)\n\t\treturn (struct authenticate_message *)conn->mechToken;\n\n\tsz = le16_to_cpu(req->SecurityBufferOffset);\n\treturn (struct authenticate_message *)((char *)&req->hdr.ProtocolId\n\t\t\t\t\t       + sz);\n}\n\nstatic struct ksmbd_user *session_user(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_sess_setup_req *req)\n{\n\tstruct authenticate_message *authblob;\n\tstruct ksmbd_user *user;\n\tchar *name;\n\tunsigned int auth_msg_len, name_off, name_len, secbuf_len;\n\n\tsecbuf_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (secbuf_len < sizeof(struct authenticate_message)) {\n\t\tksmbd_debug(SMB, \"blob len %d too small\\n\", secbuf_len);\n\t\treturn NULL;\n\t}\n\tauthblob = user_authblob(conn, req);\n\tname_off = le32_to_cpu(authblob->UserName.BufferOffset);\n\tname_len = le16_to_cpu(authblob->UserName.Length);\n\tauth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;\n\n\tif (auth_msg_len < (u64)name_off + name_len)\n\t\treturn NULL;\n\n\tname = smb_strndup_from_utf16((const char *)authblob + name_off,\n\t\t\t\t      name_len,\n\t\t\t\t      true,\n\t\t\t\t      conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"cannot allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tksmbd_debug(SMB, \"session setup request for user %s\\n\", name);\n\tuser = ksmbd_login_user(name);\n\tkfree(name);\n\treturn user;\n}\n\nstatic int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(work->response_buf, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(conn, user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t/*\n\t * If session state is SMB2_SESSION_VALID, We can assume\n\t * that it is reauthentication. And the user/password\n\t * has been verified, so return it here.\n\t */\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\tif (conn->binding)\n\t\t\tgoto binding_session;\n\t\treturn 0;\n\t}\n\n\tif ((rsp->SessionFlags != SMB2_SESSION_FLAG_IS_GUEST_LE &&\n\t     (conn->sign || server_conf.enforced_signing)) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn) &&\n\t\t\t!(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\trc = conn->ops->generate_encryptionkey(conn, sess);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t/*\n\t\t * signing is disable if encryption is enable\n\t\t * on this session\n\t\t */\n\t\tsess->sign = false;\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tread_lock(&sess->chann_lock);\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tread_unlock(&sess->chann_lock);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\twrite_lock(&sess->chann_lock);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t\twrite_unlock(&sess->chann_lock);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\t(le16_to_cpu(rsp->SecurityBufferOffset) + 4);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(conn, sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(work->response_buf, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(conn, sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tread_lock(&sess->chann_lock);\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tread_unlock(&sess->chann_lock);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\twrite_lock(&sess->chann_lock);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t\twrite_unlock(&sess->chann_lock);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n#else\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint smb2_sess_setup(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess;\n\tstruct negotiate_message *negblob;\n\tunsigned int negblob_len, negblob_off;\n\tint rc = 0;\n\n\tksmbd_debug(SMB, \"Received request for session setup\\n\");\n\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->SessionFlags = 0;\n\trsp->SecurityBufferOffset = cpu_to_le16(72);\n\trsp->SecurityBufferLength = 0;\n\tinc_rfc1001_len(work->response_buf, 9);\n\n\tif (!req->hdr.SessionId) {\n\t\tsess = ksmbd_smb2_session_create();\n\t\tif (!sess) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\trsp->hdr.SessionId = cpu_to_le64(sess->id);\n\t\trc = ksmbd_session_register(conn, sess);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\t} else if (conn->dialect >= SMB30_PROT_ID &&\n\t\t   (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   req->Flags & SMB2_SESSION_REQ_FLAG_BINDING) {\n\t\tu64 sess_id = le64_to_cpu(req->hdr.SessionId);\n\n\t\tsess = ksmbd_session_lookup_slowpath(sess_id);\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (conn->dialect != sess->dialect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!(req->hdr.Flags & SMB2_FLAGS_SIGNED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (strncmp(conn->ClientGUID, sess->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_IN_PROGRESS) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_session_lookup(conn, sess_id)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = true;\n\t} else if ((conn->dialect < SMB30_PROT_ID ||\n\t\t    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   (req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\tsess = NULL;\n\t\trc = -EACCES;\n\t\tgoto out_err;\n\t} else {\n\t\tsess = ksmbd_session_lookup(conn,\n\t\t\t\t\t    le64_to_cpu(req->hdr.SessionId));\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\twork->sess = sess;\n\n\tif (sess->state == SMB2_SESSION_EXPIRED)\n\t\tsess->state = SMB2_SESSION_IN_PROGRESS;\n\n\tnegblob_off = le16_to_cpu(req->SecurityBufferOffset);\n\tnegblob_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer) ||\n\t    negblob_len < offsetof(struct negotiate_message, NegotiateFlags)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tnegblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId +\n\t\t\tnegblob_off);\n\n\tif (decode_negotiation_token(conn, negblob, negblob_len) == 0) {\n\t\tif (conn->mechToken)\n\t\t\tnegblob = (struct negotiate_message *)conn->mechToken;\n\t}\n\n\tif (server_conf.auth_mechs & conn->auth_mechs) {\n\t\trc = generate_preauth_hash(work);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tif (conn->preferred_auth_mech &\n\t\t\t\t(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {\n\t\t\trc = krb5_authenticate(work);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tksmbd_conn_set_good(work);\n\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\tsess->Preauth_HashValue = NULL;\n\t\t} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {\n\t\t\tif (negblob->MessageType == NtLmNegotiate) {\n\t\t\t\trc = ntlm_negotiate(work, negblob, negblob_len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\t\t\t\trsp->hdr.Status =\n\t\t\t\t\tSTATUS_MORE_PROCESSING_REQUIRED;\n\t\t\t\t/*\n\t\t\t\t * Note: here total size -1 is done as an\n\t\t\t\t * adjustment for 0 size blob\n\t\t\t\t */\n\t\t\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength) - 1);\n\n\t\t\t} else if (negblob->MessageType == NtLmAuthenticate) {\n\t\t\t\trc = ntlm_authenticate(work);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\tksmbd_conn_set_good(work);\n\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t\tif (conn->binding) {\n\t\t\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\t\t\tpreauth_sess =\n\t\t\t\t\t\tksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\t\t\tif (preauth_sess) {\n\t\t\t\t\t\tlist_del(&preauth_sess->preauth_entry);\n\t\t\t\t\t\tkfree(preauth_sess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\t\tsess->Preauth_HashValue = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: need one more negotiation */\n\t\t\tpr_err(\"Not support the preferred authentication\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Not support authentication\\n\");\n\t\trc = -EINVAL;\n\t}\n\nout_err:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\telse if (rc)\n\t\trsp->hdr.Status = STATUS_LOGON_FAILURE;\n\n\tif (conn->use_spnego && conn->mechToken) {\n\t\tkfree(conn->mechToken);\n\t\tconn->mechToken = NULL;\n\t}\n\n\tif (rc < 0) {\n\t\t/*\n\t\t * SecurityBufferOffset should be set to zero\n\t\t * in session setup error response.\n\t\t */\n\t\trsp->SecurityBufferOffset = 0;\n\n\t\tif (sess) {\n\t\t\tbool try_delay = false;\n\n\t\t\t/*\n\t\t\t * To avoid dictionary attacks (repeated session setups rapidly sent) to\n\t\t\t * connect to server, ksmbd make a delay of a 5 seconds on session setup\n\t\t\t * failure to make it harder to send enough random connection requests\n\t\t\t * to break into a server.\n\t\t\t */\n\t\t\tif (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)\n\t\t\t\ttry_delay = true;\n\n\t\t\txa_erase(&conn->sessions, sess->id);\n\t\t\tksmbd_session_destroy(sess);\n\t\t\twork->sess = NULL;\n\t\t\tif (try_delay)\n\t\t\t\tssleep(5);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_tree_connect() - handler for smb2 tree connect command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_tree_connect(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_tree_connect_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_tree_connect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *treename = NULL, *name = NULL;\n\tstruct ksmbd_tree_conn_status status;\n\tstruct ksmbd_share_config *share;\n\tint rc = -EINVAL;\n\n\ttreename = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->PathLength), true,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(treename)) {\n\t\tpr_err(\"treename is NULL\\n\");\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tname = ksmbd_extract_sharename(treename);\n\tif (IS_ERR(name)) {\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tksmbd_debug(SMB, \"tree connect request for tree %s treename %s\\n\",\n\t\t    name, treename);\n\n\tstatus = ksmbd_tree_conn_connect(conn, sess, name);\n\tif (status.ret == KSMBD_TREE_CONN_STATUS_OK)\n\t\trsp->hdr.Id.SyncId.TreeId = cpu_to_le32(status.tree_conn->id);\n\telse\n\t\tgoto out_err1;\n\n\tshare = status.tree_conn->share_conf;\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC share path request\\n\");\n\t\trsp->ShareType = SMB2_SHARE_TYPE_PIPE;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_DELETE_LE | FILE_READ_CONTROL_LE |\n\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\tFILE_SYNCHRONIZE_LE;\n\t} else {\n\t\trsp->ShareType = SMB2_SHARE_TYPE_DISK;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE;\n\t\tif (test_tree_conn_flag(status.tree_conn,\n\t\t\t\t\tKSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\trsp->MaximalAccess |= FILE_WRITE_DATA_LE |\n\t\t\t\tFILE_APPEND_DATA_LE | FILE_WRITE_EA_LE |\n\t\t\t\tFILE_DELETE_LE | FILE_WRITE_ATTRIBUTES_LE |\n\t\t\t\tFILE_DELETE_CHILD_LE | FILE_READ_CONTROL_LE |\n\t\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\t\tFILE_SYNCHRONIZE_LE;\n\t\t}\n\t}\n\n\tstatus.tree_conn->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\tif (conn->posix_ext_supported)\n\t\tstatus.tree_conn->posix_extensions = true;\n\nout_err1:\n\trsp->StructureSize = cpu_to_le16(16);\n\trsp->Capabilities = 0;\n\trsp->Reserved = 0;\n\t/* default manual caching */\n\trsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;\n\tinc_rfc1001_len(work->response_buf, 16);\n\n\tif (!IS_ERR(treename))\n\t\tkfree(treename);\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tswitch (status.ret) {\n\tcase KSMBD_TREE_CONN_STATUS_OK:\n\t\trsp->hdr.Status = STATUS_SUCCESS;\n\t\trc = 0;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_NO_SHARE:\n\t\trsp->hdr.Status = STATUS_BAD_NETWORK_PATH;\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase KSMBD_TREE_CONN_STATUS_NOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_ERROR:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_CONNS:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_SESSIONS:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tbreak;\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_create_open_flags() - convert smb open flags to unix open flags\n * @file_present:\tis file already present\n * @access:\t\tfile access flags\n * @disposition:\tfile disposition flags\n * @may_flags:\t\tset with MAY_ flags\n *\n * Return:      file open flags\n */\nstatic int smb2_create_open_flags(bool file_present, __le32 access,\n\t\t\t\t  __le32 disposition,\n\t\t\t\t  int *may_flags)\n{\n\tint oflags = O_NONBLOCK | O_LARGEFILE;\n\n\tif (access & FILE_READ_DESIRED_ACCESS_LE &&\n\t    access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_RDWR;\n\t\t*may_flags = MAY_OPEN | MAY_READ | MAY_WRITE;\n\t} else if (access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_WRONLY;\n\t\t*may_flags = MAY_OPEN | MAY_WRITE;\n\t} else {\n\t\toflags |= O_RDONLY;\n\t\t*may_flags = MAY_OPEN | MAY_READ;\n\t}\n\n\tif (access == FILE_READ_ATTRIBUTES_LE)\n\t\toflags |= O_PATH;\n\n\tif (file_present) {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_CREATE_LE:\n\t\t\tbreak;\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_TRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_CREATE_LE:\n\t\tcase FILE_OPEN_IF_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_CREAT;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\t\toflags &= ~O_CREAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn oflags;\n}\n\n/**\n * smb2_tree_disconnect() - handler for smb tree connect request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}\n\n/**\n * smb2_session_logoff() - handler for session log off request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_session_logoff(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\t/* setting CifsExiting here may race with start_tcp_sess */\n\tksmbd_conn_set_need_reconnect(work);\n\tksmbd_close_session_fds(work);\n\tksmbd_conn_wait_idle(conn);\n\n\tif (ksmbd_tree_conn_session_logoff(sess)) {\n\t\tstruct smb2_logoff_req *req = smb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_destroy_file_table(&sess->file_table);\n\tsess->state = SMB2_SESSION_EXPIRED;\n\n\tksmbd_free_user(sess->user);\n\tsess->user = NULL;\n\n\t/* let start_tcp_sess free connection info now */\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * create_smb2_pipe() - create IPC pipe\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nstatic noinline int create_smb2_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_create_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_create_req *req = smb2_get_msg(work->request_buf);\n\tint id;\n\tint err;\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(req->Buffer, le16_to_cpu(req->NameLength),\n\t\t\t\t      1, work->conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\terr = PTR_ERR(name);\n\t\tgoto out;\n\t}\n\n\tid = ksmbd_session_rpc_open(work->sess, name);\n\tif (id < 0) {\n\t\tpr_err(\"Unable to open RPC pipe: %d\\n\", id);\n\t\terr = id;\n\t\tgoto out;\n\t}\n\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->StructureSize = cpu_to_le16(89);\n\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(FILE_OPENED);\n\n\trsp->CreationTime = cpu_to_le64(0);\n\trsp->LastAccessTime = cpu_to_le64(0);\n\trsp->ChangeTime = cpu_to_le64(0);\n\trsp->AllocationSize = cpu_to_le64(0);\n\trsp->EndofFile = cpu_to_le64(0);\n\trsp->FileAttributes = FILE_ATTRIBUTE_NORMAL_LE;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFileId = id;\n\trsp->PersistentFileId = 0;\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\tkfree(name);\n\treturn 0;\n\nout:\n\tswitch (err) {\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tcase -ENOSPC:\n\tcase -ENOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\t}\n\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tsmb2_set_err_rsp(work);\n\treturn err;\n}\n\n/**\n * smb2_set_ea() - handler for setting extended attributes using set\n *\t\tinfo command\n * @eabuf:\tset info command buffer\n * @buf_len:\tset info command buffer length\n * @path:\tdentry path for get ea\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,\n\t\t       struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *attr_name = NULL, *value;\n\tint rc = 0;\n\tunsigned int next = 0;\n\n\tif (buf_len < sizeof(struct smb2_ea_info) + eabuf->EaNameLength +\n\t\t\tle16_to_cpu(eabuf->EaValueLength))\n\t\treturn -EINVAL;\n\n\tattr_name = kmalloc(XATTR_NAME_MAX + 1, GFP_KERNEL);\n\tif (!attr_name)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tif (!eabuf->EaNameLength)\n\t\t\tgoto next;\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"name : <%s>, name_len : %u, value_len : %u, next : %u\\n\",\n\t\t\t    eabuf->name, eabuf->EaNameLength,\n\t\t\t    le16_to_cpu(eabuf->EaValueLength),\n\t\t\t    le32_to_cpu(eabuf->NextEntryOffset));\n\n\t\tif (eabuf->EaNameLength >\n\t\t    (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(attr_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\t\tmemcpy(&attr_name[XATTR_USER_PREFIX_LEN], eabuf->name,\n\t\t       eabuf->EaNameLength);\n\t\tattr_name[XATTR_USER_PREFIX_LEN + eabuf->EaNameLength] = '\\0';\n\t\tvalue = (char *)&eabuf->name + eabuf->EaNameLength + 1;\n\n\t\tif (!eabuf->EaValueLength) {\n\t\t\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t\t\t     path->dentry,\n\t\t\t\t\t\t     attr_name,\n\t\t\t\t\t\t     XATTR_USER_PREFIX_LEN +\n\t\t\t\t\t\t     eabuf->EaNameLength);\n\n\t\t\t/* delete the EA only when it exits */\n\t\t\tif (rc > 0) {\n\t\t\t\trc = ksmbd_vfs_remove_xattr(user_ns,\n\t\t\t\t\t\t\t    path->dentry,\n\t\t\t\t\t\t\t    attr_name);\n\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\t    \"remove xattr failed(%d)\\n\",\n\t\t\t\t\t\t    rc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* if the EA doesn't exist, just do nothing. */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\t\tpath->dentry, attr_name, value,\n\t\t\t\t\t\tle16_to_cpu(eabuf->EaValueLength), 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"ksmbd_vfs_setxattr is failed(%d)\\n\",\n\t\t\t\t\t    rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tnext = le32_to_cpu(eabuf->NextEntryOffset);\n\t\tif (next == 0 || buf_len < next)\n\t\t\tbreak;\n\t\tbuf_len -= next;\n\t\teabuf = (struct smb2_ea_info *)((char *)eabuf + next);\n\t\tif (next < (u32)eabuf->EaNameLength + le16_to_cpu(eabuf->EaValueLength))\n\t\t\tbreak;\n\n\t} while (next != 0);\n\n\tkfree(attr_name);\n\treturn rc;\n}\n\nstatic noinline int smb2_set_stream_name_xattr(struct path *path,\n\t\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t\t       char *stream_name, int s_type)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tsize_t xattr_stream_size;\n\tchar *xattr_stream_name;\n\tint rc;\n\n\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t s_type);\n\tif (rc)\n\t\treturn rc;\n\n\tfp->stream.name = xattr_stream_name;\n\tfp->stream.size = xattr_stream_size;\n\n\t/* Check if there is stream prefix in xattr space */\n\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t     path->dentry,\n\t\t\t\t     xattr_stream_name,\n\t\t\t\t     xattr_stream_size);\n\tif (rc >= 0)\n\t\treturn 0;\n\n\tif (fp->cdoption == FILE_OPEN_LE) {\n\t\tksmbd_debug(SMB, \"XATTR stream name lookup failed: %d\\n\", rc);\n\t\treturn -EBADF;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, path->dentry,\n\t\t\t\txattr_stream_name, NULL, 0, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR stream name :%d\\n\", rc);\n\treturn 0;\n}\n\nstatic int smb2_remove_smb_xattrs(struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], DOS_ATTRIBUTE_PREFIX,\n\t\t\t    DOS_ATTRIBUTE_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\terr = ksmbd_vfs_remove_xattr(user_ns, path->dentry, name);\n\t\tif (err)\n\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic int smb2_create_truncate(struct path *path)\n{\n\tint rc = vfs_truncate(path, 0);\n\n\tif (rc) {\n\t\tpr_err(\"vfs_truncate failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = smb2_remove_smb_xattrs(path);\n\tif (rc == -EOPNOTSUPP)\n\t\trc = 0;\n\tif (rc)\n\t\tksmbd_debug(SMB,\n\t\t\t    \"ksmbd_truncate_stream_name_xattr failed, rc %d\\n\",\n\t\t\t    rc);\n\treturn rc;\n}\n\nstatic void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, struct path *path,\n\t\t\t    struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da = {0};\n\tint rc;\n\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\tda.version = 4;\n\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\tda.itime = da.create_time = fp->create_time;\n\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\tXATTR_DOSINFO_ITIME;\n\n\trc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc)\n\t\tksmbd_debug(SMB, \"failed to store file attribute into xattr\\n\");\n}\n\nstatic void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,\n\t\t\t       struct path *path, struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da;\n\tint rc;\n\n\tfp->f_ci->m_fattr &= ~(FILE_ATTRIBUTE_HIDDEN_LE | FILE_ATTRIBUTE_SYSTEM_LE);\n\n\t/* get FileAttributes from XATTR_NAME_DOS_ATTRIBUTE */\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\trc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc > 0) {\n\t\tfp->f_ci->m_fattr = cpu_to_le32(da.attr);\n\t\tfp->create_time = da.create_time;\n\t\tfp->itime = da.itime;\n\t}\n}\n\nstatic int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,\n\t\t      int open_flags, umode_t posix_mode, bool is_dir)\n{\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tumode_t mode;\n\tint rc;\n\n\tif (!(open_flags & O_CREAT))\n\t\treturn -EBADF;\n\n\tksmbd_debug(SMB, \"file does not exist, so creating\\n\");\n\tif (is_dir == true) {\n\t\tksmbd_debug(SMB, \"creating directory\\n\");\n\n\t\tmode = share_config_directory_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_mkdir(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tksmbd_debug(SMB, \"creating regular file\\n\");\n\n\t\tmode = share_config_create_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_create(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, 0, path, 0);\n\tif (rc) {\n\t\tpr_err(\"cannot get linux path (%s), err = %d\\n\",\n\t\t       name, rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int smb2_create_sd_buffer(struct ksmbd_work *work,\n\t\t\t\t struct smb2_create_req *req,\n\t\t\t\t struct path *path)\n{\n\tstruct create_context *context;\n\tstruct create_sd_buf_req *sd_buf;\n\n\tif (!req->CreateContextsOffset)\n\t\treturn -ENOENT;\n\n\t/* Parse SD BUFFER create contexts */\n\tcontext = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER);\n\tif (!context)\n\t\treturn -ENOENT;\n\telse if (IS_ERR(context))\n\t\treturn PTR_ERR(context);\n\n\tksmbd_debug(SMB,\n\t\t    \"Set ACLs using SMB2_CREATE_SD_BUFFER context\\n\");\n\tsd_buf = (struct create_sd_buf_req *)context;\n\tif (le16_to_cpu(context->DataOffset) +\n\t    le32_to_cpu(context->DataLength) <\n\t    sizeof(struct create_sd_buf_req))\n\t\treturn -EINVAL;\n\treturn set_info_sec(work->conn, work->tcon, path, &sd_buf->ntsd,\n\t\t\t    le32_to_cpu(sd_buf->ccontext.DataLength), true);\n}\n\nstatic void ksmbd_acls_fattr(struct smb_fattr *fattr,\n\t\t\t     struct user_namespace *mnt_userns,\n\t\t\t     struct inode *inode)\n{\n\tfattr->cf_uid = i_uid_into_mnt(mnt_userns, inode);\n\tfattr->cf_gid = i_gid_into_mnt(mnt_userns, inode);\n\tfattr->cf_mode = inode->i_mode;\n\tfattr->cf_acls = NULL;\n\tfattr->cf_dacls = NULL;\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tfattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tfattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);\n\t}\n}\n\n/**\n * smb2_open() - handler for smb file open request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_open(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct path path;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file *filp = NULL;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct kstat stat;\n\tstruct create_context *context;\n\tstruct lease_ctx_info *lc = NULL;\n\tstruct create_ea_buf_req *ea_buf = NULL;\n\tstruct oplock_info *opinfo;\n\t__le32 *next_ptr = NULL;\n\tint req_op_level = 0, open_flags = 0, may_flags = 0, file_info = 0;\n\tint rc = 0;\n\tint contxt_cnt = 0, query_disk_id = 0;\n\tint maximal_access_ctxt = 0, posix_ctxt = 0;\n\tint s_type = 0;\n\tint next_off = 0;\n\tchar *name = NULL;\n\tchar *stream_name = NULL;\n\tbool file_present = false, created = false, already_permitted = false;\n\tint share_ret, need_truncate = 0;\n\tu64 time;\n\tumode_t posix_mode = 0;\n\t__le32 daccess, maximal_access = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (req->hdr.NextCommand && !work->next_smb2_rcv_hdr_off &&\n\t    (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"invalid flag in chained command\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe create request\\n\");\n\t\treturn create_smb2_pipe(work);\n\t}\n\n\tif (req->NameLength) {\n\t\tif ((req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t\t    *(char *)req->Buffer == '\\\\') {\n\t\t\tpr_err(\"not allow directory name included leading slash\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tname = smb2_get_name(req->Buffer,\n\t\t\t\t     le16_to_cpu(req->NameLength),\n\t\t\t\t     work->conn->local_nls);\n\t\tif (IS_ERR(name)) {\n\t\t\trc = PTR_ERR(name);\n\t\t\tif (rc != -ENOMEM)\n\t\t\t\trc = -ENOENT;\n\t\t\tname = NULL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"converted name = %s\\n\", name);\n\t\tif (strchr(name, ':')) {\n\t\t\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t    KSMBD_SHARE_FLAG_STREAMS)) {\n\t\t\t\trc = -EBADF;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\trc = parse_stream_name(name, &stream_name, &s_type);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_out1;\n\t\t}\n\n\t\trc = ksmbd_validate_filename(name);\n\t\tif (rc < 0)\n\t\t\tgoto err_out1;\n\n\t\tif (ksmbd_share_veto_filename(share, name)) {\n\t\t\trc = -ENOENT;\n\t\t\tksmbd_debug(SMB, \"Reject open(), vetoed file: %s\\n\",\n\t\t\t\t    name);\n\t\t\tgoto err_out1;\n\t\t}\n\t} else {\n\t\tname = kstrdup(\"\", GFP_KERNEL);\n\t\tif (!name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out1;\n\t\t}\n\t}\n\n\treq_op_level = req->RequestedOplockLevel;\n\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\n\t\tlc = parse_lease_state(req);\n\n\tif (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {\n\t\tpr_err(\"Invalid impersonationlevel : 0x%x\\n\",\n\t\t       le32_to_cpu(req->ImpersonationLevel));\n\t\trc = -EIO;\n\t\trsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {\n\t\tpr_err(\"Invalid create options : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateOptions));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t} else {\n\t\tif (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&\n\t\t    req->CreateOptions & FILE_RANDOM_ACCESS_LE)\n\t\t\treq->CreateOptions = ~(FILE_SEQUENTIAL_ONLY_LE);\n\n\t\tif (req->CreateOptions &\n\t\t    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |\n\t\t     FILE_RESERVE_OPFILTER_LE)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {\n\t\t\t\treq->CreateOptions = ~(FILE_NO_COMPRESSION_LE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (le32_to_cpu(req->CreateDisposition) >\n\t    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {\n\t\tpr_err(\"Invalid create disposition : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateDisposition));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {\n\t\tpr_err(\"Invalid desired access : 0x%x\\n\",\n\t\t       le32_to_cpu(req->DesiredAccess));\n\t\trc = -EACCES;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {\n\t\tpr_err(\"Invalid file attribute : 0x%x\\n\",\n\t\t       le32_to_cpu(req->FileAttributes));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\t/* Parse non-durable handle create contexts */\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tea_buf = (struct create_ea_buf_req *)context;\n\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t    sizeof(struct create_ea_buf_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\tif (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {\n\t\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"get query maximal access context\\n\");\n\t\t\tmaximal_access_ctxt = 1;\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_TIMEWARP_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get timewarp context\\n\");\n\t\t\trc = -EBADF;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (tcon->posix_extensions) {\n\t\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t\t SMB2_CREATE_TAG_POSIX);\n\t\t\tif (IS_ERR(context)) {\n\t\t\t\trc = PTR_ERR(context);\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (context) {\n\t\t\t\tstruct create_posix *posix =\n\t\t\t\t\t(struct create_posix *)context;\n\t\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t\t    sizeof(struct create_posix) - 4) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto err_out1;\n\t\t\t\t}\n\t\t\t\tksmbd_debug(SMB, \"get posix context\\n\");\n\n\t\t\t\tposix_mode = le32_to_cpu(posix->Mode);\n\t\t\t\tposix_ctxt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out1;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (!rc) {\n\t\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {\n\t\t\t/*\n\t\t\t * If file exists with under flags, return access\n\t\t\t * denied error.\n\t\t\t */\n\t\t\tif (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||\n\t\t\t    req->CreateDisposition == FILE_OPEN_IF_LE) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else if (d_is_symlink(path.dentry)) {\n\t\t\trc = -EACCES;\n\t\t\tpath_put(&path);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto err_out;\n\t\tksmbd_debug(SMB, \"can not get linux path for %s, rc = %d\\n\",\n\t\t\t    name, rc);\n\t\trc = 0;\n\t} else {\n\t\tfile_present = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t}\n\tif (stream_name) {\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\t}\n\t\t} else {\n\t\t\tif (S_ISDIR(stat.mode) && s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\t\t}\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&\n\t\t    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {\n\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\trc = -EIO;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (file_present && req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE &&\n\t    S_ISDIR(stat.mode) && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\tksmbd_debug(SMB, \"open() argument is a directory: %s, %x\\n\",\n\t\t\t    name, req->CreateOptions);\n\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present && (req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t    !(req->CreateDisposition == FILE_CREATE_LE) &&\n\t    !S_ISDIR(stat.mode)) {\n\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!stream_name && file_present &&\n\t    req->CreateDisposition == FILE_CREATE_LE) {\n\t\trc = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tdaccess = smb_map_generic_desired_access(req->DesiredAccess);\n\n\tif (file_present && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\trc = smb_check_perm_dacl(conn, &path, &daccess,\n\t\t\t\t\t sess->user->uid);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (daccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tif (!file_present) {\n\t\t\tdaccess = cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\t} else {\n\t\t\trc = ksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t    &daccess);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\talready_permitted = true;\n\t\t}\n\t\tmaximal_access = daccess;\n\t}\n\n\topen_flags = smb2_create_open_flags(file_present, daccess,\n\t\t\t\t\t    req->CreateDisposition,\n\t\t\t\t\t    &may_flags);\n\n\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tif (open_flags & O_CREAT) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t/*create file if not present */\n\tif (!file_present) {\n\t\trc = smb2_creat(work, &path, name, open_flags, posix_mode,\n\t\t\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcreated = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tif (ea_buf) {\n\t\t\tif (le32_to_cpu(ea_buf->ccontext.DataLength) <\n\t\t\t    sizeof(struct smb2_ea_info)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\trc = smb2_set_ea(&ea_buf->ea,\n\t\t\t\t\t le32_to_cpu(ea_buf->ccontext.DataLength),\n\t\t\t\t\t &path);\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\trc = 0;\n\t\t\telse if (rc)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (!already_permitted) {\n\t\t/* FILE_READ_ATTRIBUTE is allowed without inode_permission,\n\t\t * because execute(search) permission on a parent directory,\n\t\t * is already granted.\n\t\t */\n\t\tif (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {\n\t\t\trc = inode_permission(user_ns,\n\t\t\t\t\t      d_inode(path.dentry),\n\t\t\t\t\t      may_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tif ((daccess & FILE_DELETE_LE) ||\n\t\t\t    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\t\t\trc = ksmbd_vfs_may_delete(user_ns,\n\t\t\t\t\t\t\t  path.dentry);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = ksmbd_query_inode_status(d_inode(path.dentry->d_parent));\n\tif (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\trc = 0;\n\tfilp = dentry_open(&path, open_flags, current_cred());\n\tif (IS_ERR(filp)) {\n\t\trc = PTR_ERR(filp);\n\t\tpr_err(\"dentry open for dir failed, rc %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (file_present) {\n\t\tif (!(open_flags & O_TRUNC))\n\t\t\tfile_info = FILE_OPENED;\n\t\telse\n\t\t\tfile_info = FILE_OVERWRITTEN;\n\n\t\tif ((req->CreateDisposition & FILE_CREATE_MASK_LE) ==\n\t\t    FILE_SUPERSEDE_LE)\n\t\t\tfile_info = FILE_SUPERSEDED;\n\t} else if (open_flags & O_CREAT) {\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tksmbd_vfs_set_fadvise(filp, req->CreateOptions);\n\n\t/* Obtain Volatile-ID */\n\tfp = ksmbd_open_fd(work, filp);\n\tif (IS_ERR(fp)) {\n\t\tfput(filp);\n\t\trc = PTR_ERR(fp);\n\t\tfp = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/* Get Persistent-ID */\n\tksmbd_open_durable_fd(fp);\n\tif (!has_file_id(fp->persistent_id)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfp->cdoption = req->CreateDisposition;\n\tfp->daccess = daccess;\n\tfp->saccess = req->ShareAccess;\n\tfp->coption = req->CreateOptions;\n\n\t/* Set default windows and posix acls if creating new file */\n\tif (created) {\n\t\tint posix_acl_rc;\n\t\tstruct inode *inode = d_inode(path.dentry);\n\n\t\tposix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,\n\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t   d_inode(path.dentry->d_parent));\n\t\tif (posix_acl_rc)\n\t\t\tksmbd_debug(SMB, \"inherit posix acl failed : %d\\n\", posix_acl_rc);\n\n\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\trc = smb_inherit_dacl(conn, &path, sess->user->uid,\n\t\t\t\t\t      sess->user->gid);\n\t\t}\n\n\t\tif (rc) {\n\t\t\trc = smb2_create_sd_buffer(work, req, &path);\n\t\t\tif (rc) {\n\t\t\t\tif (posix_acl_rc)\n\t\t\t\t\tksmbd_vfs_set_init_posix_acl(user_ns,\n\t\t\t\t\t\t\t\t     inode);\n\n\t\t\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\t\t\tstruct smb_fattr fattr;\n\t\t\t\t\tstruct smb_ntsd *pntsd;\n\t\t\t\t\tint pntsd_size, ace_num = 0;\n\n\t\t\t\t\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\t\t\t\t\tif (fattr.cf_acls)\n\t\t\t\t\t\tace_num = fattr.cf_acls->a_count;\n\t\t\t\t\tif (fattr.cf_dacls)\n\t\t\t\t\t\tace_num += fattr.cf_dacls->a_count;\n\n\t\t\t\t\tpntsd = kmalloc(sizeof(struct smb_ntsd) +\n\t\t\t\t\t\t\tsizeof(struct smb_sid) * 3 +\n\t\t\t\t\t\t\tsizeof(struct smb_acl) +\n\t\t\t\t\t\t\tsizeof(struct smb_ace) * ace_num * 2,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!pntsd)\n\t\t\t\t\t\tgoto err_out;\n\n\t\t\t\t\trc = build_sec_desc(user_ns,\n\t\t\t\t\t\t\t    pntsd, NULL,\n\t\t\t\t\t\t\t    OWNER_SECINFO |\n\t\t\t\t\t\t\t    GROUP_SECINFO |\n\t\t\t\t\t\t\t    DACL_SECINFO,\n\t\t\t\t\t\t\t    &pntsd_size, &fattr);\n\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = ksmbd_vfs_set_sd_xattr(conn,\n\t\t\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t\t    pntsd,\n\t\t\t\t\t\t\t\t    pntsd_size);\n\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tpr_err(\"failed to store ntacl in xattr : %d\\n\",\n\t\t\t\t\t\t       rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\trc = smb2_set_stream_name_xattr(&path,\n\t\t\t\t\t\tfp,\n\t\t\t\t\t\tstream_name,\n\t\t\t\t\t\ts_type);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tfp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));\n\tif (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&\n\t    !fp->attrib_only && !stream_name) {\n\t\tsmb_break_all_oplock(work, fp);\n\t\tneed_truncate = 1;\n\t}\n\n\t/* fp should be searchable through ksmbd_inode.m_fp_list\n\t * after daccess, saccess, attrib_only, and stream are\n\t * initialized.\n\t */\n\twrite_lock(&fp->f_ci->m_lock);\n\tlist_add(&fp->node, &fp->f_ci->m_fp_list);\n\twrite_unlock(&fp->f_ci->m_lock);\n\n\trc = ksmbd_vfs_getattr(&path, &stat);\n\tif (rc) {\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t\trc = 0;\n\t}\n\n\t/* Check delete pending among previous fp before oplock break */\n\tif (ksmbd_inode_pending_delete(fp)) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tshare_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);\n\tif (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||\n\t    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&\n\t     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {\n\t\tif (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\t\trc = share_ret;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) {\n\t\t\treq_op_level = smb2_map_lease_to_oplock(lc->req_state);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"lease req for(%s) req oplock state 0x%x, lease state 0x%x\\n\",\n\t\t\t\t    name, req_op_level, lc->req_state);\n\t\t\trc = find_same_lease_key(sess, fp->f_ci, lc);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t} else if (open_flags == O_RDONLY &&\n\t\t\t   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t\trc = smb_grant_oplock(work, req_op_level,\n\t\t\t\t      fp->persistent_id, fp,\n\t\t\t\t      le32_to_cpu(req->hdr.Id.SyncId.TreeId),\n\t\t\t\t      lc, share_ret);\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)\n\t\tksmbd_fd_set_delete_on_close(fp, file_info);\n\n\tif (need_truncate) {\n\t\trc = smb2_create_truncate(&path);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\tstruct create_alloc_size_req *az_req;\n\n\t\taz_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,\n\t\t\t\t\tSMB2_CREATE_ALLOCATION_SIZE);\n\t\tif (IS_ERR(az_req)) {\n\t\t\trc = PTR_ERR(az_req);\n\t\t\tgoto err_out;\n\t\t} else if (az_req) {\n\t\t\tloff_t alloc_size;\n\t\t\tint err;\n\n\t\t\tif (le16_to_cpu(az_req->ccontext.DataOffset) +\n\t\t\t    le32_to_cpu(az_req->ccontext.DataLength) <\n\t\t\t    sizeof(struct create_alloc_size_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\talloc_size = le64_to_cpu(az_req->AllocationSize);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"request smb2 create allocate size : %llu\\n\",\n\t\t\t\t    alloc_size);\n\t\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\t\terr = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t\t    alloc_size);\n\t\t\tif (err < 0)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"vfs_fallocate is failed : %d\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get query on disk id context\\n\");\n\t\t\tquery_disk_id = 1;\n\t\t}\n\t}\n\n\tif (stat.result_mask & STATX_BTIME)\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.btime);\n\telse\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.ctime);\n\tif (req->FileAttributes || fp->f_ci->m_fattr == 0)\n\t\tfp->f_ci->m_fattr =\n\t\t\tcpu_to_le32(smb2_get_dos_mode(&stat, le32_to_cpu(req->FileAttributes)));\n\n\tif (!created)\n\t\tsmb2_update_xattrs(tcon, &path, fp);\n\telse\n\t\tsmb2_new_xattrs(tcon, &path, fp);\n\n\tmemcpy(fp->client_guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\n\tgeneric_fillattr(user_ns, file_inode(fp->filp),\n\t\t\t &stat);\n\n\trsp->StructureSize = cpu_to_le16(89);\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;\n\trcu_read_unlock();\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(file_info);\n\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\trsp->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\trsp->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\trsp->ChangeTime = cpu_to_le64(time);\n\trsp->AllocationSize = S_ISDIR(stat.mode) ? 0 :\n\t\tcpu_to_le64(stat.blocks << 9);\n\trsp->EndofFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\trsp->FileAttributes = fp->f_ci->m_fattr;\n\n\trsp->Reserved2 = 0;\n\n\trsp->PersistentFileId = fp->persistent_id;\n\trsp->VolatileFileId = fp->volatile_id;\n\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\n\t/* If lease is request send lease context response */\n\tif (opinfo && opinfo->is_lease) {\n\t\tstruct create_context *lease_ccontext;\n\n\t\tksmbd_debug(SMB, \"lease granted on(%s) lease state 0x%x\\n\",\n\t\t\t    name, opinfo->o_lease->state);\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\n\t\tlease_ccontext = (struct create_context *)rsp->Buffer;\n\t\tcontxt_cnt++;\n\t\tcreate_lease_buf(rsp->Buffer, opinfo->o_lease);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_lease_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_lease_size);\n\t\tnext_ptr = &lease_ccontext->Next;\n\t\tnext_off = conn->vals->create_lease_size;\n\t}\n\n\tif (maximal_access_ctxt) {\n\t\tstruct create_context *mxac_ccontext;\n\n\t\tif (maximal_access == 0)\n\t\t\tksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t       path.dentry,\n\t\t\t\t\t\t       &maximal_access);\n\t\tmxac_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_mxac_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tle32_to_cpu(maximal_access));\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_mxac_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_mxac_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &mxac_ccontext->Next;\n\t\tnext_off = conn->vals->create_mxac_size;\n\t}\n\n\tif (query_disk_id) {\n\t\tstruct create_context *disk_id_ccontext;\n\n\t\tdisk_id_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_disk_id_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tstat.ino, tcon->id);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_disk_id_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_disk_id_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &disk_id_ccontext->Next;\n\t\tnext_off = conn->vals->create_disk_id_size;\n\t}\n\n\tif (posix_ctxt) {\n\t\tcontxt_cnt++;\n\t\tcreate_posix_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tfp);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_posix_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_posix_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t}\n\n\tif (contxt_cnt > 0) {\n\t\trsp->CreateContextsOffset =\n\t\t\tcpu_to_le32(offsetof(struct smb2_create_rsp, Buffer));\n\t}\n\nerr_out:\n\tif (file_present || created)\n\t\tpath_put(&path);\n\tksmbd_revert_fsids(work);\nerr_out1:\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (rc == -EOPNOTSUPP)\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\telse if (rc == -EACCES || rc == -ESTALE || rc == -EXDEV)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\t\telse if (rc == -EPERM)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (rc == -EBUSY)\n\t\t\trsp->hdr.Status = STATUS_DELETE_PENDING;\n\t\telse if (rc == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\telse if (rc == -ENOEXEC)\n\t\t\trsp->hdr.Status = STATUS_DUPLICATE_OBJECTID;\n\t\telse if (rc == -ENXIO)\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_DEVICE;\n\t\telse if (rc == -EEXIST)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\t\telse if (rc == -EMFILE)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\tif (!rsp->hdr.Status)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\t\tif (fp)\n\t\t\tksmbd_fd_put(work, fp);\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_debug(SMB, \"Error response: %x\\n\", rsp->hdr.Status);\n\t}\n\n\tkfree(name);\n\tkfree(lc);\n\n\treturn 0;\n}\n\nstatic int readdir_info_level_struct_sz(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_full_directory_info);\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_both_directory_info);\n\tcase FILE_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_directory_info);\n\tcase FILE_NAMES_INFORMATION:\n\t\treturn sizeof(struct file_names_info);\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_full_dir_info);\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_both_directory_info);\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treturn sizeof(struct smb2_posix_info);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dentry_name(struct ksmbd_dir_info *d_info, int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(ffdinfo->NextEntryOffset);\n\t\td_info->name = ffdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(ffdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fbdinfo->NextEntryOffset);\n\t\td_info->name = fbdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fbdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fdinfo->NextEntryOffset);\n\t\td_info->name = fdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fninfo->NextEntryOffset);\n\t\td_info->name = fninfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fninfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(dinfo->NextEntryOffset);\n\t\td_info->name = dinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(dinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fibdinfo->NextEntryOffset);\n\t\td_info->name = fibdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fibdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(posix_info->NextEntryOffset);\n\t\td_info->name = posix_info->name;\n\t\td_info->name_len = le32_to_cpu(posix_info->name_len);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * smb2_populate_readdir_entry() - encode directory entry in smb2 response\n * buffer\n * @conn:\tconnection instance\n * @info_level:\tsmb information level\n * @d_info:\tstructure included variables for query dir\n * @ksmbd_kstat:\tksmbd wrapper of dirent stat information\n *\n * if directory has many entries, find first can't read it fully.\n * find next might be called multiple times to read remaining dir entries\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,\n\t\t\t\t       struct ksmbd_dir_info *d_info,\n\t\t\t\t       struct ksmbd_kstat *ksmbd_kstat)\n{\n\tint next_entry_offset = 0;\n\tchar *conv_name;\n\tint conv_len;\n\tvoid *kstat;\n\tint struct_sz, rc = 0;\n\n\tconv_name = ksmbd_convert_dir_info_name(d_info,\n\t\t\t\t\t\tconn->local_nls,\n\t\t\t\t\t\t&conv_len);\n\tif (!conv_name)\n\t\treturn -ENOMEM;\n\n\t/* Somehow the name has only terminating NULL bytes */\n\tif (conv_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto free_conv_name;\n\t}\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level) - 1 + conv_len;\n\tnext_entry_offset = ALIGN(struct_sz, KSMBD_DIR_INFO_ALIGNMENT);\n\td_info->last_entry_off_align = next_entry_offset - struct_sz;\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\trc = -ENOSPC;\n\t\tgoto free_conv_name;\n\t}\n\n\tkstat = d_info->wptr;\n\tif (info_level != FILE_NAMES_INFORMATION)\n\t\tkstat = ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)kstat;\n\t\tffdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tffdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (ffdinfo->EaSize)\n\t\t\tffdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tffdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(ffdinfo->FileName, conv_name, conv_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)kstat;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfbdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fbdinfo->EaSize)\n\t\t\tfbdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfbdinfo->ShortNameLength = 0;\n\t\tfbdinfo->Reserved = 0;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfbdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fbdinfo->FileName, conv_name, conv_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)kstat;\n\t\tfdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fdinfo->FileName, conv_name, conv_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)kstat;\n\t\tfninfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tmemcpy(fninfo->FileName, conv_name, conv_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)kstat;\n\t\tdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (dinfo->EaSize)\n\t\t\tdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tdinfo->Reserved = 0;\n\t\tdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(dinfo->FileName, conv_name, conv_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)kstat;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfibdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fibdinfo->EaSize)\n\t\t\tfibdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tfibdinfo->ShortNameLength = 0;\n\t\tfibdinfo->Reserved = 0;\n\t\tfibdinfo->Reserved2 = cpu_to_le16(0);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfibdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fibdinfo->FileName, conv_name, conv_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\t\tu64 time;\n\n\t\tposix_info = (struct smb2_posix_info *)kstat;\n\t\tposix_info->Ignored = 0;\n\t\tposix_info->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\t\tposix_info->ChangeTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->atime);\n\t\tposix_info->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->mtime);\n\t\tposix_info->LastWriteTime = cpu_to_le64(time);\n\t\tposix_info->EndOfFile = cpu_to_le64(ksmbd_kstat->kstat->size);\n\t\tposix_info->AllocationSize = cpu_to_le64(ksmbd_kstat->kstat->blocks << 9);\n\t\tposix_info->DeviceId = cpu_to_le32(ksmbd_kstat->kstat->rdev);\n\t\tposix_info->HardLinks = cpu_to_le32(ksmbd_kstat->kstat->nlink);\n\t\tposix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode);\n\t\tposix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tposix_info->DosAttributes =\n\t\t\tS_ISDIR(ksmbd_kstat->kstat->mode) ?\n\t\t\t\tFILE_ATTRIBUTE_DIRECTORY_LE : FILE_ATTRIBUTE_ARCHIVE_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tposix_info->DosAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tid_to_sid(from_kuid_munged(&init_user_ns, ksmbd_kstat->kstat->uid),\n\t\t\t  SIDNFS_USER, (struct smb_sid *)&posix_info->SidBuffer[0]);\n\t\tid_to_sid(from_kgid_munged(&init_user_ns, ksmbd_kstat->kstat->gid),\n\t\t\t  SIDNFS_GROUP, (struct smb_sid *)&posix_info->SidBuffer[20]);\n\t\tmemcpy(posix_info->name, conv_name, conv_len);\n\t\tposix_info->name_len = cpu_to_le32(conv_len);\n\t\tposix_info->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\n\t} /* switch (info_level) */\n\n\td_info->last_entry_offset = d_info->data_count;\n\td_info->data_count += next_entry_offset;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\n\tksmbd_debug(SMB,\n\t\t    \"info_level : %d, buf_len :%d, next_offset : %d, data_count : %d\\n\",\n\t\t    info_level, d_info->out_buf_len,\n\t\t    next_entry_offset, d_info->data_count);\n\nfree_conv_name:\n\tkfree(conv_name);\n\treturn rc;\n}\n\nstruct smb2_query_dir_private {\n\tstruct ksmbd_work\t*work;\n\tchar\t\t\t*search_pattern;\n\tstruct ksmbd_file\t*dir_fp;\n\n\tstruct ksmbd_dir_info\t*d_info;\n\tint\t\t\tinfo_level;\n};\n\nstatic void lock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n}\n\nstatic void unlock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_unlock(d_inode(dir));\n}\n\nstatic int process_query_dir_entries(struct smb2_query_dir_private *priv)\n{\n\tstruct user_namespace\t*user_ns = file_mnt_user_ns(priv->dir_fp->filp);\n\tstruct kstat\t\tkstat;\n\tstruct ksmbd_kstat\tksmbd_kstat;\n\tint\t\t\trc;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < priv->d_info->num_entry; i++) {\n\t\tstruct dentry *dent;\n\n\t\tif (dentry_name(priv->d_info, priv->info_level))\n\t\t\treturn -EINVAL;\n\n\t\tlock_dir(priv->dir_fp);\n\t\tdent = lookup_one(user_ns, priv->d_info->name,\n\t\t\t\t  priv->dir_fp->filp->f_path.dentry,\n\t\t\t\t  priv->d_info->name_len);\n\t\tunlock_dir(priv->dir_fp);\n\n\t\tif (IS_ERR(dent)) {\n\t\t\tksmbd_debug(SMB, \"Cannot lookup `%s' [%ld]\\n\",\n\t\t\t\t    priv->d_info->name,\n\t\t\t\t    PTR_ERR(dent));\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(d_is_negative(dent))) {\n\t\t\tdput(dent);\n\t\t\tksmbd_debug(SMB, \"Negative dentry `%s'\\n\",\n\t\t\t\t    priv->d_info->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tksmbd_kstat.kstat = &kstat;\n\t\tif (priv->info_level != FILE_NAMES_INFORMATION)\n\t\t\tksmbd_vfs_fill_dentry_attrs(priv->work,\n\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t    dent,\n\t\t\t\t\t\t    &ksmbd_kstat);\n\n\t\trc = smb2_populate_readdir_entry(priv->work->conn,\n\t\t\t\t\t\t priv->info_level,\n\t\t\t\t\t\t priv->d_info,\n\t\t\t\t\t\t &ksmbd_kstat);\n\t\tdput(dent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int reserve_populate_dentry(struct ksmbd_dir_info *d_info,\n\t\t\t\t   int info_level)\n{\n\tint struct_sz;\n\tint conv_len;\n\tint next_entry_offset;\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level);\n\tif (struct_sz == -EOPNOTSUPP)\n\t\treturn -EOPNOTSUPP;\n\n\tconv_len = (d_info->name_len + 1) * 2;\n\tnext_entry_offset = ALIGN(struct_sz - 1 + conv_len,\n\t\t\t\t  KSMBD_DIR_INFO_ALIGNMENT);\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\treturn -ENOSPC;\n\t}\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->wptr;\n\t\tmemcpy(ffdinfo->FileName, d_info->name, d_info->name_len);\n\t\tffdinfo->FileName[d_info->name_len] = 0x00;\n\t\tffdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fbdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfbdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->wptr;\n\t\tmemcpy(fdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->wptr;\n\t\tmemcpy(fninfo->FileName, d_info->name, d_info->name_len);\n\t\tfninfo->FileName[d_info->name_len] = 0x00;\n\t\tfninfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->wptr;\n\t\tmemcpy(dinfo->FileName, d_info->name, d_info->name_len);\n\t\tdinfo->FileName[d_info->name_len] = 0x00;\n\t\tdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fibdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfibdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->wptr;\n\t\tmemcpy(posix_info->name, d_info->name, d_info->name_len);\n\t\tposix_info->name[d_info->name_len] = 0x00;\n\t\tposix_info->name_len = cpu_to_le32(d_info->name_len);\n\t\tposix_info->NextEntryOffset =\n\t\t\tcpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\t} /* switch (info_level) */\n\n\td_info->num_entry++;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\treturn 0;\n}\n\nstatic int __query_dir(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data\t*buf;\n\tstruct smb2_query_dir_private\t*priv;\n\tstruct ksmbd_dir_info\t\t*d_info;\n\tint\t\t\t\trc;\n\n\tbuf\t= container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tpriv\t= buf->private;\n\td_info\t= priv->d_info;\n\n\t/* dot and dotdot entries are already reserved */\n\tif (!strcmp(\".\", name) || !strcmp(\"..\", name))\n\t\treturn 0;\n\tif (ksmbd_share_veto_filename(priv->work->tcon->share_conf, name))\n\t\treturn 0;\n\tif (!match_pattern(name, namlen, priv->search_pattern))\n\t\treturn 0;\n\n\td_info->name\t\t= name;\n\td_info->name_len\t= namlen;\n\trc = reserve_populate_dentry(d_info, priv->info_level);\n\tif (rc)\n\t\treturn rc;\n\tif (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {\n\t\td_info->out_buf_len = 0;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void restart_ctx(struct dir_context *ctx)\n{\n\tctx->pos = 0;\n}\n\nstatic int verify_info_level(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\tcase FILE_DIRECTORY_INFORMATION:\n\tcase FILE_NAMES_INFORMATION:\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}\n\nint smb2_query_dir(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tstruct ksmbd_file *dir_fp = NULL;\n\tstruct ksmbd_dir_info d_info;\n\tint rc = 0;\n\tchar *srch_ptr = NULL;\n\tunsigned char srch_flag;\n\tint buffer_sz;\n\tstruct smb2_query_dir_private query_dir_private = {NULL, };\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = verify_info_level(req->FileInformationClass);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_out2;\n\t}\n\n\tdir_fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!dir_fp) {\n\t\trc = -EBADF;\n\t\tgoto err_out2;\n\t}\n\n\tif (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||\n\t    inode_permission(file_mnt_user_ns(dir_fp->filp),\n\t\t\t     file_inode(dir_fp->filp),\n\t\t\t     MAY_READ | MAY_EXEC)) {\n\t\tpr_err(\"no right to enumerate directory (%pd)\\n\",\n\t\t       dir_fp->filp->f_path.dentry);\n\t\trc = -EACCES;\n\t\tgoto err_out2;\n\t}\n\n\tif (!S_ISDIR(file_inode(dir_fp->filp)->i_mode)) {\n\t\tpr_err(\"can't do query dir for a file\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tsrch_flag = req->Flags;\n\tsrch_ptr = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->FileNameLength), 1,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(srch_ptr)) {\n\t\tksmbd_debug(SMB, \"Search Pattern not found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t} else {\n\t\tksmbd_debug(SMB, \"Search pattern is %s\\n\", srch_ptr);\n\t}\n\n\tif (srch_flag & SMB2_REOPEN || srch_flag & SMB2_RESTART_SCANS) {\n\t\tksmbd_debug(SMB, \"Restart directory scan\\n\");\n\t\tgeneric_file_llseek(dir_fp->filp, 0, SEEK_SET);\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\t}\n\n\tmemset(&d_info, 0, sizeof(struct ksmbd_dir_info));\n\td_info.wptr = (char *)rsp->Buffer;\n\td_info.rptr = (char *)rsp->Buffer;\n\td_info.out_buf_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (d_info.out_buf_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\td_info.flags = srch_flag;\n\n\t/*\n\t * reserve dot and dotdot entries in head of buffer\n\t * in first response\n\t */\n\trc = ksmbd_populate_dot_dotdot_entries(work, req->FileInformationClass,\n\t\t\t\t\t       dir_fp, &d_info, srch_ptr,\n\t\t\t\t\t       smb2_populate_readdir_entry);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\telse if (rc)\n\t\tgoto err_out;\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_HIDE_DOT_FILES))\n\t\td_info.hide_dot_file = true;\n\n\tbuffer_sz\t\t\t\t= d_info.out_buf_len;\n\td_info.rptr\t\t\t\t= d_info.wptr;\n\tquery_dir_private.work\t\t\t= work;\n\tquery_dir_private.search_pattern\t= srch_ptr;\n\tquery_dir_private.dir_fp\t\t= dir_fp;\n\tquery_dir_private.d_info\t\t= &d_info;\n\tquery_dir_private.info_level\t\t= req->FileInformationClass;\n\tdir_fp->readdir_data.private\t\t= &query_dir_private;\n\tset_ctx_actor(&dir_fp->readdir_data.ctx, __query_dir);\n\n\trc = iterate_dir(dir_fp->filp, &dir_fp->readdir_data.ctx);\n\t/*\n\t * req->OutputBufferLength is too small to contain even one entry.\n\t * In this case, it immediately returns OutputBufferLength 0 to client.\n\t */\n\tif (!d_info.out_buf_len && !d_info.num_entry)\n\t\tgoto no_buf_len;\n\tif (rc == 0)\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\tif (rc)\n\t\tgoto err_out;\n\n\td_info.wptr = d_info.rptr;\n\td_info.out_buf_len = buffer_sz;\n\trc = process_query_dir_entries(&query_dir_private);\n\tif (rc)\n\t\tgoto err_out;\n\n\tif (!d_info.data_count && d_info.out_buf_len >= 0) {\n\t\tif (srch_flag & SMB2_RETURN_SINGLE_ENTRY && !is_asterisk(srch_ptr)) {\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\t\t} else {\n\t\t\tdir_fp->dot_dotdot[0] = dir_fp->dot_dotdot[1] = 0;\n\t\t\trsp->hdr.Status = STATUS_NO_MORE_FILES;\n\t\t}\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(0);\n\t\trsp->OutputBufferLength = cpu_to_le32(0);\n\t\trsp->Buffer[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, 9);\n\t} else {\nno_buf_len:\n\t\t((struct file_directory_info *)\n\t\t((char *)rsp->Buffer + d_info.last_entry_offset))\n\t\t->NextEntryOffset = 0;\n\t\tif (d_info.data_count >= d_info.last_entry_off_align)\n\t\t\td_info.data_count -= d_info.last_entry_off_align;\n\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(72);\n\t\trsp->OutputBufferLength = cpu_to_le32(d_info.data_count);\n\t\tinc_rfc1001_len(work->response_buf, 8 + d_info.data_count);\n\t}\n\n\tkfree(srch_ptr);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n\nerr_out:\n\tpr_err(\"error while processing smb2 query dir rc = %d\\n\", rc);\n\tkfree(srch_ptr);\n\nerr_out2:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\telse if (rc == -EBADF)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tif (!rsp->hdr.Status)\n\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n}\n\n/**\n * buffer_check_err() - helper function to check buffer errors\n * @reqOutputBufferLength:\tmax buffer length expected in command response\n * @rsp:\t\tquery info response buffer contains output buffer length\n * @rsp_org:\t\tbase response buffer pointer in case of chained response\n * @infoclass_size:\tquery info class response buffer size\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int buffer_check_err(int reqOutputBufferLength,\n\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t    void *rsp_org, int infoclass_size)\n{\n\tif (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {\n\t\tif (reqOutputBufferLength < infoclass_size) {\n\t\t\tpr_err(\"Invalid Buffer Size Requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;\n\t\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"Buffer Overflow\\n\");\n\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr) +\n\t\t\t\treqOutputBufferLength);\n\t\trsp->OutputBufferLength = cpu_to_le32(reqOutputBufferLength);\n\t}\n\treturn 0;\n}\n\nstatic void get_standard_info_pipe(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\n\tsinfo->AllocationSize = cpu_to_le64(4096);\n\tsinfo->EndOfFile = cpu_to_le64(0);\n\tsinfo->NumberOfLinks = cpu_to_le32(1);\n\tsinfo->DeletePending = 1;\n\tsinfo->Directory = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\n\t/* any unique number */\n\tfile_info->IndexNumber = cpu_to_le64(num | (1ULL << 63));\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int smb2_get_info_file_pipe(struct ksmbd_session *sess,\n\t\t\t\t   struct smb2_query_info_req *req,\n\t\t\t\t   struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tu64 id;\n\tint rc;\n\n\t/*\n\t * Windows can sometime send query file info request on\n\t * pipe without opening it, checking error condition here\n\t */\n\tid = req->VolatileFileId;\n\tif (!ksmbd_session_rpc_method(sess, id))\n\t\treturn -ENOENT;\n\n\tksmbd_debug(SMB, \"FileInfoClass %u, FileId 0x%llx\\n\",\n\t\t    req->FileInfoClass, req->VolatileFileId);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_standard_info_pipe(rsp, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_STANDARD_INFORMATION_SIZE);\n\t\tbreak;\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_internal_info_pipe(rsp, id, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_INTERNAL_INFORMATION_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"smb2_info_file_pipe for %u not supported\\n\",\n\t\t\t    req->FileInfoClass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/**\n * smb2_get_ea() - handler for smb2 get extended attribute command\n * @work:\tsmb work containing query info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\tget extended attribute request\n * @rsp:\tresponse buffer pointer\n * @rsp_org:\tbase response buffer pointer in case of chained response\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t       struct smb2_query_info_req *req,\n\t\t       struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_ea_info *eainfo, *prev_eainfo;\n\tchar *name, *ptr, *xattr_list = NULL, *buf;\n\tint rc, name_len, value_len, xattr_list_len, idx;\n\tssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;\n\tstruct smb2_ea_info_req *ea_req = NULL;\n\tstruct path *path;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\n\tif (!(fp->daccess & FILE_READ_EA_LE)) {\n\t\tpr_err(\"Not permitted to read ext attr : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tpath = &fp->filp->f_path;\n\t/* single EA entry is requested with given user.* name */\n\tif (req->InputBufferLength) {\n\t\tif (le32_to_cpu(req->InputBufferLength) <\n\t\t    sizeof(struct smb2_ea_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tea_req = (struct smb2_ea_info_req *)req->Buffer;\n\t} else {\n\t\t/* need to send all EAs, if no specific EA is requested*/\n\t\tif (le32_to_cpu(req->Flags) & SL_RETURN_SINGLE_ENTRY)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"All EAs are requested but need to send single EA entry in rsp flags 0x%x\\n\",\n\t\t\t\t    le32_to_cpu(req->Flags));\n\t}\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\treturn -EINVAL;\n\n\trc = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (rc < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tgoto out;\n\t} else if (!rc) { /* there is no EA in the file */\n\t\tksmbd_debug(SMB, \"no ea data in the file\\n\");\n\t\tgoto done;\n\t}\n\txattr_list_len = rc;\n\n\tptr = (char *)rsp->Buffer;\n\teainfo = (struct smb2_ea_info *)ptr;\n\tprev_eainfo = eainfo;\n\tidx = 0;\n\n\twhile (idx < xattr_list_len) {\n\t\tname = xattr_list + idx;\n\t\tname_len = strlen(name);\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", name, name_len);\n\t\tidx += name_len + 1;\n\n\t\t/*\n\t\t * CIFS does not support EA other than user.* namespace,\n\t\t * still keep the framework generic, to list other attrs\n\t\t * in future.\n\t\t */\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,\n\t\t\t     STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (req->InputBufferLength &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], ea_req->name,\n\t\t\t    ea_req->EaNameLength))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN],\n\t\t\t     DOS_ATTRIBUTE_PREFIX, DOS_ATTRIBUTE_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tname_len -= XATTR_USER_PREFIX_LEN;\n\n\t\tptr = (char *)(&eainfo->name + name_len + 1);\n\t\tbuf_free_len -= (offsetof(struct smb2_ea_info, name) +\n\t\t\t\tname_len + 1);\n\t\t/* bailout if xattr can't fit in buf_free_len */\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns, path->dentry,\n\t\t\t\t\t       name, &buf);\n\t\tif (value_len <= 0) {\n\t\t\trc = -ENOENT;\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_free_len -= value_len;\n\t\tif (buf_free_len < 0) {\n\t\t\tkfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, buf, value_len);\n\t\tkfree(buf);\n\n\t\tptr += value_len;\n\t\teainfo->Flags = 0;\n\t\teainfo->EaNameLength = name_len;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tmemcpy(eainfo->name, &name[XATTR_USER_PREFIX_LEN],\n\t\t\t       name_len);\n\t\telse\n\t\t\tmemcpy(eainfo->name, name, name_len);\n\n\t\teainfo->name[name_len] = '\\0';\n\t\teainfo->EaValueLength = cpu_to_le16(value_len);\n\t\tnext_offset = offsetof(struct smb2_ea_info, name) +\n\t\t\tname_len + 1 + value_len;\n\n\t\t/* align next xattr entry at 4 byte bundary */\n\t\talignment_bytes = ((next_offset + 3) & ~3) - next_offset;\n\t\tif (alignment_bytes) {\n\t\t\tmemset(ptr, '\\0', alignment_bytes);\n\t\t\tptr += alignment_bytes;\n\t\t\tnext_offset += alignment_bytes;\n\t\t\tbuf_free_len -= alignment_bytes;\n\t\t}\n\t\teainfo->NextEntryOffset = cpu_to_le32(next_offset);\n\t\tprev_eainfo = eainfo;\n\t\teainfo = (struct smb2_ea_info *)ptr;\n\t\trsp_data_cnt += next_offset;\n\n\t\tif (req->InputBufferLength) {\n\t\t\tksmbd_debug(SMB, \"single entry requested\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no more ea entries */\n\tprev_eainfo->NextEntryOffset = 0;\ndone:\n\trc = 0;\n\tif (rsp_data_cnt == 0)\n\t\trsp->hdr.Status = STATUS_NO_EAS_ON_FILE;\n\trsp->OutputBufferLength = cpu_to_le32(rsp_data_cnt);\n\tinc_rfc1001_len(rsp_org, rsp_data_cnt);\nout:\n\tkvfree(xattr_list);\n\treturn rc;\n}\n\nstatic void get_file_access_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_access_info *file_info;\n\n\tfile_info = (struct smb2_file_access_info *)rsp->Buffer;\n\tfile_info->AccessFlags = fp->daccess;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_access_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_access_info));\n}\n\nstatic int get_file_basic_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_basic_info *basic_info;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tbasic_info = (struct smb2_file_basic_info *)rsp->Buffer;\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tbasic_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tbasic_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tbasic_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tbasic_info->ChangeTime = cpu_to_le64(time);\n\tbasic_info->Attributes = fp->f_ci->m_fattr;\n\tbasic_info->Pad1 = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_basic_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_basic_info));\n\treturn 0;\n}\n\nstatic unsigned long long get_allocation_size(struct inode *inode,\n\t\t\t\t\t      struct kstat *stat)\n{\n\tunsigned long long alloc_size = 0;\n\n\tif (!S_ISDIR(stat->mode)) {\n\t\tif ((inode->i_blocks << 9) <= stat->size)\n\t\t\talloc_size = stat->size;\n\t\telse\n\t\t\talloc_size = inode->i_blocks << 9;\n\t}\n\n\treturn alloc_size;\n}\n\nstatic void get_file_standard_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\n\tsinfo->AllocationSize = cpu_to_le64(get_allocation_size(inode, &stat));\n\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tsinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);\n\tsinfo->DeletePending = delete_pending;\n\tsinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_file_alignment_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct smb2_file_alignment_info *file_info;\n\n\tfile_info = (struct smb2_file_alignment_info *)rsp->Buffer;\n\tfile_info->AlignmentRequirement = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alignment_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_alignment_info));\n}\n\nstatic int get_file_all_info(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_rsp *rsp,\n\t\t\t     struct ksmbd_file *fp,\n\t\t\t     void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_all_info *file_info;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tint conv_len;\n\tchar *filename;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tksmbd_debug(SMB, \"no right to read the attributes : 0x%x\\n\",\n\t\t\t    fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfilename = convert_to_nt_pathname(work->tcon->share_conf, &fp->filp->f_path);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tksmbd_debug(SMB, \"filename = %s\\n\", filename);\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\tfile_info = (struct smb2_file_all_info *)rsp->Buffer;\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->Pad1 = 0;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->NumberOfLinks =\n\t\t\tcpu_to_le32(get_nlink(&stat) - delete_pending);\n\tfile_info->DeletePending = delete_pending;\n\tfile_info->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\tfile_info->Pad2 = 0;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\tfile_info->EASize = 0;\n\tfile_info->AccessFlags = fp->daccess;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\tfile_info->Mode = fp->coption;\n\tfile_info->AlignmentRequirement = 0;\n\tconv_len = smbConvertToUTF16((__le16 *)file_info->FileName, filename,\n\t\t\t\t     PATH_MAX, conn->local_nls, 0);\n\tconv_len *= 2;\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_all_info) + conv_len - 1);\n\tkfree(filename);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n\treturn 0;\n}\n\nstatic void get_file_alternate_info(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_alt_name_info *file_info;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint conv_len;\n\n\tspin_lock(&dentry->d_lock);\n\tfile_info = (struct smb2_file_alt_name_info *)rsp->Buffer;\n\tconv_len = ksmbd_extract_shortname(conn,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   file_info->FileName);\n\tspin_unlock(&dentry->d_lock);\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alt_name_info) + conv_len);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n}\n\nstatic void get_file_stream_info(struct ksmbd_work *work,\n\t\t\t\t struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp,\n\t\t\t\t void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_stream_info *file_info;\n\tchar *stream_name, *xattr_list = NULL, *stream_buf;\n\tstruct kstat stat;\n\tstruct path *path = &fp->filp->f_path;\n\tssize_t xattr_list_len;\n\tint nbytes = 0, streamlen, stream_name_len, next, idx = 0;\n\tint buf_free_len;\n\tstruct smb2_query_info_req *req = ksmbd_req_buf_next(work);\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_stream_info *)rsp->Buffer;\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\tgoto out;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (idx < xattr_list_len) {\n\t\tstream_name = xattr_list + idx;\n\t\tstreamlen = strlen(stream_name);\n\t\tidx += streamlen + 1;\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", stream_name, streamlen);\n\n\t\tif (strncmp(&stream_name[XATTR_USER_PREFIX_LEN],\n\t\t\t    STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tstream_name_len = streamlen - (XATTR_USER_PREFIX_LEN +\n\t\t\t\tSTREAM_PREFIX_LEN);\n\t\tstreamlen = stream_name_len;\n\n\t\t/* plus : size */\n\t\tstreamlen += 1;\n\t\tstream_buf = kmalloc(streamlen + 1, GFP_KERNEL);\n\t\tif (!stream_buf)\n\t\t\tbreak;\n\n\t\tstreamlen = snprintf(stream_buf, streamlen + 1,\n\t\t\t\t     \":%s\", &stream_name[XATTR_NAME_STREAM_LEN]);\n\n\t\tnext = sizeof(struct smb2_file_stream_info) + streamlen * 2;\n\t\tif (next > buf_free_len) {\n\t\t\tkfree(stream_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tfile_info = (struct smb2_file_stream_info *)&rsp->Buffer[nbytes];\n\t\tstreamlen  = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t       stream_buf, streamlen,\n\t\t\t\t\t       conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tkfree(stream_buf);\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stream_name_len);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stream_name_len);\n\n\t\tnbytes += next;\n\t\tbuf_free_len -= next;\n\t\tfile_info->NextEntryOffset = cpu_to_le32(next);\n\t}\n\nout:\n\tif (!S_ISDIR(stat.mode) &&\n\t    buf_free_len >= sizeof(struct smb2_file_stream_info) + 7 * 2) {\n\t\tfile_info = (struct smb2_file_stream_info *)\n\t\t\t&rsp->Buffer[nbytes];\n\t\tstreamlen = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t      \"::$DATA\", 7, conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stat.size);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stat.blocks << 9);\n\t\tnbytes += sizeof(struct smb2_file_stream_info) + streamlen;\n\t}\n\n\t/* last entry offset should be 0 */\n\tfile_info->NextEntryOffset = 0;\n\tkvfree(xattr_list);\n\n\trsp->OutputBufferLength = cpu_to_le32(nbytes);\n\tinc_rfc1001_len(rsp_org, nbytes);\n}\n\nstatic void get_file_internal_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int get_file_network_open_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_ntwrk_info *file_info;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_ntwrk_info *)rsp->Buffer;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->Reserved = cpu_to_le32(0);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ntwrk_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ntwrk_info));\n\treturn 0;\n}\n\nstatic void get_file_ea_info(struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_file_ea_info *file_info;\n\n\tfile_info = (struct smb2_file_ea_info *)rsp->Buffer;\n\tfile_info->EASize = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ea_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ea_info));\n}\n\nstatic void get_file_position_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_pos_info *file_info;\n\n\tfile_info = (struct smb2_file_pos_info *)rsp->Buffer;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_pos_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_pos_info));\n}\n\nstatic void get_file_mode_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_mode_info *file_info;\n\n\tfile_info = (struct smb2_file_mode_info *)rsp->Buffer;\n\tfile_info->Mode = fp->coption & FILE_MODE_INFO_MASK;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_mode_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_mode_info));\n}\n\nstatic void get_file_compression_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_comp_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\n\tfile_info = (struct smb2_file_comp_info *)rsp->Buffer;\n\tfile_info->CompressedFileSize = cpu_to_le64(stat.blocks << 9);\n\tfile_info->CompressionFormat = COMPRESSION_FORMAT_NONE;\n\tfile_info->CompressionUnitShift = 0;\n\tfile_info->ChunkShift = 0;\n\tfile_info->ClusterShift = 0;\n\tmemset(&file_info->Reserved[0], 0, 3);\n\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_comp_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_comp_info));\n}\n\nstatic int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_attr_tag_info *file_info;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_attr_tag_info *)rsp->Buffer;\n\tfile_info->FileAttributes = fp->f_ci->m_fattr;\n\tfile_info->ReparseTag = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_attr_tag_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_attr_tag_info));\n\treturn 0;\n}\n\nstatic int find_file_posix_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\tstruct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb311_posix_qinfo *file_info;\n\tstruct inode *inode = file_inode(fp->filp);\n\tu64 time;\n\n\tfile_info = (struct smb311_posix_qinfo *)rsp->Buffer;\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->DosAttributes = fp->f_ci->m_fattr;\n\tfile_info->Inode = cpu_to_le64(inode->i_ino);\n\tfile_info->EndOfFile = cpu_to_le64(inode->i_size);\n\tfile_info->AllocationSize = cpu_to_le64(inode->i_blocks << 9);\n\tfile_info->HardLinks = cpu_to_le32(inode->i_nlink);\n\tfile_info->Mode = cpu_to_le32(inode->i_mode);\n\tfile_info->DeviceId = cpu_to_le32(inode->i_rdev);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb311_posix_qinfo));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb311_posix_qinfo));\n\treturn 0;\n}\n\nstatic int smb2_get_info_file(struct ksmbd_work *work,\n\t\t\t      struct smb2_query_info_req *req,\n\t\t\t      struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tint fileinfoclass = 0;\n\tint rc = 0;\n\tint file_infoclass_size;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\t/* smb2 info file called for pipe */\n\t\treturn smb2_get_info_file_pipe(work->sess, req, rsp,\n\t\t\t\t\t       work->response_buf);\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tfileinfoclass = req->FileInfoClass;\n\n\tswitch (fileinfoclass) {\n\tcase FILE_ACCESS_INFORMATION:\n\t\tget_file_access_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ACCESS_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_BASIC_INFORMATION:\n\t\trc = get_file_basic_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_BASIC_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_file_standard_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STANDARD_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALIGNMENT_INFORMATION:\n\t\tget_file_alignment_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALIGNMENT_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALL_INFORMATION:\n\t\trc = get_file_all_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALTERNATE_NAME_INFORMATION:\n\t\tget_file_alternate_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALTERNATE_NAME_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STREAM_INFORMATION:\n\t\tget_file_stream_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STREAM_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_file_internal_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_INTERNAL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_NETWORK_OPEN_INFORMATION:\n\t\trc = get_file_network_open_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_NETWORK_OPEN_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_EA_INFORMATION:\n\t\tget_file_ea_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_FULL_EA_INFORMATION:\n\t\trc = smb2_get_ea(work, fp, req, rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_FULL_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_POSITION_INFORMATION:\n\t\tget_file_position_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_POSITION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_MODE_INFORMATION:\n\t\tget_file_mode_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_MODE_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_COMPRESSION_INFORMATION:\n\t\tget_file_compression_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_COMPRESSION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ATTRIBUTE_TAG_INFORMATION:\n\t\trc = get_file_attribute_tag_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ATTRIBUTE_TAG_INFORMATION_SIZE;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\trc = find_file_posix_info(rsp, fp, work->response_buf);\n\t\t\tfile_infoclass_size = sizeof(struct smb311_posix_qinfo);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"fileinfoclass %d not supported yet\\n\",\n\t\t\t    fileinfoclass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tif (!rc)\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, work->response_buf,\n\t\t\t\t      file_infoclass_size);\n\tksmbd_fd_put(work, fp);\n\treturn rc;\n}\n\nstatic int smb2_get_info_filesystem(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_req *req,\n\t\t\t\t    struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tint fsinfoclass = 0;\n\tstruct kstatfs stfs;\n\tstruct path path;\n\tint rc = 0, len;\n\tint fs_infoclass_size = 0;\n\n\trc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);\n\tif (rc) {\n\t\tpr_err(\"cannot create vfs path\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = vfs_statfs(&path, &stfs);\n\tif (rc) {\n\t\tpr_err(\"cannot do stat of path %s\\n\", share->path);\n\t\tpath_put(&path);\n\t\treturn -EIO;\n\t}\n\n\tfsinfoclass = req->FileInfoClass;\n\n\tswitch (fsinfoclass) {\n\tcase FS_DEVICE_INFORMATION:\n\t{\n\t\tstruct filesystem_device_info *info;\n\n\t\tinfo = (struct filesystem_device_info *)rsp->Buffer;\n\n\t\tinfo->DeviceType = cpu_to_le32(stfs.f_type);\n\t\tinfo->DeviceCharacteristics = cpu_to_le32(0x00000020);\n\t\trsp->OutputBufferLength = cpu_to_le32(8);\n\t\tinc_rfc1001_len(work->response_buf, 8);\n\t\tfs_infoclass_size = FS_DEVICE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_ATTRIBUTE_INFORMATION:\n\t{\n\t\tstruct filesystem_attribute_info *info;\n\t\tsize_t sz;\n\n\t\tinfo = (struct filesystem_attribute_info *)rsp->Buffer;\n\t\tinfo->Attributes = cpu_to_le32(FILE_SUPPORTS_OBJECT_IDS |\n\t\t\t\t\t       FILE_PERSISTENT_ACLS |\n\t\t\t\t\t       FILE_UNICODE_ON_DISK |\n\t\t\t\t\t       FILE_CASE_PRESERVED_NAMES |\n\t\t\t\t\t       FILE_CASE_SENSITIVE_SEARCH |\n\t\t\t\t\t       FILE_SUPPORTS_BLOCK_REFCOUNTING);\n\n\t\tinfo->Attributes |= cpu_to_le32(server_conf.share_fake_fscaps);\n\n\t\tinfo->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);\n\t\tlen = smbConvertToUTF16((__le16 *)info->FileSystemName,\n\t\t\t\t\t\"NTFS\", PATH_MAX, conn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->FileSystemNameLen = cpu_to_le32(len);\n\t\tsz = sizeof(struct filesystem_attribute_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_ATTRIBUTE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_VOLUME_INFORMATION:\n\t{\n\t\tstruct filesystem_vol_info *info;\n\t\tsize_t sz;\n\t\tunsigned int serial_crc = 0;\n\n\t\tinfo = (struct filesystem_vol_info *)(rsp->Buffer);\n\t\tinfo->VolumeCreationTime = 0;\n\t\tserial_crc = crc32_le(serial_crc, share->name,\n\t\t\t\t      strlen(share->name));\n\t\tserial_crc = crc32_le(serial_crc, share->path,\n\t\t\t\t      strlen(share->path));\n\t\tserial_crc = crc32_le(serial_crc, ksmbd_netbios_name(),\n\t\t\t\t      strlen(ksmbd_netbios_name()));\n\t\t/* Taking dummy value of serial number*/\n\t\tinfo->SerialNumber = cpu_to_le32(serial_crc);\n\t\tlen = smbConvertToUTF16((__le16 *)info->VolumeLabel,\n\t\t\t\t\tshare->name, PATH_MAX,\n\t\t\t\t\tconn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->VolumeLabelSize = cpu_to_le32(len);\n\t\tinfo->Reserved = 0;\n\t\tsz = sizeof(struct filesystem_vol_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_VOLUME_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SIZE_INFORMATION:\n\t{\n\t\tstruct filesystem_info *info;\n\n\t\tinfo = (struct filesystem_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(24);\n\t\tinc_rfc1001_len(work->response_buf, 24);\n\t\tfs_infoclass_size = FS_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_FULL_SIZE_INFORMATION:\n\t{\n\t\tstruct smb2_fs_full_size_info *info;\n\n\t\tinfo = (struct smb2_fs_full_size_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->CallerAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bavail);\n\t\tinfo->ActualAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(32);\n\t\tinc_rfc1001_len(work->response_buf, 32);\n\t\tfs_infoclass_size = FS_FULL_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_OBJECT_ID_INFORMATION:\n\t{\n\t\tstruct object_id_info *info;\n\n\t\tinfo = (struct object_id_info *)(rsp->Buffer);\n\n\t\tif (!user_guest(sess->user))\n\t\t\tmemcpy(info->objid, user_passkey(sess->user), 16);\n\t\telse\n\t\t\tmemset(info->objid, 0, 16);\n\n\t\tinfo->extended_info.magic = cpu_to_le32(EXTENDED_INFO_MAGIC);\n\t\tinfo->extended_info.version = cpu_to_le32(1);\n\t\tinfo->extended_info.release = cpu_to_le32(1);\n\t\tinfo->extended_info.rel_date = 0;\n\t\tmemcpy(info->extended_info.version_string, \"1.1.0\", strlen(\"1.1.0\"));\n\t\trsp->OutputBufferLength = cpu_to_le32(64);\n\t\tinc_rfc1001_len(work->response_buf, 64);\n\t\tfs_infoclass_size = FS_OBJECT_ID_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SECTOR_SIZE_INFORMATION:\n\t{\n\t\tstruct smb3_fs_ss_info *info;\n\t\tunsigned int sector_size =\n\t\t\tmin_t(unsigned int, path.mnt->mnt_sb->s_blocksize, 4096);\n\n\t\tinfo = (struct smb3_fs_ss_info *)(rsp->Buffer);\n\n\t\tinfo->LogicalBytesPerSector = cpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForPerf = cpu_to_le32(sector_size);\n\t\tinfo->FSEffPhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->Flags = cpu_to_le32(SSINFO_FLAGS_ALIGNED_DEVICE |\n\t\t\t\t    SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE);\n\t\tinfo->ByteOffsetForSectorAlignment = 0;\n\t\tinfo->ByteOffsetForPartitionAlignment = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(28);\n\t\tinc_rfc1001_len(work->response_buf, 28);\n\t\tfs_infoclass_size = FS_SECTOR_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_CONTROL_INFORMATION:\n\t{\n\t\t/*\n\t\t * TODO : The current implementation is based on\n\t\t * test result with win7(NTFS) server. It's need to\n\t\t * modify this to get valid Quota values\n\t\t * from Linux kernel\n\t\t */\n\t\tstruct smb2_fs_control_info *info;\n\n\t\tinfo = (struct smb2_fs_control_info *)(rsp->Buffer);\n\t\tinfo->FreeSpaceStartFiltering = 0;\n\t\tinfo->FreeSpaceThreshold = 0;\n\t\tinfo->FreeSpaceStopFiltering = 0;\n\t\tinfo->DefaultQuotaThreshold = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->DefaultQuotaLimit = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->Padding = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(48);\n\t\tinc_rfc1001_len(work->response_buf, 48);\n\t\tfs_infoclass_size = FS_CONTROL_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_POSIX_INFORMATION:\n\t{\n\t\tstruct filesystem_posix_info *info;\n\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tinfo = (struct filesystem_posix_info *)(rsp->Buffer);\n\t\t\tinfo->OptimalTransferSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->BlockSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->TotalBlocks = cpu_to_le64(stfs.f_blocks);\n\t\t\tinfo->BlocksAvail = cpu_to_le64(stfs.f_bfree);\n\t\t\tinfo->UserBlocksAvail = cpu_to_le64(stfs.f_bavail);\n\t\t\tinfo->TotalFileNodes = cpu_to_le64(stfs.f_files);\n\t\t\tinfo->FreeFileNodes = cpu_to_le64(stfs.f_ffree);\n\t\t\trsp->OutputBufferLength = cpu_to_le32(56);\n\t\t\tinc_rfc1001_len(work->response_buf, 56);\n\t\t\tfs_infoclass_size = FS_POSIX_INFORMATION_SIZE;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpath_put(&path);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t      rsp, work->response_buf,\n\t\t\t      fs_infoclass_size);\n\tpath_put(&path);\n\treturn rc;\n}\n\nstatic int smb2_get_info_sec(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_req *req,\n\t\t\t     struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode;\n\t__u32 secdesclen;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\tint addition_info = le32_to_cpu(req->AdditionalInformation);\n\tint rc;\n\n\tif (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t      PROTECTED_DACL_SECINFO |\n\t\t\t      UNPROTECTED_DACL_SECINFO)) {\n\t\tksmbd_debug(SMB, \"Unsupported addition info: 0x%x)\\n\",\n\t\t       addition_info);\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PROTECTED);\n\t\tpntsd->osidoffset = 0;\n\t\tpntsd->gsidoffset = 0;\n\t\tpntsd->sacloffset = 0;\n\t\tpntsd->dacloffset = 0;\n\n\t\tsecdesclen = sizeof(struct smb_ntsd);\n\t\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\t\tinc_rfc1001_len(work->response_buf, secdesclen);\n\n\t\treturn 0;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tinode = file_inode(fp->filp);\n\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR))\n\t\tksmbd_vfs_get_sd_xattr(work->conn, user_ns,\n\t\t\t\t       fp->filp->f_path.dentry, &ppntsd);\n\n\trc = build_sec_desc(user_ns, pntsd, ppntsd, addition_info,\n\t\t\t    &secdesclen, &fattr);\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tkfree(ppntsd);\n\tksmbd_fd_put(work, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\tinc_rfc1001_len(work->response_buf, secdesclen);\n\treturn 0;\n}\n\n/**\n * smb2_query_info() - handler for smb2 query info command\n * @work:\tsmb work containing query info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_query_info(struct ksmbd_work *work)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp;\n\tint rc = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"GOT query info request\\n\");\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_get_info_file(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_FILESYSTEM:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILESYSTEM\\n\");\n\t\trc = smb2_get_info_filesystem(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\trc = smb2_get_info_sec(work, req, rsp);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"InfoType %d not supported yet\\n\",\n\t\t\t    req->InfoType);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (rc == -EIO)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t\telse if (rc == -EOPNOTSUPP || rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\t\tsmb2_set_err_rsp(work);\n\n\t\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\",\n\t\t\t    rc);\n\t\treturn rc;\n\t}\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->OutputBufferOffset = cpu_to_le16(72);\n\tinc_rfc1001_len(work->response_buf, 8);\n\treturn 0;\n}\n\n/**\n * smb2_close_pipe() - handler for closing IPC pipe\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nstatic noinline int smb2_close_pipe(struct ksmbd_work *work)\n{\n\tu64 id;\n\tstruct smb2_close_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_close_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\tksmbd_session_rpc_close(work->sess, id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Flags = 0;\n\trsp->Reserved = 0;\n\trsp->CreationTime = 0;\n\trsp->LastAccessTime = 0;\n\trsp->LastWriteTime = 0;\n\trsp->ChangeTime = 0;\n\trsp->AllocationSize = 0;\n\trsp->EndOfFile = 0;\n\trsp->Attributes = 0;\n\tinc_rfc1001_len(work->response_buf, 60);\n\treturn 0;\n}\n\n/**\n * smb2_close() - handler for smb2 close file command\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nint smb2_close(struct ksmbd_work *work)\n{\n\tu64 volatile_id = KSMBD_NO_FID;\n\tu64 sess_id;\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_file *fp;\n\tstruct inode *inode;\n\tu64 time;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe close request\\n\");\n\t\treturn smb2_close_pipe(work);\n\t}\n\n\tsess_id = le64_to_cpu(req->hdr.SessionId);\n\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\tsess_id = work->compound_sid;\n\n\twork->compound_sid = 0;\n\tif (check_session_id(conn, sess_id)) {\n\t\twork->compound_sid = sess_id;\n\t} else {\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\t\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\terr = -EBADF;\n\t\tgoto out;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off &&\n\t    !has_file_id(req->VolatileFileId)) {\n\t\tif (!has_file_id(work->compound_fid)) {\n\t\t\t/* file already closed, return FILE_CLOSED */\n\t\t\tksmbd_debug(SMB, \"file already closed\\n\");\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Compound request set FID = %llu:%llu\\n\",\n\t\t\t\t    work->compound_fid,\n\t\t\t\t    work->compound_pfid);\n\t\t\tvolatile_id = work->compound_fid;\n\n\t\t\t/* file closed, stored id is not valid anymore */\n\t\t\twork->compound_fid = KSMBD_NO_FID;\n\t\t\twork->compound_pfid = KSMBD_NO_FID;\n\t\t}\n\t} else {\n\t\tvolatile_id = req->VolatileFileId;\n\t}\n\tksmbd_debug(SMB, \"volatile_id = %llu\\n\", volatile_id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Reserved = 0;\n\n\tif (req->Flags == SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB) {\n\t\tfp = ksmbd_lookup_fd_fast(work, volatile_id);\n\t\tif (!fp) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode = file_inode(fp->filp);\n\t\trsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\t\trsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :\n\t\t\tcpu_to_le64(inode->i_blocks << 9);\n\t\trsp->EndOfFile = cpu_to_le64(inode->i_size);\n\t\trsp->Attributes = fp->f_ci->m_fattr;\n\t\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\t\trsp->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\t\trsp->LastWriteTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\t\trsp->ChangeTime = cpu_to_le64(time);\n\t\tksmbd_fd_put(work, fp);\n\t} else {\n\t\trsp->Flags = 0;\n\t\trsp->AllocationSize = 0;\n\t\trsp->EndOfFile = 0;\n\t\trsp->Attributes = 0;\n\t\trsp->CreationTime = 0;\n\t\trsp->LastAccessTime = 0;\n\t\trsp->LastWriteTime = 0;\n\t\trsp->ChangeTime = 0;\n\t}\n\n\terr = ksmbd_close_fd(work, volatile_id);\nout:\n\tif (err) {\n\t\tif (rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t} else {\n\t\tinc_rfc1001_len(work->response_buf, 60);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_echo() - handler for smb2 echo(ping) command\n * @work:\tsmb work containing echo request buffer\n *\n * Return:\t0\n */\nint smb2_echo(struct ksmbd_work *work)\n{\n\tstruct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n}\n\nstatic int smb2_rename(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp,\n\t\t       struct user_namespace *user_ns,\n\t\t       struct smb2_file_rename_info *file_info,\n\t\t       struct nls_table *local_nls)\n{\n\tstruct ksmbd_share_config *share = fp->tcon->share_conf;\n\tchar *new_name = NULL, *abs_oldname = NULL, *old_name = NULL;\n\tchar *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tksmbd_debug(SMB, \"setting FILE_RENAME_INFO\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tabs_oldname = d_path(&fp->filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(abs_oldname)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\told_name = strrchr(abs_oldname, '/');\n\tif (old_name && old_name[1] != '\\0') {\n\t\told_name++;\n\t} else {\n\t\tksmbd_debug(SMB, \"can't get last component in path %s\\n\",\n\t\t\t    abs_oldname);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tnew_name = smb2_get_name(file_info->FileName,\n\t\t\t\t le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t local_nls);\n\tif (IS_ERR(new_name)) {\n\t\trc = PTR_ERR(new_name);\n\t\tgoto out;\n\t}\n\n\tif (strchr(new_name, ':')) {\n\t\tint s_type;\n\t\tchar *xattr_stream_name, *stream_name = NULL;\n\t\tsize_t xattr_stream_size;\n\t\tint len;\n\n\t\trc = parse_stream_name(new_name, &stream_name, &s_type);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tlen = strlen(new_name);\n\t\tif (len > 0 && new_name[len - 1] != '/') {\n\t\t\tpr_err(\"not allow base filename in rename\\n\");\n\t\t\trc = -ESHARE;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t\t s_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\tfp->filp->f_path.dentry,\n\t\t\t\t\txattr_stream_name,\n\t\t\t\t\tNULL, 0, 0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"failed to store stream name in xattr: %d\\n\",\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"new name %s\\n\", new_name);\n\trc = ksmbd_vfs_kern_path(work, new_name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (ksmbd_share_veto_filename(share, new_name)) {\n\t\trc = -ENOENT;\n\t\tksmbd_debug(SMB, \"Can't rename vetoed file: %s\\n\", new_name);\n\t\tgoto out;\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, new_name);\n\t\t\tif (rc) {\n\t\t\t\tif (rc != -ENOTEMPTY)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s, rc %d\\n\",\n\t\t\t\t\t    new_name, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present &&\n\t\t    strncmp(old_name, path.dentry->d_name.name, strlen(old_name))) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cannot rename already existing file\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_fp_rename(work, fp, new_name);\nout:\n\tkfree(pathname);\n\tif (!IS_ERR(new_name))\n\t\tkfree(new_name);\n\treturn rc;\n}\n\nstatic int smb2_create_link(struct ksmbd_work *work,\n\t\t\t    struct ksmbd_share_config *share,\n\t\t\t    struct smb2_file_link_info *file_info,\n\t\t\t    unsigned int buf_len, struct file *filp,\n\t\t\t    struct nls_table *local_nls)\n{\n\tchar *link_name = NULL, *target_name = NULL, *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_link_info) +\n\t\t\tle32_to_cpu(file_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tksmbd_debug(SMB, \"setting FILE_LINK_INFORMATION\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tlink_name = smb2_get_name(file_info->FileName,\n\t\t\t\t  le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t  local_nls);\n\tif (IS_ERR(link_name) || S_ISDIR(file_inode(filp)->i_mode)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"link name is %s\\n\", link_name);\n\ttarget_name = d_path(&filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(target_name)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"target name is %s\\n\", target_name);\n\trc = ksmbd_vfs_kern_path(work, link_name, LOOKUP_NO_SYMLINKS, &path, 0);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, link_name);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s\\n\",\n\t\t\t\t\t    link_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB, \"link already exists\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_link(work, target_name, link_name);\n\tif (rc)\n\t\trc = -EINVAL;\nout:\n\tif (!IS_ERR(link_name))\n\t\tkfree(link_name);\n\tkfree(pathname);\n\treturn rc;\n}\n\nstatic int set_file_basic_info(struct ksmbd_file *fp,\n\t\t\t       struct smb2_file_basic_info *file_info,\n\t\t\t       struct ksmbd_share_config *share)\n{\n\tstruct iattr attrs;\n\tstruct file *filp;\n\tstruct inode *inode;\n\tstruct user_namespace *user_ns;\n\tint rc = 0;\n\n\tif (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))\n\t\treturn -EACCES;\n\n\tattrs.ia_valid = 0;\n\tfilp = fp->filp;\n\tinode = file_inode(filp);\n\tuser_ns = file_mnt_user_ns(filp);\n\n\tif (file_info->CreationTime)\n\t\tfp->create_time = le64_to_cpu(file_info->CreationTime);\n\n\tif (file_info->LastAccessTime) {\n\t\tattrs.ia_atime = ksmbd_NTtimeToUnix(file_info->LastAccessTime);\n\t\tattrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t}\n\n\tattrs.ia_valid |= ATTR_CTIME;\n\tif (file_info->ChangeTime)\n\t\tattrs.ia_ctime = ksmbd_NTtimeToUnix(file_info->ChangeTime);\n\telse\n\t\tattrs.ia_ctime = inode->i_ctime;\n\n\tif (file_info->LastWriteTime) {\n\t\tattrs.ia_mtime = ksmbd_NTtimeToUnix(file_info->LastWriteTime);\n\t\tattrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t}\n\n\tif (file_info->Attributes) {\n\t\tif (!S_ISDIR(inode->i_mode) &&\n\t\t    file_info->Attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\t\tpr_err(\"can't change a file to a directory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(S_ISDIR(inode->i_mode) && file_info->Attributes == FILE_ATTRIBUTE_NORMAL_LE))\n\t\t\tfp->f_ci->m_fattr = file_info->Attributes |\n\t\t\t\t(fp->f_ci->m_fattr & FILE_ATTRIBUTE_DIRECTORY_LE);\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_STORE_DOS_ATTRS) &&\n\t    (file_info->CreationTime || file_info->Attributes)) {\n\t\tstruct xattr_dos_attrib da = {0};\n\n\t\tda.version = 4;\n\t\tda.itime = fp->itime;\n\t\tda.create_time = fp->create_time;\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\t\tXATTR_DOSINFO_ITIME;\n\n\t\trc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t    filp->f_path.dentry, &da);\n\t\tif (rc)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"failed to restore file attribute in EA\\n\");\n\t\trc = 0;\n\t}\n\n\tif (attrs.ia_valid) {\n\t\tstruct dentry *dentry = filp->f_path.dentry;\n\t\tstruct inode *inode = d_inode(dentry);\n\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EACCES;\n\n\t\tinode_lock(inode);\n\t\tinode->i_ctime = attrs.ia_ctime;\n\t\tattrs.ia_valid &= ~ATTR_CTIME;\n\t\trc = notify_change(user_ns, dentry, &attrs, NULL);\n\t\tinode_unlock(inode);\n\t}\n\treturn rc;\n}\n\nstatic int set_file_allocation_info(struct ksmbd_work *work,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    struct smb2_file_alloc_info *file_alloc_info)\n{\n\t/*\n\t * TODO : It's working fine only when store dos attributes\n\t * is not yes. need to implement a logic which works\n\t * properly with any smb.conf option\n\t */\n\n\tloff_t alloc_blks;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\talloc_blks = (le64_to_cpu(file_alloc_info->AllocationSize) + 511) >> 9;\n\tinode = file_inode(fp->filp);\n\n\tif (alloc_blks > inode->i_blocks) {\n\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\trc = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t   alloc_blks * 512);\n\t\tif (rc && rc != -EOPNOTSUPP) {\n\t\t\tpr_err(\"vfs_fallocate is failed : %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else if (alloc_blks < inode->i_blocks) {\n\t\tloff_t size;\n\n\t\t/*\n\t\t * Allocation size could be smaller than original one\n\t\t * which means allocated blocks in file should be\n\t\t * deallocated. use truncate to cut out it, but inode\n\t\t * size is also updated with truncate offset.\n\t\t * inode size is retained by backup inode size.\n\t\t */\n\t\tsize = i_size_read(inode);\n\t\trc = ksmbd_vfs_truncate(work, fp, alloc_blks * 512);\n\t\tif (rc) {\n\t\t\tpr_err(\"truncate failed!, err %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (size < alloc_blks * 512)\n\t\t\ti_size_write(inode, size);\n\t}\n\treturn 0;\n}\n\nstatic int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t\tstruct smb2_file_eof_info *file_eof_info)\n{\n\tloff_t newsize;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\tnewsize = le64_to_cpu(file_eof_info->EndOfFile);\n\tinode = file_inode(fp->filp);\n\n\t/*\n\t * If FILE_END_OF_FILE_INFORMATION of set_info_file is called\n\t * on FAT32 shared device, truncate execution time is too long\n\t * and network error could cause from windows client. because\n\t * truncate of some filesystem like FAT32 fill zero data in\n\t * truncated range.\n\t */\n\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC) {\n\t\tksmbd_debug(SMB, \"truncated to newsize %lld\\n\", newsize);\n\t\trc = ksmbd_vfs_truncate(work, fp, newsize);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"truncate failed!, err %d\\n\", rc);\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\trc = -EBADF;\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t   struct smb2_file_rename_info *rename_info,\n\t\t\t   unsigned int buf_len)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ksmbd_file *parent_fp;\n\tstruct dentry *parent;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint ret;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_rename_info) +\n\t\t\tle32_to_cpu(rename_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tif (ksmbd_stream_fd(fp))\n\t\tgoto next;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tparent_fp = ksmbd_lookup_fd_inode(d_inode(parent));\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\n\tif (parent_fp) {\n\t\tif (parent_fp->daccess & FILE_DELETE_LE) {\n\t\t\tpr_err(\"parent dir is opened with delete access\\n\");\n\t\t\tksmbd_fd_put(work, parent_fp);\n\t\t\treturn -ESHARE;\n\t\t}\n\t\tksmbd_fd_put(work, parent_fp);\n\t}\nnext:\n\treturn smb2_rename(work, fp, user_ns, rename_info,\n\t\t\t   work->conn->local_nls);\n}\n\nstatic int set_file_disposition_info(struct ksmbd_file *fp,\n\t\t\t\t     struct smb2_file_disposition_info *file_info)\n{\n\tstruct inode *inode;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tinode = file_inode(fp->filp);\n\tif (file_info->DeletePending) {\n\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t    ksmbd_vfs_empty_dir(fp) == -ENOTEMPTY)\n\t\t\treturn -EBUSY;\n\t\tksmbd_set_inode_pending_delete(fp);\n\t} else {\n\t\tksmbd_clear_inode_pending_delete(fp);\n\t}\n\treturn 0;\n}\n\nstatic int set_file_position_info(struct ksmbd_file *fp,\n\t\t\t\t  struct smb2_file_pos_info *file_info)\n{\n\tloff_t current_byte_offset;\n\tunsigned long sector_size;\n\tstruct inode *inode;\n\n\tinode = file_inode(fp->filp);\n\tcurrent_byte_offset = le64_to_cpu(file_info->CurrentByteOffset);\n\tsector_size = inode->i_sb->s_blocksize;\n\n\tif (current_byte_offset < 0 ||\n\t    (fp->coption == FILE_NO_INTERMEDIATE_BUFFERING_LE &&\n\t     current_byte_offset & (sector_size - 1))) {\n\t\tpr_err(\"CurrentByteOffset is not valid : %llu\\n\",\n\t\t       current_byte_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tfp->filp->f_pos = current_byte_offset;\n\treturn 0;\n}\n\nstatic int set_file_mode_info(struct ksmbd_file *fp,\n\t\t\t      struct smb2_file_mode_info *file_info)\n{\n\t__le32 mode;\n\n\tmode = file_info->Mode;\n\n\tif ((mode & ~FILE_MODE_INFO_MASK)) {\n\t\tpr_err(\"Mode is not valid : 0x%x\\n\", le32_to_cpu(mode));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * TODO : need to implement consideration for\n\t * FILE_SYNCHRONOUS_IO_ALERT and FILE_SYNCHRONOUS_IO_NONALERT\n\t */\n\tksmbd_vfs_set_fadvise(fp->filp, mode);\n\tfp->coption = mode;\n\treturn 0;\n}\n\n/**\n * smb2_set_info_file() - handler for smb2 set info command\n * @work:\tsmb work containing set info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\trequest buffer pointer\n * @share:\tksmbd_share_config pointer\n *\n * Return:\t0 on success, otherwise error\n * TODO: need to implement an error handling for STATUS_INFO_LENGTH_MISMATCH\n */\nstatic int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t      struct smb2_set_info_req *req,\n\t\t\t      struct ksmbd_share_config *share)\n{\n\tunsigned int buf_len = le32_to_cpu(req->BufferLength);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_BASIC_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_basic_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_basic_info(fp, (struct smb2_file_basic_info *)req->Buffer, share);\n\t}\n\tcase FILE_ALLOCATION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_alloc_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_allocation_info(work, fp,\n\t\t\t\t\t\t(struct smb2_file_alloc_info *)req->Buffer);\n\t}\n\tcase FILE_END_OF_FILE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_eof_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_end_of_file_info(work, fp,\n\t\t\t\t\t    (struct smb2_file_eof_info *)req->Buffer);\n\t}\n\tcase FILE_RENAME_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_rename_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_rename_info(work, fp,\n\t\t\t\t       (struct smb2_file_rename_info *)req->Buffer,\n\t\t\t\t       buf_len);\n\t}\n\tcase FILE_LINK_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_link_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_create_link(work, work->tcon->share_conf,\n\t\t\t\t\t(struct smb2_file_link_info *)req->Buffer,\n\t\t\t\t\tbuf_len, fp->filp,\n\t\t\t\t\twork->conn->local_nls);\n\t}\n\tcase FILE_DISPOSITION_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_disposition_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_disposition_info(fp,\n\t\t\t\t\t\t (struct smb2_file_disposition_info *)req->Buffer);\n\t}\n\tcase FILE_FULL_EA_INFORMATION:\n\t{\n\t\tif (!(fp->daccess & FILE_WRITE_EA_LE)) {\n\t\t\tpr_err(\"Not permitted to write ext  attr: 0x%x\\n\",\n\t\t\t       fp->daccess);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_ea_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_set_ea((struct smb2_ea_info *)req->Buffer,\n\t\t\t\t   buf_len, &fp->filp->f_path);\n\t}\n\tcase FILE_POSITION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_pos_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_position_info(fp, (struct smb2_file_pos_info *)req->Buffer);\n\t}\n\tcase FILE_MODE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_mode_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_mode_info(fp, (struct smb2_file_mode_info *)req->Buffer);\n\t}\n\t}\n\n\tpr_err(\"Unimplemented Fileinfoclass :%d\\n\", req->FileInfoClass);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int smb2_set_info_sec(struct ksmbd_file *fp, int addition_info,\n\t\t\t     char *buffer, int buf_len)\n{\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)buffer;\n\n\tfp->saccess |= FILE_SHARE_DELETE_LE;\n\n\treturn set_info_sec(fp->conn, fp->tcon, &fp->filp->f_path, pntsd,\n\t\t\tbuf_len, false);\n}\n\n/**\n * smb2_set_info() - handler for smb2 set info command handler\n * @work:\tsmb work containing set info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_set_info(struct ksmbd_work *work)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp;\n\tstruct ksmbd_file *fp;\n\tint rc = 0;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tksmbd_debug(SMB, \"Received set info request\\n\");\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid id for close: %u\\n\", id);\n\t\trc = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_set_info_file(work, fp, req, work->tcon->share_conf);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\tif (ksmbd_override_fsids(work)) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = smb2_set_info_sec(fp,\n\t\t\t\t       le32_to_cpu(req->AdditionalInformation),\n\t\t\t\t       req->Buffer,\n\t\t\t\t       le32_to_cpu(req->BufferLength));\n\t\tksmbd_revert_fsids(work);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0)\n\t\tgoto err_out;\n\n\trsp->StructureSize = cpu_to_le16(2);\n\tinc_rfc1001_len(work->response_buf, 2);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nerr_out:\n\tif (rc == -EACCES || rc == -EPERM || rc == -EXDEV)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\telse if (rc == -EBUSY || rc == -ENOTEMPTY)\n\t\trsp->hdr.Status = STATUS_DIRECTORY_NOT_EMPTY;\n\telse if (rc == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (rc == -EBADF || rc == -ESTALE)\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\telse if (rc == -EEXIST)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\telse if (rsp->hdr.Status == 0 || rc == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\", rc);\n\treturn rc;\n}\n\n/**\n * smb2_read_pipe() - handler for smb2 read from IPC pipe\n * @work:\tsmb work containing read IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_read_pipe(struct ksmbd_work *work)\n{\n\tint nbytes = 0, err;\n\tu64 id;\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tstruct smb2_read_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_read_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\n\tinc_rfc1001_len(work->response_buf, 16);\n\trpc_resp = ksmbd_rpc_read(work->sess, id);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twork->aux_payload_buf =\n\t\t\tkvmalloc(rpc_resp->payload_sz, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!work->aux_payload_buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(work->aux_payload_buf, rpc_resp->payload,\n\t\t       rpc_resp->payload_sz);\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\t\twork->aux_payload_sz = nbytes;\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\treturn 0;\n\nout:\n\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\tsmb2_set_err_rsp(work);\n\tkvfree(rpc_resp);\n\treturn err;\n}\n\nstatic int smb2_set_remote_key_for_rdma(struct ksmbd_work *work,\n\t\t\t\t\tstruct smb2_buffer_desc_v1 *desc,\n\t\t\t\t\t__le32 Channel,\n\t\t\t\t\t__le16 ChannelInfoLength)\n{\n\tunsigned int i, ch_count;\n\n\tif (work->conn->dialect == SMB30_PROT_ID &&\n\t    Channel != SMB2_CHANNEL_RDMA_V1)\n\t\treturn -EINVAL;\n\n\tch_count = le16_to_cpu(ChannelInfoLength) / sizeof(*desc);\n\tif (ksmbd_debug_types & KSMBD_DEBUG_RDMA) {\n\t\tfor (i = 0; i < ch_count; i++) {\n\t\t\tpr_info(\"RDMA r/w request %#x: token %#x, length %#x\\n\",\n\t\t\t\ti,\n\t\t\t\tle32_to_cpu(desc[i].token),\n\t\t\t\tle32_to_cpu(desc[i].length));\n\t\t}\n\t}\n\tif (!ch_count)\n\t\treturn -EINVAL;\n\n\twork->need_invalidate_rkey =\n\t\t(Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE);\n\tif (Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE)\n\t\twork->remote_key = le32_to_cpu(desc->token);\n\treturn 0;\n}\n\nstatic ssize_t smb2_read_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t      struct smb2_read_req *req, void *data_buf,\n\t\t\t\t      size_t length)\n{\n\tint err;\n\n\terr = ksmbd_conn_rdma_write(work->conn, data_buf, length,\n\t\t\t\t    (struct smb2_buffer_desc_v1 *)\n\t\t\t\t    ((char *)req + le16_to_cpu(req->ReadChannelInfoOffset)),\n\t\t\t\t    le16_to_cpu(req->ReadChannelInfoLength));\n\tif (err)\n\t\treturn err;\n\n\treturn length;\n}\n\n/**\n * smb2_read() - handler for smb2 read from file\n * @work:\tsmb work containing read command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_read(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_read_req *req;\n\tstruct smb2_read_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length, mincount;\n\tssize_t nbytes = 0, remain_bytes = 0;\n\tint err = 0;\n\tbool is_rdma_channel = false;\n\tunsigned int max_read_size = conn->vals->max_read_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe read request\\n\");\n\t\treturn smb2_read_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\tis_rdma_channel = true;\n\t\tmax_read_size = get_smbd_max_read_write_size();\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->ReadChannelInfoOffset);\n\n\t\tif (ch_offset < offsetof(struct smb2_read_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->ReadChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to read : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\tmincount = le32_to_cpu(req->MinimumCount);\n\n\tif (length > max_read_size) {\n\t\tksmbd_debug(SMB, \"limiting read size to max size(%u)\\n\",\n\t\t\t    max_read_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t    fp->filp->f_path.dentry, offset, length);\n\n\twork->aux_payload_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->aux_payload_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnbytes = ksmbd_vfs_read(work, fp, length, &offset);\n\tif (nbytes < 0) {\n\t\terr = nbytes;\n\t\tgoto out;\n\t}\n\n\tif ((nbytes == 0 && length != 0) || nbytes < mincount) {\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\t\trsp->hdr.Status = STATUS_END_OF_FILE;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn 0;\n\t}\n\n\tksmbd_debug(SMB, \"nbytes %zu, offset %lld mincount %zu\\n\",\n\t\t    nbytes, offset, mincount);\n\n\tif (is_rdma_channel == true) {\n\t\t/* write data to the client using rdma channel */\n\t\tremain_bytes = smb2_read_rdma_channel(work, req,\n\t\t\t\t\t\t      work->aux_payload_buf,\n\t\t\t\t\t\t      nbytes);\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\n\t\tnbytes = 0;\n\t\tif (remain_bytes < 0) {\n\t\t\terr = (int)remain_bytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = cpu_to_le32(remain_bytes);\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\twork->aux_payload_sz = nbytes;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\tif (err == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\telse if (err == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (err == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (err == -ESHARE)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\t\tsmb2_set_err_rsp(work);\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_write_pipe() - handler for smb2 write on IPC pipe\n * @work:\tsmb work containing write IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_write_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_write_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tu64 id = 0;\n\tint err = 0, ret = 0;\n\tchar *data_buf;\n\tsize_t length;\n\n\tlength = le32_to_cpu(req->Length);\n\tid = req->VolatileFileId;\n\n\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t    get_rfc1002_len(work->request_buf)) {\n\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t       le16_to_cpu(req->DataOffset),\n\t\t       get_rfc1002_len(work->request_buf));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t   le16_to_cpu(req->DataOffset));\n\n\trpc_resp = ksmbd_rpc_write(work->sess, id, data_buf, length);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tkvfree(rpc_resp);\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\tkvfree(rpc_resp);\n\t\t\treturn ret;\n\t\t}\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(length);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\treturn 0;\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t smb2_write_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t       struct smb2_write_req *req,\n\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t       loff_t offset, size_t length, bool sync)\n{\n\tchar *data_buf;\n\tint ret;\n\tssize_t nbytes;\n\n\tdata_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tret = ksmbd_conn_rdma_read(work->conn, data_buf, length,\n\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t   ((char *)req + le16_to_cpu(req->WriteChannelInfoOffset)),\n\t\t\t\t   le16_to_cpu(req->WriteChannelInfoLength));\n\tif (ret < 0) {\n\t\tkvfree(data_buf);\n\t\treturn ret;\n\t}\n\n\tret = ksmbd_vfs_write(work, fp, data_buf, length, &offset, sync, &nbytes);\n\tkvfree(data_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nbytes;\n}\n\n/**\n * smb2_write() - handler for smb2 write from file\n * @work:\tsmb work containing write command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false, is_rdma_channel = false;\n\tint err = 0;\n\tunsigned int max_write_size = work->conn->vals->max_write_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tis_rdma_channel = true;\n\t\tmax_write_size = get_smbd_max_read_write_size();\n\t\tlength = le32_to_cpu(req->RemainingBytes);\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (length > max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (is_rdma_channel == false) {\n\t\tif (le16_to_cpu(req->DataOffset) <\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t    le16_to_cpu(req->DataOffset));\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset, length,\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_flush() - handler for smb2 flush file - fsync\n * @work:\tsmb work containing flush command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_flush(struct ksmbd_work *work)\n{\n\tstruct smb2_flush_req *req;\n\tstruct smb2_flush_rsp *rsp;\n\tint err;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"SMB2_FLUSH called for fid %llu\\n\", req->VolatileFileId);\n\n\terr = ksmbd_vfs_fsync(work, req->VolatileFileId, req->PersistentFileId);\n\tif (err)\n\t\tgoto out;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\n/**\n * smb2_cancel() - handler for smb2 cancel command\n * @work:\tsmb work containing cancel command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_cancel(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tstruct smb2_hdr *chdr;\n\tstruct ksmbd_work *cancel_work = NULL, *iter;\n\tstruct list_head *command_list;\n\n\tksmbd_debug(SMB, \"smb2 cancel called on mid %llu, async flags 0x%x\\n\",\n\t\t    hdr->MessageId, hdr->Flags);\n\n\tif (hdr->Flags & SMB2_FLAGS_ASYNC_COMMAND) {\n\t\tcommand_list = &conn->async_requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list,\n\t\t\t\t    async_request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (iter->async_id !=\n\t\t\t    le64_to_cpu(hdr->Id.AsyncId))\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with AsyncId %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->Id.AsyncId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t} else {\n\t\tcommand_list = &conn->requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list, request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (chdr->MessageId != hdr->MessageId ||\n\t\t\t    iter == work)\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with mid %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->MessageId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\tif (cancel_work) {\n\t\tcancel_work->state = KSMBD_WORK_CANCELLED;\n\t\tif (cancel_work->cancel_fn)\n\t\t\tcancel_work->cancel_fn(cancel_work->cancel_argv);\n\t}\n\n\t/* For SMB2_CANCEL command itself send no response*/\n\twork->send_no_response = 1;\n\treturn 0;\n}\n\nstruct file_lock *smb_flock_init(struct file *f)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\tgoto out;\n\n\tlocks_init_lock(fl);\n\n\tfl->fl_owner = f;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = f;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\nout:\n\treturn fl;\n}\n\nstatic int smb2_set_flock_flags(struct file_lock *flock, int flags)\n{\n\tint cmd = -EINVAL;\n\n\t/* Checking for wrong flag combination during lock request*/\n\tswitch (flags) {\n\tcase SMB2_LOCKFLAG_SHARED:\n\t\tksmbd_debug(SMB, \"received shared request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_RDLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE:\n\t\tksmbd_debug(SMB, \"received exclusive request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_WRLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_SHARED | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received shared & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received exclusive & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_UNLOCK:\n\t\tksmbd_debug(SMB, \"received unlock request\\n\");\n\t\tflock->fl_type = F_UNLCK;\n\t\tcmd = 0;\n\t\tbreak;\n\t}\n\n\treturn cmd;\n}\n\nstatic struct ksmbd_lock *smb2_lock_init(struct file_lock *flock,\n\t\t\t\t\t unsigned int cmd, int flags,\n\t\t\t\t\t struct list_head *lock_list)\n{\n\tstruct ksmbd_lock *lock;\n\n\tlock = kzalloc(sizeof(struct ksmbd_lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn NULL;\n\n\tlock->cmd = cmd;\n\tlock->fl = flock;\n\tlock->start = flock->fl_start;\n\tlock->end = flock->fl_end;\n\tlock->flags = flags;\n\tif (lock->start == lock->end)\n\t\tlock->zero_len = 1;\n\tINIT_LIST_HEAD(&lock->clist);\n\tINIT_LIST_HEAD(&lock->flist);\n\tINIT_LIST_HEAD(&lock->llist);\n\tlist_add_tail(&lock->llist, lock_list);\n\n\treturn lock;\n}\n\nstatic void smb2_remove_blocked_lock(void **argv)\n{\n\tstruct file_lock *flock = (struct file_lock *)argv[0];\n\n\tksmbd_vfs_posix_lock_unblock(flock);\n\twake_up(&flock->fl_wait);\n}\n\nstatic inline bool lock_defer_pending(struct file_lock *fl)\n{\n\t/* check pending lock waiters */\n\treturn waitqueue_active(&fl->fl_wait);\n}\n\n/**\n * smb2_lock() - handler for smb2 file lock command\n * @work:\tsmb work containing lock command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_lock(struct ksmbd_work *work)\n{\n\tstruct smb2_lock_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lock_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_lock_element *lock_ele;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file_lock *flock = NULL;\n\tstruct file *filp = NULL;\n\tint lock_count;\n\tint flags = 0;\n\tint cmd = 0;\n\tint err = -EIO, i, rc = 0;\n\tu64 lock_start, lock_length;\n\tstruct ksmbd_lock *smb_lock = NULL, *cmp_lock, *tmp, *tmp2;\n\tstruct ksmbd_conn *conn;\n\tint nolock = 0;\n\tLIST_HEAD(lock_list);\n\tLIST_HEAD(rollback_list);\n\tint prior_lock = 0;\n\n\tksmbd_debug(SMB, \"Received lock request\\n\");\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid file id for lock : %llu\\n\", req->VolatileFileId);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\n\tfilp = fp->filp;\n\tlock_count = le16_to_cpu(req->LockCount);\n\tlock_ele = req->locks;\n\n\tksmbd_debug(SMB, \"lock count is %d\\n\", lock_count);\n\tif (!lock_count) {\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\tfor (i = 0; i < lock_count; i++) {\n\t\tflags = le32_to_cpu(lock_ele[i].Flags);\n\n\t\tflock = smb_flock_init(filp);\n\t\tif (!flock)\n\t\t\tgoto out;\n\n\t\tcmd = smb2_set_flock_flags(flock, flags);\n\n\t\tlock_start = le64_to_cpu(lock_ele[i].Offset);\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_start > U64_MAX - lock_length) {\n\t\t\tpr_err(\"Invalid lock range requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lock_start > OFFSET_MAX)\n\t\t\tflock->fl_start = OFFSET_MAX;\n\t\telse\n\t\t\tflock->fl_start = lock_start;\n\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_length > OFFSET_MAX - flock->fl_start)\n\t\t\tlock_length = OFFSET_MAX - flock->fl_start;\n\n\t\tflock->fl_end = flock->fl_start + lock_length;\n\n\t\tif (flock->fl_end < flock->fl_start) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"the end offset(%llx) is smaller than the start offset(%llx)\\n\",\n\t\t\t\t    flock->fl_end, flock->fl_start);\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check conflict locks in one request */\n\t\tlist_for_each_entry(cmp_lock, &lock_list, llist) {\n\t\t\tif (cmp_lock->fl->fl_start <= flock->fl_start &&\n\t\t\t    cmp_lock->fl->fl_end >= flock->fl_end) {\n\t\t\t\tif (cmp_lock->fl->fl_type != F_UNLCK &&\n\t\t\t\t    flock->fl_type != F_UNLCK) {\n\t\t\t\t\tpr_err(\"conflict two locks in one request\\n\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsmb_lock = smb2_lock_init(flock, cmd, flags, &lock_list);\n\t\tif (!smb_lock) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tif (smb_lock->cmd < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_MASK)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((prior_lock & (SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_SHARED) &&\n\t\t     smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) ||\n\t\t    (prior_lock == SMB2_LOCKFLAG_UNLOCK &&\n\t\t     !(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprior_lock = smb_lock->flags;\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) &&\n\t\t    !(smb_lock->flags & SMB2_LOCKFLAG_FAIL_IMMEDIATELY))\n\t\t\tgoto no_check_cl;\n\n\t\tnolock = 1;\n\t\t/* check locks in connection list */\n\t\tread_lock(&conn_list_lock);\n\t\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\t\tspin_lock(&conn->llist_lock);\n\t\t\tlist_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {\n\t\t\t\tif (file_inode(cmp_lock->fl->fl_file) !=\n\t\t\t\t    file_inode(smb_lock->fl->fl_file))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (smb_lock->fl->fl_type == F_UNLCK) {\n\t\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file &&\n\t\t\t\t\t    cmp_lock->start == smb_lock->start &&\n\t\t\t\t\t    cmp_lock->end == smb_lock->end &&\n\t\t\t\t\t    !lock_defer_pending(cmp_lock->fl)) {\n\t\t\t\t\t\tnolock = 0;\n\t\t\t\t\t\tlist_del(&cmp_lock->flist);\n\t\t\t\t\t\tlist_del(&cmp_lock->clist);\n\t\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\t\tread_unlock(&conn_list_lock);\n\n\t\t\t\t\t\tlocks_free_lock(cmp_lock->fl);\n\t\t\t\t\t\tkfree(cmp_lock);\n\t\t\t\t\t\tgoto out_check_cl;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file) {\n\t\t\t\t\tif (smb_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tif (cmp_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* check zero byte lock range */\n\t\t\t\tif (cmp_lock->zero_len && !smb_lock->zero_len &&\n\t\t\t\t    cmp_lock->start > smb_lock->start &&\n\t\t\t\t    cmp_lock->start < smb_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"previous lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (smb_lock->zero_len && !cmp_lock->zero_len &&\n\t\t\t\t    smb_lock->start > cmp_lock->start &&\n\t\t\t\t    smb_lock->start < cmp_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"current lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (((cmp_lock->start <= smb_lock->start &&\n\t\t\t\t      cmp_lock->end > smb_lock->start) ||\n\t\t\t\t     (cmp_lock->start < smb_lock->end &&\n\t\t\t\t      cmp_lock->end >= smb_lock->end)) &&\n\t\t\t\t    !cmp_lock->zero_len && !smb_lock->zero_len) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"Not allow lock operation on exclusive lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&conn->llist_lock);\n\t\t}\n\t\tread_unlock(&conn_list_lock);\nout_check_cl:\n\t\tif (smb_lock->fl->fl_type == F_UNLCK && nolock) {\n\t\t\tpr_err(\"Try to unlock nolocked range\\n\");\n\t\t\trsp->hdr.Status = STATUS_RANGE_NOT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\nno_check_cl:\n\t\tif (smb_lock->zero_len) {\n\t\t\terr = 0;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tflock = smb_lock->fl;\n\t\tlist_del(&smb_lock->llist);\nretry:\n\t\trc = vfs_lock_file(filp, smb_lock->cmd, flock, NULL);\nskip:\n\t\tif (flags & SMB2_LOCKFLAG_UNLOCK) {\n\t\t\tif (!rc) {\n\t\t\t\tksmbd_debug(SMB, \"File unlocked\\n\");\n\t\t\t} else if (rc == -ENOENT) {\n\t\t\t\trsp->hdr.Status = STATUS_NOT_LOCKED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlocks_free_lock(flock);\n\t\t\tkfree(smb_lock);\n\t\t} else {\n\t\t\tif (rc == FILE_LOCK_DEFERRED) {\n\t\t\t\tvoid **argv;\n\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"would have to wait for getting lock\\n\");\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\n\t\t\t\targv = kmalloc(sizeof(void *), GFP_KERNEL);\n\t\t\t\tif (!argv) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\targv[0] = flock;\n\n\t\t\t\trc = setup_async_work(work,\n\t\t\t\t\t\t      smb2_remove_blocked_lock,\n\t\t\t\t\t\t      argv);\n\t\t\t\tif (rc) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_add(&work->fp_entry, &fp->blocked_works);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\n\t\t\t\tsmb2_send_interim_resp(work, STATUS_PENDING);\n\n\t\t\t\tksmbd_vfs_posix_lock_wait(flock);\n\n\t\t\t\tif (work->state != KSMBD_WORK_ACTIVE) {\n\t\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\t\tlocks_free_lock(flock);\n\n\t\t\t\t\tif (work->state == KSMBD_WORK_CANCELLED) {\n\t\t\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\t\tSTATUS_CANCELLED;\n\t\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\t\tsmb2_send_interim_resp(work,\n\t\t\t\t\t\t\t\t       STATUS_CANCELLED);\n\t\t\t\t\t\twork->send_no_response = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tinit_smb2_rsp_hdr(work);\n\t\t\t\t\tsmb2_set_err_rsp(work);\n\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\tSTATUS_RANGE_NOT_LOCKED;\n\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\tgoto out2;\n\t\t\t\t}\n\n\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\tgoto retry;\n\t\t\t} else if (!rc) {\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tlist_add_tail(&smb_lock->flist,\n\t\t\t\t\t      &fp->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\t\t\t\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (atomic_read(&fp->f_ci->op_count) > 1)\n\t\tsmb_break_all_oplock(work, fp);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlist_del(&smb_lock->llist);\n\t\tkfree(smb_lock);\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &rollback_list, llist) {\n\t\tstruct file_lock *rlock = NULL;\n\n\t\trlock = smb_flock_init(filp);\n\t\trlock->fl_type = F_UNLCK;\n\t\trlock->fl_start = smb_lock->start;\n\t\trlock->fl_end = smb_lock->end;\n\n\t\trc = vfs_lock_file(filp, 0, rlock, NULL);\n\t\tif (rc)\n\t\t\tpr_err(\"rollback unlock fail : %d\\n\", rc);\n\n\t\tlist_del(&smb_lock->llist);\n\t\tspin_lock(&work->conn->llist_lock);\n\t\tif (!list_empty(&smb_lock->flist))\n\t\t\tlist_del(&smb_lock->flist);\n\t\tlist_del(&smb_lock->clist);\n\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlocks_free_lock(rlock);\n\t\tkfree(smb_lock);\n\t}\nout2:\n\tksmbd_debug(SMB, \"failed in taking lock(flags : %x), err : %d\\n\", flags, err);\n\n\tif (!rsp->hdr.Status) {\n\t\tif (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (err == -ENOMEM)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\nstatic int fsctl_copychunk(struct ksmbd_work *work,\n\t\t\t   struct copychunk_ioctl_req *ci_req,\n\t\t\t   unsigned int cnt_code,\n\t\t\t   unsigned int input_count,\n\t\t\t   unsigned long long volatile_id,\n\t\t\t   unsigned long long persistent_id,\n\t\t\t   struct smb2_ioctl_rsp *rsp)\n{\n\tstruct copychunk_ioctl_rsp *ci_rsp;\n\tstruct ksmbd_file *src_fp = NULL, *dst_fp = NULL;\n\tstruct srv_copychunk *chunks;\n\tunsigned int i, chunk_count, chunk_count_written = 0;\n\tunsigned int chunk_size_written = 0;\n\tloff_t total_size_written = 0;\n\tint ret = 0;\n\n\tci_rsp = (struct copychunk_ioctl_rsp *)&rsp->Buffer[0];\n\n\trsp->VolatileFileId = volatile_id;\n\trsp->PersistentFileId = persistent_id;\n\tci_rsp->ChunksWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_count());\n\tci_rsp->ChunkBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_size());\n\tci_rsp->TotalBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_total_size());\n\n\tchunks = (struct srv_copychunk *)&ci_req->Chunks[0];\n\tchunk_count = le32_to_cpu(ci_req->ChunkCount);\n\tif (chunk_count == 0)\n\t\tgoto out;\n\ttotal_size_written = 0;\n\n\t/* verify the SRV_COPYCHUNK_COPY packet */\n\tif (chunk_count > ksmbd_server_side_copy_max_chunk_count() ||\n\t    input_count < offsetof(struct copychunk_ioctl_req, Chunks) +\n\t     chunk_count * sizeof(struct srv_copychunk)) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tif (le32_to_cpu(chunks[i].Length) == 0 ||\n\t\t    le32_to_cpu(chunks[i].Length) > ksmbd_server_side_copy_max_chunk_size())\n\t\t\tbreak;\n\t\ttotal_size_written += le32_to_cpu(chunks[i].Length);\n\t}\n\n\tif (i < chunk_count ||\n\t    total_size_written > ksmbd_server_side_copy_max_total_size()) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_fp = ksmbd_lookup_foreign_fd(work,\n\t\t\t\t\t le64_to_cpu(ci_req->ResumeKey[0]));\n\tdst_fp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tret = -EINVAL;\n\tif (!src_fp ||\n\t    src_fp->persistent_id != le64_to_cpu(ci_req->ResumeKey[1])) {\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\tif (!dst_fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FILE_READ_DATA should only be included in\n\t * the FSCTL_COPYCHUNK case\n\t */\n\tif (cnt_code == FSCTL_COPYCHUNK &&\n\t    !(dst_fp->daccess & (FILE_READ_DATA_LE | FILE_GENERIC_READ_LE))) {\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tgoto out;\n\t}\n\n\tret = ksmbd_vfs_copy_file_ranges(work, src_fp, dst_fp,\n\t\t\t\t\t chunks, chunk_count,\n\t\t\t\t\t &chunk_count_written,\n\t\t\t\t\t &chunk_size_written,\n\t\t\t\t\t &total_size_written);\n\tif (ret < 0) {\n\t\tif (ret == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tif (ret == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (ret == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\telse if (ret == -EFBIG || ret == -ENOSPC)\n\t\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\t\telse if (ret == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (ret == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\telse if (ret == -E2BIG)\n\t\t\trsp->hdr.Status = STATUS_INVALID_VIEW_SIZE;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t}\n\n\tci_rsp->ChunksWritten = cpu_to_le32(chunk_count_written);\n\tci_rsp->ChunkBytesWritten = cpu_to_le32(chunk_size_written);\n\tci_rsp->TotalBytesWritten = cpu_to_le32(total_size_written);\nout:\n\tksmbd_fd_put(work, src_fp);\n\tksmbd_fd_put(work, dst_fp);\n\treturn ret;\n}\n\nstatic __be32 idev_ipv4_address(struct in_device *idev)\n{\n\t__be32 addr = 0;\n\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, idev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\taddr = ifa->ifa_address;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,\n\t\t\t\t\tstruct smb2_ioctl_rsp *rsp,\n\t\t\t\t\tunsigned int out_buf_len)\n{\n\tstruct network_interface_info_ioctl_rsp *nii_rsp = NULL;\n\tint nbytes = 0;\n\tstruct net_device *netdev;\n\tstruct sockaddr_storage_rsp *sockaddr_storage;\n\tunsigned int flags;\n\tunsigned long long speed;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, netdev) {\n\t\tbool ipv4_set = false;\n\n\t\tif (netdev->type == ARPHRD_LOOPBACK)\n\t\t\tcontinue;\n\n\t\tflags = dev_get_flags(netdev);\n\t\tif (!(flags & IFF_RUNNING))\n\t\t\tcontinue;\nipv6_retry:\n\t\tif (out_buf_len <\n\t\t    nbytes + sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tnii_rsp = (struct network_interface_info_ioctl_rsp *)\n\t\t\t\t&rsp->Buffer[nbytes];\n\t\tnii_rsp->IfIndex = cpu_to_le32(netdev->ifindex);\n\n\t\tnii_rsp->Capability = 0;\n\t\tif (netdev->real_num_tx_queues > 1)\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RSS_CAPABLE);\n\t\tif (ksmbd_rdma_capable_netdev(netdev))\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RDMA_CAPABLE);\n\n\t\tnii_rsp->Next = cpu_to_le32(152);\n\t\tnii_rsp->Reserved = 0;\n\n\t\tif (netdev->ethtool_ops->get_link_ksettings) {\n\t\t\tstruct ethtool_link_ksettings cmd;\n\n\t\t\tnetdev->ethtool_ops->get_link_ksettings(netdev, &cmd);\n\t\t\tspeed = cmd.base.speed;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"%s %s\\n\", netdev->name,\n\t\t\t\t    \"speed is unknown, defaulting to 1Gb/sec\");\n\t\t\tspeed = SPEED_1000;\n\t\t}\n\n\t\tspeed *= 1000000;\n\t\tnii_rsp->LinkSpeed = cpu_to_le64(speed);\n\n\t\tsockaddr_storage = (struct sockaddr_storage_rsp *)\n\t\t\t\t\tnii_rsp->SockAddr_Storage;\n\t\tmemset(sockaddr_storage, 0, 128);\n\n\t\tif (!ipv4_set) {\n\t\t\tstruct in_device *idev;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORK);\n\t\t\tsockaddr_storage->addr4.Port = 0;\n\n\t\t\tidev = __in_dev_get_rtnl(netdev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\t\t\tsockaddr_storage->addr4.IPv4address =\n\t\t\t\t\t\tidev_ipv4_address(idev);\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t\tipv4_set = true;\n\t\t\tgoto ipv6_retry;\n\t\t} else {\n\t\t\tstruct inet6_dev *idev6;\n\t\t\tstruct inet6_ifaddr *ifa;\n\t\t\t__u8 *ipv6_addr = sockaddr_storage->addr6.IPv6address;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORKV6);\n\t\t\tsockaddr_storage->addr6.Port = 0;\n\t\t\tsockaddr_storage->addr6.FlowInfo = 0;\n\n\t\t\tidev6 = __in6_dev_get(netdev);\n\t\t\tif (!idev6)\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(ifa, &idev6->addr_list, if_list) {\n\t\t\t\tif (ifa->flags & (IFA_F_TENTATIVE |\n\t\t\t\t\t\t\tIFA_F_DEPRECATED))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(ipv6_addr, ifa->addr.s6_addr, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsockaddr_storage->addr6.ScopeId = 0;\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t}\n\t}\n\trtnl_unlock();\n\n\t/* zero if this is last one */\n\tif (nii_rsp)\n\t\tnii_rsp->Next = 0;\n\n\trsp->PersistentFileId = SMB2_NO_FID;\n\trsp->VolatileFileId = SMB2_NO_FID;\n\treturn nbytes;\n}\n\nstatic int fsctl_validate_negotiate_info(struct ksmbd_conn *conn,\n\t\t\t\t\t struct validate_negotiate_info_req *neg_req,\n\t\t\t\t\t struct validate_negotiate_info_rsp *neg_rsp,\n\t\t\t\t\t unsigned int in_buf_len)\n{\n\tint ret = 0;\n\tint dialect;\n\n\tif (in_buf_len < offsetof(struct validate_negotiate_info_req, Dialects) +\n\t\t\tle16_to_cpu(neg_req->DialectCount) * sizeof(__le16))\n\t\treturn -EINVAL;\n\n\tdialect = ksmbd_lookup_dialect_by_id(neg_req->Dialects,\n\t\t\t\t\t     neg_req->DialectCount);\n\tif (dialect == BAD_PROT_ID || dialect != conn->dialect) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (strncmp(neg_req->Guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le16_to_cpu(neg_req->SecurityMode) != conn->cli_sec_mode) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le32_to_cpu(neg_req->Capabilities) != conn->cli_cap) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tneg_rsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\tmemset(neg_rsp->Guid, 0, SMB2_CLIENT_GUID_SIZE);\n\tneg_rsp->SecurityMode = cpu_to_le16(conn->srv_sec_mode);\n\tneg_rsp->Dialect = cpu_to_le16(conn->dialect);\nerr_out:\n\treturn ret;\n}\n\nstatic int fsctl_query_allocated_ranges(struct ksmbd_work *work, u64 id,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_req,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_rsp,\n\t\t\t\t\tunsigned int in_count, unsigned int *out_count)\n{\n\tstruct ksmbd_file *fp;\n\tloff_t start, length;\n\tint ret = 0;\n\n\t*out_count = 0;\n\tif (in_count == 0)\n\t\treturn -EINVAL;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tstart = le64_to_cpu(qar_req->file_offset);\n\tlength = le64_to_cpu(qar_req->length);\n\n\tret = ksmbd_vfs_fqar_lseek(fp, start, length,\n\t\t\t\t   qar_rsp, in_count, out_count);\n\tif (ret && ret != -E2BIG)\n\t\t*out_count = 0;\n\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_pipe_transceive(struct ksmbd_work *work, u64 id,\n\t\t\t\t unsigned int out_buf_len,\n\t\t\t\t struct smb2_ioctl_req *req,\n\t\t\t\t struct smb2_ioctl_rsp *rsp)\n{\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tchar *data_buf = (char *)&req->Buffer[0];\n\tint nbytes = 0;\n\n\trpc_resp = ksmbd_rpc_ioctl(work->sess, id, data_buf,\n\t\t\t\t   le32_to_cpu(req->InputCount));\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_SOME_NOT_MAPPED) {\n\t\t\t/*\n\t\t\t * set STATUS_SOME_NOT_MAPPED response\n\t\t\t * for unknown domain sid.\n\t\t\t */\n\t\t\trsp->hdr.Status = STATUS_SOME_NOT_MAPPED;\n\t\t} else if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t} else if (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\tif (rpc_resp->payload_sz > out_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tnbytes = out_buf_len;\n\t\t}\n\n\t\tif (!rpc_resp->payload_sz) {\n\t\t\trsp->hdr.Status =\n\t\t\t\tSTATUS_UNEXPECTED_IO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy((char *)rsp->Buffer, rpc_resp->payload, nbytes);\n\t}\nout:\n\tkvfree(rpc_resp);\n\treturn nbytes;\n}\n\nstatic inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,\n\t\t\t\t   struct file_sparse *sparse)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tint ret = 0;\n\t__le32 old_fattr;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\n\told_fattr = fp->f_ci->m_fattr;\n\tif (sparse->SetSparse)\n\t\tfp->f_ci->m_fattr |= FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\telse\n\t\tfp->f_ci->m_fattr &= ~FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\n\tif (fp->f_ci->m_fattr != old_fattr &&\n\t    test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\tret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret)\n\t\t\tfp->f_ci->m_fattr = old_fattr;\n\t}\n\nout:\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_request_resume_key(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_ioctl_req *req,\n\t\t\t\t    struct resume_key_ioctl_rsp *key_rsp)\n{\n\tstruct ksmbd_file *fp;\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tmemset(key_rsp, 0, sizeof(*key_rsp));\n\tkey_rsp->ResumeKey[0] = req->VolatileFileId;\n\tkey_rsp->ResumeKey[1] = req->PersistentFileId;\n\tksmbd_fd_put(work, fp);\n\n\treturn 0;\n}\n\n/**\n * smb2_ioctl() - handler for smb2 ioctl command\n * @work:\tsmb work containing ioctl command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_ioctl(struct ksmbd_work *work)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tunsigned int cnt_code, nbytes = 0, out_buf_len, in_buf_len;\n\tu64 id = KSMBD_NO_FID;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint ret = 0;\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id))\n\t\tid = req->VolatileFileId;\n\n\tif (req->Flags != cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL)) {\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tcnt_code = le32_to_cpu(req->CtlCode);\n\tret = smb2_calc_max_out_buf_len(work, 48,\n\t\t\t\t\tle32_to_cpu(req->MaxOutputResponse));\n\tif (ret < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tgoto out;\n\t}\n\tout_buf_len = (unsigned int)ret;\n\tin_buf_len = le32_to_cpu(req->InputCount);\n\n\tswitch (cnt_code) {\n\tcase FSCTL_DFS_GET_REFERRALS:\n\tcase FSCTL_DFS_GET_REFERRALS_EX:\n\t\t/* Not support DFS yet */\n\t\trsp->hdr.Status = STATUS_FS_DRIVER_REQUIRED;\n\t\tgoto out;\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tstruct file_object_buf_type1_ioctl_rsp *obj_buf;\n\n\t\tnbytes = sizeof(struct file_object_buf_type1_ioctl_rsp);\n\t\tobj_buf = (struct file_object_buf_type1_ioctl_rsp *)\n\t\t\t&rsp->Buffer[0];\n\n\t\t/*\n\t\t * TODO: This is dummy implementation to pass smbtorture\n\t\t * Need to check correct response later\n\t\t */\n\t\tmemset(obj_buf->ObjectId, 0x0, 16);\n\t\tmemset(obj_buf->BirthVolumeId, 0x0, 16);\n\t\tmemset(obj_buf->BirthObjectId, 0x0, 16);\n\t\tmemset(obj_buf->DomainId, 0x0, 16);\n\n\t\tbreak;\n\t}\n\tcase FSCTL_PIPE_TRANSCEIVE:\n\t\tout_buf_len = min_t(u32, KSMBD_IPC_MAX_PAYLOAD, out_buf_len);\n\t\tnbytes = fsctl_pipe_transceive(work, id, out_buf_len, req, rsp);\n\t\tbreak;\n\tcase FSCTL_VALIDATE_NEGOTIATE_INFO:\n\t\tif (conn->dialect < SMB30_PROT_ID) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct validate_negotiate_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tif (out_buf_len < sizeof(struct validate_negotiate_info_rsp))\n\t\t\treturn -EINVAL;\n\n\t\tret = fsctl_validate_negotiate_info(conn,\n\t\t\t(struct validate_negotiate_info_req *)&req->Buffer[0],\n\t\t\t(struct validate_negotiate_info_rsp *)&rsp->Buffer[0],\n\t\t\tin_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnbytes = sizeof(struct validate_negotiate_info_rsp);\n\t\trsp->PersistentFileId = SMB2_NO_FID;\n\t\trsp->VolatileFileId = SMB2_NO_FID;\n\t\tbreak;\n\tcase FSCTL_QUERY_NETWORK_INTERFACE_INFO:\n\t\tret = fsctl_query_iface_info_ioctl(conn, rsp, out_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnbytes = ret;\n\t\tbreak;\n\tcase FSCTL_REQUEST_RESUME_KEY:\n\t\tif (out_buf_len < sizeof(struct resume_key_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_request_resume_key(work, req,\n\t\t\t\t\t       (struct resume_key_ioctl_rsp *)&rsp->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\tnbytes = sizeof(struct resume_key_ioctl_rsp);\n\t\tbreak;\n\tcase FSCTL_COPYCHUNK:\n\tcase FSCTL_COPYCHUNK_WRITE:\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct copychunk_ioctl_req)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (out_buf_len < sizeof(struct copychunk_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = sizeof(struct copychunk_ioctl_rsp);\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\tfsctl_copychunk(work,\n\t\t\t\t(struct copychunk_ioctl_req *)&req->Buffer[0],\n\t\t\t\tle32_to_cpu(req->CtlCode),\n\t\t\t\tle32_to_cpu(req->InputCount),\n\t\t\t\treq->VolatileFileId,\n\t\t\t\treq->PersistentFileId,\n\t\t\t\trsp);\n\t\tbreak;\n\tcase FSCTL_SET_SPARSE:\n\t\tif (in_buf_len < sizeof(struct file_sparse)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_set_sparse(work, id,\n\t\t\t\t       (struct file_sparse *)&req->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase FSCTL_SET_ZERO_DATA:\n\t{\n\t\tstruct file_zero_data_information *zero_data;\n\t\tstruct ksmbd_file *fp;\n\t\tloff_t off, len, bfz;\n\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct file_zero_data_information)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzero_data =\n\t\t\t(struct file_zero_data_information *)&req->Buffer[0];\n\n\t\toff = le64_to_cpu(zero_data->FileOffset);\n\t\tbfz = le64_to_cpu(zero_data->BeyondFinalZero);\n\t\tif (off > bfz) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen = bfz - off;\n\t\tif (len) {\n\t\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\t\tif (!fp) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ksmbd_vfs_zero_data(work, fp, off, len);\n\t\t\tksmbd_fd_put(work, fp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t\tif (in_buf_len < sizeof(struct file_allocated_range_buffer)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_query_allocated_ranges(work, id,\n\t\t\t(struct file_allocated_range_buffer *)&req->Buffer[0],\n\t\t\t(struct file_allocated_range_buffer *)&rsp->Buffer[0],\n\t\t\tout_buf_len /\n\t\t\tsizeof(struct file_allocated_range_buffer), &nbytes);\n\t\tif (ret == -E2BIG) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t} else if (ret < 0) {\n\t\t\tnbytes = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes *= sizeof(struct file_allocated_range_buffer);\n\t\tbreak;\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tstruct reparse_data_buffer *reparse_ptr;\n\t\tstruct ksmbd_file *fp;\n\n\t\treparse_ptr = (struct reparse_data_buffer *)&rsp->Buffer[0];\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tpr_err(\"not found fp!!\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treparse_ptr->ReparseTag =\n\t\t\tsmb2_get_reparse_tag_special_file(file_inode(fp->filp)->i_mode);\n\t\treparse_ptr->ReparseDataLength = 0;\n\t\tksmbd_fd_put(work, fp);\n\t\tnbytes = sizeof(struct reparse_data_buffer);\n\t\tbreak;\n\t}\n\tcase FSCTL_DUPLICATE_EXTENTS_TO_FILE:\n\t{\n\t\tstruct ksmbd_file *fp_in, *fp_out = NULL;\n\t\tstruct duplicate_extents_to_file *dup_ext;\n\t\tloff_t src_off, dst_off, length, cloned;\n\n\t\tif (in_buf_len < sizeof(struct duplicate_extents_to_file)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdup_ext = (struct duplicate_extents_to_file *)&req->Buffer[0];\n\n\t\tfp_in = ksmbd_lookup_fd_slow(work, dup_ext->VolatileFileHandle,\n\t\t\t\t\t     dup_ext->PersistentFileHandle);\n\t\tif (!fp_in) {\n\t\t\tpr_err(\"not found file handle in duplicate extent to file\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfp_out = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp_out) {\n\t\t\tpr_err(\"not found fp\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto dup_ext_out;\n\t\t}\n\n\t\tsrc_off = le64_to_cpu(dup_ext->SourceFileOffset);\n\t\tdst_off = le64_to_cpu(dup_ext->TargetFileOffset);\n\t\tlength = le64_to_cpu(dup_ext->ByteCount);\n\t\t/*\n\t\t * XXX: It is not clear if FSCTL_DUPLICATE_EXTENTS_TO_FILE\n\t\t * should fall back to vfs_copy_file_range().  This could be\n\t\t * beneficial when re-exporting nfs/smb mount, but note that\n\t\t * this can result in partial copy that returns an error status.\n\t\t * If/when FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX is implemented,\n\t\t * fall back to vfs_copy_file_range(), should be avoided when\n\t\t * the flag DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC is set.\n\t\t */\n\t\tcloned = vfs_clone_file_range(fp_in->filp, src_off,\n\t\t\t\t\t      fp_out->filp, dst_off, length, 0);\n\t\tif (cloned == -EXDEV || cloned == -EOPNOTSUPP) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto dup_ext_out;\n\t\t} else if (cloned != length) {\n\t\t\tcloned = vfs_copy_file_range(fp_in->filp, src_off,\n\t\t\t\t\t\t     fp_out->filp, dst_off,\n\t\t\t\t\t\t     length, 0);\n\t\t\tif (cloned != length) {\n\t\t\t\tif (cloned < 0)\n\t\t\t\t\tret = cloned;\n\t\t\t\telse\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\ndup_ext_out:\n\t\tksmbd_fd_put(work, fp_in);\n\t\tksmbd_fd_put(work, fp_out);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tksmbd_debug(SMB, \"not implemented yet ioctl command 0x%x\\n\",\n\t\t\t    cnt_code);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trsp->CtlCode = cpu_to_le32(cnt_code);\n\trsp->InputCount = cpu_to_le32(0);\n\trsp->InputOffset = cpu_to_le32(112);\n\trsp->OutputOffset = cpu_to_le32(112);\n\trsp->OutputCount = cpu_to_le32(nbytes);\n\trsp->StructureSize = cpu_to_le16(49);\n\trsp->Reserved = cpu_to_le16(0);\n\trsp->Flags = cpu_to_le32(0);\n\trsp->Reserved2 = cpu_to_le32(0);\n\tinc_rfc1001_len(work->response_buf, 48 + nbytes);\n\n\treturn 0;\n\nout:\n\tif (ret == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (ret == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\telse if (ret == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\telse if (ret == -ENOSPC)\n\t\trsp->hdr.Status = STATUS_BUFFER_TOO_SMALL;\n\telse if (ret < 0 || rsp->hdr.Status == 0)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\tsmb2_set_err_rsp(work);\n\treturn 0;\n}\n\n/**\n * smb20_oplock_break_ack() - handler for smb2.0 oplock break command\n * @work:\tsmb work containing oplock break command buffer\n *\n * Return:\t0\n */\nstatic void smb20_oplock_break_ack(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_file *fp;\n\tstruct oplock_info *opinfo = NULL;\n\t__le32 err = 0;\n\tint ret = 0;\n\tu64 volatile_id, persistent_id;\n\tchar req_oplevel = 0, rsp_oplevel = 0;\n\tunsigned int oplock_change_type;\n\n\tvolatile_id = req->VolatileFid;\n\tpersistent_id = req->PersistentFid;\n\treq_oplevel = req->OplockLevel;\n\tksmbd_debug(OPLOCK, \"v_id %llu, p_id %llu request oplock level %d\\n\",\n\t\t    volatile_id, persistent_id, req_oplevel);\n\n\tfp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tif (!fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn;\n\t}\n\n\topinfo = opinfo_get(fp);\n\tif (!opinfo) {\n\t\tpr_err(\"unexpected null oplock_info\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn;\n\t}\n\n\tif (opinfo->level == SMB2_OPLOCK_LEVEL_NONE) {\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tgoto err_out;\n\t}\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tksmbd_debug(SMB, \"unexpected oplock state 0x%x\\n\", opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t    (req_oplevel != SMB2_OPLOCK_LEVEL_II &&\n\t     req_oplevel != SMB2_OPLOCK_LEVEL_NONE)) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t   req_oplevel != SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t} else if (req_oplevel == SMB2_OPLOCK_LEVEL_II ||\n\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t    req_oplevel == SMB2_OPLOCK_LEVEL_II) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_READ;\n\t\t} else if ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t\t    opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else {\n\t\t\toplock_change_type = 0;\n\t\t}\n\t} else {\n\t\toplock_change_type = 0;\n\t}\n\n\tswitch (oplock_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_II;\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown oplock change 0x%x -> 0x%x\\n\",\n\t\t       opinfo->level, rsp_oplevel);\n\t}\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\trsp->StructureSize = cpu_to_le16(24);\n\trsp->OplockLevel = rsp_oplevel;\n\trsp->Reserved = 0;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFid = volatile_id;\n\trsp->PersistentFid = persistent_id;\n\tinc_rfc1001_len(work->response_buf, 24);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\tsmb2_set_err_rsp(work);\n}\n\nstatic int check_lease_state(struct lease *lease, __le32 req_state)\n{\n\tif ((lease->new_state ==\n\t     (SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE)) &&\n\t    !(req_state & SMB2_LEASE_WRITE_CACHING_LE)) {\n\t\tlease->new_state = req_state;\n\t\treturn 0;\n\t}\n\n\tif (lease->new_state == req_state)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * smb21_lease_break_ack() - handler for smb2.1 lease break command\n * @work:\tsmb work containing lease break command buffer\n *\n * Return:\t0\n */\nstatic void smb21_lease_break_ack(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_lease_ack *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lease_ack *rsp = smb2_get_msg(work->response_buf);\n\tstruct oplock_info *opinfo;\n\t__le32 err = 0;\n\tint ret = 0;\n\tunsigned int lease_change_type;\n\t__le32 lease_state;\n\tstruct lease *lease;\n\n\tksmbd_debug(OPLOCK, \"smb21 lease break, lease state(0x%x)\\n\",\n\t\t    le32_to_cpu(req->LeaseState));\n\topinfo = lookup_lease_in_table(conn, req->LeaseKey);\n\tif (!opinfo) {\n\t\tksmbd_debug(OPLOCK, \"file not opened\\n\");\n\t\tsmb2_set_err_rsp(work);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\treturn;\n\t}\n\tlease = opinfo->o_lease;\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tpr_err(\"unexpected lease break state 0x%x\\n\",\n\t\t       opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif (check_lease_state(lease, req->LeaseState)) {\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\t\tksmbd_debug(OPLOCK,\n\t\t\t    \"req lease state: 0x%x, expected state: 0x%x\\n\",\n\t\t\t    req->LeaseState, lease->new_state);\n\t\tgoto err_out;\n\t}\n\n\tif (!atomic_read(&opinfo->breaking_cnt)) {\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\t/* check for bad lease state */\n\tif (req->LeaseState &\n\t    (~(SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE))) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\telse\n\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else if (lease->state == SMB2_LEASE_READ_CACHING_LE &&\n\t\t   req->LeaseState != SMB2_LEASE_NONE_LE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else {\n\t\t/* valid lease state changes */\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif (req->LeaseState == SMB2_LEASE_NONE_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else if (req->LeaseState & SMB2_LEASE_READ_CACHING_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_READ;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_HANDLE_TO_READ;\n\t\t} else {\n\t\t\tlease_change_type = 0;\n\t\t}\n\t}\n\n\tswitch (lease_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_HANDLE_TO_READ:\n\t\tret = opinfo_read_handle_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"unknown lease change 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t}\n\n\tlease_state = lease->state;\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\topinfo_put(opinfo);\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\trsp->StructureSize = cpu_to_le16(36);\n\trsp->Reserved = 0;\n\trsp->Flags = 0;\n\tmemcpy(rsp->LeaseKey, req->LeaseKey, 16);\n\trsp->LeaseState = lease_state;\n\trsp->LeaseDuration = 0;\n\tinc_rfc1001_len(work->response_buf, 36);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\n\topinfo_put(opinfo);\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * smb2_oplock_break() - dispatcher for smb2.0 and 2.1 oplock/lease break\n * @work:\tsmb work containing oplock/lease break command buffer\n *\n * Return:\t0\n */\nint smb2_oplock_break(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\n\tswitch (le16_to_cpu(req->StructureSize)) {\n\tcase OP_BREAK_STRUCT_SIZE_20:\n\t\tsmb20_oplock_break_ack(work);\n\t\tbreak;\n\tcase OP_BREAK_STRUCT_SIZE_21:\n\t\tsmb21_lease_break_ack(work);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"invalid break cmd %d\\n\",\n\t\t\t    le16_to_cpu(req->StructureSize));\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_notify() - handler for smb2 notify request\n * @work:   smb work containing notify command buffer\n *\n * Return:      0\n */\nint smb2_notify(struct ksmbd_work *work)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct smb2_change_notify_rsp *rsp;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (work->next_smb2_rcv_hdr_off && req->hdr.NextCommand) {\n\t\trsp->hdr.Status = STATUS_INTERNAL_ERROR;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\trsp->hdr.Status = STATUS_NOT_IMPLEMENTED;\n\treturn 0;\n}\n\n/**\n * smb2_is_sign_req() - handler for checking packet signing status\n * @work:\tsmb work containing notify command buffer\n * @command:\tSMB2 command id\n *\n * Return:\ttrue if packed is signed, false otherwise\n */\nbool smb2_is_sign_req(struct ksmbd_work *work, unsigned int command)\n{\n\tstruct smb2_hdr *rcv_hdr2 = smb2_get_msg(work->request_buf);\n\n\tif ((rcv_hdr2->Flags & SMB2_FLAGS_SIGNED) &&\n\t    command != SMB2_NEGOTIATE_HE &&\n\t    command != SMB2_SESSION_SETUP_HE &&\n\t    command != SMB2_OPLOCK_BREAK_HE)\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * smb2_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb2_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, 1,\n\t\t\t\tsignature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb2_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tstruct smb2_hdr *req_hdr;\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[2];\n\tsize_t len;\n\tint n_vec = 1;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, n_vec,\n\t\t\t\t signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb3_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tchar *signing_key;\n\tstruct smb2_hdr *hdr;\n\tstruct channel *chann;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tif (le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tread_lock(&work->sess->chann_lock);\n\t\tchann = lookup_chann_list(work->sess, conn);\n\t\tif (!chann) {\n\t\t\tread_unlock(&work->sess->chann_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsigning_key = chann->smb3signingkey;\n\t\tread_unlock(&work->sess->chann_lock);\n\t}\n\n\tif (!signing_key) {\n\t\tpr_err(\"SMB3 signing key is not generated\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb3_pdu(conn, signing_key, iov, 1, signature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb3_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb3_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *req_hdr, *hdr;\n\tstruct channel *chann;\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[2];\n\tint n_vec = 1;\n\tsize_t len;\n\tchar *signing_key;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (conn->binding == false &&\n\t    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tread_lock(&work->sess->chann_lock);\n\t\tchann = lookup_chann_list(work->sess, work->conn);\n\t\tif (!chann) {\n\t\t\tread_unlock(&work->sess->chann_lock);\n\t\t\treturn;\n\t\t}\n\t\tsigning_key = chann->smb3signingkey;\n\t\tread_unlock(&work->sess->chann_lock);\n\t}\n\n\tif (!signing_key)\n\t\treturn;\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec, signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_preauth_hash_rsp() - handler for computing preauth hash on response\n * @work:   smb work containing response buffer\n *\n */\nvoid smb3_preauth_hash_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct smb2_hdr *req, *rsp;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (le16_to_cpu(req->Command) == SMB2_NEGOTIATE_HE &&\n\t    conn->preauth_info)\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE && sess) {\n\t\t__u8 *hash_value;\n\n\t\tif (conn->binding) {\n\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn;\n\t\t\thash_value = preauth_sess->Preauth_HashValue;\n\t\t} else {\n\t\t\thash_value = sess->Preauth_HashValue;\n\t\t\tif (!hash_value)\n\t\t\t\treturn;\n\t\t}\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t hash_value);\n\t}\n}\n\nstatic void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)\n{\n\tstruct smb2_transform_hdr *tr_hdr = tr_buf + 4;\n\tstruct smb2_hdr *hdr = smb2_get_msg(old_buf);\n\tunsigned int orig_len = get_rfc1002_len(old_buf);\n\n\t/* tr_buf must be cleared by the caller */\n\ttr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;\n\ttr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);\n\ttr_hdr->Flags = cpu_to_le16(TRANSFORM_FLAG_ENCRYPTED);\n\tif (cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\tmemcpy(&tr_hdr->SessionId, &hdr->SessionId, 8);\n\tinc_rfc1001_len(tr_buf, sizeof(struct smb2_transform_hdr));\n\tinc_rfc1001_len(tr_buf, orig_len);\n}\n\nint smb3_encrypt_resp(struct ksmbd_work *work)\n{\n\tchar *buf = work->response_buf;\n\tstruct kvec iov[3];\n\tint rc = -ENOMEM;\n\tint buf_size = 0, rq_nvec = 2 + (work->aux_payload_sz ? 1 : 0);\n\n\tif (ARRAY_SIZE(iov) < rq_nvec)\n\t\treturn -ENOMEM;\n\n\twork->tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);\n\tif (!work->tr_buf)\n\t\treturn rc;\n\n\t/* fill transform header */\n\tfill_transform_hdr(work->tr_buf, buf, work->conn->cipher_type);\n\n\tiov[0].iov_base = work->tr_buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tbuf_size += iov[0].iov_len - 4;\n\n\tiov[1].iov_base = buf + 4;\n\tiov[1].iov_len = get_rfc1002_len(buf);\n\tif (work->aux_payload_sz) {\n\t\tiov[1].iov_len = work->resp_hdr_sz - 4;\n\n\t\tiov[2].iov_base = work->aux_payload_buf;\n\t\tiov[2].iov_len = work->aux_payload_sz;\n\t\tbuf_size += iov[2].iov_len;\n\t}\n\tbuf_size += iov[1].iov_len;\n\twork->resp_hdr_sz = iov[1].iov_len;\n\n\trc = ksmbd_crypt_message(work->conn, iov, rq_nvec, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf, iov[1].iov_base, iov[1].iov_len);\n\t*(__be32 *)work->tr_buf = cpu_to_be32(buf_size);\n\n\treturn rc;\n}\n\nbool smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = smb2_get_msg(buf);\n\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}\n\nint smb3_decrypt_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess;\n\tchar *buf = work->request_buf;\n\tunsigned int pdu_length = get_rfc1002_len(buf);\n\tstruct kvec iov[2];\n\tint buf_data_size = pdu_length - sizeof(struct smb2_transform_hdr);\n\tstruct smb2_transform_hdr *tr_hdr = smb2_get_msg(buf);\n\tint rc = 0;\n\n\tif (buf_data_size < sizeof(struct smb2_hdr)) {\n\t\tpr_err(\"Transform message is too small (%u)\\n\",\n\t\t       pdu_length);\n\t\treturn -ECONNABORTED;\n\t}\n\n\tif (buf_data_size < le32_to_cpu(tr_hdr->OriginalMessageSize)) {\n\t\tpr_err(\"Transform message is broken\\n\");\n\t\treturn -ECONNABORTED;\n\t}\n\n\tsess = ksmbd_session_lookup_all(conn, le64_to_cpu(tr_hdr->SessionId));\n\tif (!sess) {\n\t\tpr_err(\"invalid session id(%llx) in transform header\\n\",\n\t\t       le64_to_cpu(tr_hdr->SessionId));\n\t\treturn -ECONNABORTED;\n\t}\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_base = buf + sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_len = buf_data_size;\n\trc = ksmbd_crypt_message(conn, iov, 2, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf + 4, iov[1].iov_base, buf_data_size);\n\t*(__be32 *)buf = cpu_to_be32(buf_data_size);\n\n\treturn rc;\n}\n\nbool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *rsp = smb2_get_msg(work->response_buf);\n\n\tif (conn->dialect < SMB30_PROT_ID)\n\t\treturn false;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp = ksmbd_resp_buf_next(work);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE &&\n\t    rsp->Status == STATUS_SUCCESS)\n\t\treturn true;\n\treturn false;\n}\n", "// SPDX-License-Identifier: LGPL-2.1+\n/*\n *   Copyright (C) International Business Machines  Corp., 2007,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *   Copyright (C) 2020 Samsung Electronics Co., Ltd.\n *   Author(s): Namjae Jeon <linkinjeon@kernel.org>\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mnt_idmapping.h>\n\n#include \"smbacl.h\"\n#include \"smb_common.h\"\n#include \"server.h\"\n#include \"misc.h\"\n#include \"mgmt/share_config.h\"\n\nstatic const struct smb_sid domain = {1, 4, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(21), cpu_to_le32(1), cpu_to_le32(2), cpu_to_le32(3),\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* security id for everyone/world system group */\nstatic const struct smb_sid creator_owner = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {0} };\n/* security id for everyone/world system group */\nstatic const struct smb_sid creator_group = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {cpu_to_le32(1)} };\n\n/* security id for everyone/world system group */\nstatic const struct smb_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n/* security id for Authenticated Users system group */\nstatic const struct smb_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\n/* S-1-22-1 Unmapped Unix users */\nstatic const struct smb_sid sid_unix_users = {1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-22-2 Unmapped Unix groups */\nstatic const struct smb_sid sid_unix_groups = { 1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/*\n * See http://technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx\n */\n\n/* S-1-5-88 MS NFS and Apple style UID/GID/mode */\n\n/* S-1-5-88-1 Unix uid */\nstatic const struct smb_sid sid_unix_NFS_users = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-5-88-2 Unix gid */\nstatic const struct smb_sid sid_unix_NFS_groups = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-5-88-3 Unix mode */\nstatic const struct smb_sid sid_unix_NFS_mode = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/*\n * if the two SIDs (roughly equivalent to a UUID for a user or group) are\n * the same returns zero, if they do not match returns non-zero.\n */\nint compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif (!ctsid || !cwsid)\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t    le32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}\n\nstatic void smb_copy_sid(struct smb_sid *dst, const struct smb_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}\n\n/*\n * change posix mode to reflect permissions\n * pmode is the existing mode (we only want to overwrite part of this\n * bits to set can be: S_IRWXU, S_IRWXG or S_IRWXO ie 00700 or 00070 or 00007\n */\nstatic umode_t access_flags_to_mode(struct smb_fattr *fattr, __le32 ace_flags,\n\t\t\t\t    int type)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\tumode_t mode = 0;\n\n\tif (flags & GENERIC_ALL) {\n\t\tmode = 0777;\n\t\tksmbd_debug(SMB, \"all perms\\n\");\n\t\treturn mode;\n\t}\n\n\tif ((flags & GENERIC_READ) || (flags & FILE_READ_RIGHTS))\n\t\tmode = 0444;\n\tif ((flags & GENERIC_WRITE) || (flags & FILE_WRITE_RIGHTS)) {\n\t\tmode |= 0222;\n\t\tif (S_ISDIR(fattr->cf_mode))\n\t\t\tmode |= 0111;\n\t}\n\tif ((flags & GENERIC_EXECUTE) || (flags & FILE_EXEC_RIGHTS))\n\t\tmode |= 0111;\n\n\tif (type == ACCESS_DENIED_ACE_TYPE || type == ACCESS_DENIED_OBJECT_ACE_TYPE)\n\t\tmode = ~mode;\n\n\tksmbd_debug(SMB, \"access flags 0x%x mode now %04o\\n\", flags, mode);\n\n\treturn mode;\n}\n\n/*\n * Generate access flags to reflect permissions mode is the existing mode.\n * This function is called for every ACE in the DACL whose SID matches\n * with either owner or group or everyone.\n */\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t __u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/*\n\t * check for R/W/X UGO since we do not know whose flags\n\t * is this but we have cleared all the bits sans RWX for\n\t * either user or group or other as per bits_to_use\n\t */\n\tif (mode & 0444)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & 0222)\n\t\t*pace_flags |= FILE_WRITE_RIGHTS;\n\tif (mode & 0111)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tksmbd_debug(SMB, \"mode: %o, access flags now 0x%x\\n\",\n\t\t    mode, *pace_flags);\n}\n\nstatic __u16 fill_ace_for_sid(struct smb_ace *pntace,\n\t\t\t      const struct smb_sid *psid, int type, int flags,\n\t\t\t      umode_t mode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = type;\n\tpntace->flags = flags;\n\tmode_to_access_flags(mode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\nvoid id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid)\n{\n\tswitch (sidtype) {\n\tcase SIDOWNER:\n\t\tsmb_copy_sid(ssid, &server_conf.domain_sid);\n\t\tbreak;\n\tcase SIDUNIX_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_users);\n\t\tbreak;\n\tcase SIDUNIX_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_groups);\n\t\tbreak;\n\tcase SIDCREATOR_OWNER:\n\t\tsmb_copy_sid(ssid, &creator_owner);\n\t\treturn;\n\tcase SIDCREATOR_GROUP:\n\t\tsmb_copy_sid(ssid, &creator_group);\n\t\treturn;\n\tcase SIDNFS_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_users);\n\t\tbreak;\n\tcase SIDNFS_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_groups);\n\t\tbreak;\n\tcase SIDNFS_MODE:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_mode);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* RID */\n\tssid->sub_auth[ssid->num_subauth] = cpu_to_le32(cid);\n\tssid->num_subauth++;\n}\n\nstatic int sid_to_id(struct user_namespace *user_ns,\n\t\t     struct smb_sid *psid, uint sidtype,\n\t\t     struct smb_fattr *fattr)\n{\n\tint rc = -EINVAL;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tpr_err(\"%s: %u subauthorities is too many!\\n\",\n\t\t       __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tuid = mapped_kuid_user(user_ns, &init_user_ns, KUIDT_INIT(id));\n\t\tif (uid_valid(uid)) {\n\t\t\tfattr->cf_uid = uid;\n\t\t\trc = 0;\n\t\t}\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tgid = mapped_kgid_user(user_ns, &init_user_ns, KGIDT_INIT(id));\n\t\tif (gid_valid(gid)) {\n\t\t\tfattr->cf_gid = gid;\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nvoid posix_state_to_acl(struct posix_acl_state *state,\n\t\t\tstruct posix_acl_entry *pace)\n{\n\tint i;\n\n\tpace->e_tag = ACL_USER_OBJ;\n\tpace->e_perm = state->owner.allow;\n\tfor (i = 0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tpace->e_perm = state->users->aces[i].perms.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\tpace->e_perm = state->group.allow;\n\n\tfor (i = 0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tpace->e_perm = state->groups->aces[i].perms.allow;\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tpace->e_perm = state->mask.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\tpace->e_perm = state->other.allow;\n}\n\nint init_acl_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't know which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt * sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid free_acl_state(struct posix_acl_state *state)\n{\n\tkfree(state->users);\n\tkfree(state->groups);\n}\n\nstatic void parse_dacl(struct user_namespace *user_ns,\n\t\t       struct smb_acl *pdacl, char *end_of_acl,\n\t\t       struct smb_sid *pownersid, struct smb_sid *pgrpsid,\n\t\t       struct smb_fattr *fattr)\n{\n\tint i, ret;\n\tint num_aces = 0;\n\tunsigned int acl_size;\n\tchar *acl_base;\n\tstruct smb_ace **ppace;\n\tstruct posix_acl_entry *cf_pace, *cf_pdace;\n\tstruct posix_acl_state acl_state, default_acl_state;\n\tumode_t mode = 0, acl_mode;\n\tbool owner_found = false, group_found = false, others_found = false;\n\n\tif (!pdacl)\n\t\treturn;\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + sizeof(struct smb_acl) ||\n\t    end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tpr_err(\"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tksmbd_debug(SMB, \"DACL revision %d size %d num aces %d\\n\",\n\t\t    le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t    le32_to_cpu(pdacl->num_aces));\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct smb_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces <= 0)\n\t\treturn;\n\n\tif (num_aces > ULONG_MAX / sizeof(struct smb_ace *))\n\t\treturn;\n\n\tppace = kmalloc_array(num_aces, sizeof(struct smb_ace *), GFP_KERNEL);\n\tif (!ppace)\n\t\treturn;\n\n\tret = init_acl_state(&acl_state, num_aces);\n\tif (ret)\n\t\treturn;\n\tret = init_acl_state(&default_acl_state, num_aces);\n\tif (ret) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn;\n\t}\n\n\t/*\n\t * reset rwx permissions for user/group/other.\n\t * Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t * user/group/other have no permissions\n\t */\n\tfor (i = 0; i < num_aces; ++i) {\n\t\tif (end_of_acl - acl_base < acl_size)\n\t\t\tbreak;\n\n\t\tppace[i] = (struct smb_ace *)(acl_base + acl_size);\n\t\tacl_base = (char *)ppace[i];\n\t\tacl_size = offsetof(struct smb_ace, sid) +\n\t\t\toffsetof(struct smb_sid, sub_auth);\n\n\t\tif (end_of_acl - acl_base < acl_size ||\n\t\t    ppace[i]->sid.num_subauth > SID_MAX_SUB_AUTHORITIES ||\n\t\t    (end_of_acl - acl_base <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth) ||\n\t\t    (le16_to_cpu(ppace[i]->size) <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth))\n\t\t\tbreak;\n\n\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\tppace[i]->access_req =\n\t\t\tsmb_map_generic_desired_access(ppace[i]->access_req);\n\n\t\tif (!(compare_sids(&ppace[i]->sid, &sid_unix_NFS_mode))) {\n\t\t\tfattr->cf_mode =\n\t\t\t\tle32_to_cpu(ppace[i]->sid.sub_auth[2]);\n\t\t\tbreak;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pownersid)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0700;\n\n\t\t\tif (!owner_found) {\n\t\t\t\tmode &= ~(0700);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\towner_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pgrpsid) ||\n\t\t\t   ppace[i]->sid.sub_auth[ppace[i]->sid.num_subauth - 1] ==\n\t\t\t    DOMAIN_USER_RID_LE) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0070;\n\t\t\tif (!group_found) {\n\t\t\t\tmode &= ~(0070);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tgroup_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_everyone)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0007;\n\t\t\tif (!others_found) {\n\t\t\t\tmode &= ~(0007);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tothers_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_owner)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_group)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_authusers)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct smb_fattr temp_fattr;\n\n\t\t\tacl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\ttemp_fattr.cf_uid = INVALID_UID;\n\t\t\tret = sid_to_id(user_ns, &ppace[i]->sid, SIDOWNER, &temp_fattr);\n\t\t\tif (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {\n\t\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t\t       __func__, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tacl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tacl_state.users->aces[acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t}\n\t}\n\tkfree(ppace);\n\n\tif (owner_found) {\n\t\t/* The owner must be set to at least read-only. */\n\t\tacl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tacl_state.users->aces[acl_state.users->n].uid = fattr->cf_uid;\n\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\tfattr->cf_uid;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t}\n\n\tif (group_found) {\n\t\tacl_state.group.allow = (mode & 0070) >> 3;\n\t\tacl_state.groups->aces[acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t\tdefault_acl_state.group.allow = (mode & 0070) >> 3;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t}\n\n\tif (others_found) {\n\t\tfattr->cf_mode &= ~(0007);\n\t\tfattr->cf_mode |= mode & 0007;\n\n\t\tacl_state.other.allow = mode & 0007;\n\t\tdefault_acl_state.other.allow = mode & 0007;\n\t}\n\n\tif (acl_state.users->n || acl_state.groups->n) {\n\t\tacl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_acls =\n\t\t\t\tposix_acl_alloc(acl_state.users->n +\n\t\t\t\t\tacl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_acls) {\n\t\t\t\tcf_pace = fattr->cf_acls->a_entries;\n\t\t\t\tposix_state_to_acl(&acl_state, cf_pace);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_acl_state.users->n || default_acl_state.groups->n) {\n\t\tdefault_acl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_dacls =\n\t\t\t\tposix_acl_alloc(default_acl_state.users->n +\n\t\t\t\tdefault_acl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_dacls) {\n\t\t\t\tcf_pdace = fattr->cf_dacls->a_entries;\n\t\t\t\tposix_state_to_acl(&default_acl_state, cf_pdace);\n\t\t\t}\n\t\t}\n\t}\n\tfree_acl_state(&acl_state);\n\tfree_acl_state(&default_acl_state);\n}\n\nstatic void set_posix_acl_entries_dacl(struct user_namespace *user_ns,\n\t\t\t\t       struct smb_ace *pndace,\n\t\t\t\t       struct smb_fattr *fattr, u32 *num_aces,\n\t\t\t\t       u16 *size, u32 nt_aces_num)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct smb_sid *sid;\n\tstruct smb_ace *ntace;\n\tint i, j;\n\n\tif (!fattr->cf_acls)\n\t\tgoto posix_default_acl;\n\n\tpace = fattr->cf_acls->a_entries;\n\tfor (i = 0; i < fattr->cf_acls->a_count; i++, pace++) {\n\t\tint flags = 0;\n\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\t\t\tunsigned int sid_type = SIDOWNER;\n\n\t\t\tuid = posix_acl_uid_translate(user_ns, pace);\n\t\t\tif (!uid)\n\t\t\t\tsid_type = SIDUNIX_USER;\n\t\t\tid_to_sid(uid, sid_type, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(user_ns, pace);\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, sid);\n\t\t} else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {\n\t\t\tsmb_copy_sid(sid, &sid_everyone);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\t\tntace = pndace;\n\t\tfor (j = 0; j < nt_aces_num; j++) {\n\t\t\tif (ntace->sid.sub_auth[ntace->sid.num_subauth - 1] ==\n\t\t\t\t\tsid->sub_auth[sid->num_subauth - 1])\n\t\t\t\tgoto pass_same_sid;\n\t\t\tntace = (struct smb_ace *)((char *)ntace +\n\t\t\t\t\tle16_to_cpu(ntace->size));\n\t\t}\n\n\t\tif (S_ISDIR(fattr->cf_mode) && pace->e_tag == ACL_OTHER)\n\t\t\tflags = 0x03;\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, flags,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\n\t\tif (S_ISDIR(fattr->cf_mode) &&\n\t\t    (pace->e_tag == ACL_USER || pace->e_tag == ACL_GROUP)) {\n\t\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED,\n\t\t\t\t\t0x03, pace->e_perm, 0777);\n\t\t\t(*num_aces)++;\n\t\t\tif (pace->e_tag == ACL_USER)\n\t\t\t\tntace->access_req |=\n\t\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\t}\n\npass_same_sid:\n\t\tkfree(sid);\n\t}\n\n\tif (nt_aces_num)\n\t\treturn;\n\nposix_default_acl:\n\tif (!fattr->cf_dacls)\n\t\treturn;\n\n\tpace = fattr->cf_dacls->a_entries;\n\tfor (i = 0; i < fattr->cf_dacls->a_count; i++, pace++) {\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\n\t\t\tuid = posix_acl_uid_translate(user_ns, pace);\n\t\t\tid_to_sid(uid, SIDCREATOR_OWNER, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(user_ns, pace);\n\t\t\tid_to_sid(gid, SIDCREATOR_GROUP, sid);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, 0x0b,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\tkfree(sid);\n\t}\n}\n\nstatic void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic void set_mode_dacl(struct user_namespace *user_ns,\n\t\t\t  struct smb_acl *pndacl, struct smb_fattr *fattr)\n{\n\tstruct smb_ace *pace, *pndace;\n\tu32 num_aces = 0;\n\tu16 size = 0, ace_size = 0;\n\tuid_t uid;\n\tconst struct smb_sid *sid;\n\n\tpace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\n\tif (fattr->cf_acls) {\n\t\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t\t   &num_aces, &size, num_aces);\n\t\tgoto out;\n\t}\n\n\t/* owner RID */\n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (uid)\n\t\tsid = &server_conf.domain_sid;\n\telse\n\t\tsid = &sid_unix_users;\n\tace_size = fill_ace_for_sid(pace, sid, ACCESS_ALLOWED, 0,\n\t\t\t\t    fattr->cf_mode, 0700);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] = cpu_to_le32(uid);\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t/* Group RID */\n\tace_size = fill_ace_for_sid(pace, &sid_unix_groups,\n\t\t\t\t    ACCESS_ALLOWED, 0, fattr->cf_mode, 0070);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] =\n\t\tcpu_to_le32(from_kgid(&init_user_ns, fattr->cf_gid));\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\tnum_aces = 3;\n\n\tif (S_ISDIR(fattr->cf_mode)) {\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t/* creator owner */\n\t\tsize += fill_ace_for_sid(pace, &creator_owner, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0700);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t/* creator group */\n\t\tsize += fill_ace_for_sid(pace, &creator_group, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0070);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\t\tnum_aces = 5;\n\t}\n\n\t/* other */\n\tsize += fill_ace_for_sid(pace, &sid_everyone, ACCESS_ALLOWED, 0,\n\t\t\t\t fattr->cf_mode, 0007);\n\nout:\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic int parse_sid(struct smb_sid *psid, char *end_of_acl)\n{\n\t/*\n\t * validate that we do not go past end of ACL - sid must be at least 8\n\t * bytes long (assuming no sub-auths - e.g. the null SID\n\t */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tpr_err(\"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Convert CIFS ACL to POSIX form */\nint parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   int acl_len, struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\tint pntsd_type;\n\n\tif (!pntsd)\n\t\treturn -EIO;\n\n\tif (acl_len < sizeof(struct smb_ntsd))\n\t\treturn -EINVAL;\n\n\towner_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct smb_acl *)((char *)pntsd + dacloffset);\n\tksmbd_debug(SMB,\n\t\t    \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t    pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t    le32_to_cpu(pntsd->gsidoffset),\n\t\t    le32_to_cpu(pntsd->sacloffset), dacloffset);\n\n\tpntsd_type = le16_to_cpu(pntsd->type);\n\tif (!(pntsd_type & DACL_PRESENT)) {\n\t\tksmbd_debug(SMB, \"DACL_PRESENT in DACL type is not set\\n\");\n\t\treturn rc;\n\t}\n\n\tpntsd->type = cpu_to_le16(DACL_PRESENT);\n\n\tif (pntsd->osidoffset) {\n\t\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = sid_to_id(user_ns, owner_sid_ptr, SIDOWNER, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t       __func__, rc);\n\t\t\towner_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif (pntsd->gsidoffset) {\n\t\trc = parse_sid(group_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t\trc = sid_to_id(user_ns, group_sid_ptr, SIDUNIX_GROUP, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgroup_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif ((pntsd_type & (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ)) ==\n\t    (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ))\n\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\tif (pntsd_type & DACL_PROTECTED)\n\t\tpntsd->type |= cpu_to_le16(DACL_PROTECTED);\n\n\tif (dacloffset) {\n\t\tparse_dacl(user_ns, dacl_ptr, end_of_acl,\n\t\t\t   owner_sid_ptr, group_sid_ptr, fattr);\n\t}\n\n\treturn 0;\n}\n\n/* Convert permission bits from mode to equivalent CIFS ACL */\nint build_sec_desc(struct user_namespace *user_ns,\n\t\t   struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,\n\t\t   int addition_info, __u32 *secdesclen,\n\t\t   struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\t__u32 offset;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct smb_acl *dacl_ptr = NULL; /* no need for SACL ptr */\n\tuid_t uid;\n\tgid_t gid;\n\tunsigned int sid_type = SIDOWNER;\n\n\tnowner_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!nowner_sid_ptr)\n\t\treturn -ENOMEM;\n\n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, nowner_sid_ptr);\n\n\tngroup_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!ngroup_sid_ptr) {\n\t\tkfree(nowner_sid_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\tgid = from_kgid(&init_user_ns, fattr->cf_gid);\n\tid_to_sid(gid, SIDUNIX_GROUP, ngroup_sid_ptr);\n\n\toffset = sizeof(struct smb_ntsd);\n\tpntsd->sacloffset = 0;\n\tpntsd->revision = cpu_to_le16(1);\n\tpntsd->type = cpu_to_le16(SELF_RELATIVE);\n\tif (ppntsd)\n\t\tpntsd->type |= ppntsd->type;\n\n\tif (addition_info & OWNER_SECINFO) {\n\t\tpntsd->osidoffset = cpu_to_le32(offset);\n\t\towner_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (nowner_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & GROUP_SECINFO) {\n\t\tpntsd->gsidoffset = cpu_to_le32(offset);\n\t\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (ngroup_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & DACL_SECINFO) {\n\t\tpntsd->type |= cpu_to_le16(DACL_PRESENT);\n\t\tdacl_ptr = (struct smb_acl *)((char *)pntsd + offset);\n\t\tdacl_ptr->revision = cpu_to_le16(2);\n\t\tdacl_ptr->size = cpu_to_le16(sizeof(struct smb_acl));\n\t\tdacl_ptr->num_aces = 0;\n\n\t\tif (!ppntsd) {\n\t\t\tset_mode_dacl(user_ns, dacl_ptr, fattr);\n\t\t} else if (!ppntsd->dacloffset) {\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct smb_acl *ppdacl_ptr;\n\n\t\t\tppdacl_ptr = (struct smb_acl *)((char *)ppntsd +\n\t\t\t\t\t\tle32_to_cpu(ppntsd->dacloffset));\n\t\t\tset_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,\n\t\t\t\t       nowner_sid_ptr, ngroup_sid_ptr, fattr);\n\t\t}\n\t\tpntsd->dacloffset = cpu_to_le32(offset);\n\t\toffset += le16_to_cpu(dacl_ptr->size);\n\t}\n\nout:\n\tkfree(nowner_sid_ptr);\n\tkfree(ngroup_sid_ptr);\n\t*secdesclen = offset;\n\treturn rc;\n}\n\nstatic void smb_set_ace(struct smb_ace *ace, const struct smb_sid *sid, u8 type,\n\t\t\tu8 flags, __le32 access_req)\n{\n\tace->type = type;\n\tace->flags = flags;\n\tace->access_req = access_req;\n\tsmb_copy_sid(&ace->sid, sid);\n\tace->size = cpu_to_le16(1 + 1 + 2 + 4 + 1 + 1 + 6 + (sid->num_subauth * 4));\n}\n\nint smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}\n\nbool smb_inherit_flags(int flags, bool is_dir)\n{\n\tif (!is_dir)\n\t\treturn (flags & OBJECT_INHERIT_ACE) != 0;\n\n\tif (flags & OBJECT_INHERIT_ACE && !(flags & NO_PROPAGATE_INHERIT_ACE))\n\t\treturn true;\n\n\tif (flags & CONTAINER_INHERIT_ACE)\n\t\treturn true;\n\treturn false;\n}\n\nint smb_check_perm_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t\t__le32 *pdaccess, int uid)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tstruct smb_ntsd *pntsd = NULL;\n\tstruct smb_acl *pdacl;\n\tstruct posix_acl *posix_acls;\n\tint rc = 0, acl_size;\n\tstruct smb_sid sid;\n\tint granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);\n\tstruct smb_ace *ace;\n\tint i, found = 0;\n\tunsigned int access_bits = 0;\n\tstruct smb_ace *others_ace = NULL;\n\tstruct posix_acl_entry *pa_entry;\n\tunsigned int sid_type = SIDOWNER;\n\tchar *end_of_acl;\n\n\tksmbd_debug(SMB, \"check permission using windows acl\\n\");\n\tacl_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t  path->dentry, &pntsd);\n\tif (acl_size <= 0 || !pntsd || !pntsd->dacloffset) {\n\t\tkfree(pntsd);\n\t\treturn 0;\n\t}\n\n\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\tend_of_acl = ((char *)pntsd) + acl_size;\n\tif (end_of_acl <= (char *)pdacl) {\n\t\tkfree(pntsd);\n\t\treturn 0;\n\t}\n\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size) ||\n\t    le16_to_cpu(pdacl->size) < sizeof(struct smb_acl)) {\n\t\tkfree(pntsd);\n\t\treturn 0;\n\t}\n\n\tif (!pdacl->num_aces) {\n\t\tif (!(le16_to_cpu(pdacl->size) - sizeof(struct smb_acl)) &&\n\t\t    *pdaccess & ~(FILE_READ_CONTROL_LE | FILE_WRITE_DAC_LE)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\tkfree(pntsd);\n\t\treturn 0;\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\t\tgranted |= le32_to_cpu(ace->access_req);\n\t\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t\t\tif (end_of_acl < (char *)ace)\n\t\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, &sid);\n\n\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\tif (!compare_sids(&sid, &ace->sid) ||\n\t\t    !compare_sids(&sid_unix_NFS_mode, &ace->sid)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!compare_sids(&sid_everyone, &ace->sid))\n\t\t\tothers_ace = ace;\n\n\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t\tif (end_of_acl < (char *)ace)\n\t\t\tgoto err_out;\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE && found) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tgranted |= le32_to_cpu(ace->access_req);\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tposix_acls = get_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);\n\t\tif (posix_acls && !found) {\n\t\t\tunsigned int id = -1;\n\n\t\t\tpa_entry = posix_acls->a_entries;\n\t\t\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++) {\n\t\t\t\tif (pa_entry->e_tag == ACL_USER)\n\t\t\t\t\tid = posix_acl_uid_translate(user_ns, pa_entry);\n\t\t\t\telse if (pa_entry->e_tag == ACL_GROUP)\n\t\t\t\t\tid = posix_acl_gid_translate(user_ns, pa_entry);\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (id == uid) {\n\t\t\t\t\tmode_to_access_flags(pa_entry->e_perm,\n\t\t\t\t\t\t\t     0777,\n\t\t\t\t\t\t\t     &access_bits);\n\t\t\t\t\tif (!access_bits)\n\t\t\t\t\t\taccess_bits =\n\t\t\t\t\t\t\tSET_MINIMUM_RIGHTS;\n\t\t\t\t\tposix_acl_release(posix_acls);\n\t\t\t\t\tgoto check_access_bits;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (posix_acls)\n\t\t\tposix_acl_release(posix_acls);\n\t}\n\n\tif (!found) {\n\t\tif (others_ace) {\n\t\t\tace = others_ace;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"Can't find corresponding sid\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tswitch (ace->type) {\n\tcase ACCESS_ALLOWED_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(ace->access_req);\n\t\tbreak;\n\tcase ACCESS_DENIED_ACE_TYPE:\n\tcase ACCESS_DENIED_CALLBACK_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(~ace->access_req);\n\t\tbreak;\n\t}\n\ncheck_access_bits:\n\tif (granted &\n\t    ~(access_bits | FILE_READ_ATTRIBUTES | READ_CONTROL | WRITE_DAC | DELETE)) {\n\t\tksmbd_debug(SMB, \"Access denied with winACL, granted : %x, access_req : %x\\n\",\n\t\t\t    granted, le32_to_cpu(ace->access_req));\n\t\trc = -EACCES;\n\t\tgoto err_out;\n\t}\n\n\t*pdaccess = cpu_to_le32(granted);\nerr_out:\n\tkfree(pntsd);\n\treturn rc;\n}\n\nint set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,\n\t\t struct path *path, struct smb_ntsd *pntsd, int ntsd_len,\n\t\t bool type_check)\n{\n\tint rc;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tstruct iattr newattrs;\n\n\tfattr.cf_uid = INVALID_UID;\n\tfattr.cf_gid = INVALID_GID;\n\tfattr.cf_mode = inode->i_mode;\n\n\trc = parse_sec_desc(user_ns, pntsd, ntsd_len, &fattr);\n\tif (rc)\n\t\tgoto out;\n\n\tnewattrs.ia_valid = ATTR_CTIME;\n\tif (!uid_eq(fattr.cf_uid, INVALID_UID)) {\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = fattr.cf_uid;\n\t}\n\tif (!gid_eq(fattr.cf_gid, INVALID_GID)) {\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = fattr.cf_gid;\n\t}\n\tnewattrs.ia_valid |= ATTR_MODE;\n\tnewattrs.ia_mode = (inode->i_mode & ~0777) | (fattr.cf_mode & 0777);\n\n\tksmbd_vfs_remove_acl_xattrs(user_ns, path->dentry);\n\t/* Update posix acls */\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL) && fattr.cf_dacls) {\n\t\trc = set_posix_acl(user_ns, inode,\n\t\t\t\t   ACL_TYPE_ACCESS, fattr.cf_acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t\tif (S_ISDIR(inode->i_mode) && fattr.cf_dacls) {\n\t\t\trc = set_posix_acl(user_ns, inode,\n\t\t\t\t\t   ACL_TYPE_DEFAULT, fattr.cf_dacls);\n\t\t\tif (rc)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t\t    rc);\n\t\t}\n\t}\n\n\tinode_lock(inode);\n\trc = notify_change(user_ns, path->dentry, &newattrs, NULL);\n\tinode_unlock(inode);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Check it only calling from SD BUFFER context */\n\tif (type_check && !(le16_to_cpu(pntsd->type) & DACL_PRESENT))\n\t\tgoto out;\n\n\tif (test_share_config_flag(tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t/* Update WinACL in xattr */\n\t\tksmbd_vfs_remove_sd_xattrs(user_ns, path->dentry);\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, ntsd_len);\n\t}\n\nout:\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tmark_inode_dirty(inode);\n\treturn rc;\n}\n\nvoid ksmbd_init_domain(u32 *sub_auth)\n{\n\tint i;\n\n\tmemcpy(&server_conf.domain_sid, &domain, sizeof(struct smb_sid));\n\tfor (i = 0; i < 3; ++i)\n\t\tserver_conf.domain_sid.sub_auth[i + 1] = cpu_to_le32(sub_auth[i]);\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n/*\n *   Copyright (c) International Business Machines  Corp., 2007\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *   Modified by Namjae Jeon (linkinjeon@kernel.org)\n */\n\n#ifndef _SMBACL_H\n#define _SMBACL_H\n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/posix_acl.h>\n#include <linux/mnt_idmapping.h>\n\n#include \"mgmt/tree_connect.h\"\n\n#define NUM_AUTHS (6)\t/* number of authority fields */\n#define SID_MAX_SUB_AUTHORITIES (15) /* max number of sub authority fields */\n\n/*\n * ACE types - see MS-DTYP 2.4.4.1\n */\nenum {\n\tACCESS_ALLOWED,\n\tACCESS_DENIED,\n};\n\n/*\n * Security ID types\n */\nenum {\n\tSIDOWNER = 1,\n\tSIDGROUP,\n\tSIDCREATOR_OWNER,\n\tSIDCREATOR_GROUP,\n\tSIDUNIX_USER,\n\tSIDUNIX_GROUP,\n\tSIDNFS_USER,\n\tSIDNFS_GROUP,\n\tSIDNFS_MODE,\n};\n\n/* Revision for ACLs */\n#define SD_REVISION\t1\n\n/* Control flags for Security Descriptor */\n#define OWNER_DEFAULTED\t\t0x0001\n#define GROUP_DEFAULTED\t\t0x0002\n#define DACL_PRESENT\t\t0x0004\n#define DACL_DEFAULTED\t\t0x0008\n#define SACL_PRESENT\t\t0x0010\n#define SACL_DEFAULTED\t\t0x0020\n#define DACL_TRUSTED\t\t0x0040\n#define SERVER_SECURITY\t\t0x0080\n#define DACL_AUTO_INHERIT_REQ\t0x0100\n#define SACL_AUTO_INHERIT_REQ\t0x0200\n#define DACL_AUTO_INHERITED\t0x0400\n#define SACL_AUTO_INHERITED\t0x0800\n#define DACL_PROTECTED\t\t0x1000\n#define SACL_PROTECTED\t\t0x2000\n#define RM_CONTROL_VALID\t0x4000\n#define SELF_RELATIVE\t\t0x8000\n\n/* ACE types - see MS-DTYP 2.4.4.1 */\n#define ACCESS_ALLOWED_ACE_TYPE 0x00\n#define ACCESS_DENIED_ACE_TYPE  0x01\n#define SYSTEM_AUDIT_ACE_TYPE   0x02\n#define SYSTEM_ALARM_ACE_TYPE   0x03\n#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE 0x04\n#define ACCESS_ALLOWED_OBJECT_ACE_TYPE  0x05\n#define ACCESS_DENIED_OBJECT_ACE_TYPE   0x06\n#define SYSTEM_AUDIT_OBJECT_ACE_TYPE    0x07\n#define SYSTEM_ALARM_OBJECT_ACE_TYPE    0x08\n#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE 0x09\n#define ACCESS_DENIED_CALLBACK_ACE_TYPE 0x0A\n#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE 0x0B\n#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE  0x0C\n#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE  0x0D\n#define SYSTEM_ALARM_CALLBACK_ACE_TYPE  0x0E /* Reserved */\n#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE 0x0F\n#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE 0x10 /* reserved */\n#define SYSTEM_MANDATORY_LABEL_ACE_TYPE 0x11\n#define SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE 0x12\n#define SYSTEM_SCOPED_POLICY_ID_ACE_TYPE 0x13\n\n/* ACE flags */\n#define OBJECT_INHERIT_ACE\t\t0x01\n#define CONTAINER_INHERIT_ACE\t\t0x02\n#define NO_PROPAGATE_INHERIT_ACE\t0x04\n#define INHERIT_ONLY_ACE\t\t0x08\n#define INHERITED_ACE\t\t\t0x10\n#define SUCCESSFUL_ACCESS_ACE_FLAG\t0x40\n#define FAILED_ACCESS_ACE_FLAG\t\t0x80\n\n/*\n * Maximum size of a string representation of a SID:\n *\n * The fields are unsigned values in decimal. So:\n *\n * u8:  max 3 bytes in decimal\n * u32: max 10 bytes in decimal\n *\n * \"S-\" + 3 bytes for version field + 15 for authority field + NULL terminator\n *\n * For authority field, max is when all 6 values are non-zero and it must be\n * represented in hex. So \"-0x\" + 12 hex digits.\n *\n * Add 11 bytes for each subauthority field (10 bytes each + 1 for '-')\n */\n#define SID_STRING_BASE_SIZE (2 + 3 + 15 + 1)\n#define SID_STRING_SUBAUTH_SIZE (11) /* size of a single subauth string */\n\n#define DOMAIN_USER_RID_LE\tcpu_to_le32(513)\n\nstruct ksmbd_conn;\n\nstruct smb_ntsd {\n\t__le16 revision; /* revision level */\n\t__le16 type;\n\t__le32 osidoffset;\n\t__le32 gsidoffset;\n\t__le32 sacloffset;\n\t__le32 dacloffset;\n} __packed;\n\nstruct smb_sid {\n\t__u8 revision; /* revision level */\n\t__u8 num_subauth;\n\t__u8 authority[NUM_AUTHS];\n\t__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */\n} __packed;\n\n/* size of a struct cifs_sid, sans sub_auth array */\n#define CIFS_SID_BASE_SIZE (1 + 1 + NUM_AUTHS)\n\nstruct smb_acl {\n\t__le16 revision; /* revision level */\n\t__le16 size;\n\t__le32 num_aces;\n} __packed;\n\nstruct smb_ace {\n\t__u8 type;\n\t__u8 flags;\n\t__le16 size;\n\t__le32 access_req;\n\tstruct smb_sid sid; /* ie UUID of user or group who gets these perms */\n} __packed;\n\nstruct smb_fattr {\n\tkuid_t\tcf_uid;\n\tkgid_t\tcf_gid;\n\tumode_t\tcf_mode;\n\t__le32 daccess;\n\tstruct posix_acl *cf_acls;\n\tstruct posix_acl *cf_dacls;\n};\n\nstruct posix_ace_state {\n\tu32 allow;\n\tu32 deny;\n};\n\nstruct posix_user_ace_state {\n\tunion {\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t};\n\tstruct posix_ace_state perms;\n};\n\nstruct posix_ace_state_array {\n\tint n;\n\tstruct posix_user_ace_state aces[];\n};\n\n/*\n * while processing the nfsv4 ace, this maintains the partial permissions\n * calculated so far:\n */\n\nstruct posix_acl_state {\n\tstruct posix_ace_state owner;\n\tstruct posix_ace_state group;\n\tstruct posix_ace_state other;\n\tstruct posix_ace_state everyone;\n\tstruct posix_ace_state mask; /* deny unused in this case */\n\tstruct posix_ace_state_array *users;\n\tstruct posix_ace_state_array *groups;\n};\n\nint parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   int acl_len, struct smb_fattr *fattr);\nint build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   struct smb_ntsd *ppntsd, int addition_info,\n\t\t   __u32 *secdesclen, struct smb_fattr *fattr);\nint init_acl_state(struct posix_acl_state *state, int cnt);\nvoid free_acl_state(struct posix_acl_state *state);\nvoid posix_state_to_acl(struct posix_acl_state *state,\n\t\t\tstruct posix_acl_entry *pace);\nint compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid);\nbool smb_inherit_flags(int flags, bool is_dir);\nint smb_inherit_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t     unsigned int uid, unsigned int gid);\nint smb_check_perm_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t\t__le32 *pdaccess, int uid);\nint set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,\n\t\t struct path *path, struct smb_ntsd *pntsd, int ntsd_len,\n\t\t bool type_check);\nvoid id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid);\nvoid ksmbd_init_domain(u32 *sub_auth);\n\nstatic inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,\n\t\t\t\t\t    struct posix_acl_entry *pace)\n{\n\tkuid_t kuid;\n\n\t/* If this is an idmapped mount, apply the idmapping. */\n\tkuid = mapped_kuid_fs(mnt_userns, &init_user_ns, pace->e_uid);\n\n\t/* Translate the kuid into a userspace id ksmbd would see. */\n\treturn from_kuid(&init_user_ns, kuid);\n}\n\nstatic inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,\n\t\t\t\t\t    struct posix_acl_entry *pace)\n{\n\tkgid_t kgid;\n\n\t/* If this is an idmapped mount, apply the idmapping. */\n\tkgid = mapped_kgid_fs(mnt_userns, &init_user_ns, pace->e_gid);\n\n\t/* Translate the kgid into a userspace id ksmbd would see. */\n\treturn from_kgid(&init_user_ns, kgid);\n}\n\n#endif /* _SMBACL_H */\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/xattr.h>\n#include <linux/falloc.h>\n#include <linux/fsnotify.h>\n#include <linux/dcache.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/xacct.h>\n#include <linux/crc32c.h>\n\n#include \"../internal.h\"\t/* for vfs_path_lookup */\n\n#include \"glob.h\"\n#include \"oplock.h\"\n#include \"connection.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"smbacl.h\"\n#include \"ndr.h\"\n#include \"auth.h\"\n#include \"misc.h\"\n\n#include \"smb_common.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/user_config.h\"\n\nstatic char *extract_last_component(char *path)\n{\n\tchar *p = strrchr(path, '/');\n\n\tif (p && p[1] != '\\0') {\n\t\t*p = '\\0';\n\t\tp++;\n\t} else {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nstatic void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,\n\t\t\t\t    struct inode *parent_inode,\n\t\t\t\t    struct inode *inode)\n{\n\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_INHERIT_OWNER))\n\t\treturn;\n\n\ti_uid_write(inode, i_uid_read(parent_inode));\n}\n\n/**\n * ksmbd_vfs_lock_parent() - lock parent dentry if it is stable\n *\n * the parent dentry got by dget_parent or @parent could be\n * unstable, we try to lock a parent inode and lookup the\n * child dentry again.\n *\n * the reference count of @parent isn't incremented.\n */\nint ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,\n\t\t\t  struct dentry *child)\n{\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode_lock_nested(d_inode(parent), I_MUTEX_PARENT);\n\tdentry = lookup_one(user_ns, child->d_name.name, parent,\n\t\t\t    child->d_name.len);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto out_err;\n\t}\n\n\tif (dentry != child) {\n\t\tret = -ESTALE;\n\t\tdput(dentry);\n\t\tgoto out_err;\n\t}\n\n\tdput(dentry);\n\treturn 0;\nout_err:\n\tinode_unlock(d_inode(parent));\n\treturn ret;\n}\n\nint ksmbd_vfs_may_delete(struct user_namespace *user_ns,\n\t\t\t struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tint ret;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tret = inode_permission(user_ns, d_inode(parent),\n\t\t\t       MAY_EXEC | MAY_WRITE);\n\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\treturn ret;\n}\n\nint ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry, __le32 *daccess)\n{\n\tstruct dentry *parent;\n\tint ret = 0;\n\n\t*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_WRITE))\n\t\t*daccess |= cpu_to_le32(WRITE_DAC | WRITE_OWNER | SYNCHRONIZE |\n\t\t\t\tFILE_WRITE_DATA | FILE_APPEND_DATA |\n\t\t\t\tFILE_WRITE_EA | FILE_WRITE_ATTRIBUTES |\n\t\t\t\tFILE_DELETE_CHILD);\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_READ))\n\t\t*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_EXEC))\n\t\t*daccess |= FILE_EXECUTE_LE;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tif (!inode_permission(user_ns, d_inode(parent), MAY_EXEC | MAY_WRITE))\n\t\t*daccess |= FILE_DELETE_LE;\n\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\treturn ret;\n}\n\n/**\n * ksmbd_vfs_create() - vfs helper for smb create file\n * @work:\twork\n * @name:\tfile name that is relative to share\n * @mode:\tfile create mode\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS, &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -ENOENT)\n\t\t\tpr_err(\"path create failed for %s, err %d\\n\",\n\t\t\t       name, err);\n\t\treturn err;\n\t}\n\n\tmode |= S_IFREG;\n\terr = vfs_create(mnt_user_ns(path.mnt), d_inode(path.dentry),\n\t\t\t dentry, mode, true);\n\tif (!err) {\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry),\n\t\t\t\t\td_inode(dentry));\n\t} else {\n\t\tpr_err(\"File(%s): creation failed (err:%d)\\n\", name, err);\n\t}\n\tdone_path_create(&path, dentry);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_mkdir() - vfs helper for smb create directory\n * @work:\twork\n * @name:\tdirectory name that is relative to share\n * @mode:\tdirectory create mode\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,\n\t\t\t\t\t    &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -EEXIST)\n\t\t\tksmbd_debug(VFS, \"path create failed for %s, err %d\\n\",\n\t\t\t\t    name, err);\n\t\treturn err;\n\t}\n\n\tuser_ns = mnt_user_ns(path.mnt);\n\tmode |= S_IFDIR;\n\terr = vfs_mkdir(user_ns, d_inode(path.dentry), dentry, mode);\n\tif (err) {\n\t\tgoto out;\n\t} else if (d_unhashed(dentry)) {\n\t\tstruct dentry *d;\n\n\t\td = lookup_one(user_ns, dentry->d_name.name, dentry->d_parent,\n\t\t\t       dentry->d_name.len);\n\t\tif (IS_ERR(d)) {\n\t\t\terr = PTR_ERR(d);\n\t\t\tgoto out;\n\t\t}\n\t\tif (unlikely(d_is_negative(d))) {\n\t\t\tdput(d);\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry), d_inode(d));\n\t\tdput(d);\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (err)\n\t\tpr_err(\"mkdir(%s): creation failed (err:%d)\\n\", name, err);\n\treturn err;\n}\n\nstatic ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,\n\t\t\t\t      struct dentry *dentry, char *attr_name,\n\t\t\t\t      int attr_name_len, char **attr_value)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns,\n\t\t\t\t\t       dentry,\n\t\t\t\t\t       name,\n\t\t\t\t\t       attr_value);\n\t\tif (value_len < 0)\n\t\t\tpr_err(\"failed to get xattr in file\\n\");\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nstatic int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t size_t count)\n{\n\tssize_t v_len;\n\tchar *stream_buf = NULL;\n\n\tksmbd_debug(VFS, \"read stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tv_len = ksmbd_vfs_getcasexattr(file_mnt_user_ns(fp->filp),\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif ((int)v_len <= 0)\n\t\treturn (int)v_len;\n\n\tif (v_len <= *pos) {\n\t\tcount = -EINVAL;\n\t\tgoto free_buf;\n\t}\n\n\tif (v_len - *pos < count)\n\t\tcount = v_len - *pos;\n\n\tmemcpy(buf, &stream_buf[*pos], count);\n\nfree_buf:\n\tkvfree(stream_buf);\n\treturn count;\n}\n\n/**\n * check_lock_range() - vfs helper for smb byte range file locking\n * @filp:\tthe file to apply the lock to\n * @start:\tlock start byte offset\n * @end:\tlock end byte offset\n * @type:\tbyte range type read/write\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int check_lock_range(struct file *filp, loff_t start, loff_t end,\n\t\t\t    unsigned char type)\n{\n\tstruct file_lock *flock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\tint error = 0;\n\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(flock, &ctx->flc_posix, fl_list) {\n\t\t/* check conflict locks */\n\t\tif (flock->fl_end >= start && end >= flock->fl_start) {\n\t\t\tif (flock->fl_type == F_RDLCK) {\n\t\t\t\tif (type == WRITE) {\n\t\t\t\t\tpr_err(\"not allow write by shared lock\\n\");\n\t\t\t\t\terror = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (flock->fl_type == F_WRLCK) {\n\t\t\t\t/* check owner in lock */\n\t\t\t\tif (flock->fl_file != filp) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tpr_err(\"not allow rw access by exclusive lock from other opens\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn error;\n}\n\n/**\n * ksmbd_vfs_read() - vfs helper for smb file read\n * @work:\tsmb work\n * @fid:\tfile id of open file\n * @count:\tread byte count\n * @pos:\tfile pos\n *\n * Return:\tnumber of read bytes on success, otherwise error\n */\nint ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,\n\t\t   loff_t *pos)\n{\n\tstruct file *filp = fp->filp;\n\tssize_t nbytes = 0;\n\tchar *rbuf = work->aux_payload_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (unlikely(count == 0))\n\t\treturn 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\t\tpr_err(\"no right to read(%pd)\\n\",\n\t\t\t       fp->filp->f_path.dentry);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\tif (ksmbd_stream_fd(fp))\n\t\treturn ksmbd_vfs_stream_read(fp, rbuf, pos, count);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tint ret;\n\n\t\tret = check_lock_range(filp, *pos, *pos + count - 1, READ);\n\t\tif (ret) {\n\t\t\tpr_err(\"unable to read due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tnbytes = kernel_read(filp, rbuf, count, pos);\n\tif (nbytes < 0) {\n\t\tpr_err(\"smb read failed, err = %zd\\n\", nbytes);\n\t\treturn nbytes;\n\t}\n\n\tfilp->f_pos = *pos;\n\treturn nbytes;\n}\n\nstatic int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t  size_t count)\n{\n\tchar *stream_buf = NULL, *wbuf;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\tsize_t size, v_len;\n\tint err = 0;\n\n\tksmbd_debug(VFS, \"write stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tsize = *pos + count;\n\tif (size > XATTR_SIZE_MAX) {\n\t\tsize = XATTR_SIZE_MAX;\n\t\tcount = (*pos + count) - XATTR_SIZE_MAX;\n\t}\n\n\tv_len = ksmbd_vfs_getcasexattr(user_ns,\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif ((int)v_len < 0) {\n\t\tpr_err(\"not found stream in xattr : %zd\\n\", v_len);\n\t\terr = (int)v_len;\n\t\tgoto out;\n\t}\n\n\tif (v_len < size) {\n\t\twbuf = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!wbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (v_len > 0)\n\t\t\tmemcpy(wbuf, stream_buf, v_len);\n\t\tkvfree(stream_buf);\n\t\tstream_buf = wbuf;\n\t}\n\n\tmemcpy(&stream_buf[*pos], buf, count);\n\n\terr = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t fp->filp->f_path.dentry,\n\t\t\t\t fp->stream.name,\n\t\t\t\t (void *)stream_buf,\n\t\t\t\t size,\n\t\t\t\t 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfp->filp->f_pos = *pos;\n\terr = 0;\nout:\n\tkvfree(stream_buf);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_write() - vfs helper for smb file write\n * @work:\twork\n * @fid:\tfile id of open file\n * @buf:\tbuf containing data for writing\n * @count:\tread byte count\n * @pos:\tfile pos\n * @sync:\tfsync after write\n * @written:\tnumber of bytes written\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t    char *buf, size_t count, loff_t *pos, bool sync,\n\t\t    ssize_t *written)\n{\n\tstruct file *filp;\n\tloff_t\toffset = *pos;\n\tint err = 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & FILE_WRITE_DATA_LE)) {\n\t\t\tpr_err(\"no right to write(%pd)\\n\",\n\t\t\t       fp->filp->f_path.dentry);\n\t\t\terr = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfilp = fp->filp;\n\n\tif (ksmbd_stream_fd(fp)) {\n\t\terr = ksmbd_vfs_stream_write(fp, buf, pos, count);\n\t\tif (!err)\n\t\t\t*written = count;\n\t\tgoto out;\n\t}\n\n\tif (!work->tcon->posix_extensions) {\n\t\terr = check_lock_range(filp, *pos, *pos + count - 1, WRITE);\n\t\tif (err) {\n\t\t\tpr_err(\"unable to write due to lock\\n\");\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Do we need to break any of a levelII oplock? */\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\terr = kernel_write(filp, buf, count, pos);\n\tif (err < 0) {\n\t\tksmbd_debug(VFS, \"smb write failed, err = %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfilp->f_pos = *pos;\n\t*written = err;\n\terr = 0;\n\tif (sync) {\n\t\terr = vfs_fsync_range(filp, offset, offset + *written, 0);\n\t\tif (err < 0)\n\t\t\tpr_err(\"fsync failed for filename = %pd, err = %d\\n\",\n\t\t\t       fp->filp->f_path.dentry, err);\n\t}\n\nout:\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_getattr() - vfs helper for smb getattr\n * @work:\twork\n * @fid:\tfile id of open file\n * @attrs:\tinode attributes\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint err;\n\n\terr = vfs_getattr(path, stat, STATX_BTIME, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tpr_err(\"getattr failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_fsync() - vfs helper for smb fsync\n * @work:\twork\n * @fid:\tfile id of open file\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)\n{\n\tstruct ksmbd_file *fp;\n\tint err;\n\n\tfp = ksmbd_lookup_fd_slow(work, fid, p_id);\n\tif (!fp) {\n\t\tpr_err(\"failed to get filp for fid %llu\\n\", fid);\n\t\treturn -ENOENT;\n\t}\n\terr = vfs_fsync(fp->filp, 0);\n\tif (err < 0)\n\t\tpr_err(\"smb fsync failed, err = %d\\n\", err);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_remove_file() - vfs helper for smb rmdir or unlink\n * @name:\tdirectory or file name that is relative to share\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path path;\n\tstruct dentry *parent;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\terr = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, false);\n\tif (err) {\n\t\tksmbd_debug(VFS, \"can't get %s, err %d\\n\", name, err);\n\t\tksmbd_revert_fsids(work);\n\t\treturn err;\n\t}\n\n\tuser_ns = mnt_user_ns(path.mnt);\n\tparent = dget_parent(path.dentry);\n\terr = ksmbd_vfs_lock_parent(user_ns, parent, path.dentry);\n\tif (err) {\n\t\tdput(parent);\n\t\tpath_put(&path);\n\t\tksmbd_revert_fsids(work);\n\t\treturn err;\n\t}\n\n\tif (!d_inode(path.dentry)->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tif (S_ISDIR(d_inode(path.dentry)->i_mode)) {\n\t\terr = vfs_rmdir(user_ns, d_inode(parent), path.dentry);\n\t\tif (err && err != -ENOTEMPTY)\n\t\t\tksmbd_debug(VFS, \"%s: rmdir failed, err %d\\n\", name,\n\t\t\t\t    err);\n\t} else {\n\t\terr = vfs_unlink(user_ns, d_inode(parent), path.dentry, NULL);\n\t\tif (err)\n\t\t\tksmbd_debug(VFS, \"%s: unlink failed, err %d\\n\", name,\n\t\t\t\t    err);\n\t}\n\nout_err:\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\tpath_put(&path);\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_link() - vfs helper for creating smb hardlink\n * @oldname:\tsource file name\n * @newname:\thardlink name that is relative to share\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,\n\t\t   const char *newname)\n{\n\tstruct path oldpath, newpath;\n\tstruct dentry *dentry;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\terr = kern_path(oldname, LOOKUP_NO_SYMLINKS, &oldpath);\n\tif (err) {\n\t\tpr_err(\"cannot get linux path for %s, err = %d\\n\",\n\t\t       oldname, err);\n\t\tgoto out1;\n\t}\n\n\tdentry = ksmbd_vfs_kern_path_create(work, newname,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_REVAL,\n\t\t\t\t\t    &newpath);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tpr_err(\"path create err for %s, err %d\\n\", newname, err);\n\t\tgoto out2;\n\t}\n\n\terr = -EXDEV;\n\tif (oldpath.mnt != newpath.mnt) {\n\t\tpr_err(\"vfs_link failed err %d\\n\", err);\n\t\tgoto out3;\n\t}\n\n\terr = vfs_link(oldpath.dentry, mnt_user_ns(newpath.mnt),\n\t\t       d_inode(newpath.dentry),\n\t\t       dentry, NULL);\n\tif (err)\n\t\tksmbd_debug(VFS, \"vfs_link failed err %d\\n\", err);\n\nout3:\n\tdone_path_create(&newpath, dentry);\nout2:\n\tpath_put(&oldpath);\nout1:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\nstatic int ksmbd_validate_entry_in_use(struct dentry *src_dent)\n{\n\tstruct dentry *dst_dent;\n\n\tspin_lock(&src_dent->d_lock);\n\tlist_for_each_entry(dst_dent, &src_dent->d_subdirs, d_child) {\n\t\tstruct ksmbd_file *child_fp;\n\n\t\tif (d_really_is_negative(dst_dent))\n\t\t\tcontinue;\n\n\t\tchild_fp = ksmbd_lookup_fd_inode(d_inode(dst_dent));\n\t\tif (child_fp) {\n\t\t\tspin_unlock(&src_dent->d_lock);\n\t\t\tksmbd_debug(VFS, \"Forbid rename, sub file/dir is in use\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\tspin_unlock(&src_dent->d_lock);\n\n\treturn 0;\n}\n\nstatic int __ksmbd_vfs_rename(struct ksmbd_work *work,\n\t\t\t      struct user_namespace *src_user_ns,\n\t\t\t      struct dentry *src_dent_parent,\n\t\t\t      struct dentry *src_dent,\n\t\t\t      struct user_namespace *dst_user_ns,\n\t\t\t      struct dentry *dst_dent_parent,\n\t\t\t      struct dentry *trap_dent,\n\t\t\t      char *dst_name)\n{\n\tstruct dentry *dst_dent;\n\tint err;\n\n\tif (!work->tcon->posix_extensions) {\n\t\terr = ksmbd_validate_entry_in_use(src_dent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (d_really_is_negative(src_dent_parent))\n\t\treturn -ENOENT;\n\tif (d_really_is_negative(dst_dent_parent))\n\t\treturn -ENOENT;\n\tif (d_really_is_negative(src_dent))\n\t\treturn -ENOENT;\n\tif (src_dent == trap_dent)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\tdst_dent = lookup_one(dst_user_ns, dst_name, dst_dent_parent,\n\t\t\t      strlen(dst_name));\n\terr = PTR_ERR(dst_dent);\n\tif (IS_ERR(dst_dent)) {\n\t\tpr_err(\"lookup failed %s [%d]\\n\", dst_name, err);\n\t\tgoto out;\n\t}\n\n\terr = -ENOTEMPTY;\n\tif (dst_dent != trap_dent && !d_really_is_positive(dst_dent)) {\n\t\tstruct renamedata rd = {\n\t\t\t.old_mnt_userns\t= src_user_ns,\n\t\t\t.old_dir\t= d_inode(src_dent_parent),\n\t\t\t.old_dentry\t= src_dent,\n\t\t\t.new_mnt_userns\t= dst_user_ns,\n\t\t\t.new_dir\t= d_inode(dst_dent_parent),\n\t\t\t.new_dentry\t= dst_dent,\n\t\t};\n\t\terr = vfs_rename(&rd);\n\t}\n\tif (err)\n\t\tpr_err(\"vfs_rename failed err %d\\n\", err);\n\tif (dst_dent)\n\t\tdput(dst_dent);\nout:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\nint ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\tchar *newname)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path dst_path;\n\tstruct dentry *src_dent_parent, *dst_dent_parent;\n\tstruct dentry *src_dent, *trap_dent, *src_child;\n\tchar *dst_name;\n\tint err;\n\n\tdst_name = extract_last_component(newname);\n\tif (!dst_name) {\n\t\tdst_name = newname;\n\t\tnewname = \"\";\n\t}\n\n\tsrc_dent_parent = dget_parent(fp->filp->f_path.dentry);\n\tsrc_dent = fp->filp->f_path.dentry;\n\n\terr = ksmbd_vfs_kern_path(work, newname,\n\t\t\t\t  LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,\n\t\t\t\t  &dst_path, false);\n\tif (err) {\n\t\tksmbd_debug(VFS, \"Cannot get path for %s [%d]\\n\", newname, err);\n\t\tgoto out;\n\t}\n\tdst_dent_parent = dst_path.dentry;\n\n\ttrap_dent = lock_rename(src_dent_parent, dst_dent_parent);\n\tdget(src_dent);\n\tdget(dst_dent_parent);\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tsrc_child = lookup_one(user_ns, src_dent->d_name.name, src_dent_parent,\n\t\t\t       src_dent->d_name.len);\n\tif (IS_ERR(src_child)) {\n\t\terr = PTR_ERR(src_child);\n\t\tgoto out_lock;\n\t}\n\n\tif (src_child != src_dent) {\n\t\terr = -ESTALE;\n\t\tdput(src_child);\n\t\tgoto out_lock;\n\t}\n\tdput(src_child);\n\n\terr = __ksmbd_vfs_rename(work,\n\t\t\t\t user_ns,\n\t\t\t\t src_dent_parent,\n\t\t\t\t src_dent,\n\t\t\t\t mnt_user_ns(dst_path.mnt),\n\t\t\t\t dst_dent_parent,\n\t\t\t\t trap_dent,\n\t\t\t\t dst_name);\nout_lock:\n\tdput(src_dent);\n\tdput(dst_dent_parent);\n\tunlock_rename(src_dent_parent, dst_dent_parent);\n\tpath_put(&dst_path);\nout:\n\tdput(src_dent_parent);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_truncate() - vfs helper for smb file truncate\n * @work:\twork\n * @fid:\tfile id of old file\n * @size:\ttruncate to given size\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_truncate(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp, loff_t size)\n{\n\tint err = 0;\n\tstruct file *filp;\n\n\tfilp = fp->filp;\n\n\t/* Do we need to break any of a levelII oplock? */\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tstruct inode *inode = file_inode(filp);\n\n\t\tif (size < inode->i_size) {\n\t\t\terr = check_lock_range(filp, size,\n\t\t\t\t\t       inode->i_size - 1, WRITE);\n\t\t} else {\n\t\t\terr = check_lock_range(filp, inode->i_size,\n\t\t\t\t\t       size - 1, WRITE);\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err(\"failed due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\terr = vfs_truncate(&filp->f_path, size);\n\tif (err)\n\t\tpr_err(\"truncate failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_listxattr() - vfs helper for smb list extended attributes\n * @dentry:\tdentry of file for listing xattrs\n * @list:\tdestination buffer\n * @size:\tdestination buffer length\n *\n * Return:\txattr list length on success, otherwise error\n */\nssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)\n{\n\tssize_t size;\n\tchar *vlist = NULL;\n\n\tsize = vfs_listxattr(dentry, NULL, 0);\n\tif (size <= 0)\n\t\treturn size;\n\n\tvlist = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vlist)\n\t\treturn -ENOMEM;\n\n\t*list = vlist;\n\tsize = vfs_listxattr(dentry, vlist, size);\n\tif (size < 0) {\n\t\tksmbd_debug(VFS, \"listxattr failed\\n\");\n\t\tkvfree(vlist);\n\t\t*list = NULL;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t ksmbd_vfs_xattr_len(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry, char *xattr_name)\n{\n\treturn vfs_getxattr(user_ns, dentry, xattr_name, NULL, 0);\n}\n\n/**\n * ksmbd_vfs_getxattr() - vfs helper for smb get extended attributes value\n * @user_ns:\tuser namespace\n * @dentry:\tdentry of file for getting xattrs\n * @xattr_name:\tname of xattr name to query\n * @xattr_buf:\tdestination buffer xattr value\n *\n * Return:\tread xattr value length on success, otherwise error\n */\nssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   char *xattr_name, char **xattr_buf)\n{\n\tssize_t xattr_len;\n\tchar *buf;\n\n\t*xattr_buf = NULL;\n\txattr_len = ksmbd_vfs_xattr_len(user_ns, dentry, xattr_name);\n\tif (xattr_len < 0)\n\t\treturn xattr_len;\n\n\tbuf = kmalloc(xattr_len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\txattr_len = vfs_getxattr(user_ns, dentry, xattr_name,\n\t\t\t\t (void *)buf, xattr_len);\n\tif (xattr_len > 0)\n\t\t*xattr_buf = buf;\n\telse\n\t\tkfree(buf);\n\treturn xattr_len;\n}\n\n/**\n * ksmbd_vfs_setxattr() - vfs helper for smb set extended attributes value\n * @user_ns:\tuser namespace\n * @dentry:\tdentry to set XATTR at\n * @name:\txattr name for setxattr\n * @value:\txattr value to set\n * @size:\tsize of xattr value\n * @flags:\tdestination buffer length\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_setxattr(struct user_namespace *user_ns,\n\t\t       struct dentry *dentry, const char *attr_name,\n\t\t       const void *attr_value, size_t attr_size, int flags)\n{\n\tint err;\n\n\terr = vfs_setxattr(user_ns,\n\t\t\t   dentry,\n\t\t\t   attr_name,\n\t\t\t   attr_value,\n\t\t\t   attr_size,\n\t\t\t   flags);\n\tif (err)\n\t\tksmbd_debug(VFS, \"setxattr failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_set_fadvise() - convert smb IO caching options to linux options\n * @filp:\tfile pointer for IO\n * @options:\tsmb IO options\n */\nvoid ksmbd_vfs_set_fadvise(struct file *filp, __le32 option)\n{\n\tstruct address_space *mapping;\n\n\tmapping = filp->f_mapping;\n\n\tif (!option || !mapping)\n\t\treturn;\n\n\tif (option & FILE_WRITE_THROUGH_LE) {\n\t\tfilp->f_flags |= O_SYNC;\n\t} else if (option & FILE_SEQUENTIAL_ONLY_LE) {\n\t\tfilp->f_ra.ra_pages = inode_to_bdi(mapping->host)->ra_pages * 2;\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t} else if (option & FILE_RANDOM_ACCESS_LE) {\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t}\n}\n\nint ksmbd_vfs_zero_data(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\tloff_t off, loff_t len)\n{\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\tif (fp->f_ci->m_fattr & FILE_ATTRIBUTE_SPARSE_FILE_LE)\n\t\treturn vfs_fallocate(fp->filp,\n\t\t\t\t     FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\t     off, len);\n\n\treturn vfs_fallocate(fp->filp,\n\t\t\t     FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE,\n\t\t\t     off, len);\n}\n\nint ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,\n\t\t\t struct file_allocated_range_buffer *ranges,\n\t\t\t unsigned int in_count, unsigned int *out_count)\n{\n\tstruct file *f = fp->filp;\n\tstruct inode *inode = file_inode(fp->filp);\n\tloff_t maxbytes = (u64)inode->i_sb->s_maxbytes, end;\n\tloff_t extent_start, extent_end;\n\tint ret = 0;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\tif (!in_count)\n\t\treturn 0;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (length > maxbytes || (maxbytes - length) < start)\n\t\tlength = maxbytes - start;\n\n\tif (start + length > inode->i_size)\n\t\tlength = inode->i_size - start;\n\n\t*out_count = 0;\n\tend = start + length;\n\twhile (start < end && *out_count < in_count) {\n\t\textent_start = vfs_llseek(f, start, SEEK_DATA);\n\t\tif (extent_start < 0) {\n\t\t\tif (extent_start != -ENXIO)\n\t\t\t\tret = (int)extent_start;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_start >= end)\n\t\t\tbreak;\n\n\t\textent_end = vfs_llseek(f, extent_start, SEEK_HOLE);\n\t\tif (extent_end < 0) {\n\t\t\tif (extent_end != -ENXIO)\n\t\t\t\tret = (int)extent_end;\n\t\t\tbreak;\n\t\t} else if (extent_start >= extent_end) {\n\t\t\tbreak;\n\t\t}\n\n\t\tranges[*out_count].file_offset = cpu_to_le64(extent_start);\n\t\tranges[(*out_count)++].length =\n\t\t\tcpu_to_le64(min(extent_end, end) - extent_start);\n\n\t\tstart = extent_end;\n\t}\n\n\treturn ret;\n}\n\nint ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry, char *attr_name)\n{\n\treturn vfs_removexattr(user_ns, dentry, attr_name);\n}\n\nint ksmbd_vfs_unlink(struct user_namespace *user_ns,\n\t\t     struct dentry *dir, struct dentry *dentry)\n{\n\tint err = 0;\n\n\terr = ksmbd_vfs_lock_parent(user_ns, dir, dentry);\n\tif (err)\n\t\treturn err;\n\tdget(dentry);\n\n\tif (S_ISDIR(d_inode(dentry)->i_mode))\n\t\terr = vfs_rmdir(user_ns, d_inode(dir), dentry);\n\telse\n\t\terr = vfs_unlink(user_ns, d_inode(dir), dentry, NULL);\n\n\tdput(dentry);\n\tinode_unlock(d_inode(dir));\n\tif (err)\n\t\tksmbd_debug(VFS, \"failed to delete, err %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int __dir_empty(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tbuf->dirent_count++;\n\n\tif (buf->dirent_count > 2)\n\t\treturn -ENOTEMPTY;\n\treturn 0;\n}\n\n/**\n * ksmbd_vfs_empty_dir() - check for empty directory\n * @fp:\tksmbd file pointer\n *\n * Return:\ttrue if directory empty, otherwise false\n */\nint ksmbd_vfs_empty_dir(struct ksmbd_file *fp)\n{\n\tint err;\n\tstruct ksmbd_readdir_data readdir_data;\n\n\tmemset(&readdir_data, 0, sizeof(struct ksmbd_readdir_data));\n\n\tset_ctx_actor(&readdir_data.ctx, __dir_empty);\n\treaddir_data.dirent_count = 0;\n\n\terr = iterate_dir(fp->filp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 2)\n\t\terr = -ENOTEMPTY;\n\telse\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int __caseless_lookup(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\n\tif (buf->used != namlen)\n\t\treturn 0;\n\tif (!strncasecmp((char *)buf->private, name, namlen)) {\n\t\tmemcpy((char *)buf->private, name, namlen);\n\t\tbuf->dirent_count = 1;\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\n/**\n * ksmbd_vfs_lookup_in_dir() - lookup a file in a directory\n * @dir:\tpath info\n * @name:\tfilename to lookup\n * @namelen:\tfilename length\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int ksmbd_vfs_lookup_in_dir(struct path *dir, char *name, size_t namelen)\n{\n\tint ret;\n\tstruct file *dfilp;\n\tint flags = O_RDONLY | O_LARGEFILE;\n\tstruct ksmbd_readdir_data readdir_data = {\n\t\t.ctx.actor\t= __caseless_lookup,\n\t\t.private\t= name,\n\t\t.used\t\t= namelen,\n\t\t.dirent_count\t= 0,\n\t};\n\n\tdfilp = dentry_open(dir, flags, current_cred());\n\tif (IS_ERR(dfilp))\n\t\treturn PTR_ERR(dfilp);\n\n\tret = iterate_dir(dfilp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 0)\n\t\tret = 0;\n\tfput(dfilp);\n\treturn ret;\n}\n\n/**\n * ksmbd_vfs_kern_path() - lookup a file and get path info\n * @name:\tfile path that is relative to share\n * @flags:\tlookup flags\n * @path:\tif lookup succeed, return path info\n * @caseless:\tcaseless filename lookup\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,\n\t\t\tunsigned int flags, struct path *path, bool caseless)\n{\n\tstruct ksmbd_share_config *share_conf = work->tcon->share_conf;\n\tint err;\n\n\tflags |= LOOKUP_BENEATH;\n\terr = vfs_path_lookup(share_conf->vfs_path.dentry,\n\t\t\t      share_conf->vfs_path.mnt,\n\t\t\t      name,\n\t\t\t      flags,\n\t\t\t      path);\n\tif (!err)\n\t\treturn 0;\n\n\tif (caseless) {\n\t\tchar *filepath;\n\t\tstruct path parent;\n\t\tsize_t path_len, remain_len;\n\n\t\tfilepath = kstrdup(name, GFP_KERNEL);\n\t\tif (!filepath)\n\t\t\treturn -ENOMEM;\n\n\t\tpath_len = strlen(filepath);\n\t\tremain_len = path_len;\n\n\t\tparent = share_conf->vfs_path;\n\t\tpath_get(&parent);\n\n\t\twhile (d_can_lookup(parent.dentry)) {\n\t\t\tchar *filename = filepath + path_len - remain_len;\n\t\t\tchar *next = strchrnul(filename, '/');\n\t\t\tsize_t filename_len = next - filename;\n\t\t\tbool is_last = !next[0];\n\n\t\t\tif (filename_len == 0)\n\t\t\t\tbreak;\n\n\t\t\terr = ksmbd_vfs_lookup_in_dir(&parent, filename,\n\t\t\t\t\t\t      filename_len);\n\t\t\tpath_put(&parent);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnext[0] = '\\0';\n\n\t\t\terr = vfs_path_lookup(share_conf->vfs_path.dentry,\n\t\t\t\t\t      share_conf->vfs_path.mnt,\n\t\t\t\t\t      filepath,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      &parent);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\telse if (is_last) {\n\t\t\t\t*path = parent;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnext[0] = '/';\n\t\t\tremain_len -= filename_len + 1;\n\t\t}\n\n\t\tpath_put(&parent);\n\t\terr = -EINVAL;\nout:\n\t\tkfree(filepath);\n\t}\n\treturn err;\n}\n\nstruct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t  struct path *path)\n{\n\tchar *abs_name;\n\tstruct dentry *dent;\n\n\tabs_name = convert_to_unix_name(work->tcon->share_conf, name);\n\tif (!abs_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdent = kern_path_create(AT_FDCWD, abs_name, path, flags);\n\tkfree(abs_name);\n\treturn dent;\n}\n\nint ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t     name += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||\n\t\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {\n\t\t\terr = ksmbd_vfs_remove_xattr(user_ns, dentry, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"remove acl xattr failed : %s\\n\", name);\n\t\t}\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nint ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,\n\t\t\t       struct dentry *dentry)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {\n\t\t\terr = ksmbd_vfs_remove_xattr(user_ns, dentry, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t\t}\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,\n\t\t\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t\t\t    int acl_type)\n{\n\tstruct xattr_smb_acl *smb_acl = NULL;\n\tstruct posix_acl *posix_acls;\n\tstruct posix_acl_entry *pa_entry;\n\tstruct xattr_acl_entry *xa_entry;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn NULL;\n\n\tposix_acls = get_acl(inode, acl_type);\n\tif (!posix_acls)\n\t\treturn NULL;\n\n\tsmb_acl = kzalloc(sizeof(struct xattr_smb_acl) +\n\t\t\t  sizeof(struct xattr_acl_entry) * posix_acls->a_count,\n\t\t\t  GFP_KERNEL);\n\tif (!smb_acl)\n\t\tgoto out;\n\n\tsmb_acl->count = posix_acls->a_count;\n\tpa_entry = posix_acls->a_entries;\n\txa_entry = smb_acl->entries;\n\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++, xa_entry++) {\n\t\tswitch (pa_entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\txa_entry->type = SMB_ACL_USER;\n\t\t\txa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\txa_entry->type = SMB_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\txa_entry->type = SMB_ACL_GROUP;\n\t\t\txa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\txa_entry->type = SMB_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\txa_entry->type = SMB_ACL_OTHER;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\txa_entry->type = SMB_ACL_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"unknown type : 0x%x\\n\", pa_entry->e_tag);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pa_entry->e_perm & ACL_READ)\n\t\t\txa_entry->perm |= SMB_ACL_READ;\n\t\tif (pa_entry->e_perm & ACL_WRITE)\n\t\t\txa_entry->perm |= SMB_ACL_WRITE;\n\t\tif (pa_entry->e_perm & ACL_EXECUTE)\n\t\t\txa_entry->perm |= SMB_ACL_EXECUTE;\n\t}\nout:\n\tposix_acl_release(posix_acls);\n\treturn smb_acl;\n}\n\nint ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct smb_ntsd *pntsd, int len)\n{\n\tint rc;\n\tstruct ndr sd_ndr = {0}, acl_ndr = {0};\n\tstruct xattr_ntacl acl = {0};\n\tstruct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;\n\tstruct inode *inode = d_inode(dentry);\n\n\tacl.version = 4;\n\tacl.hash_type = XATTR_SD_HASH_TYPE_SHA256;\n\tacl.current_time = ksmbd_UnixTimeToNT(current_time(inode));\n\n\tmemcpy(acl.desc, \"posix_acl\", 9);\n\tacl.desc_len = 10;\n\n\tpntsd->osidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->osidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->gsidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->gsidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->dacloffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->dacloffset) + NDR_NTSD_OFFSETOF);\n\n\tacl.sd_buf = (char *)pntsd;\n\tacl.sd_size = len;\n\n\trc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\treturn rc;\n\t}\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode,\n\t\t\t\t  smb_acl, def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,\n\t\t\t       acl.posix_acl_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ndr_encode_v4_ntacl(&sd_ndr, &acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, dentry,\n\t\t\t\tXATTR_NAME_SD, sd_ndr.data,\n\t\t\t\tsd_ndr.offset, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR ntacl :%d\\n\", rc);\n\n\tkfree(sd_ndr.data);\nout:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\treturn rc;\n}\n\nint ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct smb_ntsd **pntsd)\n{\n\tint rc;\n\tstruct ndr n;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ndr acl_ndr = {0};\n\tstruct xattr_ntacl acl;\n\tstruct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;\n\t__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};\n\n\trc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tn.length = rc;\n\trc = ndr_decode_v4_ntacl(&n, &acl);\n\tif (rc)\n\t\tgoto free_n_data;\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,\n\t\t\t\t  def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {\n\t\tpr_err(\"hash value diff\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t*pntsd = acl.sd_buf;\n\t(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\n\trc = acl.sd_size;\nout_free:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\tif (rc < 0) {\n\t\tkfree(acl.sd_buf);\n\t\t*pntsd = NULL;\n\t}\n\nfree_n_data:\n\tkfree(n.data);\n\treturn rc;\n}\n\nint ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry,\n\t\t\t\t   struct xattr_dos_attrib *da)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ndr_encode_dos_attr(&n, da);\n\tif (err)\n\t\treturn err;\n\n\terr = ksmbd_vfs_setxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (void *)n.data, n.offset, 0);\n\tif (err)\n\t\tksmbd_debug(SMB, \"failed to store dos attribute in xattr\\n\");\n\tkfree(n.data);\n\n\treturn err;\n}\n\nint ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry,\n\t\t\t\t   struct xattr_dos_attrib *da)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (char **)&n.data);\n\tif (err > 0) {\n\t\tn.length = err;\n\t\tif (ndr_decode_dos_attr(&n, da))\n\t\t\terr = -EINVAL;\n\t\tkfree(n.data);\n\t} else {\n\t\tksmbd_debug(SMB, \"failed to load dos attribute in xattr\\n\");\n\t}\n\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_init_kstat() - convert unix stat information to smb stat format\n * @p:          destination buffer\n * @ksmbd_kstat:      ksmbd kstat wrapper\n */\nvoid *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)\n{\n\tstruct file_directory_info *info = (struct file_directory_info *)(*p);\n\tstruct kstat *kstat = ksmbd_kstat->kstat;\n\tu64 time;\n\n\tinfo->FileIndex = 0;\n\tinfo->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\ttime = ksmbd_UnixTimeToNT(kstat->atime);\n\tinfo->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->mtime);\n\tinfo->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->ctime);\n\tinfo->ChangeTime = cpu_to_le64(time);\n\n\tif (ksmbd_kstat->file_attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\tinfo->EndOfFile = 0;\n\t\tinfo->AllocationSize = 0;\n\t} else {\n\t\tinfo->EndOfFile = cpu_to_le64(kstat->size);\n\t\tinfo->AllocationSize = cpu_to_le64(kstat->blocks << 9);\n\t}\n\tinfo->ExtFileAttributes = ksmbd_kstat->file_attributes;\n\n\treturn info;\n}\n\nint ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,\n\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tstruct ksmbd_kstat *ksmbd_kstat)\n{\n\tu64 time;\n\tint rc;\n\n\tgeneric_fillattr(user_ns, d_inode(dentry), ksmbd_kstat->kstat);\n\n\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\tksmbd_kstat->create_time = time;\n\n\t/*\n\t * set default value for the case that store dos attributes is not yes\n\t * or that acl is disable in server's filesystem and the config is yes.\n\t */\n\tif (S_ISDIR(ksmbd_kstat->kstat->mode))\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_DIRECTORY_LE;\n\telse\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_ARCHIVE_LE;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\trc = ksmbd_vfs_get_dos_attrib_xattr(user_ns, dentry, &da);\n\t\tif (rc > 0) {\n\t\t\tksmbd_kstat->file_attributes = cpu_to_le32(da.attr);\n\t\t\tksmbd_kstat->create_time = da.create_time;\n\t\t} else {\n\t\t\tksmbd_debug(VFS, \"fail to load dos attribute.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry, char *attr_name,\n\t\t\t\tint attr_name_len)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_xattr_len(user_ns, dentry, name);\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nint ksmbd_vfs_xattr_stream_name(char *stream_name, char **xattr_stream_name,\n\t\t\t\tsize_t *xattr_stream_name_size, int s_type)\n{\n\tchar *type, *buf;\n\n\tif (s_type == DIR_STREAM)\n\t\ttype = \":$INDEX_ALLOCATION\";\n\telse\n\t\ttype = \":$DATA\";\n\n\tbuf = kasprintf(GFP_KERNEL, \"%s%s%s\",\n\t\t\tXATTR_NAME_STREAM, stream_name,\ttype);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*xattr_stream_name = buf;\n\t*xattr_stream_name_size = strlen(buf) + 1;\n\n\treturn 0;\n}\n\nint ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,\n\t\t\t       struct ksmbd_file *src_fp,\n\t\t\t       struct ksmbd_file *dst_fp,\n\t\t\t       struct srv_copychunk *chunks,\n\t\t\t       unsigned int chunk_count,\n\t\t\t       unsigned int *chunk_count_written,\n\t\t\t       unsigned int *chunk_size_written,\n\t\t\t       loff_t *total_size_written)\n{\n\tunsigned int i;\n\tloff_t src_off, dst_off, src_file_size;\n\tsize_t len;\n\tint ret;\n\n\t*chunk_count_written = 0;\n\t*chunk_size_written = 0;\n\t*total_size_written = 0;\n\n\tif (!(src_fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\tpr_err(\"no right to read(%pd)\\n\", src_fp->filp->f_path.dentry);\n\t\treturn -EACCES;\n\t}\n\tif (!(dst_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE))) {\n\t\tpr_err(\"no right to write(%pd)\\n\", dst_fp->filp->f_path.dentry);\n\t\treturn -EACCES;\n\t}\n\n\tif (ksmbd_stream_fd(src_fp) || ksmbd_stream_fd(dst_fp))\n\t\treturn -EBADF;\n\n\tsmb_break_all_levII_oplock(work, dst_fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tfor (i = 0; i < chunk_count; i++) {\n\t\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\t\tif (check_lock_range(src_fp->filp, src_off,\n\t\t\t\t\t     src_off + len - 1, READ))\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (check_lock_range(dst_fp->filp, dst_off,\n\t\t\t\t\t     dst_off + len - 1, WRITE))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tsrc_file_size = i_size_read(file_inode(src_fp->filp));\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\tif (src_off + len > src_file_size)\n\t\t\treturn -E2BIG;\n\n\t\tret = vfs_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t  dst_fp->filp, dst_off, len, 0);\n\t\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\t\tret = generic_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t\t      dst_fp->filp, dst_off,\n\t\t\t\t\t\t      len, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*chunk_count_written += 1;\n\t\t*total_size_written += ret;\n\t}\n\treturn 0;\n}\n\nvoid ksmbd_vfs_posix_lock_wait(struct file_lock *flock)\n{\n\twait_event(flock->fl_wait, !flock->fl_blocker);\n}\n\nint ksmbd_vfs_posix_lock_wait_timeout(struct file_lock *flock, long timeout)\n{\n\treturn wait_event_interruptible_timeout(flock->fl_wait,\n\t\t\t\t\t\t!flock->fl_blocker,\n\t\t\t\t\t\ttimeout);\n}\n\nvoid ksmbd_vfs_posix_lock_unblock(struct file_lock *flock)\n{\n\tlocks_delete_block(flock);\n}\n\nint ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,\n\t\t\t\t struct inode *inode)\n{\n\tstruct posix_acl_state acl_state;\n\tstruct posix_acl *acls;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tksmbd_debug(SMB, \"Set posix acls\\n\");\n\trc = init_acl_state(&acl_state, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Set default owner group */\n\tacl_state.owner.allow = (inode->i_mode & 0700) >> 6;\n\tacl_state.group.allow = (inode->i_mode & 0070) >> 3;\n\tacl_state.other.allow = inode->i_mode & 0007;\n\tacl_state.users->aces[acl_state.users->n].uid = inode->i_uid;\n\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\tacl_state.owner.allow;\n\tacl_state.groups->aces[acl_state.groups->n].gid = inode->i_gid;\n\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\tacl_state.group.allow;\n\tacl_state.mask.allow = 0x07;\n\n\tacls = posix_acl_alloc(6, GFP_KERNEL);\n\tif (!acls) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn -ENOMEM;\n\t}\n\tposix_state_to_acl(&acl_state, acls->a_entries);\n\trc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\telse if (S_ISDIR(inode->i_mode)) {\n\t\tposix_state_to_acl(&acl_state, acls->a_entries);\n\t\trc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t   acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\tfree_acl_state(&acl_state);\n\tposix_acl_release(acls);\n\treturn rc;\n}\n\nint ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,\n\t\t\t\tstruct inode *inode, struct inode *parent_inode)\n{\n\tstruct posix_acl *acls;\n\tstruct posix_acl_entry *pace;\n\tint rc, i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tacls = get_acl(parent_inode, ACL_TYPE_DEFAULT);\n\tif (!acls)\n\t\treturn -ENOENT;\n\tpace = acls->a_entries;\n\n\tfor (i = 0; i < acls->a_count; i++, pace++) {\n\t\tif (pace->e_tag == ACL_MASK) {\n\t\t\tpace->e_perm = 0x07;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t   acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\tposix_acl_release(acls);\n\treturn rc;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <linux/syscalls.h>\n#include <linux/namei.h>\n#include <linux/statfs.h>\n#include <linux/ethtool.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n\n#include \"glob.h\"\n#include \"smbfsctl.h\"\n#include \"oplock.h\"\n#include \"smbacl.h\"\n\n#include \"auth.h\"\n#include \"asn1.h\"\n#include \"connection.h\"\n#include \"transport_ipc.h\"\n#include \"transport_rdma.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"misc.h\"\n\n#include \"server.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"ksmbd_work.h\"\n#include \"mgmt/user_config.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/ksmbd_ida.h\"\n#include \"ndr.h\"\n\nstatic void __wbuf(struct ksmbd_work *work, void **req, void **rsp)\n{\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\t*req = ksmbd_req_buf_next(work);\n\t\t*rsp = ksmbd_resp_buf_next(work);\n\t} else {\n\t\t*req = smb2_get_msg(work->request_buf);\n\t\t*rsp = smb2_get_msg(work->response_buf);\n\t}\n}\n\n#define WORK_BUFFERS(w, rq, rs)\t__wbuf((w), (void **)&(rq), (void **)&(rs))\n\n/**\n * check_session_id() - check for valid session id in smb header\n * @conn:\tconnection instance\n * @id:\t\tsession id from smb header\n *\n * Return:      1 if valid session id, otherwise 0\n */\nstatic inline bool check_session_id(struct ksmbd_conn *conn, u64 id)\n{\n\tstruct ksmbd_session *sess;\n\n\tif (id == 0 || id == -1)\n\t\treturn false;\n\n\tsess = ksmbd_session_lookup_all(conn, id);\n\tif (sess)\n\t\treturn true;\n\tpr_err(\"Invalid user session id: %llu\\n\", id);\n\treturn false;\n}\n\nstruct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn *conn)\n{\n\tstruct channel *chann;\n\n\tlist_for_each_entry(chann, &sess->ksmbd_chann_list, chann_list) {\n\t\tif (chann->conn == conn)\n\t\t\treturn chann;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * smb2_get_ksmbd_tcon() - get tree connection information using a tree id.\n * @work:\tsmb work\n *\n * Return:\t0 if there is a tree connection matched or these are\n *\t\tskipable commands, otherwise error\n */\nint smb2_get_ksmbd_tcon(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tunsigned int cmd = le16_to_cpu(req_hdr->Command);\n\tint tree_id;\n\n\twork->tcon = NULL;\n\tif (cmd == SMB2_TREE_CONNECT_HE ||\n\t    cmd ==  SMB2_CANCEL_HE ||\n\t    cmd ==  SMB2_LOGOFF_HE) {\n\t\tksmbd_debug(SMB, \"skip to check tree connect request\\n\");\n\t\treturn 0;\n\t}\n\n\tif (xa_empty(&work->sess->tree_conns)) {\n\t\tksmbd_debug(SMB, \"NO tree connected\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\ttree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);\n\twork->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);\n\tif (!work->tcon) {\n\t\tpr_err(\"Invalid tid %d\\n\", tree_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_err_rsp() - set error response code on smb response\n * @work:\tsmb work containing response buffer\n */\nvoid smb2_set_err_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_err_rsp *err_rsp;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\terr_rsp = ksmbd_resp_buf_next(work);\n\telse\n\t\terr_rsp = smb2_get_msg(work->response_buf);\n\n\tif (err_rsp->hdr.Status != STATUS_STOPPED_ON_SYMLINK) {\n\t\terr_rsp->StructureSize = SMB2_ERROR_STRUCTURE_SIZE2_LE;\n\t\terr_rsp->ErrorContextCount = 0;\n\t\terr_rsp->Reserved = 0;\n\t\terr_rsp->ByteCount = 0;\n\t\terr_rsp->ErrorData[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, SMB2_ERROR_STRUCTURE_SIZE2);\n\t}\n}\n\n/**\n * is_smb2_neg_cmd() - is it smb2 negotiation command\n * @work:\tsmb work containing smb header\n *\n * Return:      true if smb2 negotiation command, otherwise false\n */\nbool is_smb2_neg_cmd(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is request not response message */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn false;\n\n\tif (hdr->Command != SMB2_NEGOTIATE)\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * is_smb2_rsp() - is it smb2 response\n * @work:\tsmb work containing smb response buffer\n *\n * Return:      true if smb2 response, otherwise false\n */\nbool is_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->response_buf);\n\n\t/* is it SMB2 header ? */\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\t/* make sure it is response not request message */\n\tif (!(hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * get_smb2_cmd_val() - get smb command code from smb header\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      smb2 request command value\n */\nu16 get_smb2_cmd_val(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rcv_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trcv_hdr = ksmbd_req_buf_next(work);\n\telse\n\t\trcv_hdr = smb2_get_msg(work->request_buf);\n\treturn le16_to_cpu(rcv_hdr->Command);\n}\n\n/**\n * set_smb2_rsp_status() - set error response code on smb2 header\n * @work:\tsmb work containing response buffer\n * @err:\terror response code\n */\nvoid set_smb2_rsp_status(struct ksmbd_work *work, __le32 err)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp_hdr = ksmbd_resp_buf_next(work);\n\telse\n\t\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Status = err;\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * init_smb2_neg_rsp() - initialize smb2 response for negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * smb2 negotiate response is sent in reply of smb1 negotiate command for\n * dialect auto-negotiation.\n */\nint init_smb2_neg_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tif (conn->need_neg == false)\n\t\treturn -EINVAL;\n\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->CreditRequest = cpu_to_le16(2);\n\trsp_hdr->Command = SMB2_NEGOTIATE;\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = 0;\n\trsp_hdr->Id.SyncId.ProcessId = 0;\n\trsp_hdr->Id.SyncId.TreeId = 0;\n\trsp_hdr->SessionId = 0;\n\tmemset(rsp_hdr->Signature, 0, 16);\n\n\trsp = smb2_get_msg(work->response_buf);\n\n\tWARN_ON(ksmbd_conn_good(work));\n\n\trsp->StructureSize = cpu_to_le16(65);\n\tksmbd_debug(SMB, \"conn->dialect 0x%x\\n\", conn->dialect);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying connection\n\t */\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\t/* Default Max Message Size till SMB2.0, 64K*/\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\tAUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tif (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\tconn->use_spnego = true;\n\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * smb2_set_rsp_credits() - set number of credits in response buffer\n * @work:\tsmb work containing smb response buffer\n */\nint smb2_set_rsp_credits(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = ksmbd_resp_buf_next(work);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned short credits_requested, aux_max;\n\tunsigned short credit_charge, credits_granted = 0;\n\n\tif (work->send_no_response)\n\t\treturn 0;\n\n\thdr->CreditCharge = req_hdr->CreditCharge;\n\n\tif (conn->total_credits > conn->vals->max_credits) {\n\t\thdr->CreditRequest = 0;\n\t\tpr_err(\"Total credits overflow: %d\\n\", conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tcredit_charge = max_t(unsigned short,\n\t\t\t      le16_to_cpu(req_hdr->CreditCharge), 1);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->total_credits -= credit_charge;\n\tconn->outstanding_credits -= credit_charge;\n\tcredits_requested = max_t(unsigned short,\n\t\t\t\t  le16_to_cpu(req_hdr->CreditRequest), 1);\n\n\t/* according to smb2.credits smbtorture, Windows server\n\t * 2016 or later grant up to 8192 credits at once.\n\t *\n\t * TODO: Need to adjuct CreditRequest value according to\n\t * current cpu load\n\t */\n\tif (hdr->Command == SMB2_NEGOTIATE)\n\t\taux_max = 1;\n\telse\n\t\taux_max = conn->vals->max_credits - credit_charge;\n\tcredits_granted = min_t(unsigned short, credits_requested, aux_max);\n\n\tif (conn->vals->max_credits - conn->total_credits < credits_granted)\n\t\tcredits_granted = conn->vals->max_credits -\n\t\t\tconn->total_credits;\n\n\tconn->total_credits += credits_granted;\n\twork->credits_granted += credits_granted;\n\n\tif (!req_hdr->NextCommand) {\n\t\t/* Update CreditRequest in last request */\n\t\thdr->CreditRequest = cpu_to_le16(work->credits_granted);\n\t}\n\tksmbd_debug(SMB,\n\t\t    \"credits: requested[%d] granted[%d] total_granted[%d]\\n\",\n\t\t    credits_requested, credits_granted,\n\t\t    conn->total_credits);\n\treturn 0;\n}\n\n/**\n * init_chained_smb2_rsp() - initialize smb2 chained response\n * @work:\tsmb work containing smb response buffer\n */\nstatic void init_chained_smb2_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *rsp = ksmbd_resp_buf_next(work);\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct smb2_hdr *rcv_hdr;\n\tint next_hdr_offset = 0;\n\tint len, new_len;\n\n\t/* Len of this response = updated RFC len - offset of previous cmd\n\t * in the compound rsp\n\t */\n\n\t/* Storing the current local FID which may be needed by subsequent\n\t * command in the compound request\n\t */\n\tif (req->Command == SMB2_CREATE && rsp->Status == STATUS_SUCCESS) {\n\t\twork->compound_fid = ((struct smb2_create_rsp *)rsp)->VolatileFileId;\n\t\twork->compound_pfid = ((struct smb2_create_rsp *)rsp)->PersistentFileId;\n\t\twork->compound_sid = le64_to_cpu(rsp->SessionId);\n\t}\n\n\tlen = get_rfc1002_len(work->response_buf) - work->next_smb2_rsp_hdr_off;\n\tnext_hdr_offset = le32_to_cpu(req->NextCommand);\n\n\tnew_len = ALIGN(len, 8);\n\tinc_rfc1001_len(work->response_buf,\n\t\t\tsizeof(struct smb2_hdr) + new_len - len);\n\trsp->NextCommand = cpu_to_le32(new_len);\n\n\twork->next_smb2_rcv_hdr_off += next_hdr_offset;\n\twork->next_smb2_rsp_hdr_off += new_len;\n\tksmbd_debug(SMB,\n\t\t    \"Compound req new_len = %d rcv off = %d rsp off = %d\\n\",\n\t\t    new_len, work->next_smb2_rcv_hdr_off,\n\t\t    work->next_smb2_rsp_hdr_off);\n\n\trsp_hdr = ksmbd_resp_buf_next(work);\n\trcv_hdr = ksmbd_req_buf_next(work);\n\n\tif (!(rcv_hdr->Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"related flag should be set\\n\");\n\t\twork->compound_fid = KSMBD_NO_FID;\n\t\twork->compound_pfid = KSMBD_NO_FID;\n\t}\n\tmemset((char *)rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\trsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR |\n\t\t\t\tSMB2_FLAGS_RELATED_OPERATIONS);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n}\n\n/**\n * is_chained_smb2_message() - check for chained command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      true if chained request, otherwise false\n */\nbool is_chained_smb2_message(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tunsigned int len, next_cmd;\n\n\tif (hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\treturn false;\n\n\thdr = ksmbd_req_buf_next(work);\n\tnext_cmd = le32_to_cpu(hdr->NextCommand);\n\tif (next_cmd > 0) {\n\t\tif ((u64)work->next_smb2_rcv_hdr_off + next_cmd +\n\t\t\t__SMB2_HEADER_STRUCTURE_SIZE >\n\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\tpr_err(\"next command(%u) offset exceeds smb msg size\\n\",\n\t\t\t       next_cmd);\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((u64)get_rfc1002_len(work->response_buf) + MAX_CIFS_SMALL_BUFFER_SIZE >\n\t\t    work->response_sz) {\n\t\t\tpr_err(\"next response offset exceeds response buffer size\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"got SMB2 chained command\\n\");\n\t\tinit_chained_smb2_rsp(work);\n\t\treturn true;\n\t} else if (work->next_smb2_rcv_hdr_off) {\n\t\t/*\n\t\t * This is last request in chained command,\n\t\t * align response to 8 byte\n\t\t */\n\t\tlen = ALIGN(get_rfc1002_len(work->response_buf), 8);\n\t\tlen = len - get_rfc1002_len(work->response_buf);\n\t\tif (len) {\n\t\t\tksmbd_debug(SMB, \"padding len %u\\n\", len);\n\t\t\tinc_rfc1001_len(work->response_buf, len);\n\t\t\tif (work->aux_payload_sz)\n\t\t\t\twork->aux_payload_sz += len;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * init_smb2_rsp_hdr() - initialize smb2 response\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint init_smb2_rsp_hdr(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *rsp_hdr = smb2_get_msg(work->response_buf);\n\tstruct smb2_hdr *rcv_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\n\tmemset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);\n\t*(__be32 *)work->response_buf =\n\t\tcpu_to_be32(conn->vals->header_size);\n\trsp_hdr->ProtocolId = rcv_hdr->ProtocolId;\n\trsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;\n\trsp_hdr->Command = rcv_hdr->Command;\n\n\t/*\n\t * Message is response. We don't grant oplock yet.\n\t */\n\trsp_hdr->Flags = (SMB2_FLAGS_SERVER_TO_REDIR);\n\trsp_hdr->NextCommand = 0;\n\trsp_hdr->MessageId = rcv_hdr->MessageId;\n\trsp_hdr->Id.SyncId.ProcessId = rcv_hdr->Id.SyncId.ProcessId;\n\trsp_hdr->Id.SyncId.TreeId = rcv_hdr->Id.SyncId.TreeId;\n\trsp_hdr->SessionId = rcv_hdr->SessionId;\n\tmemcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);\n\n\twork->syncronous = true;\n\tif (work->async_id) {\n\t\tksmbd_release_id(&conn->async_ida, work->async_id);\n\t\twork->async_id = 0;\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_allocate_rsp_buf() - allocate smb2 response buffer\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise -ENOMEM\n */\nint smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif ((req->InfoType == SMB2_O_INFO_FILE &&\n\t\t     (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION)) ||\n\t\t    req->InfoType == SMB2_O_INFO_SECURITY)\n\t\t\tsz = large_sz;\n\t}\n\n\t/* allocate large response buf for chained commands */\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\n\twork->response_sz = sz;\n\treturn 0;\n}\n\n/**\n * smb2_check_user_session() - check for valid session for a user\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_check_user_session(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tunsigned int cmd = conn->ops->get_cmd_val(work);\n\tunsigned long long sess_id;\n\n\twork->sess = NULL;\n\t/*\n\t * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not\n\t * require a session id, so no need to validate user session's for\n\t * these commands.\n\t */\n\tif (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||\n\t    cmd == SMB2_SESSION_SETUP_HE)\n\t\treturn 0;\n\n\tif (!ksmbd_conn_good(work))\n\t\treturn -EINVAL;\n\n\tsess_id = le64_to_cpu(req_hdr->SessionId);\n\t/* Check for validity of user session */\n\twork->sess = ksmbd_session_lookup_all(conn, sess_id);\n\tif (work->sess)\n\t\treturn 1;\n\tksmbd_debug(SMB, \"Invalid user session, Uid %llu\\n\", sess_id);\n\treturn -EINVAL;\n}\n\nstatic void destroy_previous_session(struct ksmbd_conn *conn,\n\t\t\t\t     struct ksmbd_user *user, u64 id)\n{\n\tstruct ksmbd_session *prev_sess = ksmbd_session_lookup_slowpath(id);\n\tstruct ksmbd_user *prev_user;\n\tstruct channel *chann;\n\n\tif (!prev_sess)\n\t\treturn;\n\n\tprev_user = prev_sess->user;\n\n\tif (!prev_user ||\n\t    strcmp(user->name, prev_user->name) ||\n\t    user->passkey_sz != prev_user->passkey_sz ||\n\t    memcmp(user->passkey, prev_user->passkey, user->passkey_sz))\n\t\treturn;\n\n\tprev_sess->state = SMB2_SESSION_EXPIRED;\n\twrite_lock(&prev_sess->chann_lock);\n\tlist_for_each_entry(chann, &prev_sess->ksmbd_chann_list, chann_list)\n\t\tchann->conn->status = KSMBD_SESS_EXITING;\n\twrite_unlock(&prev_sess->chann_lock);\n}\n\n/**\n * smb2_get_name() - get filename string from on the wire smb format\n * @src:\tsource buffer\n * @maxlen:\tmaxlen of source string\n * @local_nls:\tnls_table pointer\n *\n * Return:      matching converted filename on success, otherwise error ptr\n */\nstatic char *\nsmb2_get_name(const char *src, const int maxlen, struct nls_table *local_nls)\n{\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(src, maxlen, 1, local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"failed to get name %ld\\n\", PTR_ERR(name));\n\t\treturn name;\n\t}\n\n\tksmbd_conv_path_to_unix(name);\n\tksmbd_strip_last_slash(name);\n\treturn name;\n}\n\nint setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint id;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\trsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;\n\n\tid = ksmbd_acquire_async_msg_id(&conn->async_ida);\n\tif (id < 0) {\n\t\tpr_err(\"Failed to alloc async message id\\n\");\n\t\treturn id;\n\t}\n\twork->syncronous = false;\n\twork->async_id = id;\n\trsp_hdr->Id.AsyncId = cpu_to_le64(id);\n\n\tksmbd_debug(SMB,\n\t\t    \"Send interim Response to inform async request id : %d\\n\",\n\t\t    work->async_id);\n\n\twork->cancel_fn = fn;\n\twork->cancel_argv = arg;\n\n\tif (list_empty(&work->async_request_entry)) {\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_add_tail(&work->async_request_entry, &conn->async_requests);\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)\n{\n\tstruct smb2_hdr *rsp_hdr;\n\n\trsp_hdr = smb2_get_msg(work->response_buf);\n\tsmb2_set_err_rsp(work);\n\trsp_hdr->Status = status;\n\n\twork->multiRsp = 1;\n\tksmbd_conn_write(work);\n\trsp_hdr->Status = 0;\n\twork->multiRsp = 0;\n}\n\nstatic __le32 smb2_get_reparse_tag_special_file(umode_t mode)\n{\n\tif (S_ISDIR(mode) || S_ISREG(mode))\n\t\treturn 0;\n\n\tif (S_ISLNK(mode))\n\t\treturn IO_REPARSE_TAG_LX_SYMLINK_LE;\n\telse if (S_ISFIFO(mode))\n\t\treturn IO_REPARSE_TAG_LX_FIFO_LE;\n\telse if (S_ISSOCK(mode))\n\t\treturn IO_REPARSE_TAG_AF_UNIX_LE;\n\telse if (S_ISCHR(mode))\n\t\treturn IO_REPARSE_TAG_LX_CHR_LE;\n\telse if (S_ISBLK(mode))\n\t\treturn IO_REPARSE_TAG_LX_BLK_LE;\n\n\treturn 0;\n}\n\n/**\n * smb2_get_dos_mode() - get file mode in dos format from unix mode\n * @stat:\tkstat containing file mode\n * @attribute:\tattribute flags\n *\n * Return:      converted dos mode\n */\nstatic int smb2_get_dos_mode(struct kstat *stat, int attribute)\n{\n\tint attr = 0;\n\n\tif (S_ISDIR(stat->mode)) {\n\t\tattr = FILE_ATTRIBUTE_DIRECTORY |\n\t\t\t(attribute & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));\n\t} else {\n\t\tattr = (attribute & 0x00005137) | FILE_ATTRIBUTE_ARCHIVE;\n\t\tattr &= ~(FILE_ATTRIBUTE_DIRECTORY);\n\t\tif (S_ISREG(stat->mode) && (server_conf.share_fake_fscaps &\n\t\t\t\tFILE_SUPPORTS_SPARSE_FILES))\n\t\t\tattr |= FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (smb2_get_reparse_tag_special_file(stat->mode))\n\t\t\tattr |= FILE_ATTRIBUTE_REPARSE_POINT;\n\t}\n\n\treturn attr;\n}\n\nstatic void build_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt,\n\t\t\t       __le16 hash_id)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = hash_id;\n}\n\nstatic void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t       __le16 cipher_type)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(4);\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CipherCount = cpu_to_le16(1);\n\tpneg_ctxt->Ciphers[0] = cipher_type;\n}\n\nstatic void build_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt,\n\t\t\t\t   __le16 comp_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16(sizeof(struct smb2_compression_capabilities_context)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->Flags = cpu_to_le32(0);\n\tpneg_ctxt->CompressionAlgorithms[0] = comp_algo;\n}\n\nstatic void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t__le16 sign_algo)\n{\n\tpneg_ctxt->ContextType = SMB2_SIGNING_CAPABILITIES;\n\tpneg_ctxt->DataLength =\n\t\tcpu_to_le16((sizeof(struct smb2_signing_capabilities) + 2)\n\t\t\t- sizeof(struct smb2_neg_context));\n\tpneg_ctxt->Reserved = cpu_to_le32(0);\n\tpneg_ctxt->SigningAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SigningAlgorithms[0] = sign_algo;\n}\n\nstatic void build_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_POSIX_EXTENSIONS_AVAILABLE;\n\tpneg_ctxt->DataLength = cpu_to_le16(POSIX_CTXT_DATA_LEN);\n\t/* SMB2_CREATE_TAG_POSIX is \"0x93AD25509CB411E7B42383DE968BCD7C\" */\n\tpneg_ctxt->Name[0] = 0x93;\n\tpneg_ctxt->Name[1] = 0xAD;\n\tpneg_ctxt->Name[2] = 0x25;\n\tpneg_ctxt->Name[3] = 0x50;\n\tpneg_ctxt->Name[4] = 0x9C;\n\tpneg_ctxt->Name[5] = 0xB4;\n\tpneg_ctxt->Name[6] = 0x11;\n\tpneg_ctxt->Name[7] = 0xE7;\n\tpneg_ctxt->Name[8] = 0xB4;\n\tpneg_ctxt->Name[9] = 0x23;\n\tpneg_ctxt->Name[10] = 0x83;\n\tpneg_ctxt->Name[11] = 0xDE;\n\tpneg_ctxt->Name[12] = 0x96;\n\tpneg_ctxt->Name[13] = 0x8B;\n\tpneg_ctxt->Name[14] = 0xCD;\n\tpneg_ctxt->Name[15] = 0x7C;\n}\n\nstatic void assemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_negotiate_rsp *rsp,\n\t\t\t\t  void *smb2_buf_len)\n{\n\tchar *pneg_ctxt = (char *)rsp +\n\t\t\tle32_to_cpu(rsp->NegotiateContextOffset);\n\tint neg_ctxt_cnt = 1;\n\tint ctxt_size;\n\n\tksmbd_debug(SMB,\n\t\t    \"assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,\n\t\t\t   conn->preauth_info->Preauth_HashId);\n\trsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);\n\tinc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);\n\tctxt_size = sizeof(struct smb2_preauth_neg_context);\n\t/* Round to 8 byte boundary */\n\tpneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);\n\n\tif (conn->cipher_type) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,\n\t\t\t\t   conn->cipher_type);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt +=\n\t\t\tround_up(sizeof(struct smb2_encryption_neg_context) + 2,\n\t\t\t\t 8);\n\t}\n\n\tif (conn->compress_algorithm) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t/* Temporarily set to SMB3_COMPRESS_NONE */\n\t\tbuild_compression_ctxt((struct smb2_compression_capabilities_context *)pneg_ctxt,\n\t\t\t\t       conn->compress_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_compression_capabilities_context) + 2;\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_compression_capabilities_context) + 2,\n\t\t\t\t      8);\n\t}\n\n\tif (conn->posix_ext_supported) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\tbuild_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_posix_neg_context);\n\t\t/* Round to 8 byte boundary */\n\t\tpneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);\n\t}\n\n\tif (conn->signing_negotiated) {\n\t\tctxt_size = round_up(ctxt_size, 8);\n\t\tksmbd_debug(SMB,\n\t\t\t    \"assemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\tbuild_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,\n\t\t\t\t    conn->signing_algorithm);\n\t\trsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);\n\t\tctxt_size += sizeof(struct smb2_signing_capabilities) + 2;\n\t}\n\n\tinc_rfc1001_len(smb2_buf_len, ctxt_size);\n}\n\nstatic __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t  struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\t__le32 err = STATUS_NO_PREAUTH_INTEGRITY_HASH_OVERLAP;\n\n\tif (pneg_ctxt->HashAlgorithms == SMB2_PREAUTH_INTEGRITY_SHA512) {\n\t\tconn->preauth_info->Preauth_HashId =\n\t\t\tSMB2_PREAUTH_INTEGRITY_SHA512;\n\t\terr = STATUS_SUCCESS;\n\t}\n\n\treturn err;\n}\n\nstatic void decode_encrypt_ctxt(struct ksmbd_conn *conn,\n\t\t\t\tstruct smb2_encryption_neg_context *pneg_ctxt,\n\t\t\t\tint len_of_ctxts)\n{\n\tint cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);\n\tint i, cphs_size = cph_cnt * sizeof(__le16);\n\n\tconn->cipher_type = 0;\n\n\tif (sizeof(struct smb2_encryption_neg_context) + cphs_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid cipher count(%d)\\n\", cph_cnt);\n\t\treturn;\n\t}\n\n\tif (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION))\n\t\treturn;\n\n\tfor (i = 0; i < cph_cnt; i++) {\n\t\tif (pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_GCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES128_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_CCM ||\n\t\t    pneg_ctxt->Ciphers[i] == SMB2_ENCRYPTION_AES256_GCM) {\n\t\t\tksmbd_debug(SMB, \"Cipher ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->Ciphers[i]);\n\t\t\tconn->cipher_type = pneg_ctxt->Ciphers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * smb3_encryption_negotiated() - checks if server and client agreed on enabling encryption\n * @conn:\tsmb connection\n *\n * Return:\ttrue if connection should be encrypted, else false\n */\nstatic bool smb3_encryption_negotiated(struct ksmbd_conn *conn)\n{\n\tif (!conn->ops->generate_encryptionkey)\n\t\treturn false;\n\n\t/*\n\t * SMB 3.0 and 3.0.2 dialects use the SMB2_GLOBAL_CAP_ENCRYPTION flag.\n\t * SMB 3.1.1 uses the cipher_type field.\n\t */\n\treturn (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) ||\n\t    conn->cipher_type;\n}\n\nstatic void decode_compress_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_compression_capabilities_context *pneg_ctxt)\n{\n\tconn->compress_algorithm = SMB3_COMPRESS_NONE;\n}\n\nstatic void decode_sign_cap_ctxt(struct ksmbd_conn *conn,\n\t\t\t\t struct smb2_signing_capabilities *pneg_ctxt,\n\t\t\t\t int len_of_ctxts)\n{\n\tint sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);\n\tint i, sign_alos_size = sign_algo_cnt * sizeof(__le16);\n\n\tconn->signing_negotiated = false;\n\n\tif (sizeof(struct smb2_signing_capabilities) + sign_alos_size >\n\t    len_of_ctxts) {\n\t\tpr_err(\"Invalid signing algorithm count(%d)\\n\", sign_algo_cnt);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sign_algo_cnt; i++) {\n\t\tif (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256_LE ||\n\t\t    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC_LE) {\n\t\t\tksmbd_debug(SMB, \"Signing Algorithm ID = 0x%x\\n\",\n\t\t\t\t    pneg_ctxt->SigningAlgorithms[i]);\n\t\t\tconn->signing_negotiated = true;\n\t\t\tconn->signing_algorithm =\n\t\t\t\tpneg_ctxt->SigningAlgorithms[i];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen;\n\n\t\t/* check that offset is not beyond end of SMB */\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen + sizeof(struct smb2_neg_context) > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    len_of_ctxts);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     len_of_ctxts);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}\n\n/**\n * smb2_handle_negotiate() - handler for smb2 negotiate command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0\n */\nint smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}\n\nstatic int alloc_preauth_hash(struct ksmbd_session *sess,\n\t\t\t      struct ksmbd_conn *conn)\n{\n\tif (sess->Preauth_HashValue)\n\t\treturn 0;\n\n\tsess->Preauth_HashValue = kmemdup(conn->preauth_info->Preauth_HashValue,\n\t\t\t\t\t  PREAUTH_HASHVALUE_SIZE, GFP_KERNEL);\n\tif (!sess->Preauth_HashValue)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int generate_preauth_hash(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tu8 *preauth_hash;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn 0;\n\n\tif (conn->binding) {\n\t\tstruct preauth_session *preauth_sess;\n\n\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\tif (!preauth_sess) {\n\t\t\tpreauth_sess = ksmbd_preauth_session_alloc(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpreauth_hash = preauth_sess->Preauth_HashValue;\n\t} else {\n\t\tif (!sess->Preauth_HashValue)\n\t\t\tif (alloc_preauth_hash(sess, conn))\n\t\t\t\treturn -ENOMEM;\n\t\tpreauth_hash = sess->Preauth_HashValue;\n\t}\n\n\tksmbd_gen_preauth_integrity_hash(conn, work->request_buf, preauth_hash);\n\treturn 0;\n}\n\nstatic int decode_negotiation_token(struct ksmbd_conn *conn,\n\t\t\t\t    struct negotiate_message *negblob,\n\t\t\t\t    size_t sz)\n{\n\tif (!conn->use_spnego)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_decode_negTokenInit((char *)negblob, sz, conn)) {\n\t\tif (ksmbd_decode_negTokenTarg((char *)negblob, sz, conn)) {\n\t\t\tconn->auth_mechs |= KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->preferred_auth_mech = KSMBD_AUTH_NTLMSSP;\n\t\t\tconn->use_spnego = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ntlm_negotiate(struct ksmbd_work *work,\n\t\t\t  struct negotiate_message *negblob,\n\t\t\t  size_t negblob_len)\n{\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct challenge_message *chgblob;\n\tunsigned char *spnego_blob = NULL;\n\tu16 spnego_blob_len;\n\tchar *neg_blob;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"negotiate phase\\n\");\n\trc = ksmbd_decode_ntlmssp_neg_blob(negblob, negblob_len, work->conn);\n\tif (rc)\n\t\treturn rc;\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tchgblob =\n\t\t(struct challenge_message *)((char *)&rsp->hdr.ProtocolId + sz);\n\tmemset(chgblob, 0, sizeof(struct challenge_message));\n\n\tif (!work->conn->use_spnego) {\n\t\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\t\tif (sz < 0)\n\t\t\treturn -ENOMEM;\n\n\t\trsp->SecurityBufferLength = cpu_to_le16(sz);\n\t\treturn 0;\n\t}\n\n\tsz = sizeof(struct challenge_message);\n\tsz += (strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;\n\n\tneg_blob = kzalloc(sz, GFP_KERNEL);\n\tif (!neg_blob)\n\t\treturn -ENOMEM;\n\n\tchgblob = (struct challenge_message *)neg_blob;\n\tsz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);\n\tif (sz < 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = build_spnego_ntlmssp_neg_blob(&spnego_blob, &spnego_blob_len,\n\t\t\t\t\t   neg_blob, sz);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\nout:\n\tkfree(spnego_blob);\n\tkfree(neg_blob);\n\treturn rc;\n}\n\nstatic struct authenticate_message *user_authblob(struct ksmbd_conn *conn,\n\t\t\t\t\t\t  struct smb2_sess_setup_req *req)\n{\n\tint sz;\n\n\tif (conn->use_spnego && conn->mechToken)\n\t\treturn (struct authenticate_message *)conn->mechToken;\n\n\tsz = le16_to_cpu(req->SecurityBufferOffset);\n\treturn (struct authenticate_message *)((char *)&req->hdr.ProtocolId\n\t\t\t\t\t       + sz);\n}\n\nstatic struct ksmbd_user *session_user(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_sess_setup_req *req)\n{\n\tstruct authenticate_message *authblob;\n\tstruct ksmbd_user *user;\n\tchar *name;\n\tunsigned int auth_msg_len, name_off, name_len, secbuf_len;\n\n\tsecbuf_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (secbuf_len < sizeof(struct authenticate_message)) {\n\t\tksmbd_debug(SMB, \"blob len %d too small\\n\", secbuf_len);\n\t\treturn NULL;\n\t}\n\tauthblob = user_authblob(conn, req);\n\tname_off = le32_to_cpu(authblob->UserName.BufferOffset);\n\tname_len = le16_to_cpu(authblob->UserName.Length);\n\tauth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;\n\n\tif (auth_msg_len < (u64)name_off + name_len)\n\t\treturn NULL;\n\n\tname = smb_strndup_from_utf16((const char *)authblob + name_off,\n\t\t\t\t      name_len,\n\t\t\t\t      true,\n\t\t\t\t      conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\tpr_err(\"cannot allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tksmbd_debug(SMB, \"session setup request for user %s\\n\", name);\n\tuser = ksmbd_login_user(name);\n\tkfree(name);\n\treturn user;\n}\n\nstatic int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(work->response_buf, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(conn, user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t/*\n\t * If session state is SMB2_SESSION_VALID, We can assume\n\t * that it is reauthentication. And the user/password\n\t * has been verified, so return it here.\n\t */\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\tif (conn->binding)\n\t\t\tgoto binding_session;\n\t\treturn 0;\n\t}\n\n\tif ((rsp->SessionFlags != SMB2_SESSION_FLAG_IS_GUEST_LE &&\n\t     (conn->sign || server_conf.enforced_signing)) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn) &&\n\t\t\t!(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\trc = conn->ops->generate_encryptionkey(conn, sess);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t/*\n\t\t * signing is disable if encryption is enable\n\t\t * on this session\n\t\t */\n\t\tsess->sign = false;\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tread_lock(&sess->chann_lock);\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tread_unlock(&sess->chann_lock);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\twrite_lock(&sess->chann_lock);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t\twrite_unlock(&sess->chann_lock);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SMB_SERVER_KERBEROS5\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\t(le16_to_cpu(rsp->SecurityBufferOffset) + 4);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(conn, sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(work->response_buf, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (smb3_encryption_negotiated(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(conn, sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tread_lock(&sess->chann_lock);\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tread_unlock(&sess->chann_lock);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\twrite_lock(&sess->chann_lock);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t\twrite_unlock(&sess->chann_lock);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n#else\nstatic int krb5_authenticate(struct ksmbd_work *work)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint smb2_sess_setup(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess;\n\tstruct negotiate_message *negblob;\n\tunsigned int negblob_len, negblob_off;\n\tint rc = 0;\n\n\tksmbd_debug(SMB, \"Received request for session setup\\n\");\n\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->SessionFlags = 0;\n\trsp->SecurityBufferOffset = cpu_to_le16(72);\n\trsp->SecurityBufferLength = 0;\n\tinc_rfc1001_len(work->response_buf, 9);\n\n\tif (!req->hdr.SessionId) {\n\t\tsess = ksmbd_smb2_session_create();\n\t\tif (!sess) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\trsp->hdr.SessionId = cpu_to_le64(sess->id);\n\t\trc = ksmbd_session_register(conn, sess);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\t} else if (conn->dialect >= SMB30_PROT_ID &&\n\t\t   (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   req->Flags & SMB2_SESSION_REQ_FLAG_BINDING) {\n\t\tu64 sess_id = le64_to_cpu(req->hdr.SessionId);\n\n\t\tsess = ksmbd_session_lookup_slowpath(sess_id);\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (conn->dialect != sess->dialect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!(req->hdr.Flags & SMB2_FLAGS_SIGNED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (strncmp(conn->ClientGUID, sess->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_IN_PROGRESS) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_session_lookup(conn, sess_id)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = true;\n\t} else if ((conn->dialect < SMB30_PROT_ID ||\n\t\t    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   (req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\tsess = NULL;\n\t\trc = -EACCES;\n\t\tgoto out_err;\n\t} else {\n\t\tsess = ksmbd_session_lookup(conn,\n\t\t\t\t\t    le64_to_cpu(req->hdr.SessionId));\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\twork->sess = sess;\n\n\tif (sess->state == SMB2_SESSION_EXPIRED)\n\t\tsess->state = SMB2_SESSION_IN_PROGRESS;\n\n\tnegblob_off = le16_to_cpu(req->SecurityBufferOffset);\n\tnegblob_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer) ||\n\t    negblob_len < offsetof(struct negotiate_message, NegotiateFlags)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tnegblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId +\n\t\t\tnegblob_off);\n\n\tif (decode_negotiation_token(conn, negblob, negblob_len) == 0) {\n\t\tif (conn->mechToken)\n\t\t\tnegblob = (struct negotiate_message *)conn->mechToken;\n\t}\n\n\tif (server_conf.auth_mechs & conn->auth_mechs) {\n\t\trc = generate_preauth_hash(work);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tif (conn->preferred_auth_mech &\n\t\t\t\t(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {\n\t\t\trc = krb5_authenticate(work);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tksmbd_conn_set_good(work);\n\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\tsess->Preauth_HashValue = NULL;\n\t\t} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {\n\t\t\tif (negblob->MessageType == NtLmNegotiate) {\n\t\t\t\trc = ntlm_negotiate(work, negblob, negblob_len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\t\t\t\trsp->hdr.Status =\n\t\t\t\t\tSTATUS_MORE_PROCESSING_REQUIRED;\n\t\t\t\t/*\n\t\t\t\t * Note: here total size -1 is done as an\n\t\t\t\t * adjustment for 0 size blob\n\t\t\t\t */\n\t\t\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength) - 1);\n\n\t\t\t} else if (negblob->MessageType == NtLmAuthenticate) {\n\t\t\t\trc = ntlm_authenticate(work);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\tksmbd_conn_set_good(work);\n\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t\tif (conn->binding) {\n\t\t\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\t\t\tpreauth_sess =\n\t\t\t\t\t\tksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\t\t\tif (preauth_sess) {\n\t\t\t\t\t\tlist_del(&preauth_sess->preauth_entry);\n\t\t\t\t\t\tkfree(preauth_sess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\t\tsess->Preauth_HashValue = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: need one more negotiation */\n\t\t\tpr_err(\"Not support the preferred authentication\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Not support authentication\\n\");\n\t\trc = -EINVAL;\n\t}\n\nout_err:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\telse if (rc)\n\t\trsp->hdr.Status = STATUS_LOGON_FAILURE;\n\n\tif (conn->use_spnego && conn->mechToken) {\n\t\tkfree(conn->mechToken);\n\t\tconn->mechToken = NULL;\n\t}\n\n\tif (rc < 0) {\n\t\t/*\n\t\t * SecurityBufferOffset should be set to zero\n\t\t * in session setup error response.\n\t\t */\n\t\trsp->SecurityBufferOffset = 0;\n\n\t\tif (sess) {\n\t\t\tbool try_delay = false;\n\n\t\t\t/*\n\t\t\t * To avoid dictionary attacks (repeated session setups rapidly sent) to\n\t\t\t * connect to server, ksmbd make a delay of a 5 seconds on session setup\n\t\t\t * failure to make it harder to send enough random connection requests\n\t\t\t * to break into a server.\n\t\t\t */\n\t\t\tif (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)\n\t\t\t\ttry_delay = true;\n\n\t\t\txa_erase(&conn->sessions, sess->id);\n\t\t\tksmbd_session_destroy(sess);\n\t\t\twork->sess = NULL;\n\t\t\tif (try_delay)\n\t\t\t\tssleep(5);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_tree_connect() - handler for smb2 tree connect command\n * @work:\tsmb work containing smb request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_tree_connect(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_tree_connect_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_tree_connect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *treename = NULL, *name = NULL;\n\tstruct ksmbd_tree_conn_status status;\n\tstruct ksmbd_share_config *share;\n\tint rc = -EINVAL;\n\n\ttreename = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->PathLength), true,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(treename)) {\n\t\tpr_err(\"treename is NULL\\n\");\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tname = ksmbd_extract_sharename(treename);\n\tif (IS_ERR(name)) {\n\t\tstatus.ret = KSMBD_TREE_CONN_STATUS_ERROR;\n\t\tgoto out_err1;\n\t}\n\n\tksmbd_debug(SMB, \"tree connect request for tree %s treename %s\\n\",\n\t\t    name, treename);\n\n\tstatus = ksmbd_tree_conn_connect(conn, sess, name);\n\tif (status.ret == KSMBD_TREE_CONN_STATUS_OK)\n\t\trsp->hdr.Id.SyncId.TreeId = cpu_to_le32(status.tree_conn->id);\n\telse\n\t\tgoto out_err1;\n\n\tshare = status.tree_conn->share_conf;\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC share path request\\n\");\n\t\trsp->ShareType = SMB2_SHARE_TYPE_PIPE;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_DELETE_LE | FILE_READ_CONTROL_LE |\n\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\tFILE_SYNCHRONIZE_LE;\n\t} else {\n\t\trsp->ShareType = SMB2_SHARE_TYPE_DISK;\n\t\trsp->MaximalAccess = FILE_READ_DATA_LE | FILE_READ_EA_LE |\n\t\t\tFILE_EXECUTE_LE | FILE_READ_ATTRIBUTES_LE;\n\t\tif (test_tree_conn_flag(status.tree_conn,\n\t\t\t\t\tKSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\trsp->MaximalAccess |= FILE_WRITE_DATA_LE |\n\t\t\t\tFILE_APPEND_DATA_LE | FILE_WRITE_EA_LE |\n\t\t\t\tFILE_DELETE_LE | FILE_WRITE_ATTRIBUTES_LE |\n\t\t\t\tFILE_DELETE_CHILD_LE | FILE_READ_CONTROL_LE |\n\t\t\t\tFILE_WRITE_DAC_LE | FILE_WRITE_OWNER_LE |\n\t\t\t\tFILE_SYNCHRONIZE_LE;\n\t\t}\n\t}\n\n\tstatus.tree_conn->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\tif (conn->posix_ext_supported)\n\t\tstatus.tree_conn->posix_extensions = true;\n\nout_err1:\n\trsp->StructureSize = cpu_to_le16(16);\n\trsp->Capabilities = 0;\n\trsp->Reserved = 0;\n\t/* default manual caching */\n\trsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;\n\tinc_rfc1001_len(work->response_buf, 16);\n\n\tif (!IS_ERR(treename))\n\t\tkfree(treename);\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tswitch (status.ret) {\n\tcase KSMBD_TREE_CONN_STATUS_OK:\n\t\trsp->hdr.Status = STATUS_SUCCESS;\n\t\trc = 0;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_NO_SHARE:\n\t\trsp->hdr.Status = STATUS_BAD_NETWORK_PATH;\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase KSMBD_TREE_CONN_STATUS_NOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\tcase KSMBD_TREE_CONN_STATUS_ERROR:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_CONNS:\n\tcase KSMBD_TREE_CONN_STATUS_TOO_MANY_SESSIONS:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tbreak;\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t}\n\n\treturn rc;\n}\n\n/**\n * smb2_create_open_flags() - convert smb open flags to unix open flags\n * @file_present:\tis file already present\n * @access:\t\tfile access flags\n * @disposition:\tfile disposition flags\n * @may_flags:\t\tset with MAY_ flags\n *\n * Return:      file open flags\n */\nstatic int smb2_create_open_flags(bool file_present, __le32 access,\n\t\t\t\t  __le32 disposition,\n\t\t\t\t  int *may_flags)\n{\n\tint oflags = O_NONBLOCK | O_LARGEFILE;\n\n\tif (access & FILE_READ_DESIRED_ACCESS_LE &&\n\t    access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_RDWR;\n\t\t*may_flags = MAY_OPEN | MAY_READ | MAY_WRITE;\n\t} else if (access & FILE_WRITE_DESIRE_ACCESS_LE) {\n\t\toflags |= O_WRONLY;\n\t\t*may_flags = MAY_OPEN | MAY_WRITE;\n\t} else {\n\t\toflags |= O_RDONLY;\n\t\t*may_flags = MAY_OPEN | MAY_READ;\n\t}\n\n\tif (access == FILE_READ_ATTRIBUTES_LE)\n\t\toflags |= O_PATH;\n\n\tif (file_present) {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_CREATE_LE:\n\t\t\tbreak;\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_TRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (disposition & FILE_CREATE_MASK_LE) {\n\t\tcase FILE_SUPERSEDE_LE:\n\t\tcase FILE_CREATE_LE:\n\t\tcase FILE_OPEN_IF_LE:\n\t\tcase FILE_OVERWRITE_IF_LE:\n\t\t\toflags |= O_CREAT;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_LE:\n\t\tcase FILE_OVERWRITE_LE:\n\t\t\toflags &= ~O_CREAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn oflags;\n}\n\n/**\n * smb2_tree_disconnect() - handler for smb tree connect request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}\n\n/**\n * smb2_session_logoff() - handler for session log off request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0\n */\nint smb2_session_logoff(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\n\tksmbd_debug(SMB, \"request\\n\");\n\n\t/* setting CifsExiting here may race with start_tcp_sess */\n\tksmbd_conn_set_need_reconnect(work);\n\tksmbd_close_session_fds(work);\n\tksmbd_conn_wait_idle(conn);\n\n\tif (ksmbd_tree_conn_session_logoff(sess)) {\n\t\tstruct smb2_logoff_req *req = smb2_get_msg(work->request_buf);\n\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tksmbd_destroy_file_table(&sess->file_table);\n\tsess->state = SMB2_SESSION_EXPIRED;\n\n\tksmbd_free_user(sess->user);\n\tsess->user = NULL;\n\n\t/* let start_tcp_sess free connection info now */\n\tksmbd_conn_set_need_negotiate(work);\n\treturn 0;\n}\n\n/**\n * create_smb2_pipe() - create IPC pipe\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nstatic noinline int create_smb2_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_create_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_create_req *req = smb2_get_msg(work->request_buf);\n\tint id;\n\tint err;\n\tchar *name;\n\n\tname = smb_strndup_from_utf16(req->Buffer, le16_to_cpu(req->NameLength),\n\t\t\t\t      1, work->conn->local_nls);\n\tif (IS_ERR(name)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\terr = PTR_ERR(name);\n\t\tgoto out;\n\t}\n\n\tid = ksmbd_session_rpc_open(work->sess, name);\n\tif (id < 0) {\n\t\tpr_err(\"Unable to open RPC pipe: %d\\n\", id);\n\t\terr = id;\n\t\tgoto out;\n\t}\n\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->StructureSize = cpu_to_le16(89);\n\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(FILE_OPENED);\n\n\trsp->CreationTime = cpu_to_le64(0);\n\trsp->LastAccessTime = cpu_to_le64(0);\n\trsp->ChangeTime = cpu_to_le64(0);\n\trsp->AllocationSize = cpu_to_le64(0);\n\trsp->EndofFile = cpu_to_le64(0);\n\trsp->FileAttributes = FILE_ATTRIBUTE_NORMAL_LE;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFileId = id;\n\trsp->PersistentFileId = 0;\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\tkfree(name);\n\treturn 0;\n\nout:\n\tswitch (err) {\n\tcase -EINVAL:\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tbreak;\n\tcase -ENOSPC:\n\tcase -ENOMEM:\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tbreak;\n\t}\n\n\tif (!IS_ERR(name))\n\t\tkfree(name);\n\n\tsmb2_set_err_rsp(work);\n\treturn err;\n}\n\n/**\n * smb2_set_ea() - handler for setting extended attributes using set\n *\t\tinfo command\n * @eabuf:\tset info command buffer\n * @buf_len:\tset info command buffer length\n * @path:\tdentry path for get ea\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,\n\t\t       struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *attr_name = NULL, *value;\n\tint rc = 0;\n\tunsigned int next = 0;\n\n\tif (buf_len < sizeof(struct smb2_ea_info) + eabuf->EaNameLength +\n\t\t\tle16_to_cpu(eabuf->EaValueLength))\n\t\treturn -EINVAL;\n\n\tattr_name = kmalloc(XATTR_NAME_MAX + 1, GFP_KERNEL);\n\tif (!attr_name)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tif (!eabuf->EaNameLength)\n\t\t\tgoto next;\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"name : <%s>, name_len : %u, value_len : %u, next : %u\\n\",\n\t\t\t    eabuf->name, eabuf->EaNameLength,\n\t\t\t    le16_to_cpu(eabuf->EaValueLength),\n\t\t\t    le32_to_cpu(eabuf->NextEntryOffset));\n\n\t\tif (eabuf->EaNameLength >\n\t\t    (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(attr_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);\n\t\tmemcpy(&attr_name[XATTR_USER_PREFIX_LEN], eabuf->name,\n\t\t       eabuf->EaNameLength);\n\t\tattr_name[XATTR_USER_PREFIX_LEN + eabuf->EaNameLength] = '\\0';\n\t\tvalue = (char *)&eabuf->name + eabuf->EaNameLength + 1;\n\n\t\tif (!eabuf->EaValueLength) {\n\t\t\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t\t\t     path->dentry,\n\t\t\t\t\t\t     attr_name,\n\t\t\t\t\t\t     XATTR_USER_PREFIX_LEN +\n\t\t\t\t\t\t     eabuf->EaNameLength);\n\n\t\t\t/* delete the EA only when it exits */\n\t\t\tif (rc > 0) {\n\t\t\t\trc = ksmbd_vfs_remove_xattr(user_ns,\n\t\t\t\t\t\t\t    path->dentry,\n\t\t\t\t\t\t\t    attr_name);\n\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t\t    \"remove xattr failed(%d)\\n\",\n\t\t\t\t\t\t    rc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* if the EA doesn't exist, just do nothing. */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\t\tpath->dentry, attr_name, value,\n\t\t\t\t\t\tle16_to_cpu(eabuf->EaValueLength), 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"ksmbd_vfs_setxattr is failed(%d)\\n\",\n\t\t\t\t\t    rc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext:\n\t\tnext = le32_to_cpu(eabuf->NextEntryOffset);\n\t\tif (next == 0 || buf_len < next)\n\t\t\tbreak;\n\t\tbuf_len -= next;\n\t\teabuf = (struct smb2_ea_info *)((char *)eabuf + next);\n\t\tif (next < (u32)eabuf->EaNameLength + le16_to_cpu(eabuf->EaValueLength))\n\t\t\tbreak;\n\n\t} while (next != 0);\n\n\tkfree(attr_name);\n\treturn rc;\n}\n\nstatic noinline int smb2_set_stream_name_xattr(struct path *path,\n\t\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t\t       char *stream_name, int s_type)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tsize_t xattr_stream_size;\n\tchar *xattr_stream_name;\n\tint rc;\n\n\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t s_type);\n\tif (rc)\n\t\treturn rc;\n\n\tfp->stream.name = xattr_stream_name;\n\tfp->stream.size = xattr_stream_size;\n\n\t/* Check if there is stream prefix in xattr space */\n\trc = ksmbd_vfs_casexattr_len(user_ns,\n\t\t\t\t     path->dentry,\n\t\t\t\t     xattr_stream_name,\n\t\t\t\t     xattr_stream_size);\n\tif (rc >= 0)\n\t\treturn 0;\n\n\tif (fp->cdoption == FILE_OPEN_LE) {\n\t\tksmbd_debug(SMB, \"XATTR stream name lookup failed: %d\\n\", rc);\n\t\treturn -EBADF;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, path->dentry,\n\t\t\t\txattr_stream_name, NULL, 0, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR stream name :%d\\n\", rc);\n\treturn 0;\n}\n\nstatic int smb2_remove_smb_xattrs(struct path *path)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], DOS_ATTRIBUTE_PREFIX,\n\t\t\t    DOS_ATTRIBUTE_PREFIX_LEN) &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\terr = ksmbd_vfs_remove_xattr(user_ns, path->dentry, name);\n\t\tif (err)\n\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic int smb2_create_truncate(struct path *path)\n{\n\tint rc = vfs_truncate(path, 0);\n\n\tif (rc) {\n\t\tpr_err(\"vfs_truncate failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = smb2_remove_smb_xattrs(path);\n\tif (rc == -EOPNOTSUPP)\n\t\trc = 0;\n\tif (rc)\n\t\tksmbd_debug(SMB,\n\t\t\t    \"ksmbd_truncate_stream_name_xattr failed, rc %d\\n\",\n\t\t\t    rc);\n\treturn rc;\n}\n\nstatic void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, struct path *path,\n\t\t\t    struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da = {0};\n\tint rc;\n\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\tda.version = 4;\n\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\tda.itime = da.create_time = fp->create_time;\n\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\tXATTR_DOSINFO_ITIME;\n\n\trc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc)\n\t\tksmbd_debug(SMB, \"failed to store file attribute into xattr\\n\");\n}\n\nstatic void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,\n\t\t\t       struct path *path, struct ksmbd_file *fp)\n{\n\tstruct xattr_dos_attrib da;\n\tint rc;\n\n\tfp->f_ci->m_fattr &= ~(FILE_ATTRIBUTE_HIDDEN_LE | FILE_ATTRIBUTE_SYSTEM_LE);\n\n\t/* get FileAttributes from XATTR_NAME_DOS_ATTRIBUTE */\n\tif (!test_share_config_flag(tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))\n\t\treturn;\n\n\trc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),\n\t\t\t\t\t    path->dentry, &da);\n\tif (rc > 0) {\n\t\tfp->f_ci->m_fattr = cpu_to_le32(da.attr);\n\t\tfp->create_time = da.create_time;\n\t\tfp->itime = da.itime;\n\t}\n}\n\nstatic int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,\n\t\t      int open_flags, umode_t posix_mode, bool is_dir)\n{\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tumode_t mode;\n\tint rc;\n\n\tif (!(open_flags & O_CREAT))\n\t\treturn -EBADF;\n\n\tksmbd_debug(SMB, \"file does not exist, so creating\\n\");\n\tif (is_dir == true) {\n\t\tksmbd_debug(SMB, \"creating directory\\n\");\n\n\t\tmode = share_config_directory_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_mkdir(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tksmbd_debug(SMB, \"creating regular file\\n\");\n\n\t\tmode = share_config_create_mode(share, posix_mode);\n\t\trc = ksmbd_vfs_create(work, name, mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, 0, path, 0);\n\tif (rc) {\n\t\tpr_err(\"cannot get linux path (%s), err = %d\\n\",\n\t\t       name, rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int smb2_create_sd_buffer(struct ksmbd_work *work,\n\t\t\t\t struct smb2_create_req *req,\n\t\t\t\t struct path *path)\n{\n\tstruct create_context *context;\n\tstruct create_sd_buf_req *sd_buf;\n\n\tif (!req->CreateContextsOffset)\n\t\treturn -ENOENT;\n\n\t/* Parse SD BUFFER create contexts */\n\tcontext = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER);\n\tif (!context)\n\t\treturn -ENOENT;\n\telse if (IS_ERR(context))\n\t\treturn PTR_ERR(context);\n\n\tksmbd_debug(SMB,\n\t\t    \"Set ACLs using SMB2_CREATE_SD_BUFFER context\\n\");\n\tsd_buf = (struct create_sd_buf_req *)context;\n\tif (le16_to_cpu(context->DataOffset) +\n\t    le32_to_cpu(context->DataLength) <\n\t    sizeof(struct create_sd_buf_req))\n\t\treturn -EINVAL;\n\treturn set_info_sec(work->conn, work->tcon, path, &sd_buf->ntsd,\n\t\t\t    le32_to_cpu(sd_buf->ccontext.DataLength), true);\n}\n\nstatic void ksmbd_acls_fattr(struct smb_fattr *fattr,\n\t\t\t     struct user_namespace *mnt_userns,\n\t\t\t     struct inode *inode)\n{\n\tfattr->cf_uid = i_uid_into_mnt(mnt_userns, inode);\n\tfattr->cf_gid = i_gid_into_mnt(mnt_userns, inode);\n\tfattr->cf_mode = inode->i_mode;\n\tfattr->cf_acls = NULL;\n\tfattr->cf_dacls = NULL;\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tfattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tfattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);\n\t}\n}\n\n/**\n * smb2_open() - handler for smb file open request\n * @work:\tsmb work containing request buffer\n *\n * Return:      0 on success, otherwise error\n */\nint smb2_open(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct path path;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file *filp = NULL;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct kstat stat;\n\tstruct create_context *context;\n\tstruct lease_ctx_info *lc = NULL;\n\tstruct create_ea_buf_req *ea_buf = NULL;\n\tstruct oplock_info *opinfo;\n\t__le32 *next_ptr = NULL;\n\tint req_op_level = 0, open_flags = 0, may_flags = 0, file_info = 0;\n\tint rc = 0;\n\tint contxt_cnt = 0, query_disk_id = 0;\n\tint maximal_access_ctxt = 0, posix_ctxt = 0;\n\tint s_type = 0;\n\tint next_off = 0;\n\tchar *name = NULL;\n\tchar *stream_name = NULL;\n\tbool file_present = false, created = false, already_permitted = false;\n\tint share_ret, need_truncate = 0;\n\tu64 time;\n\tumode_t posix_mode = 0;\n\t__le32 daccess, maximal_access = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (req->hdr.NextCommand && !work->next_smb2_rcv_hdr_off &&\n\t    (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"invalid flag in chained command\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe create request\\n\");\n\t\treturn create_smb2_pipe(work);\n\t}\n\n\tif (req->NameLength) {\n\t\tif ((req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t\t    *(char *)req->Buffer == '\\\\') {\n\t\t\tpr_err(\"not allow directory name included leading slash\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tname = smb2_get_name(req->Buffer,\n\t\t\t\t     le16_to_cpu(req->NameLength),\n\t\t\t\t     work->conn->local_nls);\n\t\tif (IS_ERR(name)) {\n\t\t\trc = PTR_ERR(name);\n\t\t\tif (rc != -ENOMEM)\n\t\t\t\trc = -ENOENT;\n\t\t\tname = NULL;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"converted name = %s\\n\", name);\n\t\tif (strchr(name, ':')) {\n\t\t\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t    KSMBD_SHARE_FLAG_STREAMS)) {\n\t\t\t\trc = -EBADF;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\trc = parse_stream_name(name, &stream_name, &s_type);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_out1;\n\t\t}\n\n\t\trc = ksmbd_validate_filename(name);\n\t\tif (rc < 0)\n\t\t\tgoto err_out1;\n\n\t\tif (ksmbd_share_veto_filename(share, name)) {\n\t\t\trc = -ENOENT;\n\t\t\tksmbd_debug(SMB, \"Reject open(), vetoed file: %s\\n\",\n\t\t\t\t    name);\n\t\t\tgoto err_out1;\n\t\t}\n\t} else {\n\t\tname = kstrdup(\"\", GFP_KERNEL);\n\t\tif (!name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out1;\n\t\t}\n\t}\n\n\treq_op_level = req->RequestedOplockLevel;\n\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\n\t\tlc = parse_lease_state(req);\n\n\tif (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {\n\t\tpr_err(\"Invalid impersonationlevel : 0x%x\\n\",\n\t\t       le32_to_cpu(req->ImpersonationLevel));\n\t\trc = -EIO;\n\t\trsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {\n\t\tpr_err(\"Invalid create options : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateOptions));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t} else {\n\t\tif (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&\n\t\t    req->CreateOptions & FILE_RANDOM_ACCESS_LE)\n\t\t\treq->CreateOptions = ~(FILE_SEQUENTIAL_ONLY_LE);\n\n\t\tif (req->CreateOptions &\n\t\t    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |\n\t\t     FILE_RESERVE_OPFILTER_LE)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {\n\t\t\t\treq->CreateOptions = ~(FILE_NO_COMPRESSION_LE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (le32_to_cpu(req->CreateDisposition) >\n\t    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {\n\t\tpr_err(\"Invalid create disposition : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateDisposition));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {\n\t\tpr_err(\"Invalid desired access : 0x%x\\n\",\n\t\t       le32_to_cpu(req->DesiredAccess));\n\t\trc = -EACCES;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {\n\t\tpr_err(\"Invalid file attribute : 0x%x\\n\",\n\t\t       le32_to_cpu(req->FileAttributes));\n\t\trc = -EINVAL;\n\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\t/* Parse non-durable handle create contexts */\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tea_buf = (struct create_ea_buf_req *)context;\n\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t    sizeof(struct create_ea_buf_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\tif (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {\n\t\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"get query maximal access context\\n\");\n\t\t\tmaximal_access_ctxt = 1;\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_TIMEWARP_REQUEST);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get timewarp context\\n\");\n\t\t\trc = -EBADF;\n\t\t\tgoto err_out1;\n\t\t}\n\n\t\tif (tcon->posix_extensions) {\n\t\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t\t SMB2_CREATE_TAG_POSIX);\n\t\t\tif (IS_ERR(context)) {\n\t\t\t\trc = PTR_ERR(context);\n\t\t\t\tgoto err_out1;\n\t\t\t} else if (context) {\n\t\t\t\tstruct create_posix *posix =\n\t\t\t\t\t(struct create_posix *)context;\n\t\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t\t    sizeof(struct create_posix) - 4) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto err_out1;\n\t\t\t\t}\n\t\t\t\tksmbd_debug(SMB, \"get posix context\\n\");\n\n\t\t\t\tposix_mode = le32_to_cpu(posix->Mode);\n\t\t\t\tposix_ctxt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out1;\n\t}\n\n\trc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (!rc) {\n\t\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {\n\t\t\t/*\n\t\t\t * If file exists with under flags, return access\n\t\t\t * denied error.\n\t\t\t */\n\t\t\tif (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||\n\t\t\t    req->CreateDisposition == FILE_OPEN_IF_LE) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\t\trc = -EACCES;\n\t\t\t\tpath_put(&path);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else if (d_is_symlink(path.dentry)) {\n\t\t\trc = -EACCES;\n\t\t\tpath_put(&path);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto err_out;\n\t\tksmbd_debug(SMB, \"can not get linux path for %s, rc = %d\\n\",\n\t\t\t    name, rc);\n\t\trc = 0;\n\t} else {\n\t\tfile_present = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t}\n\tif (stream_name) {\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\t}\n\t\t} else {\n\t\t\tif (S_ISDIR(stat.mode) && s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\t\t}\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&\n\t\t    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {\n\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\trc = -EIO;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (file_present && req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE &&\n\t    S_ISDIR(stat.mode) && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\tksmbd_debug(SMB, \"open() argument is a directory: %s, %x\\n\",\n\t\t\t    name, req->CreateOptions);\n\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present && (req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t    !(req->CreateDisposition == FILE_CREATE_LE) &&\n\t    !S_ISDIR(stat.mode)) {\n\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!stream_name && file_present &&\n\t    req->CreateDisposition == FILE_CREATE_LE) {\n\t\trc = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tdaccess = smb_map_generic_desired_access(req->DesiredAccess);\n\n\tif (file_present && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\trc = smb_check_perm_dacl(conn, &path, &daccess,\n\t\t\t\t\t sess->user->uid);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (daccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tif (!file_present) {\n\t\t\tdaccess = cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\t} else {\n\t\t\trc = ksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t    &daccess);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t\talready_permitted = true;\n\t\t}\n\t\tmaximal_access = daccess;\n\t}\n\n\topen_flags = smb2_create_open_flags(file_present, daccess,\n\t\t\t\t\t    req->CreateDisposition,\n\t\t\t\t\t    &may_flags);\n\n\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tif (open_flags & O_CREAT) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t/*create file if not present */\n\tif (!file_present) {\n\t\trc = smb2_creat(work, &path, name, open_flags, posix_mode,\n\t\t\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcreated = true;\n\t\tuser_ns = mnt_user_ns(path.mnt);\n\t\tif (ea_buf) {\n\t\t\tif (le32_to_cpu(ea_buf->ccontext.DataLength) <\n\t\t\t    sizeof(struct smb2_ea_info)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\trc = smb2_set_ea(&ea_buf->ea,\n\t\t\t\t\t le32_to_cpu(ea_buf->ccontext.DataLength),\n\t\t\t\t\t &path);\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\trc = 0;\n\t\t\telse if (rc)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (!already_permitted) {\n\t\t/* FILE_READ_ATTRIBUTE is allowed without inode_permission,\n\t\t * because execute(search) permission on a parent directory,\n\t\t * is already granted.\n\t\t */\n\t\tif (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {\n\t\t\trc = inode_permission(user_ns,\n\t\t\t\t\t      d_inode(path.dentry),\n\t\t\t\t\t      may_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tif ((daccess & FILE_DELETE_LE) ||\n\t\t\t    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\t\t\trc = ksmbd_vfs_may_delete(user_ns,\n\t\t\t\t\t\t\t  path.dentry);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = ksmbd_query_inode_status(d_inode(path.dentry->d_parent));\n\tif (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\trc = 0;\n\tfilp = dentry_open(&path, open_flags, current_cred());\n\tif (IS_ERR(filp)) {\n\t\trc = PTR_ERR(filp);\n\t\tpr_err(\"dentry open for dir failed, rc %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (file_present) {\n\t\tif (!(open_flags & O_TRUNC))\n\t\t\tfile_info = FILE_OPENED;\n\t\telse\n\t\t\tfile_info = FILE_OVERWRITTEN;\n\n\t\tif ((req->CreateDisposition & FILE_CREATE_MASK_LE) ==\n\t\t    FILE_SUPERSEDE_LE)\n\t\t\tfile_info = FILE_SUPERSEDED;\n\t} else if (open_flags & O_CREAT) {\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tksmbd_vfs_set_fadvise(filp, req->CreateOptions);\n\n\t/* Obtain Volatile-ID */\n\tfp = ksmbd_open_fd(work, filp);\n\tif (IS_ERR(fp)) {\n\t\tfput(filp);\n\t\trc = PTR_ERR(fp);\n\t\tfp = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/* Get Persistent-ID */\n\tksmbd_open_durable_fd(fp);\n\tif (!has_file_id(fp->persistent_id)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfp->cdoption = req->CreateDisposition;\n\tfp->daccess = daccess;\n\tfp->saccess = req->ShareAccess;\n\tfp->coption = req->CreateOptions;\n\n\t/* Set default windows and posix acls if creating new file */\n\tif (created) {\n\t\tint posix_acl_rc;\n\t\tstruct inode *inode = d_inode(path.dentry);\n\n\t\tposix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,\n\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t   d_inode(path.dentry->d_parent));\n\t\tif (posix_acl_rc)\n\t\t\tksmbd_debug(SMB, \"inherit posix acl failed : %d\\n\", posix_acl_rc);\n\n\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\trc = smb_inherit_dacl(conn, &path, sess->user->uid,\n\t\t\t\t\t      sess->user->gid);\n\t\t}\n\n\t\tif (rc) {\n\t\t\trc = smb2_create_sd_buffer(work, req, &path);\n\t\t\tif (rc) {\n\t\t\t\tif (posix_acl_rc)\n\t\t\t\t\tksmbd_vfs_set_init_posix_acl(user_ns,\n\t\t\t\t\t\t\t\t     inode);\n\n\t\t\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\t\t\tstruct smb_fattr fattr;\n\t\t\t\t\tstruct smb_ntsd *pntsd;\n\t\t\t\t\tint pntsd_size, ace_num = 0;\n\n\t\t\t\t\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\t\t\t\t\tif (fattr.cf_acls)\n\t\t\t\t\t\tace_num = fattr.cf_acls->a_count;\n\t\t\t\t\tif (fattr.cf_dacls)\n\t\t\t\t\t\tace_num += fattr.cf_dacls->a_count;\n\n\t\t\t\t\tpntsd = kmalloc(sizeof(struct smb_ntsd) +\n\t\t\t\t\t\t\tsizeof(struct smb_sid) * 3 +\n\t\t\t\t\t\t\tsizeof(struct smb_acl) +\n\t\t\t\t\t\t\tsizeof(struct smb_ace) * ace_num * 2,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!pntsd)\n\t\t\t\t\t\tgoto err_out;\n\n\t\t\t\t\trc = build_sec_desc(user_ns,\n\t\t\t\t\t\t\t    pntsd, NULL, 0,\n\t\t\t\t\t\t\t    OWNER_SECINFO |\n\t\t\t\t\t\t\t    GROUP_SECINFO |\n\t\t\t\t\t\t\t    DACL_SECINFO,\n\t\t\t\t\t\t\t    &pntsd_size, &fattr);\n\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = ksmbd_vfs_set_sd_xattr(conn,\n\t\t\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t\t    pntsd,\n\t\t\t\t\t\t\t\t    pntsd_size);\n\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tpr_err(\"failed to store ntacl in xattr : %d\\n\",\n\t\t\t\t\t\t       rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\trc = smb2_set_stream_name_xattr(&path,\n\t\t\t\t\t\tfp,\n\t\t\t\t\t\tstream_name,\n\t\t\t\t\t\ts_type);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tfp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));\n\tif (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&\n\t    !fp->attrib_only && !stream_name) {\n\t\tsmb_break_all_oplock(work, fp);\n\t\tneed_truncate = 1;\n\t}\n\n\t/* fp should be searchable through ksmbd_inode.m_fp_list\n\t * after daccess, saccess, attrib_only, and stream are\n\t * initialized.\n\t */\n\twrite_lock(&fp->f_ci->m_lock);\n\tlist_add(&fp->node, &fp->f_ci->m_fp_list);\n\twrite_unlock(&fp->f_ci->m_lock);\n\n\trc = ksmbd_vfs_getattr(&path, &stat);\n\tif (rc) {\n\t\tgeneric_fillattr(user_ns, d_inode(path.dentry), &stat);\n\t\trc = 0;\n\t}\n\n\t/* Check delete pending among previous fp before oplock break */\n\tif (ksmbd_inode_pending_delete(fp)) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tshare_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);\n\tif (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||\n\t    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&\n\t     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {\n\t\tif (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\t\trc = share_ret;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) {\n\t\t\treq_op_level = smb2_map_lease_to_oplock(lc->req_state);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"lease req for(%s) req oplock state 0x%x, lease state 0x%x\\n\",\n\t\t\t\t    name, req_op_level, lc->req_state);\n\t\t\trc = find_same_lease_key(sess, fp->f_ci, lc);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\t\t} else if (open_flags == O_RDONLY &&\n\t\t\t   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t\trc = smb_grant_oplock(work, req_op_level,\n\t\t\t\t      fp->persistent_id, fp,\n\t\t\t\t      le32_to_cpu(req->hdr.Id.SyncId.TreeId),\n\t\t\t\t      lc, share_ret);\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)\n\t\tksmbd_fd_set_delete_on_close(fp, file_info);\n\n\tif (need_truncate) {\n\t\trc = smb2_create_truncate(&path);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\tstruct create_alloc_size_req *az_req;\n\n\t\taz_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,\n\t\t\t\t\tSMB2_CREATE_ALLOCATION_SIZE);\n\t\tif (IS_ERR(az_req)) {\n\t\t\trc = PTR_ERR(az_req);\n\t\t\tgoto err_out;\n\t\t} else if (az_req) {\n\t\t\tloff_t alloc_size;\n\t\t\tint err;\n\n\t\t\tif (le16_to_cpu(az_req->ccontext.DataOffset) +\n\t\t\t    le32_to_cpu(az_req->ccontext.DataLength) <\n\t\t\t    sizeof(struct create_alloc_size_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\talloc_size = le64_to_cpu(az_req->AllocationSize);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"request smb2 create allocate size : %llu\\n\",\n\t\t\t\t    alloc_size);\n\t\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\t\terr = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t\t    alloc_size);\n\t\t\tif (err < 0)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"vfs_fallocate is failed : %d\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get query on disk id context\\n\");\n\t\t\tquery_disk_id = 1;\n\t\t}\n\t}\n\n\tif (stat.result_mask & STATX_BTIME)\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.btime);\n\telse\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.ctime);\n\tif (req->FileAttributes || fp->f_ci->m_fattr == 0)\n\t\tfp->f_ci->m_fattr =\n\t\t\tcpu_to_le32(smb2_get_dos_mode(&stat, le32_to_cpu(req->FileAttributes)));\n\n\tif (!created)\n\t\tsmb2_update_xattrs(tcon, &path, fp);\n\telse\n\t\tsmb2_new_xattrs(tcon, &path, fp);\n\n\tmemcpy(fp->client_guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\n\tgeneric_fillattr(user_ns, file_inode(fp->filp),\n\t\t\t &stat);\n\n\trsp->StructureSize = cpu_to_le16(89);\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;\n\trcu_read_unlock();\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(file_info);\n\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\trsp->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\trsp->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\trsp->ChangeTime = cpu_to_le64(time);\n\trsp->AllocationSize = S_ISDIR(stat.mode) ? 0 :\n\t\tcpu_to_le64(stat.blocks << 9);\n\trsp->EndofFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\trsp->FileAttributes = fp->f_ci->m_fattr;\n\n\trsp->Reserved2 = 0;\n\n\trsp->PersistentFileId = fp->persistent_id;\n\trsp->VolatileFileId = fp->volatile_id;\n\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\tinc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/\n\n\t/* If lease is request send lease context response */\n\tif (opinfo && opinfo->is_lease) {\n\t\tstruct create_context *lease_ccontext;\n\n\t\tksmbd_debug(SMB, \"lease granted on(%s) lease state 0x%x\\n\",\n\t\t\t    name, opinfo->o_lease->state);\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\n\t\tlease_ccontext = (struct create_context *)rsp->Buffer;\n\t\tcontxt_cnt++;\n\t\tcreate_lease_buf(rsp->Buffer, opinfo->o_lease);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_lease_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_lease_size);\n\t\tnext_ptr = &lease_ccontext->Next;\n\t\tnext_off = conn->vals->create_lease_size;\n\t}\n\n\tif (maximal_access_ctxt) {\n\t\tstruct create_context *mxac_ccontext;\n\n\t\tif (maximal_access == 0)\n\t\t\tksmbd_vfs_query_maximal_access(user_ns,\n\t\t\t\t\t\t       path.dentry,\n\t\t\t\t\t\t       &maximal_access);\n\t\tmxac_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_mxac_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tle32_to_cpu(maximal_access));\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_mxac_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_mxac_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &mxac_ccontext->Next;\n\t\tnext_off = conn->vals->create_mxac_size;\n\t}\n\n\tif (query_disk_id) {\n\t\tstruct create_context *disk_id_ccontext;\n\n\t\tdisk_id_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_disk_id_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tstat.ino, tcon->id);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_disk_id_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_disk_id_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &disk_id_ccontext->Next;\n\t\tnext_off = conn->vals->create_disk_id_size;\n\t}\n\n\tif (posix_ctxt) {\n\t\tcontxt_cnt++;\n\t\tcreate_posix_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tfp);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_posix_size);\n\t\tinc_rfc1001_len(work->response_buf,\n\t\t\t\tconn->vals->create_posix_size);\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t}\n\n\tif (contxt_cnt > 0) {\n\t\trsp->CreateContextsOffset =\n\t\t\tcpu_to_le32(offsetof(struct smb2_create_rsp, Buffer));\n\t}\n\nerr_out:\n\tif (file_present || created)\n\t\tpath_put(&path);\n\tksmbd_revert_fsids(work);\nerr_out1:\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (rc == -EOPNOTSUPP)\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\telse if (rc == -EACCES || rc == -ESTALE || rc == -EXDEV)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\t\telse if (rc == -EPERM)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (rc == -EBUSY)\n\t\t\trsp->hdr.Status = STATUS_DELETE_PENDING;\n\t\telse if (rc == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\telse if (rc == -ENOEXEC)\n\t\t\trsp->hdr.Status = STATUS_DUPLICATE_OBJECTID;\n\t\telse if (rc == -ENXIO)\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_DEVICE;\n\t\telse if (rc == -EEXIST)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\t\telse if (rc == -EMFILE)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\tif (!rsp->hdr.Status)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\t\tif (fp)\n\t\t\tksmbd_fd_put(work, fp);\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_debug(SMB, \"Error response: %x\\n\", rsp->hdr.Status);\n\t}\n\n\tkfree(name);\n\tkfree(lc);\n\n\treturn 0;\n}\n\nstatic int readdir_info_level_struct_sz(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_full_directory_info);\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_both_directory_info);\n\tcase FILE_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_directory_info);\n\tcase FILE_NAMES_INFORMATION:\n\t\treturn sizeof(struct file_names_info);\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_full_dir_info);\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t\treturn sizeof(struct file_id_both_directory_info);\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\treturn sizeof(struct smb2_posix_info);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dentry_name(struct ksmbd_dir_info *d_info, int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(ffdinfo->NextEntryOffset);\n\t\td_info->name = ffdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(ffdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fbdinfo->NextEntryOffset);\n\t\td_info->name = fbdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fbdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fdinfo->NextEntryOffset);\n\t\td_info->name = fdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fninfo->NextEntryOffset);\n\t\td_info->name = fninfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fninfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(dinfo->NextEntryOffset);\n\t\td_info->name = dinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(dinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(fibdinfo->NextEntryOffset);\n\t\td_info->name = fibdinfo->FileName;\n\t\td_info->name_len = le32_to_cpu(fibdinfo->FileNameLength);\n\t\treturn 0;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->rptr;\n\t\td_info->rptr += le32_to_cpu(posix_info->NextEntryOffset);\n\t\td_info->name = posix_info->name;\n\t\td_info->name_len = le32_to_cpu(posix_info->name_len);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * smb2_populate_readdir_entry() - encode directory entry in smb2 response\n * buffer\n * @conn:\tconnection instance\n * @info_level:\tsmb information level\n * @d_info:\tstructure included variables for query dir\n * @ksmbd_kstat:\tksmbd wrapper of dirent stat information\n *\n * if directory has many entries, find first can't read it fully.\n * find next might be called multiple times to read remaining dir entries\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,\n\t\t\t\t       struct ksmbd_dir_info *d_info,\n\t\t\t\t       struct ksmbd_kstat *ksmbd_kstat)\n{\n\tint next_entry_offset = 0;\n\tchar *conv_name;\n\tint conv_len;\n\tvoid *kstat;\n\tint struct_sz, rc = 0;\n\n\tconv_name = ksmbd_convert_dir_info_name(d_info,\n\t\t\t\t\t\tconn->local_nls,\n\t\t\t\t\t\t&conv_len);\n\tif (!conv_name)\n\t\treturn -ENOMEM;\n\n\t/* Somehow the name has only terminating NULL bytes */\n\tif (conv_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto free_conv_name;\n\t}\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level) - 1 + conv_len;\n\tnext_entry_offset = ALIGN(struct_sz, KSMBD_DIR_INFO_ALIGNMENT);\n\td_info->last_entry_off_align = next_entry_offset - struct_sz;\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\trc = -ENOSPC;\n\t\tgoto free_conv_name;\n\t}\n\n\tkstat = d_info->wptr;\n\tif (info_level != FILE_NAMES_INFORMATION)\n\t\tkstat = ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)kstat;\n\t\tffdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tffdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (ffdinfo->EaSize)\n\t\t\tffdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tffdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(ffdinfo->FileName, conv_name, conv_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)kstat;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfbdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fbdinfo->EaSize)\n\t\t\tfbdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfbdinfo->ShortNameLength = 0;\n\t\tfbdinfo->Reserved = 0;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfbdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fbdinfo->FileName, conv_name, conv_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)kstat;\n\t\tfdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fdinfo->FileName, conv_name, conv_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)kstat;\n\t\tfninfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tmemcpy(fninfo->FileName, conv_name, conv_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)kstat;\n\t\tdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (dinfo->EaSize)\n\t\t\tdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tdinfo->Reserved = 0;\n\t\tdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(dinfo->FileName, conv_name, conv_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)kstat;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(conv_len);\n\t\tfibdinfo->EaSize =\n\t\t\tsmb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);\n\t\tif (fibdinfo->EaSize)\n\t\t\tfibdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;\n\t\tfibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tfibdinfo->ShortNameLength = 0;\n\t\tfibdinfo->Reserved = 0;\n\t\tfibdinfo->Reserved2 = cpu_to_le16(0);\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tfibdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tmemcpy(fibdinfo->FileName, conv_name, conv_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\t\tu64 time;\n\n\t\tposix_info = (struct smb2_posix_info *)kstat;\n\t\tposix_info->Ignored = 0;\n\t\tposix_info->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\t\tposix_info->ChangeTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->atime);\n\t\tposix_info->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->mtime);\n\t\tposix_info->LastWriteTime = cpu_to_le64(time);\n\t\tposix_info->EndOfFile = cpu_to_le64(ksmbd_kstat->kstat->size);\n\t\tposix_info->AllocationSize = cpu_to_le64(ksmbd_kstat->kstat->blocks << 9);\n\t\tposix_info->DeviceId = cpu_to_le32(ksmbd_kstat->kstat->rdev);\n\t\tposix_info->HardLinks = cpu_to_le32(ksmbd_kstat->kstat->nlink);\n\t\tposix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode);\n\t\tposix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);\n\t\tposix_info->DosAttributes =\n\t\t\tS_ISDIR(ksmbd_kstat->kstat->mode) ?\n\t\t\t\tFILE_ATTRIBUTE_DIRECTORY_LE : FILE_ATTRIBUTE_ARCHIVE_LE;\n\t\tif (d_info->hide_dot_file && d_info->name[0] == '.')\n\t\t\tposix_info->DosAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;\n\t\tid_to_sid(from_kuid_munged(&init_user_ns, ksmbd_kstat->kstat->uid),\n\t\t\t  SIDNFS_USER, (struct smb_sid *)&posix_info->SidBuffer[0]);\n\t\tid_to_sid(from_kgid_munged(&init_user_ns, ksmbd_kstat->kstat->gid),\n\t\t\t  SIDNFS_GROUP, (struct smb_sid *)&posix_info->SidBuffer[20]);\n\t\tmemcpy(posix_info->name, conv_name, conv_len);\n\t\tposix_info->name_len = cpu_to_le32(conv_len);\n\t\tposix_info->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\n\t} /* switch (info_level) */\n\n\td_info->last_entry_offset = d_info->data_count;\n\td_info->data_count += next_entry_offset;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\n\tksmbd_debug(SMB,\n\t\t    \"info_level : %d, buf_len :%d, next_offset : %d, data_count : %d\\n\",\n\t\t    info_level, d_info->out_buf_len,\n\t\t    next_entry_offset, d_info->data_count);\n\nfree_conv_name:\n\tkfree(conv_name);\n\treturn rc;\n}\n\nstruct smb2_query_dir_private {\n\tstruct ksmbd_work\t*work;\n\tchar\t\t\t*search_pattern;\n\tstruct ksmbd_file\t*dir_fp;\n\n\tstruct ksmbd_dir_info\t*d_info;\n\tint\t\t\tinfo_level;\n};\n\nstatic void lock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n}\n\nstatic void unlock_dir(struct ksmbd_file *dir_fp)\n{\n\tstruct dentry *dir = dir_fp->filp->f_path.dentry;\n\n\tinode_unlock(d_inode(dir));\n}\n\nstatic int process_query_dir_entries(struct smb2_query_dir_private *priv)\n{\n\tstruct user_namespace\t*user_ns = file_mnt_user_ns(priv->dir_fp->filp);\n\tstruct kstat\t\tkstat;\n\tstruct ksmbd_kstat\tksmbd_kstat;\n\tint\t\t\trc;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < priv->d_info->num_entry; i++) {\n\t\tstruct dentry *dent;\n\n\t\tif (dentry_name(priv->d_info, priv->info_level))\n\t\t\treturn -EINVAL;\n\n\t\tlock_dir(priv->dir_fp);\n\t\tdent = lookup_one(user_ns, priv->d_info->name,\n\t\t\t\t  priv->dir_fp->filp->f_path.dentry,\n\t\t\t\t  priv->d_info->name_len);\n\t\tunlock_dir(priv->dir_fp);\n\n\t\tif (IS_ERR(dent)) {\n\t\t\tksmbd_debug(SMB, \"Cannot lookup `%s' [%ld]\\n\",\n\t\t\t\t    priv->d_info->name,\n\t\t\t\t    PTR_ERR(dent));\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(d_is_negative(dent))) {\n\t\t\tdput(dent);\n\t\t\tksmbd_debug(SMB, \"Negative dentry `%s'\\n\",\n\t\t\t\t    priv->d_info->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tksmbd_kstat.kstat = &kstat;\n\t\tif (priv->info_level != FILE_NAMES_INFORMATION)\n\t\t\tksmbd_vfs_fill_dentry_attrs(priv->work,\n\t\t\t\t\t\t    user_ns,\n\t\t\t\t\t\t    dent,\n\t\t\t\t\t\t    &ksmbd_kstat);\n\n\t\trc = smb2_populate_readdir_entry(priv->work->conn,\n\t\t\t\t\t\t priv->info_level,\n\t\t\t\t\t\t priv->d_info,\n\t\t\t\t\t\t &ksmbd_kstat);\n\t\tdput(dent);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int reserve_populate_dentry(struct ksmbd_dir_info *d_info,\n\t\t\t\t   int info_level)\n{\n\tint struct_sz;\n\tint conv_len;\n\tint next_entry_offset;\n\n\tstruct_sz = readdir_info_level_struct_sz(info_level);\n\tif (struct_sz == -EOPNOTSUPP)\n\t\treturn -EOPNOTSUPP;\n\n\tconv_len = (d_info->name_len + 1) * 2;\n\tnext_entry_offset = ALIGN(struct_sz - 1 + conv_len,\n\t\t\t\t  KSMBD_DIR_INFO_ALIGNMENT);\n\n\tif (next_entry_offset > d_info->out_buf_len) {\n\t\td_info->out_buf_len = 0;\n\t\treturn -ENOSPC;\n\t}\n\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_full_directory_info *ffdinfo;\n\n\t\tffdinfo = (struct file_full_directory_info *)d_info->wptr;\n\t\tmemcpy(ffdinfo->FileName, d_info->name, d_info->name_len);\n\t\tffdinfo->FileName[d_info->name_len] = 0x00;\n\t\tffdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_both_directory_info *fbdinfo;\n\n\t\tfbdinfo = (struct file_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fbdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfbdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfbdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_directory_info *fdinfo;\n\n\t\tfdinfo = (struct file_directory_info *)d_info->wptr;\n\t\tmemcpy(fdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILE_NAMES_INFORMATION:\n\t{\n\t\tstruct file_names_info *fninfo;\n\n\t\tfninfo = (struct file_names_info *)d_info->wptr;\n\t\tmemcpy(fninfo->FileName, d_info->name, d_info->name_len);\n\t\tfninfo->FileName[d_info->name_len] = 0x00;\n\t\tfninfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_full_dir_info *dinfo;\n\n\t\tdinfo = (struct file_id_full_dir_info *)d_info->wptr;\n\t\tmemcpy(dinfo->FileName, d_info->name, d_info->name_len);\n\t\tdinfo->FileName[d_info->name_len] = 0x00;\n\t\tdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\t{\n\t\tstruct file_id_both_directory_info *fibdinfo;\n\n\t\tfibdinfo = (struct file_id_both_directory_info *)d_info->wptr;\n\t\tmemcpy(fibdinfo->FileName, d_info->name, d_info->name_len);\n\t\tfibdinfo->FileName[d_info->name_len] = 0x00;\n\t\tfibdinfo->FileNameLength = cpu_to_le32(d_info->name_len);\n\t\tfibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t{\n\t\tstruct smb2_posix_info *posix_info;\n\n\t\tposix_info = (struct smb2_posix_info *)d_info->wptr;\n\t\tmemcpy(posix_info->name, d_info->name, d_info->name_len);\n\t\tposix_info->name[d_info->name_len] = 0x00;\n\t\tposix_info->name_len = cpu_to_le32(d_info->name_len);\n\t\tposix_info->NextEntryOffset =\n\t\t\tcpu_to_le32(next_entry_offset);\n\t\tbreak;\n\t}\n\t} /* switch (info_level) */\n\n\td_info->num_entry++;\n\td_info->out_buf_len -= next_entry_offset;\n\td_info->wptr += next_entry_offset;\n\treturn 0;\n}\n\nstatic int __query_dir(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data\t*buf;\n\tstruct smb2_query_dir_private\t*priv;\n\tstruct ksmbd_dir_info\t\t*d_info;\n\tint\t\t\t\trc;\n\n\tbuf\t= container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tpriv\t= buf->private;\n\td_info\t= priv->d_info;\n\n\t/* dot and dotdot entries are already reserved */\n\tif (!strcmp(\".\", name) || !strcmp(\"..\", name))\n\t\treturn 0;\n\tif (ksmbd_share_veto_filename(priv->work->tcon->share_conf, name))\n\t\treturn 0;\n\tif (!match_pattern(name, namlen, priv->search_pattern))\n\t\treturn 0;\n\n\td_info->name\t\t= name;\n\td_info->name_len\t= namlen;\n\trc = reserve_populate_dentry(d_info, priv->info_level);\n\tif (rc)\n\t\treturn rc;\n\tif (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {\n\t\td_info->out_buf_len = 0;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void restart_ctx(struct dir_context *ctx)\n{\n\tctx->pos = 0;\n}\n\nstatic int verify_info_level(int info_level)\n{\n\tswitch (info_level) {\n\tcase FILE_FULL_DIRECTORY_INFORMATION:\n\tcase FILE_BOTH_DIRECTORY_INFORMATION:\n\tcase FILE_DIRECTORY_INFORMATION:\n\tcase FILE_NAMES_INFORMATION:\n\tcase FILEID_FULL_DIRECTORY_INFORMATION:\n\tcase FILEID_BOTH_DIRECTORY_INFORMATION:\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n{\n\tint free_len;\n\n\tfree_len = (int)(work->response_sz -\n\t\t(get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;\n\treturn free_len;\n}\n\nstatic int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = smb2_resp_buf_len(work, hdr2_len);\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}\n\nint smb2_query_dir(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tstruct ksmbd_file *dir_fp = NULL;\n\tstruct ksmbd_dir_info d_info;\n\tint rc = 0;\n\tchar *srch_ptr = NULL;\n\tunsigned char srch_flag;\n\tint buffer_sz;\n\tstruct smb2_query_dir_private query_dir_private = {NULL, };\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = verify_info_level(req->FileInformationClass);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto err_out2;\n\t}\n\n\tdir_fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!dir_fp) {\n\t\trc = -EBADF;\n\t\tgoto err_out2;\n\t}\n\n\tif (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||\n\t    inode_permission(file_mnt_user_ns(dir_fp->filp),\n\t\t\t     file_inode(dir_fp->filp),\n\t\t\t     MAY_READ | MAY_EXEC)) {\n\t\tpr_err(\"no right to enumerate directory (%pd)\\n\",\n\t\t       dir_fp->filp->f_path.dentry);\n\t\trc = -EACCES;\n\t\tgoto err_out2;\n\t}\n\n\tif (!S_ISDIR(file_inode(dir_fp->filp)->i_mode)) {\n\t\tpr_err(\"can't do query dir for a file\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tsrch_flag = req->Flags;\n\tsrch_ptr = smb_strndup_from_utf16(req->Buffer,\n\t\t\t\t\t  le16_to_cpu(req->FileNameLength), 1,\n\t\t\t\t\t  conn->local_nls);\n\tif (IS_ERR(srch_ptr)) {\n\t\tksmbd_debug(SMB, \"Search Pattern not found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t} else {\n\t\tksmbd_debug(SMB, \"Search pattern is %s\\n\", srch_ptr);\n\t}\n\n\tif (srch_flag & SMB2_REOPEN || srch_flag & SMB2_RESTART_SCANS) {\n\t\tksmbd_debug(SMB, \"Restart directory scan\\n\");\n\t\tgeneric_file_llseek(dir_fp->filp, 0, SEEK_SET);\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\t}\n\n\tmemset(&d_info, 0, sizeof(struct ksmbd_dir_info));\n\td_info.wptr = (char *)rsp->Buffer;\n\td_info.rptr = (char *)rsp->Buffer;\n\td_info.out_buf_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (d_info.out_buf_len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\td_info.flags = srch_flag;\n\n\t/*\n\t * reserve dot and dotdot entries in head of buffer\n\t * in first response\n\t */\n\trc = ksmbd_populate_dot_dotdot_entries(work, req->FileInformationClass,\n\t\t\t\t\t       dir_fp, &d_info, srch_ptr,\n\t\t\t\t\t       smb2_populate_readdir_entry);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\telse if (rc)\n\t\tgoto err_out;\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_HIDE_DOT_FILES))\n\t\td_info.hide_dot_file = true;\n\n\tbuffer_sz\t\t\t\t= d_info.out_buf_len;\n\td_info.rptr\t\t\t\t= d_info.wptr;\n\tquery_dir_private.work\t\t\t= work;\n\tquery_dir_private.search_pattern\t= srch_ptr;\n\tquery_dir_private.dir_fp\t\t= dir_fp;\n\tquery_dir_private.d_info\t\t= &d_info;\n\tquery_dir_private.info_level\t\t= req->FileInformationClass;\n\tdir_fp->readdir_data.private\t\t= &query_dir_private;\n\tset_ctx_actor(&dir_fp->readdir_data.ctx, __query_dir);\n\n\trc = iterate_dir(dir_fp->filp, &dir_fp->readdir_data.ctx);\n\t/*\n\t * req->OutputBufferLength is too small to contain even one entry.\n\t * In this case, it immediately returns OutputBufferLength 0 to client.\n\t */\n\tif (!d_info.out_buf_len && !d_info.num_entry)\n\t\tgoto no_buf_len;\n\tif (rc == 0)\n\t\trestart_ctx(&dir_fp->readdir_data.ctx);\n\tif (rc == -ENOSPC)\n\t\trc = 0;\n\tif (rc)\n\t\tgoto err_out;\n\n\td_info.wptr = d_info.rptr;\n\td_info.out_buf_len = buffer_sz;\n\trc = process_query_dir_entries(&query_dir_private);\n\tif (rc)\n\t\tgoto err_out;\n\n\tif (!d_info.data_count && d_info.out_buf_len >= 0) {\n\t\tif (srch_flag & SMB2_RETURN_SINGLE_ENTRY && !is_asterisk(srch_ptr)) {\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\t\t} else {\n\t\t\tdir_fp->dot_dotdot[0] = dir_fp->dot_dotdot[1] = 0;\n\t\t\trsp->hdr.Status = STATUS_NO_MORE_FILES;\n\t\t}\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(0);\n\t\trsp->OutputBufferLength = cpu_to_le32(0);\n\t\trsp->Buffer[0] = 0;\n\t\tinc_rfc1001_len(work->response_buf, 9);\n\t} else {\nno_buf_len:\n\t\t((struct file_directory_info *)\n\t\t((char *)rsp->Buffer + d_info.last_entry_offset))\n\t\t->NextEntryOffset = 0;\n\t\tif (d_info.data_count >= d_info.last_entry_off_align)\n\t\t\td_info.data_count -= d_info.last_entry_off_align;\n\n\t\trsp->StructureSize = cpu_to_le16(9);\n\t\trsp->OutputBufferOffset = cpu_to_le16(72);\n\t\trsp->OutputBufferLength = cpu_to_le32(d_info.data_count);\n\t\tinc_rfc1001_len(work->response_buf, 8 + d_info.data_count);\n\t}\n\n\tkfree(srch_ptr);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n\nerr_out:\n\tpr_err(\"error while processing smb2 query dir rc = %d\\n\", rc);\n\tkfree(srch_ptr);\n\nerr_out2:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_NO_SUCH_FILE;\n\telse if (rc == -EBADF)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_NO_MEMORY;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tif (!rsp->hdr.Status)\n\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, dir_fp);\n\tksmbd_revert_fsids(work);\n\treturn 0;\n}\n\n/**\n * buffer_check_err() - helper function to check buffer errors\n * @reqOutputBufferLength:\tmax buffer length expected in command response\n * @rsp:\t\tquery info response buffer contains output buffer length\n * @rsp_org:\t\tbase response buffer pointer in case of chained response\n * @infoclass_size:\tquery info class response buffer size\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int buffer_check_err(int reqOutputBufferLength,\n\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t    void *rsp_org, int infoclass_size)\n{\n\tif (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {\n\t\tif (reqOutputBufferLength < infoclass_size) {\n\t\t\tpr_err(\"Invalid Buffer Size Requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;\n\t\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"Buffer Overflow\\n\");\n\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr) +\n\t\t\t\treqOutputBufferLength);\n\t\trsp->OutputBufferLength = cpu_to_le32(reqOutputBufferLength);\n\t}\n\treturn 0;\n}\n\nstatic void get_standard_info_pipe(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\n\tsinfo->AllocationSize = cpu_to_le64(4096);\n\tsinfo->EndOfFile = cpu_to_le64(0);\n\tsinfo->NumberOfLinks = cpu_to_le32(1);\n\tsinfo->DeletePending = 1;\n\tsinfo->Directory = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,\n\t\t\t\t   void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\n\t/* any unique number */\n\tfile_info->IndexNumber = cpu_to_le64(num | (1ULL << 63));\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int smb2_get_info_file_pipe(struct ksmbd_session *sess,\n\t\t\t\t   struct smb2_query_info_req *req,\n\t\t\t\t   struct smb2_query_info_rsp *rsp,\n\t\t\t\t   void *rsp_org)\n{\n\tu64 id;\n\tint rc;\n\n\t/*\n\t * Windows can sometime send query file info request on\n\t * pipe without opening it, checking error condition here\n\t */\n\tid = req->VolatileFileId;\n\tif (!ksmbd_session_rpc_method(sess, id))\n\t\treturn -ENOENT;\n\n\tksmbd_debug(SMB, \"FileInfoClass %u, FileId 0x%llx\\n\",\n\t\t    req->FileInfoClass, req->VolatileFileId);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_standard_info_pipe(rsp, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_STANDARD_INFORMATION_SIZE);\n\t\tbreak;\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_internal_info_pipe(rsp, id, rsp_org);\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, rsp_org,\n\t\t\t\t      FILE_INTERNAL_INFORMATION_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"smb2_info_file_pipe for %u not supported\\n\",\n\t\t\t    req->FileInfoClass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/**\n * smb2_get_ea() - handler for smb2 get extended attribute command\n * @work:\tsmb work containing query info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\tget extended attribute request\n * @rsp:\tresponse buffer pointer\n * @rsp_org:\tbase response buffer pointer in case of chained response\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t       struct smb2_query_info_req *req,\n\t\t       struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_ea_info *eainfo, *prev_eainfo;\n\tchar *name, *ptr, *xattr_list = NULL, *buf;\n\tint rc, name_len, value_len, xattr_list_len, idx;\n\tssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;\n\tstruct smb2_ea_info_req *ea_req = NULL;\n\tstruct path *path;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\n\tif (!(fp->daccess & FILE_READ_EA_LE)) {\n\t\tpr_err(\"Not permitted to read ext attr : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tpath = &fp->filp->f_path;\n\t/* single EA entry is requested with given user.* name */\n\tif (req->InputBufferLength) {\n\t\tif (le32_to_cpu(req->InputBufferLength) <\n\t\t    sizeof(struct smb2_ea_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tea_req = (struct smb2_ea_info_req *)req->Buffer;\n\t} else {\n\t\t/* need to send all EAs, if no specific EA is requested*/\n\t\tif (le32_to_cpu(req->Flags) & SL_RETURN_SINGLE_ENTRY)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"All EAs are requested but need to send single EA entry in rsp flags 0x%x\\n\",\n\t\t\t\t    le32_to_cpu(req->Flags));\n\t}\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\treturn -EINVAL;\n\n\trc = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (rc < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tgoto out;\n\t} else if (!rc) { /* there is no EA in the file */\n\t\tksmbd_debug(SMB, \"no ea data in the file\\n\");\n\t\tgoto done;\n\t}\n\txattr_list_len = rc;\n\n\tptr = (char *)rsp->Buffer;\n\teainfo = (struct smb2_ea_info *)ptr;\n\tprev_eainfo = eainfo;\n\tidx = 0;\n\n\twhile (idx < xattr_list_len) {\n\t\tname = xattr_list + idx;\n\t\tname_len = strlen(name);\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", name, name_len);\n\t\tidx += name_len + 1;\n\n\t\t/*\n\t\t * CIFS does not support EA other than user.* namespace,\n\t\t * still keep the framework generic, to list other attrs\n\t\t * in future.\n\t\t */\n\t\tif (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,\n\t\t\t     STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (req->InputBufferLength &&\n\t\t    strncmp(&name[XATTR_USER_PREFIX_LEN], ea_req->name,\n\t\t\t    ea_req->EaNameLength))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(&name[XATTR_USER_PREFIX_LEN],\n\t\t\t     DOS_ATTRIBUTE_PREFIX, DOS_ATTRIBUTE_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tname_len -= XATTR_USER_PREFIX_LEN;\n\n\t\tptr = (char *)(&eainfo->name + name_len + 1);\n\t\tbuf_free_len -= (offsetof(struct smb2_ea_info, name) +\n\t\t\t\tname_len + 1);\n\t\t/* bailout if xattr can't fit in buf_free_len */\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns, path->dentry,\n\t\t\t\t\t       name, &buf);\n\t\tif (value_len <= 0) {\n\t\t\trc = -ENOENT;\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_free_len -= value_len;\n\t\tif (buf_free_len < 0) {\n\t\t\tkfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(ptr, buf, value_len);\n\t\tkfree(buf);\n\n\t\tptr += value_len;\n\t\teainfo->Flags = 0;\n\t\teainfo->EaNameLength = name_len;\n\n\t\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n\t\t\tmemcpy(eainfo->name, &name[XATTR_USER_PREFIX_LEN],\n\t\t\t       name_len);\n\t\telse\n\t\t\tmemcpy(eainfo->name, name, name_len);\n\n\t\teainfo->name[name_len] = '\\0';\n\t\teainfo->EaValueLength = cpu_to_le16(value_len);\n\t\tnext_offset = offsetof(struct smb2_ea_info, name) +\n\t\t\tname_len + 1 + value_len;\n\n\t\t/* align next xattr entry at 4 byte bundary */\n\t\talignment_bytes = ((next_offset + 3) & ~3) - next_offset;\n\t\tif (alignment_bytes) {\n\t\t\tmemset(ptr, '\\0', alignment_bytes);\n\t\t\tptr += alignment_bytes;\n\t\t\tnext_offset += alignment_bytes;\n\t\t\tbuf_free_len -= alignment_bytes;\n\t\t}\n\t\teainfo->NextEntryOffset = cpu_to_le32(next_offset);\n\t\tprev_eainfo = eainfo;\n\t\teainfo = (struct smb2_ea_info *)ptr;\n\t\trsp_data_cnt += next_offset;\n\n\t\tif (req->InputBufferLength) {\n\t\t\tksmbd_debug(SMB, \"single entry requested\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no more ea entries */\n\tprev_eainfo->NextEntryOffset = 0;\ndone:\n\trc = 0;\n\tif (rsp_data_cnt == 0)\n\t\trsp->hdr.Status = STATUS_NO_EAS_ON_FILE;\n\trsp->OutputBufferLength = cpu_to_le32(rsp_data_cnt);\n\tinc_rfc1001_len(rsp_org, rsp_data_cnt);\nout:\n\tkvfree(xattr_list);\n\treturn rc;\n}\n\nstatic void get_file_access_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_access_info *file_info;\n\n\tfile_info = (struct smb2_file_access_info *)rsp->Buffer;\n\tfile_info->AccessFlags = fp->daccess;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_access_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_access_info));\n}\n\nstatic int get_file_basic_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_basic_info *basic_info;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tbasic_info = (struct smb2_file_basic_info *)rsp->Buffer;\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tbasic_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tbasic_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tbasic_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tbasic_info->ChangeTime = cpu_to_le64(time);\n\tbasic_info->Attributes = fp->f_ci->m_fattr;\n\tbasic_info->Pad1 = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_basic_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_basic_info));\n\treturn 0;\n}\n\nstatic unsigned long long get_allocation_size(struct inode *inode,\n\t\t\t\t\t      struct kstat *stat)\n{\n\tunsigned long long alloc_size = 0;\n\n\tif (!S_ISDIR(stat->mode)) {\n\t\tif ((inode->i_blocks << 9) <= stat->size)\n\t\t\talloc_size = stat->size;\n\t\telse\n\t\t\talloc_size = inode->i_blocks << 9;\n\t}\n\n\treturn alloc_size;\n}\n\nstatic void get_file_standard_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_standard_info *sinfo;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\n\tsinfo->AllocationSize = cpu_to_le64(get_allocation_size(inode, &stat));\n\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tsinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);\n\tsinfo->DeletePending = delete_pending;\n\tsinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_standard_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_standard_info));\n}\n\nstatic void get_file_alignment_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct smb2_file_alignment_info *file_info;\n\n\tfile_info = (struct smb2_file_alignment_info *)rsp->Buffer;\n\tfile_info->AlignmentRequirement = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alignment_info));\n\tinc_rfc1001_len(rsp_org,\n\t\t\tsizeof(struct smb2_file_alignment_info));\n}\n\nstatic int get_file_all_info(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_rsp *rsp,\n\t\t\t     struct ksmbd_file *fp,\n\t\t\t     void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_all_info *file_info;\n\tunsigned int delete_pending;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tint conv_len;\n\tchar *filename;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tksmbd_debug(SMB, \"no right to read the attributes : 0x%x\\n\",\n\t\t\t    fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfilename = convert_to_nt_pathname(work->tcon->share_conf, &fp->filp->f_path);\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tksmbd_debug(SMB, \"filename = %s\\n\", filename);\n\tdelete_pending = ksmbd_inode_pending_delete(fp);\n\tfile_info = (struct smb2_file_all_info *)rsp->Buffer;\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->Pad1 = 0;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->NumberOfLinks =\n\t\t\tcpu_to_le32(get_nlink(&stat) - delete_pending);\n\tfile_info->DeletePending = delete_pending;\n\tfile_info->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n\tfile_info->Pad2 = 0;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\tfile_info->EASize = 0;\n\tfile_info->AccessFlags = fp->daccess;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\tfile_info->Mode = fp->coption;\n\tfile_info->AlignmentRequirement = 0;\n\tconv_len = smbConvertToUTF16((__le16 *)file_info->FileName, filename,\n\t\t\t\t     PATH_MAX, conn->local_nls, 0);\n\tconv_len *= 2;\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_all_info) + conv_len - 1);\n\tkfree(filename);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n\treturn 0;\n}\n\nstatic void get_file_alternate_info(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_rsp *rsp,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_alt_name_info *file_info;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint conv_len;\n\n\tspin_lock(&dentry->d_lock);\n\tfile_info = (struct smb2_file_alt_name_info *)rsp->Buffer;\n\tconv_len = ksmbd_extract_shortname(conn,\n\t\t\t\t\t   dentry->d_name.name,\n\t\t\t\t\t   file_info->FileName);\n\tspin_unlock(&dentry->d_lock);\n\tfile_info->FileNameLength = cpu_to_le32(conv_len);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_alt_name_info) + conv_len);\n\tinc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));\n}\n\nstatic void get_file_stream_info(struct ksmbd_work *work,\n\t\t\t\t struct smb2_query_info_rsp *rsp,\n\t\t\t\t struct ksmbd_file *fp,\n\t\t\t\t void *rsp_org)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_file_stream_info *file_info;\n\tchar *stream_name, *xattr_list = NULL, *stream_buf;\n\tstruct kstat stat;\n\tstruct path *path = &fp->filp->f_path;\n\tssize_t xattr_list_len;\n\tint nbytes = 0, streamlen, stream_name_len, next, idx = 0;\n\tint buf_free_len;\n\tstruct smb2_query_info_req *req = ksmbd_req_buf_next(work);\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_stream_info *)rsp->Buffer;\n\n\tbuf_free_len =\n\t\tsmb2_calc_max_out_buf_len(work, 8,\n\t\t\t\t\t  le32_to_cpu(req->OutputBufferLength));\n\tif (buf_free_len < 0)\n\t\tgoto out;\n\n\txattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (idx < xattr_list_len) {\n\t\tstream_name = xattr_list + idx;\n\t\tstreamlen = strlen(stream_name);\n\t\tidx += streamlen + 1;\n\n\t\tksmbd_debug(SMB, \"%s, len %d\\n\", stream_name, streamlen);\n\n\t\tif (strncmp(&stream_name[XATTR_USER_PREFIX_LEN],\n\t\t\t    STREAM_PREFIX, STREAM_PREFIX_LEN))\n\t\t\tcontinue;\n\n\t\tstream_name_len = streamlen - (XATTR_USER_PREFIX_LEN +\n\t\t\t\tSTREAM_PREFIX_LEN);\n\t\tstreamlen = stream_name_len;\n\n\t\t/* plus : size */\n\t\tstreamlen += 1;\n\t\tstream_buf = kmalloc(streamlen + 1, GFP_KERNEL);\n\t\tif (!stream_buf)\n\t\t\tbreak;\n\n\t\tstreamlen = snprintf(stream_buf, streamlen + 1,\n\t\t\t\t     \":%s\", &stream_name[XATTR_NAME_STREAM_LEN]);\n\n\t\tnext = sizeof(struct smb2_file_stream_info) + streamlen * 2;\n\t\tif (next > buf_free_len) {\n\t\t\tkfree(stream_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tfile_info = (struct smb2_file_stream_info *)&rsp->Buffer[nbytes];\n\t\tstreamlen  = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t       stream_buf, streamlen,\n\t\t\t\t\t       conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tkfree(stream_buf);\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stream_name_len);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stream_name_len);\n\n\t\tnbytes += next;\n\t\tbuf_free_len -= next;\n\t\tfile_info->NextEntryOffset = cpu_to_le32(next);\n\t}\n\nout:\n\tif (!S_ISDIR(stat.mode) &&\n\t    buf_free_len >= sizeof(struct smb2_file_stream_info) + 7 * 2) {\n\t\tfile_info = (struct smb2_file_stream_info *)\n\t\t\t&rsp->Buffer[nbytes];\n\t\tstreamlen = smbConvertToUTF16((__le16 *)file_info->StreamName,\n\t\t\t\t\t      \"::$DATA\", 7, conn->local_nls, 0);\n\t\tstreamlen *= 2;\n\t\tfile_info->StreamNameLength = cpu_to_le32(streamlen);\n\t\tfile_info->StreamSize = cpu_to_le64(stat.size);\n\t\tfile_info->StreamAllocationSize = cpu_to_le64(stat.blocks << 9);\n\t\tnbytes += sizeof(struct smb2_file_stream_info) + streamlen;\n\t}\n\n\t/* last entry offset should be 0 */\n\tfile_info->NextEntryOffset = 0;\n\tkvfree(xattr_list);\n\n\trsp->OutputBufferLength = cpu_to_le32(nbytes);\n\tinc_rfc1001_len(rsp_org, nbytes);\n}\n\nstatic void get_file_internal_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_internal_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\tfile_info = (struct smb2_file_internal_info *)rsp->Buffer;\n\tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_internal_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));\n}\n\nstatic int get_file_network_open_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_ntwrk_info *file_info;\n\tstruct inode *inode;\n\tstruct kstat stat;\n\tu64 time;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_ntwrk_info *)rsp->Buffer;\n\n\tinode = file_inode(fp->filp);\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);\n\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->Attributes = fp->f_ci->m_fattr;\n\tfile_info->AllocationSize =\n\t\tcpu_to_le64(get_allocation_size(inode, &stat));\n\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\tfile_info->Reserved = cpu_to_le32(0);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ntwrk_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ntwrk_info));\n\treturn 0;\n}\n\nstatic void get_file_ea_info(struct smb2_query_info_rsp *rsp, void *rsp_org)\n{\n\tstruct smb2_file_ea_info *file_info;\n\n\tfile_info = (struct smb2_file_ea_info *)rsp->Buffer;\n\tfile_info->EASize = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_ea_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ea_info));\n}\n\nstatic void get_file_position_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t   struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_pos_info *file_info;\n\n\tfile_info = (struct smb2_file_pos_info *)rsp->Buffer;\n\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_pos_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_pos_info));\n}\n\nstatic void get_file_mode_info(struct smb2_query_info_rsp *rsp,\n\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_mode_info *file_info;\n\n\tfile_info = (struct smb2_file_mode_info *)rsp->Buffer;\n\tfile_info->Mode = fp->coption & FILE_MODE_INFO_MASK;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_mode_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_mode_info));\n}\n\nstatic void get_file_compression_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t      struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_comp_info *file_info;\n\tstruct kstat stat;\n\n\tgeneric_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),\n\t\t\t &stat);\n\n\tfile_info = (struct smb2_file_comp_info *)rsp->Buffer;\n\tfile_info->CompressedFileSize = cpu_to_le64(stat.blocks << 9);\n\tfile_info->CompressionFormat = COMPRESSION_FORMAT_NONE;\n\tfile_info->CompressionUnitShift = 0;\n\tfile_info->ChunkShift = 0;\n\tfile_info->ClusterShift = 0;\n\tmemset(&file_info->Reserved[0], 0, 3);\n\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_comp_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_comp_info));\n}\n\nstatic int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\t       struct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb2_file_attr_tag_info *file_info;\n\n\tif (!(fp->daccess & FILE_READ_ATTRIBUTES_LE)) {\n\t\tpr_err(\"no right to read the attributes : 0x%x\\n\",\n\t\t       fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tfile_info = (struct smb2_file_attr_tag_info *)rsp->Buffer;\n\tfile_info->FileAttributes = fp->f_ci->m_fattr;\n\tfile_info->ReparseTag = 0;\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb2_file_attr_tag_info));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb2_file_attr_tag_info));\n\treturn 0;\n}\n\nstatic int find_file_posix_info(struct smb2_query_info_rsp *rsp,\n\t\t\t\tstruct ksmbd_file *fp, void *rsp_org)\n{\n\tstruct smb311_posix_qinfo *file_info;\n\tstruct inode *inode = file_inode(fp->filp);\n\tu64 time;\n\n\tfile_info = (struct smb311_posix_qinfo *)rsp->Buffer;\n\tfile_info->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\tfile_info->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\tfile_info->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\tfile_info->ChangeTime = cpu_to_le64(time);\n\tfile_info->DosAttributes = fp->f_ci->m_fattr;\n\tfile_info->Inode = cpu_to_le64(inode->i_ino);\n\tfile_info->EndOfFile = cpu_to_le64(inode->i_size);\n\tfile_info->AllocationSize = cpu_to_le64(inode->i_blocks << 9);\n\tfile_info->HardLinks = cpu_to_le32(inode->i_nlink);\n\tfile_info->Mode = cpu_to_le32(inode->i_mode);\n\tfile_info->DeviceId = cpu_to_le32(inode->i_rdev);\n\trsp->OutputBufferLength =\n\t\tcpu_to_le32(sizeof(struct smb311_posix_qinfo));\n\tinc_rfc1001_len(rsp_org, sizeof(struct smb311_posix_qinfo));\n\treturn 0;\n}\n\nstatic int smb2_get_info_file(struct ksmbd_work *work,\n\t\t\t      struct smb2_query_info_req *req,\n\t\t\t      struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tint fileinfoclass = 0;\n\tint rc = 0;\n\tint file_infoclass_size;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\t/* smb2 info file called for pipe */\n\t\treturn smb2_get_info_file_pipe(work->sess, req, rsp,\n\t\t\t\t\t       work->response_buf);\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tfileinfoclass = req->FileInfoClass;\n\n\tswitch (fileinfoclass) {\n\tcase FILE_ACCESS_INFORMATION:\n\t\tget_file_access_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ACCESS_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_BASIC_INFORMATION:\n\t\trc = get_file_basic_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_BASIC_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STANDARD_INFORMATION:\n\t\tget_file_standard_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STANDARD_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALIGNMENT_INFORMATION:\n\t\tget_file_alignment_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALIGNMENT_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALL_INFORMATION:\n\t\trc = get_file_all_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ALTERNATE_NAME_INFORMATION:\n\t\tget_file_alternate_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ALTERNATE_NAME_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_STREAM_INFORMATION:\n\t\tget_file_stream_info(work, rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_STREAM_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_INTERNAL_INFORMATION:\n\t\tget_file_internal_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_INTERNAL_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_NETWORK_OPEN_INFORMATION:\n\t\trc = get_file_network_open_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_NETWORK_OPEN_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_EA_INFORMATION:\n\t\tget_file_ea_info(rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_FULL_EA_INFORMATION:\n\t\trc = smb2_get_ea(work, fp, req, rsp, work->response_buf);\n\t\tfile_infoclass_size = FILE_FULL_EA_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_POSITION_INFORMATION:\n\t\tget_file_position_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_POSITION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_MODE_INFORMATION:\n\t\tget_file_mode_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_MODE_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_COMPRESSION_INFORMATION:\n\t\tget_file_compression_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_COMPRESSION_INFORMATION_SIZE;\n\t\tbreak;\n\n\tcase FILE_ATTRIBUTE_TAG_INFORMATION:\n\t\trc = get_file_attribute_tag_info(rsp, fp, work->response_buf);\n\t\tfile_infoclass_size = FILE_ATTRIBUTE_TAG_INFORMATION_SIZE;\n\t\tbreak;\n\tcase SMB_FIND_FILE_POSIX_INFO:\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\trc = find_file_posix_info(rsp, fp, work->response_buf);\n\t\t\tfile_infoclass_size = sizeof(struct smb311_posix_qinfo);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"fileinfoclass %d not supported yet\\n\",\n\t\t\t    fileinfoclass);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tif (!rc)\n\t\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t\t      rsp, work->response_buf,\n\t\t\t\t      file_infoclass_size);\n\tksmbd_fd_put(work, fp);\n\treturn rc;\n}\n\nstatic int smb2_get_info_filesystem(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_query_info_req *req,\n\t\t\t\t    struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_share_config *share = work->tcon->share_conf;\n\tint fsinfoclass = 0;\n\tstruct kstatfs stfs;\n\tstruct path path;\n\tint rc = 0, len;\n\tint fs_infoclass_size = 0;\n\n\trc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);\n\tif (rc) {\n\t\tpr_err(\"cannot create vfs path\\n\");\n\t\treturn -EIO;\n\t}\n\n\trc = vfs_statfs(&path, &stfs);\n\tif (rc) {\n\t\tpr_err(\"cannot do stat of path %s\\n\", share->path);\n\t\tpath_put(&path);\n\t\treturn -EIO;\n\t}\n\n\tfsinfoclass = req->FileInfoClass;\n\n\tswitch (fsinfoclass) {\n\tcase FS_DEVICE_INFORMATION:\n\t{\n\t\tstruct filesystem_device_info *info;\n\n\t\tinfo = (struct filesystem_device_info *)rsp->Buffer;\n\n\t\tinfo->DeviceType = cpu_to_le32(stfs.f_type);\n\t\tinfo->DeviceCharacteristics = cpu_to_le32(0x00000020);\n\t\trsp->OutputBufferLength = cpu_to_le32(8);\n\t\tinc_rfc1001_len(work->response_buf, 8);\n\t\tfs_infoclass_size = FS_DEVICE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_ATTRIBUTE_INFORMATION:\n\t{\n\t\tstruct filesystem_attribute_info *info;\n\t\tsize_t sz;\n\n\t\tinfo = (struct filesystem_attribute_info *)rsp->Buffer;\n\t\tinfo->Attributes = cpu_to_le32(FILE_SUPPORTS_OBJECT_IDS |\n\t\t\t\t\t       FILE_PERSISTENT_ACLS |\n\t\t\t\t\t       FILE_UNICODE_ON_DISK |\n\t\t\t\t\t       FILE_CASE_PRESERVED_NAMES |\n\t\t\t\t\t       FILE_CASE_SENSITIVE_SEARCH |\n\t\t\t\t\t       FILE_SUPPORTS_BLOCK_REFCOUNTING);\n\n\t\tinfo->Attributes |= cpu_to_le32(server_conf.share_fake_fscaps);\n\n\t\tinfo->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);\n\t\tlen = smbConvertToUTF16((__le16 *)info->FileSystemName,\n\t\t\t\t\t\"NTFS\", PATH_MAX, conn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->FileSystemNameLen = cpu_to_le32(len);\n\t\tsz = sizeof(struct filesystem_attribute_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_ATTRIBUTE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_VOLUME_INFORMATION:\n\t{\n\t\tstruct filesystem_vol_info *info;\n\t\tsize_t sz;\n\t\tunsigned int serial_crc = 0;\n\n\t\tinfo = (struct filesystem_vol_info *)(rsp->Buffer);\n\t\tinfo->VolumeCreationTime = 0;\n\t\tserial_crc = crc32_le(serial_crc, share->name,\n\t\t\t\t      strlen(share->name));\n\t\tserial_crc = crc32_le(serial_crc, share->path,\n\t\t\t\t      strlen(share->path));\n\t\tserial_crc = crc32_le(serial_crc, ksmbd_netbios_name(),\n\t\t\t\t      strlen(ksmbd_netbios_name()));\n\t\t/* Taking dummy value of serial number*/\n\t\tinfo->SerialNumber = cpu_to_le32(serial_crc);\n\t\tlen = smbConvertToUTF16((__le16 *)info->VolumeLabel,\n\t\t\t\t\tshare->name, PATH_MAX,\n\t\t\t\t\tconn->local_nls, 0);\n\t\tlen = len * 2;\n\t\tinfo->VolumeLabelSize = cpu_to_le32(len);\n\t\tinfo->Reserved = 0;\n\t\tsz = sizeof(struct filesystem_vol_info) - 2 + len;\n\t\trsp->OutputBufferLength = cpu_to_le32(sz);\n\t\tinc_rfc1001_len(work->response_buf, sz);\n\t\tfs_infoclass_size = FS_VOLUME_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SIZE_INFORMATION:\n\t{\n\t\tstruct filesystem_info *info;\n\n\t\tinfo = (struct filesystem_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(24);\n\t\tinc_rfc1001_len(work->response_buf, 24);\n\t\tfs_infoclass_size = FS_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_FULL_SIZE_INFORMATION:\n\t{\n\t\tstruct smb2_fs_full_size_info *info;\n\n\t\tinfo = (struct smb2_fs_full_size_info *)(rsp->Buffer);\n\t\tinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);\n\t\tinfo->CallerAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bavail);\n\t\tinfo->ActualAvailableAllocationUnits =\n\t\t\t\t\tcpu_to_le64(stfs.f_bfree);\n\t\tinfo->SectorsPerAllocationUnit = cpu_to_le32(1);\n\t\tinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);\n\t\trsp->OutputBufferLength = cpu_to_le32(32);\n\t\tinc_rfc1001_len(work->response_buf, 32);\n\t\tfs_infoclass_size = FS_FULL_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_OBJECT_ID_INFORMATION:\n\t{\n\t\tstruct object_id_info *info;\n\n\t\tinfo = (struct object_id_info *)(rsp->Buffer);\n\n\t\tif (!user_guest(sess->user))\n\t\t\tmemcpy(info->objid, user_passkey(sess->user), 16);\n\t\telse\n\t\t\tmemset(info->objid, 0, 16);\n\n\t\tinfo->extended_info.magic = cpu_to_le32(EXTENDED_INFO_MAGIC);\n\t\tinfo->extended_info.version = cpu_to_le32(1);\n\t\tinfo->extended_info.release = cpu_to_le32(1);\n\t\tinfo->extended_info.rel_date = 0;\n\t\tmemcpy(info->extended_info.version_string, \"1.1.0\", strlen(\"1.1.0\"));\n\t\trsp->OutputBufferLength = cpu_to_le32(64);\n\t\tinc_rfc1001_len(work->response_buf, 64);\n\t\tfs_infoclass_size = FS_OBJECT_ID_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_SECTOR_SIZE_INFORMATION:\n\t{\n\t\tstruct smb3_fs_ss_info *info;\n\t\tunsigned int sector_size =\n\t\t\tmin_t(unsigned int, path.mnt->mnt_sb->s_blocksize, 4096);\n\n\t\tinfo = (struct smb3_fs_ss_info *)(rsp->Buffer);\n\n\t\tinfo->LogicalBytesPerSector = cpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->PhysicalBytesPerSectorForPerf = cpu_to_le32(sector_size);\n\t\tinfo->FSEffPhysicalBytesPerSectorForAtomicity =\n\t\t\t\tcpu_to_le32(sector_size);\n\t\tinfo->Flags = cpu_to_le32(SSINFO_FLAGS_ALIGNED_DEVICE |\n\t\t\t\t    SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE);\n\t\tinfo->ByteOffsetForSectorAlignment = 0;\n\t\tinfo->ByteOffsetForPartitionAlignment = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(28);\n\t\tinc_rfc1001_len(work->response_buf, 28);\n\t\tfs_infoclass_size = FS_SECTOR_SIZE_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_CONTROL_INFORMATION:\n\t{\n\t\t/*\n\t\t * TODO : The current implementation is based on\n\t\t * test result with win7(NTFS) server. It's need to\n\t\t * modify this to get valid Quota values\n\t\t * from Linux kernel\n\t\t */\n\t\tstruct smb2_fs_control_info *info;\n\n\t\tinfo = (struct smb2_fs_control_info *)(rsp->Buffer);\n\t\tinfo->FreeSpaceStartFiltering = 0;\n\t\tinfo->FreeSpaceThreshold = 0;\n\t\tinfo->FreeSpaceStopFiltering = 0;\n\t\tinfo->DefaultQuotaThreshold = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->DefaultQuotaLimit = cpu_to_le64(SMB2_NO_FID);\n\t\tinfo->Padding = 0;\n\t\trsp->OutputBufferLength = cpu_to_le32(48);\n\t\tinc_rfc1001_len(work->response_buf, 48);\n\t\tfs_infoclass_size = FS_CONTROL_INFORMATION_SIZE;\n\t\tbreak;\n\t}\n\tcase FS_POSIX_INFORMATION:\n\t{\n\t\tstruct filesystem_posix_info *info;\n\n\t\tif (!work->tcon->posix_extensions) {\n\t\t\tpr_err(\"client doesn't negotiate with SMB3.1.1 POSIX Extensions\\n\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tinfo = (struct filesystem_posix_info *)(rsp->Buffer);\n\t\t\tinfo->OptimalTransferSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->BlockSize = cpu_to_le32(stfs.f_bsize);\n\t\t\tinfo->TotalBlocks = cpu_to_le64(stfs.f_blocks);\n\t\t\tinfo->BlocksAvail = cpu_to_le64(stfs.f_bfree);\n\t\t\tinfo->UserBlocksAvail = cpu_to_le64(stfs.f_bavail);\n\t\t\tinfo->TotalFileNodes = cpu_to_le64(stfs.f_files);\n\t\t\tinfo->FreeFileNodes = cpu_to_le64(stfs.f_ffree);\n\t\t\trsp->OutputBufferLength = cpu_to_le32(56);\n\t\t\tinc_rfc1001_len(work->response_buf, 56);\n\t\t\tfs_infoclass_size = FS_POSIX_INFORMATION_SIZE;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpath_put(&path);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),\n\t\t\t      rsp, work->response_buf,\n\t\t\t      fs_infoclass_size);\n\tpath_put(&path);\n\treturn rc;\n}\n\nstatic int smb2_get_info_sec(struct ksmbd_work *work,\n\t\t\t     struct smb2_query_info_req *req,\n\t\t\t     struct smb2_query_info_rsp *rsp)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode;\n\t__u32 secdesclen = 0;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\tint addition_info = le32_to_cpu(req->AdditionalInformation);\n\tint rc = 0, ppntsd_size = 0;\n\n\tif (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO |\n\t\t\t      PROTECTED_DACL_SECINFO |\n\t\t\t      UNPROTECTED_DACL_SECINFO)) {\n\t\tksmbd_debug(SMB, \"Unsupported addition info: 0x%x)\\n\",\n\t\t       addition_info);\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PROTECTED);\n\t\tpntsd->osidoffset = 0;\n\t\tpntsd->gsidoffset = 0;\n\t\tpntsd->sacloffset = 0;\n\t\tpntsd->dacloffset = 0;\n\n\t\tsecdesclen = sizeof(struct smb_ntsd);\n\t\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\t\tinc_rfc1001_len(work->response_buf, secdesclen);\n\n\t\treturn 0;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tinode = file_inode(fp->filp);\n\tksmbd_acls_fattr(&fattr, user_ns, inode);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR))\n\t\tppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry,\n\t\t\t\t\t\t     &ppntsd);\n\n\t/* Check if sd buffer size exceeds response buffer size */\n\tif (smb2_resp_buf_len(work, 8) > ppntsd_size)\n\t\trc = build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,\n\t\t\t\t    addition_info, &secdesclen, &fattr);\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tkfree(ppntsd);\n\tksmbd_fd_put(work, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trsp->OutputBufferLength = cpu_to_le32(secdesclen);\n\tinc_rfc1001_len(work->response_buf, secdesclen);\n\treturn 0;\n}\n\n/**\n * smb2_query_info() - handler for smb2 query info command\n * @work:\tsmb work containing query info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_query_info(struct ksmbd_work *work)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp;\n\tint rc = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"GOT query info request\\n\");\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_get_info_file(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_FILESYSTEM:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILESYSTEM\\n\");\n\t\trc = smb2_get_info_filesystem(work, req, rsp);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\trc = smb2_get_info_sec(work, req, rsp);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"InfoType %d not supported yet\\n\",\n\t\t\t    req->InfoType);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0) {\n\t\tif (rc == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (rc == -EIO)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t\telse if (rc == -EOPNOTSUPP || rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\t\tsmb2_set_err_rsp(work);\n\n\t\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\",\n\t\t\t    rc);\n\t\treturn rc;\n\t}\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->OutputBufferOffset = cpu_to_le16(72);\n\tinc_rfc1001_len(work->response_buf, 8);\n\treturn 0;\n}\n\n/**\n * smb2_close_pipe() - handler for closing IPC pipe\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nstatic noinline int smb2_close_pipe(struct ksmbd_work *work)\n{\n\tu64 id;\n\tstruct smb2_close_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_close_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\tksmbd_session_rpc_close(work->sess, id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Flags = 0;\n\trsp->Reserved = 0;\n\trsp->CreationTime = 0;\n\trsp->LastAccessTime = 0;\n\trsp->LastWriteTime = 0;\n\trsp->ChangeTime = 0;\n\trsp->AllocationSize = 0;\n\trsp->EndOfFile = 0;\n\trsp->Attributes = 0;\n\tinc_rfc1001_len(work->response_buf, 60);\n\treturn 0;\n}\n\n/**\n * smb2_close() - handler for smb2 close file command\n * @work:\tsmb work containing close request buffer\n *\n * Return:\t0\n */\nint smb2_close(struct ksmbd_work *work)\n{\n\tu64 volatile_id = KSMBD_NO_FID;\n\tu64 sess_id;\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_file *fp;\n\tstruct inode *inode;\n\tu64 time;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe close request\\n\");\n\t\treturn smb2_close_pipe(work);\n\t}\n\n\tsess_id = le64_to_cpu(req->hdr.SessionId);\n\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\tsess_id = work->compound_sid;\n\n\twork->compound_sid = 0;\n\tif (check_session_id(conn, sess_id)) {\n\t\twork->compound_sid = sess_id;\n\t} else {\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\t\tif (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\terr = -EBADF;\n\t\tgoto out;\n\t}\n\n\tif (work->next_smb2_rcv_hdr_off &&\n\t    !has_file_id(req->VolatileFileId)) {\n\t\tif (!has_file_id(work->compound_fid)) {\n\t\t\t/* file already closed, return FILE_CLOSED */\n\t\t\tksmbd_debug(SMB, \"file already closed\\n\");\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\t\terr = -EBADF;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Compound request set FID = %llu:%llu\\n\",\n\t\t\t\t    work->compound_fid,\n\t\t\t\t    work->compound_pfid);\n\t\t\tvolatile_id = work->compound_fid;\n\n\t\t\t/* file closed, stored id is not valid anymore */\n\t\t\twork->compound_fid = KSMBD_NO_FID;\n\t\t\twork->compound_pfid = KSMBD_NO_FID;\n\t\t}\n\t} else {\n\t\tvolatile_id = req->VolatileFileId;\n\t}\n\tksmbd_debug(SMB, \"volatile_id = %llu\\n\", volatile_id);\n\n\trsp->StructureSize = cpu_to_le16(60);\n\trsp->Reserved = 0;\n\n\tif (req->Flags == SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB) {\n\t\tfp = ksmbd_lookup_fd_fast(work, volatile_id);\n\t\tif (!fp) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode = file_inode(fp->filp);\n\t\trsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;\n\t\trsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :\n\t\t\tcpu_to_le64(inode->i_blocks << 9);\n\t\trsp->EndOfFile = cpu_to_le64(inode->i_size);\n\t\trsp->Attributes = fp->f_ci->m_fattr;\n\t\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_atime);\n\t\trsp->LastAccessTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_mtime);\n\t\trsp->LastWriteTime = cpu_to_le64(time);\n\t\ttime = ksmbd_UnixTimeToNT(inode->i_ctime);\n\t\trsp->ChangeTime = cpu_to_le64(time);\n\t\tksmbd_fd_put(work, fp);\n\t} else {\n\t\trsp->Flags = 0;\n\t\trsp->AllocationSize = 0;\n\t\trsp->EndOfFile = 0;\n\t\trsp->Attributes = 0;\n\t\trsp->CreationTime = 0;\n\t\trsp->LastAccessTime = 0;\n\t\trsp->LastWriteTime = 0;\n\t\trsp->ChangeTime = 0;\n\t}\n\n\terr = ksmbd_close_fd(work, volatile_id);\nout:\n\tif (err) {\n\t\tif (rsp->hdr.Status == 0)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t} else {\n\t\tinc_rfc1001_len(work->response_buf, 60);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_echo() - handler for smb2 echo(ping) command\n * @work:\tsmb work containing echo request buffer\n *\n * Return:\t0\n */\nint smb2_echo(struct ksmbd_work *work)\n{\n\tstruct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n}\n\nstatic int smb2_rename(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp,\n\t\t       struct user_namespace *user_ns,\n\t\t       struct smb2_file_rename_info *file_info,\n\t\t       struct nls_table *local_nls)\n{\n\tstruct ksmbd_share_config *share = fp->tcon->share_conf;\n\tchar *new_name = NULL, *abs_oldname = NULL, *old_name = NULL;\n\tchar *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tksmbd_debug(SMB, \"setting FILE_RENAME_INFO\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tabs_oldname = d_path(&fp->filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(abs_oldname)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\told_name = strrchr(abs_oldname, '/');\n\tif (old_name && old_name[1] != '\\0') {\n\t\told_name++;\n\t} else {\n\t\tksmbd_debug(SMB, \"can't get last component in path %s\\n\",\n\t\t\t    abs_oldname);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tnew_name = smb2_get_name(file_info->FileName,\n\t\t\t\t le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t local_nls);\n\tif (IS_ERR(new_name)) {\n\t\trc = PTR_ERR(new_name);\n\t\tgoto out;\n\t}\n\n\tif (strchr(new_name, ':')) {\n\t\tint s_type;\n\t\tchar *xattr_stream_name, *stream_name = NULL;\n\t\tsize_t xattr_stream_size;\n\t\tint len;\n\n\t\trc = parse_stream_name(new_name, &stream_name, &s_type);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tlen = strlen(new_name);\n\t\tif (len > 0 && new_name[len - 1] != '/') {\n\t\t\tpr_err(\"not allow base filename in rename\\n\");\n\t\t\trc = -ESHARE;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ksmbd_vfs_xattr_stream_name(stream_name,\n\t\t\t\t\t\t &xattr_stream_name,\n\t\t\t\t\t\t &xattr_stream_size,\n\t\t\t\t\t\t s_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t\tfp->filp->f_path.dentry,\n\t\t\t\t\txattr_stream_name,\n\t\t\t\t\tNULL, 0, 0);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"failed to store stream name in xattr: %d\\n\",\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"new name %s\\n\", new_name);\n\trc = ksmbd_vfs_kern_path(work, new_name, LOOKUP_NO_SYMLINKS, &path, 1);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (ksmbd_share_veto_filename(share, new_name)) {\n\t\trc = -ENOENT;\n\t\tksmbd_debug(SMB, \"Can't rename vetoed file: %s\\n\", new_name);\n\t\tgoto out;\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, new_name);\n\t\t\tif (rc) {\n\t\t\t\tif (rc != -ENOTEMPTY)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s, rc %d\\n\",\n\t\t\t\t\t    new_name, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present &&\n\t\t    strncmp(old_name, path.dentry->d_name.name, strlen(old_name))) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cannot rename already existing file\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_fp_rename(work, fp, new_name);\nout:\n\tkfree(pathname);\n\tif (!IS_ERR(new_name))\n\t\tkfree(new_name);\n\treturn rc;\n}\n\nstatic int smb2_create_link(struct ksmbd_work *work,\n\t\t\t    struct ksmbd_share_config *share,\n\t\t\t    struct smb2_file_link_info *file_info,\n\t\t\t    unsigned int buf_len, struct file *filp,\n\t\t\t    struct nls_table *local_nls)\n{\n\tchar *link_name = NULL, *target_name = NULL, *pathname = NULL;\n\tstruct path path;\n\tbool file_present = true;\n\tint rc;\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_link_info) +\n\t\t\tle32_to_cpu(file_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tksmbd_debug(SMB, \"setting FILE_LINK_INFORMATION\\n\");\n\tpathname = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\tlink_name = smb2_get_name(file_info->FileName,\n\t\t\t\t  le32_to_cpu(file_info->FileNameLength),\n\t\t\t\t  local_nls);\n\tif (IS_ERR(link_name) || S_ISDIR(file_inode(filp)->i_mode)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"link name is %s\\n\", link_name);\n\ttarget_name = d_path(&filp->f_path, pathname, PATH_MAX);\n\tif (IS_ERR(target_name)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"target name is %s\\n\", target_name);\n\trc = ksmbd_vfs_kern_path(work, link_name, LOOKUP_NO_SYMLINKS, &path, 0);\n\tif (rc) {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto out;\n\t\tfile_present = false;\n\t} else {\n\t\tpath_put(&path);\n\t}\n\n\tif (file_info->ReplaceIfExists) {\n\t\tif (file_present) {\n\t\t\trc = ksmbd_vfs_remove_file(work, link_name);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tksmbd_debug(SMB, \"cannot delete %s\\n\",\n\t\t\t\t\t    link_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (file_present) {\n\t\t\trc = -EEXIST;\n\t\t\tksmbd_debug(SMB, \"link already exists\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_link(work, target_name, link_name);\n\tif (rc)\n\t\trc = -EINVAL;\nout:\n\tif (!IS_ERR(link_name))\n\t\tkfree(link_name);\n\tkfree(pathname);\n\treturn rc;\n}\n\nstatic int set_file_basic_info(struct ksmbd_file *fp,\n\t\t\t       struct smb2_file_basic_info *file_info,\n\t\t\t       struct ksmbd_share_config *share)\n{\n\tstruct iattr attrs;\n\tstruct file *filp;\n\tstruct inode *inode;\n\tstruct user_namespace *user_ns;\n\tint rc = 0;\n\n\tif (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))\n\t\treturn -EACCES;\n\n\tattrs.ia_valid = 0;\n\tfilp = fp->filp;\n\tinode = file_inode(filp);\n\tuser_ns = file_mnt_user_ns(filp);\n\n\tif (file_info->CreationTime)\n\t\tfp->create_time = le64_to_cpu(file_info->CreationTime);\n\n\tif (file_info->LastAccessTime) {\n\t\tattrs.ia_atime = ksmbd_NTtimeToUnix(file_info->LastAccessTime);\n\t\tattrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t}\n\n\tattrs.ia_valid |= ATTR_CTIME;\n\tif (file_info->ChangeTime)\n\t\tattrs.ia_ctime = ksmbd_NTtimeToUnix(file_info->ChangeTime);\n\telse\n\t\tattrs.ia_ctime = inode->i_ctime;\n\n\tif (file_info->LastWriteTime) {\n\t\tattrs.ia_mtime = ksmbd_NTtimeToUnix(file_info->LastWriteTime);\n\t\tattrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t}\n\n\tif (file_info->Attributes) {\n\t\tif (!S_ISDIR(inode->i_mode) &&\n\t\t    file_info->Attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\t\tpr_err(\"can't change a file to a directory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(S_ISDIR(inode->i_mode) && file_info->Attributes == FILE_ATTRIBUTE_NORMAL_LE))\n\t\t\tfp->f_ci->m_fattr = file_info->Attributes |\n\t\t\t\t(fp->f_ci->m_fattr & FILE_ATTRIBUTE_DIRECTORY_LE);\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_STORE_DOS_ATTRS) &&\n\t    (file_info->CreationTime || file_info->Attributes)) {\n\t\tstruct xattr_dos_attrib da = {0};\n\n\t\tda.version = 4;\n\t\tda.itime = fp->itime;\n\t\tda.create_time = fp->create_time;\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tda.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |\n\t\t\tXATTR_DOSINFO_ITIME;\n\n\t\trc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t    filp->f_path.dentry, &da);\n\t\tif (rc)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"failed to restore file attribute in EA\\n\");\n\t\trc = 0;\n\t}\n\n\tif (attrs.ia_valid) {\n\t\tstruct dentry *dentry = filp->f_path.dentry;\n\t\tstruct inode *inode = d_inode(dentry);\n\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EACCES;\n\n\t\tinode_lock(inode);\n\t\tinode->i_ctime = attrs.ia_ctime;\n\t\tattrs.ia_valid &= ~ATTR_CTIME;\n\t\trc = notify_change(user_ns, dentry, &attrs, NULL);\n\t\tinode_unlock(inode);\n\t}\n\treturn rc;\n}\n\nstatic int set_file_allocation_info(struct ksmbd_work *work,\n\t\t\t\t    struct ksmbd_file *fp,\n\t\t\t\t    struct smb2_file_alloc_info *file_alloc_info)\n{\n\t/*\n\t * TODO : It's working fine only when store dos attributes\n\t * is not yes. need to implement a logic which works\n\t * properly with any smb.conf option\n\t */\n\n\tloff_t alloc_blks;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\talloc_blks = (le64_to_cpu(file_alloc_info->AllocationSize) + 511) >> 9;\n\tinode = file_inode(fp->filp);\n\n\tif (alloc_blks > inode->i_blocks) {\n\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\trc = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t   alloc_blks * 512);\n\t\tif (rc && rc != -EOPNOTSUPP) {\n\t\t\tpr_err(\"vfs_fallocate is failed : %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else if (alloc_blks < inode->i_blocks) {\n\t\tloff_t size;\n\n\t\t/*\n\t\t * Allocation size could be smaller than original one\n\t\t * which means allocated blocks in file should be\n\t\t * deallocated. use truncate to cut out it, but inode\n\t\t * size is also updated with truncate offset.\n\t\t * inode size is retained by backup inode size.\n\t\t */\n\t\tsize = i_size_read(inode);\n\t\trc = ksmbd_vfs_truncate(work, fp, alloc_blks * 512);\n\t\tif (rc) {\n\t\t\tpr_err(\"truncate failed!, err %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (size < alloc_blks * 512)\n\t\t\ti_size_write(inode, size);\n\t}\n\treturn 0;\n}\n\nstatic int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t\tstruct smb2_file_eof_info *file_eof_info)\n{\n\tloff_t newsize;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n\t\treturn -EACCES;\n\n\tnewsize = le64_to_cpu(file_eof_info->EndOfFile);\n\tinode = file_inode(fp->filp);\n\n\t/*\n\t * If FILE_END_OF_FILE_INFORMATION of set_info_file is called\n\t * on FAT32 shared device, truncate execution time is too long\n\t * and network error could cause from windows client. because\n\t * truncate of some filesystem like FAT32 fill zero data in\n\t * truncated range.\n\t */\n\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC) {\n\t\tksmbd_debug(SMB, \"truncated to newsize %lld\\n\", newsize);\n\t\trc = ksmbd_vfs_truncate(work, fp, newsize);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"truncate failed!, err %d\\n\", rc);\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\trc = -EBADF;\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t   struct smb2_file_rename_info *rename_info,\n\t\t\t   unsigned int buf_len)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ksmbd_file *parent_fp;\n\tstruct dentry *parent;\n\tstruct dentry *dentry = fp->filp->f_path.dentry;\n\tint ret;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tif (buf_len < (u64)sizeof(struct smb2_file_rename_info) +\n\t\t\tle32_to_cpu(rename_info->FileNameLength))\n\t\treturn -EINVAL;\n\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tif (ksmbd_stream_fd(fp))\n\t\tgoto next;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tparent_fp = ksmbd_lookup_fd_inode(d_inode(parent));\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\n\tif (parent_fp) {\n\t\tif (parent_fp->daccess & FILE_DELETE_LE) {\n\t\t\tpr_err(\"parent dir is opened with delete access\\n\");\n\t\t\tksmbd_fd_put(work, parent_fp);\n\t\t\treturn -ESHARE;\n\t\t}\n\t\tksmbd_fd_put(work, parent_fp);\n\t}\nnext:\n\treturn smb2_rename(work, fp, user_ns, rename_info,\n\t\t\t   work->conn->local_nls);\n}\n\nstatic int set_file_disposition_info(struct ksmbd_file *fp,\n\t\t\t\t     struct smb2_file_disposition_info *file_info)\n{\n\tstruct inode *inode;\n\n\tif (!(fp->daccess & FILE_DELETE_LE)) {\n\t\tpr_err(\"no right to delete : 0x%x\\n\", fp->daccess);\n\t\treturn -EACCES;\n\t}\n\n\tinode = file_inode(fp->filp);\n\tif (file_info->DeletePending) {\n\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t    ksmbd_vfs_empty_dir(fp) == -ENOTEMPTY)\n\t\t\treturn -EBUSY;\n\t\tksmbd_set_inode_pending_delete(fp);\n\t} else {\n\t\tksmbd_clear_inode_pending_delete(fp);\n\t}\n\treturn 0;\n}\n\nstatic int set_file_position_info(struct ksmbd_file *fp,\n\t\t\t\t  struct smb2_file_pos_info *file_info)\n{\n\tloff_t current_byte_offset;\n\tunsigned long sector_size;\n\tstruct inode *inode;\n\n\tinode = file_inode(fp->filp);\n\tcurrent_byte_offset = le64_to_cpu(file_info->CurrentByteOffset);\n\tsector_size = inode->i_sb->s_blocksize;\n\n\tif (current_byte_offset < 0 ||\n\t    (fp->coption == FILE_NO_INTERMEDIATE_BUFFERING_LE &&\n\t     current_byte_offset & (sector_size - 1))) {\n\t\tpr_err(\"CurrentByteOffset is not valid : %llu\\n\",\n\t\t       current_byte_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tfp->filp->f_pos = current_byte_offset;\n\treturn 0;\n}\n\nstatic int set_file_mode_info(struct ksmbd_file *fp,\n\t\t\t      struct smb2_file_mode_info *file_info)\n{\n\t__le32 mode;\n\n\tmode = file_info->Mode;\n\n\tif ((mode & ~FILE_MODE_INFO_MASK)) {\n\t\tpr_err(\"Mode is not valid : 0x%x\\n\", le32_to_cpu(mode));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * TODO : need to implement consideration for\n\t * FILE_SYNCHRONOUS_IO_ALERT and FILE_SYNCHRONOUS_IO_NONALERT\n\t */\n\tksmbd_vfs_set_fadvise(fp->filp, mode);\n\tfp->coption = mode;\n\treturn 0;\n}\n\n/**\n * smb2_set_info_file() - handler for smb2 set info command\n * @work:\tsmb work containing set info command buffer\n * @fp:\t\tksmbd_file pointer\n * @req:\trequest buffer pointer\n * @share:\tksmbd_share_config pointer\n *\n * Return:\t0 on success, otherwise error\n * TODO: need to implement an error handling for STATUS_INFO_LENGTH_MISMATCH\n */\nstatic int smb2_set_info_file(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\t      struct smb2_set_info_req *req,\n\t\t\t      struct ksmbd_share_config *share)\n{\n\tunsigned int buf_len = le32_to_cpu(req->BufferLength);\n\n\tswitch (req->FileInfoClass) {\n\tcase FILE_BASIC_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_basic_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_basic_info(fp, (struct smb2_file_basic_info *)req->Buffer, share);\n\t}\n\tcase FILE_ALLOCATION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_alloc_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_allocation_info(work, fp,\n\t\t\t\t\t\t(struct smb2_file_alloc_info *)req->Buffer);\n\t}\n\tcase FILE_END_OF_FILE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_eof_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_end_of_file_info(work, fp,\n\t\t\t\t\t    (struct smb2_file_eof_info *)req->Buffer);\n\t}\n\tcase FILE_RENAME_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_rename_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_rename_info(work, fp,\n\t\t\t\t       (struct smb2_file_rename_info *)req->Buffer,\n\t\t\t\t       buf_len);\n\t}\n\tcase FILE_LINK_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_link_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_create_link(work, work->tcon->share_conf,\n\t\t\t\t\t(struct smb2_file_link_info *)req->Buffer,\n\t\t\t\t\tbuf_len, fp->filp,\n\t\t\t\t\twork->conn->local_nls);\n\t}\n\tcase FILE_DISPOSITION_INFORMATION:\n\t{\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_file_disposition_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_disposition_info(fp,\n\t\t\t\t\t\t (struct smb2_file_disposition_info *)req->Buffer);\n\t}\n\tcase FILE_FULL_EA_INFORMATION:\n\t{\n\t\tif (!(fp->daccess & FILE_WRITE_EA_LE)) {\n\t\t\tpr_err(\"Not permitted to write ext  attr: 0x%x\\n\",\n\t\t\t       fp->daccess);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (buf_len < sizeof(struct smb2_ea_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn smb2_set_ea((struct smb2_ea_info *)req->Buffer,\n\t\t\t\t   buf_len, &fp->filp->f_path);\n\t}\n\tcase FILE_POSITION_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_pos_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_position_info(fp, (struct smb2_file_pos_info *)req->Buffer);\n\t}\n\tcase FILE_MODE_INFORMATION:\n\t{\n\t\tif (buf_len < sizeof(struct smb2_file_mode_info))\n\t\t\treturn -EINVAL;\n\n\t\treturn set_file_mode_info(fp, (struct smb2_file_mode_info *)req->Buffer);\n\t}\n\t}\n\n\tpr_err(\"Unimplemented Fileinfoclass :%d\\n\", req->FileInfoClass);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int smb2_set_info_sec(struct ksmbd_file *fp, int addition_info,\n\t\t\t     char *buffer, int buf_len)\n{\n\tstruct smb_ntsd *pntsd = (struct smb_ntsd *)buffer;\n\n\tfp->saccess |= FILE_SHARE_DELETE_LE;\n\n\treturn set_info_sec(fp->conn, fp->tcon, &fp->filp->f_path, pntsd,\n\t\t\tbuf_len, false);\n}\n\n/**\n * smb2_set_info() - handler for smb2 set info command handler\n * @work:\tsmb work containing set info request buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_set_info(struct ksmbd_work *work)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp;\n\tstruct ksmbd_file *fp;\n\tint rc = 0;\n\tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n\n\tksmbd_debug(SMB, \"Received set info request\\n\");\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t\tpid = work->compound_pfid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id)) {\n\t\tid = req->VolatileFileId;\n\t\tpid = req->PersistentFileId;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, id, pid);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid id for close: %u\\n\", id);\n\t\trc = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tswitch (req->InfoType) {\n\tcase SMB2_O_INFO_FILE:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_FILE\\n\");\n\t\trc = smb2_set_info_file(work, fp, req, work->tcon->share_conf);\n\t\tbreak;\n\tcase SMB2_O_INFO_SECURITY:\n\t\tksmbd_debug(SMB, \"GOT SMB2_O_INFO_SECURITY\\n\");\n\t\tif (ksmbd_override_fsids(work)) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = smb2_set_info_sec(fp,\n\t\t\t\t       le32_to_cpu(req->AdditionalInformation),\n\t\t\t\t       req->Buffer,\n\t\t\t\t       le32_to_cpu(req->BufferLength));\n\t\tksmbd_revert_fsids(work);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tif (rc < 0)\n\t\tgoto err_out;\n\n\trsp->StructureSize = cpu_to_le16(2);\n\tinc_rfc1001_len(work->response_buf, 2);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nerr_out:\n\tif (rc == -EACCES || rc == -EPERM || rc == -EXDEV)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\telse if (rc == -EBUSY || rc == -ENOTEMPTY)\n\t\trsp->hdr.Status = STATUS_DIRECTORY_NOT_EMPTY;\n\telse if (rc == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (rc == -EBADF || rc == -ESTALE)\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\telse if (rc == -EEXIST)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\telse if (rsp->hdr.Status == 0 || rc == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_INVALID_INFO_CLASS;\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\tksmbd_debug(SMB, \"error while processing smb2 query rc = %d\\n\", rc);\n\treturn rc;\n}\n\n/**\n * smb2_read_pipe() - handler for smb2 read from IPC pipe\n * @work:\tsmb work containing read IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_read_pipe(struct ksmbd_work *work)\n{\n\tint nbytes = 0, err;\n\tu64 id;\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tstruct smb2_read_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_read_rsp *rsp = smb2_get_msg(work->response_buf);\n\n\tid = req->VolatileFileId;\n\n\tinc_rfc1001_len(work->response_buf, 16);\n\trpc_resp = ksmbd_rpc_read(work->sess, id);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twork->aux_payload_buf =\n\t\t\tkvmalloc(rpc_resp->payload_sz, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!work->aux_payload_buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(work->aux_payload_buf, rpc_resp->payload,\n\t\t       rpc_resp->payload_sz);\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\t\twork->aux_payload_sz = nbytes;\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\treturn 0;\n\nout:\n\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\tsmb2_set_err_rsp(work);\n\tkvfree(rpc_resp);\n\treturn err;\n}\n\nstatic int smb2_set_remote_key_for_rdma(struct ksmbd_work *work,\n\t\t\t\t\tstruct smb2_buffer_desc_v1 *desc,\n\t\t\t\t\t__le32 Channel,\n\t\t\t\t\t__le16 ChannelInfoLength)\n{\n\tunsigned int i, ch_count;\n\n\tif (work->conn->dialect == SMB30_PROT_ID &&\n\t    Channel != SMB2_CHANNEL_RDMA_V1)\n\t\treturn -EINVAL;\n\n\tch_count = le16_to_cpu(ChannelInfoLength) / sizeof(*desc);\n\tif (ksmbd_debug_types & KSMBD_DEBUG_RDMA) {\n\t\tfor (i = 0; i < ch_count; i++) {\n\t\t\tpr_info(\"RDMA r/w request %#x: token %#x, length %#x\\n\",\n\t\t\t\ti,\n\t\t\t\tle32_to_cpu(desc[i].token),\n\t\t\t\tle32_to_cpu(desc[i].length));\n\t\t}\n\t}\n\tif (!ch_count)\n\t\treturn -EINVAL;\n\n\twork->need_invalidate_rkey =\n\t\t(Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE);\n\tif (Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE)\n\t\twork->remote_key = le32_to_cpu(desc->token);\n\treturn 0;\n}\n\nstatic ssize_t smb2_read_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t      struct smb2_read_req *req, void *data_buf,\n\t\t\t\t      size_t length)\n{\n\tint err;\n\n\terr = ksmbd_conn_rdma_write(work->conn, data_buf, length,\n\t\t\t\t    (struct smb2_buffer_desc_v1 *)\n\t\t\t\t    ((char *)req + le16_to_cpu(req->ReadChannelInfoOffset)),\n\t\t\t\t    le16_to_cpu(req->ReadChannelInfoLength));\n\tif (err)\n\t\treturn err;\n\n\treturn length;\n}\n\n/**\n * smb2_read() - handler for smb2 read from file\n * @work:\tsmb work containing read command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_read(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_read_req *req;\n\tstruct smb2_read_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length, mincount;\n\tssize_t nbytes = 0, remain_bytes = 0;\n\tint err = 0;\n\tbool is_rdma_channel = false;\n\tunsigned int max_read_size = conn->vals->max_read_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe read request\\n\");\n\t\treturn smb2_read_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1) {\n\t\tis_rdma_channel = true;\n\t\tmax_read_size = get_smbd_max_read_write_size();\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->ReadChannelInfoOffset);\n\n\t\tif (ch_offset < offsetof(struct smb2_read_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->ReadChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to read : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\tmincount = le32_to_cpu(req->MinimumCount);\n\n\tif (length > max_read_size) {\n\t\tksmbd_debug(SMB, \"limiting read size to max size(%u)\\n\",\n\t\t\t    max_read_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t    fp->filp->f_path.dentry, offset, length);\n\n\twork->aux_payload_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->aux_payload_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnbytes = ksmbd_vfs_read(work, fp, length, &offset);\n\tif (nbytes < 0) {\n\t\terr = nbytes;\n\t\tgoto out;\n\t}\n\n\tif ((nbytes == 0 && length != 0) || nbytes < mincount) {\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\t\trsp->hdr.Status = STATUS_END_OF_FILE;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn 0;\n\t}\n\n\tksmbd_debug(SMB, \"nbytes %zu, offset %lld mincount %zu\\n\",\n\t\t    nbytes, offset, mincount);\n\n\tif (is_rdma_channel == true) {\n\t\t/* write data to the client using rdma channel */\n\t\tremain_bytes = smb2_read_rdma_channel(work, req,\n\t\t\t\t\t\t      work->aux_payload_buf,\n\t\t\t\t\t\t      nbytes);\n\t\tkvfree(work->aux_payload_buf);\n\t\twork->aux_payload_buf = NULL;\n\n\t\tnbytes = 0;\n\t\tif (remain_bytes < 0) {\n\t\t\terr = (int)remain_bytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 80;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = cpu_to_le32(remain_bytes);\n\trsp->Flags = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\twork->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;\n\twork->aux_payload_sz = nbytes;\n\tinc_rfc1001_len(work->response_buf, nbytes);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\tif (err == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_INVALID_DEVICE_REQUEST;\n\t\telse if (err == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse if (err == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (err == -ESHARE)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\t\tsmb2_set_err_rsp(work);\n\t}\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_write_pipe() - handler for smb2 write on IPC pipe\n * @work:\tsmb work containing write IPC pipe command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nstatic noinline int smb2_write_pipe(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_write_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tu64 id = 0;\n\tint err = 0, ret = 0;\n\tchar *data_buf;\n\tsize_t length;\n\n\tlength = le32_to_cpu(req->Length);\n\tid = req->VolatileFileId;\n\n\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t    get_rfc1002_len(work->request_buf)) {\n\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t       le16_to_cpu(req->DataOffset),\n\t\t       get_rfc1002_len(work->request_buf));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t   le16_to_cpu(req->DataOffset));\n\n\trpc_resp = ksmbd_rpc_write(work->sess, id, data_buf, length);\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tkvfree(rpc_resp);\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\t\tsmb2_set_err_rsp(work);\n\t\t\tkvfree(rpc_resp);\n\t\t\treturn ret;\n\t\t}\n\t\tkvfree(rpc_resp);\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(length);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\treturn 0;\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\nstatic ssize_t smb2_write_rdma_channel(struct ksmbd_work *work,\n\t\t\t\t       struct smb2_write_req *req,\n\t\t\t\t       struct ksmbd_file *fp,\n\t\t\t\t       loff_t offset, size_t length, bool sync)\n{\n\tchar *data_buf;\n\tint ret;\n\tssize_t nbytes;\n\n\tdata_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tret = ksmbd_conn_rdma_read(work->conn, data_buf, length,\n\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t   ((char *)req + le16_to_cpu(req->WriteChannelInfoOffset)),\n\t\t\t\t   le16_to_cpu(req->WriteChannelInfoLength));\n\tif (ret < 0) {\n\t\tkvfree(data_buf);\n\t\treturn ret;\n\t}\n\n\tret = ksmbd_vfs_write(work, fp, data_buf, length, &offset, sync, &nbytes);\n\tkvfree(data_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn nbytes;\n}\n\n/**\n * smb2_write() - handler for smb2 write from file\n * @work:\tsmb work containing write command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false, is_rdma_channel = false;\n\tint err = 0;\n\tunsigned int max_write_size = work->conn->vals->max_write_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tis_rdma_channel = true;\n\t\tmax_write_size = get_smbd_max_read_write_size();\n\t\tlength = le32_to_cpu(req->RemainingBytes);\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (length > max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (is_rdma_channel == false) {\n\t\tif (le16_to_cpu(req->DataOffset) <\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t    le16_to_cpu(req->DataOffset));\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset, length,\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * smb2_flush() - handler for smb2 flush file - fsync\n * @work:\tsmb work containing flush command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_flush(struct ksmbd_work *work)\n{\n\tstruct smb2_flush_req *req;\n\tstruct smb2_flush_rsp *rsp;\n\tint err;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tksmbd_debug(SMB, \"SMB2_FLUSH called for fid %llu\\n\", req->VolatileFileId);\n\n\terr = ksmbd_vfs_fsync(work, req->VolatileFileId, req->PersistentFileId);\n\tif (err)\n\t\tgoto out;\n\n\trsp->StructureSize = cpu_to_le16(4);\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\treturn 0;\n\nout:\n\tif (err) {\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn err;\n}\n\n/**\n * smb2_cancel() - handler for smb2 cancel command\n * @work:\tsmb work containing cancel command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_cancel(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tstruct smb2_hdr *chdr;\n\tstruct ksmbd_work *cancel_work = NULL, *iter;\n\tstruct list_head *command_list;\n\n\tksmbd_debug(SMB, \"smb2 cancel called on mid %llu, async flags 0x%x\\n\",\n\t\t    hdr->MessageId, hdr->Flags);\n\n\tif (hdr->Flags & SMB2_FLAGS_ASYNC_COMMAND) {\n\t\tcommand_list = &conn->async_requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list,\n\t\t\t\t    async_request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (iter->async_id !=\n\t\t\t    le64_to_cpu(hdr->Id.AsyncId))\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with AsyncId %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->Id.AsyncId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t} else {\n\t\tcommand_list = &conn->requests;\n\n\t\tspin_lock(&conn->request_lock);\n\t\tlist_for_each_entry(iter, command_list, request_entry) {\n\t\t\tchdr = smb2_get_msg(iter->request_buf);\n\n\t\t\tif (chdr->MessageId != hdr->MessageId ||\n\t\t\t    iter == work)\n\t\t\t\tcontinue;\n\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"smb2 with mid %llu cancelled command = 0x%x\\n\",\n\t\t\t\t    le64_to_cpu(hdr->MessageId),\n\t\t\t\t    le16_to_cpu(chdr->Command));\n\t\t\tcancel_work = iter;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&conn->request_lock);\n\t}\n\n\tif (cancel_work) {\n\t\tcancel_work->state = KSMBD_WORK_CANCELLED;\n\t\tif (cancel_work->cancel_fn)\n\t\t\tcancel_work->cancel_fn(cancel_work->cancel_argv);\n\t}\n\n\t/* For SMB2_CANCEL command itself send no response*/\n\twork->send_no_response = 1;\n\treturn 0;\n}\n\nstruct file_lock *smb_flock_init(struct file *f)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\tgoto out;\n\n\tlocks_init_lock(fl);\n\n\tfl->fl_owner = f;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = f;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\nout:\n\treturn fl;\n}\n\nstatic int smb2_set_flock_flags(struct file_lock *flock, int flags)\n{\n\tint cmd = -EINVAL;\n\n\t/* Checking for wrong flag combination during lock request*/\n\tswitch (flags) {\n\tcase SMB2_LOCKFLAG_SHARED:\n\t\tksmbd_debug(SMB, \"received shared request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_RDLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE:\n\t\tksmbd_debug(SMB, \"received exclusive request\\n\");\n\t\tcmd = F_SETLKW;\n\t\tflock->fl_type = F_WRLCK;\n\t\tflock->fl_flags |= FL_SLEEP;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_SHARED | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received shared & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_RDLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_FAIL_IMMEDIATELY:\n\t\tksmbd_debug(SMB,\n\t\t\t    \"received exclusive & fail immediately request\\n\");\n\t\tcmd = F_SETLK;\n\t\tflock->fl_type = F_WRLCK;\n\t\tbreak;\n\tcase SMB2_LOCKFLAG_UNLOCK:\n\t\tksmbd_debug(SMB, \"received unlock request\\n\");\n\t\tflock->fl_type = F_UNLCK;\n\t\tcmd = 0;\n\t\tbreak;\n\t}\n\n\treturn cmd;\n}\n\nstatic struct ksmbd_lock *smb2_lock_init(struct file_lock *flock,\n\t\t\t\t\t unsigned int cmd, int flags,\n\t\t\t\t\t struct list_head *lock_list)\n{\n\tstruct ksmbd_lock *lock;\n\n\tlock = kzalloc(sizeof(struct ksmbd_lock), GFP_KERNEL);\n\tif (!lock)\n\t\treturn NULL;\n\n\tlock->cmd = cmd;\n\tlock->fl = flock;\n\tlock->start = flock->fl_start;\n\tlock->end = flock->fl_end;\n\tlock->flags = flags;\n\tif (lock->start == lock->end)\n\t\tlock->zero_len = 1;\n\tINIT_LIST_HEAD(&lock->clist);\n\tINIT_LIST_HEAD(&lock->flist);\n\tINIT_LIST_HEAD(&lock->llist);\n\tlist_add_tail(&lock->llist, lock_list);\n\n\treturn lock;\n}\n\nstatic void smb2_remove_blocked_lock(void **argv)\n{\n\tstruct file_lock *flock = (struct file_lock *)argv[0];\n\n\tksmbd_vfs_posix_lock_unblock(flock);\n\twake_up(&flock->fl_wait);\n}\n\nstatic inline bool lock_defer_pending(struct file_lock *fl)\n{\n\t/* check pending lock waiters */\n\treturn waitqueue_active(&fl->fl_wait);\n}\n\n/**\n * smb2_lock() - handler for smb2 file lock command\n * @work:\tsmb work containing lock command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_lock(struct ksmbd_work *work)\n{\n\tstruct smb2_lock_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lock_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct smb2_lock_element *lock_ele;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file_lock *flock = NULL;\n\tstruct file *filp = NULL;\n\tint lock_count;\n\tint flags = 0;\n\tint cmd = 0;\n\tint err = -EIO, i, rc = 0;\n\tu64 lock_start, lock_length;\n\tstruct ksmbd_lock *smb_lock = NULL, *cmp_lock, *tmp, *tmp2;\n\tstruct ksmbd_conn *conn;\n\tint nolock = 0;\n\tLIST_HEAD(lock_list);\n\tLIST_HEAD(rollback_list);\n\tint prior_lock = 0;\n\n\tksmbd_debug(SMB, \"Received lock request\\n\");\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\tksmbd_debug(SMB, \"Invalid file id for lock : %llu\\n\", req->VolatileFileId);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\n\tfilp = fp->filp;\n\tlock_count = le16_to_cpu(req->LockCount);\n\tlock_ele = req->locks;\n\n\tksmbd_debug(SMB, \"lock count is %d\\n\", lock_count);\n\tif (!lock_count) {\n\t\terr = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\tfor (i = 0; i < lock_count; i++) {\n\t\tflags = le32_to_cpu(lock_ele[i].Flags);\n\n\t\tflock = smb_flock_init(filp);\n\t\tif (!flock)\n\t\t\tgoto out;\n\n\t\tcmd = smb2_set_flock_flags(flock, flags);\n\n\t\tlock_start = le64_to_cpu(lock_ele[i].Offset);\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_start > U64_MAX - lock_length) {\n\t\t\tpr_err(\"Invalid lock range requested\\n\");\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lock_start > OFFSET_MAX)\n\t\t\tflock->fl_start = OFFSET_MAX;\n\t\telse\n\t\t\tflock->fl_start = lock_start;\n\n\t\tlock_length = le64_to_cpu(lock_ele[i].Length);\n\t\tif (lock_length > OFFSET_MAX - flock->fl_start)\n\t\t\tlock_length = OFFSET_MAX - flock->fl_start;\n\n\t\tflock->fl_end = flock->fl_start + lock_length;\n\n\t\tif (flock->fl_end < flock->fl_start) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"the end offset(%llx) is smaller than the start offset(%llx)\\n\",\n\t\t\t\t    flock->fl_end, flock->fl_start);\n\t\t\trsp->hdr.Status = STATUS_INVALID_LOCK_RANGE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check conflict locks in one request */\n\t\tlist_for_each_entry(cmp_lock, &lock_list, llist) {\n\t\t\tif (cmp_lock->fl->fl_start <= flock->fl_start &&\n\t\t\t    cmp_lock->fl->fl_end >= flock->fl_end) {\n\t\t\t\tif (cmp_lock->fl->fl_type != F_UNLCK &&\n\t\t\t\t    flock->fl_type != F_UNLCK) {\n\t\t\t\t\tpr_err(\"conflict two locks in one request\\n\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsmb_lock = smb2_lock_init(flock, cmd, flags, &lock_list);\n\t\tif (!smb_lock) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tif (smb_lock->cmd < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_MASK)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((prior_lock & (SMB2_LOCKFLAG_EXCLUSIVE | SMB2_LOCKFLAG_SHARED) &&\n\t\t     smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) ||\n\t\t    (prior_lock == SMB2_LOCKFLAG_UNLOCK &&\n\t\t     !(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprior_lock = smb_lock->flags;\n\n\t\tif (!(smb_lock->flags & SMB2_LOCKFLAG_UNLOCK) &&\n\t\t    !(smb_lock->flags & SMB2_LOCKFLAG_FAIL_IMMEDIATELY))\n\t\t\tgoto no_check_cl;\n\n\t\tnolock = 1;\n\t\t/* check locks in connection list */\n\t\tread_lock(&conn_list_lock);\n\t\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\t\tspin_lock(&conn->llist_lock);\n\t\t\tlist_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {\n\t\t\t\tif (file_inode(cmp_lock->fl->fl_file) !=\n\t\t\t\t    file_inode(smb_lock->fl->fl_file))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (smb_lock->fl->fl_type == F_UNLCK) {\n\t\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file &&\n\t\t\t\t\t    cmp_lock->start == smb_lock->start &&\n\t\t\t\t\t    cmp_lock->end == smb_lock->end &&\n\t\t\t\t\t    !lock_defer_pending(cmp_lock->fl)) {\n\t\t\t\t\t\tnolock = 0;\n\t\t\t\t\t\tlist_del(&cmp_lock->flist);\n\t\t\t\t\t\tlist_del(&cmp_lock->clist);\n\t\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\t\tread_unlock(&conn_list_lock);\n\n\t\t\t\t\t\tlocks_free_lock(cmp_lock->fl);\n\t\t\t\t\t\tkfree(cmp_lock);\n\t\t\t\t\t\tgoto out_check_cl;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cmp_lock->fl->fl_file == smb_lock->fl->fl_file) {\n\t\t\t\t\tif (smb_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tif (cmp_lock->flags & SMB2_LOCKFLAG_SHARED)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* check zero byte lock range */\n\t\t\t\tif (cmp_lock->zero_len && !smb_lock->zero_len &&\n\t\t\t\t    cmp_lock->start > smb_lock->start &&\n\t\t\t\t    cmp_lock->start < smb_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"previous lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (smb_lock->zero_len && !cmp_lock->zero_len &&\n\t\t\t\t    smb_lock->start > cmp_lock->start &&\n\t\t\t\t    smb_lock->start < cmp_lock->end) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"current lock conflict with zero byte lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (((cmp_lock->start <= smb_lock->start &&\n\t\t\t\t      cmp_lock->end > smb_lock->start) ||\n\t\t\t\t     (cmp_lock->start < smb_lock->end &&\n\t\t\t\t      cmp_lock->end >= smb_lock->end)) &&\n\t\t\t\t    !cmp_lock->zero_len && !smb_lock->zero_len) {\n\t\t\t\t\tspin_unlock(&conn->llist_lock);\n\t\t\t\t\tread_unlock(&conn_list_lock);\n\t\t\t\t\tpr_err(\"Not allow lock operation on exclusive lock range\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&conn->llist_lock);\n\t\t}\n\t\tread_unlock(&conn_list_lock);\nout_check_cl:\n\t\tif (smb_lock->fl->fl_type == F_UNLCK && nolock) {\n\t\t\tpr_err(\"Try to unlock nolocked range\\n\");\n\t\t\trsp->hdr.Status = STATUS_RANGE_NOT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\nno_check_cl:\n\t\tif (smb_lock->zero_len) {\n\t\t\terr = 0;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tflock = smb_lock->fl;\n\t\tlist_del(&smb_lock->llist);\nretry:\n\t\trc = vfs_lock_file(filp, smb_lock->cmd, flock, NULL);\nskip:\n\t\tif (flags & SMB2_LOCKFLAG_UNLOCK) {\n\t\t\tif (!rc) {\n\t\t\t\tksmbd_debug(SMB, \"File unlocked\\n\");\n\t\t\t} else if (rc == -ENOENT) {\n\t\t\t\trsp->hdr.Status = STATUS_NOT_LOCKED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlocks_free_lock(flock);\n\t\t\tkfree(smb_lock);\n\t\t} else {\n\t\t\tif (rc == FILE_LOCK_DEFERRED) {\n\t\t\t\tvoid **argv;\n\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"would have to wait for getting lock\\n\");\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\n\t\t\t\targv = kmalloc(sizeof(void *), GFP_KERNEL);\n\t\t\t\tif (!argv) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\targv[0] = flock;\n\n\t\t\t\trc = setup_async_work(work,\n\t\t\t\t\t\t      smb2_remove_blocked_lock,\n\t\t\t\t\t\t      argv);\n\t\t\t\tif (rc) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_add(&work->fp_entry, &fp->blocked_works);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\n\t\t\t\tsmb2_send_interim_resp(work, STATUS_PENDING);\n\n\t\t\t\tksmbd_vfs_posix_lock_wait(flock);\n\n\t\t\t\tif (work->state != KSMBD_WORK_ACTIVE) {\n\t\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\t\tlocks_free_lock(flock);\n\n\t\t\t\t\tif (work->state == KSMBD_WORK_CANCELLED) {\n\t\t\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\t\tSTATUS_CANCELLED;\n\t\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\t\tsmb2_send_interim_resp(work,\n\t\t\t\t\t\t\t\t       STATUS_CANCELLED);\n\t\t\t\t\t\twork->send_no_response = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tinit_smb2_rsp_hdr(work);\n\t\t\t\t\tsmb2_set_err_rsp(work);\n\t\t\t\t\trsp->hdr.Status =\n\t\t\t\t\t\tSTATUS_RANGE_NOT_LOCKED;\n\t\t\t\t\tkfree(smb_lock);\n\t\t\t\t\tgoto out2;\n\t\t\t\t}\n\n\t\t\t\tlist_del(&smb_lock->llist);\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_del(&smb_lock->clist);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\t\t\tspin_lock(&fp->f_lock);\n\t\t\t\tlist_del(&work->fp_entry);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\tgoto retry;\n\t\t\t} else if (!rc) {\n\t\t\t\tspin_lock(&work->conn->llist_lock);\n\t\t\t\tlist_add_tail(&smb_lock->clist,\n\t\t\t\t\t      &work->conn->lock_list);\n\t\t\t\tlist_add_tail(&smb_lock->flist,\n\t\t\t\t\t      &fp->lock_list);\n\t\t\t\tspin_unlock(&work->conn->llist_lock);\n\t\t\t\tlist_add(&smb_lock->llist, &rollback_list);\n\t\t\t\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (atomic_read(&fp->f_ci->op_count) > 1)\n\t\tsmb_break_all_oplock(work, fp);\n\n\trsp->StructureSize = cpu_to_le16(4);\n\tksmbd_debug(SMB, \"successful in taking lock\\n\");\n\trsp->hdr.Status = STATUS_SUCCESS;\n\trsp->Reserved = 0;\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tlist_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlist_del(&smb_lock->llist);\n\t\tkfree(smb_lock);\n\t}\n\n\tlist_for_each_entry_safe(smb_lock, tmp, &rollback_list, llist) {\n\t\tstruct file_lock *rlock = NULL;\n\n\t\trlock = smb_flock_init(filp);\n\t\trlock->fl_type = F_UNLCK;\n\t\trlock->fl_start = smb_lock->start;\n\t\trlock->fl_end = smb_lock->end;\n\n\t\trc = vfs_lock_file(filp, 0, rlock, NULL);\n\t\tif (rc)\n\t\t\tpr_err(\"rollback unlock fail : %d\\n\", rc);\n\n\t\tlist_del(&smb_lock->llist);\n\t\tspin_lock(&work->conn->llist_lock);\n\t\tif (!list_empty(&smb_lock->flist))\n\t\t\tlist_del(&smb_lock->flist);\n\t\tlist_del(&smb_lock->clist);\n\t\tspin_unlock(&work->conn->llist_lock);\n\n\t\tlocks_free_lock(smb_lock->fl);\n\t\tlocks_free_lock(rlock);\n\t\tkfree(smb_lock);\n\t}\nout2:\n\tksmbd_debug(SMB, \"failed in taking lock(flags : %x), err : %d\\n\", flags, err);\n\n\tif (!rsp->hdr.Status) {\n\t\tif (err == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (err == -ENOMEM)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\telse if (err == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_LOCK_NOT_GRANTED;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\nstatic int fsctl_copychunk(struct ksmbd_work *work,\n\t\t\t   struct copychunk_ioctl_req *ci_req,\n\t\t\t   unsigned int cnt_code,\n\t\t\t   unsigned int input_count,\n\t\t\t   unsigned long long volatile_id,\n\t\t\t   unsigned long long persistent_id,\n\t\t\t   struct smb2_ioctl_rsp *rsp)\n{\n\tstruct copychunk_ioctl_rsp *ci_rsp;\n\tstruct ksmbd_file *src_fp = NULL, *dst_fp = NULL;\n\tstruct srv_copychunk *chunks;\n\tunsigned int i, chunk_count, chunk_count_written = 0;\n\tunsigned int chunk_size_written = 0;\n\tloff_t total_size_written = 0;\n\tint ret = 0;\n\n\tci_rsp = (struct copychunk_ioctl_rsp *)&rsp->Buffer[0];\n\n\trsp->VolatileFileId = volatile_id;\n\trsp->PersistentFileId = persistent_id;\n\tci_rsp->ChunksWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_count());\n\tci_rsp->ChunkBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_chunk_size());\n\tci_rsp->TotalBytesWritten =\n\t\tcpu_to_le32(ksmbd_server_side_copy_max_total_size());\n\n\tchunks = (struct srv_copychunk *)&ci_req->Chunks[0];\n\tchunk_count = le32_to_cpu(ci_req->ChunkCount);\n\tif (chunk_count == 0)\n\t\tgoto out;\n\ttotal_size_written = 0;\n\n\t/* verify the SRV_COPYCHUNK_COPY packet */\n\tif (chunk_count > ksmbd_server_side_copy_max_chunk_count() ||\n\t    input_count < offsetof(struct copychunk_ioctl_req, Chunks) +\n\t     chunk_count * sizeof(struct srv_copychunk)) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tif (le32_to_cpu(chunks[i].Length) == 0 ||\n\t\t    le32_to_cpu(chunks[i].Length) > ksmbd_server_side_copy_max_chunk_size())\n\t\t\tbreak;\n\t\ttotal_size_written += le32_to_cpu(chunks[i].Length);\n\t}\n\n\tif (i < chunk_count ||\n\t    total_size_written > ksmbd_server_side_copy_max_total_size()) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_fp = ksmbd_lookup_foreign_fd(work,\n\t\t\t\t\t le64_to_cpu(ci_req->ResumeKey[0]));\n\tdst_fp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tret = -EINVAL;\n\tif (!src_fp ||\n\t    src_fp->persistent_id != le64_to_cpu(ci_req->ResumeKey[1])) {\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\tgoto out;\n\t}\n\n\tif (!dst_fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FILE_READ_DATA should only be included in\n\t * the FSCTL_COPYCHUNK case\n\t */\n\tif (cnt_code == FSCTL_COPYCHUNK &&\n\t    !(dst_fp->daccess & (FILE_READ_DATA_LE | FILE_GENERIC_READ_LE))) {\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tgoto out;\n\t}\n\n\tret = ksmbd_vfs_copy_file_ranges(work, src_fp, dst_fp,\n\t\t\t\t\t chunks, chunk_count,\n\t\t\t\t\t &chunk_count_written,\n\t\t\t\t\t &chunk_size_written,\n\t\t\t\t\t &total_size_written);\n\tif (ret < 0) {\n\t\tif (ret == -EACCES)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\tif (ret == -EAGAIN)\n\t\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\t\telse if (ret == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\t\telse if (ret == -EFBIG || ret == -ENOSPC)\n\t\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\t\telse if (ret == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (ret == -EISDIR)\n\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\telse if (ret == -E2BIG)\n\t\t\trsp->hdr.Status = STATUS_INVALID_VIEW_SIZE;\n\t\telse\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\t}\n\n\tci_rsp->ChunksWritten = cpu_to_le32(chunk_count_written);\n\tci_rsp->ChunkBytesWritten = cpu_to_le32(chunk_size_written);\n\tci_rsp->TotalBytesWritten = cpu_to_le32(total_size_written);\nout:\n\tksmbd_fd_put(work, src_fp);\n\tksmbd_fd_put(work, dst_fp);\n\treturn ret;\n}\n\nstatic __be32 idev_ipv4_address(struct in_device *idev)\n{\n\t__be32 addr = 0;\n\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, idev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\taddr = ifa->ifa_address;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int fsctl_query_iface_info_ioctl(struct ksmbd_conn *conn,\n\t\t\t\t\tstruct smb2_ioctl_rsp *rsp,\n\t\t\t\t\tunsigned int out_buf_len)\n{\n\tstruct network_interface_info_ioctl_rsp *nii_rsp = NULL;\n\tint nbytes = 0;\n\tstruct net_device *netdev;\n\tstruct sockaddr_storage_rsp *sockaddr_storage;\n\tunsigned int flags;\n\tunsigned long long speed;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, netdev) {\n\t\tbool ipv4_set = false;\n\n\t\tif (netdev->type == ARPHRD_LOOPBACK)\n\t\t\tcontinue;\n\n\t\tflags = dev_get_flags(netdev);\n\t\tif (!(flags & IFF_RUNNING))\n\t\t\tcontinue;\nipv6_retry:\n\t\tif (out_buf_len <\n\t\t    nbytes + sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tnii_rsp = (struct network_interface_info_ioctl_rsp *)\n\t\t\t\t&rsp->Buffer[nbytes];\n\t\tnii_rsp->IfIndex = cpu_to_le32(netdev->ifindex);\n\n\t\tnii_rsp->Capability = 0;\n\t\tif (netdev->real_num_tx_queues > 1)\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RSS_CAPABLE);\n\t\tif (ksmbd_rdma_capable_netdev(netdev))\n\t\t\tnii_rsp->Capability |= cpu_to_le32(RDMA_CAPABLE);\n\n\t\tnii_rsp->Next = cpu_to_le32(152);\n\t\tnii_rsp->Reserved = 0;\n\n\t\tif (netdev->ethtool_ops->get_link_ksettings) {\n\t\t\tstruct ethtool_link_ksettings cmd;\n\n\t\t\tnetdev->ethtool_ops->get_link_ksettings(netdev, &cmd);\n\t\t\tspeed = cmd.base.speed;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"%s %s\\n\", netdev->name,\n\t\t\t\t    \"speed is unknown, defaulting to 1Gb/sec\");\n\t\t\tspeed = SPEED_1000;\n\t\t}\n\n\t\tspeed *= 1000000;\n\t\tnii_rsp->LinkSpeed = cpu_to_le64(speed);\n\n\t\tsockaddr_storage = (struct sockaddr_storage_rsp *)\n\t\t\t\t\tnii_rsp->SockAddr_Storage;\n\t\tmemset(sockaddr_storage, 0, 128);\n\n\t\tif (!ipv4_set) {\n\t\t\tstruct in_device *idev;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORK);\n\t\t\tsockaddr_storage->addr4.Port = 0;\n\n\t\t\tidev = __in_dev_get_rtnl(netdev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\t\t\tsockaddr_storage->addr4.IPv4address =\n\t\t\t\t\t\tidev_ipv4_address(idev);\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t\tipv4_set = true;\n\t\t\tgoto ipv6_retry;\n\t\t} else {\n\t\t\tstruct inet6_dev *idev6;\n\t\t\tstruct inet6_ifaddr *ifa;\n\t\t\t__u8 *ipv6_addr = sockaddr_storage->addr6.IPv6address;\n\n\t\t\tsockaddr_storage->Family = cpu_to_le16(INTERNETWORKV6);\n\t\t\tsockaddr_storage->addr6.Port = 0;\n\t\t\tsockaddr_storage->addr6.FlowInfo = 0;\n\n\t\t\tidev6 = __in6_dev_get(netdev);\n\t\t\tif (!idev6)\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(ifa, &idev6->addr_list, if_list) {\n\t\t\t\tif (ifa->flags & (IFA_F_TENTATIVE |\n\t\t\t\t\t\t\tIFA_F_DEPRECATED))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(ipv6_addr, ifa->addr.s6_addr, 16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsockaddr_storage->addr6.ScopeId = 0;\n\t\t\tnbytes += sizeof(struct network_interface_info_ioctl_rsp);\n\t\t}\n\t}\n\trtnl_unlock();\n\n\t/* zero if this is last one */\n\tif (nii_rsp)\n\t\tnii_rsp->Next = 0;\n\n\trsp->PersistentFileId = SMB2_NO_FID;\n\trsp->VolatileFileId = SMB2_NO_FID;\n\treturn nbytes;\n}\n\nstatic int fsctl_validate_negotiate_info(struct ksmbd_conn *conn,\n\t\t\t\t\t struct validate_negotiate_info_req *neg_req,\n\t\t\t\t\t struct validate_negotiate_info_rsp *neg_rsp,\n\t\t\t\t\t unsigned int in_buf_len)\n{\n\tint ret = 0;\n\tint dialect;\n\n\tif (in_buf_len < offsetof(struct validate_negotiate_info_req, Dialects) +\n\t\t\tle16_to_cpu(neg_req->DialectCount) * sizeof(__le16))\n\t\treturn -EINVAL;\n\n\tdialect = ksmbd_lookup_dialect_by_id(neg_req->Dialects,\n\t\t\t\t\t     neg_req->DialectCount);\n\tif (dialect == BAD_PROT_ID || dialect != conn->dialect) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (strncmp(neg_req->Guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le16_to_cpu(neg_req->SecurityMode) != conn->cli_sec_mode) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (le32_to_cpu(neg_req->Capabilities) != conn->cli_cap) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tneg_rsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\tmemset(neg_rsp->Guid, 0, SMB2_CLIENT_GUID_SIZE);\n\tneg_rsp->SecurityMode = cpu_to_le16(conn->srv_sec_mode);\n\tneg_rsp->Dialect = cpu_to_le16(conn->dialect);\nerr_out:\n\treturn ret;\n}\n\nstatic int fsctl_query_allocated_ranges(struct ksmbd_work *work, u64 id,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_req,\n\t\t\t\t\tstruct file_allocated_range_buffer *qar_rsp,\n\t\t\t\t\tunsigned int in_count, unsigned int *out_count)\n{\n\tstruct ksmbd_file *fp;\n\tloff_t start, length;\n\tint ret = 0;\n\n\t*out_count = 0;\n\tif (in_count == 0)\n\t\treturn -EINVAL;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tstart = le64_to_cpu(qar_req->file_offset);\n\tlength = le64_to_cpu(qar_req->length);\n\n\tret = ksmbd_vfs_fqar_lseek(fp, start, length,\n\t\t\t\t   qar_rsp, in_count, out_count);\n\tif (ret && ret != -E2BIG)\n\t\t*out_count = 0;\n\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_pipe_transceive(struct ksmbd_work *work, u64 id,\n\t\t\t\t unsigned int out_buf_len,\n\t\t\t\t struct smb2_ioctl_req *req,\n\t\t\t\t struct smb2_ioctl_rsp *rsp)\n{\n\tstruct ksmbd_rpc_command *rpc_resp;\n\tchar *data_buf = (char *)&req->Buffer[0];\n\tint nbytes = 0;\n\n\trpc_resp = ksmbd_rpc_ioctl(work->sess, id, data_buf,\n\t\t\t\t   le32_to_cpu(req->InputCount));\n\tif (rpc_resp) {\n\t\tif (rpc_resp->flags == KSMBD_RPC_SOME_NOT_MAPPED) {\n\t\t\t/*\n\t\t\t * set STATUS_SOME_NOT_MAPPED response\n\t\t\t * for unknown domain sid.\n\t\t\t */\n\t\t\trsp->hdr.Status = STATUS_SOME_NOT_MAPPED;\n\t\t} else if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t} else if (rpc_resp->flags != KSMBD_RPC_OK) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = rpc_resp->payload_sz;\n\t\tif (rpc_resp->payload_sz > out_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t\tnbytes = out_buf_len;\n\t\t}\n\n\t\tif (!rpc_resp->payload_sz) {\n\t\t\trsp->hdr.Status =\n\t\t\t\tSTATUS_UNEXPECTED_IO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy((char *)rsp->Buffer, rpc_resp->payload, nbytes);\n\t}\nout:\n\tkvfree(rpc_resp);\n\treturn nbytes;\n}\n\nstatic inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,\n\t\t\t\t   struct file_sparse *sparse)\n{\n\tstruct ksmbd_file *fp;\n\tstruct user_namespace *user_ns;\n\tint ret = 0;\n\t__le32 old_fattr;\n\n\tfp = ksmbd_lookup_fd_fast(work, id);\n\tif (!fp)\n\t\treturn -ENOENT;\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\n\told_fattr = fp->f_ci->m_fattr;\n\tif (sparse->SetSparse)\n\t\tfp->f_ci->m_fattr |= FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\telse\n\t\tfp->f_ci->m_fattr &= ~FILE_ATTRIBUTE_SPARSE_FILE_LE;\n\n\tif (fp->f_ci->m_fattr != old_fattr &&\n\t    test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\tret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\n\t\tda.attr = le32_to_cpu(fp->f_ci->m_fattr);\n\t\tret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,\n\t\t\t\t\t\t     fp->filp->f_path.dentry, &da);\n\t\tif (ret)\n\t\t\tfp->f_ci->m_fattr = old_fattr;\n\t}\n\nout:\n\tksmbd_fd_put(work, fp);\n\treturn ret;\n}\n\nstatic int fsctl_request_resume_key(struct ksmbd_work *work,\n\t\t\t\t    struct smb2_ioctl_req *req,\n\t\t\t\t    struct resume_key_ioctl_rsp *key_rsp)\n{\n\tstruct ksmbd_file *fp;\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp)\n\t\treturn -ENOENT;\n\n\tmemset(key_rsp, 0, sizeof(*key_rsp));\n\tkey_rsp->ResumeKey[0] = req->VolatileFileId;\n\tkey_rsp->ResumeKey[1] = req->PersistentFileId;\n\tksmbd_fd_put(work, fp);\n\n\treturn 0;\n}\n\n/**\n * smb2_ioctl() - handler for smb2 ioctl command\n * @work:\tsmb work containing ioctl command buffer\n *\n * Return:\t0 on success, otherwise error\n */\nint smb2_ioctl(struct ksmbd_work *work)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tunsigned int cnt_code, nbytes = 0, out_buf_len, in_buf_len;\n\tu64 id = KSMBD_NO_FID;\n\tstruct ksmbd_conn *conn = work->conn;\n\tint ret = 0;\n\n\tif (work->next_smb2_rcv_hdr_off) {\n\t\treq = ksmbd_req_buf_next(work);\n\t\trsp = ksmbd_resp_buf_next(work);\n\t\tif (!has_file_id(req->VolatileFileId)) {\n\t\t\tksmbd_debug(SMB, \"Compound request set FID = %llu\\n\",\n\t\t\t\t    work->compound_fid);\n\t\t\tid = work->compound_fid;\n\t\t}\n\t} else {\n\t\treq = smb2_get_msg(work->request_buf);\n\t\trsp = smb2_get_msg(work->response_buf);\n\t}\n\n\tif (!has_file_id(id))\n\t\tid = req->VolatileFileId;\n\n\tif (req->Flags != cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL)) {\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tcnt_code = le32_to_cpu(req->CtlCode);\n\tret = smb2_calc_max_out_buf_len(work, 48,\n\t\t\t\t\tle32_to_cpu(req->MaxOutputResponse));\n\tif (ret < 0) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tgoto out;\n\t}\n\tout_buf_len = (unsigned int)ret;\n\tin_buf_len = le32_to_cpu(req->InputCount);\n\n\tswitch (cnt_code) {\n\tcase FSCTL_DFS_GET_REFERRALS:\n\tcase FSCTL_DFS_GET_REFERRALS_EX:\n\t\t/* Not support DFS yet */\n\t\trsp->hdr.Status = STATUS_FS_DRIVER_REQUIRED;\n\t\tgoto out;\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tstruct file_object_buf_type1_ioctl_rsp *obj_buf;\n\n\t\tnbytes = sizeof(struct file_object_buf_type1_ioctl_rsp);\n\t\tobj_buf = (struct file_object_buf_type1_ioctl_rsp *)\n\t\t\t&rsp->Buffer[0];\n\n\t\t/*\n\t\t * TODO: This is dummy implementation to pass smbtorture\n\t\t * Need to check correct response later\n\t\t */\n\t\tmemset(obj_buf->ObjectId, 0x0, 16);\n\t\tmemset(obj_buf->BirthVolumeId, 0x0, 16);\n\t\tmemset(obj_buf->BirthObjectId, 0x0, 16);\n\t\tmemset(obj_buf->DomainId, 0x0, 16);\n\n\t\tbreak;\n\t}\n\tcase FSCTL_PIPE_TRANSCEIVE:\n\t\tout_buf_len = min_t(u32, KSMBD_IPC_MAX_PAYLOAD, out_buf_len);\n\t\tnbytes = fsctl_pipe_transceive(work, id, out_buf_len, req, rsp);\n\t\tbreak;\n\tcase FSCTL_VALIDATE_NEGOTIATE_INFO:\n\t\tif (conn->dialect < SMB30_PROT_ID) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct validate_negotiate_info_req))\n\t\t\treturn -EINVAL;\n\n\t\tif (out_buf_len < sizeof(struct validate_negotiate_info_rsp))\n\t\t\treturn -EINVAL;\n\n\t\tret = fsctl_validate_negotiate_info(conn,\n\t\t\t(struct validate_negotiate_info_req *)&req->Buffer[0],\n\t\t\t(struct validate_negotiate_info_rsp *)&rsp->Buffer[0],\n\t\t\tin_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tnbytes = sizeof(struct validate_negotiate_info_rsp);\n\t\trsp->PersistentFileId = SMB2_NO_FID;\n\t\trsp->VolatileFileId = SMB2_NO_FID;\n\t\tbreak;\n\tcase FSCTL_QUERY_NETWORK_INTERFACE_INFO:\n\t\tret = fsctl_query_iface_info_ioctl(conn, rsp, out_buf_len);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnbytes = ret;\n\t\tbreak;\n\tcase FSCTL_REQUEST_RESUME_KEY:\n\t\tif (out_buf_len < sizeof(struct resume_key_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_request_resume_key(work, req,\n\t\t\t\t\t       (struct resume_key_ioctl_rsp *)&rsp->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\tnbytes = sizeof(struct resume_key_ioctl_rsp);\n\t\tbreak;\n\tcase FSCTL_COPYCHUNK:\n\tcase FSCTL_COPYCHUNK_WRITE:\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct copychunk_ioctl_req)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (out_buf_len < sizeof(struct copychunk_ioctl_rsp)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes = sizeof(struct copychunk_ioctl_rsp);\n\t\trsp->VolatileFileId = req->VolatileFileId;\n\t\trsp->PersistentFileId = req->PersistentFileId;\n\t\tfsctl_copychunk(work,\n\t\t\t\t(struct copychunk_ioctl_req *)&req->Buffer[0],\n\t\t\t\tle32_to_cpu(req->CtlCode),\n\t\t\t\tle32_to_cpu(req->InputCount),\n\t\t\t\treq->VolatileFileId,\n\t\t\t\treq->PersistentFileId,\n\t\t\t\trsp);\n\t\tbreak;\n\tcase FSCTL_SET_SPARSE:\n\t\tif (in_buf_len < sizeof(struct file_sparse)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_set_sparse(work, id,\n\t\t\t\t       (struct file_sparse *)&req->Buffer[0]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase FSCTL_SET_ZERO_DATA:\n\t{\n\t\tstruct file_zero_data_information *zero_data;\n\t\tstruct ksmbd_file *fp;\n\t\tloff_t off, len, bfz;\n\n\t\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (in_buf_len < sizeof(struct file_zero_data_information)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzero_data =\n\t\t\t(struct file_zero_data_information *)&req->Buffer[0];\n\n\t\toff = le64_to_cpu(zero_data->FileOffset);\n\t\tbfz = le64_to_cpu(zero_data->BeyondFinalZero);\n\t\tif (off > bfz) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen = bfz - off;\n\t\tif (len) {\n\t\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\t\tif (!fp) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ksmbd_vfs_zero_data(work, fp, off, len);\n\t\t\tksmbd_fd_put(work, fp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t\tif (in_buf_len < sizeof(struct file_allocated_range_buffer)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fsctl_query_allocated_ranges(work, id,\n\t\t\t(struct file_allocated_range_buffer *)&req->Buffer[0],\n\t\t\t(struct file_allocated_range_buffer *)&rsp->Buffer[0],\n\t\t\tout_buf_len /\n\t\t\tsizeof(struct file_allocated_range_buffer), &nbytes);\n\t\tif (ret == -E2BIG) {\n\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;\n\t\t} else if (ret < 0) {\n\t\t\tnbytes = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnbytes *= sizeof(struct file_allocated_range_buffer);\n\t\tbreak;\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tstruct reparse_data_buffer *reparse_ptr;\n\t\tstruct ksmbd_file *fp;\n\n\t\treparse_ptr = (struct reparse_data_buffer *)&rsp->Buffer[0];\n\t\tfp = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp) {\n\t\t\tpr_err(\"not found fp!!\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treparse_ptr->ReparseTag =\n\t\t\tsmb2_get_reparse_tag_special_file(file_inode(fp->filp)->i_mode);\n\t\treparse_ptr->ReparseDataLength = 0;\n\t\tksmbd_fd_put(work, fp);\n\t\tnbytes = sizeof(struct reparse_data_buffer);\n\t\tbreak;\n\t}\n\tcase FSCTL_DUPLICATE_EXTENTS_TO_FILE:\n\t{\n\t\tstruct ksmbd_file *fp_in, *fp_out = NULL;\n\t\tstruct duplicate_extents_to_file *dup_ext;\n\t\tloff_t src_off, dst_off, length, cloned;\n\n\t\tif (in_buf_len < sizeof(struct duplicate_extents_to_file)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdup_ext = (struct duplicate_extents_to_file *)&req->Buffer[0];\n\n\t\tfp_in = ksmbd_lookup_fd_slow(work, dup_ext->VolatileFileHandle,\n\t\t\t\t\t     dup_ext->PersistentFileHandle);\n\t\tif (!fp_in) {\n\t\t\tpr_err(\"not found file handle in duplicate extent to file\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfp_out = ksmbd_lookup_fd_fast(work, id);\n\t\tif (!fp_out) {\n\t\t\tpr_err(\"not found fp\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto dup_ext_out;\n\t\t}\n\n\t\tsrc_off = le64_to_cpu(dup_ext->SourceFileOffset);\n\t\tdst_off = le64_to_cpu(dup_ext->TargetFileOffset);\n\t\tlength = le64_to_cpu(dup_ext->ByteCount);\n\t\t/*\n\t\t * XXX: It is not clear if FSCTL_DUPLICATE_EXTENTS_TO_FILE\n\t\t * should fall back to vfs_copy_file_range().  This could be\n\t\t * beneficial when re-exporting nfs/smb mount, but note that\n\t\t * this can result in partial copy that returns an error status.\n\t\t * If/when FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX is implemented,\n\t\t * fall back to vfs_copy_file_range(), should be avoided when\n\t\t * the flag DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC is set.\n\t\t */\n\t\tcloned = vfs_clone_file_range(fp_in->filp, src_off,\n\t\t\t\t\t      fp_out->filp, dst_off, length, 0);\n\t\tif (cloned == -EXDEV || cloned == -EOPNOTSUPP) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto dup_ext_out;\n\t\t} else if (cloned != length) {\n\t\t\tcloned = vfs_copy_file_range(fp_in->filp, src_off,\n\t\t\t\t\t\t     fp_out->filp, dst_off,\n\t\t\t\t\t\t     length, 0);\n\t\t\tif (cloned != length) {\n\t\t\t\tif (cloned < 0)\n\t\t\t\t\tret = cloned;\n\t\t\t\telse\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\ndup_ext_out:\n\t\tksmbd_fd_put(work, fp_in);\n\t\tksmbd_fd_put(work, fp_out);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tksmbd_debug(SMB, \"not implemented yet ioctl command 0x%x\\n\",\n\t\t\t    cnt_code);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trsp->CtlCode = cpu_to_le32(cnt_code);\n\trsp->InputCount = cpu_to_le32(0);\n\trsp->InputOffset = cpu_to_le32(112);\n\trsp->OutputOffset = cpu_to_le32(112);\n\trsp->OutputCount = cpu_to_le32(nbytes);\n\trsp->StructureSize = cpu_to_le16(49);\n\trsp->Reserved = cpu_to_le16(0);\n\trsp->Flags = cpu_to_le32(0);\n\trsp->Reserved2 = cpu_to_le32(0);\n\tinc_rfc1001_len(work->response_buf, 48 + nbytes);\n\n\treturn 0;\n\nout:\n\tif (ret == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (ret == -ENOENT)\n\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\telse if (ret == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\telse if (ret == -ENOSPC)\n\t\trsp->hdr.Status = STATUS_BUFFER_TOO_SMALL;\n\telse if (ret < 0 || rsp->hdr.Status == 0)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\tsmb2_set_err_rsp(work);\n\treturn 0;\n}\n\n/**\n * smb20_oplock_break_ack() - handler for smb2.0 oplock break command\n * @work:\tsmb work containing oplock break command buffer\n *\n * Return:\t0\n */\nstatic void smb20_oplock_break_ack(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_file *fp;\n\tstruct oplock_info *opinfo = NULL;\n\t__le32 err = 0;\n\tint ret = 0;\n\tu64 volatile_id, persistent_id;\n\tchar req_oplevel = 0, rsp_oplevel = 0;\n\tunsigned int oplock_change_type;\n\n\tvolatile_id = req->VolatileFid;\n\tpersistent_id = req->PersistentFid;\n\treq_oplevel = req->OplockLevel;\n\tksmbd_debug(OPLOCK, \"v_id %llu, p_id %llu request oplock level %d\\n\",\n\t\t    volatile_id, persistent_id, req_oplevel);\n\n\tfp = ksmbd_lookup_fd_slow(work, volatile_id, persistent_id);\n\tif (!fp) {\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn;\n\t}\n\n\topinfo = opinfo_get(fp);\n\tif (!opinfo) {\n\t\tpr_err(\"unexpected null oplock_info\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_fd_put(work, fp);\n\t\treturn;\n\t}\n\n\tif (opinfo->level == SMB2_OPLOCK_LEVEL_NONE) {\n\t\trsp->hdr.Status = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tgoto err_out;\n\t}\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tksmbd_debug(SMB, \"unexpected oplock state 0x%x\\n\", opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t    (req_oplevel != SMB2_OPLOCK_LEVEL_II &&\n\t     req_oplevel != SMB2_OPLOCK_LEVEL_NONE)) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t   req_oplevel != SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t} else if (req_oplevel == SMB2_OPLOCK_LEVEL_II ||\n\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t     opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t    req_oplevel == SMB2_OPLOCK_LEVEL_II) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_READ;\n\t\t} else if ((opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE ||\n\t\t\t    opinfo->level == SMB2_OPLOCK_LEVEL_BATCH) &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t} else if (opinfo->level == SMB2_OPLOCK_LEVEL_II &&\n\t\t\t   req_oplevel == SMB2_OPLOCK_LEVEL_NONE) {\n\t\t\toplock_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else {\n\t\t\toplock_change_type = 0;\n\t\t}\n\t} else {\n\t\toplock_change_type = 0;\n\t}\n\n\tswitch (oplock_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_II;\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\trsp_oplevel = SMB2_OPLOCK_LEVEL_NONE;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown oplock change 0x%x -> 0x%x\\n\",\n\t\t       opinfo->level, rsp_oplevel);\n\t}\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\trsp->StructureSize = cpu_to_le16(24);\n\trsp->OplockLevel = rsp_oplevel;\n\trsp->Reserved = 0;\n\trsp->Reserved2 = 0;\n\trsp->VolatileFid = volatile_id;\n\trsp->PersistentFid = persistent_id;\n\tinc_rfc1001_len(work->response_buf, 24);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\n\topinfo_put(opinfo);\n\tksmbd_fd_put(work, fp);\n\tsmb2_set_err_rsp(work);\n}\n\nstatic int check_lease_state(struct lease *lease, __le32 req_state)\n{\n\tif ((lease->new_state ==\n\t     (SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE)) &&\n\t    !(req_state & SMB2_LEASE_WRITE_CACHING_LE)) {\n\t\tlease->new_state = req_state;\n\t\treturn 0;\n\t}\n\n\tif (lease->new_state == req_state)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * smb21_lease_break_ack() - handler for smb2.1 lease break command\n * @work:\tsmb work containing lease break command buffer\n *\n * Return:\t0\n */\nstatic void smb21_lease_break_ack(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_lease_ack *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_lease_ack *rsp = smb2_get_msg(work->response_buf);\n\tstruct oplock_info *opinfo;\n\t__le32 err = 0;\n\tint ret = 0;\n\tunsigned int lease_change_type;\n\t__le32 lease_state;\n\tstruct lease *lease;\n\n\tksmbd_debug(OPLOCK, \"smb21 lease break, lease state(0x%x)\\n\",\n\t\t    le32_to_cpu(req->LeaseState));\n\topinfo = lookup_lease_in_table(conn, req->LeaseKey);\n\tif (!opinfo) {\n\t\tksmbd_debug(OPLOCK, \"file not opened\\n\");\n\t\tsmb2_set_err_rsp(work);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\treturn;\n\t}\n\tlease = opinfo->o_lease;\n\n\tif (opinfo->op_state == OPLOCK_STATE_NONE) {\n\t\tpr_err(\"unexpected lease break state 0x%x\\n\",\n\t\t       opinfo->op_state);\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\tif (check_lease_state(lease, req->LeaseState)) {\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\t\tksmbd_debug(OPLOCK,\n\t\t\t    \"req lease state: 0x%x, expected state: 0x%x\\n\",\n\t\t\t    req->LeaseState, lease->new_state);\n\t\tgoto err_out;\n\t}\n\n\tif (!atomic_read(&opinfo->breaking_cnt)) {\n\t\trsp->hdr.Status = STATUS_UNSUCCESSFUL;\n\t\tgoto err_out;\n\t}\n\n\t/* check for bad lease state */\n\tif (req->LeaseState &\n\t    (~(SMB2_LEASE_READ_CACHING_LE | SMB2_LEASE_HANDLE_CACHING_LE))) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\telse\n\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else if (lease->state == SMB2_LEASE_READ_CACHING_LE &&\n\t\t   req->LeaseState != SMB2_LEASE_NONE_LE) {\n\t\terr = STATUS_INVALID_OPLOCK_PROTOCOL;\n\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\tksmbd_debug(OPLOCK, \"handle bad lease state 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t} else {\n\t\t/* valid lease state changes */\n\t\terr = STATUS_INVALID_DEVICE_STATE;\n\t\tif (req->LeaseState == SMB2_LEASE_NONE_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_NONE;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_TO_NONE;\n\t\t} else if (req->LeaseState & SMB2_LEASE_READ_CACHING_LE) {\n\t\t\tif (lease->state & SMB2_LEASE_WRITE_CACHING_LE)\n\t\t\t\tlease_change_type = OPLOCK_WRITE_TO_READ;\n\t\t\telse\n\t\t\t\tlease_change_type = OPLOCK_READ_HANDLE_TO_READ;\n\t\t} else {\n\t\t\tlease_change_type = 0;\n\t\t}\n\t}\n\n\tswitch (lease_change_type) {\n\tcase OPLOCK_WRITE_TO_READ:\n\t\tret = opinfo_write_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_HANDLE_TO_READ:\n\t\tret = opinfo_read_handle_to_read(opinfo);\n\t\tbreak;\n\tcase OPLOCK_WRITE_TO_NONE:\n\t\tret = opinfo_write_to_none(opinfo);\n\t\tbreak;\n\tcase OPLOCK_READ_TO_NONE:\n\t\tret = opinfo_read_to_none(opinfo);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"unknown lease change 0x%x -> 0x%x\\n\",\n\t\t\t    le32_to_cpu(lease->state),\n\t\t\t    le32_to_cpu(req->LeaseState));\n\t}\n\n\tlease_state = lease->state;\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\topinfo_put(opinfo);\n\n\tif (ret < 0) {\n\t\trsp->hdr.Status = err;\n\t\tgoto err_out;\n\t}\n\n\trsp->StructureSize = cpu_to_le16(36);\n\trsp->Reserved = 0;\n\trsp->Flags = 0;\n\tmemcpy(rsp->LeaseKey, req->LeaseKey, 16);\n\trsp->LeaseState = lease_state;\n\trsp->LeaseDuration = 0;\n\tinc_rfc1001_len(work->response_buf, 36);\n\treturn;\n\nerr_out:\n\topinfo->op_state = OPLOCK_STATE_NONE;\n\twake_up_interruptible_all(&opinfo->oplock_q);\n\tatomic_dec(&opinfo->breaking_cnt);\n\twake_up_interruptible_all(&opinfo->oplock_brk);\n\n\topinfo_put(opinfo);\n\tsmb2_set_err_rsp(work);\n}\n\n/**\n * smb2_oplock_break() - dispatcher for smb2.0 and 2.1 oplock/lease break\n * @work:\tsmb work containing oplock/lease break command buffer\n *\n * Return:\t0\n */\nint smb2_oplock_break(struct ksmbd_work *work)\n{\n\tstruct smb2_oplock_break *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);\n\n\tswitch (le16_to_cpu(req->StructureSize)) {\n\tcase OP_BREAK_STRUCT_SIZE_20:\n\t\tsmb20_oplock_break_ack(work);\n\t\tbreak;\n\tcase OP_BREAK_STRUCT_SIZE_21:\n\t\tsmb21_lease_break_ack(work);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(OPLOCK, \"invalid break cmd %d\\n\",\n\t\t\t    le16_to_cpu(req->StructureSize));\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t}\n\n\treturn 0;\n}\n\n/**\n * smb2_notify() - handler for smb2 notify request\n * @work:   smb work containing notify command buffer\n *\n * Return:      0\n */\nint smb2_notify(struct ksmbd_work *work)\n{\n\tstruct smb2_change_notify_req *req;\n\tstruct smb2_change_notify_rsp *rsp;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (work->next_smb2_rcv_hdr_off && req->hdr.NextCommand) {\n\t\trsp->hdr.Status = STATUS_INTERNAL_ERROR;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\n\tsmb2_set_err_rsp(work);\n\trsp->hdr.Status = STATUS_NOT_IMPLEMENTED;\n\treturn 0;\n}\n\n/**\n * smb2_is_sign_req() - handler for checking packet signing status\n * @work:\tsmb work containing notify command buffer\n * @command:\tSMB2 command id\n *\n * Return:\ttrue if packed is signed, false otherwise\n */\nbool smb2_is_sign_req(struct ksmbd_work *work, unsigned int command)\n{\n\tstruct smb2_hdr *rcv_hdr2 = smb2_get_msg(work->request_buf);\n\n\tif ((rcv_hdr2->Flags & SMB2_FLAGS_SIGNED) &&\n\t    command != SMB2_NEGOTIATE_HE &&\n\t    command != SMB2_SESSION_SETUP_HE &&\n\t    command != SMB2_OPLOCK_BREAK_HE)\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * smb2_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb2_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, 1,\n\t\t\t\tsignature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb2_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb2_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr;\n\tstruct smb2_hdr *req_hdr;\n\tchar signature[SMB2_HMACSHA256_SIZE];\n\tstruct kvec iov[2];\n\tsize_t len;\n\tint n_vec = 1;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, n_vec,\n\t\t\t\t signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_check_sign_req() - handler for req packet sign processing\n * @work:   smb work containing notify command buffer\n *\n * Return:\t1 on success, 0 otherwise\n */\nint smb3_check_sign_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tchar *signing_key;\n\tstruct smb2_hdr *hdr;\n\tstruct channel *chann;\n\tchar signature_req[SMB2_SIGNATURE_SIZE];\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[1];\n\tsize_t len;\n\n\thdr = smb2_get_msg(work->request_buf);\n\tif (work->next_smb2_rcv_hdr_off)\n\t\thdr = ksmbd_req_buf_next(work);\n\n\tif (!hdr->NextCommand && !work->next_smb2_rcv_hdr_off)\n\t\tlen = get_rfc1002_len(work->request_buf);\n\telse if (hdr->NextCommand)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse\n\t\tlen = get_rfc1002_len(work->request_buf) -\n\t\t\twork->next_smb2_rcv_hdr_off;\n\n\tif (le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tread_lock(&work->sess->chann_lock);\n\t\tchann = lookup_chann_list(work->sess, conn);\n\t\tif (!chann) {\n\t\t\tread_unlock(&work->sess->chann_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tsigning_key = chann->smb3signingkey;\n\t\tread_unlock(&work->sess->chann_lock);\n\t}\n\n\tif (!signing_key) {\n\t\tpr_err(\"SMB3 signing key is not generated\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(signature_req, hdr->Signature, SMB2_SIGNATURE_SIZE);\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\n\tif (ksmbd_sign_smb3_pdu(conn, signing_key, iov, 1, signature))\n\t\treturn 0;\n\n\tif (memcmp(signature, signature_req, SMB2_SIGNATURE_SIZE)) {\n\t\tpr_err(\"bad smb2 signature\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * smb3_set_sign_rsp() - handler for rsp packet sign processing\n * @work:   smb work containing notify command buffer\n *\n */\nvoid smb3_set_sign_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *req_hdr, *hdr;\n\tstruct channel *chann;\n\tchar signature[SMB2_CMACAES_SIZE];\n\tstruct kvec iov[2];\n\tint n_vec = 1;\n\tsize_t len;\n\tchar *signing_key;\n\n\thdr = smb2_get_msg(work->response_buf);\n\tif (work->next_smb2_rsp_hdr_off)\n\t\thdr = ksmbd_resp_buf_next(work);\n\n\treq_hdr = ksmbd_req_buf_next(work);\n\n\tif (!work->next_smb2_rsp_hdr_off) {\n\t\tlen = get_rfc1002_len(work->response_buf);\n\t\tif (req_hdr->NextCommand)\n\t\t\tlen = ALIGN(len, 8);\n\t} else {\n\t\tlen = get_rfc1002_len(work->response_buf) -\n\t\t\twork->next_smb2_rsp_hdr_off;\n\t\tlen = ALIGN(len, 8);\n\t}\n\n\tif (conn->binding == false &&\n\t    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {\n\t\tsigning_key = work->sess->smb3signingkey;\n\t} else {\n\t\tread_lock(&work->sess->chann_lock);\n\t\tchann = lookup_chann_list(work->sess, work->conn);\n\t\tif (!chann) {\n\t\t\tread_unlock(&work->sess->chann_lock);\n\t\t\treturn;\n\t\t}\n\t\tsigning_key = chann->smb3signingkey;\n\t\tread_unlock(&work->sess->chann_lock);\n\t}\n\n\tif (!signing_key)\n\t\treturn;\n\n\tif (req_hdr->NextCommand)\n\t\thdr->NextCommand = cpu_to_le32(len);\n\n\thdr->Flags |= SMB2_FLAGS_SIGNED;\n\tmemset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);\n\tiov[0].iov_base = (char *)&hdr->ProtocolId;\n\tiov[0].iov_len = len;\n\tif (work->aux_payload_sz) {\n\t\tiov[0].iov_len -= work->aux_payload_sz;\n\t\tiov[1].iov_base = work->aux_payload_buf;\n\t\tiov[1].iov_len = work->aux_payload_sz;\n\t\tn_vec++;\n\t}\n\n\tif (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec, signature))\n\t\tmemcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);\n}\n\n/**\n * smb3_preauth_hash_rsp() - handler for computing preauth hash on response\n * @work:   smb work containing response buffer\n *\n */\nvoid smb3_preauth_hash_rsp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct smb2_hdr *req, *rsp;\n\n\tif (conn->dialect != SMB311_PROT_ID)\n\t\treturn;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (le16_to_cpu(req->Command) == SMB2_NEGOTIATE_HE &&\n\t    conn->preauth_info)\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE && sess) {\n\t\t__u8 *hash_value;\n\n\t\tif (conn->binding) {\n\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\tpreauth_sess = ksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\tif (!preauth_sess)\n\t\t\t\treturn;\n\t\t\thash_value = preauth_sess->Preauth_HashValue;\n\t\t} else {\n\t\t\thash_value = sess->Preauth_HashValue;\n\t\t\tif (!hash_value)\n\t\t\t\treturn;\n\t\t}\n\t\tksmbd_gen_preauth_integrity_hash(conn, work->response_buf,\n\t\t\t\t\t\t hash_value);\n\t}\n}\n\nstatic void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)\n{\n\tstruct smb2_transform_hdr *tr_hdr = tr_buf + 4;\n\tstruct smb2_hdr *hdr = smb2_get_msg(old_buf);\n\tunsigned int orig_len = get_rfc1002_len(old_buf);\n\n\t/* tr_buf must be cleared by the caller */\n\ttr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;\n\ttr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);\n\ttr_hdr->Flags = cpu_to_le16(TRANSFORM_FLAG_ENCRYPTED);\n\tif (cipher_type == SMB2_ENCRYPTION_AES128_GCM ||\n\t    cipher_type == SMB2_ENCRYPTION_AES256_GCM)\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);\n\telse\n\t\tget_random_bytes(&tr_hdr->Nonce, SMB3_AES_CCM_NONCE);\n\tmemcpy(&tr_hdr->SessionId, &hdr->SessionId, 8);\n\tinc_rfc1001_len(tr_buf, sizeof(struct smb2_transform_hdr));\n\tinc_rfc1001_len(tr_buf, orig_len);\n}\n\nint smb3_encrypt_resp(struct ksmbd_work *work)\n{\n\tchar *buf = work->response_buf;\n\tstruct kvec iov[3];\n\tint rc = -ENOMEM;\n\tint buf_size = 0, rq_nvec = 2 + (work->aux_payload_sz ? 1 : 0);\n\n\tif (ARRAY_SIZE(iov) < rq_nvec)\n\t\treturn -ENOMEM;\n\n\twork->tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);\n\tif (!work->tr_buf)\n\t\treturn rc;\n\n\t/* fill transform header */\n\tfill_transform_hdr(work->tr_buf, buf, work->conn->cipher_type);\n\n\tiov[0].iov_base = work->tr_buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tbuf_size += iov[0].iov_len - 4;\n\n\tiov[1].iov_base = buf + 4;\n\tiov[1].iov_len = get_rfc1002_len(buf);\n\tif (work->aux_payload_sz) {\n\t\tiov[1].iov_len = work->resp_hdr_sz - 4;\n\n\t\tiov[2].iov_base = work->aux_payload_buf;\n\t\tiov[2].iov_len = work->aux_payload_sz;\n\t\tbuf_size += iov[2].iov_len;\n\t}\n\tbuf_size += iov[1].iov_len;\n\twork->resp_hdr_sz = iov[1].iov_len;\n\n\trc = ksmbd_crypt_message(work->conn, iov, rq_nvec, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf, iov[1].iov_base, iov[1].iov_len);\n\t*(__be32 *)work->tr_buf = cpu_to_be32(buf_size);\n\n\treturn rc;\n}\n\nbool smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = smb2_get_msg(buf);\n\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}\n\nint smb3_decrypt_req(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess;\n\tchar *buf = work->request_buf;\n\tunsigned int pdu_length = get_rfc1002_len(buf);\n\tstruct kvec iov[2];\n\tint buf_data_size = pdu_length - sizeof(struct smb2_transform_hdr);\n\tstruct smb2_transform_hdr *tr_hdr = smb2_get_msg(buf);\n\tint rc = 0;\n\n\tif (buf_data_size < sizeof(struct smb2_hdr)) {\n\t\tpr_err(\"Transform message is too small (%u)\\n\",\n\t\t       pdu_length);\n\t\treturn -ECONNABORTED;\n\t}\n\n\tif (buf_data_size < le32_to_cpu(tr_hdr->OriginalMessageSize)) {\n\t\tpr_err(\"Transform message is broken\\n\");\n\t\treturn -ECONNABORTED;\n\t}\n\n\tsess = ksmbd_session_lookup_all(conn, le64_to_cpu(tr_hdr->SessionId));\n\tif (!sess) {\n\t\tpr_err(\"invalid session id(%llx) in transform header\\n\",\n\t\t       le64_to_cpu(tr_hdr->SessionId));\n\t\treturn -ECONNABORTED;\n\t}\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_base = buf + sizeof(struct smb2_transform_hdr) + 4;\n\tiov[1].iov_len = buf_data_size;\n\trc = ksmbd_crypt_message(conn, iov, 2, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemmove(buf + 4, iov[1].iov_base, buf_data_size);\n\t*(__be32 *)buf = cpu_to_be32(buf_data_size);\n\n\treturn rc;\n}\n\nbool smb3_11_final_sess_setup_resp(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_hdr *rsp = smb2_get_msg(work->response_buf);\n\n\tif (conn->dialect < SMB30_PROT_ID)\n\t\treturn false;\n\n\tif (work->next_smb2_rcv_hdr_off)\n\t\trsp = ksmbd_resp_buf_next(work);\n\n\tif (le16_to_cpu(rsp->Command) == SMB2_SESSION_SETUP_HE &&\n\t    rsp->Status == STATUS_SUCCESS)\n\t\treturn true;\n\treturn false;\n}\n", "// SPDX-License-Identifier: LGPL-2.1+\n/*\n *   Copyright (C) International Business Machines  Corp., 2007,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *   Copyright (C) 2020 Samsung Electronics Co., Ltd.\n *   Author(s): Namjae Jeon <linkinjeon@kernel.org>\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mnt_idmapping.h>\n\n#include \"smbacl.h\"\n#include \"smb_common.h\"\n#include \"server.h\"\n#include \"misc.h\"\n#include \"mgmt/share_config.h\"\n\nstatic const struct smb_sid domain = {1, 4, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(21), cpu_to_le32(1), cpu_to_le32(2), cpu_to_le32(3),\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* security id for everyone/world system group */\nstatic const struct smb_sid creator_owner = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {0} };\n/* security id for everyone/world system group */\nstatic const struct smb_sid creator_group = {\n\t1, 1, {0, 0, 0, 0, 0, 3}, {cpu_to_le32(1)} };\n\n/* security id for everyone/world system group */\nstatic const struct smb_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n/* security id for Authenticated Users system group */\nstatic const struct smb_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\n/* S-1-22-1 Unmapped Unix users */\nstatic const struct smb_sid sid_unix_users = {1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-22-2 Unmapped Unix groups */\nstatic const struct smb_sid sid_unix_groups = { 1, 1, {0, 0, 0, 0, 0, 22},\n\t\t{cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/*\n * See http://technet.microsoft.com/en-us/library/hh509017(v=ws.10).aspx\n */\n\n/* S-1-5-88 MS NFS and Apple style UID/GID/mode */\n\n/* S-1-5-88-1 Unix uid */\nstatic const struct smb_sid sid_unix_NFS_users = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-5-88-2 Unix gid */\nstatic const struct smb_sid sid_unix_NFS_groups = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/* S-1-5-88-3 Unix mode */\nstatic const struct smb_sid sid_unix_NFS_mode = { 1, 2, {0, 0, 0, 0, 0, 5},\n\t{cpu_to_le32(88),\n\t cpu_to_le32(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };\n\n/*\n * if the two SIDs (roughly equivalent to a UUID for a user or group) are\n * the same returns zero, if they do not match returns non-zero.\n */\nint compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif (!ctsid || !cwsid)\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t    le32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}\n\nstatic void smb_copy_sid(struct smb_sid *dst, const struct smb_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}\n\n/*\n * change posix mode to reflect permissions\n * pmode is the existing mode (we only want to overwrite part of this\n * bits to set can be: S_IRWXU, S_IRWXG or S_IRWXO ie 00700 or 00070 or 00007\n */\nstatic umode_t access_flags_to_mode(struct smb_fattr *fattr, __le32 ace_flags,\n\t\t\t\t    int type)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\tumode_t mode = 0;\n\n\tif (flags & GENERIC_ALL) {\n\t\tmode = 0777;\n\t\tksmbd_debug(SMB, \"all perms\\n\");\n\t\treturn mode;\n\t}\n\n\tif ((flags & GENERIC_READ) || (flags & FILE_READ_RIGHTS))\n\t\tmode = 0444;\n\tif ((flags & GENERIC_WRITE) || (flags & FILE_WRITE_RIGHTS)) {\n\t\tmode |= 0222;\n\t\tif (S_ISDIR(fattr->cf_mode))\n\t\t\tmode |= 0111;\n\t}\n\tif ((flags & GENERIC_EXECUTE) || (flags & FILE_EXEC_RIGHTS))\n\t\tmode |= 0111;\n\n\tif (type == ACCESS_DENIED_ACE_TYPE || type == ACCESS_DENIED_OBJECT_ACE_TYPE)\n\t\tmode = ~mode;\n\n\tksmbd_debug(SMB, \"access flags 0x%x mode now %04o\\n\", flags, mode);\n\n\treturn mode;\n}\n\n/*\n * Generate access flags to reflect permissions mode is the existing mode.\n * This function is called for every ACE in the DACL whose SID matches\n * with either owner or group or everyone.\n */\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t __u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/*\n\t * check for R/W/X UGO since we do not know whose flags\n\t * is this but we have cleared all the bits sans RWX for\n\t * either user or group or other as per bits_to_use\n\t */\n\tif (mode & 0444)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & 0222)\n\t\t*pace_flags |= FILE_WRITE_RIGHTS;\n\tif (mode & 0111)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tksmbd_debug(SMB, \"mode: %o, access flags now 0x%x\\n\",\n\t\t    mode, *pace_flags);\n}\n\nstatic __u16 fill_ace_for_sid(struct smb_ace *pntace,\n\t\t\t      const struct smb_sid *psid, int type, int flags,\n\t\t\t      umode_t mode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = type;\n\tpntace->flags = flags;\n\tmode_to_access_flags(mode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\nvoid id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid)\n{\n\tswitch (sidtype) {\n\tcase SIDOWNER:\n\t\tsmb_copy_sid(ssid, &server_conf.domain_sid);\n\t\tbreak;\n\tcase SIDUNIX_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_users);\n\t\tbreak;\n\tcase SIDUNIX_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_groups);\n\t\tbreak;\n\tcase SIDCREATOR_OWNER:\n\t\tsmb_copy_sid(ssid, &creator_owner);\n\t\treturn;\n\tcase SIDCREATOR_GROUP:\n\t\tsmb_copy_sid(ssid, &creator_group);\n\t\treturn;\n\tcase SIDNFS_USER:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_users);\n\t\tbreak;\n\tcase SIDNFS_GROUP:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_groups);\n\t\tbreak;\n\tcase SIDNFS_MODE:\n\t\tsmb_copy_sid(ssid, &sid_unix_NFS_mode);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/* RID */\n\tssid->sub_auth[ssid->num_subauth] = cpu_to_le32(cid);\n\tssid->num_subauth++;\n}\n\nstatic int sid_to_id(struct user_namespace *user_ns,\n\t\t     struct smb_sid *psid, uint sidtype,\n\t\t     struct smb_fattr *fattr)\n{\n\tint rc = -EINVAL;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tpr_err(\"%s: %u subauthorities is too many!\\n\",\n\t\t       __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tuid = mapped_kuid_user(user_ns, &init_user_ns, KUIDT_INIT(id));\n\t\tif (uid_valid(uid)) {\n\t\t\tfattr->cf_uid = uid;\n\t\t\trc = 0;\n\t\t}\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\n\t\tid = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);\n\t\tgid = mapped_kgid_user(user_ns, &init_user_ns, KGIDT_INIT(id));\n\t\tif (gid_valid(gid)) {\n\t\t\tfattr->cf_gid = gid;\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nvoid posix_state_to_acl(struct posix_acl_state *state,\n\t\t\tstruct posix_acl_entry *pace)\n{\n\tint i;\n\n\tpace->e_tag = ACL_USER_OBJ;\n\tpace->e_perm = state->owner.allow;\n\tfor (i = 0; i < state->users->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_USER;\n\t\tpace->e_uid = state->users->aces[i].uid;\n\t\tpace->e_perm = state->users->aces[i].perms.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_GROUP_OBJ;\n\tpace->e_perm = state->group.allow;\n\n\tfor (i = 0; i < state->groups->n; i++) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_GROUP;\n\t\tpace->e_gid = state->groups->aces[i].gid;\n\t\tpace->e_perm = state->groups->aces[i].perms.allow;\n\t}\n\n\tif (state->users->n || state->groups->n) {\n\t\tpace++;\n\t\tpace->e_tag = ACL_MASK;\n\t\tpace->e_perm = state->mask.allow;\n\t}\n\n\tpace++;\n\tpace->e_tag = ACL_OTHER;\n\tpace->e_perm = state->other.allow;\n}\n\nint init_acl_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't know which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt * sizeof(struct posix_user_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid free_acl_state(struct posix_acl_state *state)\n{\n\tkfree(state->users);\n\tkfree(state->groups);\n}\n\nstatic void parse_dacl(struct user_namespace *user_ns,\n\t\t       struct smb_acl *pdacl, char *end_of_acl,\n\t\t       struct smb_sid *pownersid, struct smb_sid *pgrpsid,\n\t\t       struct smb_fattr *fattr)\n{\n\tint i, ret;\n\tint num_aces = 0;\n\tunsigned int acl_size;\n\tchar *acl_base;\n\tstruct smb_ace **ppace;\n\tstruct posix_acl_entry *cf_pace, *cf_pdace;\n\tstruct posix_acl_state acl_state, default_acl_state;\n\tumode_t mode = 0, acl_mode;\n\tbool owner_found = false, group_found = false, others_found = false;\n\n\tif (!pdacl)\n\t\treturn;\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + sizeof(struct smb_acl) ||\n\t    end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tpr_err(\"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tksmbd_debug(SMB, \"DACL revision %d size %d num aces %d\\n\",\n\t\t    le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t    le32_to_cpu(pdacl->num_aces));\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct smb_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces <= 0)\n\t\treturn;\n\n\tif (num_aces > ULONG_MAX / sizeof(struct smb_ace *))\n\t\treturn;\n\n\tppace = kmalloc_array(num_aces, sizeof(struct smb_ace *), GFP_KERNEL);\n\tif (!ppace)\n\t\treturn;\n\n\tret = init_acl_state(&acl_state, num_aces);\n\tif (ret)\n\t\treturn;\n\tret = init_acl_state(&default_acl_state, num_aces);\n\tif (ret) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn;\n\t}\n\n\t/*\n\t * reset rwx permissions for user/group/other.\n\t * Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t * user/group/other have no permissions\n\t */\n\tfor (i = 0; i < num_aces; ++i) {\n\t\tif (end_of_acl - acl_base < acl_size)\n\t\t\tbreak;\n\n\t\tppace[i] = (struct smb_ace *)(acl_base + acl_size);\n\t\tacl_base = (char *)ppace[i];\n\t\tacl_size = offsetof(struct smb_ace, sid) +\n\t\t\toffsetof(struct smb_sid, sub_auth);\n\n\t\tif (end_of_acl - acl_base < acl_size ||\n\t\t    ppace[i]->sid.num_subauth > SID_MAX_SUB_AUTHORITIES ||\n\t\t    (end_of_acl - acl_base <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth) ||\n\t\t    (le16_to_cpu(ppace[i]->size) <\n\t\t     acl_size + sizeof(__le32) * ppace[i]->sid.num_subauth))\n\t\t\tbreak;\n\n\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\tppace[i]->access_req =\n\t\t\tsmb_map_generic_desired_access(ppace[i]->access_req);\n\n\t\tif (!(compare_sids(&ppace[i]->sid, &sid_unix_NFS_mode))) {\n\t\t\tfattr->cf_mode =\n\t\t\t\tle32_to_cpu(ppace[i]->sid.sub_auth[2]);\n\t\t\tbreak;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pownersid)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0700;\n\n\t\t\tif (!owner_found) {\n\t\t\t\tmode &= ~(0700);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\towner_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, pgrpsid) ||\n\t\t\t   ppace[i]->sid.sub_auth[ppace[i]->sid.num_subauth - 1] ==\n\t\t\t    DOMAIN_USER_RID_LE) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0070;\n\t\t\tif (!group_found) {\n\t\t\t\tmode &= ~(0070);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tgroup_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_everyone)) {\n\t\t\tacl_mode = access_flags_to_mode(fattr,\n\t\t\t\t\t\t\tppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\tacl_mode &= 0007;\n\t\t\tif (!others_found) {\n\t\t\t\tmode &= ~(0007);\n\t\t\t\tmode |= acl_mode;\n\t\t\t}\n\t\t\tothers_found = true;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_owner)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &creator_group)) {\n\t\t\tcontinue;\n\t\t} else if (!compare_sids(&ppace[i]->sid, &sid_authusers)) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tstruct smb_fattr temp_fattr;\n\n\t\t\tacl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,\n\t\t\t\t\t\t\tppace[i]->type);\n\t\t\ttemp_fattr.cf_uid = INVALID_UID;\n\t\t\tret = sid_to_id(user_ns, &ppace[i]->sid, SIDOWNER, &temp_fattr);\n\t\t\tif (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {\n\t\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t\t       __func__, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tacl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tacl_state.users->aces[acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.owner.allow = ((acl_mode & 0700) >> 6) | 0004;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\t\ttemp_fattr.cf_uid;\n\t\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t\t((acl_mode & 0700) >> 6) | 0004;\n\t\t}\n\t}\n\tkfree(ppace);\n\n\tif (owner_found) {\n\t\t/* The owner must be set to at least read-only. */\n\t\tacl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tacl_state.users->aces[acl_state.users->n].uid = fattr->cf_uid;\n\t\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.owner.allow = ((mode & 0700) >> 6) | 0004;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n].uid =\n\t\t\tfattr->cf_uid;\n\t\tdefault_acl_state.users->aces[default_acl_state.users->n++].perms.allow =\n\t\t\t((mode & 0700) >> 6) | 0004;\n\t}\n\n\tif (group_found) {\n\t\tacl_state.group.allow = (mode & 0070) >> 3;\n\t\tacl_state.groups->aces[acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t\tdefault_acl_state.group.allow = (mode & 0070) >> 3;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n].gid =\n\t\t\tfattr->cf_gid;\n\t\tdefault_acl_state.groups->aces[default_acl_state.groups->n++].perms.allow =\n\t\t\t(mode & 0070) >> 3;\n\t}\n\n\tif (others_found) {\n\t\tfattr->cf_mode &= ~(0007);\n\t\tfattr->cf_mode |= mode & 0007;\n\n\t\tacl_state.other.allow = mode & 0007;\n\t\tdefault_acl_state.other.allow = mode & 0007;\n\t}\n\n\tif (acl_state.users->n || acl_state.groups->n) {\n\t\tacl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_acls =\n\t\t\t\tposix_acl_alloc(acl_state.users->n +\n\t\t\t\t\tacl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_acls) {\n\t\t\t\tcf_pace = fattr->cf_acls->a_entries;\n\t\t\t\tposix_state_to_acl(&acl_state, cf_pace);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_acl_state.users->n || default_acl_state.groups->n) {\n\t\tdefault_acl_state.mask.allow = 0x07;\n\n\t\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\t\tfattr->cf_dacls =\n\t\t\t\tposix_acl_alloc(default_acl_state.users->n +\n\t\t\t\tdefault_acl_state.groups->n + 4, GFP_KERNEL);\n\t\t\tif (fattr->cf_dacls) {\n\t\t\t\tcf_pdace = fattr->cf_dacls->a_entries;\n\t\t\t\tposix_state_to_acl(&default_acl_state, cf_pdace);\n\t\t\t}\n\t\t}\n\t}\n\tfree_acl_state(&acl_state);\n\tfree_acl_state(&default_acl_state);\n}\n\nstatic void set_posix_acl_entries_dacl(struct user_namespace *user_ns,\n\t\t\t\t       struct smb_ace *pndace,\n\t\t\t\t       struct smb_fattr *fattr, u32 *num_aces,\n\t\t\t\t       u16 *size, u32 nt_aces_num)\n{\n\tstruct posix_acl_entry *pace;\n\tstruct smb_sid *sid;\n\tstruct smb_ace *ntace;\n\tint i, j;\n\n\tif (!fattr->cf_acls)\n\t\tgoto posix_default_acl;\n\n\tpace = fattr->cf_acls->a_entries;\n\tfor (i = 0; i < fattr->cf_acls->a_count; i++, pace++) {\n\t\tint flags = 0;\n\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\t\t\tunsigned int sid_type = SIDOWNER;\n\n\t\t\tuid = posix_acl_uid_translate(user_ns, pace);\n\t\t\tif (!uid)\n\t\t\t\tsid_type = SIDUNIX_USER;\n\t\t\tid_to_sid(uid, sid_type, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(user_ns, pace);\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, sid);\n\t\t} else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {\n\t\t\tsmb_copy_sid(sid, &sid_everyone);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\t\tntace = pndace;\n\t\tfor (j = 0; j < nt_aces_num; j++) {\n\t\t\tif (ntace->sid.sub_auth[ntace->sid.num_subauth - 1] ==\n\t\t\t\t\tsid->sub_auth[sid->num_subauth - 1])\n\t\t\t\tgoto pass_same_sid;\n\t\t\tntace = (struct smb_ace *)((char *)ntace +\n\t\t\t\t\tle16_to_cpu(ntace->size));\n\t\t}\n\n\t\tif (S_ISDIR(fattr->cf_mode) && pace->e_tag == ACL_OTHER)\n\t\t\tflags = 0x03;\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, flags,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\n\t\tif (S_ISDIR(fattr->cf_mode) &&\n\t\t    (pace->e_tag == ACL_USER || pace->e_tag == ACL_GROUP)) {\n\t\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED,\n\t\t\t\t\t0x03, pace->e_perm, 0777);\n\t\t\t(*num_aces)++;\n\t\t\tif (pace->e_tag == ACL_USER)\n\t\t\t\tntace->access_req |=\n\t\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\t}\n\npass_same_sid:\n\t\tkfree(sid);\n\t}\n\n\tif (nt_aces_num)\n\t\treturn;\n\nposix_default_acl:\n\tif (!fattr->cf_dacls)\n\t\treturn;\n\n\tpace = fattr->cf_dacls->a_entries;\n\tfor (i = 0; i < fattr->cf_dacls->a_count; i++, pace++) {\n\t\tsid = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\t\tif (!sid)\n\t\t\tbreak;\n\n\t\tif (pace->e_tag == ACL_USER) {\n\t\t\tuid_t uid;\n\n\t\t\tuid = posix_acl_uid_translate(user_ns, pace);\n\t\t\tid_to_sid(uid, SIDCREATOR_OWNER, sid);\n\t\t} else if (pace->e_tag == ACL_GROUP) {\n\t\t\tgid_t gid;\n\n\t\t\tgid = posix_acl_gid_translate(user_ns, pace);\n\t\t\tid_to_sid(gid, SIDCREATOR_GROUP, sid);\n\t\t} else {\n\t\t\tkfree(sid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tntace = (struct smb_ace *)((char *)pndace + *size);\n\t\t*size += fill_ace_for_sid(ntace, sid, ACCESS_ALLOWED, 0x0b,\n\t\t\t\tpace->e_perm, 0777);\n\t\t(*num_aces)++;\n\t\tif (pace->e_tag == ACL_USER)\n\t\t\tntace->access_req |=\n\t\t\t\tFILE_DELETE_LE | FILE_DELETE_CHILD_LE;\n\t\tkfree(sid);\n\t}\n}\n\nstatic void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   unsigned int aces_size,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tunsigned short nt_ace_size;\n\n\t\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\t\tbreak;\n\n\t\t\tnt_ace_size = le16_to_cpu(ntace->size);\n\t\t\tif (nt_ace_size > aces_size)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((char *)pndace + size, ntace, nt_ace_size);\n\t\t\tsize += nt_ace_size;\n\t\t\taces_size -= nt_ace_size;\n\t\t\tntace = (struct smb_ace *)((char *)ntace + nt_ace_size);\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic void set_mode_dacl(struct user_namespace *user_ns,\n\t\t\t  struct smb_acl *pndacl, struct smb_fattr *fattr)\n{\n\tstruct smb_ace *pace, *pndace;\n\tu32 num_aces = 0;\n\tu16 size = 0, ace_size = 0;\n\tuid_t uid;\n\tconst struct smb_sid *sid;\n\n\tpace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\n\tif (fattr->cf_acls) {\n\t\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t\t   &num_aces, &size, num_aces);\n\t\tgoto out;\n\t}\n\n\t/* owner RID */\n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (uid)\n\t\tsid = &server_conf.domain_sid;\n\telse\n\t\tsid = &sid_unix_users;\n\tace_size = fill_ace_for_sid(pace, sid, ACCESS_ALLOWED, 0,\n\t\t\t\t    fattr->cf_mode, 0700);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] = cpu_to_le32(uid);\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t/* Group RID */\n\tace_size = fill_ace_for_sid(pace, &sid_unix_groups,\n\t\t\t\t    ACCESS_ALLOWED, 0, fattr->cf_mode, 0070);\n\tpace->sid.sub_auth[pace->sid.num_subauth++] =\n\t\tcpu_to_le32(from_kgid(&init_user_ns, fattr->cf_gid));\n\tpace->size = cpu_to_le16(ace_size + 4);\n\tsize += le16_to_cpu(pace->size);\n\tpace = (struct smb_ace *)((char *)pndace + size);\n\tnum_aces = 3;\n\n\tif (S_ISDIR(fattr->cf_mode)) {\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t/* creator owner */\n\t\tsize += fill_ace_for_sid(pace, &creator_owner, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0700);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\n\t\t/* creator group */\n\t\tsize += fill_ace_for_sid(pace, &creator_group, ACCESS_ALLOWED,\n\t\t\t\t\t 0x0b, fattr->cf_mode, 0070);\n\t\tpace = (struct smb_ace *)((char *)pndace + size);\n\t\tnum_aces = 5;\n\t}\n\n\t/* other */\n\tsize += fill_ace_for_sid(pace, &sid_everyone, ACCESS_ALLOWED, 0,\n\t\t\t\t fattr->cf_mode, 0007);\n\nout:\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}\n\nstatic int parse_sid(struct smb_sid *psid, char *end_of_acl)\n{\n\t/*\n\t * validate that we do not go past end of ACL - sid must be at least 8\n\t * bytes long (assuming no sub-auths - e.g. the null SID\n\t */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tpr_err(\"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Convert CIFS ACL to POSIX form */\nint parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   int acl_len, struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\tint pntsd_type;\n\n\tif (!pntsd)\n\t\treturn -EIO;\n\n\tif (acl_len < sizeof(struct smb_ntsd))\n\t\treturn -EINVAL;\n\n\towner_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd +\n\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct smb_acl *)((char *)pntsd + dacloffset);\n\tksmbd_debug(SMB,\n\t\t    \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t    pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t    le32_to_cpu(pntsd->gsidoffset),\n\t\t    le32_to_cpu(pntsd->sacloffset), dacloffset);\n\n\tpntsd_type = le16_to_cpu(pntsd->type);\n\tif (!(pntsd_type & DACL_PRESENT)) {\n\t\tksmbd_debug(SMB, \"DACL_PRESENT in DACL type is not set\\n\");\n\t\treturn rc;\n\t}\n\n\tpntsd->type = cpu_to_le16(DACL_PRESENT);\n\n\tif (pntsd->osidoffset) {\n\t\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = sid_to_id(user_ns, owner_sid_ptr, SIDOWNER, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t       __func__, rc);\n\t\t\towner_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif (pntsd->gsidoffset) {\n\t\trc = parse_sid(group_sid_ptr, end_of_acl);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t\trc = sid_to_id(user_ns, group_sid_ptr, SIDUNIX_GROUP, fattr);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgroup_sid_ptr = NULL;\n\t\t}\n\t}\n\n\tif ((pntsd_type & (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ)) ==\n\t    (DACL_AUTO_INHERITED | DACL_AUTO_INHERIT_REQ))\n\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\tif (pntsd_type & DACL_PROTECTED)\n\t\tpntsd->type |= cpu_to_le16(DACL_PROTECTED);\n\n\tif (dacloffset) {\n\t\tparse_dacl(user_ns, dacl_ptr, end_of_acl,\n\t\t\t   owner_sid_ptr, group_sid_ptr, fattr);\n\t}\n\n\treturn 0;\n}\n\n/* Convert permission bits from mode to equivalent CIFS ACL */\nint build_sec_desc(struct user_namespace *user_ns,\n\t\t   struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,\n\t\t   int ppntsd_size, int addition_info, __u32 *secdesclen,\n\t\t   struct smb_fattr *fattr)\n{\n\tint rc = 0;\n\t__u32 offset;\n\tstruct smb_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct smb_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct smb_acl *dacl_ptr = NULL; /* no need for SACL ptr */\n\tuid_t uid;\n\tgid_t gid;\n\tunsigned int sid_type = SIDOWNER;\n\n\tnowner_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!nowner_sid_ptr)\n\t\treturn -ENOMEM;\n\n\tuid = from_kuid(&init_user_ns, fattr->cf_uid);\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, nowner_sid_ptr);\n\n\tngroup_sid_ptr = kmalloc(sizeof(struct smb_sid), GFP_KERNEL);\n\tif (!ngroup_sid_ptr) {\n\t\tkfree(nowner_sid_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\tgid = from_kgid(&init_user_ns, fattr->cf_gid);\n\tid_to_sid(gid, SIDUNIX_GROUP, ngroup_sid_ptr);\n\n\toffset = sizeof(struct smb_ntsd);\n\tpntsd->sacloffset = 0;\n\tpntsd->revision = cpu_to_le16(1);\n\tpntsd->type = cpu_to_le16(SELF_RELATIVE);\n\tif (ppntsd)\n\t\tpntsd->type |= ppntsd->type;\n\n\tif (addition_info & OWNER_SECINFO) {\n\t\tpntsd->osidoffset = cpu_to_le32(offset);\n\t\towner_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (nowner_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & GROUP_SECINFO) {\n\t\tpntsd->gsidoffset = cpu_to_le32(offset);\n\t\tgroup_sid_ptr = (struct smb_sid *)((char *)pntsd + offset);\n\t\tsmb_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\toffset += 1 + 1 + 6 + (ngroup_sid_ptr->num_subauth * 4);\n\t}\n\n\tif (addition_info & DACL_SECINFO) {\n\t\tpntsd->type |= cpu_to_le16(DACL_PRESENT);\n\t\tdacl_ptr = (struct smb_acl *)((char *)pntsd + offset);\n\t\tdacl_ptr->revision = cpu_to_le16(2);\n\t\tdacl_ptr->size = cpu_to_le16(sizeof(struct smb_acl));\n\t\tdacl_ptr->num_aces = 0;\n\n\t\tif (!ppntsd) {\n\t\t\tset_mode_dacl(user_ns, dacl_ptr, fattr);\n\t\t} else {\n\t\t\tstruct smb_acl *ppdacl_ptr;\n\t\t\tunsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);\n\t\t\tint ppdacl_size, ntacl_size = ppntsd_size - dacl_offset;\n\n\t\t\tif (!dacl_offset ||\n\t\t\t    (dacl_offset + sizeof(struct smb_acl) > ppntsd_size))\n\t\t\t\tgoto out;\n\n\t\t\tppdacl_ptr = (struct smb_acl *)((char *)ppntsd + dacl_offset);\n\t\t\tppdacl_size = le16_to_cpu(ppdacl_ptr->size);\n\t\t\tif (ppdacl_size > ntacl_size ||\n\t\t\t    ppdacl_size < sizeof(struct smb_acl))\n\t\t\t\tgoto out;\n\n\t\t\tset_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,\n\t\t\t\t       ntacl_size - sizeof(struct smb_acl),\n\t\t\t\t       nowner_sid_ptr, ngroup_sid_ptr,\n\t\t\t\t       fattr);\n\t\t}\n\t\tpntsd->dacloffset = cpu_to_le32(offset);\n\t\toffset += le16_to_cpu(dacl_ptr->size);\n\t}\n\nout:\n\tkfree(nowner_sid_ptr);\n\tkfree(ngroup_sid_ptr);\n\t*secdesclen = offset;\n\treturn rc;\n}\n\nstatic void smb_set_ace(struct smb_ace *ace, const struct smb_sid *sid, u8 type,\n\t\t\tu8 flags, __le32 access_req)\n{\n\tace->type = type;\n\tace->flags = flags;\n\tace->access_req = access_req;\n\tsmb_copy_sid(&ace->sid, sid);\n\tace->size = cpu_to_le16(1 + 1 + 2 + 4 + 1 + 1 + 6 + (sid->num_subauth * 4));\n}\n\nint smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}\n\nbool smb_inherit_flags(int flags, bool is_dir)\n{\n\tif (!is_dir)\n\t\treturn (flags & OBJECT_INHERIT_ACE) != 0;\n\n\tif (flags & OBJECT_INHERIT_ACE && !(flags & NO_PROPAGATE_INHERIT_ACE))\n\t\treturn true;\n\n\tif (flags & CONTAINER_INHERIT_ACE)\n\t\treturn true;\n\treturn false;\n}\n\nint smb_check_perm_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t\t__le32 *pdaccess, int uid)\n{\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tstruct smb_ntsd *pntsd = NULL;\n\tstruct smb_acl *pdacl;\n\tstruct posix_acl *posix_acls;\n\tint rc = 0, pntsd_size, acl_size, aces_size, pdacl_size, dacl_offset;\n\tstruct smb_sid sid;\n\tint granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);\n\tstruct smb_ace *ace;\n\tint i, found = 0;\n\tunsigned int access_bits = 0;\n\tstruct smb_ace *others_ace = NULL;\n\tstruct posix_acl_entry *pa_entry;\n\tunsigned int sid_type = SIDOWNER;\n\tunsigned short ace_size;\n\n\tksmbd_debug(SMB, \"check permission using windows acl\\n\");\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    path->dentry, &pntsd);\n\tif (pntsd_size <= 0 || !pntsd)\n\t\tgoto err_out;\n\n\tdacl_offset = le32_to_cpu(pntsd->dacloffset);\n\tif (!dacl_offset ||\n\t    (dacl_offset + sizeof(struct smb_acl) > pntsd_size))\n\t\tgoto err_out;\n\n\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\tacl_size = pntsd_size - dacl_offset;\n\tpdacl_size = le16_to_cpu(pdacl->size);\n\n\tif (pdacl_size > acl_size || pdacl_size < sizeof(struct smb_acl))\n\t\tgoto err_out;\n\n\tif (!pdacl->num_aces) {\n\t\tif (!(pdacl_size - sizeof(struct smb_acl)) &&\n\t\t    *pdaccess & ~(FILE_READ_CONTROL_LE | FILE_WRITE_DAC_LE)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\taces_size = acl_size - sizeof(struct smb_acl);\n\t\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\t\tbreak;\n\t\t\tace_size = le16_to_cpu(ace->size);\n\t\t\tif (ace_size > aces_size)\n\t\t\t\tbreak;\n\t\t\taces_size -= ace_size;\n\t\t\tgranted |= le32_to_cpu(ace->access_req);\n\t\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t\t}\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (!uid)\n\t\tsid_type = SIDUNIX_USER;\n\tid_to_sid(uid, sid_type, &sid);\n\n\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\taces_size = acl_size - sizeof(struct smb_acl);\n\tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\t\tace_size = le16_to_cpu(ace->size);\n\t\tif (ace_size > aces_size)\n\t\t\tbreak;\n\t\taces_size -= ace_size;\n\n\t\tif (!compare_sids(&sid, &ace->sid) ||\n\t\t    !compare_sids(&sid_unix_NFS_mode, &ace->sid)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!compare_sids(&sid_everyone, &ace->sid))\n\t\t\tothers_ace = ace;\n\n\t\tace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n\t}\n\n\tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE && found) {\n\t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |\n\t\t\tDELETE;\n\n\t\tgranted |= le32_to_cpu(ace->access_req);\n\n\t\tif (!pdacl->num_aces)\n\t\t\tgranted = GENERIC_ALL_FLAGS;\n\t}\n\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {\n\t\tposix_acls = get_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);\n\t\tif (posix_acls && !found) {\n\t\t\tunsigned int id = -1;\n\n\t\t\tpa_entry = posix_acls->a_entries;\n\t\t\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++) {\n\t\t\t\tif (pa_entry->e_tag == ACL_USER)\n\t\t\t\t\tid = posix_acl_uid_translate(user_ns, pa_entry);\n\t\t\t\telse if (pa_entry->e_tag == ACL_GROUP)\n\t\t\t\t\tid = posix_acl_gid_translate(user_ns, pa_entry);\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (id == uid) {\n\t\t\t\t\tmode_to_access_flags(pa_entry->e_perm,\n\t\t\t\t\t\t\t     0777,\n\t\t\t\t\t\t\t     &access_bits);\n\t\t\t\t\tif (!access_bits)\n\t\t\t\t\t\taccess_bits =\n\t\t\t\t\t\t\tSET_MINIMUM_RIGHTS;\n\t\t\t\t\tposix_acl_release(posix_acls);\n\t\t\t\t\tgoto check_access_bits;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (posix_acls)\n\t\t\tposix_acl_release(posix_acls);\n\t}\n\n\tif (!found) {\n\t\tif (others_ace) {\n\t\t\tace = others_ace;\n\t\t} else {\n\t\t\tksmbd_debug(SMB, \"Can't find corresponding sid\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tswitch (ace->type) {\n\tcase ACCESS_ALLOWED_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(ace->access_req);\n\t\tbreak;\n\tcase ACCESS_DENIED_ACE_TYPE:\n\tcase ACCESS_DENIED_CALLBACK_ACE_TYPE:\n\t\taccess_bits = le32_to_cpu(~ace->access_req);\n\t\tbreak;\n\t}\n\ncheck_access_bits:\n\tif (granted &\n\t    ~(access_bits | FILE_READ_ATTRIBUTES | READ_CONTROL | WRITE_DAC | DELETE)) {\n\t\tksmbd_debug(SMB, \"Access denied with winACL, granted : %x, access_req : %x\\n\",\n\t\t\t    granted, le32_to_cpu(ace->access_req));\n\t\trc = -EACCES;\n\t\tgoto err_out;\n\t}\n\n\t*pdaccess = cpu_to_le32(granted);\nerr_out:\n\tkfree(pntsd);\n\treturn rc;\n}\n\nint set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,\n\t\t struct path *path, struct smb_ntsd *pntsd, int ntsd_len,\n\t\t bool type_check)\n{\n\tint rc;\n\tstruct smb_fattr fattr = {{0}};\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tstruct iattr newattrs;\n\n\tfattr.cf_uid = INVALID_UID;\n\tfattr.cf_gid = INVALID_GID;\n\tfattr.cf_mode = inode->i_mode;\n\n\trc = parse_sec_desc(user_ns, pntsd, ntsd_len, &fattr);\n\tif (rc)\n\t\tgoto out;\n\n\tnewattrs.ia_valid = ATTR_CTIME;\n\tif (!uid_eq(fattr.cf_uid, INVALID_UID)) {\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = fattr.cf_uid;\n\t}\n\tif (!gid_eq(fattr.cf_gid, INVALID_GID)) {\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = fattr.cf_gid;\n\t}\n\tnewattrs.ia_valid |= ATTR_MODE;\n\tnewattrs.ia_mode = (inode->i_mode & ~0777) | (fattr.cf_mode & 0777);\n\n\tksmbd_vfs_remove_acl_xattrs(user_ns, path->dentry);\n\t/* Update posix acls */\n\tif (IS_ENABLED(CONFIG_FS_POSIX_ACL) && fattr.cf_dacls) {\n\t\trc = set_posix_acl(user_ns, inode,\n\t\t\t\t   ACL_TYPE_ACCESS, fattr.cf_acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t\tif (S_ISDIR(inode->i_mode) && fattr.cf_dacls) {\n\t\t\trc = set_posix_acl(user_ns, inode,\n\t\t\t\t\t   ACL_TYPE_DEFAULT, fattr.cf_dacls);\n\t\t\tif (rc)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t\t    rc);\n\t\t}\n\t}\n\n\tinode_lock(inode);\n\trc = notify_change(user_ns, path->dentry, &newattrs, NULL);\n\tinode_unlock(inode);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Check it only calling from SD BUFFER context */\n\tif (type_check && !(le16_to_cpu(pntsd->type) & DACL_PRESENT))\n\t\tgoto out;\n\n\tif (test_share_config_flag(tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t/* Update WinACL in xattr */\n\t\tksmbd_vfs_remove_sd_xattrs(user_ns, path->dentry);\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, ntsd_len);\n\t}\n\nout:\n\tposix_acl_release(fattr.cf_acls);\n\tposix_acl_release(fattr.cf_dacls);\n\tmark_inode_dirty(inode);\n\treturn rc;\n}\n\nvoid ksmbd_init_domain(u32 *sub_auth)\n{\n\tint i;\n\n\tmemcpy(&server_conf.domain_sid, &domain, sizeof(struct smb_sid));\n\tfor (i = 0; i < 3; ++i)\n\t\tserver_conf.domain_sid.sub_auth[i + 1] = cpu_to_le32(sub_auth[i]);\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n/*\n *   Copyright (c) International Business Machines  Corp., 2007\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *   Modified by Namjae Jeon (linkinjeon@kernel.org)\n */\n\n#ifndef _SMBACL_H\n#define _SMBACL_H\n\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/posix_acl.h>\n#include <linux/mnt_idmapping.h>\n\n#include \"mgmt/tree_connect.h\"\n\n#define NUM_AUTHS (6)\t/* number of authority fields */\n#define SID_MAX_SUB_AUTHORITIES (15) /* max number of sub authority fields */\n\n/*\n * ACE types - see MS-DTYP 2.4.4.1\n */\nenum {\n\tACCESS_ALLOWED,\n\tACCESS_DENIED,\n};\n\n/*\n * Security ID types\n */\nenum {\n\tSIDOWNER = 1,\n\tSIDGROUP,\n\tSIDCREATOR_OWNER,\n\tSIDCREATOR_GROUP,\n\tSIDUNIX_USER,\n\tSIDUNIX_GROUP,\n\tSIDNFS_USER,\n\tSIDNFS_GROUP,\n\tSIDNFS_MODE,\n};\n\n/* Revision for ACLs */\n#define SD_REVISION\t1\n\n/* Control flags for Security Descriptor */\n#define OWNER_DEFAULTED\t\t0x0001\n#define GROUP_DEFAULTED\t\t0x0002\n#define DACL_PRESENT\t\t0x0004\n#define DACL_DEFAULTED\t\t0x0008\n#define SACL_PRESENT\t\t0x0010\n#define SACL_DEFAULTED\t\t0x0020\n#define DACL_TRUSTED\t\t0x0040\n#define SERVER_SECURITY\t\t0x0080\n#define DACL_AUTO_INHERIT_REQ\t0x0100\n#define SACL_AUTO_INHERIT_REQ\t0x0200\n#define DACL_AUTO_INHERITED\t0x0400\n#define SACL_AUTO_INHERITED\t0x0800\n#define DACL_PROTECTED\t\t0x1000\n#define SACL_PROTECTED\t\t0x2000\n#define RM_CONTROL_VALID\t0x4000\n#define SELF_RELATIVE\t\t0x8000\n\n/* ACE types - see MS-DTYP 2.4.4.1 */\n#define ACCESS_ALLOWED_ACE_TYPE 0x00\n#define ACCESS_DENIED_ACE_TYPE  0x01\n#define SYSTEM_AUDIT_ACE_TYPE   0x02\n#define SYSTEM_ALARM_ACE_TYPE   0x03\n#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE 0x04\n#define ACCESS_ALLOWED_OBJECT_ACE_TYPE  0x05\n#define ACCESS_DENIED_OBJECT_ACE_TYPE   0x06\n#define SYSTEM_AUDIT_OBJECT_ACE_TYPE    0x07\n#define SYSTEM_ALARM_OBJECT_ACE_TYPE    0x08\n#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE 0x09\n#define ACCESS_DENIED_CALLBACK_ACE_TYPE 0x0A\n#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE 0x0B\n#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE  0x0C\n#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE  0x0D\n#define SYSTEM_ALARM_CALLBACK_ACE_TYPE  0x0E /* Reserved */\n#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE 0x0F\n#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE 0x10 /* reserved */\n#define SYSTEM_MANDATORY_LABEL_ACE_TYPE 0x11\n#define SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE 0x12\n#define SYSTEM_SCOPED_POLICY_ID_ACE_TYPE 0x13\n\n/* ACE flags */\n#define OBJECT_INHERIT_ACE\t\t0x01\n#define CONTAINER_INHERIT_ACE\t\t0x02\n#define NO_PROPAGATE_INHERIT_ACE\t0x04\n#define INHERIT_ONLY_ACE\t\t0x08\n#define INHERITED_ACE\t\t\t0x10\n#define SUCCESSFUL_ACCESS_ACE_FLAG\t0x40\n#define FAILED_ACCESS_ACE_FLAG\t\t0x80\n\n/*\n * Maximum size of a string representation of a SID:\n *\n * The fields are unsigned values in decimal. So:\n *\n * u8:  max 3 bytes in decimal\n * u32: max 10 bytes in decimal\n *\n * \"S-\" + 3 bytes for version field + 15 for authority field + NULL terminator\n *\n * For authority field, max is when all 6 values are non-zero and it must be\n * represented in hex. So \"-0x\" + 12 hex digits.\n *\n * Add 11 bytes for each subauthority field (10 bytes each + 1 for '-')\n */\n#define SID_STRING_BASE_SIZE (2 + 3 + 15 + 1)\n#define SID_STRING_SUBAUTH_SIZE (11) /* size of a single subauth string */\n\n#define DOMAIN_USER_RID_LE\tcpu_to_le32(513)\n\nstruct ksmbd_conn;\n\nstruct smb_ntsd {\n\t__le16 revision; /* revision level */\n\t__le16 type;\n\t__le32 osidoffset;\n\t__le32 gsidoffset;\n\t__le32 sacloffset;\n\t__le32 dacloffset;\n} __packed;\n\nstruct smb_sid {\n\t__u8 revision; /* revision level */\n\t__u8 num_subauth;\n\t__u8 authority[NUM_AUTHS];\n\t__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */\n} __packed;\n\n/* size of a struct cifs_sid, sans sub_auth array */\n#define CIFS_SID_BASE_SIZE (1 + 1 + NUM_AUTHS)\n\nstruct smb_acl {\n\t__le16 revision; /* revision level */\n\t__le16 size;\n\t__le32 num_aces;\n} __packed;\n\nstruct smb_ace {\n\t__u8 type;\n\t__u8 flags;\n\t__le16 size;\n\t__le32 access_req;\n\tstruct smb_sid sid; /* ie UUID of user or group who gets these perms */\n} __packed;\n\nstruct smb_fattr {\n\tkuid_t\tcf_uid;\n\tkgid_t\tcf_gid;\n\tumode_t\tcf_mode;\n\t__le32 daccess;\n\tstruct posix_acl *cf_acls;\n\tstruct posix_acl *cf_dacls;\n};\n\nstruct posix_ace_state {\n\tu32 allow;\n\tu32 deny;\n};\n\nstruct posix_user_ace_state {\n\tunion {\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t};\n\tstruct posix_ace_state perms;\n};\n\nstruct posix_ace_state_array {\n\tint n;\n\tstruct posix_user_ace_state aces[];\n};\n\n/*\n * while processing the nfsv4 ace, this maintains the partial permissions\n * calculated so far:\n */\n\nstruct posix_acl_state {\n\tstruct posix_ace_state owner;\n\tstruct posix_ace_state group;\n\tstruct posix_ace_state other;\n\tstruct posix_ace_state everyone;\n\tstruct posix_ace_state mask; /* deny unused in this case */\n\tstruct posix_ace_state_array *users;\n\tstruct posix_ace_state_array *groups;\n};\n\nint parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   int acl_len, struct smb_fattr *fattr);\nint build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,\n\t\t   struct smb_ntsd *ppntsd, int ppntsd_size, int addition_info,\n\t\t   __u32 *secdesclen, struct smb_fattr *fattr);\nint init_acl_state(struct posix_acl_state *state, int cnt);\nvoid free_acl_state(struct posix_acl_state *state);\nvoid posix_state_to_acl(struct posix_acl_state *state,\n\t\t\tstruct posix_acl_entry *pace);\nint compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid);\nbool smb_inherit_flags(int flags, bool is_dir);\nint smb_inherit_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t     unsigned int uid, unsigned int gid);\nint smb_check_perm_dacl(struct ksmbd_conn *conn, struct path *path,\n\t\t\t__le32 *pdaccess, int uid);\nint set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,\n\t\t struct path *path, struct smb_ntsd *pntsd, int ntsd_len,\n\t\t bool type_check);\nvoid id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid);\nvoid ksmbd_init_domain(u32 *sub_auth);\n\nstatic inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,\n\t\t\t\t\t    struct posix_acl_entry *pace)\n{\n\tkuid_t kuid;\n\n\t/* If this is an idmapped mount, apply the idmapping. */\n\tkuid = mapped_kuid_fs(mnt_userns, &init_user_ns, pace->e_uid);\n\n\t/* Translate the kuid into a userspace id ksmbd would see. */\n\treturn from_kuid(&init_user_ns, kuid);\n}\n\nstatic inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,\n\t\t\t\t\t    struct posix_acl_entry *pace)\n{\n\tkgid_t kgid;\n\n\t/* If this is an idmapped mount, apply the idmapping. */\n\tkgid = mapped_kgid_fs(mnt_userns, &init_user_ns, pace->e_gid);\n\n\t/* Translate the kgid into a userspace id ksmbd would see. */\n\treturn from_kgid(&init_user_ns, kgid);\n}\n\n#endif /* _SMBACL_H */\n", "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/xattr.h>\n#include <linux/falloc.h>\n#include <linux/fsnotify.h>\n#include <linux/dcache.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/xacct.h>\n#include <linux/crc32c.h>\n\n#include \"../internal.h\"\t/* for vfs_path_lookup */\n\n#include \"glob.h\"\n#include \"oplock.h\"\n#include \"connection.h\"\n#include \"vfs.h\"\n#include \"vfs_cache.h\"\n#include \"smbacl.h\"\n#include \"ndr.h\"\n#include \"auth.h\"\n#include \"misc.h\"\n\n#include \"smb_common.h\"\n#include \"mgmt/share_config.h\"\n#include \"mgmt/tree_connect.h\"\n#include \"mgmt/user_session.h\"\n#include \"mgmt/user_config.h\"\n\nstatic char *extract_last_component(char *path)\n{\n\tchar *p = strrchr(path, '/');\n\n\tif (p && p[1] != '\\0') {\n\t\t*p = '\\0';\n\t\tp++;\n\t} else {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nstatic void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,\n\t\t\t\t    struct inode *parent_inode,\n\t\t\t\t    struct inode *inode)\n{\n\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t    KSMBD_SHARE_FLAG_INHERIT_OWNER))\n\t\treturn;\n\n\ti_uid_write(inode, i_uid_read(parent_inode));\n}\n\n/**\n * ksmbd_vfs_lock_parent() - lock parent dentry if it is stable\n *\n * the parent dentry got by dget_parent or @parent could be\n * unstable, we try to lock a parent inode and lookup the\n * child dentry again.\n *\n * the reference count of @parent isn't incremented.\n */\nint ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,\n\t\t\t  struct dentry *child)\n{\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tinode_lock_nested(d_inode(parent), I_MUTEX_PARENT);\n\tdentry = lookup_one(user_ns, child->d_name.name, parent,\n\t\t\t    child->d_name.len);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto out_err;\n\t}\n\n\tif (dentry != child) {\n\t\tret = -ESTALE;\n\t\tdput(dentry);\n\t\tgoto out_err;\n\t}\n\n\tdput(dentry);\n\treturn 0;\nout_err:\n\tinode_unlock(d_inode(parent));\n\treturn ret;\n}\n\nint ksmbd_vfs_may_delete(struct user_namespace *user_ns,\n\t\t\t struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tint ret;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tret = inode_permission(user_ns, d_inode(parent),\n\t\t\t       MAY_EXEC | MAY_WRITE);\n\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\treturn ret;\n}\n\nint ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry, __le32 *daccess)\n{\n\tstruct dentry *parent;\n\tint ret = 0;\n\n\t*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_WRITE))\n\t\t*daccess |= cpu_to_le32(WRITE_DAC | WRITE_OWNER | SYNCHRONIZE |\n\t\t\t\tFILE_WRITE_DATA | FILE_APPEND_DATA |\n\t\t\t\tFILE_WRITE_EA | FILE_WRITE_ATTRIBUTES |\n\t\t\t\tFILE_DELETE_CHILD);\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_READ))\n\t\t*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;\n\n\tif (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_EXEC))\n\t\t*daccess |= FILE_EXECUTE_LE;\n\n\tparent = dget_parent(dentry);\n\tret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);\n\tif (ret) {\n\t\tdput(parent);\n\t\treturn ret;\n\t}\n\n\tif (!inode_permission(user_ns, d_inode(parent), MAY_EXEC | MAY_WRITE))\n\t\t*daccess |= FILE_DELETE_LE;\n\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\treturn ret;\n}\n\n/**\n * ksmbd_vfs_create() - vfs helper for smb create file\n * @work:\twork\n * @name:\tfile name that is relative to share\n * @mode:\tfile create mode\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS, &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -ENOENT)\n\t\t\tpr_err(\"path create failed for %s, err %d\\n\",\n\t\t\t       name, err);\n\t\treturn err;\n\t}\n\n\tmode |= S_IFREG;\n\terr = vfs_create(mnt_user_ns(path.mnt), d_inode(path.dentry),\n\t\t\t dentry, mode, true);\n\tif (!err) {\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry),\n\t\t\t\t\td_inode(dentry));\n\t} else {\n\t\tpr_err(\"File(%s): creation failed (err:%d)\\n\", name, err);\n\t}\n\tdone_path_create(&path, dentry);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_mkdir() - vfs helper for smb create directory\n * @work:\twork\n * @name:\tdirectory name that is relative to share\n * @mode:\tdirectory create mode\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = ksmbd_vfs_kern_path_create(work, name,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,\n\t\t\t\t\t    &path);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tif (err != -EEXIST)\n\t\t\tksmbd_debug(VFS, \"path create failed for %s, err %d\\n\",\n\t\t\t\t    name, err);\n\t\treturn err;\n\t}\n\n\tuser_ns = mnt_user_ns(path.mnt);\n\tmode |= S_IFDIR;\n\terr = vfs_mkdir(user_ns, d_inode(path.dentry), dentry, mode);\n\tif (err) {\n\t\tgoto out;\n\t} else if (d_unhashed(dentry)) {\n\t\tstruct dentry *d;\n\n\t\td = lookup_one(user_ns, dentry->d_name.name, dentry->d_parent,\n\t\t\t       dentry->d_name.len);\n\t\tif (IS_ERR(d)) {\n\t\t\terr = PTR_ERR(d);\n\t\t\tgoto out;\n\t\t}\n\t\tif (unlikely(d_is_negative(d))) {\n\t\t\tdput(d);\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tksmbd_vfs_inherit_owner(work, d_inode(path.dentry), d_inode(d));\n\t\tdput(d);\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (err)\n\t\tpr_err(\"mkdir(%s): creation failed (err:%d)\\n\", name, err);\n\treturn err;\n}\n\nstatic ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,\n\t\t\t\t      struct dentry *dentry, char *attr_name,\n\t\t\t\t      int attr_name_len, char **attr_value)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_getxattr(user_ns,\n\t\t\t\t\t       dentry,\n\t\t\t\t\t       name,\n\t\t\t\t\t       attr_value);\n\t\tif (value_len < 0)\n\t\t\tpr_err(\"failed to get xattr in file\\n\");\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nstatic int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t size_t count)\n{\n\tssize_t v_len;\n\tchar *stream_buf = NULL;\n\n\tksmbd_debug(VFS, \"read stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tv_len = ksmbd_vfs_getcasexattr(file_mnt_user_ns(fp->filp),\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif ((int)v_len <= 0)\n\t\treturn (int)v_len;\n\n\tif (v_len <= *pos) {\n\t\tcount = -EINVAL;\n\t\tgoto free_buf;\n\t}\n\n\tif (v_len - *pos < count)\n\t\tcount = v_len - *pos;\n\n\tmemcpy(buf, &stream_buf[*pos], count);\n\nfree_buf:\n\tkvfree(stream_buf);\n\treturn count;\n}\n\n/**\n * check_lock_range() - vfs helper for smb byte range file locking\n * @filp:\tthe file to apply the lock to\n * @start:\tlock start byte offset\n * @end:\tlock end byte offset\n * @type:\tbyte range type read/write\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int check_lock_range(struct file *filp, loff_t start, loff_t end,\n\t\t\t    unsigned char type)\n{\n\tstruct file_lock *flock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\tint error = 0;\n\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(flock, &ctx->flc_posix, fl_list) {\n\t\t/* check conflict locks */\n\t\tif (flock->fl_end >= start && end >= flock->fl_start) {\n\t\t\tif (flock->fl_type == F_RDLCK) {\n\t\t\t\tif (type == WRITE) {\n\t\t\t\t\tpr_err(\"not allow write by shared lock\\n\");\n\t\t\t\t\terror = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (flock->fl_type == F_WRLCK) {\n\t\t\t\t/* check owner in lock */\n\t\t\t\tif (flock->fl_file != filp) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tpr_err(\"not allow rw access by exclusive lock from other opens\\n\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn error;\n}\n\n/**\n * ksmbd_vfs_read() - vfs helper for smb file read\n * @work:\tsmb work\n * @fid:\tfile id of open file\n * @count:\tread byte count\n * @pos:\tfile pos\n *\n * Return:\tnumber of read bytes on success, otherwise error\n */\nint ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,\n\t\t   loff_t *pos)\n{\n\tstruct file *filp = fp->filp;\n\tssize_t nbytes = 0;\n\tchar *rbuf = work->aux_payload_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (unlikely(count == 0))\n\t\treturn 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\t\tpr_err(\"no right to read(%pd)\\n\",\n\t\t\t       fp->filp->f_path.dentry);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\tif (ksmbd_stream_fd(fp))\n\t\treturn ksmbd_vfs_stream_read(fp, rbuf, pos, count);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tint ret;\n\n\t\tret = check_lock_range(filp, *pos, *pos + count - 1, READ);\n\t\tif (ret) {\n\t\t\tpr_err(\"unable to read due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tnbytes = kernel_read(filp, rbuf, count, pos);\n\tif (nbytes < 0) {\n\t\tpr_err(\"smb read failed, err = %zd\\n\", nbytes);\n\t\treturn nbytes;\n\t}\n\n\tfilp->f_pos = *pos;\n\treturn nbytes;\n}\n\nstatic int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,\n\t\t\t\t  size_t count)\n{\n\tchar *stream_buf = NULL, *wbuf;\n\tstruct user_namespace *user_ns = file_mnt_user_ns(fp->filp);\n\tsize_t size, v_len;\n\tint err = 0;\n\n\tksmbd_debug(VFS, \"write stream data pos : %llu, count : %zd\\n\",\n\t\t    *pos, count);\n\n\tsize = *pos + count;\n\tif (size > XATTR_SIZE_MAX) {\n\t\tsize = XATTR_SIZE_MAX;\n\t\tcount = (*pos + count) - XATTR_SIZE_MAX;\n\t}\n\n\tv_len = ksmbd_vfs_getcasexattr(user_ns,\n\t\t\t\t       fp->filp->f_path.dentry,\n\t\t\t\t       fp->stream.name,\n\t\t\t\t       fp->stream.size,\n\t\t\t\t       &stream_buf);\n\tif ((int)v_len < 0) {\n\t\tpr_err(\"not found stream in xattr : %zd\\n\", v_len);\n\t\terr = (int)v_len;\n\t\tgoto out;\n\t}\n\n\tif (v_len < size) {\n\t\twbuf = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);\n\t\tif (!wbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (v_len > 0)\n\t\t\tmemcpy(wbuf, stream_buf, v_len);\n\t\tkvfree(stream_buf);\n\t\tstream_buf = wbuf;\n\t}\n\n\tmemcpy(&stream_buf[*pos], buf, count);\n\n\terr = ksmbd_vfs_setxattr(user_ns,\n\t\t\t\t fp->filp->f_path.dentry,\n\t\t\t\t fp->stream.name,\n\t\t\t\t (void *)stream_buf,\n\t\t\t\t size,\n\t\t\t\t 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfp->filp->f_pos = *pos;\n\terr = 0;\nout:\n\tkvfree(stream_buf);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_write() - vfs helper for smb file write\n * @work:\twork\n * @fid:\tfile id of open file\n * @buf:\tbuf containing data for writing\n * @count:\tread byte count\n * @pos:\tfile pos\n * @sync:\tfsync after write\n * @written:\tnumber of bytes written\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t    char *buf, size_t count, loff_t *pos, bool sync,\n\t\t    ssize_t *written)\n{\n\tstruct file *filp;\n\tloff_t\toffset = *pos;\n\tint err = 0;\n\n\tif (work->conn->connection_type) {\n\t\tif (!(fp->daccess & FILE_WRITE_DATA_LE)) {\n\t\t\tpr_err(\"no right to write(%pd)\\n\",\n\t\t\t       fp->filp->f_path.dentry);\n\t\t\terr = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfilp = fp->filp;\n\n\tif (ksmbd_stream_fd(fp)) {\n\t\terr = ksmbd_vfs_stream_write(fp, buf, pos, count);\n\t\tif (!err)\n\t\t\t*written = count;\n\t\tgoto out;\n\t}\n\n\tif (!work->tcon->posix_extensions) {\n\t\terr = check_lock_range(filp, *pos, *pos + count - 1, WRITE);\n\t\tif (err) {\n\t\t\tpr_err(\"unable to write due to lock\\n\");\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Do we need to break any of a levelII oplock? */\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\terr = kernel_write(filp, buf, count, pos);\n\tif (err < 0) {\n\t\tksmbd_debug(VFS, \"smb write failed, err = %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfilp->f_pos = *pos;\n\t*written = err;\n\terr = 0;\n\tif (sync) {\n\t\terr = vfs_fsync_range(filp, offset, offset + *written, 0);\n\t\tif (err < 0)\n\t\t\tpr_err(\"fsync failed for filename = %pd, err = %d\\n\",\n\t\t\t       fp->filp->f_path.dentry, err);\n\t}\n\nout:\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_getattr() - vfs helper for smb getattr\n * @work:\twork\n * @fid:\tfile id of open file\n * @attrs:\tinode attributes\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint err;\n\n\terr = vfs_getattr(path, stat, STATX_BTIME, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\tpr_err(\"getattr failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_fsync() - vfs helper for smb fsync\n * @work:\twork\n * @fid:\tfile id of open file\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)\n{\n\tstruct ksmbd_file *fp;\n\tint err;\n\n\tfp = ksmbd_lookup_fd_slow(work, fid, p_id);\n\tif (!fp) {\n\t\tpr_err(\"failed to get filp for fid %llu\\n\", fid);\n\t\treturn -ENOENT;\n\t}\n\terr = vfs_fsync(fp->filp, 0);\n\tif (err < 0)\n\t\tpr_err(\"smb fsync failed, err = %d\\n\", err);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_remove_file() - vfs helper for smb rmdir or unlink\n * @name:\tdirectory or file name that is relative to share\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path path;\n\tstruct dentry *parent;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\terr = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, false);\n\tif (err) {\n\t\tksmbd_debug(VFS, \"can't get %s, err %d\\n\", name, err);\n\t\tksmbd_revert_fsids(work);\n\t\treturn err;\n\t}\n\n\tuser_ns = mnt_user_ns(path.mnt);\n\tparent = dget_parent(path.dentry);\n\terr = ksmbd_vfs_lock_parent(user_ns, parent, path.dentry);\n\tif (err) {\n\t\tdput(parent);\n\t\tpath_put(&path);\n\t\tksmbd_revert_fsids(work);\n\t\treturn err;\n\t}\n\n\tif (!d_inode(path.dentry)->i_nlink) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tif (S_ISDIR(d_inode(path.dentry)->i_mode)) {\n\t\terr = vfs_rmdir(user_ns, d_inode(parent), path.dentry);\n\t\tif (err && err != -ENOTEMPTY)\n\t\t\tksmbd_debug(VFS, \"%s: rmdir failed, err %d\\n\", name,\n\t\t\t\t    err);\n\t} else {\n\t\terr = vfs_unlink(user_ns, d_inode(parent), path.dentry, NULL);\n\t\tif (err)\n\t\t\tksmbd_debug(VFS, \"%s: unlink failed, err %d\\n\", name,\n\t\t\t\t    err);\n\t}\n\nout_err:\n\tinode_unlock(d_inode(parent));\n\tdput(parent);\n\tpath_put(&path);\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_link() - vfs helper for creating smb hardlink\n * @oldname:\tsource file name\n * @newname:\thardlink name that is relative to share\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,\n\t\t   const char *newname)\n{\n\tstruct path oldpath, newpath;\n\tstruct dentry *dentry;\n\tint err;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\terr = kern_path(oldname, LOOKUP_NO_SYMLINKS, &oldpath);\n\tif (err) {\n\t\tpr_err(\"cannot get linux path for %s, err = %d\\n\",\n\t\t       oldname, err);\n\t\tgoto out1;\n\t}\n\n\tdentry = ksmbd_vfs_kern_path_create(work, newname,\n\t\t\t\t\t    LOOKUP_NO_SYMLINKS | LOOKUP_REVAL,\n\t\t\t\t\t    &newpath);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tpr_err(\"path create err for %s, err %d\\n\", newname, err);\n\t\tgoto out2;\n\t}\n\n\terr = -EXDEV;\n\tif (oldpath.mnt != newpath.mnt) {\n\t\tpr_err(\"vfs_link failed err %d\\n\", err);\n\t\tgoto out3;\n\t}\n\n\terr = vfs_link(oldpath.dentry, mnt_user_ns(newpath.mnt),\n\t\t       d_inode(newpath.dentry),\n\t\t       dentry, NULL);\n\tif (err)\n\t\tksmbd_debug(VFS, \"vfs_link failed err %d\\n\", err);\n\nout3:\n\tdone_path_create(&newpath, dentry);\nout2:\n\tpath_put(&oldpath);\nout1:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\nstatic int ksmbd_validate_entry_in_use(struct dentry *src_dent)\n{\n\tstruct dentry *dst_dent;\n\n\tspin_lock(&src_dent->d_lock);\n\tlist_for_each_entry(dst_dent, &src_dent->d_subdirs, d_child) {\n\t\tstruct ksmbd_file *child_fp;\n\n\t\tif (d_really_is_negative(dst_dent))\n\t\t\tcontinue;\n\n\t\tchild_fp = ksmbd_lookup_fd_inode(d_inode(dst_dent));\n\t\tif (child_fp) {\n\t\t\tspin_unlock(&src_dent->d_lock);\n\t\t\tksmbd_debug(VFS, \"Forbid rename, sub file/dir is in use\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\tspin_unlock(&src_dent->d_lock);\n\n\treturn 0;\n}\n\nstatic int __ksmbd_vfs_rename(struct ksmbd_work *work,\n\t\t\t      struct user_namespace *src_user_ns,\n\t\t\t      struct dentry *src_dent_parent,\n\t\t\t      struct dentry *src_dent,\n\t\t\t      struct user_namespace *dst_user_ns,\n\t\t\t      struct dentry *dst_dent_parent,\n\t\t\t      struct dentry *trap_dent,\n\t\t\t      char *dst_name)\n{\n\tstruct dentry *dst_dent;\n\tint err;\n\n\tif (!work->tcon->posix_extensions) {\n\t\terr = ksmbd_validate_entry_in_use(src_dent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (d_really_is_negative(src_dent_parent))\n\t\treturn -ENOENT;\n\tif (d_really_is_negative(dst_dent_parent))\n\t\treturn -ENOENT;\n\tif (d_really_is_negative(src_dent))\n\t\treturn -ENOENT;\n\tif (src_dent == trap_dent)\n\t\treturn -EINVAL;\n\n\tif (ksmbd_override_fsids(work))\n\t\treturn -ENOMEM;\n\n\tdst_dent = lookup_one(dst_user_ns, dst_name, dst_dent_parent,\n\t\t\t      strlen(dst_name));\n\terr = PTR_ERR(dst_dent);\n\tif (IS_ERR(dst_dent)) {\n\t\tpr_err(\"lookup failed %s [%d]\\n\", dst_name, err);\n\t\tgoto out;\n\t}\n\n\terr = -ENOTEMPTY;\n\tif (dst_dent != trap_dent && !d_really_is_positive(dst_dent)) {\n\t\tstruct renamedata rd = {\n\t\t\t.old_mnt_userns\t= src_user_ns,\n\t\t\t.old_dir\t= d_inode(src_dent_parent),\n\t\t\t.old_dentry\t= src_dent,\n\t\t\t.new_mnt_userns\t= dst_user_ns,\n\t\t\t.new_dir\t= d_inode(dst_dent_parent),\n\t\t\t.new_dentry\t= dst_dent,\n\t\t};\n\t\terr = vfs_rename(&rd);\n\t}\n\tif (err)\n\t\tpr_err(\"vfs_rename failed err %d\\n\", err);\n\tif (dst_dent)\n\t\tdput(dst_dent);\nout:\n\tksmbd_revert_fsids(work);\n\treturn err;\n}\n\nint ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\tchar *newname)\n{\n\tstruct user_namespace *user_ns;\n\tstruct path dst_path;\n\tstruct dentry *src_dent_parent, *dst_dent_parent;\n\tstruct dentry *src_dent, *trap_dent, *src_child;\n\tchar *dst_name;\n\tint err;\n\n\tdst_name = extract_last_component(newname);\n\tif (!dst_name) {\n\t\tdst_name = newname;\n\t\tnewname = \"\";\n\t}\n\n\tsrc_dent_parent = dget_parent(fp->filp->f_path.dentry);\n\tsrc_dent = fp->filp->f_path.dentry;\n\n\terr = ksmbd_vfs_kern_path(work, newname,\n\t\t\t\t  LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,\n\t\t\t\t  &dst_path, false);\n\tif (err) {\n\t\tksmbd_debug(VFS, \"Cannot get path for %s [%d]\\n\", newname, err);\n\t\tgoto out;\n\t}\n\tdst_dent_parent = dst_path.dentry;\n\n\ttrap_dent = lock_rename(src_dent_parent, dst_dent_parent);\n\tdget(src_dent);\n\tdget(dst_dent_parent);\n\tuser_ns = file_mnt_user_ns(fp->filp);\n\tsrc_child = lookup_one(user_ns, src_dent->d_name.name, src_dent_parent,\n\t\t\t       src_dent->d_name.len);\n\tif (IS_ERR(src_child)) {\n\t\terr = PTR_ERR(src_child);\n\t\tgoto out_lock;\n\t}\n\n\tif (src_child != src_dent) {\n\t\terr = -ESTALE;\n\t\tdput(src_child);\n\t\tgoto out_lock;\n\t}\n\tdput(src_child);\n\n\terr = __ksmbd_vfs_rename(work,\n\t\t\t\t user_ns,\n\t\t\t\t src_dent_parent,\n\t\t\t\t src_dent,\n\t\t\t\t mnt_user_ns(dst_path.mnt),\n\t\t\t\t dst_dent_parent,\n\t\t\t\t trap_dent,\n\t\t\t\t dst_name);\nout_lock:\n\tdput(src_dent);\n\tdput(dst_dent_parent);\n\tunlock_rename(src_dent_parent, dst_dent_parent);\n\tpath_put(&dst_path);\nout:\n\tdput(src_dent_parent);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_truncate() - vfs helper for smb file truncate\n * @work:\twork\n * @fid:\tfile id of old file\n * @size:\ttruncate to given size\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_truncate(struct ksmbd_work *work,\n\t\t       struct ksmbd_file *fp, loff_t size)\n{\n\tint err = 0;\n\tstruct file *filp;\n\n\tfilp = fp->filp;\n\n\t/* Do we need to break any of a levelII oplock? */\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tstruct inode *inode = file_inode(filp);\n\n\t\tif (size < inode->i_size) {\n\t\t\terr = check_lock_range(filp, size,\n\t\t\t\t\t       inode->i_size - 1, WRITE);\n\t\t} else {\n\t\t\terr = check_lock_range(filp, inode->i_size,\n\t\t\t\t\t       size - 1, WRITE);\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err(\"failed due to lock\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\terr = vfs_truncate(&filp->f_path, size);\n\tif (err)\n\t\tpr_err(\"truncate failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_listxattr() - vfs helper for smb list extended attributes\n * @dentry:\tdentry of file for listing xattrs\n * @list:\tdestination buffer\n * @size:\tdestination buffer length\n *\n * Return:\txattr list length on success, otherwise error\n */\nssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)\n{\n\tssize_t size;\n\tchar *vlist = NULL;\n\n\tsize = vfs_listxattr(dentry, NULL, 0);\n\tif (size <= 0)\n\t\treturn size;\n\n\tvlist = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vlist)\n\t\treturn -ENOMEM;\n\n\t*list = vlist;\n\tsize = vfs_listxattr(dentry, vlist, size);\n\tif (size < 0) {\n\t\tksmbd_debug(VFS, \"listxattr failed\\n\");\n\t\tkvfree(vlist);\n\t\t*list = NULL;\n\t}\n\n\treturn size;\n}\n\nstatic ssize_t ksmbd_vfs_xattr_len(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry, char *xattr_name)\n{\n\treturn vfs_getxattr(user_ns, dentry, xattr_name, NULL, 0);\n}\n\n/**\n * ksmbd_vfs_getxattr() - vfs helper for smb get extended attributes value\n * @user_ns:\tuser namespace\n * @dentry:\tdentry of file for getting xattrs\n * @xattr_name:\tname of xattr name to query\n * @xattr_buf:\tdestination buffer xattr value\n *\n * Return:\tread xattr value length on success, otherwise error\n */\nssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   char *xattr_name, char **xattr_buf)\n{\n\tssize_t xattr_len;\n\tchar *buf;\n\n\t*xattr_buf = NULL;\n\txattr_len = ksmbd_vfs_xattr_len(user_ns, dentry, xattr_name);\n\tif (xattr_len < 0)\n\t\treturn xattr_len;\n\n\tbuf = kmalloc(xattr_len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\txattr_len = vfs_getxattr(user_ns, dentry, xattr_name,\n\t\t\t\t (void *)buf, xattr_len);\n\tif (xattr_len > 0)\n\t\t*xattr_buf = buf;\n\telse\n\t\tkfree(buf);\n\treturn xattr_len;\n}\n\n/**\n * ksmbd_vfs_setxattr() - vfs helper for smb set extended attributes value\n * @user_ns:\tuser namespace\n * @dentry:\tdentry to set XATTR at\n * @name:\txattr name for setxattr\n * @value:\txattr value to set\n * @size:\tsize of xattr value\n * @flags:\tdestination buffer length\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_setxattr(struct user_namespace *user_ns,\n\t\t       struct dentry *dentry, const char *attr_name,\n\t\t       const void *attr_value, size_t attr_size, int flags)\n{\n\tint err;\n\n\terr = vfs_setxattr(user_ns,\n\t\t\t   dentry,\n\t\t\t   attr_name,\n\t\t\t   attr_value,\n\t\t\t   attr_size,\n\t\t\t   flags);\n\tif (err)\n\t\tksmbd_debug(VFS, \"setxattr failed, err %d\\n\", err);\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_set_fadvise() - convert smb IO caching options to linux options\n * @filp:\tfile pointer for IO\n * @options:\tsmb IO options\n */\nvoid ksmbd_vfs_set_fadvise(struct file *filp, __le32 option)\n{\n\tstruct address_space *mapping;\n\n\tmapping = filp->f_mapping;\n\n\tif (!option || !mapping)\n\t\treturn;\n\n\tif (option & FILE_WRITE_THROUGH_LE) {\n\t\tfilp->f_flags |= O_SYNC;\n\t} else if (option & FILE_SEQUENTIAL_ONLY_LE) {\n\t\tfilp->f_ra.ra_pages = inode_to_bdi(mapping->host)->ra_pages * 2;\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t} else if (option & FILE_RANDOM_ACCESS_LE) {\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&filp->f_lock);\n\t}\n}\n\nint ksmbd_vfs_zero_data(struct ksmbd_work *work, struct ksmbd_file *fp,\n\t\t\tloff_t off, loff_t len)\n{\n\tsmb_break_all_levII_oplock(work, fp, 1);\n\tif (fp->f_ci->m_fattr & FILE_ATTRIBUTE_SPARSE_FILE_LE)\n\t\treturn vfs_fallocate(fp->filp,\n\t\t\t\t     FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\t     off, len);\n\n\treturn vfs_fallocate(fp->filp,\n\t\t\t     FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE,\n\t\t\t     off, len);\n}\n\nint ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,\n\t\t\t struct file_allocated_range_buffer *ranges,\n\t\t\t unsigned int in_count, unsigned int *out_count)\n{\n\tstruct file *f = fp->filp;\n\tstruct inode *inode = file_inode(fp->filp);\n\tloff_t maxbytes = (u64)inode->i_sb->s_maxbytes, end;\n\tloff_t extent_start, extent_end;\n\tint ret = 0;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\tif (!in_count)\n\t\treturn 0;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (length > maxbytes || (maxbytes - length) < start)\n\t\tlength = maxbytes - start;\n\n\tif (start + length > inode->i_size)\n\t\tlength = inode->i_size - start;\n\n\t*out_count = 0;\n\tend = start + length;\n\twhile (start < end && *out_count < in_count) {\n\t\textent_start = vfs_llseek(f, start, SEEK_DATA);\n\t\tif (extent_start < 0) {\n\t\t\tif (extent_start != -ENXIO)\n\t\t\t\tret = (int)extent_start;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_start >= end)\n\t\t\tbreak;\n\n\t\textent_end = vfs_llseek(f, extent_start, SEEK_HOLE);\n\t\tif (extent_end < 0) {\n\t\t\tif (extent_end != -ENXIO)\n\t\t\t\tret = (int)extent_end;\n\t\t\tbreak;\n\t\t} else if (extent_start >= extent_end) {\n\t\t\tbreak;\n\t\t}\n\n\t\tranges[*out_count].file_offset = cpu_to_le64(extent_start);\n\t\tranges[(*out_count)++].length =\n\t\t\tcpu_to_le64(min(extent_end, end) - extent_start);\n\n\t\tstart = extent_end;\n\t}\n\n\treturn ret;\n}\n\nint ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry, char *attr_name)\n{\n\treturn vfs_removexattr(user_ns, dentry, attr_name);\n}\n\nint ksmbd_vfs_unlink(struct user_namespace *user_ns,\n\t\t     struct dentry *dir, struct dentry *dentry)\n{\n\tint err = 0;\n\n\terr = ksmbd_vfs_lock_parent(user_ns, dir, dentry);\n\tif (err)\n\t\treturn err;\n\tdget(dentry);\n\n\tif (S_ISDIR(d_inode(dentry)->i_mode))\n\t\terr = vfs_rmdir(user_ns, d_inode(dir), dentry);\n\telse\n\t\terr = vfs_unlink(user_ns, d_inode(dir), dentry, NULL);\n\n\tdput(dentry);\n\tinode_unlock(d_inode(dir));\n\tif (err)\n\t\tksmbd_debug(VFS, \"failed to delete, err %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int __dir_empty(struct dir_context *ctx, const char *name, int namlen,\n\t\t       loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\tbuf->dirent_count++;\n\n\tif (buf->dirent_count > 2)\n\t\treturn -ENOTEMPTY;\n\treturn 0;\n}\n\n/**\n * ksmbd_vfs_empty_dir() - check for empty directory\n * @fp:\tksmbd file pointer\n *\n * Return:\ttrue if directory empty, otherwise false\n */\nint ksmbd_vfs_empty_dir(struct ksmbd_file *fp)\n{\n\tint err;\n\tstruct ksmbd_readdir_data readdir_data;\n\n\tmemset(&readdir_data, 0, sizeof(struct ksmbd_readdir_data));\n\n\tset_ctx_actor(&readdir_data.ctx, __dir_empty);\n\treaddir_data.dirent_count = 0;\n\n\terr = iterate_dir(fp->filp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 2)\n\t\terr = -ENOTEMPTY;\n\telse\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int __caseless_lookup(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct ksmbd_readdir_data *buf;\n\n\tbuf = container_of(ctx, struct ksmbd_readdir_data, ctx);\n\n\tif (buf->used != namlen)\n\t\treturn 0;\n\tif (!strncasecmp((char *)buf->private, name, namlen)) {\n\t\tmemcpy((char *)buf->private, name, namlen);\n\t\tbuf->dirent_count = 1;\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\n/**\n * ksmbd_vfs_lookup_in_dir() - lookup a file in a directory\n * @dir:\tpath info\n * @name:\tfilename to lookup\n * @namelen:\tfilename length\n *\n * Return:\t0 on success, otherwise error\n */\nstatic int ksmbd_vfs_lookup_in_dir(struct path *dir, char *name, size_t namelen)\n{\n\tint ret;\n\tstruct file *dfilp;\n\tint flags = O_RDONLY | O_LARGEFILE;\n\tstruct ksmbd_readdir_data readdir_data = {\n\t\t.ctx.actor\t= __caseless_lookup,\n\t\t.private\t= name,\n\t\t.used\t\t= namelen,\n\t\t.dirent_count\t= 0,\n\t};\n\n\tdfilp = dentry_open(dir, flags, current_cred());\n\tif (IS_ERR(dfilp))\n\t\treturn PTR_ERR(dfilp);\n\n\tret = iterate_dir(dfilp, &readdir_data.ctx);\n\tif (readdir_data.dirent_count > 0)\n\t\tret = 0;\n\tfput(dfilp);\n\treturn ret;\n}\n\n/**\n * ksmbd_vfs_kern_path() - lookup a file and get path info\n * @name:\tfile path that is relative to share\n * @flags:\tlookup flags\n * @path:\tif lookup succeed, return path info\n * @caseless:\tcaseless filename lookup\n *\n * Return:\t0 on success, otherwise error\n */\nint ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,\n\t\t\tunsigned int flags, struct path *path, bool caseless)\n{\n\tstruct ksmbd_share_config *share_conf = work->tcon->share_conf;\n\tint err;\n\n\tflags |= LOOKUP_BENEATH;\n\terr = vfs_path_lookup(share_conf->vfs_path.dentry,\n\t\t\t      share_conf->vfs_path.mnt,\n\t\t\t      name,\n\t\t\t      flags,\n\t\t\t      path);\n\tif (!err)\n\t\treturn 0;\n\n\tif (caseless) {\n\t\tchar *filepath;\n\t\tstruct path parent;\n\t\tsize_t path_len, remain_len;\n\n\t\tfilepath = kstrdup(name, GFP_KERNEL);\n\t\tif (!filepath)\n\t\t\treturn -ENOMEM;\n\n\t\tpath_len = strlen(filepath);\n\t\tremain_len = path_len;\n\n\t\tparent = share_conf->vfs_path;\n\t\tpath_get(&parent);\n\n\t\twhile (d_can_lookup(parent.dentry)) {\n\t\t\tchar *filename = filepath + path_len - remain_len;\n\t\t\tchar *next = strchrnul(filename, '/');\n\t\t\tsize_t filename_len = next - filename;\n\t\t\tbool is_last = !next[0];\n\n\t\t\tif (filename_len == 0)\n\t\t\t\tbreak;\n\n\t\t\terr = ksmbd_vfs_lookup_in_dir(&parent, filename,\n\t\t\t\t\t\t      filename_len);\n\t\t\tpath_put(&parent);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnext[0] = '\\0';\n\n\t\t\terr = vfs_path_lookup(share_conf->vfs_path.dentry,\n\t\t\t\t\t      share_conf->vfs_path.mnt,\n\t\t\t\t\t      filepath,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      &parent);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\telse if (is_last) {\n\t\t\t\t*path = parent;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnext[0] = '/';\n\t\t\tremain_len -= filename_len + 1;\n\t\t}\n\n\t\tpath_put(&parent);\n\t\terr = -EINVAL;\nout:\n\t\tkfree(filepath);\n\t}\n\treturn err;\n}\n\nstruct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t  struct path *path)\n{\n\tchar *abs_name;\n\tstruct dentry *dent;\n\n\tabs_name = convert_to_unix_name(work->tcon->share_conf, name);\n\tif (!abs_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdent = kern_path_create(AT_FDCWD, abs_name, path, flags);\n\tkfree(abs_name);\n\treturn dent;\n}\n\nint ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t     name += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||\n\t\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,\n\t\t\t     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {\n\t\t\terr = ksmbd_vfs_remove_xattr(user_ns, dentry, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"remove acl xattr failed : %s\\n\", name);\n\t\t}\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nint ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,\n\t\t\t       struct dentry *dentry)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t xattr_list_len;\n\tint err = 0;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len < 0) {\n\t\tgoto out;\n\t} else if (!xattr_list_len) {\n\t\tksmbd_debug(SMB, \"empty xattr in the file\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(SMB, \"%s, len %zd\\n\", name, strlen(name));\n\n\t\tif (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {\n\t\t\terr = ksmbd_vfs_remove_xattr(user_ns, dentry, name);\n\t\t\tif (err)\n\t\t\t\tksmbd_debug(SMB, \"remove xattr failed : %s\\n\", name);\n\t\t}\n\t}\nout:\n\tkvfree(xattr_list);\n\treturn err;\n}\n\nstatic struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,\n\t\t\t\t\t\t\t    struct inode *inode,\n\t\t\t\t\t\t\t    int acl_type)\n{\n\tstruct xattr_smb_acl *smb_acl = NULL;\n\tstruct posix_acl *posix_acls;\n\tstruct posix_acl_entry *pa_entry;\n\tstruct xattr_acl_entry *xa_entry;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn NULL;\n\n\tposix_acls = get_acl(inode, acl_type);\n\tif (!posix_acls)\n\t\treturn NULL;\n\n\tsmb_acl = kzalloc(sizeof(struct xattr_smb_acl) +\n\t\t\t  sizeof(struct xattr_acl_entry) * posix_acls->a_count,\n\t\t\t  GFP_KERNEL);\n\tif (!smb_acl)\n\t\tgoto out;\n\n\tsmb_acl->count = posix_acls->a_count;\n\tpa_entry = posix_acls->a_entries;\n\txa_entry = smb_acl->entries;\n\tfor (i = 0; i < posix_acls->a_count; i++, pa_entry++, xa_entry++) {\n\t\tswitch (pa_entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\txa_entry->type = SMB_ACL_USER;\n\t\t\txa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\t\txa_entry->type = SMB_ACL_USER_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\txa_entry->type = SMB_ACL_GROUP;\n\t\t\txa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\txa_entry->type = SMB_ACL_GROUP_OBJ;\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\txa_entry->type = SMB_ACL_OTHER;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\txa_entry->type = SMB_ACL_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"unknown type : 0x%x\\n\", pa_entry->e_tag);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pa_entry->e_perm & ACL_READ)\n\t\t\txa_entry->perm |= SMB_ACL_READ;\n\t\tif (pa_entry->e_perm & ACL_WRITE)\n\t\t\txa_entry->perm |= SMB_ACL_WRITE;\n\t\tif (pa_entry->e_perm & ACL_EXECUTE)\n\t\t\txa_entry->perm |= SMB_ACL_EXECUTE;\n\t}\nout:\n\tposix_acl_release(posix_acls);\n\treturn smb_acl;\n}\n\nint ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct smb_ntsd *pntsd, int len)\n{\n\tint rc;\n\tstruct ndr sd_ndr = {0}, acl_ndr = {0};\n\tstruct xattr_ntacl acl = {0};\n\tstruct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;\n\tstruct inode *inode = d_inode(dentry);\n\n\tacl.version = 4;\n\tacl.hash_type = XATTR_SD_HASH_TYPE_SHA256;\n\tacl.current_time = ksmbd_UnixTimeToNT(current_time(inode));\n\n\tmemcpy(acl.desc, \"posix_acl\", 9);\n\tacl.desc_len = 10;\n\n\tpntsd->osidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->osidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->gsidoffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->gsidoffset) + NDR_NTSD_OFFSETOF);\n\tpntsd->dacloffset =\n\t\tcpu_to_le32(le32_to_cpu(pntsd->dacloffset) + NDR_NTSD_OFFSETOF);\n\n\tacl.sd_buf = (char *)pntsd;\n\tacl.sd_size = len;\n\n\trc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\treturn rc;\n\t}\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode,\n\t\t\t\t  smb_acl, def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,\n\t\t\t       acl.posix_acl_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ndr_encode_v4_ntacl(&sd_ndr, &acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out;\n\t}\n\n\trc = ksmbd_vfs_setxattr(user_ns, dentry,\n\t\t\t\tXATTR_NAME_SD, sd_ndr.data,\n\t\t\t\tsd_ndr.offset, 0);\n\tif (rc < 0)\n\t\tpr_err(\"Failed to store XATTR ntacl :%d\\n\", rc);\n\n\tkfree(sd_ndr.data);\nout:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\treturn rc;\n}\n\nint ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,\n\t\t\t   struct user_namespace *user_ns,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct smb_ntsd **pntsd)\n{\n\tint rc;\n\tstruct ndr n;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ndr acl_ndr = {0};\n\tstruct xattr_ntacl acl;\n\tstruct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;\n\t__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};\n\n\trc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);\n\tif (rc <= 0)\n\t\treturn rc;\n\n\tn.length = rc;\n\trc = ndr_decode_v4_ntacl(&n, &acl);\n\tif (rc)\n\t\tgoto free_n_data;\n\n\tsmb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t ACL_TYPE_ACCESS);\n\tif (S_ISDIR(inode->i_mode))\n\t\tdef_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,\n\t\t\t\t\t\t\t     ACL_TYPE_DEFAULT);\n\n\trc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,\n\t\t\t\t  def_smb_acl);\n\tif (rc) {\n\t\tpr_err(\"failed to encode ndr to posix acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\trc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);\n\tif (rc) {\n\t\tpr_err(\"failed to generate hash for ndr acl\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {\n\t\tpr_err(\"hash value diff\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t*pntsd = acl.sd_buf;\n\tif (acl.sd_size < sizeof(struct smb_ntsd)) {\n\t\tpr_err(\"sd size is invalid\\n\");\n\t\tgoto out_free;\n\t}\n\n\t(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\t(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -\n\t\t\t\t\t   NDR_NTSD_OFFSETOF);\n\n\trc = acl.sd_size;\nout_free:\n\tkfree(acl_ndr.data);\n\tkfree(smb_acl);\n\tkfree(def_smb_acl);\n\tif (rc < 0) {\n\t\tkfree(acl.sd_buf);\n\t\t*pntsd = NULL;\n\t}\n\nfree_n_data:\n\tkfree(n.data);\n\treturn rc;\n}\n\nint ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry,\n\t\t\t\t   struct xattr_dos_attrib *da)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ndr_encode_dos_attr(&n, da);\n\tif (err)\n\t\treturn err;\n\n\terr = ksmbd_vfs_setxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (void *)n.data, n.offset, 0);\n\tif (err)\n\t\tksmbd_debug(SMB, \"failed to store dos attribute in xattr\\n\");\n\tkfree(n.data);\n\n\treturn err;\n}\n\nint ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,\n\t\t\t\t   struct dentry *dentry,\n\t\t\t\t   struct xattr_dos_attrib *da)\n{\n\tstruct ndr n;\n\tint err;\n\n\terr = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,\n\t\t\t\t (char **)&n.data);\n\tif (err > 0) {\n\t\tn.length = err;\n\t\tif (ndr_decode_dos_attr(&n, da))\n\t\t\terr = -EINVAL;\n\t\tkfree(n.data);\n\t} else {\n\t\tksmbd_debug(SMB, \"failed to load dos attribute in xattr\\n\");\n\t}\n\n\treturn err;\n}\n\n/**\n * ksmbd_vfs_init_kstat() - convert unix stat information to smb stat format\n * @p:          destination buffer\n * @ksmbd_kstat:      ksmbd kstat wrapper\n */\nvoid *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)\n{\n\tstruct file_directory_info *info = (struct file_directory_info *)(*p);\n\tstruct kstat *kstat = ksmbd_kstat->kstat;\n\tu64 time;\n\n\tinfo->FileIndex = 0;\n\tinfo->CreationTime = cpu_to_le64(ksmbd_kstat->create_time);\n\ttime = ksmbd_UnixTimeToNT(kstat->atime);\n\tinfo->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->mtime);\n\tinfo->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(kstat->ctime);\n\tinfo->ChangeTime = cpu_to_le64(time);\n\n\tif (ksmbd_kstat->file_attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {\n\t\tinfo->EndOfFile = 0;\n\t\tinfo->AllocationSize = 0;\n\t} else {\n\t\tinfo->EndOfFile = cpu_to_le64(kstat->size);\n\t\tinfo->AllocationSize = cpu_to_le64(kstat->blocks << 9);\n\t}\n\tinfo->ExtFileAttributes = ksmbd_kstat->file_attributes;\n\n\treturn info;\n}\n\nint ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,\n\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry,\n\t\t\t\tstruct ksmbd_kstat *ksmbd_kstat)\n{\n\tu64 time;\n\tint rc;\n\n\tgeneric_fillattr(user_ns, d_inode(dentry), ksmbd_kstat->kstat);\n\n\ttime = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);\n\tksmbd_kstat->create_time = time;\n\n\t/*\n\t * set default value for the case that store dos attributes is not yes\n\t * or that acl is disable in server's filesystem and the config is yes.\n\t */\n\tif (S_ISDIR(ksmbd_kstat->kstat->mode))\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_DIRECTORY_LE;\n\telse\n\t\tksmbd_kstat->file_attributes = FILE_ATTRIBUTE_ARCHIVE_LE;\n\n\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {\n\t\tstruct xattr_dos_attrib da;\n\n\t\trc = ksmbd_vfs_get_dos_attrib_xattr(user_ns, dentry, &da);\n\t\tif (rc > 0) {\n\t\t\tksmbd_kstat->file_attributes = cpu_to_le32(da.attr);\n\t\t\tksmbd_kstat->create_time = da.create_time;\n\t\t} else {\n\t\t\tksmbd_debug(VFS, \"fail to load dos attribute.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,\n\t\t\t\tstruct dentry *dentry, char *attr_name,\n\t\t\t\tint attr_name_len)\n{\n\tchar *name, *xattr_list = NULL;\n\tssize_t value_len = -ENOENT, xattr_list_len;\n\n\txattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);\n\tif (xattr_list_len <= 0)\n\t\tgoto out;\n\n\tfor (name = xattr_list; name - xattr_list < xattr_list_len;\n\t\t\tname += strlen(name) + 1) {\n\t\tksmbd_debug(VFS, \"%s, len %zd\\n\", name, strlen(name));\n\t\tif (strncasecmp(attr_name, name, attr_name_len))\n\t\t\tcontinue;\n\n\t\tvalue_len = ksmbd_vfs_xattr_len(user_ns, dentry, name);\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(xattr_list);\n\treturn value_len;\n}\n\nint ksmbd_vfs_xattr_stream_name(char *stream_name, char **xattr_stream_name,\n\t\t\t\tsize_t *xattr_stream_name_size, int s_type)\n{\n\tchar *type, *buf;\n\n\tif (s_type == DIR_STREAM)\n\t\ttype = \":$INDEX_ALLOCATION\";\n\telse\n\t\ttype = \":$DATA\";\n\n\tbuf = kasprintf(GFP_KERNEL, \"%s%s%s\",\n\t\t\tXATTR_NAME_STREAM, stream_name,\ttype);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*xattr_stream_name = buf;\n\t*xattr_stream_name_size = strlen(buf) + 1;\n\n\treturn 0;\n}\n\nint ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,\n\t\t\t       struct ksmbd_file *src_fp,\n\t\t\t       struct ksmbd_file *dst_fp,\n\t\t\t       struct srv_copychunk *chunks,\n\t\t\t       unsigned int chunk_count,\n\t\t\t       unsigned int *chunk_count_written,\n\t\t\t       unsigned int *chunk_size_written,\n\t\t\t       loff_t *total_size_written)\n{\n\tunsigned int i;\n\tloff_t src_off, dst_off, src_file_size;\n\tsize_t len;\n\tint ret;\n\n\t*chunk_count_written = 0;\n\t*chunk_size_written = 0;\n\t*total_size_written = 0;\n\n\tif (!(src_fp->daccess & (FILE_READ_DATA_LE | FILE_EXECUTE_LE))) {\n\t\tpr_err(\"no right to read(%pd)\\n\", src_fp->filp->f_path.dentry);\n\t\treturn -EACCES;\n\t}\n\tif (!(dst_fp->daccess & (FILE_WRITE_DATA_LE | FILE_APPEND_DATA_LE))) {\n\t\tpr_err(\"no right to write(%pd)\\n\", dst_fp->filp->f_path.dentry);\n\t\treturn -EACCES;\n\t}\n\n\tif (ksmbd_stream_fd(src_fp) || ksmbd_stream_fd(dst_fp))\n\t\treturn -EBADF;\n\n\tsmb_break_all_levII_oplock(work, dst_fp, 1);\n\n\tif (!work->tcon->posix_extensions) {\n\t\tfor (i = 0; i < chunk_count; i++) {\n\t\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\t\tif (check_lock_range(src_fp->filp, src_off,\n\t\t\t\t\t     src_off + len - 1, READ))\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (check_lock_range(dst_fp->filp, dst_off,\n\t\t\t\t\t     dst_off + len - 1, WRITE))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tsrc_file_size = i_size_read(file_inode(src_fp->filp));\n\n\tfor (i = 0; i < chunk_count; i++) {\n\t\tsrc_off = le64_to_cpu(chunks[i].SourceOffset);\n\t\tdst_off = le64_to_cpu(chunks[i].TargetOffset);\n\t\tlen = le32_to_cpu(chunks[i].Length);\n\n\t\tif (src_off + len > src_file_size)\n\t\t\treturn -E2BIG;\n\n\t\tret = vfs_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t  dst_fp->filp, dst_off, len, 0);\n\t\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\t\tret = generic_copy_file_range(src_fp->filp, src_off,\n\t\t\t\t\t\t      dst_fp->filp, dst_off,\n\t\t\t\t\t\t      len, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*chunk_count_written += 1;\n\t\t*total_size_written += ret;\n\t}\n\treturn 0;\n}\n\nvoid ksmbd_vfs_posix_lock_wait(struct file_lock *flock)\n{\n\twait_event(flock->fl_wait, !flock->fl_blocker);\n}\n\nint ksmbd_vfs_posix_lock_wait_timeout(struct file_lock *flock, long timeout)\n{\n\treturn wait_event_interruptible_timeout(flock->fl_wait,\n\t\t\t\t\t\t!flock->fl_blocker,\n\t\t\t\t\t\ttimeout);\n}\n\nvoid ksmbd_vfs_posix_lock_unblock(struct file_lock *flock)\n{\n\tlocks_delete_block(flock);\n}\n\nint ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,\n\t\t\t\t struct inode *inode)\n{\n\tstruct posix_acl_state acl_state;\n\tstruct posix_acl *acls;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tksmbd_debug(SMB, \"Set posix acls\\n\");\n\trc = init_acl_state(&acl_state, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Set default owner group */\n\tacl_state.owner.allow = (inode->i_mode & 0700) >> 6;\n\tacl_state.group.allow = (inode->i_mode & 0070) >> 3;\n\tacl_state.other.allow = inode->i_mode & 0007;\n\tacl_state.users->aces[acl_state.users->n].uid = inode->i_uid;\n\tacl_state.users->aces[acl_state.users->n++].perms.allow =\n\t\tacl_state.owner.allow;\n\tacl_state.groups->aces[acl_state.groups->n].gid = inode->i_gid;\n\tacl_state.groups->aces[acl_state.groups->n++].perms.allow =\n\t\tacl_state.group.allow;\n\tacl_state.mask.allow = 0x07;\n\n\tacls = posix_acl_alloc(6, GFP_KERNEL);\n\tif (!acls) {\n\t\tfree_acl_state(&acl_state);\n\t\treturn -ENOMEM;\n\t}\n\tposix_state_to_acl(&acl_state, acls->a_entries);\n\trc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\telse if (S_ISDIR(inode->i_mode)) {\n\t\tposix_state_to_acl(&acl_state, acls->a_entries);\n\t\trc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t   acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\tfree_acl_state(&acl_state);\n\tposix_acl_release(acls);\n\treturn rc;\n}\n\nint ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,\n\t\t\t\tstruct inode *inode, struct inode *parent_inode)\n{\n\tstruct posix_acl *acls;\n\tstruct posix_acl_entry *pace;\n\tint rc, i;\n\n\tif (!IS_ENABLED(CONFIG_FS_POSIX_ACL))\n\t\treturn -EOPNOTSUPP;\n\n\tacls = get_acl(parent_inode, ACL_TYPE_DEFAULT);\n\tif (!acls)\n\t\treturn -ENOENT;\n\tpace = acls->a_entries;\n\n\tfor (i = 0; i < acls->a_count; i++, pace++) {\n\t\tif (pace->e_tag == ACL_MASK) {\n\t\t\tpace->e_perm = 0x07;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);\n\tif (rc < 0)\n\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\\n\",\n\t\t\t    rc);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\trc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t   acls);\n\t\tif (rc < 0)\n\t\t\tksmbd_debug(SMB, \"Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\\n\",\n\t\t\t\t    rc);\n\t}\n\tposix_acl_release(acls);\n\treturn rc;\n}\n"], "filenames": ["fs/ksmbd/smb2pdu.c", "fs/ksmbd/smbacl.c", "fs/ksmbd/smbacl.h", "fs/ksmbd/vfs.c"], "buggy_code_start_loc": [538, 692, 196, 1541], "buggy_code_end_loc": [5164, 1231, 197, 1541], "fixing_code_start_loc": [538, 693, 196, 1542], "fixing_code_end_loc": [5175, 1276, 197, 1547], "type": "CWE-787", "message": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.", "other": {"cve": {"id": "CVE-2022-47942", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-23T16:15:12.863", "lastModified": "2023-05-16T11:03:10.667", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.15", "versionEndExcluding": "5.15.62", "matchCriteriaId": "71F188B5-F7A2-4F91-B40B-02ACCA3184A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.16", "versionEndExcluding": "5.18.18", "matchCriteriaId": "5B42E453-8837-49D0-A5EF-03F818A6DC11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.19", "versionEndExcluding": "5.19.2", "matchCriteriaId": "A1A2A5A5-4598-4D7E-BA07-4660398D6C8F"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/12/23/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8f0541186e9ad1b62accc9519cc2b7a7240272a7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/8f0541186e9ad1b62accc9519cc2b7a7240272a7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.zerodayinitiative.com/advisories/ZDI-22-1688/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8f0541186e9ad1b62accc9519cc2b7a7240272a7"}}