{"buggy_code": ["<?php namespace System\\Classes;\n\nuse App;\nuse Url;\nuse File;\nuse Lang;\nuse Http;\nuse Cache;\nuse Schema;\nuse Config;\nuse ApplicationException;\nuse Cms\\Classes\\ThemeManager;\nuse System\\Models\\Parameter;\nuse System\\Models\\PluginVersion;\nuse System\\Helpers\\Cache as CacheHelper;\nuse October\\Rain\\Filesystem\\Zip;\nuse Carbon\\Carbon;\nuse Exception;\n\n/**\n * Update manager\n *\n * Handles the CMS install and update process.\n *\n * @package october\\system\n * @author Alexey Bobkov, Samuel Georges\n */\nclass UpdateManager\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var \\Illuminate\\Console\\OutputStyle\n     */\n    protected $notesOutput;\n\n    /**\n     * @var string Application base path.\n     */\n    protected $baseDirectory;\n\n    /**\n     * @var string A temporary working directory.\n     */\n    protected $tempDirectory;\n\n    /**\n     * @var \\System\\Classes\\PluginManager\n     */\n    protected $pluginManager;\n\n    /**\n     * @var \\Cms\\Classes\\ThemeManager\n     */\n    protected $themeManager;\n\n    /**\n     * @var \\System\\Classes\\VersionManager\n     */\n    protected $versionManager;\n\n    /**\n     * @var string Secure API Key\n     */\n    protected $key;\n\n    /**\n     * @var string Secure API Secret\n     */\n    protected $secret;\n\n    /**\n     * @var boolean If set to true, core updates will not be downloaded or extracted.\n     */\n    protected $disableCoreUpdates = false;\n\n    /**\n     * @var array Cache of gateway products\n     */\n    protected $productCache;\n\n    /**\n     * @var \\Illuminate\\Database\\Migrations\\Migrator\n     */\n    protected $migrator;\n\n    /**\n     * @var \\Illuminate\\Database\\Migrations\\DatabaseMigrationRepository\n     */\n    protected $repository;\n\n    /**\n     * @var array An array of messages returned by migrations / seeders. Returned at the end of the update process.\n     */\n    protected $messages = [];\n\n    /**\n     * Initialize this singleton.\n     */\n    protected function init()\n    {\n        $this->pluginManager = PluginManager::instance();\n        $this->themeManager = class_exists(ThemeManager::class) ? ThemeManager::instance() : null;\n        $this->versionManager = VersionManager::instance();\n        $this->tempDirectory = temp_path();\n        $this->baseDirectory = base_path();\n        $this->disableCoreUpdates = Config::get('cms.disableCoreUpdates', false);\n        $this->bindContainerObjects();\n\n        /*\n         * Ensure temp directory exists\n         */\n        if (!File::isDirectory($this->tempDirectory)) {\n            File::makeDirectory($this->tempDirectory, 0777, true);\n        }\n    }\n\n    /**\n     * These objects are \"soft singletons\" and may be lost when\n     * the IoC container reboots. This provides a way to rebuild\n     * for the purposes of unit testing.\n     */\n    public function bindContainerObjects()\n    {\n        $this->migrator = App::make('migrator');\n        $this->repository = App::make('migration.repository');\n    }\n\n    /**\n     * Creates the migration table and updates\n     * @return self\n     */\n    public function update()\n    {\n        $firstUp = !Schema::hasTable($this->getMigrationTableName());\n        if ($firstUp) {\n            $this->repository->createRepository();\n            $this->note('Migration table created');\n        }\n\n        /*\n         * Update modules\n         */\n        $modules = Config::get('cms.loadModules', []);\n        foreach ($modules as $module) {\n            $this->migrateModule($module);\n        }\n\n        /*\n         * Update plugins\n         */\n        $plugins = $this->pluginManager->getPlugins();\n        foreach ($plugins as $code => $plugin) {\n            $this->updatePlugin($code);\n        }\n\n        Parameter::set('system::update.count', 0);\n        CacheHelper::clear();\n\n        /*\n         * Seed modules\n         */\n        if ($firstUp) {\n            $modules = Config::get('cms.loadModules', []);\n            foreach ($modules as $module) {\n                $this->seedModule($module);\n            }\n        }\n\n        // Print messages returned by migrations / seeders\n        $this->printMessages();\n\n        return $this;\n    }\n\n    /**\n     * Checks for new updates and returns the amount of unapplied updates.\n     * Only requests from the server at a set interval (retry timer).\n     * @param boolean $force Ignore the retry timer.\n     * @return int            Number of unapplied updates.\n     */\n    public function check($force = false)\n    {\n        /*\n         * Already know about updates, never retry.\n         */\n        $oldCount = Parameter::get('system::update.count');\n        if ($oldCount > 0) {\n            return $oldCount;\n        }\n\n        /*\n         * Retry period not passed, skipping.\n         */\n        if (!$force\n            && ($retryTimestamp = Parameter::get('system::update.retry'))\n            && Carbon::createFromTimeStamp($retryTimestamp)->isFuture()\n        ) {\n            return $oldCount;\n        }\n\n        try {\n            $result = $this->requestUpdateList();\n            $newCount = array_get($result, 'update', 0);\n        } catch (Exception $ex) {\n            $newCount = 0;\n        }\n\n        /*\n         * Remember update count, set retry date\n         */\n        Parameter::set('system::update.count', $newCount);\n        Parameter::set('system::update.retry', Carbon::now()->addHours(24)->timestamp);\n\n        return $newCount;\n    }\n\n    /**\n     * Requests an update list used for checking for new updates.\n     * @param boolean $force Request application and plugins hash list regardless of version.\n     * @return array\n     */\n    public function requestUpdateList($force = false)\n    {\n        $installed = PluginVersion::all();\n        $versions = $installed->lists('version', 'code');\n        $names = $installed->lists('name', 'code');\n        $icons = $installed->lists('icon', 'code');\n        $frozen = $installed->lists('is_frozen', 'code');\n        $updatable = $installed->lists('is_updatable', 'code');\n        $build = Parameter::get('system::core.build');\n        $themes = [];\n\n        if ($this->themeManager) {\n            $themes = array_keys($this->themeManager->getInstalled());\n        }\n\n        $params = [\n            'core'    => $this->getHash(),\n            'plugins' => base64_encode(json_encode($versions)),\n            'themes'  => base64_encode(json_encode($themes)),\n            'build'   => $build,\n            'force'   => $force\n        ];\n\n        $result = $this->requestServerData('core/update', $params);\n        $updateCount = (int) array_get($result, 'update', 0);\n\n        /*\n         * Inject known core build\n         */\n        if ($core = array_get($result, 'core')) {\n            $core['old_build'] = Parameter::get('system::core.build');\n            $result['core'] = $core;\n        }\n\n        /*\n         * Inject the application's known plugin name and version\n         */\n        $plugins = [];\n        foreach (array_get($result, 'plugins', []) as $code => $info) {\n            $info['name'] = $names[$code] ?? $code;\n            $info['old_version'] = $versions[$code] ?? false;\n            $info['icon'] = $icons[$code] ?? false;\n\n            /*\n             * If a plugin has updates frozen, or cannot be updated,\n             * do not add to the list and discount an update unit.\n             */\n            if (\n                (isset($frozen[$code]) && $frozen[$code]) ||\n                (isset($updatable[$code]) && !$updatable[$code])\n            ) {\n                $updateCount = max(0, --$updateCount);\n            } else {\n                $plugins[$code] = $info;\n            }\n        }\n        $result['plugins'] = $plugins;\n\n        /*\n         * Strip out themes that have been installed before\n         */\n        if ($this->themeManager) {\n            $themes = [];\n            foreach (array_get($result, 'themes', []) as $code => $info) {\n                if (!$this->themeManager->isInstalled($code)) {\n                    $themes[$code] = $info;\n                }\n            }\n            $result['themes'] = $themes;\n        }\n\n        /*\n         * If there is a core update and core updates are disabled,\n         * remove the entry and discount an update unit.\n         */\n        if (array_get($result, 'core') && $this->disableCoreUpdates) {\n            $updateCount = max(0, --$updateCount);\n            unset($result['core']);\n        }\n\n        /*\n         * Recalculate the update counter\n         */\n        $updateCount += count($themes);\n        $result['hasUpdates'] = $updateCount > 0;\n        $result['update'] = $updateCount;\n        Parameter::set('system::update.count', $updateCount);\n\n        return $result;\n    }\n\n    /**\n     * Requests details about a project based on its identifier.\n     * @param string $projectId\n     * @return array\n     */\n    public function requestProjectDetails($projectId)\n    {\n        return $this->requestServerData('project/detail', ['id' => $projectId]);\n    }\n\n    /**\n     * Roll back all modules and plugins.\n     * @return self\n     */\n    public function uninstall()\n    {\n        /*\n         * Rollback plugins\n         */\n        $plugins = array_reverse($this->pluginManager->getPlugins());\n        foreach ($plugins as $name => $plugin) {\n            $this->rollbackPlugin($name);\n        }\n\n        /*\n         * Register module migration files\n         */\n        $paths = [];\n        $modules = Config::get('cms.loadModules', []);\n\n        foreach ($modules as $module) {\n            $paths[] = $path = base_path() . '/modules/' . strtolower($module) . '/database/migrations';\n        }\n\n        /*\n         * Rollback modules\n         */\n        if (isset($this->notesOutput)) {\n            $this->migrator->setOutput($this->notesOutput);\n        }\n\n        while (true) {\n            $rolledBack = $this->migrator->rollback($paths, ['pretend' => false]);\n\n            if (count($rolledBack) == 0) {\n                break;\n            }\n        }\n\n        Schema::dropIfExists($this->getMigrationTableName());\n\n        return $this;\n    }\n\n    /**\n     * Determines build number from source manifest.\n     *\n     * This will return an array with the following information:\n     *  - `build`: The build number we determined was most likely the build installed.\n     *  - `modified`: Whether we detected any modifications between the installed build and the manifest.\n     *  - `confident`: Whether we are at least 60% sure that this is the installed build. More modifications to\n     *                  to the code = less confidence.\n     *  - `changes`: If $detailed is true, this will include the list of files modified, created and deleted.\n     *\n     * @param bool $detailed If true, the list of files modified, added and deleted will be included in the result.\n     * @return array\n     */\n    public function getBuildNumberManually($detailed = false)\n    {\n        $source = new SourceManifest();\n        $manifest = new FileManifest(null, null, true);\n\n        // Find build by comparing with source manifest\n        return $source->compare($manifest, $detailed);\n    }\n\n    /**\n     * Sets the build number in the database.\n     *\n     * @param bool $detailed If true, the list of files modified, added and deleted will be included in the result.\n     * @return void\n     */\n    public function setBuildNumberManually($detailed = false)\n    {\n        $build = $this->getBuildNumberManually($detailed);\n\n        if ($build['confident']) {\n            $this->setBuild($build['build'], null, $build['modified']);\n        }\n\n        return $build;\n    }\n\n    //\n    // Modules\n    //\n\n    /**\n     * Returns the currently installed system hash.\n     * @return string\n     */\n    public function getHash()\n    {\n        return Parameter::get('system::core.hash', md5('NULL'));\n    }\n\n    /**\n     * Run migrations on a single module\n     * @param string $module Module name\n     * @return self\n     */\n    public function migrateModule($module)\n    {\n        if (isset($this->notesOutput)) {\n            $this->migrator->setOutput($this->notesOutput);\n        }\n\n        $this->note($module);\n\n        $this->migrator->run(base_path() . '/modules/'.strtolower($module).'/database/migrations');\n\n        return $this;\n    }\n\n    /**\n     * Run seeds on a module\n     * @param string $module Module name\n     * @return self\n     */\n    public function seedModule($module)\n    {\n        $className = '\\\\' . $module . '\\Database\\Seeds\\DatabaseSeeder';\n        if (!class_exists($className)) {\n            return;\n        }\n\n        $seeder = App::make($className);\n        $return = $seeder->run();\n\n        if (isset($return) && (is_string($return) || is_array($return))) {\n            $this->addMessage($className, $return);\n        }\n\n        $this->note(sprintf('<info>Seeded %s</info> ', $module));\n        return $this;\n    }\n\n    /**\n     * Downloads the core from the update server.\n     * @param string $hash Expected file hash.\n     * @return void\n     */\n    public function downloadCore($hash)\n    {\n        $this->requestServerFile('core/get', 'core', $hash, ['type' => 'update']);\n    }\n\n    /**\n     * Extracts the core after it has been downloaded.\n     * @return void\n     */\n    public function extractCore()\n    {\n        $filePath = $this->getFilePath('core');\n\n        if (!Zip::extract($filePath, $this->baseDirectory)) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        @unlink($filePath);\n    }\n\n    /**\n     * Sets the build number and hash\n     * @param string $hash\n     * @param string $build\n     * @param bool $modified\n     * @return void\n     */\n    public function setBuild($build, $hash = null, $modified = false)\n    {\n        $params = [\n            'system::core.build' => $build,\n            'system::core.modified' => $modified,\n        ];\n\n        if ($hash) {\n            $params['system::core.hash'] = $hash;\n        }\n\n        Parameter::set($params);\n    }\n\n    //\n    // Plugins\n    //\n\n    /**\n     * Looks up a plugin from the update server.\n     * @param string $name Plugin name.\n     * @return array Details about the plugin.\n     */\n    public function requestPluginDetails($name)\n    {\n        return $this->requestServerData('plugin/detail', ['name' => $name]);\n    }\n\n    /**\n     * Looks up content for a plugin from the update server.\n     * @param string $name Plugin name.\n     * @return array Content for the plugin.\n     */\n    public function requestPluginContent($name)\n    {\n        return $this->requestServerData('plugin/content', ['name' => $name]);\n    }\n\n    /**\n     * Runs update on a single plugin\n     * @param string $name Plugin name.\n     * @return self\n     */\n    public function updatePlugin($name)\n    {\n        /*\n         * Update the plugin database and version\n         */\n        if (!($plugin = $this->pluginManager->findByIdentifier($name))) {\n            $this->note('<error>Unable to find:</error> ' . $name);\n            return;\n        }\n\n        $this->note($name);\n\n        $this->versionManager->setNotesOutput($this->notesOutput);\n\n        $this->versionManager->updatePlugin($plugin);\n\n        return $this;\n    }\n\n    /**\n     * Rollback an existing plugin\n     *\n     * @param string $name Plugin name.\n     * @param string $stopOnVersion If this parameter is specified, the process stops once the provided version number is reached\n     * @return self\n     */\n    public function rollbackPlugin(string $name, string $stopOnVersion = null)\n    {\n        /*\n         * Remove the plugin database and version\n         */\n        if (!($plugin = $this->pluginManager->findByIdentifier($name))\n            && $this->versionManager->purgePlugin($name)\n        ) {\n            $this->note('<info>Purged from database:</info> ' . $name);\n            return $this;\n        }\n\n        if ($stopOnVersion && !$this->versionManager->hasDatabaseVersion($plugin, $stopOnVersion)) {\n            throw new ApplicationException(Lang::get('system::lang.updates.plugin_version_not_found'));\n        }\n\n        if ($this->versionManager->removePlugin($plugin, $stopOnVersion, true)) {\n            $this->note('<info>Rolled back:</info> ' . $name);\n\n            if ($currentVersion = $this->versionManager->getCurrentVersion($plugin)) {\n                $this->note('<info>Current Version:</info> ' . $currentVersion . ' (' . $this->versionManager->getCurrentVersionNote($plugin) . ')');\n            }\n\n            return $this;\n        }\n\n        $this->note('<error>Unable to find:</error> ' . $name);\n\n        return $this;\n    }\n\n    /**\n     * Downloads a plugin from the update server.\n     * @param string $name Plugin name.\n     * @param string $hash Expected file hash.\n     * @param boolean $installation Indicates whether this is a plugin installation request.\n     * @return self\n     */\n    public function downloadPlugin($name, $hash, $installation = false)\n    {\n        $fileCode = $name . $hash;\n        $this->requestServerFile('plugin/get', $fileCode, $hash, [\n            'name'         => $name,\n            'installation' => $installation ? 1 : 0\n        ]);\n    }\n\n    /**\n     * Extracts a plugin after it has been downloaded.\n     */\n    public function extractPlugin($name, $hash)\n    {\n        $fileCode = $name . $hash;\n        $filePath = $this->getFilePath($fileCode);\n        $innerPath = str_replace('.', '/', strtolower($name));\n\n        if (!Zip::extract($filePath, plugins_path($innerPath))) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        @unlink($filePath);\n    }\n\n    //\n    // Themes\n    //\n\n    /**\n     * Looks up a theme from the update server.\n     * @param string $name Theme name.\n     * @return array Details about the theme.\n     */\n    public function requestThemeDetails($name)\n    {\n        return $this->requestServerData('theme/detail', ['name' => $name]);\n    }\n\n    /**\n     * Downloads a theme from the update server.\n     * @param string $name Theme name.\n     * @param string $hash Expected file hash.\n     * @return self\n     */\n    public function downloadTheme($name, $hash)\n    {\n        $fileCode = $name . $hash;\n\n        $this->requestServerFile('theme/get', $fileCode, $hash, ['name' => $name]);\n    }\n\n    /**\n     * Extracts a theme after it has been downloaded.\n     */\n    public function extractTheme($name, $hash)\n    {\n        $fileCode = $name . $hash;\n        $filePath = $this->getFilePath($fileCode);\n        $innerPath = str_replace('.', '-', strtolower($name));\n\n        if (!Zip::extract($filePath, themes_path($innerPath))) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        if ($this->themeManager) {\n            $this->themeManager->setInstalled($name);\n        }\n\n        @unlink($filePath);\n    }\n\n    //\n    // Products\n    //\n\n    public function requestProductDetails($codes, $type = null)\n    {\n        if ($type != 'plugin' && $type != 'theme') {\n            $type = 'plugin';\n        }\n\n        $codes = (array) $codes;\n        $this->loadProductDetailCache();\n\n        /*\n         * New products requested\n         */\n        $newCodes = array_diff($codes, array_keys($this->productCache[$type]));\n        if (count($newCodes)) {\n            $dataCodes = [];\n            $data = $this->requestServerData($type . '/details', ['names' => $newCodes]);\n            foreach ($data as $product) {\n                $code = array_get($product, 'code', -1);\n                $this->cacheProductDetail($type, $code, $product);\n                $dataCodes[] = $code;\n            }\n\n            /*\n             * Cache unknown products\n             */\n            $unknownCodes = array_diff($newCodes, $dataCodes);\n            foreach ($unknownCodes as $code) {\n                $this->cacheProductDetail($type, $code, -1);\n            }\n\n            $this->saveProductDetailCache();\n        }\n\n        /*\n         * Build details from cache\n         */\n        $result = [];\n        $requestedDetails = array_intersect_key($this->productCache[$type], array_flip($codes));\n\n        foreach ($requestedDetails as $detail) {\n            if ($detail === -1) {\n                continue;\n            }\n            $result[] = $detail;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns popular themes found on the marketplace.\n     */\n    public function requestPopularProducts($type = null)\n    {\n        if ($type != 'plugin' && $type != 'theme') {\n            $type = 'plugin';\n        }\n\n        $cacheKey = 'system-updates-popular-' . $type;\n\n        if (Cache::has($cacheKey)) {\n            return @unserialize(@base64_decode(Cache::get($cacheKey))) ?: [];\n        }\n\n        $data = $this->requestServerData($type . '/popular');\n        $expiresAt = now()->addMinutes(60);\n        Cache::put($cacheKey, base64_encode(serialize($data)), $expiresAt);\n\n        foreach ($data as $product) {\n            $code = array_get($product, 'code', -1);\n            $this->cacheProductDetail($type, $code, $product);\n        }\n\n        $this->saveProductDetailCache();\n\n        return $data;\n    }\n\n    protected function loadProductDetailCache()\n    {\n        $defaultCache = ['theme' => [], 'plugin' => []];\n        $cacheKey = 'system-updates-product-details';\n\n        if (Cache::has($cacheKey)) {\n            $this->productCache = @unserialize(@base64_decode(Cache::get($cacheKey))) ?: $defaultCache;\n        } else {\n            $this->productCache = $defaultCache;\n        }\n    }\n\n    protected function saveProductDetailCache()\n    {\n        if ($this->productCache === null) {\n            $this->loadProductDetailCache();\n        }\n\n        $cacheKey = 'system-updates-product-details';\n        $expiresAt = Carbon::now()->addDays(2);\n        Cache::put($cacheKey, base64_encode(serialize($this->productCache)), $expiresAt);\n    }\n\n    protected function cacheProductDetail($type, $code, $data)\n    {\n        if ($this->productCache === null) {\n            $this->loadProductDetailCache();\n        }\n\n        $this->productCache[$type][$code] = $data;\n    }\n\n    //\n    // Changelog\n    //\n\n    /**\n     * Returns the latest changelog information.\n     */\n    public function requestChangelog()\n    {\n        $result = Http::get('https://octobercms.com/changelog?json');\n\n        if ($result->code == 404) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_empty'));\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(\n                strlen($result->body)\n                ? $result->body\n                : Lang::get('system::lang.server.response_empty')\n            );\n        }\n\n        try {\n            $resultData = json_decode($result->body, true);\n        } catch (Exception $ex) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        return $resultData;\n    }\n\n    //\n    // Notes\n    //\n\n    /**\n     * Raise a note event for the migrator.\n     * @param string $message\n     * @return self\n     */\n    protected function note($message)\n    {\n        if ($this->notesOutput !== null) {\n            $this->notesOutput->writeln($message);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets an output stream for writing notes.\n     * @param Illuminate\\Console\\Command $output\n     * @return self\n     */\n    public function setNotesOutput($output)\n    {\n        $this->notesOutput = $output;\n\n        return $this;\n    }\n\n    //\n    // Gateway access\n    //\n\n    /**\n     * Contacts the update server for a response.\n     * @param string $uri Gateway API URI\n     * @param array $postData Extra post data\n     * @return array\n     */\n    public function requestServerData($uri, $postData = [])\n    {\n        $result = Http::post($this->createServerUrl($uri), function ($http) use ($postData) {\n            $this->applyHttpAttributes($http, $postData);\n        });\n\n        if ($result->code == 404) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_not_found'));\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(\n                strlen($result->body)\n                ? $result->body\n                : Lang::get('system::lang.server.response_empty')\n            );\n        }\n\n        $resultData = false;\n\n        try {\n            $resultData = @json_decode($result->body, true);\n        } catch (Exception $ex) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        if ($resultData === false || (is_string($resultData) && !strlen($resultData))) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        return $resultData;\n    }\n\n    /**\n     * Downloads a file from the update server.\n     * @param string $uri Gateway API URI\n     * @param string $fileCode A unique code for saving the file.\n     * @param string $expectedHash The expected file hash of the file.\n     * @param array $postData Extra post data\n     * @return void\n     */\n    public function requestServerFile($uri, $fileCode, $expectedHash, $postData = [])\n    {\n        $filePath = $this->getFilePath($fileCode);\n\n        $result = Http::post($this->createServerUrl($uri), function ($http) use ($postData, $filePath) {\n            $this->applyHttpAttributes($http, $postData);\n            $http->toFile($filePath);\n        });\n\n        if (in_array($result->code, [301, 302])) {\n            if ($redirectUrl = array_get($result->info, 'redirect_url')) {\n                $result = Http::get($redirectUrl, function ($http) use ($postData, $filePath) {\n                    $http->toFile($filePath);\n                });\n            }\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(File::get($filePath));\n        }\n    }\n\n    /**\n     * Calculates a file path for a file code\n     * @param string $fileCode A unique file code\n     * @return string           Full path on the disk\n     */\n    protected function getFilePath($fileCode)\n    {\n        $name = md5($fileCode) . '.arc';\n        return $this->tempDirectory . '/' . $name;\n    }\n\n    /**\n     * Set the API security for all transmissions.\n     * @param string $key API Key\n     * @param string $secret API Secret\n     */\n    public function setSecurity($key, $secret)\n    {\n        $this->key = $key;\n        $this->secret = $secret;\n    }\n\n    /**\n     * Create a complete gateway server URL from supplied URI\n     * @param string $uri URI\n     * @return string      URL\n     */\n    protected function createServerUrl($uri)\n    {\n        $gateway = Config::get('cms.updateServer', 'https://gateway.octobercms.com/api');\n        if (substr($gateway, -1) != '/') {\n            $gateway .= '/';\n        }\n\n        return $gateway . $uri;\n    }\n\n    /**\n     * Modifies the Network HTTP object with common attributes.\n     * @param Http $http Network object\n     * @param array $postData Post data\n     * @return void\n     */\n    protected function applyHttpAttributes($http, $postData)\n    {\n        $postData['protocol_version'] = '1.2';\n        $postData['client'] = 'october';\n\n        $postData['server'] = base64_encode(json_encode([\n            'php'   => PHP_VERSION,\n            'url'   => Url::to('/'),\n            'since' => PluginVersion::orderBy('created_at')->value('created_at')\n        ]));\n\n        if ($projectId = Parameter::get('system::project.id')) {\n            $postData['project'] = $projectId;\n        }\n\n        if (Config::get('cms.edgeUpdates', false)) {\n            $postData['edge'] = 1;\n        }\n\n        if ($this->key && $this->secret) {\n            $postData['nonce'] = $this->createNonce();\n            $http->header('Rest-Key', $this->key);\n            $http->header('Rest-Sign', $this->createSignature($postData, $this->secret));\n        }\n\n        if ($credentials = Config::get('cms.updateAuth')) {\n            $http->auth($credentials);\n        }\n\n        $http->noRedirect();\n        $http->data($postData);\n    }\n\n    /**\n     * Create a nonce based on millisecond time\n     * @return int\n     */\n    protected function createNonce()\n    {\n        $mt = explode(' ', microtime());\n        return $mt[1] . substr($mt[0], 2, 6);\n    }\n\n    /**\n     * Create a unique signature for transmission.\n     * @return string\n     */\n    protected function createSignature($data, $secret)\n    {\n        return base64_encode(hash_hmac('sha512', http_build_query($data, '', '&'), base64_decode($secret), true));\n    }\n\n    /**\n     * @return string\n     */\n    public function getMigrationTableName()\n    {\n        return Config::get('database.migrations', 'migrations');\n    }\n\n    /**\n     * Adds a message from a specific migration or seeder.\n     *\n     * @param string|object $class\n     * @param string|array $message\n     * @return void\n     */\n    protected function addMessage($class, $message)\n    {\n        if (empty($message)) {\n            return;\n        }\n\n        if (is_object($class)) {\n            $class = get_class($class);\n        }\n        if (!isset($this->messages[$class])) {\n            $this->messages[$class] = [];\n        }\n\n        if (is_string($message)) {\n            $this->messages[$class][] = $message;\n        } elseif (is_array($message)) {\n            array_merge($this->messages[$class], $message);\n        }\n    }\n\n    /**\n     * Prints collated messages from the migrations and seeders\n     *\n     * @return void\n     */\n    protected function printMessages()\n    {\n        if (!count($this->messages)) {\n            return;\n        }\n\n        // Add a line break\n        $this->note('');\n\n        foreach ($this->messages as $class => $messages) {\n            $this->note(sprintf('<info>%s reported:</info>', $class));\n\n            foreach ($messages as $message) {\n                $this->note(' - ' . (string) $message);\n            }\n        }\n    }\n}\n"], "fixing_code": ["<?php namespace System\\Classes;\n\nuse App;\nuse Url;\nuse File;\nuse Lang;\nuse Http;\nuse Cache;\nuse Schema;\nuse Config;\nuse Request;\nuse ApplicationException;\nuse Cms\\Classes\\ThemeManager;\nuse System\\Models\\Parameter;\nuse System\\Models\\PluginVersion;\nuse System\\Helpers\\Cache as CacheHelper;\nuse October\\Rain\\Filesystem\\Zip;\nuse Carbon\\Carbon;\nuse Exception;\n\n/**\n * Update manager\n *\n * Handles the CMS install and update process.\n *\n * @package october\\system\n * @author Alexey Bobkov, Samuel Georges\n */\nclass UpdateManager\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var \\Illuminate\\Console\\OutputStyle\n     */\n    protected $notesOutput;\n\n    /**\n     * @var string Application base path.\n     */\n    protected $baseDirectory;\n\n    /**\n     * @var string A temporary working directory.\n     */\n    protected $tempDirectory;\n\n    /**\n     * @var \\System\\Classes\\PluginManager\n     */\n    protected $pluginManager;\n\n    /**\n     * @var \\Cms\\Classes\\ThemeManager\n     */\n    protected $themeManager;\n\n    /**\n     * @var \\System\\Classes\\VersionManager\n     */\n    protected $versionManager;\n\n    /**\n     * @var string Secure API Key\n     */\n    protected $key;\n\n    /**\n     * @var string Secure API Secret\n     */\n    protected $secret;\n\n    /**\n     * @var boolean If set to true, core updates will not be downloaded or extracted.\n     */\n    protected $disableCoreUpdates = false;\n\n    /**\n     * @var array Cache of gateway products\n     */\n    protected $productCache;\n\n    /**\n     * @var \\Illuminate\\Database\\Migrations\\Migrator\n     */\n    protected $migrator;\n\n    /**\n     * @var \\Illuminate\\Database\\Migrations\\DatabaseMigrationRepository\n     */\n    protected $repository;\n\n    /**\n     * @var array An array of messages returned by migrations / seeders. Returned at the end of the update process.\n     */\n    protected $messages = [];\n\n    /**\n     * Initialize this singleton.\n     */\n    protected function init()\n    {\n        $this->pluginManager = PluginManager::instance();\n        $this->themeManager = class_exists(ThemeManager::class) ? ThemeManager::instance() : null;\n        $this->versionManager = VersionManager::instance();\n        $this->tempDirectory = temp_path();\n        $this->baseDirectory = base_path();\n        $this->disableCoreUpdates = Config::get('cms.disableCoreUpdates', false);\n        $this->bindContainerObjects();\n\n        /*\n         * Ensure temp directory exists\n         */\n        if (!File::isDirectory($this->tempDirectory)) {\n            File::makeDirectory($this->tempDirectory, 0777, true);\n        }\n    }\n\n    /**\n     * These objects are \"soft singletons\" and may be lost when\n     * the IoC container reboots. This provides a way to rebuild\n     * for the purposes of unit testing.\n     */\n    public function bindContainerObjects()\n    {\n        $this->migrator = App::make('migrator');\n        $this->repository = App::make('migration.repository');\n    }\n\n    /**\n     * Creates the migration table and updates\n     * @return self\n     */\n    public function update()\n    {\n        $firstUp = !Schema::hasTable($this->getMigrationTableName());\n        if ($firstUp) {\n            $this->repository->createRepository();\n            $this->note('Migration table created');\n        }\n\n        /*\n         * Update modules\n         */\n        $modules = Config::get('cms.loadModules', []);\n        foreach ($modules as $module) {\n            $this->migrateModule($module);\n        }\n\n        /*\n         * Update plugins\n         */\n        $plugins = $this->pluginManager->getPlugins();\n        foreach ($plugins as $code => $plugin) {\n            $this->updatePlugin($code);\n        }\n\n        Parameter::set('system::update.count', 0);\n        CacheHelper::clear();\n\n        /*\n         * Seed modules\n         */\n        if ($firstUp) {\n            $modules = Config::get('cms.loadModules', []);\n            foreach ($modules as $module) {\n                $this->seedModule($module);\n            }\n        }\n\n        // Print messages returned by migrations / seeders\n        $this->printMessages();\n\n        return $this;\n    }\n\n    /**\n     * Checks for new updates and returns the amount of unapplied updates.\n     * Only requests from the server at a set interval (retry timer).\n     * @param boolean $force Ignore the retry timer.\n     * @return int            Number of unapplied updates.\n     */\n    public function check($force = false)\n    {\n        /*\n         * Already know about updates, never retry.\n         */\n        $oldCount = Parameter::get('system::update.count');\n        if ($oldCount > 0) {\n            return $oldCount;\n        }\n\n        /*\n         * Retry period not passed, skipping.\n         */\n        if (!$force\n            && ($retryTimestamp = Parameter::get('system::update.retry'))\n            && Carbon::createFromTimeStamp($retryTimestamp)->isFuture()\n        ) {\n            return $oldCount;\n        }\n\n        try {\n            $result = $this->requestUpdateList();\n            $newCount = array_get($result, 'update', 0);\n        } catch (Exception $ex) {\n            $newCount = 0;\n        }\n\n        /*\n         * Remember update count, set retry date\n         */\n        Parameter::set('system::update.count', $newCount);\n        Parameter::set('system::update.retry', Carbon::now()->addHours(24)->timestamp);\n\n        return $newCount;\n    }\n\n    /**\n     * Requests an update list used for checking for new updates.\n     * @param boolean $force Request application and plugins hash list regardless of version.\n     * @return array\n     */\n    public function requestUpdateList($force = false)\n    {\n        $installed = PluginVersion::all();\n        $versions = $installed->lists('version', 'code');\n        $names = $installed->lists('name', 'code');\n        $icons = $installed->lists('icon', 'code');\n        $frozen = $installed->lists('is_frozen', 'code');\n        $updatable = $installed->lists('is_updatable', 'code');\n        $build = Parameter::get('system::core.build');\n        $themes = [];\n\n        if ($this->themeManager) {\n            $themes = array_keys($this->themeManager->getInstalled());\n        }\n\n        $params = [\n            'core'    => $this->getHash(),\n            'plugins' => base64_encode(json_encode($versions)),\n            'themes'  => base64_encode(json_encode($themes)),\n            'build'   => $build,\n            'force'   => $force\n        ];\n\n        $result = $this->requestServerData('core/update', $params);\n        $updateCount = (int) array_get($result, 'update', 0);\n\n        /*\n         * Inject known core build\n         */\n        if ($core = array_get($result, 'core')) {\n            $core['old_build'] = Parameter::get('system::core.build');\n            $result['core'] = $core;\n        }\n\n        /*\n         * Inject the application's known plugin name and version\n         */\n        $plugins = [];\n        foreach (array_get($result, 'plugins', []) as $code => $info) {\n            $info['name'] = $names[$code] ?? $code;\n            $info['old_version'] = $versions[$code] ?? false;\n            $info['icon'] = $icons[$code] ?? false;\n\n            /*\n             * If a plugin has updates frozen, or cannot be updated,\n             * do not add to the list and discount an update unit.\n             */\n            if (\n                (isset($frozen[$code]) && $frozen[$code]) ||\n                (isset($updatable[$code]) && !$updatable[$code])\n            ) {\n                $updateCount = max(0, --$updateCount);\n            } else {\n                $plugins[$code] = $info;\n            }\n        }\n        $result['plugins'] = $plugins;\n\n        /*\n         * Strip out themes that have been installed before\n         */\n        if ($this->themeManager) {\n            $themes = [];\n            foreach (array_get($result, 'themes', []) as $code => $info) {\n                if (!$this->themeManager->isInstalled($code)) {\n                    $themes[$code] = $info;\n                }\n            }\n            $result['themes'] = $themes;\n        }\n\n        /*\n         * If there is a core update and core updates are disabled,\n         * remove the entry and discount an update unit.\n         */\n        if (array_get($result, 'core') && $this->disableCoreUpdates) {\n            $updateCount = max(0, --$updateCount);\n            unset($result['core']);\n        }\n\n        /*\n         * Recalculate the update counter\n         */\n        $updateCount += count($themes);\n        $result['hasUpdates'] = $updateCount > 0;\n        $result['update'] = $updateCount;\n        Parameter::set('system::update.count', $updateCount);\n\n        return $result;\n    }\n\n    /**\n     * Requests details about a project based on its identifier.\n     * @param string $projectId\n     * @return array\n     */\n    public function requestProjectDetails($projectId)\n    {\n        return $this->requestServerData('project/detail', ['id' => $projectId]);\n    }\n\n    /**\n     * Roll back all modules and plugins.\n     * @return self\n     */\n    public function uninstall()\n    {\n        /*\n         * Rollback plugins\n         */\n        $plugins = array_reverse($this->pluginManager->getPlugins());\n        foreach ($plugins as $name => $plugin) {\n            $this->rollbackPlugin($name);\n        }\n\n        /*\n         * Register module migration files\n         */\n        $paths = [];\n        $modules = Config::get('cms.loadModules', []);\n\n        foreach ($modules as $module) {\n            $paths[] = $path = base_path() . '/modules/' . strtolower($module) . '/database/migrations';\n        }\n\n        /*\n         * Rollback modules\n         */\n        if (isset($this->notesOutput)) {\n            $this->migrator->setOutput($this->notesOutput);\n        }\n\n        while (true) {\n            $rolledBack = $this->migrator->rollback($paths, ['pretend' => false]);\n\n            if (count($rolledBack) == 0) {\n                break;\n            }\n        }\n\n        Schema::dropIfExists($this->getMigrationTableName());\n\n        return $this;\n    }\n\n    /**\n     * Determines build number from source manifest.\n     *\n     * This will return an array with the following information:\n     *  - `build`: The build number we determined was most likely the build installed.\n     *  - `modified`: Whether we detected any modifications between the installed build and the manifest.\n     *  - `confident`: Whether we are at least 60% sure that this is the installed build. More modifications to\n     *                  to the code = less confidence.\n     *  - `changes`: If $detailed is true, this will include the list of files modified, created and deleted.\n     *\n     * @param bool $detailed If true, the list of files modified, added and deleted will be included in the result.\n     * @return array\n     */\n    public function getBuildNumberManually($detailed = false)\n    {\n        $source = new SourceManifest();\n        $manifest = new FileManifest(null, null, true);\n\n        // Find build by comparing with source manifest\n        return $source->compare($manifest, $detailed);\n    }\n\n    /**\n     * Sets the build number in the database.\n     *\n     * @param bool $detailed If true, the list of files modified, added and deleted will be included in the result.\n     * @return void\n     */\n    public function setBuildNumberManually($detailed = false)\n    {\n        $build = $this->getBuildNumberManually($detailed);\n\n        if ($build['confident']) {\n            $this->setBuild($build['build'], null, $build['modified']);\n        }\n\n        return $build;\n    }\n\n    //\n    // Modules\n    //\n\n    /**\n     * Returns the currently installed system hash.\n     * @return string\n     */\n    public function getHash()\n    {\n        return Parameter::get('system::core.hash', md5('NULL'));\n    }\n\n    /**\n     * Run migrations on a single module\n     * @param string $module Module name\n     * @return self\n     */\n    public function migrateModule($module)\n    {\n        if (isset($this->notesOutput)) {\n            $this->migrator->setOutput($this->notesOutput);\n        }\n\n        $this->note($module);\n\n        $this->migrator->run(base_path() . '/modules/'.strtolower($module).'/database/migrations');\n\n        return $this;\n    }\n\n    /**\n     * Run seeds on a module\n     * @param string $module Module name\n     * @return self\n     */\n    public function seedModule($module)\n    {\n        $className = '\\\\' . $module . '\\Database\\Seeds\\DatabaseSeeder';\n        if (!class_exists($className)) {\n            return;\n        }\n\n        $seeder = App::make($className);\n        $return = $seeder->run();\n\n        if (isset($return) && (is_string($return) || is_array($return))) {\n            $this->addMessage($className, $return);\n        }\n\n        $this->note(sprintf('<info>Seeded %s</info> ', $module));\n        return $this;\n    }\n\n    /**\n     * Downloads the core from the update server.\n     * @param string $hash Expected file hash.\n     * @return void\n     */\n    public function downloadCore($hash)\n    {\n        $this->requestServerFile('core/get', 'core', $hash, ['type' => 'update']);\n    }\n\n    /**\n     * Extracts the core after it has been downloaded.\n     * @return void\n     */\n    public function extractCore()\n    {\n        $filePath = $this->getFilePath('core');\n\n        if (!Zip::extract($filePath, $this->baseDirectory)) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        @unlink($filePath);\n    }\n\n    /**\n     * Sets the build number and hash\n     * @param string $hash\n     * @param string $build\n     * @param bool $modified\n     * @return void\n     */\n    public function setBuild($build, $hash = null, $modified = false)\n    {\n        $params = [\n            'system::core.build' => $build,\n            'system::core.modified' => $modified,\n        ];\n\n        if ($hash) {\n            $params['system::core.hash'] = $hash;\n        }\n\n        Parameter::set($params);\n    }\n\n    //\n    // Plugins\n    //\n\n    /**\n     * Looks up a plugin from the update server.\n     * @param string $name Plugin name.\n     * @return array Details about the plugin.\n     */\n    public function requestPluginDetails($name)\n    {\n        return $this->requestServerData('plugin/detail', ['name' => $name]);\n    }\n\n    /**\n     * Looks up content for a plugin from the update server.\n     * @param string $name Plugin name.\n     * @return array Content for the plugin.\n     */\n    public function requestPluginContent($name)\n    {\n        return $this->requestServerData('plugin/content', ['name' => $name]);\n    }\n\n    /**\n     * Runs update on a single plugin\n     * @param string $name Plugin name.\n     * @return self\n     */\n    public function updatePlugin($name)\n    {\n        /*\n         * Update the plugin database and version\n         */\n        if (!($plugin = $this->pluginManager->findByIdentifier($name))) {\n            $this->note('<error>Unable to find:</error> ' . $name);\n            return;\n        }\n\n        $this->note($name);\n\n        $this->versionManager->setNotesOutput($this->notesOutput);\n\n        $this->versionManager->updatePlugin($plugin);\n\n        return $this;\n    }\n\n    /**\n     * Rollback an existing plugin\n     *\n     * @param string $name Plugin name.\n     * @param string $stopOnVersion If this parameter is specified, the process stops once the provided version number is reached\n     * @return self\n     */\n    public function rollbackPlugin(string $name, string $stopOnVersion = null)\n    {\n        /*\n         * Remove the plugin database and version\n         */\n        if (!($plugin = $this->pluginManager->findByIdentifier($name))\n            && $this->versionManager->purgePlugin($name)\n        ) {\n            $this->note('<info>Purged from database:</info> ' . $name);\n            return $this;\n        }\n\n        if ($stopOnVersion && !$this->versionManager->hasDatabaseVersion($plugin, $stopOnVersion)) {\n            throw new ApplicationException(Lang::get('system::lang.updates.plugin_version_not_found'));\n        }\n\n        if ($this->versionManager->removePlugin($plugin, $stopOnVersion, true)) {\n            $this->note('<info>Rolled back:</info> ' . $name);\n\n            if ($currentVersion = $this->versionManager->getCurrentVersion($plugin)) {\n                $this->note('<info>Current Version:</info> ' . $currentVersion . ' (' . $this->versionManager->getCurrentVersionNote($plugin) . ')');\n            }\n\n            return $this;\n        }\n\n        $this->note('<error>Unable to find:</error> ' . $name);\n\n        return $this;\n    }\n\n    /**\n     * Downloads a plugin from the update server.\n     * @param string $name Plugin name.\n     * @param string $hash Expected file hash.\n     * @param boolean $installation Indicates whether this is a plugin installation request.\n     * @return self\n     */\n    public function downloadPlugin($name, $hash, $installation = false)\n    {\n        $fileCode = $name . $hash;\n        $this->requestServerFile('plugin/get', $fileCode, $hash, [\n            'name'         => $name,\n            'installation' => $installation ? 1 : 0\n        ]);\n    }\n\n    /**\n     * Extracts a plugin after it has been downloaded.\n     */\n    public function extractPlugin($name, $hash)\n    {\n        $fileCode = $name . $hash;\n        $filePath = $this->getFilePath($fileCode);\n        $innerPath = str_replace('.', '/', strtolower($name));\n\n        if (!Zip::extract($filePath, plugins_path($innerPath))) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        @unlink($filePath);\n    }\n\n    //\n    // Themes\n    //\n\n    /**\n     * Looks up a theme from the update server.\n     * @param string $name Theme name.\n     * @return array Details about the theme.\n     */\n    public function requestThemeDetails($name)\n    {\n        return $this->requestServerData('theme/detail', ['name' => $name]);\n    }\n\n    /**\n     * Downloads a theme from the update server.\n     * @param string $name Theme name.\n     * @param string $hash Expected file hash.\n     * @return self\n     */\n    public function downloadTheme($name, $hash)\n    {\n        $fileCode = $name . $hash;\n\n        $this->requestServerFile('theme/get', $fileCode, $hash, ['name' => $name]);\n    }\n\n    /**\n     * Extracts a theme after it has been downloaded.\n     */\n    public function extractTheme($name, $hash)\n    {\n        $fileCode = $name . $hash;\n        $filePath = $this->getFilePath($fileCode);\n        $innerPath = str_replace('.', '-', strtolower($name));\n\n        if (!Zip::extract($filePath, themes_path($innerPath))) {\n            throw new ApplicationException(Lang::get('system::lang.zip.extract_failed', ['file' => $filePath]));\n        }\n\n        if ($this->themeManager) {\n            $this->themeManager->setInstalled($name);\n        }\n\n        @unlink($filePath);\n    }\n\n    //\n    // Products\n    //\n\n    public function requestProductDetails($codes, $type = null)\n    {\n        if ($type != 'plugin' && $type != 'theme') {\n            $type = 'plugin';\n        }\n\n        $codes = (array) $codes;\n        $this->loadProductDetailCache();\n\n        /*\n         * New products requested\n         */\n        $newCodes = array_diff($codes, array_keys($this->productCache[$type]));\n        if (count($newCodes)) {\n            $dataCodes = [];\n            $data = $this->requestServerData($type . '/details', ['names' => $newCodes]);\n            foreach ($data as $product) {\n                $code = array_get($product, 'code', -1);\n                $this->cacheProductDetail($type, $code, $product);\n                $dataCodes[] = $code;\n            }\n\n            /*\n             * Cache unknown products\n             */\n            $unknownCodes = array_diff($newCodes, $dataCodes);\n            foreach ($unknownCodes as $code) {\n                $this->cacheProductDetail($type, $code, -1);\n            }\n\n            $this->saveProductDetailCache();\n        }\n\n        /*\n         * Build details from cache\n         */\n        $result = [];\n        $requestedDetails = array_intersect_key($this->productCache[$type], array_flip($codes));\n\n        foreach ($requestedDetails as $detail) {\n            if ($detail === -1) {\n                continue;\n            }\n            $result[] = $detail;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns popular themes found on the marketplace.\n     */\n    public function requestPopularProducts($type = null)\n    {\n        if ($type != 'plugin' && $type != 'theme') {\n            $type = 'plugin';\n        }\n\n        $cacheKey = 'system-updates-popular-' . $type;\n\n        if (Cache::has($cacheKey)) {\n            return @unserialize(@base64_decode(Cache::get($cacheKey))) ?: [];\n        }\n\n        $data = $this->requestServerData($type . '/popular');\n        $expiresAt = now()->addMinutes(60);\n        Cache::put($cacheKey, base64_encode(serialize($data)), $expiresAt);\n\n        foreach ($data as $product) {\n            $code = array_get($product, 'code', -1);\n            $this->cacheProductDetail($type, $code, $product);\n        }\n\n        $this->saveProductDetailCache();\n\n        return $data;\n    }\n\n    protected function loadProductDetailCache()\n    {\n        $defaultCache = ['theme' => [], 'plugin' => []];\n        $cacheKey = 'system-updates-product-details';\n\n        if (Cache::has($cacheKey)) {\n            $this->productCache = @unserialize(@base64_decode(Cache::get($cacheKey))) ?: $defaultCache;\n        } else {\n            $this->productCache = $defaultCache;\n        }\n    }\n\n    protected function saveProductDetailCache()\n    {\n        if ($this->productCache === null) {\n            $this->loadProductDetailCache();\n        }\n\n        $cacheKey = 'system-updates-product-details';\n        $expiresAt = Carbon::now()->addDays(2);\n        Cache::put($cacheKey, base64_encode(serialize($this->productCache)), $expiresAt);\n    }\n\n    protected function cacheProductDetail($type, $code, $data)\n    {\n        if ($this->productCache === null) {\n            $this->loadProductDetailCache();\n        }\n\n        $this->productCache[$type][$code] = $data;\n    }\n\n    //\n    // Changelog\n    //\n\n    /**\n     * Returns the latest changelog information.\n     */\n    public function requestChangelog()\n    {\n        $result = Http::get('https://octobercms.com/changelog?json');\n\n        if ($result->code == 404) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_empty'));\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(\n                strlen($result->body)\n                ? $result->body\n                : Lang::get('system::lang.server.response_empty')\n            );\n        }\n\n        try {\n            $resultData = json_decode($result->body, true);\n        } catch (Exception $ex) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        return $resultData;\n    }\n\n    //\n    // Notes\n    //\n\n    /**\n     * Raise a note event for the migrator.\n     * @param string $message\n     * @return self\n     */\n    protected function note($message)\n    {\n        if ($this->notesOutput !== null) {\n            $this->notesOutput->writeln($message);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets an output stream for writing notes.\n     * @param Illuminate\\Console\\Command $output\n     * @return self\n     */\n    public function setNotesOutput($output)\n    {\n        $this->notesOutput = $output;\n\n        return $this;\n    }\n\n    //\n    // Gateway access\n    //\n\n    /**\n     * Contacts the update server for a response.\n     * @param string $uri Gateway API URI\n     * @param array $postData Extra post data\n     * @return array\n     */\n    public function requestServerData($uri, $postData = [])\n    {\n        $result = Http::post($this->createServerUrl($uri), function ($http) use ($postData) {\n            $this->applyHttpAttributes($http, $postData);\n        });\n\n        if ($result->code == 404) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_not_found'));\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(\n                strlen($result->body)\n                ? $result->body\n                : Lang::get('system::lang.server.response_empty')\n            );\n        }\n\n        $resultData = false;\n\n        try {\n            $resultData = @json_decode($result->body, true);\n        } catch (Exception $ex) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        if ($resultData === false || (is_string($resultData) && !strlen($resultData))) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid'));\n        }\n\n        if (!$this->validateServerSignature($resultData, $result->headers['Rest-Sign'] ?? '')) {\n            throw new ApplicationException(Lang::get('system::lang.server.response_invalid') . ' (Bad signature)');\n        }\n\n        return $resultData;\n    }\n\n    /**\n     * Downloads a file from the update server.\n     * @param string $uri Gateway API URI\n     * @param string $fileCode A unique code for saving the file.\n     * @param string $expectedHash The expected file hash of the file.\n     * @param array $postData Extra post data\n     * @return void\n     */\n    public function requestServerFile($uri, $fileCode, $expectedHash, $postData = [])\n    {\n        $filePath = $this->getFilePath($fileCode);\n\n        $result = Http::post($this->createServerUrl($uri), function ($http) use ($postData, $filePath) {\n            $this->applyHttpAttributes($http, $postData);\n            $http->toFile($filePath);\n        });\n\n        if (in_array($result->code, [301, 302])) {\n            if ($redirectUrl = array_get($result->info, 'redirect_url')) {\n                $result = Http::get($redirectUrl, function ($http) use ($postData, $filePath) {\n                    $http->toFile($filePath);\n                });\n            }\n        }\n\n        if ($result->code != 200) {\n            throw new ApplicationException(File::get($filePath));\n        }\n    }\n\n    /**\n     * Calculates a file path for a file code\n     * @param string $fileCode A unique file code\n     * @return string           Full path on the disk\n     */\n    protected function getFilePath($fileCode)\n    {\n        $name = md5($fileCode) . '.arc';\n        return $this->tempDirectory . '/' . $name;\n    }\n\n    /**\n     * Set the API security for all transmissions.\n     * @param string $key API Key\n     * @param string $secret API Secret\n     */\n    public function setSecurity($key, $secret)\n    {\n        $this->key = $key;\n        $this->secret = $secret;\n    }\n\n    /**\n     * Create a complete gateway server URL from supplied URI\n     * @param string $uri URI\n     * @return string      URL\n     */\n    protected function createServerUrl($uri)\n    {\n        $gateway = Config::get('cms.updateServer', 'https://gateway.octobercms.com/api');\n        if (substr($gateway, -1) != '/') {\n            $gateway .= '/';\n        }\n\n        return $gateway . $uri;\n    }\n\n    /**\n     * Modifies the Network HTTP object with common attributes.\n     * @param Http $http Network object\n     * @param array $postData Post data\n     * @return void\n     */\n    protected function applyHttpAttributes($http, $postData)\n    {\n        $postData['protocol_version'] = '1.3';\n        $postData['client'] = 'October CMS';\n\n        $postData['server'] = base64_encode(json_encode([\n            'php'   => PHP_VERSION,\n            'url'   => Url::to('/'),\n            'ip'    => Request::ip(),\n            'since' => PluginVersion::orderBy('created_at')->value('created_at')\n        ]));\n\n        if ($projectId = Parameter::get('system::project.id')) {\n            $postData['project'] = $projectId;\n        }\n\n        if (Config::get('cms.edgeUpdates', false)) {\n            $postData['edge'] = 1;\n        }\n\n        if ($this->key && $this->secret) {\n            $postData['nonce'] = $this->createNonce();\n            $http->header('Rest-Key', $this->key);\n            $http->header('Rest-Sign', $this->createSignature($postData, $this->secret));\n        }\n\n        if ($credentials = Config::get('cms.updateAuth')) {\n            $http->auth($credentials);\n        }\n\n        $http->noRedirect();\n        $http->data($postData);\n    }\n\n    /**\n     * Create a nonce based on millisecond time\n     * @return int\n     */\n    protected function createNonce()\n    {\n        $mt = explode(' ', microtime());\n        return $mt[1] . substr($mt[0], 2, 6);\n    }\n\n    /**\n     * Create a unique signature for transmission.\n     * @return string\n     */\n    protected function createSignature($data, $secret)\n    {\n        return base64_encode(hash_hmac('sha512', http_build_query($data, '', '&'), base64_decode($secret), true));\n    }\n\n    /**\n     * @return string\n     */\n    public function getMigrationTableName()\n    {\n        return Config::get('database.migrations', 'migrations');\n    }\n\n    /**\n     * Adds a message from a specific migration or seeder.\n     *\n     * @param string|object $class\n     * @param string|array $message\n     * @return void\n     */\n    protected function addMessage($class, $message)\n    {\n        if (empty($message)) {\n            return;\n        }\n\n        if (is_object($class)) {\n            $class = get_class($class);\n        }\n        if (!isset($this->messages[$class])) {\n            $this->messages[$class] = [];\n        }\n\n        if (is_string($message)) {\n            $this->messages[$class][] = $message;\n        } elseif (is_array($message)) {\n            array_merge($this->messages[$class], $message);\n        }\n    }\n\n    /**\n     * Prints collated messages from the migrations and seeders\n     *\n     * @return void\n     */\n    protected function printMessages()\n    {\n        if (!count($this->messages)) {\n            return;\n        }\n\n        // Add a line break\n        $this->note('');\n\n        foreach ($this->messages as $class => $messages) {\n            $this->note(sprintf('<info>%s reported:</info>', $class));\n\n            foreach ($messages as $message) {\n                $this->note(' - ' . (string) $message);\n            }\n        }\n    }\n\n    /**\n     * validateServerSignature checks the server has provided a valid signature\n     *\n     * @return bool\n     */\n    protected function validateServerSignature($data, $signature)\n    {\n        if (!$signature) {\n            return false;\n        }\n\n        $signature = base64_decode($signature);\n\n        $pubKey = '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt+KwvTXqC8Mz9vV4KIvX\n3y+aZusrlg26jdbNVUuhXNFbt1VisjJydHW2+WGsiEHSy2s61ZAV2dICR6f3huSw\njY/MH9j23Oo/u61CBpvIS3Q8uC+TLtJl4/F9eqlnzocfMoKe8NmcBbUR3TKQoIok\nxbSMl6jiE2k5TJdzhHUxjZRIeeLDLMKYX6xt37LdhuM8zO6sXQmCGg4J6LmHTJph\n96H11gBvcFSFJSmIiDykJOELZl/aVcY1g3YgpL0mw5Bw1VTmKaRdz1eBi9DmKrKX\nUijG4gD8eLRV/FS/sZCFNR/evbQXvTBxO0TOIVi85PlQEcMl4SBj0CoTyNbcAGtz\n4wIDAQAB\n-----END PUBLIC KEY-----';\n\n        $pubKey = Config::get('system.update_gateway_key', $pubKey);\n\n        $data = base64_encode(json_encode($data));\n\n        return openssl_verify($data, $signature, $pubKey) === 1;\n    }\n}\n"], "filenames": ["modules/system/classes/UpdateManager.php"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [1072], "fixing_code_start_loc": [11], "fixing_code_end_loc": [1109], "type": "CWE-347", "message": "Octobercms is a self-hosted CMS platform based on the Laravel PHP Framework. Affected versions of OctoberCMS did not validate gateway server signatures. As a result non-authoritative gateway servers may be used to exfiltrate user private keys. Users are advised to upgrade their installations to build 474 or v1.1.10. The only known workaround is to manually apply the patch (e3b455ad587282f0fbcb7763c6d9c3d000ca1e6a) which adds server signature validation.", "other": {"cve": {"id": "CVE-2022-23655", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-24T00:15:07.507", "lastModified": "2022-03-07T17:15:35.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Octobercms is a self-hosted CMS platform based on the Laravel PHP Framework. Affected versions of OctoberCMS did not validate gateway server signatures. As a result non-authoritative gateway servers may be used to exfiltrate user private keys. Users are advised to upgrade their installations to build 474 or v1.1.10. The only known workaround is to manually apply the patch (e3b455ad587282f0fbcb7763c6d9c3d000ca1e6a) which adds server signature validation."}, {"lang": "es", "value": "Octobercms es una plataforma CMS auto-alojada basada en el framework PHP Laravel. Las versiones afectadas de OctoberCMS no comprueban las firmas del servidor de puerta de enlace. Como resultado, los servidores de puerta de enlace no autorizados pueden ser usados para exfiltrar las claves privadas de usuarios. Es recomendado a usuarios actualizar sus instalaciones a versi\u00f3n 474 o a versi\u00f3n v1.1.10. La \u00fanica medida de mitigaci\u00f3n conocida es aplicar manualmente el parche (e3b455ad587282f0fbcb7763c6d9c3d000ca1e6a) que a\u00f1ade la comprobaci\u00f3n de la firma del servidor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.475", "matchCriteriaId": "42D784EC-AC13-4AE2-83D8-39C4170BCB7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.11", "matchCriteriaId": "F871AD37-852B-4C7A-AC65-B0FD3938534C"}]}]}], "references": [{"url": "https://github.com/octobercms/october/commit/e3b455ad587282f0fbcb7763c6d9c3d000ca1e6a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/october/security/advisories/GHSA-53m6-44rc-h2q5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/october/commit/e3b455ad587282f0fbcb7763c6d9c3d000ca1e6a"}}