{"buggy_code": ["package io.onedev.server.migration;\r\n\r\nimport java.beans.IntrospectionException;\r\nimport java.beans.PropertyDescriptor;\r\nimport java.io.IOException;\r\nimport java.io.StringReader;\r\nimport java.io.StringWriter;\r\nimport java.lang.reflect.Method;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.hibernate.proxy.HibernateProxyHelper;\r\nimport org.yaml.snakeyaml.DumperOptions;\r\nimport org.yaml.snakeyaml.DumperOptions.FlowStyle;\r\nimport org.yaml.snakeyaml.Yaml;\r\nimport org.yaml.snakeyaml.constructor.Constructor;\r\nimport org.yaml.snakeyaml.emitter.Emitter;\r\nimport org.yaml.snakeyaml.introspector.BeanAccess;\r\nimport org.yaml.snakeyaml.introspector.MethodProperty;\r\nimport org.yaml.snakeyaml.introspector.Property;\r\nimport org.yaml.snakeyaml.introspector.PropertyUtils;\r\nimport org.yaml.snakeyaml.nodes.MappingNode;\r\nimport org.yaml.snakeyaml.nodes.Node;\r\nimport org.yaml.snakeyaml.nodes.NodeTuple;\r\nimport org.yaml.snakeyaml.nodes.ScalarNode;\r\nimport org.yaml.snakeyaml.nodes.Tag;\r\nimport org.yaml.snakeyaml.representer.Representer;\r\nimport org.yaml.snakeyaml.resolver.Resolver;\r\nimport org.yaml.snakeyaml.serializer.Serializer;\r\n\r\nimport edu.emory.mathcs.backport.java.util.Collections;\r\nimport io.onedev.commons.launcher.loader.ImplementationRegistry;\r\nimport io.onedev.commons.utils.ClassUtils;\r\nimport io.onedev.server.OneDev;\r\nimport io.onedev.server.GeneralException;\r\nimport io.onedev.server.util.BeanUtils;\r\nimport io.onedev.server.web.editable.annotation.Editable;\r\n\r\npublic class VersionedYamlDoc extends MappingNode {\r\n\r\n\tpublic VersionedYamlDoc(MappingNode wrapped) {\r\n\t\tsuper(wrapped.getTag(), wrapped.getValue(), wrapped.getFlowStyle());\r\n\t}\r\n\t\r\n\tpublic static VersionedYamlDoc fromYaml(String yaml) {\r\n\t\treturn new VersionedYamlDoc((MappingNode) new OneYaml().compose(new StringReader(yaml)));\r\n\t}\r\n\t\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic <T> T toBean(Class<T> beanClass) {\r\n        setTag(new Tag(beanClass));\r\n        \r\n\t\tif (getVersion() != null) {\r\n\t\t\ttry {\r\n\t\t\t\tMigrationHelper.migrate(getVersion(), beanClass.newInstance(), this);\r\n\t\t\t\tremoveVersion();\r\n\t\t\t} catch (InstantiationException | IllegalAccessException e) {\r\n\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        return (T) new OneYaml().construct(this);\r\n\t}\r\n\t\r\n\tpublic static VersionedYamlDoc fromBean(Object bean) {\r\n\t\tVersionedYamlDoc doc = new VersionedYamlDoc((MappingNode) new OneYaml().represent(bean));\r\n\t\tdoc.setVersion(MigrationHelper.getVersion(HibernateProxyHelper.getClassWithoutInitializingProxy(bean)));\r\n\t\treturn doc;\r\n\t}\r\n\t\r\n\tprivate String getVersion() {\r\n\t\tfor (NodeTuple tuple: getValue()) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) \r\n\t\t\t\treturn ((ScalarNode)tuple.getValueNode()).getValue();\r\n\t\t}\r\n\t\tthrow new GeneralException(\"Unable to find version\");\r\n\t}\r\n\t\r\n\tprivate void removeVersion() {\r\n\t\tfor (Iterator<NodeTuple> it = getValue().iterator(); it.hasNext();) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) it.next().getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) \r\n\t\t\t\tit.remove();\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void setVersion(String version) {\r\n\t\tScalarNode versionNode = null;\r\n\t\tfor (NodeTuple tuple:  getValue()) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) {\r\n\t\t\t\t((ScalarNode) tuple.getValueNode()).setValue(version);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (versionNode == null) {\r\n\t\t\tScalarNode keyNode = new ScalarNode(Tag.STR, \"version\", null, null, DumperOptions.ScalarStyle.PLAIN);\r\n\t\t\tversionNode = new ScalarNode(Tag.INT, version, null, null, DumperOptions.ScalarStyle.PLAIN);\r\n\t\t\tgetValue().add(0, new NodeTuple(keyNode, versionNode));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic String toYaml() {\r\n\t\tStringWriter writer = new StringWriter();\r\n\t\tDumperOptions dumperOptions = new DumperOptions();\r\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \r\n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\r\n\t\ttry {\r\n\t\t\tserializer.open();\r\n\t\t\tserializer.serialize(this);\r\n\t\t\tserializer.close();\r\n\t\t\treturn writer.toString();\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate static class OneConstructor extends Constructor {\r\n\t\t\r\n\t\tpublic Object construct(Node node) {\r\n\t\t\treturn constructDocument(node);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tprotected Class<?> getClassForNode(Node node) {\r\n\t\t\tClass<?> type = node.getType();\r\n\t\t\tif (type.getAnnotation(Editable.class) != null && !ClassUtils.isConcrete(type)) {\r\n\t\t\t\tImplementationRegistry registry = OneDev.getInstance(ImplementationRegistry.class);\r\n\t\t\t\tfor (Class<?> implementationClass: registry.getImplementations(node.getType())) {\r\n\t\t\t\t\tString implementationTag = new Tag(\"!\" + implementationClass.getSimpleName()).getValue();\r\n\t\t\t\t\tif (implementationTag.equals(node.getTag().getValue()))\r\n\t\t\t\t\t\treturn implementationClass;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn super.getClassForNode(node);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tprivate static class OneYaml extends Yaml {\r\n\r\n\t\tOneYaml() {\r\n\t\t\tsuper(newConstructor(), newRepresenter());\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\t * Use property here as yaml will be read by human and we want to make \r\n\t\t\t * it consistent with presented in UI \r\n\t\t\t */\r\n\t\t\tsetBeanAccess(BeanAccess.PROPERTY);\r\n\t\t}\r\n\t\t\r\n\t\tprivate static Representer newRepresenter() {\r\n\t\t\tRepresenter representer = new Representer() {\r\n\t\t\t\t\r\n\t\t\t    @SuppressWarnings(\"rawtypes\")\r\n\t\t\t\t@Override\r\n\t\t\t    protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, \r\n\t\t\t    \t\tObject propertyValue,Tag customTag) {\r\n\t\t\t        if (propertyValue == null \r\n\t\t\t        \t\t|| propertyValue instanceof Collection && ((Collection) propertyValue).isEmpty()\r\n\t\t\t        \t\t|| propertyValue instanceof Map && ((Map) propertyValue).isEmpty()) { \r\n\t\t\t        \treturn null;\r\n\t\t\t        } else {\r\n\t\t\t        \treturn super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);\r\n\t\t\t        }\r\n\t\t\t    }\r\n\r\n\t\t\t};\r\n\t\t\trepresenter.setDefaultFlowStyle(FlowStyle.BLOCK);\r\n\t\t\trepresenter.setPropertyUtils(new PropertyUtils() {\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tprotected Set<Property> createPropertySet(Class<? extends Object> type, BeanAccess bAccess) {\r\n\t\t\t\t\tList<Property> properties = new ArrayList<>();\r\n\t\t\t\t\tMap<String, Integer> orders = new HashMap<>();\r\n\t\t\t\t\tif (type.getAnnotation(Editable.class) != null) {\r\n\t\t\t\t\t\tfor (Method getter: BeanUtils.findGetters(type)) {\r\n\t\t\t\t\t\t\tEditable editable = getter.getAnnotation(Editable.class);\r\n\t\t\t\t\t\t\tMethod setter = BeanUtils.findSetter(getter);\r\n\t\t\t\t\t\t\tif (editable != null && setter != null) {\r\n\t\t\t\t\t\t\t\tString propertyName = BeanUtils.getPropertyName(getter);\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tproperties.add(new MethodProperty(new PropertyDescriptor(propertyName, getter, setter)));\r\n\t\t\t\t\t\t\t\t} catch (IntrospectionException e) {\r\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\torders.put(propertyName, editable.order());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tCollections.sort(properties, new Comparator<Property>() {\r\n\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic int compare(Property o1, Property o2) {\r\n\t\t\t\t\t\t\treturn orders.get(o1.getName()) - orders.get(o2.getName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn new LinkedHashSet<>(properties);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\treturn representer;\r\n\t\t}\r\n\t\t\r\n\t\tprivate static OneConstructor newConstructor() {\r\n\t\t\treturn new OneConstructor();\r\n\t\t}\r\n\t\t\r\n\t\tpublic Object construct(Node node) {\r\n\t        return ((OneConstructor)constructor).construct(node);\r\n\t\t}\r\n\t    \r\n\t}\r\n\r\n}\r\n"], "fixing_code": ["package io.onedev.server.migration;\r\n\r\nimport java.beans.IntrospectionException;\r\nimport java.beans.PropertyDescriptor;\r\nimport java.io.IOException;\r\nimport java.io.StringReader;\r\nimport java.io.StringWriter;\r\nimport java.lang.reflect.Method;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.hibernate.proxy.HibernateProxyHelper;\r\nimport org.yaml.snakeyaml.DumperOptions;\r\nimport org.yaml.snakeyaml.DumperOptions.FlowStyle;\r\nimport org.yaml.snakeyaml.Yaml;\r\nimport org.yaml.snakeyaml.constructor.Constructor;\r\nimport org.yaml.snakeyaml.emitter.Emitter;\r\nimport org.yaml.snakeyaml.introspector.BeanAccess;\r\nimport org.yaml.snakeyaml.introspector.MethodProperty;\r\nimport org.yaml.snakeyaml.introspector.Property;\r\nimport org.yaml.snakeyaml.introspector.PropertyUtils;\r\nimport org.yaml.snakeyaml.nodes.MappingNode;\r\nimport org.yaml.snakeyaml.nodes.Node;\r\nimport org.yaml.snakeyaml.nodes.NodeTuple;\r\nimport org.yaml.snakeyaml.nodes.ScalarNode;\r\nimport org.yaml.snakeyaml.nodes.Tag;\r\nimport org.yaml.snakeyaml.representer.Representer;\r\nimport org.yaml.snakeyaml.resolver.Resolver;\r\nimport org.yaml.snakeyaml.serializer.Serializer;\r\n\r\nimport edu.emory.mathcs.backport.java.util.Collections;\r\nimport io.onedev.commons.launcher.loader.ImplementationRegistry;\r\nimport io.onedev.commons.utils.ClassUtils;\r\nimport io.onedev.server.GeneralException;\r\nimport io.onedev.server.OneDev;\r\nimport io.onedev.server.util.BeanUtils;\r\nimport io.onedev.server.web.editable.annotation.Editable;\r\n\r\npublic class VersionedYamlDoc extends MappingNode {\r\n\r\n\tpublic VersionedYamlDoc(MappingNode wrapped) {\r\n\t\tsuper(wrapped.getTag(), wrapped.getValue(), wrapped.getFlowStyle());\r\n\t}\r\n\t\r\n\tpublic static VersionedYamlDoc fromYaml(String yaml) {\r\n\t\treturn new VersionedYamlDoc((MappingNode) new OneYaml().compose(new StringReader(yaml)));\r\n\t}\r\n\t\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic <T> T toBean(Class<T> beanClass) {\r\n        setTag(new Tag(beanClass));\r\n\t\tif (getVersion() != null) {\r\n\t\t\ttry {\r\n\t\t\t\tMigrationHelper.migrate(getVersion(), beanClass.newInstance(), this);\r\n\t\t\t\tremoveVersion();\r\n\t\t\t} catch (InstantiationException | IllegalAccessException e) {\r\n\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        return (T) new OneYaml().construct(this);\r\n\t}\r\n\t\r\n\tpublic static VersionedYamlDoc fromBean(Object bean) {\r\n\t\tVersionedYamlDoc doc = new VersionedYamlDoc((MappingNode) new OneYaml().represent(bean));\r\n\t\tdoc.setVersion(MigrationHelper.getVersion(HibernateProxyHelper.getClassWithoutInitializingProxy(bean)));\r\n\t\treturn doc;\r\n\t}\r\n\t\r\n\tprivate String getVersion() {\r\n\t\tfor (NodeTuple tuple: getValue()) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) \r\n\t\t\t\treturn ((ScalarNode)tuple.getValueNode()).getValue();\r\n\t\t}\r\n\t\tthrow new GeneralException(\"Unable to find version\");\r\n\t}\r\n\t\r\n\tprivate void removeVersion() {\r\n\t\tfor (Iterator<NodeTuple> it = getValue().iterator(); it.hasNext();) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) it.next().getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) \r\n\t\t\t\tit.remove();\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void setVersion(String version) {\r\n\t\tScalarNode versionNode = null;\r\n\t\tfor (NodeTuple tuple:  getValue()) {\r\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\r\n\t\t\tif (keyNode.getValue().equals(\"version\")) {\r\n\t\t\t\t((ScalarNode) tuple.getValueNode()).setValue(version);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (versionNode == null) {\r\n\t\t\tScalarNode keyNode = new ScalarNode(Tag.STR, \"version\", null, null, DumperOptions.ScalarStyle.PLAIN);\r\n\t\t\tversionNode = new ScalarNode(Tag.INT, version, null, null, DumperOptions.ScalarStyle.PLAIN);\r\n\t\t\tgetValue().add(0, new NodeTuple(keyNode, versionNode));\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic String toYaml() {\r\n\t\tStringWriter writer = new StringWriter();\r\n\t\tDumperOptions dumperOptions = new DumperOptions();\r\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \r\n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\r\n\t\ttry {\r\n\t\t\tserializer.open();\r\n\t\t\tserializer.serialize(this);\r\n\t\t\tserializer.close();\r\n\t\t\treturn writer.toString();\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate static class OneConstructor extends Constructor {\r\n\t\t\r\n\t\tpublic Object construct(Node node) {\r\n\t\t\treturn constructDocument(node);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tprotected Class<?> getClassForNode(Node node) {\r\n\t\t\tif (node instanceof VersionedYamlDoc) {\r\n\t\t\t\treturn super.getClassForNode(node);\r\n\t\t\t} else {\r\n\t\t\t\tClass<?> type = node.getType();\r\n\t\t\t\tif (type.getAnnotation(Editable.class) == null) {\r\n\t\t\t\t\t// Do not deserialize unknown classes to avoid security vulnerabilities\r\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Unexpected yaml node (type: %s, tag: %s)\", \r\n\t\t\t\t\t\t\ttype, node.getTag()));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!ClassUtils.isConcrete(type)) {\r\n\t\t\t\t\t\tImplementationRegistry registry = OneDev.getInstance(ImplementationRegistry.class);\r\n\t\t\t\t\t\tfor (Class<?> implementationClass: registry.getImplementations(node.getType())) {\r\n\t\t\t\t\t\t\tString implementationTag = new Tag(\"!\" + implementationClass.getSimpleName()).getValue();\r\n\t\t\t\t\t\t\tif (implementationTag.equals(node.getTag().getValue()))\r\n\t\t\t\t\t\t\t\treturn implementationClass;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn super.getClassForNode(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tprivate static class OneYaml extends Yaml {\r\n\r\n\t\tOneYaml() {\r\n\t\t\tsuper(newConstructor(), newRepresenter());\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\t * Use property here as yaml will be read by human and we want to make \r\n\t\t\t * it consistent with presented in UI \r\n\t\t\t */\r\n\t\t\tsetBeanAccess(BeanAccess.PROPERTY);\r\n\t\t}\r\n\t\t\r\n\t\tprivate static Representer newRepresenter() {\r\n\t\t\tRepresenter representer = new Representer() {\r\n\t\t\t\t\r\n\t\t\t    @SuppressWarnings(\"rawtypes\")\r\n\t\t\t\t@Override\r\n\t\t\t    protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, \r\n\t\t\t    \t\tObject propertyValue,Tag customTag) {\r\n\t\t\t        if (propertyValue == null \r\n\t\t\t        \t\t|| propertyValue instanceof Collection && ((Collection) propertyValue).isEmpty()\r\n\t\t\t        \t\t|| propertyValue instanceof Map && ((Map) propertyValue).isEmpty()) { \r\n\t\t\t        \treturn null;\r\n\t\t\t        } else {\r\n\t\t\t        \treturn super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);\r\n\t\t\t        }\r\n\t\t\t    }\r\n\r\n\t\t\t};\r\n\t\t\trepresenter.setDefaultFlowStyle(FlowStyle.BLOCK);\r\n\t\t\trepresenter.setPropertyUtils(new PropertyUtils() {\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tprotected Set<Property> createPropertySet(Class<? extends Object> type, BeanAccess bAccess) {\r\n\t\t\t\t\tList<Property> properties = new ArrayList<>();\r\n\t\t\t\t\tMap<String, Integer> orders = new HashMap<>();\r\n\t\t\t\t\tif (type.getAnnotation(Editable.class) != null) {\r\n\t\t\t\t\t\tfor (Method getter: BeanUtils.findGetters(type)) {\r\n\t\t\t\t\t\t\tEditable editable = getter.getAnnotation(Editable.class);\r\n\t\t\t\t\t\t\tMethod setter = BeanUtils.findSetter(getter);\r\n\t\t\t\t\t\t\tif (editable != null && setter != null) {\r\n\t\t\t\t\t\t\t\tString propertyName = BeanUtils.getPropertyName(getter);\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tproperties.add(new MethodProperty(new PropertyDescriptor(propertyName, getter, setter)));\r\n\t\t\t\t\t\t\t\t} catch (IntrospectionException e) {\r\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\torders.put(propertyName, editable.order());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tCollections.sort(properties, new Comparator<Property>() {\r\n\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic int compare(Property o1, Property o2) {\r\n\t\t\t\t\t\t\treturn orders.get(o1.getName()) - orders.get(o2.getName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn new LinkedHashSet<>(properties);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\treturn representer;\r\n\t\t}\r\n\t\t\r\n\t\tprivate static OneConstructor newConstructor() {\r\n\t\t\treturn new OneConstructor();\r\n\t\t}\r\n\t\t\r\n\t\tpublic Object construct(Node node) {\r\n\t        return ((OneConstructor)constructor).construct(node);\r\n\t\t}\r\n\t    \r\n\t}\r\n\r\n}\r\n"], "filenames": ["server-core/src/main/java/io/onedev/server/migration/VersionedYamlDoc.java"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [145], "fixing_code_start_loc": [41], "fixing_code_end_loc": [152], "type": "CWE-502", "message": "OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, there is an issue involving YAML parsing which can lead to post-auth remote code execution. In order to parse and process YAML files, OneDev uses SnakeYaml which by default (when not using `SafeConstructor`) allows the instantiation of arbitrary classes. We can leverage that to run arbitrary code by instantiating classes such as `javax.script.ScriptEngineManager` and using `URLClassLoader` to load the script engine provider, resulting in the instantiation of a user controlled class. For a full example refer to the referenced GHSA. This issue was addressed in 4.0.3 by only allowing certain known classes to be deserialized", "other": {"cve": {"id": "CVE-2021-21249", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-15T21:15:13.740", "lastModified": "2022-04-26T16:13:44.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, there is an issue involving YAML parsing which can lead to post-auth remote code execution. In order to parse and process YAML files, OneDev uses SnakeYaml which by default (when not using `SafeConstructor`) allows the instantiation of arbitrary classes. We can leverage that to run arbitrary code by instantiating classes such as `javax.script.ScriptEngineManager` and using `URLClassLoader` to load the script engine provider, resulting in the instantiation of a user controlled class. For a full example refer to the referenced GHSA. This issue was addressed in 4.0.3 by only allowing certain known classes to be deserialized"}, {"lang": "es", "value": "OneDev es una plataforma devops todo en uno.&#xa0;En OneDev versiones anteriores a 4.0.3, Se presenta un problema relacionado con el an\u00e1lisis de YAML que puede conllevar a una ejecuci\u00f3n de c\u00f3digo remota  posterior a la autenticaci\u00f3n.&#xa0;Para analizar y procesar archivos YAML, OneDev usa SnakeYaml que por defecto (cuando no usa \"SafeConstructor\") permite la instanciaci\u00f3n de clases arbitrarias.&#xa0;Podemos aprovechar eso para ejecutar c\u00f3digo arbitrario creando instancias de clases como \"javax.script.ScriptEngineManager\" y usando \"URLClassLoader\" para cargar el proveedor del motor de script, resultando en la instanciaci\u00f3n de una clase controlada por el usuario.&#xa0;Para obtener un ejemplo completo, consulte la GHSA referenciada.&#xa0;Este problema fue abordado en la versi\u00f3n 4.0.3, al permitir que determinadas clases conocidas sean deserializadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onedev_project:onedev:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.3", "matchCriteriaId": "5287F01C-3A77-4491-AB49-401A50FAA6E9"}]}]}], "references": [{"url": "https://github.com/theonedev/onedev/commit/d6fc4212b1ac1e9bbe3ce444e95f9af1e3ab8b66", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/theonedev/onedev/security/advisories/GHSA-7xhq-m2q9-6hpm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/theonedev/onedev/commit/d6fc4212b1ac1e9bbe3ce444e95f9af1e3ab8b66"}}