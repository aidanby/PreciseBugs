{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"quant.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\n#include <math.h>\n\nu32 gf_bifs_dec_qp14_get_bits(GF_BifsDecoder *codec)\n{\n\tif (!codec->ActiveQP || !codec->coord_stored) return 0;\n\treturn (u32) ceil(log1p(codec->NumCoord) / log(2) );\n}\n\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter)\n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\nvoid gf_bifs_dec_qp14_reset(GF_BifsDecoder * codec)\n{\n\tcodec->coord_stored = GF_FALSE;\n\tcodec->storing_coord = GF_FALSE;\n\tcodec->NumCoord = 0;\n}\n\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements)\n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n\nGF_Err gf_bifs_dec_qp_set(GF_BifsDecoder *codec, GF_Node *qp)\n{\n\tassert(gf_node_get_tag(qp) == TAG_MPEG4_QuantizationParameter);\n\n\t/*if we have an active QP, push it into the stack*/\n\tif (codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) )\n\t\tgf_list_insert(codec->QPs, codec->ActiveQP, 0);\n\n\tcodec->ActiveQP = (M_QuantizationParameter *)qp;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_qp_remove(GF_BifsDecoder *codec, Bool ActivatePrev)\n{\n\tif (!codec->force_keep_qp && codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) ) {\n\t\tgf_node_unregister((GF_Node *) codec->ActiveQP, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tif (!ActivatePrev) return GF_OK;\n\n\tif (gf_list_count(codec->QPs)) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter*)gf_list_get(codec->QPs, 0);\n\t\tgf_list_rem(codec->QPs, 0);\n\t} else if (codec->scenegraph->global_qp) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter *)codec->scenegraph->global_qp;\n\t}\n\treturn GF_OK;\n}\n\n//parses efficient float\nFixed gf_bifs_dec_mantissa_float(GF_BifsDecoder *codec, GF_BitStream *bs)\n{\n\tu32 mantLength, expLength, mantSign, mantissa;\n\tunsigned char exp;\n\n\tunion {\n\t\tFloat f;\n\t\tlong l;\n\t} ft_value;\n\n\tmantLength = gf_bs_read_int(bs, 4);\n\tif (!mantLength) return 0;\n\n\texpLength = gf_bs_read_int(bs, 3);\n\tmantSign = gf_bs_read_int(bs, 1);\n\tmantissa = gf_bs_read_int(bs, mantLength - 1);\n\n\texp = 127;\n\tif (expLength) {\n\t\tu32 expSign = gf_bs_read_int(bs, 1);\n\t\tu32 exponent = gf_bs_read_int(bs, expLength-1);\n\t\texp += (1-2*expSign)*( (1 << (expLength-1) ) + exponent);\n\t}\n\n\tft_value.l = mantSign << 31;\n\tft_value.l |= (exp & 0xff) << 23;\n\tft_value.l |= mantissa << 9;\n\treturn FLT2FIX(ft_value.f);\n}\n\n//check if the quant type is on in the QP, and if so retrieves NbBits and Min Max\n//specified for the field\nBool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b_min, SFVec3f *b_max)\n{\n\tswitch (q_type) {\n\tcase QC_3DPOS:\n\t\tif (!qp->position3DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position3DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position3DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position3DMin.y);\n\t\tb_min->z = MAX(b_min->z, qp->position3DMin.z);\n\t\tb_max->x = MIN(b_max->x, qp->position3DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position3DMax.y);\n\t\tb_max->z = MIN(b_max->z, qp->position3DMax.z);\n\t\treturn GF_TRUE;\n\tcase QC_2DPOS:\n\t\tif (!qp->position2DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position2DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position2DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position2DMin.y);\n\t\tb_max->x = MIN(b_max->x, qp->position2DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position2DMax.y);\n\t\treturn GF_TRUE;\n\tcase QC_ORDER:\n\t\tif (!qp->drawOrderQuant) return GF_FALSE;\n\t\t*NbBits = qp->drawOrderNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->drawOrderMin);\n\t\tb_max->x = MIN(b_max->x, qp->drawOrderMax);\n\t\treturn GF_TRUE;\n\tcase QC_COLOR:\n\t\tif (!qp->colorQuant) return GF_FALSE;\n\t\t*NbBits = qp->colorNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->colorMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->colorMax);\n\t\treturn GF_TRUE;\n\tcase QC_TEXTURE_COORD:\n\t\tif (!qp->textureCoordinateQuant) return GF_FALSE;\n\t\t*NbBits = qp->textureCoordinateNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->textureCoordinateMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->textureCoordinateMax);\n\t\treturn GF_TRUE;\n\tcase QC_ANGLE:\n\t\tif (!qp->angleQuant) return GF_FALSE;\n\t\t*NbBits = qp->angleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->angleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->angleMax);\n\t\treturn GF_TRUE;\n\tcase QC_SCALE:\n\t\tif (!qp->scaleQuant) return GF_FALSE;\n\t\t*NbBits = qp->scaleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->scaleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->scaleMax);\n\t\treturn GF_TRUE;\n\tcase QC_INTERPOL_KEYS:\n\t\tif (!qp->keyQuant) return GF_FALSE;\n\t\t*NbBits = qp->keyNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->keyMin);\n\t\tb_min->y = MAX(b_min->y, qp->keyMin);\n\t\tb_min->z = MAX(b_min->z, qp->keyMin);\n\t\tb_max->x = MIN(b_max->x, qp->keyMax);\n\t\tb_max->y = MIN(b_max->y, qp->keyMax);\n\t\tb_max->z = MIN(b_max->z, qp->keyMax);\n\t\treturn GF_TRUE;\n\tcase QC_NORMALS:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_ROTATION:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_3D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_2D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\n\t//cf specs, from here ALWAYS ON\n\tcase QC_LINEAR_SCALAR:\n\t\t//nbBits is the one from the FCT - DO NOT CHANGE IT\n\t\treturn GF_TRUE;\n\tcase QC_COORD_INDEX:\n\t\t//nbBits has to be recomputed on the fly\n\t\treturn GF_TRUE;\n\tcase QC_RESERVED:\n\t\t*NbBits = 0;\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n\n//Linear inverse Quantization for floats\nFixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)\n{\n\tif (!value) return Min;\n\tif (value == (u32) ((1 << NbBits) - 1) ) return Max;\n\treturn Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );\n}\n\n\nGF_Err Q_DecFloat(GF_BifsDecoder *codec, GF_BitStream *bs, u32 FieldType, SFVec3f BMin, SFVec3f BMax, u32 NbBits, void *field_ptr)\n{\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field_ptr) = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec2f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->z = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field_ptr)->red = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->green = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->blue = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\n\tcase GF_SG_VRML_SFROTATION:\n\t\t//forbidden in this Q mode\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n//int in quant are either Linear Scalar fields or CoordIndex\n//the quant is just a bitshifting into [0, 2^NbBits-1]\n//so IntMin + ReadBit(NbBits) = value\nGF_Err Q_DecInt(GF_BifsDecoder *codec, GF_BitStream *bs, u32 QType, SFInt32 b_min, u32 NbBits, void *field_ptr)\n{\n\tswitch (QType) {\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\t*((SFInt32 *)field_ptr) = gf_bs_read_int(bs, NbBits) + b_min;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n//SFRotation and SFVec3f are quantized as normalized vectors ,mapped on a cube\n//in the UnitSphere (R=1.0)\nGF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}\n\n//parses a rotation\nGF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tu32 i;\n\tFixed q, sin2, comp[4];\n\tGF_Err e;\n\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 3, comp);\n\tif (e) return e;\n\n\tq = 2 * gf_acos(comp[0]);\n\tsin2 = gf_sin(q / 2);\n\n\tif (ABS(sin2) <= FIX_EPSILON) {\n\t\tfor (i=1; i<4; i++) comp[i] = 0;\n\t\tcomp[3] = FIX_ONE;\n\t} else {\n\t\tfor (i=1; i<4; i++) comp[i] = gf_divfix(comp[i], sin2);\n\t}\n\t((SFRotation *)field_ptr)->x = comp[1];\n\t((SFRotation *)field_ptr)->y = comp[2];\n\t((SFRotation *)field_ptr)->z = comp[3];\n\t((SFRotation *)field_ptr)->q = q;\n\treturn GF_OK;\n}\n\n//parses a Normal vec\nGF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tFixed comp[4];\n\tSFVec3f v;\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);\n\tif (e) return e;\n\tv.x = comp[0];\n\tv.y = comp[1];\n\tv.z = comp[2];\n\tgf_vec_norm(&v);\n\t*((SFVec3f *)field_ptr) = v;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_unquant_field(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field)\n{\n\tBool HasQ;\n\tu8 QType, AType;\n\tu32 NbBits;\n\tFixed b_min, b_max;\n\tSFVec3f BMin, BMax;\n\tGF_Err e;\n\n\t/*check QP*/\n\tif (!codec->ActiveQP) return GF_EOS;\n\t/*check FieldType*/\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_EOS;\n\t}\n\n\t/*check NDT*/\n\tHasQ = gf_bifs_get_aq_info(node, field->fieldIndex, &QType, &AType, &b_min, &b_max, &NbBits);\n\tif (!HasQ || !QType) return GF_EOS;\n\n\t/*get NbBits for QP14 (QC_COORD_INDEX)*/\n\tif (QType == QC_COORD_INDEX) {\n\t\tNbBits = gf_bifs_dec_qp14_get_bits(codec);\n\t\t/*QP14 is always on, not having NbBits set means the coord field is set after the index field, hence not decodable*/\n\t\tif (!NbBits) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tBMin.x = BMin.y = BMin.z = b_min;\n\tBMax.x = BMax.y = BMax.z = b_max;\n\n\t/*check is the QP is on and retrieves the bounds*/\n\tif (!Q_IsTypeOn(codec->ActiveQP, QType, &NbBits, &BMin, &BMax)) return GF_EOS;\n\n\t/*ok the field is Quantized, dequantize*/\n\tswitch (QType) {\n\t//these are all SFFloat quantized on n fields\n\tcase QC_3DPOS:\n\tcase QC_2DPOS:\n\tcase QC_ORDER:\n\tcase QC_COLOR:\n\tcase QC_TEXTURE_COORD:\n\tcase QC_ANGLE:\n\tcase QC_SCALE:\n\tcase QC_INTERPOL_KEYS:\n\tcase QC_SIZE_3D:\n\tcase QC_SIZE_2D:\n\t\te = Q_DecFloat(codec, bs, field->fieldType, BMin, BMax, NbBits, field->far_ptr);\n\t\tbreak;\n\t//SFInt types\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\te = Q_DecInt(codec, bs, QType, (SFInt32) b_min, NbBits, field->far_ptr);\n\t\tbreak;\n\t//normalized fields (normals and vectors)\n\tcase QC_NORMALS:\n\t\t//normal quant is only for SFVec3F\n\t\tif (field->fieldType != GF_SG_VRML_SFVEC3F) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecNormal(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tcase QC_ROTATION:\n\t\t//normal quant is only for SFRotation\n\t\tif (field->fieldType != GF_SG_VRML_SFROTATION) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecRotation(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (e) return e;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"quant.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\n#include <math.h>\n\nu32 gf_bifs_dec_qp14_get_bits(GF_BifsDecoder *codec)\n{\n\tif (!codec->ActiveQP || !codec->coord_stored) return 0;\n\treturn (u32) ceil(log1p(codec->NumCoord) / log(2) );\n}\n\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter)\n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\nvoid gf_bifs_dec_qp14_reset(GF_BifsDecoder * codec)\n{\n\tcodec->coord_stored = GF_FALSE;\n\tcodec->storing_coord = GF_FALSE;\n\tcodec->NumCoord = 0;\n}\n\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements)\n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n\nGF_Err gf_bifs_dec_qp_set(GF_BifsDecoder *codec, GF_Node *qp)\n{\n\tassert(gf_node_get_tag(qp) == TAG_MPEG4_QuantizationParameter);\n\n\t/*if we have an active QP, push it into the stack*/\n\tif (codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) )\n\t\tgf_list_insert(codec->QPs, codec->ActiveQP, 0);\n\n\tcodec->ActiveQP = (M_QuantizationParameter *)qp;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_qp_remove(GF_BifsDecoder *codec, Bool ActivatePrev)\n{\n\tif (!codec->force_keep_qp && codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) ) {\n\t\tgf_node_unregister((GF_Node *) codec->ActiveQP, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tif (!ActivatePrev) return GF_OK;\n\n\tif (gf_list_count(codec->QPs)) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter*)gf_list_get(codec->QPs, 0);\n\t\tgf_list_rem(codec->QPs, 0);\n\t} else if (codec->scenegraph->global_qp) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter *)codec->scenegraph->global_qp;\n\t}\n\treturn GF_OK;\n}\n\n//parses efficient float\nFixed gf_bifs_dec_mantissa_float(GF_BifsDecoder *codec, GF_BitStream *bs)\n{\n\tu32 mantLength, expLength, mantSign, mantissa;\n\tunsigned char exp;\n\n\tunion {\n\t\tFloat f;\n\t\tlong l;\n\t} ft_value;\n\n\tmantLength = gf_bs_read_int(bs, 4);\n\tif (!mantLength) return 0;\n\n\texpLength = gf_bs_read_int(bs, 3);\n\tmantSign = gf_bs_read_int(bs, 1);\n\tmantissa = gf_bs_read_int(bs, mantLength - 1);\n\n\texp = 127;\n\tif (expLength) {\n\t\tu32 expSign = gf_bs_read_int(bs, 1);\n\t\tu32 exponent = gf_bs_read_int(bs, expLength-1);\n\t\texp += (1-2*expSign)*( (1 << (expLength-1) ) + exponent);\n\t}\n\n\tft_value.l = mantSign << 31;\n\tft_value.l |= (exp & 0xff) << 23;\n\tft_value.l |= mantissa << 9;\n\treturn FLT2FIX(ft_value.f);\n}\n\n//check if the quant type is on in the QP, and if so retrieves NbBits and Min Max\n//specified for the field\nBool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b_min, SFVec3f *b_max)\n{\n\tswitch (q_type) {\n\tcase QC_3DPOS:\n\t\tif (!qp->position3DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position3DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position3DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position3DMin.y);\n\t\tb_min->z = MAX(b_min->z, qp->position3DMin.z);\n\t\tb_max->x = MIN(b_max->x, qp->position3DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position3DMax.y);\n\t\tb_max->z = MIN(b_max->z, qp->position3DMax.z);\n\t\treturn GF_TRUE;\n\tcase QC_2DPOS:\n\t\tif (!qp->position2DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position2DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position2DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position2DMin.y);\n\t\tb_max->x = MIN(b_max->x, qp->position2DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position2DMax.y);\n\t\treturn GF_TRUE;\n\tcase QC_ORDER:\n\t\tif (!qp->drawOrderQuant) return GF_FALSE;\n\t\t*NbBits = qp->drawOrderNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->drawOrderMin);\n\t\tb_max->x = MIN(b_max->x, qp->drawOrderMax);\n\t\treturn GF_TRUE;\n\tcase QC_COLOR:\n\t\tif (!qp->colorQuant) return GF_FALSE;\n\t\t*NbBits = qp->colorNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->colorMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->colorMax);\n\t\treturn GF_TRUE;\n\tcase QC_TEXTURE_COORD:\n\t\tif (!qp->textureCoordinateQuant) return GF_FALSE;\n\t\t*NbBits = qp->textureCoordinateNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->textureCoordinateMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->textureCoordinateMax);\n\t\treturn GF_TRUE;\n\tcase QC_ANGLE:\n\t\tif (!qp->angleQuant) return GF_FALSE;\n\t\t*NbBits = qp->angleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->angleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->angleMax);\n\t\treturn GF_TRUE;\n\tcase QC_SCALE:\n\t\tif (!qp->scaleQuant) return GF_FALSE;\n\t\t*NbBits = qp->scaleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->scaleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->scaleMax);\n\t\treturn GF_TRUE;\n\tcase QC_INTERPOL_KEYS:\n\t\tif (!qp->keyQuant) return GF_FALSE;\n\t\t*NbBits = qp->keyNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->keyMin);\n\t\tb_min->y = MAX(b_min->y, qp->keyMin);\n\t\tb_min->z = MAX(b_min->z, qp->keyMin);\n\t\tb_max->x = MIN(b_max->x, qp->keyMax);\n\t\tb_max->y = MIN(b_max->y, qp->keyMax);\n\t\tb_max->z = MIN(b_max->z, qp->keyMax);\n\t\treturn GF_TRUE;\n\tcase QC_NORMALS:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_ROTATION:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_3D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_2D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\n\t//cf specs, from here ALWAYS ON\n\tcase QC_LINEAR_SCALAR:\n\t\t//nbBits is the one from the FCT - DO NOT CHANGE IT\n\t\treturn GF_TRUE;\n\tcase QC_COORD_INDEX:\n\t\t//nbBits has to be recomputed on the fly\n\t\treturn GF_TRUE;\n\tcase QC_RESERVED:\n\t\t*NbBits = 0;\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n\n//Linear inverse Quantization for floats\nFixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)\n{\n\tif (!value) return Min;\n\tif (value == (u32) ((1 << NbBits) - 1) ) return Max;\n\treturn Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );\n}\n\n\nGF_Err Q_DecFloat(GF_BifsDecoder *codec, GF_BitStream *bs, u32 FieldType, SFVec3f BMin, SFVec3f BMax, u32 NbBits, void *field_ptr)\n{\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field_ptr) = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec2f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->z = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field_ptr)->red = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->green = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->blue = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\n\tcase GF_SG_VRML_SFROTATION:\n\t\t//forbidden in this Q mode\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n//int in quant are either Linear Scalar fields or CoordIndex\n//the quant is just a bitshifting into [0, 2^NbBits-1]\n//so IntMin + ReadBit(NbBits) = value\nGF_Err Q_DecInt(GF_BifsDecoder *codec, GF_BitStream *bs, u32 QType, SFInt32 b_min, u32 NbBits, void *field_ptr)\n{\n\tswitch (QType) {\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\t*((SFInt32 *)field_ptr) = gf_bs_read_int(bs, NbBits) + b_min;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n//SFRotation and SFVec3f are quantized as normalized vectors ,mapped on a cube\n//in the UnitSphere (R=1.0)\nGF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}\n\n//parses a rotation\nGF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tu32 i;\n\tFixed q, sin2, comp[4];\n\tGF_Err e;\n\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 3, comp);\n\tif (e) return e;\n\n\tq = 2 * gf_acos(comp[0]);\n\tsin2 = gf_sin(q / 2);\n\n\tif (ABS(sin2) <= FIX_EPSILON) {\n\t\tfor (i=1; i<4; i++) comp[i] = 0;\n\t\tcomp[3] = FIX_ONE;\n\t} else {\n\t\tfor (i=1; i<4; i++) comp[i] = gf_divfix(comp[i], sin2);\n\t}\n\t((SFRotation *)field_ptr)->x = comp[1];\n\t((SFRotation *)field_ptr)->y = comp[2];\n\t((SFRotation *)field_ptr)->z = comp[3];\n\t((SFRotation *)field_ptr)->q = q;\n\treturn GF_OK;\n}\n\n//parses a Normal vec\nGF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tFixed comp[4];\n\tSFVec3f v;\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);\n\tif (e) return e;\n\tv.x = comp[0];\n\tv.y = comp[1];\n\tv.z = comp[2];\n\tgf_vec_norm(&v);\n\t*((SFVec3f *)field_ptr) = v;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_unquant_field(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field)\n{\n\tBool HasQ;\n\tu8 QType, AType;\n\tu32 NbBits;\n\tFixed b_min, b_max;\n\tSFVec3f BMin, BMax;\n\tGF_Err e;\n\n\t/*check QP*/\n\tif (!codec->ActiveQP) return GF_EOS;\n\t/*check FieldType*/\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_EOS;\n\t}\n\n\t/*check NDT*/\n\tHasQ = gf_bifs_get_aq_info(node, field->fieldIndex, &QType, &AType, &b_min, &b_max, &NbBits);\n\tif (!HasQ || !QType) return GF_EOS;\n\n\t/*get NbBits for QP14 (QC_COORD_INDEX)*/\n\tif (QType == QC_COORD_INDEX) {\n\t\tNbBits = gf_bifs_dec_qp14_get_bits(codec);\n\t\t/*QP14 is always on, not having NbBits set means the coord field is set after the index field, hence not decodable*/\n\t\tif (!NbBits) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tBMin.x = BMin.y = BMin.z = b_min;\n\tBMax.x = BMax.y = BMax.z = b_max;\n\n\t/*check is the QP is on and retrieves the bounds*/\n\tif (!Q_IsTypeOn(codec->ActiveQP, QType, &NbBits, &BMin, &BMax)) return GF_EOS;\n\n\t/*ok the field is Quantized, dequantize*/\n\tswitch (QType) {\n\t//these are all SFFloat quantized on n fields\n\tcase QC_3DPOS:\n\tcase QC_2DPOS:\n\tcase QC_ORDER:\n\tcase QC_COLOR:\n\tcase QC_TEXTURE_COORD:\n\tcase QC_ANGLE:\n\tcase QC_SCALE:\n\tcase QC_INTERPOL_KEYS:\n\tcase QC_SIZE_3D:\n\tcase QC_SIZE_2D:\n\t\te = Q_DecFloat(codec, bs, field->fieldType, BMin, BMax, NbBits, field->far_ptr);\n\t\tbreak;\n\t//SFInt types\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\te = Q_DecInt(codec, bs, QType, (SFInt32) b_min, NbBits, field->far_ptr);\n\t\tbreak;\n\t//normalized fields (normals and vectors)\n\tcase QC_NORMALS:\n\t\t//normal quant is only for SFVec3F\n\t\tif (field->fieldType != GF_SG_VRML_SFVEC3F) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecNormal(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tcase QC_ROTATION:\n\t\t//normal quant is only for SFRotation\n\t\tif (field->fieldType != GF_SG_VRML_SFROTATION) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecRotation(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (e) return e;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n"], "filenames": ["src/bifs/unquantize.c"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [288], "fixing_code_start_loc": [5], "fixing_code_end_loc": [288], "type": "CWE-190", "message": "Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file bifs/unquantize.c in GPAC version 2.2-rev0-gab012bbfb-master.", "other": {"cve": {"id": "CVE-2023-23144", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-20T19:15:18.333", "lastModified": "2023-05-27T04:15:24.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file bifs/unquantize.c in GPAC version 2.2-rev0-gab012bbfb-master."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.2-rev0-gab012bbfb-master:*:*:*:*:*:*:*", "matchCriteriaId": "D3076C60-CC3F-4803-A5C1-B5057607B315"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/3a2458a49b3e6399709d456d7b35e7a6f50cfb86", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/3a2458a49b3e6399709d456d7b35e7a6f50cfb86"}}