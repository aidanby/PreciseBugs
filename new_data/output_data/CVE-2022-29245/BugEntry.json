{"buggy_code": ["using System;\nusing Renci.SshNet.Abstractions;\nusing Renci.SshNet.Common;\nusing Renci.SshNet.Messages.Transport;\nusing Renci.SshNet.Security.Chaos.NaCl;\nusing Renci.SshNet.Security.Chaos.NaCl.Internal.Ed25519Ref10;\n\nnamespace Renci.SshNet.Security\n{\n    internal class KeyExchangeECCurve25519 : KeyExchangeEC\n    {\n        private byte[] _privateKey;\n\n        /// <summary>\n        /// Gets algorithm name.\n        /// </summary>\n        public override string Name\n        {\n            get { return \"curve25519-sha256\"; }\n        }\n\n        /// <summary>\n        /// Gets the size, in bits, of the computed hash code.\n        /// </summary>\n        /// <value>\n        /// The size, in bits, of the computed hash code.\n        /// </value>\n        protected override int HashSize\n        {\n            get { return 256; }\n        }\n\n        /// <summary>\n        /// Starts key exchange algorithm\n        /// </summary>\n        /// <param name=\"session\">The session.</param>\n        /// <param name=\"message\">Key exchange init message.</param>\n        public override void Start(Session session, KeyExchangeInitMessage message)\n        {\n            base.Start(session, message);\n\n            Session.RegisterMessage(\"SSH_MSG_KEX_ECDH_REPLY\");\n\n            Session.KeyExchangeEcdhReplyMessageReceived += Session_KeyExchangeEcdhReplyMessageReceived;\n\n            var basepoint = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            basepoint[0] = 9;\n\n            var rnd = new Random();\n            _privateKey = new byte[MontgomeryCurve25519.PrivateKeySizeInBytes];\n            rnd.NextBytes(_privateKey);\n\n            _clientExchangeValue = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            MontgomeryOperations.scalarmult(_clientExchangeValue, 0, _privateKey, 0, basepoint, 0);\n\n            SendMessage(new KeyExchangeEcdhInitMessage(_clientExchangeValue));\n        }\n\n        /// <summary>\n        /// Finishes key exchange algorithm.\n        /// </summary>\n        public override void Finish()\n        {\n            base.Finish();\n\n            Session.KeyExchangeEcdhReplyMessageReceived -= Session_KeyExchangeEcdhReplyMessageReceived;\n        }\n\n        /// <summary>\n        /// Hashes the specified data bytes.\n        /// </summary>\n        /// <param name=\"hashData\">The hash data.</param>\n        /// <returns>\n        /// Hashed bytes\n        /// </returns>\n        protected override byte[] Hash(byte[] hashData)\n        {\n            using (var sha256 = CryptoAbstraction.CreateSHA256())\n            {\n                return sha256.ComputeHash(hashData, 0, hashData.Length);\n            }\n        }\n\n        private void Session_KeyExchangeEcdhReplyMessageReceived(object sender, MessageEventArgs<KeyExchangeEcdhReplyMessage> e)\n        {\n            var message = e.Message;\n\n            //  Unregister message once received\n            Session.UnRegisterMessage(\"SSH_MSG_KEX_ECDH_REPLY\");\n\n            HandleServerEcdhReply(message.KS, message.QS, message.Signature);\n\n            //  When SSH_MSG_KEXDH_REPLY received key exchange is completed\n            Finish();\n        }\n\n        /// <summary>\n        /// Handles the server DH reply message.\n        /// </summary>\n        /// <param name=\"hostKey\">The host key.</param>\n        /// <param name=\"serverExchangeValue\">The server exchange value.</param>\n        /// <param name=\"signature\">The signature.</param>\n        private void HandleServerEcdhReply(byte[] hostKey, byte[] serverExchangeValue, byte[] signature)\n        {\n            _serverExchangeValue = serverExchangeValue;\n            _hostKey = hostKey;\n            _signature = signature;\n\n            var sharedKey = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            MontgomeryOperations.scalarmult(sharedKey, 0, _privateKey, 0, serverExchangeValue, 0);\n            SharedKey = sharedKey.ToBigInteger2().ToByteArray().Reverse();\n        }\n    }\n}\n"], "fixing_code": ["using System;\nusing Renci.SshNet.Abstractions;\nusing Renci.SshNet.Common;\nusing Renci.SshNet.Messages.Transport;\nusing Renci.SshNet.Security.Chaos.NaCl;\nusing Renci.SshNet.Security.Chaos.NaCl.Internal.Ed25519Ref10;\n\nnamespace Renci.SshNet.Security\n{\n    internal class KeyExchangeECCurve25519 : KeyExchangeEC\n    {\n        private byte[] _privateKey;\n\n        /// <summary>\n        /// Gets algorithm name.\n        /// </summary>\n        public override string Name\n        {\n            get { return \"curve25519-sha256\"; }\n        }\n\n        /// <summary>\n        /// Gets the size, in bits, of the computed hash code.\n        /// </summary>\n        /// <value>\n        /// The size, in bits, of the computed hash code.\n        /// </value>\n        protected override int HashSize\n        {\n            get { return 256; }\n        }\n\n        /// <summary>\n        /// Starts key exchange algorithm\n        /// </summary>\n        /// <param name=\"session\">The session.</param>\n        /// <param name=\"message\">Key exchange init message.</param>\n        public override void Start(Session session, KeyExchangeInitMessage message)\n        {\n            base.Start(session, message);\n\n            Session.RegisterMessage(\"SSH_MSG_KEX_ECDH_REPLY\");\n\n            Session.KeyExchangeEcdhReplyMessageReceived += Session_KeyExchangeEcdhReplyMessageReceived;\n\n            var basepoint = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            basepoint[0] = 9;\n\n            _privateKey = CryptoAbstraction.GenerateRandom(MontgomeryCurve25519.PrivateKeySizeInBytes);\n\n            _clientExchangeValue = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            MontgomeryOperations.scalarmult(_clientExchangeValue, 0, _privateKey, 0, basepoint, 0);\n\n            SendMessage(new KeyExchangeEcdhInitMessage(_clientExchangeValue));\n        }\n\n        /// <summary>\n        /// Finishes key exchange algorithm.\n        /// </summary>\n        public override void Finish()\n        {\n            base.Finish();\n\n            Session.KeyExchangeEcdhReplyMessageReceived -= Session_KeyExchangeEcdhReplyMessageReceived;\n        }\n\n        /// <summary>\n        /// Hashes the specified data bytes.\n        /// </summary>\n        /// <param name=\"hashData\">The hash data.</param>\n        /// <returns>\n        /// Hashed bytes\n        /// </returns>\n        protected override byte[] Hash(byte[] hashData)\n        {\n            using (var sha256 = CryptoAbstraction.CreateSHA256())\n            {\n                return sha256.ComputeHash(hashData, 0, hashData.Length);\n            }\n        }\n\n        private void Session_KeyExchangeEcdhReplyMessageReceived(object sender, MessageEventArgs<KeyExchangeEcdhReplyMessage> e)\n        {\n            var message = e.Message;\n\n            //  Unregister message once received\n            Session.UnRegisterMessage(\"SSH_MSG_KEX_ECDH_REPLY\");\n\n            HandleServerEcdhReply(message.KS, message.QS, message.Signature);\n\n            //  When SSH_MSG_KEXDH_REPLY received key exchange is completed\n            Finish();\n        }\n\n        /// <summary>\n        /// Handles the server DH reply message.\n        /// </summary>\n        /// <param name=\"hostKey\">The host key.</param>\n        /// <param name=\"serverExchangeValue\">The server exchange value.</param>\n        /// <param name=\"signature\">The signature.</param>\n        private void HandleServerEcdhReply(byte[] hostKey, byte[] serverExchangeValue, byte[] signature)\n        {\n            _serverExchangeValue = serverExchangeValue;\n            _hostKey = hostKey;\n            _signature = signature;\n\n            var sharedKey = new byte[MontgomeryCurve25519.PublicKeySizeInBytes];\n            MontgomeryOperations.scalarmult(sharedKey, 0, _privateKey, 0, serverExchangeValue, 0);\n            SharedKey = sharedKey.ToBigInteger2().ToByteArray().Reverse();\n        }\n    }\n}\n"], "filenames": ["src/Renci.SshNet/Security/KeyExchangeECCurve25519.cs"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [52], "fixing_code_start_loc": [49], "fixing_code_end_loc": [50], "type": "CWE-338", "message": "SSH.NET is a Secure Shell (SSH) library for .NET. In versions 2020.0.0 and 2020.0.1, during an `X25519` key exchange, the client\u00e2\u20ac\u2122s private key is generated with `System.Random`. `System.Random` is not a cryptographically secure random number generator, it must therefore not be used for cryptographic purposes. When establishing an SSH connection to a remote host, during the X25519 key exchange, the private key is generated with a weak random number generator whose seed can be brute forced. This allows an attacker who is able to eavesdrop on the communications to decrypt them. Version 2020.0.2 contains a patch for this issue. As a workaround, one may disable support for `curve25519-sha256` and `curve25519-sha256@libssh.org` key exchange algorithms.", "other": {"cve": {"id": "CVE-2022-29245", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-31T17:15:07.837", "lastModified": "2022-06-14T22:39:27.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SSH.NET is a Secure Shell (SSH) library for .NET. In versions 2020.0.0 and 2020.0.1, during an `X25519` key exchange, the client\u00e2\u20ac\u2122s private key is generated with `System.Random`. `System.Random` is not a cryptographically secure random number generator, it must therefore not be used for cryptographic purposes. When establishing an SSH connection to a remote host, during the X25519 key exchange, the private key is generated with a weak random number generator whose seed can be brute forced. This allows an attacker who is able to eavesdrop on the communications to decrypt them. Version 2020.0.2 contains a patch for this issue. As a workaround, one may disable support for `curve25519-sha256` and `curve25519-sha256@libssh.org` key exchange algorithms."}, {"lang": "es", "value": "SSH.NET es una biblioteca de Secure Shell (SSH) para .NET. En versiones 2020.0.0 y 2020.0.1, durante un intercambio de claves \"X25519\", la clave privada del cliente se genera con \"System.Random\". \"System.Random\" no es un generador de n\u00fameros aleatorios criptogr\u00e1ficamente seguro, por lo que no debe ser usado con fines criptogr\u00e1ficos. Cuando es establecida una conexi\u00f3n SSH con un host remoto, durante el intercambio de claves X25519, la clave privada es generada con un generador de n\u00fameros aleatorios d\u00e9bil cuya semilla puede ser forzada. Esto permite que un atacante que sea capaz de espiar las comunicaciones las descifre. La versi\u00f3n 2020.0.2 contiene un parche para este problema. Como mitigaci\u00f3n, puede deshabilitarse el soporte para los algoritmos de intercambio de claves \"curve25519-sha256\" y \"curve25519-sha256@libssh.org\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ssh.net_project:ssh.net:2020.0.0:-:*:*:*:.net:*:*", "matchCriteriaId": "FFDC66EC-7329-4E57-BBE8-EE775C4EBF63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ssh.net_project:ssh.net:2020.0.0:beta1:*:*:*:.net:*:*", "matchCriteriaId": "882F0E06-ED64-4064-9B0F-C26AC60245D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ssh.net_project:ssh.net:2020.0.1:*:*:*:*:.net:*:*", "matchCriteriaId": "04838499-F443-440E-912C-EB9E7BE26D25"}]}]}], "references": [{"url": "https://github.com/sshnet/SSH.NET/blob/bc99ada7da3f05f50d9379f2644941d91d5bf05a/src/Renci.SshNet/Security/KeyExchangeECCurve25519.cs#L51", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sshnet/SSH.NET/commit/03c6d60736b8f7b42e44d6989a53f9b644a091fb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sshnet/SSH.NET/releases/tag/2020.0.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/sshnet/SSH.NET/security/advisories/GHSA-72p8-v4hg-v45p", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sshnet/SSH.NET/commit/03c6d60736b8f7b42e44d6989a53f9b644a091fb"}}