{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.rdp\")\n\nconst char* DATA_PDU_TYPE_STRINGS[80] = {\n\t\"?\",\n\t\"?\",      /* 0x00 - 0x01 */\n\t\"Update\", /* 0x02 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\", /* 0x03 - 0x0A */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x0B - 0x13 */\n\t\"Control\", /* 0x14 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x15 - 0x1A */\n\t\"Pointer\", /* 0x1B */\n\t\"Input\",   /* 0x1C */\n\t\"?\",\n\t\"?\",                            /* 0x1D - 0x1E */\n\t\"Synchronize\",                  /* 0x1F */\n\t\"?\",                            /* 0x20 */\n\t\"Refresh Rect\",                 /* 0x21 */\n\t\"Play Sound\",                   /* 0x22 */\n\t\"Suppress Output\",              /* 0x23 */\n\t\"Shutdown Request\",             /* 0x24 */\n\t\"Shutdown Denied\",              /* 0x25 */\n\t\"Save Session Info\",            /* 0x26 */\n\t\"Font List\",                    /* 0x27 */\n\t\"Font Map\",                     /* 0x28 */\n\t\"Set Keyboard Indicators\",      /* 0x29 */\n\t\"?\",                            /* 0x2A */\n\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\"Bitmap Cache Error\",           /* 0x2C */\n\t\"Set Keyboard IME Status\",      /* 0x2D */\n\t\"Offscreen Cache Error\",        /* 0x2E */\n\t\"Set Error Info\",               /* 0x2F */\n\t\"Draw Nine Grid Error\",         /* 0x30 */\n\t\"Draw GDI+ Error\",              /* 0x31 */\n\t\"ARC Status\",                   /* 0x32 */\n\t\"?\",\n\t\"?\",\n\t\"?\",              /* 0x33 - 0x35 */\n\t\"Status Info\",    /* 0x36 */\n\t\"Monitor Layout\", /* 0x37 */\n\t\"FrameAcknowledge\",\n\t\"?\",\n\t\"?\", /* 0x38 - 0x40 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\" /* 0x41 - 0x46 */\n};\n\nstatic void rdp_read_flow_control_pdu(wStream* s, UINT16* type);\nstatic void rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type,\n                                           UINT16 channel_id);\nstatic void rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id);\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length)\n{\n\t/* Basic Security Header */\n\tif ((Stream_GetRemainingLength(s) < 4) || (length && (*length < 4)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *flags); /* flags */\n\tStream_Seek(s, 2);             /* flagsHi (unused) */\n\n\tif (length)\n\t\t*length -= 4;\n\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(wStream* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tStream_Write_UINT16(s, flags); /* flags */\n\tStream_Write_UINT16(s, 0);     /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, *length); /* totalLength */\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\t/* Share Control Header */\n\tStream_Write_UINT16(s, length);      /* totalLength */\n\tStream_Write_UINT16(s, type | 0x10); /* pduType */\n\tStream_Write_UINT16(s, channel_id);  /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type, UINT32* shareId,\n                                BYTE* compressedType, UINT16* compressedLength)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tStream_Read_UINT32(s, *shareId);          /* shareId (4 bytes) */\n\tStream_Seek_UINT8(s);                     /* pad1 (1 byte) */\n\tStream_Seek_UINT8(s);                     /* streamId (1 byte) */\n\tStream_Read_UINT16(s, *length);           /* uncompressedLength (2 bytes) */\n\tStream_Read_UINT8(s, *type);              /* pduType2, Data PDU Type (1 byte) */\n\tStream_Read_UINT8(s, *compressedType);    /* compressedType (1 byte) */\n\tStream_Read_UINT16(s, *compressedLength); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\t/* Share Data Header */\n\tStream_Write_UINT32(s, share_id);  /* shareId (4 bytes) */\n\tStream_Write_UINT8(s, 0);          /* pad1 (1 byte) */\n\tStream_Write_UINT8(s, STREAM_LOW); /* streamId (1 byte) */\n\tStream_Write_UINT16(s, length);    /* uncompressedLength (2 bytes) */\n\tStream_Write_UINT8(s, type);       /* pduType2, Data PDU Type (1 byte) */\n\tStream_Write_UINT8(s, 0);          /* compressedType (1 byte) */\n\tStream_Write_UINT16(s, 0);         /* compressedLength (2 bytes) */\n}\n\nstatic BOOL rdp_security_stream_init(rdpRdp* rdp, wStream* s, BOOL sec_header)\n{\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tif (rdp->do_crypt)\n\t{\n\t\tif (!Stream_SafeSeek(s, 12))\n\t\t\treturn FALSE;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t{\n\t\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_header)\n\t{\n\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_send_stream_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, FALSE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_send_stream_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_CONTROL_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_DATA_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo)\n{\n\trdp->errorInfo = errorInfo;\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t{\n\t\trdpContext* context = rdp->context;\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\t\tif (context)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, MAKE_FREERDP_ERROR(ERRINFO, errorInfo));\n\n\t\t\tif (context->pubSub)\n\t\t\t{\n\t\t\t\tErrorInfoEventArgs e;\n\t\t\t\tEventArgsInit(&e, \"freerdp\");\n\t\t\t\te.code = rdp->errorInfo;\n\t\t\t\tPubSub_OnErrorInfo(context->pubSub, context, &e);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tWLog_ERR(TAG, \"%s missing context=%p\", __FUNCTION__, context);\n\t}\n\telse\n\t{\n\t\tfreerdp_set_last_error_log(rdp->context, FREERDP_ERROR_SUCCESS);\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_message_channel_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, TRUE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channelId)\n{\n\tBYTE li;\n\tBYTE byte;\n\tBYTE code;\n\tBYTE choice;\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\tenum DomainMCSPDU domainMCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest\n\t                                     : DomainMCSPDU_SendDataIndication;\n\n\tif (!tpkt_read_header(s, length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_header(s, &code, &li, *length))\n\t\treturn FALSE;\n\n\tif (code != X224_TPDU_DATA)\n\t{\n\t\tif (code == X224_TPDU_DISCONNECT_REQUEST)\n\t\t{\n\t\t\tfreerdp_abort_connect(rdp->instance);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tdomainMCSPDU = (enum DomainMCSPDU)(choice >> 2);\n\n\tif (domainMCSPDU != MCSPDU)\n\t{\n\t\tif (domainMCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tMCSPDU = domainMCSPDU;\n\n\tif (*length < 8U)\n\t\treturn FALSE;\n\n\tif ((*length - 8U) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tint reason = 0;\n\t\tTerminateEventArgs e;\n\t\trdpContext* context;\n\n\t\tif (!mcs_recv_disconnect_provider_ultimatum(rdp->mcs, s, &reason))\n\t\t\treturn FALSE;\n\n\t\tif (!rdp->instance)\n\t\t\treturn FALSE;\n\n\t\tcontext = rdp->instance->context;\n\t\tcontext->disconnectUltimatum = reason;\n\n\t\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\t{\n\t\t\t/**\n\t\t\t * Some servers like Windows Server 2008 R2 do not send the error info pdu\n\t\t\t * when the user logs off like they should. Map DisconnectProviderUltimatum\n\t\t\t * to a ERRINFO_LOGOFF_BY_USER when the errinfo code is ERRINFO_SUCCESS.\n\t\t\t */\n\t\t\tif (reason == Disconnect_Ultimatum_provider_initiated)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t\telse if (reason == Disconnect_Ultimatum_user_requested)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_LOGOFF_BY_USER);\n\t\t\telse\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t}\n\n\t\tWLog_DBG(TAG, \"DisconnectProviderUltimatum: reason: %d\", reason);\n\t\tfreerdp_abort_connect(rdp->instance);\n\t\tEventArgsInit(&e, \"freerdp\");\n\t\te.code = 0;\n\t\tPubSub_OnTerminate(context->pubSub, context, &e);\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID)) /* initiator (UserId) */\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, channelId, 0)) /* channelId */\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte); /* dataPriority + Segmentation (0x70) */\n\n\tif (!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\n\tif (*length > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channelId)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication\n\t                                     : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) &&\n\t    (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->userId, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channelId, 0);                          /* channelId */\n\tStream_Write_UINT8(s, 0x70);                                   /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, even though we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tStream_Write_UINT16_BE(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic BOOL rdp_security_stream_out(rdpRdp* rdp, wStream* s, int length, UINT32 sec_flags,\n                                    UINT32* pad)\n{\n\tBYTE* data;\n\tBOOL status;\n\tsec_flags |= rdp->sec_flags;\n\t*pad = 0;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 12;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\t\t\t\tStream_Write_UINT16(s, 0x10); /* length */\n\t\t\t\tStream_Write_UINT8(s, 0x1);   /* TSFIPS_VERSION 1*/\n\t\t\t\t/* handle padding */\n\t\t\t\t*pad = 8 - (length % 8);\n\n\t\t\t\tif (*pad == 8)\n\t\t\t\t\t*pad = 0;\n\n\t\t\t\tif (*pad)\n\t\t\t\t\tmemset(data + length, 0, *pad);\n\n\t\t\t\tStream_Write_UINT8(s, *pad);\n\n\t\t\t\tif (!security_hmac_signature(data, length, Stream_Pointer(s), rdp))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + *pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 8;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tstatus =\n\t\t\t\t\t    security_salted_mac_signature(rdp, data, length, TRUE, Stream_Pointer(s));\n\t\t\t\telse\n\t\t\t\t\tstatus = security_mac_signature(rdp, data, length, Stream_Pointer(s));\n\n\t\t\t\tif (!status)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\n\t\t\t\tif (!security_encrypt(Stream_Pointer(s), length, rdp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn TRUE;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp, UINT16 sec_flags)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tUINT32 pad;\n\tUINT16 length;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\treturn FALSE;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\tWLog_DBG(TAG, \"%s: sending data (type=0x%x size=%\" PRIuz \" channelId=%\" PRIu16 \")\",\n\t         __FUNCTION__, type, Stream_Length(s), channel_id);\n\n\trdp->outPackets++;\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags)\n{\n\tBOOL rc = FALSE;\n\tUINT16 length;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, rdp->mcs->messageChannelId);\n\n\tif (!rdp_security_stream_out(rdp, s, length, sec_flags, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nstatic BOOL rdp_recv_server_shutdown_denied_pdu(rdpRdp* rdp, wStream* s)\n{\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_indicators_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT16 ledFlags;\n\trdpContext* context = rdp->instance->context;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);   /* unitId (2 bytes) */\n\tStream_Read_UINT16(s, ledFlags); /* ledFlags (2 bytes) */\n\tIFCALL(context->update->SetKeyboardIndicators, context, ledFlags);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_ime_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT32 imeState;\n\tUINT32 imeConvMode;\n\n\tif (!rdp || !rdp->input)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);      /* unitId (2 bytes) */\n\tStream_Read_UINT32(s, imeState);    /* imeState (4 bytes) */\n\tStream_Read_UINT32(s, imeConvMode); /* imeConvMode (4 bytes) */\n\tIFCALL(rdp->update->SetKeyboardImeStatus, rdp->context, unitId, imeState, imeConvMode);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 errorInfo;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, errorInfo); /* errorInfo (4 bytes) */\n\treturn rdp_set_error_info(rdp, errorInfo);\n}\n\nstatic BOOL rdp_recv_server_auto_reconnect_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 arcStatus;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, arcStatus); /* arcStatus (4 bytes) */\n\tWLog_WARN(TAG, \"AutoReconnectStatus: 0x%08\" PRIX32 \"\", arcStatus);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_status_info_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 statusCode;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, statusCode); /* statusCode (4 bytes) */\n\n\tif (rdp->update->ServerStatusInfo)\n\t\treturn rdp->update->ServerStatusInfo(rdp->context, statusCode);\n\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_monitor_layout_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 index;\n\tUINT32 monitorCount;\n\tMONITOR_DEF* monitor;\n\tMONITOR_DEF* monitorDefArray;\n\tBOOL ret = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount (4 bytes) */\n\n\tif ((Stream_GetRemainingLength(s) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tmonitorDefArray = (MONITOR_DEF*)calloc(monitorCount, sizeof(MONITOR_DEF));\n\n\tif (!monitorDefArray)\n\t\treturn FALSE;\n\n\tfor (monitor = monitorDefArray, index = 0; index < monitorCount; index++, monitor++)\n\t{\n\t\tStream_Read_UINT32(s, monitor->left);   /* left (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->top);    /* top (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->right);  /* right (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->bottom); /* bottom (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->flags);  /* flags (4 bytes) */\n\t}\n\n\tIFCALLRET(rdp->update->RemoteMonitors, ret, rdp->context, monitorCount, monitorDefArray);\n\tfree(monitorDefArray);\n\treturn ret;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tBYTE type;\n\twStream* cs;\n\tUINT16 length;\n\tUINT32 shareId;\n\tBYTE compressedType;\n\tUINT16 compressedLength;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &shareId, &compressedType,\n\t                                &compressedLength))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_data_header() failed\");\n\t\treturn -1;\n\t}\n\n\tcs = s;\n\n\tif (compressedType & PACKET_COMPRESSED)\n\t{\n\t\tUINT32 DstSize = 0;\n\t\tBYTE* pDstData = NULL;\n\t\tUINT16 SrcSize = compressedLength - 18;\n\n\t\tif ((compressedLength < 18) || (Stream_GetRemainingLength(s) < SrcSize))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress: not enough bytes for compressedLength %\" PRIu16 \"\",\n\t\t\t         compressedLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (bulk_decompress(rdp->bulk, Stream_Pointer(s), SrcSize, &pDstData, &DstSize,\n\t\t                    compressedType))\n\t\t{\n\t\t\tif (!(cs = StreamPool_Take(rdp->transport->ReceivePool, DstSize)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Couldn't take stream from pool\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tStream_SetPosition(cs, 0);\n\t\t\tStream_Write(cs, pDstData, DstSize);\n\t\t\tStream_SealLength(cs);\n\t\t\tStream_SetPosition(cs, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Seek(s, SrcSize);\n\t}\n\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_UPDATE - update_recv() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_CONTROL - rdp_recv_server_control_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_POINTER - update_recv_pointer() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SYNCHRONIZE - rdp_recv_synchronize_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_PLAY_SOUND - update_recv_play_sound() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tif (!rdp_recv_server_shutdown_denied_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SHUTDOWN_DENIED - rdp_recv_server_shutdown_denied_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif (!rdp_recv_save_session_info(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_SAVE_SESSION_INFO - rdp_recv_save_session_info() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif (!rdp_recv_font_map_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_FONT_MAP - rdp_recv_font_map_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tif (!rdp_recv_server_set_keyboard_indicators_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_indicators_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tif (!rdp_recv_server_set_keyboard_ime_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_ime_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SET_ERROR_INFO - rdp_recv_set_error_info_data_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tif (!rdp_recv_server_auto_reconnect_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_ARC_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_auto_reconnect_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tif (!rdp_recv_server_status_info_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_STATUS_INFO - rdp_recv_server_status_info_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tif (!rdp_recv_monitor_layout_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_MONITOR_LAYOUT - rdp_recv_monitor_layout_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn 0;\nout_fail:\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn -1;\n}\n\nint rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags)\n{\n\tif (securityFlags & SEC_AUTODETECT_REQ)\n\t{\n\t\t/* Server Auto-Detect Request PDU */\n\t\treturn rdp_recv_autodetect_request_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_AUTODETECT_RSP)\n\t{\n\t\t/* Client Auto-Detect Response PDU */\n\t\treturn rdp_recv_autodetect_response_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_HEARTBEAT)\n\t{\n\t\t/* Heartbeat PDU */\n\t\treturn rdp_recv_heartbeat_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_TRANSPORT_REQ)\n\t{\n\t\t/* Initiate Multitransport Request PDU */\n\t\treturn rdp_recv_multitransport_packet(rdp, s);\n\t}\n\n\treturn -1;\n}\n\nint rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, &type, &channelId))\n\t\treturn -1;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn rdp_recv_data_pdu(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_FLOW_RESPONSE || type == PDU_TYPE_FLOW_STOP ||\n\t         type == PDU_TYPE_FLOW_TEST)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nvoid rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);  /* pad8bits */\n\tStream_Seek_UINT8(s);  /* flowIdentifier */\n\tStream_Seek_UINT8(s);  /* flowNumber */\n\tStream_Seek_UINT16(s); /* pduSource */\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tBOOL status;\n\tINT32 length;\n\n\tif (!rdp || !s || !pLength)\n\t\treturn FALSE;\n\n\tlength = *pLength;\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tINT64 padLength;\n\n\t\tif (Stream_GetRemainingLength(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, len);    /* 0x10 */\n\t\tStream_Read_UINT8(s, version); /* 0x1 */\n\t\tStream_Read_UINT8(s, pad);\n\t\tsig = Stream_Pointer(s);\n\t\tStream_Seek(s, 8); /* signature */\n\t\tlength -= 12;\n\t\tpadLength = length - pad;\n\n\t\tif ((length <= 0) || (padLength <= 0))\n\t\t\treturn FALSE;\n\n\t\tif (!security_fips_decrypt(Stream_Pointer(s), length, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: cannot decrypt\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(Stream_Pointer(s), length - pad, sig, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: invalid packet signature\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tStream_SetLength(s, Stream_Length(s) - pad);\n\t\t*pLength = padLength;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < sizeof(wmac))\n\t\treturn FALSE;\n\n\tStream_Read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\n\tif (length <= 0)\n\t\treturn FALSE;\n\n\tif (!security_decrypt(Stream_Pointer(s), length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tstatus = security_salted_mac_signature(rdp, Stream_Pointer(s), length, FALSE, cmac);\n\telse\n\t\tstatus = security_mac_signature(rdp, Stream_Pointer(s), length, cmac);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"WARNING: invalid packet signature\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t// return FALSE;\n\t}\n\n\t*pLength = length;\n\treturn TRUE;\n}\n\nstatic const char* pdu_type_to_str(UINT16 pduType)\n{\n\tstatic char buffer[1024] = { 0 };\n\tswitch (pduType)\n\t{\n\t\tcase PDU_TYPE_DEMAND_ACTIVE:\n\t\t\treturn \"PDU_TYPE_DEMAND_ACTIVE\";\n\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\treturn \"PDU_TYPE_CONFIRM_ACTIVE\";\n\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\treturn \"PDU_TYPE_DEACTIVATE_ALL\";\n\t\tcase PDU_TYPE_DATA:\n\t\t\treturn \"PDU_TYPE_DATA\";\n\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\treturn \"PDU_TYPE_SERVER_REDIRECTION\";\n\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\treturn \"PDU_TYPE_FLOW_TEST\";\n\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\treturn \"PDU_TYPE_FLOW_RESPONSE\";\n\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\treturn \"PDU_TYPE_FLOW_STOP\";\n\t\tdefault:\n\t\t\t_snprintf(buffer, sizeof(buffer), \"UNKNOWN %04\" PRIx16, pduType);\n\t\t\treturn buffer;\n\t}\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, wStream* s)\n{\n\tint rc = 0;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId = 0;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_security_header() fail\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\tStream_Rewind(s, 2);\n\t\t\trdp->inPackets++;\n\n\t\t\trc = rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\twhile (Stream_GetRemainingLength(s) > 3)\n\t\t{\n\t\t\tsize_t startheader, endheader, start, end, diff, headerdiff;\n\n\t\t\tstartheader = Stream_GetPosition(s);\n\t\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() fail\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart = endheader = Stream_GetPosition(s);\n\t\t\theaderdiff = endheader - startheader;\n\t\t\tif (pduLength < headerdiff)\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() invalid pduLength %\" PRIu16,\n\t\t\t\t    pduLength);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpduLength -= headerdiff;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\t\t\trdp->inPackets++;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\trc = rdp_recv_data_pdu(rdp, s);\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, s))\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_recv_deactivate_all() fail\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\n\t\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\t\tWLog_DBG(TAG, \"flow message 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\t/* http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\t\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"incorrect PDU type: 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tend = Stream_GetPosition(s);\n\t\t\tdiff = end - start;\n\t\t\tif (diff != pduLength)\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG,\n\t\t\t\t          \"pduType %s not properly parsed, %\" PRIdz\n\t\t\t\t          \" bytes remaining unhandled. Skipping.\",\n\t\t\t\t          pdu_type_to_str(pduType), diff);\n\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rdp->mcs->messageChannelId && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\t\trdp->inPackets++;\n\t\trc = rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\trdp->inPackets++;\n\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId, length))\n\t\t\treturn -1;\n\t}\n\nout:\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn rc;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: fastpath_read_header_rdp() fail\");\n\t\treturn -1;\n\t}\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags =\n\t\t    (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, &length, flags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: rdp_decrypt() fail\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\nint rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*)extra;\n\n\t/*\n\t * At any point in the connection sequence between when all\n\t * MCS channels have been joined and when the RDP connection\n\t * enters the active state, an auto-detect PDU can be received\n\t * on the MCS message channel.\n\t */\n\tif ((rdp->state > CONNECTION_STATE_MCS_CHANNEL_JOIN) && (rdp->state < CONNECTION_STATE_ACTIVE))\n\t{\n\t\tif (rdp_client_connect_auto_detect(rdp, s))\n\t\t\treturn 0;\n\t}\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NLA:\n\t\t\tif (nla_get_state(rdp->nla) < NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\tif (nla_recv_pdu(rdp->nla, s) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nla_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (nla_get_state(rdp->nla) == NLA_STATE_POST_NEGO)\n\t\t\t{\n\t\t\t\tnego_recv(rdp->transport, s, (void*)rdp->nego);\n\n\t\t\t\tif (nego_get_state(rdp->nego) != NEGO_STATE_FINAL)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nego_recv() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\ttransport_set_nla_mode(rdp->transport, FALSE);\n\n\t\t\t\tif (rdp->settings->VmConnectMode)\n\t\t\t\t{\n\t\t\t\t\tif (!nego_set_state(rdp->nego, NEGO_STATE_NLA))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tif (!nego_set_requested_protocols(rdp->nego, PROTOCOL_HYBRID | PROTOCOL_SSL))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tnego_send_negotiation_request(rdp->nego);\n\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_POST_NEGO))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_FINAL)\n\t\t\t{\n\t\t\t\tnla_free(rdp->nla);\n\t\t\t\trdp->nla = NULL;\n\n\t\t\t\tif (!mcs_client_begin(rdp->mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - mcs_client_begin() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!mcs_recv_connect_response(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_connect_response failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_erect_domain_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_erect_domain_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_attach_user_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_attach_user_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_ATTACH_USER);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!mcs_recv_attach_user_confirm(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_attach_user_confirm failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_channel_join_request(rdp->mcs, rdp->mcs->userId))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_channel_join_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_CHANNEL_JOIN);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_mcs_channel_join_confirm() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\tstatus = -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t\tstatus = rdp_client_connect_license(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_client_connect_license() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tstatus = rdp_client_connect_demand_active(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_demand_active() - %i\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t{\n\t\t\t\tActivatedEventArgs activatedEvent;\n\t\t\t\trdpContext* context = rdp->context;\n\t\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_ACTIVE);\n\t\t\t\tEventArgsInit(&activatedEvent, \"libfreerdp\");\n\t\t\t\tactivatedEvent.firstActivation = !rdp->deactivation_reactivation;\n\t\t\t\tPubSub_OnActivated(context->pubSub, context, &activatedEvent);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s: %s state %d\", __FUNCTION__,\n\t\t\t         rdp_server_connection_state_string(rdp->state), rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nBOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)\n{\n\treturn freerdp_channel_send(rdp, channelId, data, size);\n}\n\nBOOL rdp_send_error_info(rdpRdp* rdp)\n{\n\twStream* s;\n\tBOOL status;\n\n\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\treturn TRUE;\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, rdp->errorInfo); /* error id (4 bytes) */\n\tstatus = rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_ERROR_INFO, 0);\n\treturn status;\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\tint status;\n\trdpTransport* transport = rdp->transport;\n\n\tif (transport->tsg)\n\t{\n\t\trdpTsg* tsg = transport->tsg;\n\n\t\tif (!tsg_check_event_handles(tsg))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_check_fds: tsg_check_event_handles()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (tsg_get_state(tsg) != TSG_STATE_PIPE_CREATED)\n\t\t\treturn 1;\n\t}\n\n\tstatus = transport_check_fds(transport);\n\n\tif (status == 1)\n\t{\n\t\tif (!rdp_client_redirect(rdp)) /* session redirection */\n\t\t\treturn -1;\n\t}\n\n\tif (status < 0)\n\t\tWLog_DBG(TAG, \"transport_check_fds() - %i\", status);\n\n\treturn status;\n}\n\nBOOL freerdp_get_stats(rdpRdp* rdp, UINT64* inBytes, UINT64* outBytes, UINT64* inPackets,\n                       UINT64* outPackets)\n{\n\tif (!rdp)\n\t\treturn FALSE;\n\n\tif (inBytes)\n\t\t*inBytes = rdp->inBytes;\n\tif (outBytes)\n\t\t*outBytes = rdp->outBytes;\n\tif (inPackets)\n\t\t*inPackets = rdp->inPackets;\n\tif (outPackets)\n\t\t*outPackets = rdp->outPackets;\n\n\treturn TRUE;\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(rdpContext* context)\n{\n\trdpRdp* rdp;\n\tDWORD flags;\n\tBOOL newSettings = FALSE;\n\trdp = (rdpRdp*)calloc(1, sizeof(rdpRdp));\n\n\tif (!rdp)\n\t\treturn NULL;\n\n\trdp->context = context;\n\trdp->instance = context->instance;\n\tflags = 0;\n\n\tif (context->ServerMode)\n\t\tflags |= FREERDP_SETTINGS_SERVER_MODE;\n\n\tif (!context->settings)\n\t{\n\t\tcontext->settings = freerdp_settings_new(flags);\n\n\t\tif (!context->settings)\n\t\t\tgoto out_free;\n\n\t\tnewSettings = TRUE;\n\t}\n\n\trdp->settings = context->settings;\n\n\tif (context->instance)\n\t{\n\t\trdp->settings->instance = context->instance;\n\t\tcontext->instance->settings = rdp->settings;\n\t}\n\telse if (context->peer)\n\t{\n\t\trdp->settings->instance = context->peer;\n\t\tcontext->peer->settings = rdp->settings;\n\t}\n\n\trdp->transport = transport_new(context);\n\n\tif (!rdp->transport)\n\t\tgoto out_free_settings;\n\n\trdp->license = license_new(rdp);\n\n\tif (!rdp->license)\n\t\tgoto out_free_transport;\n\n\trdp->input = input_new(rdp);\n\n\tif (!rdp->input)\n\t\tgoto out_free_license;\n\n\trdp->update = update_new(rdp);\n\n\tif (!rdp->update)\n\t\tgoto out_free_input;\n\n\trdp->fastpath = fastpath_new(rdp);\n\n\tif (!rdp->fastpath)\n\t\tgoto out_free_update;\n\n\trdp->nego = nego_new(rdp->transport);\n\n\tif (!rdp->nego)\n\t\tgoto out_free_fastpath;\n\n\trdp->mcs = mcs_new(rdp->transport);\n\n\tif (!rdp->mcs)\n\t\tgoto out_free_nego;\n\n\trdp->redirection = redirection_new();\n\n\tif (!rdp->redirection)\n\t\tgoto out_free_mcs;\n\n\trdp->autodetect = autodetect_new();\n\n\tif (!rdp->autodetect)\n\t\tgoto out_free_redirection;\n\n\trdp->heartbeat = heartbeat_new();\n\n\tif (!rdp->heartbeat)\n\t\tgoto out_free_autodetect;\n\n\trdp->multitransport = multitransport_new();\n\n\tif (!rdp->multitransport)\n\t\tgoto out_free_heartbeat;\n\n\trdp->bulk = bulk_new(context);\n\n\tif (!rdp->bulk)\n\t\tgoto out_free_multitransport;\n\n\treturn rdp;\nout_free_multitransport:\n\tmultitransport_free(rdp->multitransport);\nout_free_heartbeat:\n\theartbeat_free(rdp->heartbeat);\nout_free_autodetect:\n\tautodetect_free(rdp->autodetect);\nout_free_redirection:\n\tredirection_free(rdp->redirection);\nout_free_mcs:\n\tmcs_free(rdp->mcs);\nout_free_nego:\n\tnego_free(rdp->nego);\nout_free_fastpath:\n\tfastpath_free(rdp->fastpath);\nout_free_update:\n\tupdate_free(rdp->update);\nout_free_input:\n\tinput_free(rdp->input);\nout_free_license:\n\tlicense_free(rdp->license);\nout_free_transport:\n\ttransport_free(rdp->transport);\nout_free_settings:\n\n\tif (newSettings)\n\t\tfreerdp_settings_free(rdp->settings);\n\nout_free:\n\tfree(rdp);\n\treturn NULL;\n}\n\nvoid rdp_reset(rdpRdp* rdp)\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tcontext = rdp->context;\n\tsettings = rdp->settings;\n\tbulk_reset(rdp->bulk);\n\n\tif (rdp->rc4_decrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = NULL;\n\t}\n\n\tif (rdp->rc4_encrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = NULL;\n\t}\n\n\tif (rdp->fips_encrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\trdp->fips_encrypt = NULL;\n\t}\n\n\tif (rdp->fips_decrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\trdp->fips_decrypt = NULL;\n\t}\n\n\tif (settings->ServerRandom)\n\t{\n\t\tfree(settings->ServerRandom);\n\t\tsettings->ServerRandom = NULL;\n\t\tsettings->ServerRandomLength = 0;\n\t}\n\n\tif (settings->ServerCertificate)\n\t{\n\t\tfree(settings->ServerCertificate);\n\t\tsettings->ServerCertificate = NULL;\n\t}\n\n\tif (settings->ClientAddress)\n\t{\n\t\tfree(settings->ClientAddress);\n\t\tsettings->ClientAddress = NULL;\n\t}\n\n\tmcs_free(rdp->mcs);\n\tnego_free(rdp->nego);\n\tlicense_free(rdp->license);\n\ttransport_free(rdp->transport);\n\tfastpath_free(rdp->fastpath);\n\trdp->transport = transport_new(context);\n\trdp->license = license_new(rdp);\n\trdp->nego = nego_new(rdp->transport);\n\trdp->mcs = mcs_new(rdp->transport);\n\trdp->fastpath = fastpath_new(rdp);\n\trdp->transport->layer = TRANSPORT_LAYER_TCP;\n\trdp->errorInfo = 0;\n\trdp->deactivation_reactivation = 0;\n\trdp->finalize_sc_pdus = 0;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tnla_free(rdp->nla);\n\t\tredirection_free(rdp->redirection);\n\t\tautodetect_free(rdp->autodetect);\n\t\theartbeat_free(rdp->heartbeat);\n\t\tmultitransport_free(rdp->multitransport);\n\t\tbulk_free(rdp->bulk);\n\t\tfree(rdp);\n\t}\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.rdp\")\n\nconst char* DATA_PDU_TYPE_STRINGS[80] = {\n\t\"?\",\n\t\"?\",      /* 0x00 - 0x01 */\n\t\"Update\", /* 0x02 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\", /* 0x03 - 0x0A */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x0B - 0x13 */\n\t\"Control\", /* 0x14 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x15 - 0x1A */\n\t\"Pointer\", /* 0x1B */\n\t\"Input\",   /* 0x1C */\n\t\"?\",\n\t\"?\",                            /* 0x1D - 0x1E */\n\t\"Synchronize\",                  /* 0x1F */\n\t\"?\",                            /* 0x20 */\n\t\"Refresh Rect\",                 /* 0x21 */\n\t\"Play Sound\",                   /* 0x22 */\n\t\"Suppress Output\",              /* 0x23 */\n\t\"Shutdown Request\",             /* 0x24 */\n\t\"Shutdown Denied\",              /* 0x25 */\n\t\"Save Session Info\",            /* 0x26 */\n\t\"Font List\",                    /* 0x27 */\n\t\"Font Map\",                     /* 0x28 */\n\t\"Set Keyboard Indicators\",      /* 0x29 */\n\t\"?\",                            /* 0x2A */\n\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\"Bitmap Cache Error\",           /* 0x2C */\n\t\"Set Keyboard IME Status\",      /* 0x2D */\n\t\"Offscreen Cache Error\",        /* 0x2E */\n\t\"Set Error Info\",               /* 0x2F */\n\t\"Draw Nine Grid Error\",         /* 0x30 */\n\t\"Draw GDI+ Error\",              /* 0x31 */\n\t\"ARC Status\",                   /* 0x32 */\n\t\"?\",\n\t\"?\",\n\t\"?\",              /* 0x33 - 0x35 */\n\t\"Status Info\",    /* 0x36 */\n\t\"Monitor Layout\", /* 0x37 */\n\t\"FrameAcknowledge\",\n\t\"?\",\n\t\"?\", /* 0x38 - 0x40 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\" /* 0x41 - 0x46 */\n};\n\nstatic BOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type);\nstatic void rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type,\n                                           UINT16 channel_id);\nstatic void rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id);\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length)\n{\n\t/* Basic Security Header */\n\tif ((Stream_GetRemainingLength(s) < 4) || (length && (*length < 4)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *flags); /* flags */\n\tStream_Seek(s, 2);             /* flagsHi (unused) */\n\n\tif (length)\n\t\t*length -= 4;\n\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(wStream* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tStream_Write_UINT16(s, flags); /* flags */\n\tStream_Write_UINT16(s, 0);     /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tUINT16 len;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, len); /* totalLength */\n\n\t*length = len;\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (len == 0x8000)\n\t{\n\t\tif (!rdp_read_flow_control_pdu(s, type))\n\t\t\treturn FALSE;\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif ((len < 4) || ((len - 2) > Stream_GetRemainingLength(s)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (len > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\t/* Share Control Header */\n\tStream_Write_UINT16(s, length);      /* totalLength */\n\tStream_Write_UINT16(s, type | 0x10); /* pduType */\n\tStream_Write_UINT16(s, channel_id);  /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type, UINT32* shareId,\n                                BYTE* compressedType, UINT16* compressedLength)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tStream_Read_UINT32(s, *shareId);          /* shareId (4 bytes) */\n\tStream_Seek_UINT8(s);                     /* pad1 (1 byte) */\n\tStream_Seek_UINT8(s);                     /* streamId (1 byte) */\n\tStream_Read_UINT16(s, *length);           /* uncompressedLength (2 bytes) */\n\tStream_Read_UINT8(s, *type);              /* pduType2, Data PDU Type (1 byte) */\n\tStream_Read_UINT8(s, *compressedType);    /* compressedType (1 byte) */\n\tStream_Read_UINT16(s, *compressedLength); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\t/* Share Data Header */\n\tStream_Write_UINT32(s, share_id);  /* shareId (4 bytes) */\n\tStream_Write_UINT8(s, 0);          /* pad1 (1 byte) */\n\tStream_Write_UINT8(s, STREAM_LOW); /* streamId (1 byte) */\n\tStream_Write_UINT16(s, length);    /* uncompressedLength (2 bytes) */\n\tStream_Write_UINT8(s, type);       /* pduType2, Data PDU Type (1 byte) */\n\tStream_Write_UINT8(s, 0);          /* compressedType (1 byte) */\n\tStream_Write_UINT16(s, 0);         /* compressedLength (2 bytes) */\n}\n\nstatic BOOL rdp_security_stream_init(rdpRdp* rdp, wStream* s, BOOL sec_header)\n{\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tif (rdp->do_crypt)\n\t{\n\t\tif (!Stream_SafeSeek(s, 12))\n\t\t\treturn FALSE;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t{\n\t\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_header)\n\t{\n\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_send_stream_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, FALSE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_send_stream_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_CONTROL_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_DATA_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo)\n{\n\trdp->errorInfo = errorInfo;\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t{\n\t\trdpContext* context = rdp->context;\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\t\tif (context)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, MAKE_FREERDP_ERROR(ERRINFO, errorInfo));\n\n\t\t\tif (context->pubSub)\n\t\t\t{\n\t\t\t\tErrorInfoEventArgs e;\n\t\t\t\tEventArgsInit(&e, \"freerdp\");\n\t\t\t\te.code = rdp->errorInfo;\n\t\t\t\tPubSub_OnErrorInfo(context->pubSub, context, &e);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tWLog_ERR(TAG, \"%s missing context=%p\", __FUNCTION__, context);\n\t}\n\telse\n\t{\n\t\tfreerdp_set_last_error_log(rdp->context, FREERDP_ERROR_SUCCESS);\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_message_channel_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, TRUE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channelId)\n{\n\tBYTE li;\n\tBYTE byte;\n\tBYTE code;\n\tBYTE choice;\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\tenum DomainMCSPDU domainMCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest\n\t                                     : DomainMCSPDU_SendDataIndication;\n\n\tif (!tpkt_read_header(s, length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_header(s, &code, &li, *length))\n\t\treturn FALSE;\n\n\tif (code != X224_TPDU_DATA)\n\t{\n\t\tif (code == X224_TPDU_DISCONNECT_REQUEST)\n\t\t{\n\t\t\tfreerdp_abort_connect(rdp->instance);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tdomainMCSPDU = (enum DomainMCSPDU)(choice >> 2);\n\n\tif (domainMCSPDU != MCSPDU)\n\t{\n\t\tif (domainMCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tMCSPDU = domainMCSPDU;\n\n\tif (*length < 8U)\n\t\treturn FALSE;\n\n\tif ((*length - 8U) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tint reason = 0;\n\t\tTerminateEventArgs e;\n\t\trdpContext* context;\n\n\t\tif (!mcs_recv_disconnect_provider_ultimatum(rdp->mcs, s, &reason))\n\t\t\treturn FALSE;\n\n\t\tif (!rdp->instance)\n\t\t\treturn FALSE;\n\n\t\tcontext = rdp->instance->context;\n\t\tcontext->disconnectUltimatum = reason;\n\n\t\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\t{\n\t\t\t/**\n\t\t\t * Some servers like Windows Server 2008 R2 do not send the error info pdu\n\t\t\t * when the user logs off like they should. Map DisconnectProviderUltimatum\n\t\t\t * to a ERRINFO_LOGOFF_BY_USER when the errinfo code is ERRINFO_SUCCESS.\n\t\t\t */\n\t\t\tif (reason == Disconnect_Ultimatum_provider_initiated)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t\telse if (reason == Disconnect_Ultimatum_user_requested)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_LOGOFF_BY_USER);\n\t\t\telse\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t}\n\n\t\tWLog_DBG(TAG, \"DisconnectProviderUltimatum: reason: %d\", reason);\n\t\tfreerdp_abort_connect(rdp->instance);\n\t\tEventArgsInit(&e, \"freerdp\");\n\t\te.code = 0;\n\t\tPubSub_OnTerminate(context->pubSub, context, &e);\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID)) /* initiator (UserId) */\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, channelId, 0)) /* channelId */\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte); /* dataPriority + Segmentation (0x70) */\n\n\tif (!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\n\tif (*length > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channelId)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication\n\t                                     : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) &&\n\t    (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->userId, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channelId, 0);                          /* channelId */\n\tStream_Write_UINT8(s, 0x70);                                   /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, even though we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tStream_Write_UINT16_BE(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic BOOL rdp_security_stream_out(rdpRdp* rdp, wStream* s, int length, UINT32 sec_flags,\n                                    UINT32* pad)\n{\n\tBYTE* data;\n\tBOOL status;\n\tsec_flags |= rdp->sec_flags;\n\t*pad = 0;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 12;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\t\t\t\tStream_Write_UINT16(s, 0x10); /* length */\n\t\t\t\tStream_Write_UINT8(s, 0x1);   /* TSFIPS_VERSION 1*/\n\t\t\t\t/* handle padding */\n\t\t\t\t*pad = 8 - (length % 8);\n\n\t\t\t\tif (*pad == 8)\n\t\t\t\t\t*pad = 0;\n\n\t\t\t\tif (*pad)\n\t\t\t\t\tmemset(data + length, 0, *pad);\n\n\t\t\t\tStream_Write_UINT8(s, *pad);\n\n\t\t\t\tif (!security_hmac_signature(data, length, Stream_Pointer(s), rdp))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + *pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 8;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tstatus =\n\t\t\t\t\t    security_salted_mac_signature(rdp, data, length, TRUE, Stream_Pointer(s));\n\t\t\t\telse\n\t\t\t\t\tstatus = security_mac_signature(rdp, data, length, Stream_Pointer(s));\n\n\t\t\t\tif (!status)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\n\t\t\t\tif (!security_encrypt(Stream_Pointer(s), length, rdp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn TRUE;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp, UINT16 sec_flags)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tUINT32 pad;\n\tUINT16 length;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\treturn FALSE;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\tWLog_DBG(TAG, \"%s: sending data (type=0x%x size=%\" PRIuz \" channelId=%\" PRIu16 \")\",\n\t         __FUNCTION__, type, Stream_Length(s), channel_id);\n\n\trdp->outPackets++;\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags)\n{\n\tBOOL rc = FALSE;\n\tUINT16 length;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, rdp->mcs->messageChannelId);\n\n\tif (!rdp_security_stream_out(rdp, s, length, sec_flags, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nstatic BOOL rdp_recv_server_shutdown_denied_pdu(rdpRdp* rdp, wStream* s)\n{\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_indicators_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT16 ledFlags;\n\trdpContext* context = rdp->instance->context;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);   /* unitId (2 bytes) */\n\tStream_Read_UINT16(s, ledFlags); /* ledFlags (2 bytes) */\n\tIFCALL(context->update->SetKeyboardIndicators, context, ledFlags);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_ime_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT32 imeState;\n\tUINT32 imeConvMode;\n\n\tif (!rdp || !rdp->input)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);      /* unitId (2 bytes) */\n\tStream_Read_UINT32(s, imeState);    /* imeState (4 bytes) */\n\tStream_Read_UINT32(s, imeConvMode); /* imeConvMode (4 bytes) */\n\tIFCALL(rdp->update->SetKeyboardImeStatus, rdp->context, unitId, imeState, imeConvMode);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 errorInfo;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, errorInfo); /* errorInfo (4 bytes) */\n\treturn rdp_set_error_info(rdp, errorInfo);\n}\n\nstatic BOOL rdp_recv_server_auto_reconnect_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 arcStatus;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, arcStatus); /* arcStatus (4 bytes) */\n\tWLog_WARN(TAG, \"AutoReconnectStatus: 0x%08\" PRIX32 \"\", arcStatus);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_status_info_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 statusCode;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, statusCode); /* statusCode (4 bytes) */\n\n\tif (rdp->update->ServerStatusInfo)\n\t\treturn rdp->update->ServerStatusInfo(rdp->context, statusCode);\n\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_monitor_layout_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 index;\n\tUINT32 monitorCount;\n\tMONITOR_DEF* monitor;\n\tMONITOR_DEF* monitorDefArray;\n\tBOOL ret = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount (4 bytes) */\n\n\tif ((Stream_GetRemainingLength(s) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tmonitorDefArray = (MONITOR_DEF*)calloc(monitorCount, sizeof(MONITOR_DEF));\n\n\tif (!monitorDefArray)\n\t\treturn FALSE;\n\n\tfor (monitor = monitorDefArray, index = 0; index < monitorCount; index++, monitor++)\n\t{\n\t\tStream_Read_UINT32(s, monitor->left);   /* left (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->top);    /* top (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->right);  /* right (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->bottom); /* bottom (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->flags);  /* flags (4 bytes) */\n\t}\n\n\tIFCALLRET(rdp->update->RemoteMonitors, ret, rdp->context, monitorCount, monitorDefArray);\n\tfree(monitorDefArray);\n\treturn ret;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tBYTE type;\n\twStream* cs;\n\tUINT16 length;\n\tUINT32 shareId;\n\tBYTE compressedType;\n\tUINT16 compressedLength;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &shareId, &compressedType,\n\t                                &compressedLength))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_data_header() failed\");\n\t\treturn -1;\n\t}\n\n\tcs = s;\n\n\tif (compressedType & PACKET_COMPRESSED)\n\t{\n\t\tUINT32 DstSize = 0;\n\t\tBYTE* pDstData = NULL;\n\t\tUINT16 SrcSize = compressedLength - 18;\n\n\t\tif ((compressedLength < 18) || (Stream_GetRemainingLength(s) < SrcSize))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress: not enough bytes for compressedLength %\" PRIu16 \"\",\n\t\t\t         compressedLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (bulk_decompress(rdp->bulk, Stream_Pointer(s), SrcSize, &pDstData, &DstSize,\n\t\t                    compressedType))\n\t\t{\n\t\t\tif (!(cs = StreamPool_Take(rdp->transport->ReceivePool, DstSize)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Couldn't take stream from pool\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tStream_SetPosition(cs, 0);\n\t\t\tStream_Write(cs, pDstData, DstSize);\n\t\t\tStream_SealLength(cs);\n\t\t\tStream_SetPosition(cs, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Seek(s, SrcSize);\n\t}\n\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_UPDATE - update_recv() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_CONTROL - rdp_recv_server_control_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_POINTER - update_recv_pointer() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SYNCHRONIZE - rdp_recv_synchronize_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_PLAY_SOUND - update_recv_play_sound() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tif (!rdp_recv_server_shutdown_denied_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SHUTDOWN_DENIED - rdp_recv_server_shutdown_denied_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif (!rdp_recv_save_session_info(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_SAVE_SESSION_INFO - rdp_recv_save_session_info() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif (!rdp_recv_font_map_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_FONT_MAP - rdp_recv_font_map_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tif (!rdp_recv_server_set_keyboard_indicators_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_indicators_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tif (!rdp_recv_server_set_keyboard_ime_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_ime_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SET_ERROR_INFO - rdp_recv_set_error_info_data_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tif (!rdp_recv_server_auto_reconnect_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_ARC_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_auto_reconnect_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tif (!rdp_recv_server_status_info_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_STATUS_INFO - rdp_recv_server_status_info_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tif (!rdp_recv_monitor_layout_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_MONITOR_LAYOUT - rdp_recv_monitor_layout_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn 0;\nout_fail:\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn -1;\n}\n\nint rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags)\n{\n\tif (securityFlags & SEC_AUTODETECT_REQ)\n\t{\n\t\t/* Server Auto-Detect Request PDU */\n\t\treturn rdp_recv_autodetect_request_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_AUTODETECT_RSP)\n\t{\n\t\t/* Client Auto-Detect Response PDU */\n\t\treturn rdp_recv_autodetect_response_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_HEARTBEAT)\n\t{\n\t\t/* Heartbeat PDU */\n\t\treturn rdp_recv_heartbeat_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_TRANSPORT_REQ)\n\t{\n\t\t/* Initiate Multitransport Request PDU */\n\t\treturn rdp_recv_multitransport_packet(rdp, s);\n\t}\n\n\treturn -1;\n}\n\nint rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, &type, &channelId))\n\t\treturn -1;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn rdp_recv_data_pdu(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_FLOW_RESPONSE || type == PDU_TYPE_FLOW_STOP ||\n\t         type == PDU_TYPE_FLOW_TEST)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nBOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tif (!type)\n\t\treturn FALSE;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);  /* pad8bits */\n\tStream_Seek_UINT8(s);  /* flowIdentifier */\n\tStream_Seek_UINT8(s);  /* flowNumber */\n\tStream_Seek_UINT16(s); /* pduSource */\n\treturn TRUE;\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tBOOL status;\n\tINT32 length;\n\n\tif (!rdp || !s || !pLength)\n\t\treturn FALSE;\n\n\tlength = *pLength;\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tINT64 padLength;\n\n\t\tif (Stream_GetRemainingLength(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, len);    /* 0x10 */\n\t\tStream_Read_UINT8(s, version); /* 0x1 */\n\t\tStream_Read_UINT8(s, pad);\n\t\tsig = Stream_Pointer(s);\n\t\tStream_Seek(s, 8); /* signature */\n\t\tlength -= 12;\n\t\tpadLength = length - pad;\n\n\t\tif ((length <= 0) || (padLength <= 0))\n\t\t\treturn FALSE;\n\n\t\tif (!security_fips_decrypt(Stream_Pointer(s), length, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: cannot decrypt\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(Stream_Pointer(s), length - pad, sig, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: invalid packet signature\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tStream_SetLength(s, Stream_Length(s) - pad);\n\t\t*pLength = padLength;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < sizeof(wmac))\n\t\treturn FALSE;\n\n\tStream_Read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\n\tif (length <= 0)\n\t\treturn FALSE;\n\n\tif (!security_decrypt(Stream_Pointer(s), length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tstatus = security_salted_mac_signature(rdp, Stream_Pointer(s), length, FALSE, cmac);\n\telse\n\t\tstatus = security_mac_signature(rdp, Stream_Pointer(s), length, cmac);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"WARNING: invalid packet signature\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t// return FALSE;\n\t}\n\n\t*pLength = length;\n\treturn TRUE;\n}\n\nstatic const char* pdu_type_to_str(UINT16 pduType)\n{\n\tstatic char buffer[1024] = { 0 };\n\tswitch (pduType)\n\t{\n\t\tcase PDU_TYPE_DEMAND_ACTIVE:\n\t\t\treturn \"PDU_TYPE_DEMAND_ACTIVE\";\n\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\treturn \"PDU_TYPE_CONFIRM_ACTIVE\";\n\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\treturn \"PDU_TYPE_DEACTIVATE_ALL\";\n\t\tcase PDU_TYPE_DATA:\n\t\t\treturn \"PDU_TYPE_DATA\";\n\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\treturn \"PDU_TYPE_SERVER_REDIRECTION\";\n\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\treturn \"PDU_TYPE_FLOW_TEST\";\n\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\treturn \"PDU_TYPE_FLOW_RESPONSE\";\n\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\treturn \"PDU_TYPE_FLOW_STOP\";\n\t\tdefault:\n\t\t\t_snprintf(buffer, sizeof(buffer), \"UNKNOWN %04\" PRIx16, pduType);\n\t\t\treturn buffer;\n\t}\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, wStream* s)\n{\n\tint rc = 0;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId = 0;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_security_header() fail\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\tStream_Rewind(s, 2);\n\t\t\trdp->inPackets++;\n\n\t\t\trc = rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\twhile (Stream_GetRemainingLength(s) > 3)\n\t\t{\n\t\t\tsize_t startheader, endheader, start, end, diff, headerdiff;\n\n\t\t\tstartheader = Stream_GetPosition(s);\n\t\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() fail\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart = endheader = Stream_GetPosition(s);\n\t\t\theaderdiff = endheader - startheader;\n\t\t\tif (pduLength < headerdiff)\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() invalid pduLength %\" PRIu16,\n\t\t\t\t    pduLength);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpduLength -= headerdiff;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\t\t\trdp->inPackets++;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\trc = rdp_recv_data_pdu(rdp, s);\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, s))\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_recv_deactivate_all() fail\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\n\t\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\t\tWLog_DBG(TAG, \"flow message 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\t/* http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\t\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"incorrect PDU type: 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tend = Stream_GetPosition(s);\n\t\t\tdiff = end - start;\n\t\t\tif (diff != pduLength)\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG,\n\t\t\t\t          \"pduType %s not properly parsed, %\" PRIdz\n\t\t\t\t          \" bytes remaining unhandled. Skipping.\",\n\t\t\t\t          pdu_type_to_str(pduType), diff);\n\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rdp->mcs->messageChannelId && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\t\trdp->inPackets++;\n\t\trc = rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\trdp->inPackets++;\n\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId, length))\n\t\t\treturn -1;\n\t}\n\nout:\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn rc;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: fastpath_read_header_rdp() fail\");\n\t\treturn -1;\n\t}\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags =\n\t\t    (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, &length, flags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: rdp_decrypt() fail\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\nint rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*)extra;\n\n\t/*\n\t * At any point in the connection sequence between when all\n\t * MCS channels have been joined and when the RDP connection\n\t * enters the active state, an auto-detect PDU can be received\n\t * on the MCS message channel.\n\t */\n\tif ((rdp->state > CONNECTION_STATE_MCS_CHANNEL_JOIN) && (rdp->state < CONNECTION_STATE_ACTIVE))\n\t{\n\t\tif (rdp_client_connect_auto_detect(rdp, s))\n\t\t\treturn 0;\n\t}\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NLA:\n\t\t\tif (nla_get_state(rdp->nla) < NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\tif (nla_recv_pdu(rdp->nla, s) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nla_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (nla_get_state(rdp->nla) == NLA_STATE_POST_NEGO)\n\t\t\t{\n\t\t\t\tnego_recv(rdp->transport, s, (void*)rdp->nego);\n\n\t\t\t\tif (nego_get_state(rdp->nego) != NEGO_STATE_FINAL)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nego_recv() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\ttransport_set_nla_mode(rdp->transport, FALSE);\n\n\t\t\t\tif (rdp->settings->VmConnectMode)\n\t\t\t\t{\n\t\t\t\t\tif (!nego_set_state(rdp->nego, NEGO_STATE_NLA))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tif (!nego_set_requested_protocols(rdp->nego, PROTOCOL_HYBRID | PROTOCOL_SSL))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tnego_send_negotiation_request(rdp->nego);\n\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_POST_NEGO))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_FINAL)\n\t\t\t{\n\t\t\t\tnla_free(rdp->nla);\n\t\t\t\trdp->nla = NULL;\n\n\t\t\t\tif (!mcs_client_begin(rdp->mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - mcs_client_begin() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!mcs_recv_connect_response(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_connect_response failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_erect_domain_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_erect_domain_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_attach_user_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_attach_user_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_ATTACH_USER);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!mcs_recv_attach_user_confirm(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_attach_user_confirm failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_channel_join_request(rdp->mcs, rdp->mcs->userId))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_channel_join_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_CHANNEL_JOIN);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_mcs_channel_join_confirm() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\tstatus = -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t\tstatus = rdp_client_connect_license(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_client_connect_license() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tstatus = rdp_client_connect_demand_active(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_demand_active() - %i\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t{\n\t\t\t\tActivatedEventArgs activatedEvent;\n\t\t\t\trdpContext* context = rdp->context;\n\t\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_ACTIVE);\n\t\t\t\tEventArgsInit(&activatedEvent, \"libfreerdp\");\n\t\t\t\tactivatedEvent.firstActivation = !rdp->deactivation_reactivation;\n\t\t\t\tPubSub_OnActivated(context->pubSub, context, &activatedEvent);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s: %s state %d\", __FUNCTION__,\n\t\t\t         rdp_server_connection_state_string(rdp->state), rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nBOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)\n{\n\treturn freerdp_channel_send(rdp, channelId, data, size);\n}\n\nBOOL rdp_send_error_info(rdpRdp* rdp)\n{\n\twStream* s;\n\tBOOL status;\n\n\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\treturn TRUE;\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, rdp->errorInfo); /* error id (4 bytes) */\n\tstatus = rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_ERROR_INFO, 0);\n\treturn status;\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\tint status;\n\trdpTransport* transport = rdp->transport;\n\n\tif (transport->tsg)\n\t{\n\t\trdpTsg* tsg = transport->tsg;\n\n\t\tif (!tsg_check_event_handles(tsg))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_check_fds: tsg_check_event_handles()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (tsg_get_state(tsg) != TSG_STATE_PIPE_CREATED)\n\t\t\treturn 1;\n\t}\n\n\tstatus = transport_check_fds(transport);\n\n\tif (status == 1)\n\t{\n\t\tif (!rdp_client_redirect(rdp)) /* session redirection */\n\t\t\treturn -1;\n\t}\n\n\tif (status < 0)\n\t\tWLog_DBG(TAG, \"transport_check_fds() - %i\", status);\n\n\treturn status;\n}\n\nBOOL freerdp_get_stats(rdpRdp* rdp, UINT64* inBytes, UINT64* outBytes, UINT64* inPackets,\n                       UINT64* outPackets)\n{\n\tif (!rdp)\n\t\treturn FALSE;\n\n\tif (inBytes)\n\t\t*inBytes = rdp->inBytes;\n\tif (outBytes)\n\t\t*outBytes = rdp->outBytes;\n\tif (inPackets)\n\t\t*inPackets = rdp->inPackets;\n\tif (outPackets)\n\t\t*outPackets = rdp->outPackets;\n\n\treturn TRUE;\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(rdpContext* context)\n{\n\trdpRdp* rdp;\n\tDWORD flags;\n\tBOOL newSettings = FALSE;\n\trdp = (rdpRdp*)calloc(1, sizeof(rdpRdp));\n\n\tif (!rdp)\n\t\treturn NULL;\n\n\trdp->context = context;\n\trdp->instance = context->instance;\n\tflags = 0;\n\n\tif (context->ServerMode)\n\t\tflags |= FREERDP_SETTINGS_SERVER_MODE;\n\n\tif (!context->settings)\n\t{\n\t\tcontext->settings = freerdp_settings_new(flags);\n\n\t\tif (!context->settings)\n\t\t\tgoto out_free;\n\n\t\tnewSettings = TRUE;\n\t}\n\n\trdp->settings = context->settings;\n\n\tif (context->instance)\n\t{\n\t\trdp->settings->instance = context->instance;\n\t\tcontext->instance->settings = rdp->settings;\n\t}\n\telse if (context->peer)\n\t{\n\t\trdp->settings->instance = context->peer;\n\t\tcontext->peer->settings = rdp->settings;\n\t}\n\n\trdp->transport = transport_new(context);\n\n\tif (!rdp->transport)\n\t\tgoto out_free_settings;\n\n\trdp->license = license_new(rdp);\n\n\tif (!rdp->license)\n\t\tgoto out_free_transport;\n\n\trdp->input = input_new(rdp);\n\n\tif (!rdp->input)\n\t\tgoto out_free_license;\n\n\trdp->update = update_new(rdp);\n\n\tif (!rdp->update)\n\t\tgoto out_free_input;\n\n\trdp->fastpath = fastpath_new(rdp);\n\n\tif (!rdp->fastpath)\n\t\tgoto out_free_update;\n\n\trdp->nego = nego_new(rdp->transport);\n\n\tif (!rdp->nego)\n\t\tgoto out_free_fastpath;\n\n\trdp->mcs = mcs_new(rdp->transport);\n\n\tif (!rdp->mcs)\n\t\tgoto out_free_nego;\n\n\trdp->redirection = redirection_new();\n\n\tif (!rdp->redirection)\n\t\tgoto out_free_mcs;\n\n\trdp->autodetect = autodetect_new();\n\n\tif (!rdp->autodetect)\n\t\tgoto out_free_redirection;\n\n\trdp->heartbeat = heartbeat_new();\n\n\tif (!rdp->heartbeat)\n\t\tgoto out_free_autodetect;\n\n\trdp->multitransport = multitransport_new();\n\n\tif (!rdp->multitransport)\n\t\tgoto out_free_heartbeat;\n\n\trdp->bulk = bulk_new(context);\n\n\tif (!rdp->bulk)\n\t\tgoto out_free_multitransport;\n\n\treturn rdp;\nout_free_multitransport:\n\tmultitransport_free(rdp->multitransport);\nout_free_heartbeat:\n\theartbeat_free(rdp->heartbeat);\nout_free_autodetect:\n\tautodetect_free(rdp->autodetect);\nout_free_redirection:\n\tredirection_free(rdp->redirection);\nout_free_mcs:\n\tmcs_free(rdp->mcs);\nout_free_nego:\n\tnego_free(rdp->nego);\nout_free_fastpath:\n\tfastpath_free(rdp->fastpath);\nout_free_update:\n\tupdate_free(rdp->update);\nout_free_input:\n\tinput_free(rdp->input);\nout_free_license:\n\tlicense_free(rdp->license);\nout_free_transport:\n\ttransport_free(rdp->transport);\nout_free_settings:\n\n\tif (newSettings)\n\t\tfreerdp_settings_free(rdp->settings);\n\nout_free:\n\tfree(rdp);\n\treturn NULL;\n}\n\nvoid rdp_reset(rdpRdp* rdp)\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tcontext = rdp->context;\n\tsettings = rdp->settings;\n\tbulk_reset(rdp->bulk);\n\n\tif (rdp->rc4_decrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = NULL;\n\t}\n\n\tif (rdp->rc4_encrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = NULL;\n\t}\n\n\tif (rdp->fips_encrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\trdp->fips_encrypt = NULL;\n\t}\n\n\tif (rdp->fips_decrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\trdp->fips_decrypt = NULL;\n\t}\n\n\tif (settings->ServerRandom)\n\t{\n\t\tfree(settings->ServerRandom);\n\t\tsettings->ServerRandom = NULL;\n\t\tsettings->ServerRandomLength = 0;\n\t}\n\n\tif (settings->ServerCertificate)\n\t{\n\t\tfree(settings->ServerCertificate);\n\t\tsettings->ServerCertificate = NULL;\n\t}\n\n\tif (settings->ClientAddress)\n\t{\n\t\tfree(settings->ClientAddress);\n\t\tsettings->ClientAddress = NULL;\n\t}\n\n\tmcs_free(rdp->mcs);\n\tnego_free(rdp->nego);\n\tlicense_free(rdp->license);\n\ttransport_free(rdp->transport);\n\tfastpath_free(rdp->fastpath);\n\trdp->transport = transport_new(context);\n\trdp->license = license_new(rdp);\n\trdp->nego = nego_new(rdp->transport);\n\trdp->mcs = mcs_new(rdp->transport);\n\trdp->fastpath = fastpath_new(rdp);\n\trdp->transport->layer = TRANSPORT_LAYER_TCP;\n\trdp->errorInfo = 0;\n\trdp->deactivation_reactivation = 0;\n\trdp->finalize_sc_pdus = 0;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tnla_free(rdp->nla);\n\t\tredirection_free(rdp->redirection);\n\t\tautodetect_free(rdp->autodetect);\n\t\theartbeat_free(rdp->heartbeat);\n\t\tmultitransport_free(rdp->multitransport);\n\t\tbulk_free(rdp->bulk);\n\t\tfree(rdp);\n\t}\n}\n"], "filenames": ["libfreerdp/core/rdp.c"], "buggy_code_start_loc": [105], "buggy_code_end_loc": [1134], "fixing_code_start_loc": [105], "fixing_code_end_loc": [1144], "type": "CWE-125", "message": "In FreeRDP after 1.0 and before 2.0.0, there is an out-of-bounds read. It only allows to abort a session. No data extraction is possible. This has been fixed in 2.0.0.", "other": {"cve": {"id": "CVE-2020-11048", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T20:15:12.190", "lastModified": "2022-07-01T17:19:51.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP after 1.0 and before 2.0.0, there is an out-of-bounds read. It only allows to abort a session. No data extraction is possible. This has been fixed in 2.0.0."}, {"lang": "es", "value": "En FreeRDP versiones posteriores a 1.0 y versiones anteriores a 2.0.0, se presenta una lectura fuera de l\u00edmite. Solo permite abortar una sesi\u00f3n. No es posible la extracci\u00f3n de datos. Esto ha sido corregido en la versi\u00f3n 2.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "2.0.0", "matchCriteriaId": "C492C074-0329-4949-9533-ED0FE1E0B088"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/9301bfe730c66180263248b74353daa99f5a969b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/issues/6007", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-hv8w-f2hx-5gcv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00054.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4382-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/9301bfe730c66180263248b74353daa99f5a969b"}}