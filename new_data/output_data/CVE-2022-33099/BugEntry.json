{"buggy_code": ["/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n\n\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** Base lines are regularly placed at MAXIWTHABS intervals, so usually\n** an integer division gets the right place. When the source file has\n** large sequences of empty/comment lines, it may need extra entries,\n** so the original estimate needs a correction.\n** If the original estimate is -1, the initial 'if' ensures that the\n** 'while' will run at least once.\n** The assertion that the estimate is a lower bound for the correct base\n** is valid as long as the debug info has been generated with the same\n** value for MAXIWTHABS or smaller. (Previous releases use a little\n** smaller value.)\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    int i = cast_uint(pc) / MAXIWTHABS - 1;  /* get an estimate */\n    /* estimate must be a lower bound of the correct base */\n    lua_assert(i < 0 ||\n              (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));\n    while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)\n      i++;  /* low estimate; adjust it */\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getstr(p->source);\n      ar->srclen = tsslen(p->source);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(s2v(L->top));\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top, t);  /* push it on stack */\n    api_incr_top(L);\n    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n    if (!p->is_vararg)  /* regular function? */\n      i = 0;  /* consider all instructions */\n    else {  /* vararg function */\n      lua_assert(GET_OPCODE(p->code[0]) == OP_VARARGPREP);\n      currentline = nextline(p, currentline, 0);\n      i = 1;  /* skip first instruction (OP_VARARGPREP) */\n    }\n    for (; i < p->sizelineinfo; i++) {  /* for each instruction */\n      currentline = nextline(p, currentline, i);  /* get its line */\n      luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  /* calling function is a known function? */\n  if (ci != NULL && !(ci->callstatus & CIST_TAIL))\n    return funcnamefromcall(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_TRAN))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = ci->u2.transferinfo.ftransfer;\n          ar->ntransfer = ci->u2.transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic void kname (const Proto *p, int c, const char **name) {\n  TValue *kvalue = &p->k[c];\n  *name = (ttisstring(kvalue)) ? svalue(kvalue) : \"?\";\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = getobjname(p, pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *gxf (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is an upvalue? */\n    name = upvalname(p, t);\n  else\n    getobjname(p, pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, pc, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        rkname(p, pc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, const Proto *p,\n                                     int pc, const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  Instruction i = p->code[pc];  /* calling instruction */\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    /* no cases for OP_EQI and OP_EQK, as they don't call metamethods */\n    case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;\n    case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;\n    case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n\n/*\n** Try to find a name for a function based on how it was called.\n*/\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name) {\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  else if (ci->callstatus & CIST_FIN) {  /* was it called as a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  else if (isLua(ci))\n    return funcnamefromcode(L, ci_func(ci)->p, currentpc(ci), name);\n  else\n    return NULL;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** Check whether pointer 'o' points to some value in the stack\n** frame of the current function. Because 'o' may not point to a\n** value in this stack, we cannot compare it with the region\n** boundaries (undefined behaviour in ISO C).\n*/\nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId pos;\n  for (pos = ci->func + 1; pos < ci->top; pos++) {\n    if (o == s2v(pos))\n      return 1;\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *formatvarinfo (lua_State *L, const char *kind,\n                                                const char *name) {\n  if (kind == NULL)\n    return \"\";  /* no information */\n  else\n    return luaO_pushfstring(L, \" (%s '%s')\", kind, name);\n}\n\n/*\n** Build a string with a \"description\" for the value 'o', such as\n** \"variable 'x'\" or \"upvalue 'y'\".\n*/\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind && isinstack(ci, o))  /* no? try a register */\n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(cast(StkId, o) - (ci->func + 1)), &name);\n  }\n  return formatvarinfo(L, kind, name);\n}\n\n\n/*\n** Raise a type error\n*/\nstatic l_noret typeerror (lua_State *L, const TValue *o, const char *op,\n                          const char *extra) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, extra);\n}\n\n\n/*\n** Raise a type error with \"standard\" information about the faulty\n** object 'o' (using 'varinfo').\n*/\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  typeerror(L, o, op, varinfo(L, o));\n}\n\n\n/*\n** Raise an error for calling a non-callable object. Try to find a name\n** for the object based on how it was called ('funcnamefromcall'); if it\n** cannot get a name there, try 'varinfo'.\n*/\nl_noret luaG_callerror (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = funcnamefromcall(L, ci, &name);\n  const char *extra = kind ? formatvarinfo(L, kind, name) : varinfo(L, o);\n  typeerror(L, o, \"call\", extra);\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!luaV_tointegerns(p1, &temp, LUA_FLOORN2I))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src)\n    luaO_chunkid(buff, getstr(src), tsslen(src));\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'. More often than not, 'newpc' is only\n** one or a few instructions after 'oldpc' (it must be after, see\n** caller), so try to avoid calling 'luaG_getfuncline'. If they are\n** too far apart, there is a good chance of a ABSLINEINFO in the way,\n** so it goes directly to 'luaG_getfuncline'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */\n    int delta = 0;  /* line diference */\n    int pc = oldpc;\n    for (;;) {\n      int lineinfo = p->lineinfo[++pc];\n      if (lineinfo == ABSLINEINFO)\n        break;  /* cannot compute delta; fall through */\n      delta += lineinfo;\n      if (pc == newpc)\n        return (delta != 0);  /* delta computed successfully */\n    }\n  }\n  /* either instructions are too far apart or there is an absolute line\n     info in the way; compute line difference explicitly */\n  return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line whatever\n** the value of 'oldpc'.  Some exceptional conditions may return to\n** a function without setting 'oldpc'. In that case, 'oldpc' may be\n** invalid; if so, use zero as a valid value. (A wrong but valid 'oldpc'\n** at most causes an extra call to a line hook.)\n** This function is not \"Protected\" when called, so it should correct\n** 'L->top' before calling anything that can run the GC.\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */\n    L->top = ci->top;  /* correct top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    /* 'L->oldpc' may be invalid; use zero in this case */\n    int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n    int npci = pcRel(pc, p);\n    if (npci <= oldpc ||  /* call hook when jump back (loop), */\n        changedline(p, oldpc, npci)) {  /* or when enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n", "/*\n** $Id: lvm.c $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lvm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n/*\n** By default, use jump tables in the main interpreter loop on gcc\n** and compatible compilers.\n*/\n#if !defined(LUA_USE_JUMPTABLE)\n#if defined(__GNUC__)\n#define LUA_USE_JUMPTABLE\t1\n#else\n#define LUA_USE_JUMPTABLE\t0\n#endif\n#endif\n\n\n\n/* limit for table tag-method chains (to avoid infinite loops) */\n#define MAXTAGLOOP\t2000\n\n\n/*\n** 'l_intfitsf' checks whether a given integer is in the range that\n** can be converted to a float without rounding. Used in comparisons.\n*/\n\n/* number of bits in the mantissa of a float */\n#define NBM\t\t(l_floatatt(MANT_DIG))\n\n/*\n** Check whether some integers may not fit in a float, testing whether\n** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)\n** (The shifts are done in parts, to avoid shifting by more than the size\n** of an integer. In a worst case, NBM == 113 for long double and\n** sizeof(long) == 32.)\n*/\n#if ((((LUA_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \\\n\t>> (NBM - (3 * (NBM / 4))))  >  0\n\n/* limit for integers that fit in a float */\n#define MAXINTFITSF\t((lua_Unsigned)1 << NBM)\n\n/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */\n#define l_intfitsf(i)\t((MAXINTFITSF + l_castS2U(i)) <= (2 * MAXINTFITSF))\n\n#else  /* all integers fit in a float precisely */\n\n#define l_intfitsf(i)\t1\n\n#endif\n\n\n/*\n** Try to convert a value from string to a number value.\n** If the value is not a string or is a string not representing\n** a valid numeral (or if coercions from strings to numbers\n** are disabled via macro 'cvt2num'), do not modify 'result'\n** and return 0.\n*/\nstatic int l_strton (const TValue *obj, TValue *result) {\n  lua_assert(obj != result);\n  if (!cvt2num(obj))  /* is object not a string? */\n    return 0;\n  else\n    return (luaO_str2num(svalue(obj), result) == vslen(obj) + 1);\n}\n\n\n/*\n** Try to convert a value to a float. The float case is already handled\n** by the macro 'tonumber'.\n*/\nint luaV_tonumber_ (const TValue *obj, lua_Number *n) {\n  TValue v;\n  if (ttisinteger(obj)) {\n    *n = cast_num(ivalue(obj));\n    return 1;\n  }\n  else if (l_strton(obj, &v)) {  /* string coercible to number? */\n    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */\n    return 1;\n  }\n  else\n    return 0;  /* conversion failed */\n}\n\n\n/*\n** try to convert a float to an integer, rounding according to 'mode'.\n*/\nint luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode) {\n  lua_Number f = l_floor(n);\n  if (n != f) {  /* not an integral value? */\n    if (mode == F2Ieq) return 0;  /* fails if mode demands integral value */\n    else if (mode == F2Iceil)  /* needs ceil? */\n      f += 1;  /* convert floor to ceil (remember: n != f) */\n  }\n  return lua_numbertointeger(f, p);\n}\n\n\n/*\n** try to convert a value to an integer, rounding according to 'mode',\n** without string coercion.\n** (\"Fast track\" handled by macro 'tointegerns'.)\n*/\nint luaV_tointegerns (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  if (ttisfloat(obj))\n    return luaV_flttointeger(fltvalue(obj), p, mode);\n  else if (ttisinteger(obj)) {\n    *p = ivalue(obj);\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** try to convert a value to an integer.\n*/\nint luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  TValue v;\n  if (l_strton(obj, &v))  /* does 'obj' point to a numerical string? */\n    obj = &v;  /* change it to point to its corresponding number */\n  return luaV_tointegerns(obj, p, mode);\n}\n\n\n/*\n** Try to convert a 'for' limit to an integer, preserving the semantics\n** of the loop. Return true if the loop must not run; otherwise, '*p'\n** gets the integer limit.\n** (The following explanation assumes a positive step; it is valid for\n** negative steps mutatis mutandis.)\n** If the limit is an integer or can be converted to an integer,\n** rounding down, that is the limit.\n** Otherwise, check whether the limit can be converted to a float. If\n** the float is too large, clip it to LUA_MAXINTEGER.  If the float\n** is too negative, the loop should not run, because any initial\n** integer value is greater than such limit; so, the function returns\n** true to signal that. (For this latter case, no integer limit would be\n** correct; even a limit of LUA_MININTEGER would run the loop once for\n** an initial value equal to LUA_MININTEGER.)\n*/\nstatic int forlimit (lua_State *L, lua_Integer init, const TValue *lim,\n                                   lua_Integer *p, lua_Integer step) {\n  if (!luaV_tointeger(lim, p, (step < 0 ? F2Iceil : F2Ifloor))) {\n    /* not coercible to in integer */\n    lua_Number flim;  /* try to convert to float */\n    if (!tonumber(lim, &flim)) /* cannot convert to float? */\n      luaG_forerror(L, lim, \"limit\");\n    /* else 'flim' is a float out of integer bounds */\n    if (luai_numlt(0, flim)) {  /* if it is positive, it is too large */\n      if (step < 0) return 1;  /* initial value must be less than it */\n      *p = LUA_MAXINTEGER;  /* truncate */\n    }\n    else {  /* it is less than min integer */\n      if (step > 0) return 1;  /* initial value must be greater than it */\n      *p = LUA_MININTEGER;  /* truncate */\n    }\n  }\n  return (step > 0 ? init > *p : init < *p);  /* not to run? */\n}\n\n\n/*\n** Prepare a numerical for loop (opcode OP_FORPREP).\n** Return true to skip the loop. Otherwise,\n** after preparation, stack will be as follows:\n**   ra : internal index (safe copy of the control variable)\n**   ra + 1 : loop counter (integer loops) or limit (float loops)\n**   ra + 2 : step\n**   ra + 3 : control variable\n*/\nstatic int forprep (lua_State *L, StkId ra) {\n  TValue *pinit = s2v(ra);\n  TValue *plimit = s2v(ra + 1);\n  TValue *pstep = s2v(ra + 2);\n  if (ttisinteger(pinit) && ttisinteger(pstep)) { /* integer loop? */\n    lua_Integer init = ivalue(pinit);\n    lua_Integer step = ivalue(pstep);\n    lua_Integer limit;\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    setivalue(s2v(ra + 3), init);  /* control variable */\n    if (forlimit(L, init, plimit, &limit, step))\n      return 1;  /* skip the loop */\n    else {  /* prepare loop counter */\n      lua_Unsigned count;\n      if (step > 0) {  /* ascending loop? */\n        count = l_castS2U(limit) - l_castS2U(init);\n        if (step != 1)  /* avoid division in the too common case */\n          count /= l_castS2U(step);\n      }\n      else {  /* step < 0; descending loop */\n        count = l_castS2U(init) - l_castS2U(limit);\n        /* 'step+1' avoids negating 'mininteger' */\n        count /= l_castS2U(-(step + 1)) + 1u;\n      }\n      /* store the counter in place of the limit (which won't be\n         needed anymore) */\n      setivalue(plimit, l_castU2S(count));\n    }\n  }\n  else {  /* try making all values floats */\n    lua_Number init; lua_Number limit; lua_Number step;\n    if (l_unlikely(!tonumber(plimit, &limit)))\n      luaG_forerror(L, plimit, \"limit\");\n    if (l_unlikely(!tonumber(pstep, &step)))\n      luaG_forerror(L, pstep, \"step\");\n    if (l_unlikely(!tonumber(pinit, &init)))\n      luaG_forerror(L, pinit, \"initial value\");\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (luai_numlt(0, step) ? luai_numlt(limit, init)\n                            : luai_numlt(init, limit))\n      return 1;  /* skip the loop */\n    else {\n      /* make sure internal values are all floats */\n      setfltvalue(plimit, limit);\n      setfltvalue(pstep, step);\n      setfltvalue(s2v(ra), init);  /* internal index */\n      setfltvalue(s2v(ra + 3), init);  /* control variable */\n    }\n  }\n  return 0;\n}\n\n\n/*\n** Execute a step of a float numerical for loop, returning\n** true iff the loop must continue. (The integer case is\n** written online with opcode OP_FORLOOP, for performance.)\n*/\nstatic int floatforloop (StkId ra) {\n  lua_Number step = fltvalue(s2v(ra + 2));\n  lua_Number limit = fltvalue(s2v(ra + 1));\n  lua_Number idx = fltvalue(s2v(ra));  /* internal index */\n  idx = luai_numadd(L, idx, step);  /* increment index */\n  if (luai_numlt(0, step) ? luai_numle(idx, limit)\n                          : luai_numle(limit, idx)) {\n    chgfltvalue(s2v(ra), idx);  /* update internal index */\n    setfltvalue(s2v(ra + 3), idx);  /* and control variable */\n    return 1;  /* jump back */\n  }\n  else\n    return 0;  /* finish the loop */\n}\n\n\n/*\n** Finish the table access 'val = t[key]'.\n** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to\n** t[k] entry (which must be empty).\n*/\nvoid luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,\n                      const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  const TValue *tm;  /* metamethod */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    if (slot == NULL) {  /* 't' is not a table? */\n      lua_assert(!ttistable(t));\n      tm = luaT_gettmbyobj(L, t, TM_INDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");  /* no metamethod */\n      /* else will try the metamethod */\n    }\n    else {  /* 't' is a table */\n      lua_assert(isempty(slot));\n      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        setnilvalue(s2v(val));  /* result is nil */\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    if (ttisfunction(tm)) {  /* is metamethod a function? */\n      luaT_callTMres(L, tm, t, key, val);  /* call it */\n      return;\n    }\n    t = tm;  /* else try to access 'tm[key]' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {  /* fast track? */\n      setobj2s(L, val, slot);  /* done */\n      return;\n    }\n    /* else repeat (tail call 'luaV_finishget') */\n  }\n  luaG_runerror(L, \"'__index' chain too long; possible loop\");\n}\n\n\n/*\n** Finish a table assignment 't[key] = val'.\n** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points\n** to the entry 't[key]', or to a value with an absent key if there\n** is no such entry.  (The value at 'slot' must be empty, otherwise\n** 'luaV_fastget' would have done the job.)\n*/\nvoid luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                     TValue *val, const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (slot != NULL) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      lua_assert(isempty(slot));  /* slot must be empty */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, slot, val);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {\n      luaV_finishfastset(L, t, slot, val);\n      return;  /* done */\n    }\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}\n\n\n/*\n** Compare two strings 'ls' x 'rs', returning an integer less-equal-\n** -greater than zero if 'ls' is less-equal-greater than 'rs'.\n** The code is a little tricky because it allows '\\0' in the strings\n** and it uses 'strcoll' (to respect locales) for each segments\n** of the strings.\n*/\nstatic int l_strcmp (const TString *ls, const TString *rs) {\n  const char *l = getstr(ls);\n  size_t ll = tsslen(ls);\n  const char *r = getstr(rs);\n  size_t lr = tsslen(rs);\n  for (;;) {  /* for each segment */\n    int temp = strcoll(l, r);\n    if (temp != 0)  /* not equal? */\n      return temp;  /* done */\n    else {  /* strings are equal up to a '\\0' */\n      size_t len = strlen(l);  /* index of first '\\0' in both strings */\n      if (len == lr)  /* 'rs' is finished? */\n        return (len == ll) ? 0 : 1;  /* check 'ls' */\n      else if (len == ll)  /* 'ls' is finished? */\n        return -1;  /* 'ls' is less than 'rs' ('rs' is not finished) */\n      /* both strings longer than 'len'; go on comparing after the '\\0' */\n      len++;\n      l += len; ll -= len; r += len; lr -= len;\n    }\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than float 'f'. If 'i' has an\n** exact representation as a float ('l_intfitsf'), compare numbers as\n** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.\n** If 'ceil(f)' is out of integer range, either 'f' is greater than\n** all integers or less than all integers.\n** (The test with 'l_intfitsf' is only for performance; the else\n** case is correct for all values, but it is slow due to the conversion\n** from float to int.)\n** When 'f' is NaN, comparisons must result in false.\n*/\nl_sinline int LTintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numlt(cast_num(i), f);  /* compare them as floats */\n  else {  /* i < f <=> i < ceil(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return i < fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than or equal to float 'f'.\n** See comments on previous function.\n*/\nl_sinline int LEintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numle(cast_num(i), f);  /* compare them as floats */\n  else {  /* i <= f <=> i <= floor(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return i <= fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LTfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numlt(f, cast_num(i));  /* compare them as floats */\n  else {  /* f < i <=> floor(f) < i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return fi < i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than or equal to integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LEfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numle(f, cast_num(i));  /* compare them as floats */\n  else {  /* f <= i <=> ceil(f) <= i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return fi <= i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Return 'l < r', for numbers.\n*/\nl_sinline int LTnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li < ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LTintfloat(li, fltvalue(r));  /* l < r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numlt(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LTfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** Return 'l <= r', for numbers.\n*/\nl_sinline int LEnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li <= ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LEintfloat(li, fltvalue(r));  /* l <= r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numle(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LEfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** return 'l < r' for non-numbers.\n*/\nstatic int lessthanothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LT);\n}\n\n\n/*\n** Main operation less than; return 'l < r'.\n*/\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LTnum(l, r);\n  else return lessthanothers(L, l, r);\n}\n\n\n/*\n** return 'l <= r' for non-numbers.\n*/\nstatic int lessequalothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LE);\n}\n\n\n/*\n** Main operation less than or equal to; return 'l <= r'.\n*/\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LEnum(l, r);\n  else return lessequalothers(L, l, r);\n}\n\n\n/*\n** Main operation for equality of Lua values; return 't1 == t2'.\n** L == NULL means raw equality (no metamethods)\n*/\nint luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  if (ttypetag(t1) != ttypetag(t2)) {  /* not the same variant? */\n    if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)\n      return 0;  /* only numbers can be equal with different variants */\n    else {  /* two numbers with different variants */\n      /* One of them is an integer. If the other does not have an\n         integer value, they cannot be equal; otherwise, compare their\n         integer values. */\n      lua_Integer i1, i2;\n      return (luaV_tointegerns(t1, &i1, F2Ieq) &&\n              luaV_tointegerns(t2, &i2, F2Ieq) &&\n              i1 == i2);\n    }\n  }\n  /* values have same type and same variant */\n  switch (ttypetag(t1)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE: return 1;\n    case LUA_VNUMINT: return (ivalue(t1) == ivalue(t2));\n    case LUA_VNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));\n    case LUA_VLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_VLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_VSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_VTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL)  /* no TM? */\n    return 0;  /* objects are different */\n  else {\n    luaT_callTMres(L, tm, t1, t2, L->top);  /* call TM */\n    return !l_isfalse(s2v(L->top));\n  }\n}\n\n\n/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */\n#define tostring(L,o)  \\\n\t(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))\n\n#define isemptystr(o)\t(ttisshrstring(o) && tsvalue(o)->shrlen == 0)\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nstatic void copy2buff (StkId top, int n, char *buff) {\n  size_t tl = 0;  /* size already copied */\n  do {\n    size_t l = vslen(s2v(top - n));  /* length of string being copied */\n    memcpy(buff + tl, svalue(s2v(top - n)), l * sizeof(char));\n    tl += l;\n  } while (--n > 0);\n}\n\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top - total' up to 'L->top - 1'.\n*/\nvoid luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n-1;  /* got 'n' strings to create 1 new */\n    L->top -= n-1;  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n\n\n/*\n** Main operation 'ra = #rb'.\n*/\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypetag(rb)) {\n    case LUA_VTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;  /* metamethod? break switch to call it */\n      setivalue(s2v(ra), luaH_getn(h));  /* else primitive len */\n      return;\n    }\n    case LUA_VSHRSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->shrlen);\n      return;\n    }\n    case LUA_VLNGSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->u.lnglen);\n      return;\n    }\n    default: {  /* try metamethod */\n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (l_unlikely(notm(tm)))  /* no metamethod? */\n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  luaT_callTMres(L, tm, rb, rb, ra);\n}\n\n\n/*\n** Integer division; return 'm // n', that is, floor(m/n).\n** C division truncates its result (rounds towards zero).\n** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,\n** otherwise 'floor(q) == trunc(q) - 1'.\n*/\nlua_Integer luaV_idiv (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to divide by zero\");\n    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */\n  }\n  else {\n    lua_Integer q = m / n;  /* perform C division */\n    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */\n      q -= 1;  /* correct result for different rounding */\n    return q;\n  }\n}\n\n\n/*\n** Integer modulus; return 'm % n'. (Assume that C '%' with\n** negative operands follows C99 behavior. See previous comment\n** about luaV_idiv.)\n*/\nlua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to perform 'n%%0'\");\n    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */\n  }\n  else {\n    lua_Integer r = m % n;\n    if (r != 0 && (r ^ n) < 0)  /* 'm/n' would be non-integer negative? */\n      r += n;  /* correct result for different rounding */\n    return r;\n  }\n}\n\n\n/*\n** Float modulus\n*/\nlua_Number luaV_modf (lua_State *L, lua_Number m, lua_Number n) {\n  lua_Number r;\n  luai_nummod(L, m, n, r);\n  return r;\n}\n\n\n/* number of bits in an integer */\n#define NBITS\tcast_int(sizeof(lua_Integer) * CHAR_BIT)\n\n/*\n** Shift left operation. (Shift right just negates 'y'.)\n*/\n#define luaV_shiftr(x,y)\tluaV_shiftl(x,intop(-, 0, y))\n\n\nlua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {\n  if (y < 0) {  /* shift right? */\n    if (y <= -NBITS) return 0;\n    else return intop(>>, x, -y);\n  }\n  else {  /* shift left */\n    if (y >= NBITS) return 0;\n    else return intop(<<, x, y);\n  }\n}\n\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  LClosure *ncl = luaF_newLclosure(L, nup);\n  ncl->p = p;\n  setclLvalue2s(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->upvals[i] = encup[uv[i].idx];\n    luaC_objbarrier(L, ncl, ncl->upvals[i]);\n  }\n}\n\n\n/*\n** finish execution of an opcode interrupted by a yield\n*/\nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->func + 1;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      setobjs2s(L, base + GETARG_A(*(ci->u.l.savedpc - 2)), --L->top);\n      break;\n    }\n    case OP_UNM: case OP_BNOT: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_GETI:\n    case OP_GETFIELD: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LT: case OP_LE:\n    case OP_LTI: case OP_LEI:\n    case OP_GTI: case OP_GEI:\n    case OP_EQ: {  /* note that 'OP_EQI'/'OP_EQK' cannot yield */\n      int res = !l_isfalse(s2v(L->top - 1));\n      L->top--;\n#if defined(LUA_COMPAT_LT_LE)\n      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n        res = !res;  /* negate result */\n      }\n#endif\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_k(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'luaT_tryconcatTM' was called */\n      int a = GETARG_A(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + a));  /* yet to concatenate */\n      setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n      L->top = top - 1;  /* top is one after last element (at top-2) */\n      luaV_concat(L, total);  /* concat them (may yield again) */\n      break;\n    }\n    case OP_CLOSE: {  /* yielded closing variables */\n      ci->u.l.savedpc--;  /* repeat instruction to close other vars. */\n      break;\n    }\n    case OP_RETURN: {  /* yielded closing variables */\n      StkId ra = base + GETARG_A(inst);\n      /* adjust top to signal correct number of returns, in case the\n         return is \"up to top\" ('isIT') */\n      L->top = ra + ci->u2.nres;\n      /* repeat instruction to close other vars. and complete the return */\n      ci->u.l.savedpc--;\n      break;\n    }\n    default: {\n      /* only these other opcodes can yield */\n      lua_assert(op == OP_TFORCALL || op == OP_CALL ||\n           op == OP_TAILCALL || op == OP_SETTABUP || op == OP_SETTABLE ||\n           op == OP_SETI || op == OP_SETFIELD);\n      break;\n    }\n  }\n}\n\n\n\n\n/*\n** {==================================================================\n** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'\n** ===================================================================\n*/\n\n#define l_addi(L,a,b)\tintop(+, a, b)\n#define l_subi(L,a,b)\tintop(-, a, b)\n#define l_muli(L,a,b)\tintop(*, a, b)\n#define l_band(a,b)\tintop(&, a, b)\n#define l_bor(a,b)\tintop(|, a, b)\n#define l_bxor(a,b)\tintop(^, a, b)\n\n#define l_lti(a,b)\t(a < b)\n#define l_lei(a,b)\t(a <= b)\n#define l_gti(a,b)\t(a > b)\n#define l_gei(a,b)\t(a >= b)\n\n\n/*\n** Arithmetic operations with immediate operands. 'iop' is the integer\n** operation, 'fop' is the float operation.\n*/\n#define op_arithI(L,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  int imm = GETARG_sC(i);  \\\n  if (ttisinteger(v1)) {  \\\n    lua_Integer iv1 = ivalue(v1);  \\\n    pc++; setivalue(s2v(ra), iop(L, iv1, imm));  \\\n  }  \\\n  else if (ttisfloat(v1)) {  \\\n    lua_Number nb = fltvalue(v1);  \\\n    lua_Number fimm = cast_num(imm);  \\\n    pc++; setfltvalue(s2v(ra), fop(L, nb, fimm)); \\\n  }}\n\n\n/*\n** Auxiliary function for arithmetic operations over floats and others\n** with two register operands.\n*/\n#define op_arithf_aux(L,v1,v2,fop) {  \\\n  lua_Number n1; lua_Number n2;  \\\n  if (tonumberns(v1, n1) && tonumberns(v2, n2)) {  \\\n    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \\\n  }}\n\n\n/*\n** Arithmetic operations over floats and others with register operands.\n*/\n#define op_arithf(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with K operands for floats.\n*/\n#define op_arithfK(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations over integers and floats.\n*/\n#define op_arith_aux(L,v1,v2,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  if (ttisinteger(v1) && ttisinteger(v2)) {  \\\n    lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);  \\\n    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \\\n  }  \\\n  else op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with register operands.\n*/\n#define op_arith(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Arithmetic operations with K operands.\n*/\n#define op_arithK(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Bitwise operations with constant operand.\n*/\n#define op_bitwiseK(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i);  \\\n  lua_Integer i1;  \\\n  lua_Integer i2 = ivalue(v2);  \\\n  if (tointegerns(v1, &i1)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Bitwise operations with register operands.\n*/\n#define op_bitwise(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  lua_Integer i1; lua_Integer i2;  \\\n  if (tointegerns(v1, &i1) && tointegerns(v2, &i2)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Order operations with register operands. 'opn' actually works\n** for all numbers, but the fast track improves performance for\n** integers.\n*/\n#define op_order(L,opi,opn,other) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  TValue *rb = vRB(i);  \\\n  if (ttisinteger(s2v(ra)) && ttisinteger(rb)) {  \\\n    lua_Integer ia = ivalue(s2v(ra));  \\\n    lua_Integer ib = ivalue(rb);  \\\n    cond = opi(ia, ib);  \\\n  }  \\\n  else if (ttisnumber(s2v(ra)) && ttisnumber(rb))  \\\n    cond = opn(s2v(ra), rb);  \\\n  else  \\\n    Protect(cond = other(L, s2v(ra), rb));  \\\n  docondjump(); }\n\n\n/*\n** Order operations with immediate operand. (Immediate operand is\n** always small enough to have an exact representation as a float.)\n*/\n#define op_orderI(L,opi,opf,inv,tm) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  int im = GETARG_sB(i);  \\\n  if (ttisinteger(s2v(ra)))  \\\n    cond = opi(ivalue(s2v(ra)), im);  \\\n  else if (ttisfloat(s2v(ra))) {  \\\n    lua_Number fa = fltvalue(s2v(ra));  \\\n    lua_Number fim = cast_num(im);  \\\n    cond = opf(fa, fim);  \\\n  }  \\\n  else {  \\\n    int isf = GETARG_C(i);  \\\n    Protect(cond = luaT_callorderiTM(L, s2v(ra), im, inv, isf, tm));  \\\n  }  \\\n  docondjump(); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Function 'luaV_execute': main interpreter loop\n** ===================================================================\n*/\n\n/*\n** some macros for common tasks in 'luaV_execute'\n*/\n\n\n#define RA(i)\t(base+GETARG_A(i))\n#define RB(i)\t(base+GETARG_B(i))\n#define vRB(i)\ts2v(RB(i))\n#define KB(i)\t(k+GETARG_B(i))\n#define RC(i)\t(base+GETARG_C(i))\n#define vRC(i)\ts2v(RC(i))\n#define KC(i)\t(k+GETARG_C(i))\n#define RKC(i)\t((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))\n\n\n\n#define updatetrap(ci)  (trap = ci->u.l.trap)\n\n#define updatebase(ci)\t(base = ci->func + 1)\n\n\n#define updatestack(ci)  \\\n\t{ if (l_unlikely(trap)) { updatebase(ci); ra = RA(i); } }\n\n\n/*\n** Execute a jump instruction. The 'updatetrap' allows signals to stop\n** tight loops. (Without it, the local copy of 'trap' could never change.)\n*/\n#define dojump(ci,i,e)\t{ pc += GETARG_sJ(i) + e; updatetrap(ci); }\n\n\n/* for test instructions, execute the jump instruction that follows it */\n#define donextjump(ci)\t{ Instruction ni = *pc; dojump(ci, ni, 1); }\n\n/*\n** do a conditional jump: skip next instruction if 'cond' is not what\n** was expected (parameter 'k'), else do next instruction, which must\n** be a jump.\n*/\n#define docondjump()\tif (cond != GETARG_k(i)) pc++; else donextjump(ci);\n\n\n/*\n** Correct global 'pc'.\n*/\n#define savepc(L)\t(ci->u.l.savedpc = pc)\n\n\n/*\n** Whenever code can raise errors, the global 'pc' and the global\n** 'top' must be correct to report occasional errors.\n*/\n#define savestate(L,ci)\t\t(savepc(L), L->top = ci->top)\n\n\n/*\n** Protect code that, in general, can raise errors, reallocate the\n** stack, and change the hooks.\n*/\n#define Protect(exp)  (savestate(L,ci), (exp), updatetrap(ci))\n\n/* special version that does not change the top */\n#define ProtectNT(exp)  (savepc(L), (exp), updatetrap(ci))\n\n/*\n** Protect code that can only raise errors. (That is, it cannot change\n** the stack or hooks.)\n*/\n#define halfProtect(exp)  (savestate(L,ci), (exp))\n\n/* 'c' is the limit of live values in the stack */\n#define checkGC(L,c)  \\\n\t{ luaC_condGC(L, (savepc(L), L->top = (c)), \\\n                         updatetrap(ci)); \\\n           luai_threadyield(L); }\n\n\n/* fetch an instruction and prepare its execution */\n#define vmfetch()\t{ \\\n  if (l_unlikely(trap)) {  /* stack reallocation or hooks? */ \\\n    trap = luaG_traceexec(L, pc);  /* handle hooks */ \\\n    updatebase(ci);  /* correct stack */ \\\n  } \\\n  i = *(pc++); \\\n}\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l)\tcase l:\n#define vmbreak\t\tbreak\n\n\nvoid luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap)) {\n    if (pc == cl->p->code) {  /* first instruction (not resuming)? */\n      if (cl->p->is_vararg)\n        trap = 0;  /* hooks will start after VARARGPREP instruction */\n      else  /* check 'call' hook */\n        luaD_hookcall(L, ci);\n    }\n    ci->u.l.trap = 1;  /* assume trap is on, for now */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top <= L->stack_last);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        StkId ra = RA(i);\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        StkId ra = RA(i);\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        StkId ra = RA(i);\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        StkId ra = RA(i);\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        StkId ra = RA(i);\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        StkId ra = RA(i);\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        StkId ra = RA(i);\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        StkId ra = RA(i);\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        StkId ra = RA(i);\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        StkId ra = RA(i);\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        StkId ra = RA(i);\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        StkId ra = RA(i);\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        StkId ra = RA(i);\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        StkId ra = RA(i);\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        StkId ra = RA(i);\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            StkId ra = RA(i);\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        StkId ra = RA(i);\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        StkId ra = RA(i);\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n       StkId ra = RA(i);\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall: {\n        StkId ra = RA(i);\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }}\n      vmcase(OP_TFORLOOP) {\n       l_tforloop: {\n        StkId ra = RA(i);\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }}\n      vmcase(OP_SETLIST) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        StkId ra = RA(i);\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        StkId ra = RA(i);\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n\n/* }================================================================== */\n"], "fixing_code": ["/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n\n\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** Base lines are regularly placed at MAXIWTHABS intervals, so usually\n** an integer division gets the right place. When the source file has\n** large sequences of empty/comment lines, it may need extra entries,\n** so the original estimate needs a correction.\n** If the original estimate is -1, the initial 'if' ensures that the\n** 'while' will run at least once.\n** The assertion that the estimate is a lower bound for the correct base\n** is valid as long as the debug info has been generated with the same\n** value for MAXIWTHABS or smaller. (Previous releases use a little\n** smaller value.)\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    int i = cast_uint(pc) / MAXIWTHABS - 1;  /* get an estimate */\n    /* estimate must be a lower bound of the correct base */\n    lua_assert(i < 0 ||\n              (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));\n    while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)\n      i++;  /* low estimate; adjust it */\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getstr(p->source);\n      ar->srclen = tsslen(p->source);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(s2v(L->top));\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top, t);  /* push it on stack */\n    api_incr_top(L);\n    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n    if (!p->is_vararg)  /* regular function? */\n      i = 0;  /* consider all instructions */\n    else {  /* vararg function */\n      lua_assert(GET_OPCODE(p->code[0]) == OP_VARARGPREP);\n      currentline = nextline(p, currentline, 0);\n      i = 1;  /* skip first instruction (OP_VARARGPREP) */\n    }\n    for (; i < p->sizelineinfo; i++) {  /* for each instruction */\n      currentline = nextline(p, currentline, i);  /* get its line */\n      luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  /* calling function is a known function? */\n  if (ci != NULL && !(ci->callstatus & CIST_TAIL))\n    return funcnamefromcall(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_TRAN))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = ci->u2.transferinfo.ftransfer;\n          ar->ntransfer = ci->u2.transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic void kname (const Proto *p, int c, const char **name) {\n  TValue *kvalue = &p->k[c];\n  *name = (ttisstring(kvalue)) ? svalue(kvalue) : \"?\";\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = getobjname(p, pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *gxf (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is an upvalue? */\n    name = upvalname(p, t);\n  else\n    getobjname(p, pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, pc, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        rkname(p, pc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, const Proto *p,\n                                     int pc, const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  Instruction i = p->code[pc];  /* calling instruction */\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    /* no cases for OP_EQI and OP_EQK, as they don't call metamethods */\n    case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;\n    case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;\n    case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n\n/*\n** Try to find a name for a function based on how it was called.\n*/\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name) {\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  else if (ci->callstatus & CIST_FIN) {  /* was it called as a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  else if (isLua(ci))\n    return funcnamefromcode(L, ci_func(ci)->p, currentpc(ci), name);\n  else\n    return NULL;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** Check whether pointer 'o' points to some value in the stack\n** frame of the current function. Because 'o' may not point to a\n** value in this stack, we cannot compare it with the region\n** boundaries (undefined behaviour in ISO C).\n*/\nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId pos;\n  for (pos = ci->func + 1; pos < ci->top; pos++) {\n    if (o == s2v(pos))\n      return 1;\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *formatvarinfo (lua_State *L, const char *kind,\n                                                const char *name) {\n  if (kind == NULL)\n    return \"\";  /* no information */\n  else\n    return luaO_pushfstring(L, \" (%s '%s')\", kind, name);\n}\n\n/*\n** Build a string with a \"description\" for the value 'o', such as\n** \"variable 'x'\" or \"upvalue 'y'\".\n*/\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind && isinstack(ci, o))  /* no? try a register */\n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(cast(StkId, o) - (ci->func + 1)), &name);\n  }\n  return formatvarinfo(L, kind, name);\n}\n\n\n/*\n** Raise a type error\n*/\nstatic l_noret typeerror (lua_State *L, const TValue *o, const char *op,\n                          const char *extra) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, extra);\n}\n\n\n/*\n** Raise a type error with \"standard\" information about the faulty\n** object 'o' (using 'varinfo').\n*/\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  typeerror(L, o, op, varinfo(L, o));\n}\n\n\n/*\n** Raise an error for calling a non-callable object. Try to find a name\n** for the object based on how it was called ('funcnamefromcall'); if it\n** cannot get a name there, try 'varinfo'.\n*/\nl_noret luaG_callerror (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = funcnamefromcall(L, ci, &name);\n  const char *extra = kind ? formatvarinfo(L, kind, name) : varinfo(L, o);\n  typeerror(L, o, \"call\", extra);\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!luaV_tointegerns(p1, &temp, LUA_FLOORN2I))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src)\n    luaO_chunkid(buff, getstr(src), tsslen(src));\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci)) {  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n    setobjs2s(L, L->top - 2, L->top - 1);  /* remove 'msg' from the stack */\n    L->top--;\n  }\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'. More often than not, 'newpc' is only\n** one or a few instructions after 'oldpc' (it must be after, see\n** caller), so try to avoid calling 'luaG_getfuncline'. If they are\n** too far apart, there is a good chance of a ABSLINEINFO in the way,\n** so it goes directly to 'luaG_getfuncline'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */\n    int delta = 0;  /* line diference */\n    int pc = oldpc;\n    for (;;) {\n      int lineinfo = p->lineinfo[++pc];\n      if (lineinfo == ABSLINEINFO)\n        break;  /* cannot compute delta; fall through */\n      delta += lineinfo;\n      if (pc == newpc)\n        return (delta != 0);  /* delta computed successfully */\n    }\n  }\n  /* either instructions are too far apart or there is an absolute line\n     info in the way; compute line difference explicitly */\n  return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line whatever\n** the value of 'oldpc'.  Some exceptional conditions may return to\n** a function without setting 'oldpc'. In that case, 'oldpc' may be\n** invalid; if so, use zero as a valid value. (A wrong but valid 'oldpc'\n** at most causes an extra call to a line hook.)\n** This function is not \"Protected\" when called, so it should correct\n** 'L->top' before calling anything that can run the GC.\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */\n    L->top = ci->top;  /* correct top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    /* 'L->oldpc' may be invalid; use zero in this case */\n    int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n    int npci = pcRel(pc, p);\n    if (npci <= oldpc ||  /* call hook when jump back (loop), */\n        changedline(p, oldpc, npci)) {  /* or when enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n", "/*\n** $Id: lvm.c $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lvm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n/*\n** By default, use jump tables in the main interpreter loop on gcc\n** and compatible compilers.\n*/\n#if !defined(LUA_USE_JUMPTABLE)\n#if defined(__GNUC__)\n#define LUA_USE_JUMPTABLE\t1\n#else\n#define LUA_USE_JUMPTABLE\t0\n#endif\n#endif\n\n\n\n/* limit for table tag-method chains (to avoid infinite loops) */\n#define MAXTAGLOOP\t2000\n\n\n/*\n** 'l_intfitsf' checks whether a given integer is in the range that\n** can be converted to a float without rounding. Used in comparisons.\n*/\n\n/* number of bits in the mantissa of a float */\n#define NBM\t\t(l_floatatt(MANT_DIG))\n\n/*\n** Check whether some integers may not fit in a float, testing whether\n** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)\n** (The shifts are done in parts, to avoid shifting by more than the size\n** of an integer. In a worst case, NBM == 113 for long double and\n** sizeof(long) == 32.)\n*/\n#if ((((LUA_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \\\n\t>> (NBM - (3 * (NBM / 4))))  >  0\n\n/* limit for integers that fit in a float */\n#define MAXINTFITSF\t((lua_Unsigned)1 << NBM)\n\n/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */\n#define l_intfitsf(i)\t((MAXINTFITSF + l_castS2U(i)) <= (2 * MAXINTFITSF))\n\n#else  /* all integers fit in a float precisely */\n\n#define l_intfitsf(i)\t1\n\n#endif\n\n\n/*\n** Try to convert a value from string to a number value.\n** If the value is not a string or is a string not representing\n** a valid numeral (or if coercions from strings to numbers\n** are disabled via macro 'cvt2num'), do not modify 'result'\n** and return 0.\n*/\nstatic int l_strton (const TValue *obj, TValue *result) {\n  lua_assert(obj != result);\n  if (!cvt2num(obj))  /* is object not a string? */\n    return 0;\n  else\n    return (luaO_str2num(svalue(obj), result) == vslen(obj) + 1);\n}\n\n\n/*\n** Try to convert a value to a float. The float case is already handled\n** by the macro 'tonumber'.\n*/\nint luaV_tonumber_ (const TValue *obj, lua_Number *n) {\n  TValue v;\n  if (ttisinteger(obj)) {\n    *n = cast_num(ivalue(obj));\n    return 1;\n  }\n  else if (l_strton(obj, &v)) {  /* string coercible to number? */\n    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */\n    return 1;\n  }\n  else\n    return 0;  /* conversion failed */\n}\n\n\n/*\n** try to convert a float to an integer, rounding according to 'mode'.\n*/\nint luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode) {\n  lua_Number f = l_floor(n);\n  if (n != f) {  /* not an integral value? */\n    if (mode == F2Ieq) return 0;  /* fails if mode demands integral value */\n    else if (mode == F2Iceil)  /* needs ceil? */\n      f += 1;  /* convert floor to ceil (remember: n != f) */\n  }\n  return lua_numbertointeger(f, p);\n}\n\n\n/*\n** try to convert a value to an integer, rounding according to 'mode',\n** without string coercion.\n** (\"Fast track\" handled by macro 'tointegerns'.)\n*/\nint luaV_tointegerns (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  if (ttisfloat(obj))\n    return luaV_flttointeger(fltvalue(obj), p, mode);\n  else if (ttisinteger(obj)) {\n    *p = ivalue(obj);\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** try to convert a value to an integer.\n*/\nint luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  TValue v;\n  if (l_strton(obj, &v))  /* does 'obj' point to a numerical string? */\n    obj = &v;  /* change it to point to its corresponding number */\n  return luaV_tointegerns(obj, p, mode);\n}\n\n\n/*\n** Try to convert a 'for' limit to an integer, preserving the semantics\n** of the loop. Return true if the loop must not run; otherwise, '*p'\n** gets the integer limit.\n** (The following explanation assumes a positive step; it is valid for\n** negative steps mutatis mutandis.)\n** If the limit is an integer or can be converted to an integer,\n** rounding down, that is the limit.\n** Otherwise, check whether the limit can be converted to a float. If\n** the float is too large, clip it to LUA_MAXINTEGER.  If the float\n** is too negative, the loop should not run, because any initial\n** integer value is greater than such limit; so, the function returns\n** true to signal that. (For this latter case, no integer limit would be\n** correct; even a limit of LUA_MININTEGER would run the loop once for\n** an initial value equal to LUA_MININTEGER.)\n*/\nstatic int forlimit (lua_State *L, lua_Integer init, const TValue *lim,\n                                   lua_Integer *p, lua_Integer step) {\n  if (!luaV_tointeger(lim, p, (step < 0 ? F2Iceil : F2Ifloor))) {\n    /* not coercible to in integer */\n    lua_Number flim;  /* try to convert to float */\n    if (!tonumber(lim, &flim)) /* cannot convert to float? */\n      luaG_forerror(L, lim, \"limit\");\n    /* else 'flim' is a float out of integer bounds */\n    if (luai_numlt(0, flim)) {  /* if it is positive, it is too large */\n      if (step < 0) return 1;  /* initial value must be less than it */\n      *p = LUA_MAXINTEGER;  /* truncate */\n    }\n    else {  /* it is less than min integer */\n      if (step > 0) return 1;  /* initial value must be greater than it */\n      *p = LUA_MININTEGER;  /* truncate */\n    }\n  }\n  return (step > 0 ? init > *p : init < *p);  /* not to run? */\n}\n\n\n/*\n** Prepare a numerical for loop (opcode OP_FORPREP).\n** Return true to skip the loop. Otherwise,\n** after preparation, stack will be as follows:\n**   ra : internal index (safe copy of the control variable)\n**   ra + 1 : loop counter (integer loops) or limit (float loops)\n**   ra + 2 : step\n**   ra + 3 : control variable\n*/\nstatic int forprep (lua_State *L, StkId ra) {\n  TValue *pinit = s2v(ra);\n  TValue *plimit = s2v(ra + 1);\n  TValue *pstep = s2v(ra + 2);\n  if (ttisinteger(pinit) && ttisinteger(pstep)) { /* integer loop? */\n    lua_Integer init = ivalue(pinit);\n    lua_Integer step = ivalue(pstep);\n    lua_Integer limit;\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    setivalue(s2v(ra + 3), init);  /* control variable */\n    if (forlimit(L, init, plimit, &limit, step))\n      return 1;  /* skip the loop */\n    else {  /* prepare loop counter */\n      lua_Unsigned count;\n      if (step > 0) {  /* ascending loop? */\n        count = l_castS2U(limit) - l_castS2U(init);\n        if (step != 1)  /* avoid division in the too common case */\n          count /= l_castS2U(step);\n      }\n      else {  /* step < 0; descending loop */\n        count = l_castS2U(init) - l_castS2U(limit);\n        /* 'step+1' avoids negating 'mininteger' */\n        count /= l_castS2U(-(step + 1)) + 1u;\n      }\n      /* store the counter in place of the limit (which won't be\n         needed anymore) */\n      setivalue(plimit, l_castU2S(count));\n    }\n  }\n  else {  /* try making all values floats */\n    lua_Number init; lua_Number limit; lua_Number step;\n    if (l_unlikely(!tonumber(plimit, &limit)))\n      luaG_forerror(L, plimit, \"limit\");\n    if (l_unlikely(!tonumber(pstep, &step)))\n      luaG_forerror(L, pstep, \"step\");\n    if (l_unlikely(!tonumber(pinit, &init)))\n      luaG_forerror(L, pinit, \"initial value\");\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (luai_numlt(0, step) ? luai_numlt(limit, init)\n                            : luai_numlt(init, limit))\n      return 1;  /* skip the loop */\n    else {\n      /* make sure internal values are all floats */\n      setfltvalue(plimit, limit);\n      setfltvalue(pstep, step);\n      setfltvalue(s2v(ra), init);  /* internal index */\n      setfltvalue(s2v(ra + 3), init);  /* control variable */\n    }\n  }\n  return 0;\n}\n\n\n/*\n** Execute a step of a float numerical for loop, returning\n** true iff the loop must continue. (The integer case is\n** written online with opcode OP_FORLOOP, for performance.)\n*/\nstatic int floatforloop (StkId ra) {\n  lua_Number step = fltvalue(s2v(ra + 2));\n  lua_Number limit = fltvalue(s2v(ra + 1));\n  lua_Number idx = fltvalue(s2v(ra));  /* internal index */\n  idx = luai_numadd(L, idx, step);  /* increment index */\n  if (luai_numlt(0, step) ? luai_numle(idx, limit)\n                          : luai_numle(limit, idx)) {\n    chgfltvalue(s2v(ra), idx);  /* update internal index */\n    setfltvalue(s2v(ra + 3), idx);  /* and control variable */\n    return 1;  /* jump back */\n  }\n  else\n    return 0;  /* finish the loop */\n}\n\n\n/*\n** Finish the table access 'val = t[key]'.\n** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to\n** t[k] entry (which must be empty).\n*/\nvoid luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,\n                      const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  const TValue *tm;  /* metamethod */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    if (slot == NULL) {  /* 't' is not a table? */\n      lua_assert(!ttistable(t));\n      tm = luaT_gettmbyobj(L, t, TM_INDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");  /* no metamethod */\n      /* else will try the metamethod */\n    }\n    else {  /* 't' is a table */\n      lua_assert(isempty(slot));\n      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        setnilvalue(s2v(val));  /* result is nil */\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    if (ttisfunction(tm)) {  /* is metamethod a function? */\n      luaT_callTMres(L, tm, t, key, val);  /* call it */\n      return;\n    }\n    t = tm;  /* else try to access 'tm[key]' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {  /* fast track? */\n      setobj2s(L, val, slot);  /* done */\n      return;\n    }\n    /* else repeat (tail call 'luaV_finishget') */\n  }\n  luaG_runerror(L, \"'__index' chain too long; possible loop\");\n}\n\n\n/*\n** Finish a table assignment 't[key] = val'.\n** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points\n** to the entry 't[key]', or to a value with an absent key if there\n** is no such entry.  (The value at 'slot' must be empty, otherwise\n** 'luaV_fastget' would have done the job.)\n*/\nvoid luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                     TValue *val, const TValue *slot) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (slot != NULL) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      lua_assert(isempty(slot));  /* slot must be empty */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, slot, val);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    if (luaV_fastget(L, t, key, slot, luaH_get)) {\n      luaV_finishfastset(L, t, slot, val);\n      return;  /* done */\n    }\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}\n\n\n/*\n** Compare two strings 'ls' x 'rs', returning an integer less-equal-\n** -greater than zero if 'ls' is less-equal-greater than 'rs'.\n** The code is a little tricky because it allows '\\0' in the strings\n** and it uses 'strcoll' (to respect locales) for each segments\n** of the strings.\n*/\nstatic int l_strcmp (const TString *ls, const TString *rs) {\n  const char *l = getstr(ls);\n  size_t ll = tsslen(ls);\n  const char *r = getstr(rs);\n  size_t lr = tsslen(rs);\n  for (;;) {  /* for each segment */\n    int temp = strcoll(l, r);\n    if (temp != 0)  /* not equal? */\n      return temp;  /* done */\n    else {  /* strings are equal up to a '\\0' */\n      size_t len = strlen(l);  /* index of first '\\0' in both strings */\n      if (len == lr)  /* 'rs' is finished? */\n        return (len == ll) ? 0 : 1;  /* check 'ls' */\n      else if (len == ll)  /* 'ls' is finished? */\n        return -1;  /* 'ls' is less than 'rs' ('rs' is not finished) */\n      /* both strings longer than 'len'; go on comparing after the '\\0' */\n      len++;\n      l += len; ll -= len; r += len; lr -= len;\n    }\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than float 'f'. If 'i' has an\n** exact representation as a float ('l_intfitsf'), compare numbers as\n** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.\n** If 'ceil(f)' is out of integer range, either 'f' is greater than\n** all integers or less than all integers.\n** (The test with 'l_intfitsf' is only for performance; the else\n** case is correct for all values, but it is slow due to the conversion\n** from float to int.)\n** When 'f' is NaN, comparisons must result in false.\n*/\nl_sinline int LTintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numlt(cast_num(i), f);  /* compare them as floats */\n  else {  /* i < f <=> i < ceil(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return i < fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than or equal to float 'f'.\n** See comments on previous function.\n*/\nl_sinline int LEintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numle(cast_num(i), f);  /* compare them as floats */\n  else {  /* i <= f <=> i <= floor(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return i <= fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LTfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numlt(f, cast_num(i));  /* compare them as floats */\n  else {  /* f < i <=> floor(f) < i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return fi < i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than or equal to integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LEfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numle(f, cast_num(i));  /* compare them as floats */\n  else {  /* f <= i <=> ceil(f) <= i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return fi <= i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Return 'l < r', for numbers.\n*/\nl_sinline int LTnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li < ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LTintfloat(li, fltvalue(r));  /* l < r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numlt(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LTfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** Return 'l <= r', for numbers.\n*/\nl_sinline int LEnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li <= ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LEintfloat(li, fltvalue(r));  /* l <= r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numle(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LEfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** return 'l < r' for non-numbers.\n*/\nstatic int lessthanothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LT);\n}\n\n\n/*\n** Main operation less than; return 'l < r'.\n*/\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LTnum(l, r);\n  else return lessthanothers(L, l, r);\n}\n\n\n/*\n** return 'l <= r' for non-numbers.\n*/\nstatic int lessequalothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LE);\n}\n\n\n/*\n** Main operation less than or equal to; return 'l <= r'.\n*/\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LEnum(l, r);\n  else return lessequalothers(L, l, r);\n}\n\n\n/*\n** Main operation for equality of Lua values; return 't1 == t2'.\n** L == NULL means raw equality (no metamethods)\n*/\nint luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  if (ttypetag(t1) != ttypetag(t2)) {  /* not the same variant? */\n    if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)\n      return 0;  /* only numbers can be equal with different variants */\n    else {  /* two numbers with different variants */\n      /* One of them is an integer. If the other does not have an\n         integer value, they cannot be equal; otherwise, compare their\n         integer values. */\n      lua_Integer i1, i2;\n      return (luaV_tointegerns(t1, &i1, F2Ieq) &&\n              luaV_tointegerns(t2, &i2, F2Ieq) &&\n              i1 == i2);\n    }\n  }\n  /* values have same type and same variant */\n  switch (ttypetag(t1)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE: return 1;\n    case LUA_VNUMINT: return (ivalue(t1) == ivalue(t2));\n    case LUA_VNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));\n    case LUA_VLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_VLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_VSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_VTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL)  /* no TM? */\n    return 0;  /* objects are different */\n  else {\n    luaT_callTMres(L, tm, t1, t2, L->top);  /* call TM */\n    return !l_isfalse(s2v(L->top));\n  }\n}\n\n\n/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */\n#define tostring(L,o)  \\\n\t(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))\n\n#define isemptystr(o)\t(ttisshrstring(o) && tsvalue(o)->shrlen == 0)\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nstatic void copy2buff (StkId top, int n, char *buff) {\n  size_t tl = 0;  /* size already copied */\n  do {\n    size_t l = vslen(s2v(top - n));  /* length of string being copied */\n    memcpy(buff + tl, svalue(s2v(top - n)), l * sizeof(char));\n    tl += l;\n  } while (--n > 0);\n}\n\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top - total' up to 'L->top - 1'.\n*/\nvoid luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl)) {\n          L->top = top - total;  /* pop strings to avoid wasting stack */\n          luaG_runerror(L, \"string length overflow\");\n        }\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n-1;  /* got 'n' strings to create 1 new */\n    L->top = top - (n - 1);  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n\n\n/*\n** Main operation 'ra = #rb'.\n*/\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypetag(rb)) {\n    case LUA_VTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;  /* metamethod? break switch to call it */\n      setivalue(s2v(ra), luaH_getn(h));  /* else primitive len */\n      return;\n    }\n    case LUA_VSHRSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->shrlen);\n      return;\n    }\n    case LUA_VLNGSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->u.lnglen);\n      return;\n    }\n    default: {  /* try metamethod */\n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (l_unlikely(notm(tm)))  /* no metamethod? */\n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  luaT_callTMres(L, tm, rb, rb, ra);\n}\n\n\n/*\n** Integer division; return 'm // n', that is, floor(m/n).\n** C division truncates its result (rounds towards zero).\n** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,\n** otherwise 'floor(q) == trunc(q) - 1'.\n*/\nlua_Integer luaV_idiv (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to divide by zero\");\n    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */\n  }\n  else {\n    lua_Integer q = m / n;  /* perform C division */\n    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */\n      q -= 1;  /* correct result for different rounding */\n    return q;\n  }\n}\n\n\n/*\n** Integer modulus; return 'm % n'. (Assume that C '%' with\n** negative operands follows C99 behavior. See previous comment\n** about luaV_idiv.)\n*/\nlua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to perform 'n%%0'\");\n    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */\n  }\n  else {\n    lua_Integer r = m % n;\n    if (r != 0 && (r ^ n) < 0)  /* 'm/n' would be non-integer negative? */\n      r += n;  /* correct result for different rounding */\n    return r;\n  }\n}\n\n\n/*\n** Float modulus\n*/\nlua_Number luaV_modf (lua_State *L, lua_Number m, lua_Number n) {\n  lua_Number r;\n  luai_nummod(L, m, n, r);\n  return r;\n}\n\n\n/* number of bits in an integer */\n#define NBITS\tcast_int(sizeof(lua_Integer) * CHAR_BIT)\n\n/*\n** Shift left operation. (Shift right just negates 'y'.)\n*/\n#define luaV_shiftr(x,y)\tluaV_shiftl(x,intop(-, 0, y))\n\n\nlua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {\n  if (y < 0) {  /* shift right? */\n    if (y <= -NBITS) return 0;\n    else return intop(>>, x, -y);\n  }\n  else {  /* shift left */\n    if (y >= NBITS) return 0;\n    else return intop(<<, x, y);\n  }\n}\n\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  LClosure *ncl = luaF_newLclosure(L, nup);\n  ncl->p = p;\n  setclLvalue2s(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->upvals[i] = encup[uv[i].idx];\n    luaC_objbarrier(L, ncl, ncl->upvals[i]);\n  }\n}\n\n\n/*\n** finish execution of an opcode interrupted by a yield\n*/\nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->func + 1;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      setobjs2s(L, base + GETARG_A(*(ci->u.l.savedpc - 2)), --L->top);\n      break;\n    }\n    case OP_UNM: case OP_BNOT: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_GETI:\n    case OP_GETFIELD: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LT: case OP_LE:\n    case OP_LTI: case OP_LEI:\n    case OP_GTI: case OP_GEI:\n    case OP_EQ: {  /* note that 'OP_EQI'/'OP_EQK' cannot yield */\n      int res = !l_isfalse(s2v(L->top - 1));\n      L->top--;\n#if defined(LUA_COMPAT_LT_LE)\n      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n        res = !res;  /* negate result */\n      }\n#endif\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_k(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'luaT_tryconcatTM' was called */\n      int a = GETARG_A(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + a));  /* yet to concatenate */\n      setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n      L->top = top - 1;  /* top is one after last element (at top-2) */\n      luaV_concat(L, total);  /* concat them (may yield again) */\n      break;\n    }\n    case OP_CLOSE: {  /* yielded closing variables */\n      ci->u.l.savedpc--;  /* repeat instruction to close other vars. */\n      break;\n    }\n    case OP_RETURN: {  /* yielded closing variables */\n      StkId ra = base + GETARG_A(inst);\n      /* adjust top to signal correct number of returns, in case the\n         return is \"up to top\" ('isIT') */\n      L->top = ra + ci->u2.nres;\n      /* repeat instruction to close other vars. and complete the return */\n      ci->u.l.savedpc--;\n      break;\n    }\n    default: {\n      /* only these other opcodes can yield */\n      lua_assert(op == OP_TFORCALL || op == OP_CALL ||\n           op == OP_TAILCALL || op == OP_SETTABUP || op == OP_SETTABLE ||\n           op == OP_SETI || op == OP_SETFIELD);\n      break;\n    }\n  }\n}\n\n\n\n\n/*\n** {==================================================================\n** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'\n** ===================================================================\n*/\n\n#define l_addi(L,a,b)\tintop(+, a, b)\n#define l_subi(L,a,b)\tintop(-, a, b)\n#define l_muli(L,a,b)\tintop(*, a, b)\n#define l_band(a,b)\tintop(&, a, b)\n#define l_bor(a,b)\tintop(|, a, b)\n#define l_bxor(a,b)\tintop(^, a, b)\n\n#define l_lti(a,b)\t(a < b)\n#define l_lei(a,b)\t(a <= b)\n#define l_gti(a,b)\t(a > b)\n#define l_gei(a,b)\t(a >= b)\n\n\n/*\n** Arithmetic operations with immediate operands. 'iop' is the integer\n** operation, 'fop' is the float operation.\n*/\n#define op_arithI(L,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  int imm = GETARG_sC(i);  \\\n  if (ttisinteger(v1)) {  \\\n    lua_Integer iv1 = ivalue(v1);  \\\n    pc++; setivalue(s2v(ra), iop(L, iv1, imm));  \\\n  }  \\\n  else if (ttisfloat(v1)) {  \\\n    lua_Number nb = fltvalue(v1);  \\\n    lua_Number fimm = cast_num(imm);  \\\n    pc++; setfltvalue(s2v(ra), fop(L, nb, fimm)); \\\n  }}\n\n\n/*\n** Auxiliary function for arithmetic operations over floats and others\n** with two register operands.\n*/\n#define op_arithf_aux(L,v1,v2,fop) {  \\\n  lua_Number n1; lua_Number n2;  \\\n  if (tonumberns(v1, n1) && tonumberns(v2, n2)) {  \\\n    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \\\n  }}\n\n\n/*\n** Arithmetic operations over floats and others with register operands.\n*/\n#define op_arithf(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with K operands for floats.\n*/\n#define op_arithfK(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations over integers and floats.\n*/\n#define op_arith_aux(L,v1,v2,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  if (ttisinteger(v1) && ttisinteger(v2)) {  \\\n    lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);  \\\n    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \\\n  }  \\\n  else op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with register operands.\n*/\n#define op_arith(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Arithmetic operations with K operands.\n*/\n#define op_arithK(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Bitwise operations with constant operand.\n*/\n#define op_bitwiseK(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i);  \\\n  lua_Integer i1;  \\\n  lua_Integer i2 = ivalue(v2);  \\\n  if (tointegerns(v1, &i1)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Bitwise operations with register operands.\n*/\n#define op_bitwise(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  lua_Integer i1; lua_Integer i2;  \\\n  if (tointegerns(v1, &i1) && tointegerns(v2, &i2)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Order operations with register operands. 'opn' actually works\n** for all numbers, but the fast track improves performance for\n** integers.\n*/\n#define op_order(L,opi,opn,other) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  TValue *rb = vRB(i);  \\\n  if (ttisinteger(s2v(ra)) && ttisinteger(rb)) {  \\\n    lua_Integer ia = ivalue(s2v(ra));  \\\n    lua_Integer ib = ivalue(rb);  \\\n    cond = opi(ia, ib);  \\\n  }  \\\n  else if (ttisnumber(s2v(ra)) && ttisnumber(rb))  \\\n    cond = opn(s2v(ra), rb);  \\\n  else  \\\n    Protect(cond = other(L, s2v(ra), rb));  \\\n  docondjump(); }\n\n\n/*\n** Order operations with immediate operand. (Immediate operand is\n** always small enough to have an exact representation as a float.)\n*/\n#define op_orderI(L,opi,opf,inv,tm) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  int im = GETARG_sB(i);  \\\n  if (ttisinteger(s2v(ra)))  \\\n    cond = opi(ivalue(s2v(ra)), im);  \\\n  else if (ttisfloat(s2v(ra))) {  \\\n    lua_Number fa = fltvalue(s2v(ra));  \\\n    lua_Number fim = cast_num(im);  \\\n    cond = opf(fa, fim);  \\\n  }  \\\n  else {  \\\n    int isf = GETARG_C(i);  \\\n    Protect(cond = luaT_callorderiTM(L, s2v(ra), im, inv, isf, tm));  \\\n  }  \\\n  docondjump(); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Function 'luaV_execute': main interpreter loop\n** ===================================================================\n*/\n\n/*\n** some macros for common tasks in 'luaV_execute'\n*/\n\n\n#define RA(i)\t(base+GETARG_A(i))\n#define RB(i)\t(base+GETARG_B(i))\n#define vRB(i)\ts2v(RB(i))\n#define KB(i)\t(k+GETARG_B(i))\n#define RC(i)\t(base+GETARG_C(i))\n#define vRC(i)\ts2v(RC(i))\n#define KC(i)\t(k+GETARG_C(i))\n#define RKC(i)\t((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))\n\n\n\n#define updatetrap(ci)  (trap = ci->u.l.trap)\n\n#define updatebase(ci)\t(base = ci->func + 1)\n\n\n#define updatestack(ci)  \\\n\t{ if (l_unlikely(trap)) { updatebase(ci); ra = RA(i); } }\n\n\n/*\n** Execute a jump instruction. The 'updatetrap' allows signals to stop\n** tight loops. (Without it, the local copy of 'trap' could never change.)\n*/\n#define dojump(ci,i,e)\t{ pc += GETARG_sJ(i) + e; updatetrap(ci); }\n\n\n/* for test instructions, execute the jump instruction that follows it */\n#define donextjump(ci)\t{ Instruction ni = *pc; dojump(ci, ni, 1); }\n\n/*\n** do a conditional jump: skip next instruction if 'cond' is not what\n** was expected (parameter 'k'), else do next instruction, which must\n** be a jump.\n*/\n#define docondjump()\tif (cond != GETARG_k(i)) pc++; else donextjump(ci);\n\n\n/*\n** Correct global 'pc'.\n*/\n#define savepc(L)\t(ci->u.l.savedpc = pc)\n\n\n/*\n** Whenever code can raise errors, the global 'pc' and the global\n** 'top' must be correct to report occasional errors.\n*/\n#define savestate(L,ci)\t\t(savepc(L), L->top = ci->top)\n\n\n/*\n** Protect code that, in general, can raise errors, reallocate the\n** stack, and change the hooks.\n*/\n#define Protect(exp)  (savestate(L,ci), (exp), updatetrap(ci))\n\n/* special version that does not change the top */\n#define ProtectNT(exp)  (savepc(L), (exp), updatetrap(ci))\n\n/*\n** Protect code that can only raise errors. (That is, it cannot change\n** the stack or hooks.)\n*/\n#define halfProtect(exp)  (savestate(L,ci), (exp))\n\n/* 'c' is the limit of live values in the stack */\n#define checkGC(L,c)  \\\n\t{ luaC_condGC(L, (savepc(L), L->top = (c)), \\\n                         updatetrap(ci)); \\\n           luai_threadyield(L); }\n\n\n/* fetch an instruction and prepare its execution */\n#define vmfetch()\t{ \\\n  if (l_unlikely(trap)) {  /* stack reallocation or hooks? */ \\\n    trap = luaG_traceexec(L, pc);  /* handle hooks */ \\\n    updatebase(ci);  /* correct stack */ \\\n  } \\\n  i = *(pc++); \\\n}\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l)\tcase l:\n#define vmbreak\t\tbreak\n\n\nvoid luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap)) {\n    if (pc == cl->p->code) {  /* first instruction (not resuming)? */\n      if (cl->p->is_vararg)\n        trap = 0;  /* hooks will start after VARARGPREP instruction */\n      else  /* check 'call' hook */\n        luaD_hookcall(L, ci);\n    }\n    ci->u.l.trap = 1;  /* assume trap is on, for now */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top <= L->stack_last);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        StkId ra = RA(i);\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        StkId ra = RA(i);\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        StkId ra = RA(i);\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        StkId ra = RA(i);\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        StkId ra = RA(i);\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        StkId ra = RA(i);\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        StkId ra = RA(i);\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        StkId ra = RA(i);\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        StkId ra = RA(i);\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        StkId ra = RA(i);\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        StkId ra = RA(i);\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        StkId ra = RA(i);\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        StkId ra = RA(i);\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        StkId ra = RA(i);\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        StkId ra = RA(i);\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        StkId ra = RA(i);\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            StkId ra = RA(i);\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        StkId ra = RA(i);\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        StkId ra = RA(i);\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n       StkId ra = RA(i);\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall: {\n        StkId ra = RA(i);\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }}\n      vmcase(OP_TFORLOOP) {\n       l_tforloop: {\n        StkId ra = RA(i);\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }}\n      vmcase(OP_SETLIST) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        StkId ra = RA(i);\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        StkId ra = RA(i);\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n\n/* }================================================================== */\n"], "filenames": ["ldebug.c", "lvm.c"], "buggy_code_start_loc": [827, 659], "buggy_code_end_loc": [828, 676], "fixing_code_start_loc": [827, 659], "fixing_code_end_loc": [832, 678], "type": "CWE-787", "message": "An issue in the component luaG_runerror of Lua v5.4.4 and below leads to a heap-buffer overflow when a recursive error occurs.", "other": {"cve": {"id": "CVE-2022-33099", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-01T12:15:08.173", "lastModified": "2022-11-05T03:03:15.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in the component luaG_runerror of Lua v5.4.4 and below leads to a heap-buffer overflow when a recursive error occurs."}, {"lang": "es", "value": "Un problema en el componente luaG_runerror de Lua versiones v5.4.4 y posteriores, conlleva a un desbordamiento del b\u00fafer de la pila cuando es producido un error recursivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.2", "versionEndIncluding": "5.4.4", "matchCriteriaId": "F95F18B2-CD16-4739-AAA3-F0FD69B97E2C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/lua/lua/commit/42d40581dd919fb134c07027ca1ce0844c670daf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RJNJ66IFDUKWJJZXHGOLRGIA3HWWC36R/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UHYZOEFDVLVAD6EEP4CDW6DNONIVVHPA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-05/msg00035.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Vendor Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-05/msg00042.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Vendor Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-05/msg00073.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Vendor Advisory"]}, {"url": "https://www.lua.org/bugs.html#Lua-stack%20overflow%20when%20C%20stack%20overflows%20while%20handling%20an%20error:~:text=Lua%2Dstack%20overflow%20when%20C%20stack%20overflows%20while%20handling%20an%20error", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/42d40581dd919fb134c07027ca1ce0844c670daf"}}