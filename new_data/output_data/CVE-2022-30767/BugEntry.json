{"buggy_code": ["/*\n * NFS support driver - based on etherboot and U-BOOT's tftp.c\n *\n * Masami Komiya <mkomiya@sonare.it> 2004\n *\n */\n\n/* NOTE: the NFS code is heavily inspired by the NetBSD netboot code (read:\n * large portions are copied verbatim) as distributed in OSKit 0.97.  A few\n * changes were necessary to adapt the code to Etherboot and to fix several\n * inconsistencies.  Also the RPC message preparation is done \"by hand\" to\n * avoid adding netsprintf() which I find hard to understand and use.  */\n\n/* NOTE 2: Etherboot does not care about things beyond the kernel image, so\n * it loads the kernel image off the boot server (ARP_SERVER) and does not\n * access the client root disk (root-path in dhcpd.conf), which would use\n * ARP_ROOTSERVER.  The root disk is something the operating system we are\n * about to load needs to use.\tThis is different from the OSKit 0.97 logic.  */\n\n/* NOTE 3: Symlink handling introduced by Anselm M Hoffmeister, 2003-July-14\n * If a symlink is encountered, it is followed as far as possible (recursion\n * possible, maximum 16 steps). There is no clearing of \"..\"'s inside the\n * path, so please DON'T DO THAT. thx. */\n\n/* NOTE 4: NFSv3 support added by Guillaume GARDET, 2016-June-20.\n * NFSv2 is still used by default. But if server does not support NFSv2, then\n * NFSv3 is used, if available on NFS server. */\n\n#include <common.h>\n#include <command.h>\n#include <net.h>\n#include <malloc.h>\n#include <mapmem.h>\n#include \"nfs.h\"\n#include \"bootp.h\"\n\n#define HASHES_PER_LINE 65\t/* Number of \"loading\" hashes per line\t*/\n#define NFS_RETRY_COUNT 30\n#ifndef CONFIG_NFS_TIMEOUT\n# define NFS_TIMEOUT 2000UL\n#else\n# define NFS_TIMEOUT CONFIG_NFS_TIMEOUT\n#endif\n\n#define NFS_RPC_ERR\t1\n#define NFS_RPC_DROP\t124\n\nstatic int fs_mounted;\nstatic unsigned long rpc_id;\nstatic int nfs_offset = -1;\nstatic int nfs_len;\nstatic ulong nfs_timeout = NFS_TIMEOUT;\n\nstatic char dirfh[NFS_FHSIZE];\t/* NFSv2 / NFSv3 file handle of directory */\nstatic char filefh[NFS3_FHSIZE]; /* NFSv2 / NFSv3 file handle */\nstatic int filefh3_length;\t/* (variable) length of filefh when NFSv3 */\n\nstatic enum net_loop_state nfs_download_state;\nstatic struct in_addr nfs_server_ip;\nstatic int nfs_server_mount_port;\nstatic int nfs_server_port;\nstatic int nfs_our_port;\nstatic int nfs_timeout_count;\nstatic int nfs_state;\n#define STATE_PRCLOOKUP_PROG_MOUNT_REQ\t1\n#define STATE_PRCLOOKUP_PROG_NFS_REQ\t2\n#define STATE_MOUNT_REQ\t\t\t3\n#define STATE_UMOUNT_REQ\t\t4\n#define STATE_LOOKUP_REQ\t\t5\n#define STATE_READ_REQ\t\t\t6\n#define STATE_READLINK_REQ\t\t7\n\nstatic char *nfs_filename;\nstatic char *nfs_path;\nstatic char nfs_path_buff[2048];\n\n#define NFSV2_FLAG 1\n#define NFSV3_FLAG 1 << 1\nstatic char supported_nfs_versions = NFSV2_FLAG | NFSV3_FLAG;\n\nstatic inline int store_block(uchar *src, unsigned offset, unsigned len)\n{\n\tulong newsize = offset + len;\n#ifdef CONFIG_SYS_DIRECT_FLASH_NFS\n\tint i, rc = 0;\n\n\tfor (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {\n\t\t/* start address in flash? */\n\t\tif (load_addr + offset >= flash_info[i].start[0]) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) { /* Flash is destination for this packet */\n\t\trc = flash_write((uchar *)src, (ulong)(load_addr+offset), len);\n\t\tif (rc) {\n\t\t\tflash_perror(rc);\n\t\t\treturn -1;\n\t\t}\n\t} else\n#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */\n\t{\n\t\tvoid *ptr = map_sysmem(load_addr + offset, len);\n\n\t\tmemcpy(ptr, src, len);\n\t\tunmap_sysmem(ptr);\n\t}\n\n\tif (net_boot_file_size < (offset + len))\n\t\tnet_boot_file_size = newsize;\n\treturn 0;\n}\n\nstatic char *basename(char *path)\n{\n\tchar *fname;\n\n\tfname = path + strlen(path) - 1;\n\twhile (fname >= path) {\n\t\tif (*fname == '/') {\n\t\t\tfname++;\n\t\t\tbreak;\n\t\t}\n\t\tfname--;\n\t}\n\treturn fname;\n}\n\nstatic char *dirname(char *path)\n{\n\tchar *fname;\n\n\tfname = basename(path);\n\t--fname;\n\t*fname = '\\0';\n\treturn path;\n}\n\n/**************************************************************************\nRPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries\n**************************************************************************/\nstatic uint32_t *rpc_add_credentials(uint32_t *p)\n{\n\t/* Here's the executive summary on authentication requirements of the\n\t * various NFS server implementations:\tLinux accepts both AUTH_NONE\n\t * and AUTH_UNIX authentication (also accepts an empty hostname field\n\t * in the AUTH_UNIX scheme).  *BSD refuses AUTH_NONE, but accepts\n\t * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX\n\t * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have\n\t * it (if the BOOTP/DHCP reply didn't give one, just use an empty\n\t * hostname).  */\n\n\t/* Provide an AUTH_UNIX credential.  */\n\t*p++ = htonl(1);\t\t/* AUTH_UNIX */\n\t*p++ = htonl(20);\t\t/* auth length */\n\t*p++ = 0;\t\t\t/* stamp */\n\t*p++ = 0;\t\t\t/* hostname string */\n\t*p++ = 0;\t\t\t/* uid */\n\t*p++ = 0;\t\t\t/* gid */\n\t*p++ = 0;\t\t\t/* auxiliary gid list */\n\n\t/* Provide an AUTH_NONE verifier.  */\n\t*p++ = 0;\t\t\t/* AUTH_NONE */\n\t*p++ = 0;\t\t\t/* auth length */\n\n\treturn p;\n}\n\n/**************************************************************************\nRPC_LOOKUP - Lookup RPC Port numbers\n**************************************************************************/\nstatic void rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)\n{\n\tstruct rpc_t rpc_pkt;\n\tunsigned long id;\n\tuint32_t *p;\n\tint pktlen;\n\tint sport;\n\n\tid = ++rpc_id;\n\trpc_pkt.u.call.id = htonl(id);\n\trpc_pkt.u.call.type = htonl(MSG_CALL);\n\trpc_pkt.u.call.rpcvers = htonl(2);\t/* use RPC version 2 */\n\trpc_pkt.u.call.prog = htonl(rpc_prog);\n\tswitch (rpc_prog) {\n\tcase PROG_NFS:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_pkt.u.call.vers = htonl(2);\t/* NFS v2 */\n\t\telse /* NFSV3_FLAG */\n\t\t\trpc_pkt.u.call.vers = htonl(3);\t/* NFS v3 */\n\t\tbreak;\n\tcase PROG_PORTMAP:\n\tcase PROG_MOUNT:\n\tdefault:\n\t\trpc_pkt.u.call.vers = htonl(2);\t/* portmapper is version 2 */\n\t}\n\trpc_pkt.u.call.proc = htonl(rpc_proc);\n\tp = (uint32_t *)&(rpc_pkt.u.call.data);\n\n\tif (datalen)\n\t\tmemcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));\n\n\tpktlen = (char *)p + datalen * sizeof(uint32_t) - (char *)&rpc_pkt;\n\n\tmemcpy((char *)net_tx_packet + net_eth_hdr_size() + IP_UDP_HDR_SIZE,\n\t       &rpc_pkt.u.data[0], pktlen);\n\n\tif (rpc_prog == PROG_PORTMAP)\n\t\tsport = SUNRPC_PORT;\n\telse if (rpc_prog == PROG_MOUNT)\n\t\tsport = nfs_server_mount_port;\n\telse\n\t\tsport = nfs_server_port;\n\n\tnet_send_udp_packet(net_server_ethaddr, nfs_server_ip, sport,\n\t\t\t    nfs_our_port, pktlen);\n}\n\n/**************************************************************************\nRPC_LOOKUP - Lookup RPC Port numbers\n**************************************************************************/\nstatic void rpc_lookup_req(int prog, int ver)\n{\n\tuint32_t data[16];\n\n\tdata[0] = 0; data[1] = 0;\t/* auth credential */\n\tdata[2] = 0; data[3] = 0;\t/* auth verifier */\n\tdata[4] = htonl(prog);\n\tdata[5] = htonl(ver);\n\tdata[6] = htonl(17);\t/* IP_UDP */\n\tdata[7] = 0;\n\trpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);\n}\n\n/**************************************************************************\nNFS_MOUNT - Mount an NFS Filesystem\n**************************************************************************/\nstatic void nfs_mount_req(char *path)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint pathlen;\n\n\tpathlen = strlen(path);\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\t*p++ = htonl(pathlen);\n\tif (pathlen & 3)\n\t\t*(p + pathlen / 4) = 0;\n\tmemcpy(p, path, pathlen);\n\tp += (pathlen + 3) / 4;\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);\n}\n\n/**************************************************************************\nNFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server\n**************************************************************************/\nstatic void nfs_umountall_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tif ((nfs_server_mount_port == -1) || (!fs_mounted))\n\t\t/* Nothing mounted, nothing to umount */\n\t\treturn;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);\n}\n\n/***************************************************************************\n * NFS_READLINK (AH 2003-07-14)\n * This procedure is called when read of the first block fails -\n * this probably happens when it's a directory or a symlink\n * In case of successful readlink(), the dirname is manipulated,\n * so that inside the nfs() function a recursion can be done.\n **************************************************************************/\nstatic void nfs_readlink_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t} else { /* NFSV3_FLAG */\n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t}\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_NFS, NFS_READLINK, data, len);\n}\n\n/**************************************************************************\nNFS_LOOKUP - Lookup Pathname\n**************************************************************************/\nstatic void nfs_lookup_req(char *fname)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint fnamelen;\n\n\tfnamelen = strlen(fname);\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\t\trpc_req(PROG_NFS, NFS_LOOKUP, data, len);\n\t} else {  /* NFSV3_FLAG */\n\t\t*p++ = htonl(NFS_FHSIZE);\t/* Dir handle length */\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\t\trpc_req(PROG_NFS, NFS3PROC_LOOKUP, data, len);\n\t}\n}\n\n/**************************************************************************\nNFS_READ - Read File on NFS Server\n**************************************************************************/\nstatic void nfs_read_req(int offset, int readlen)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t} else { /* NFSV3_FLAG */\n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t\t*p++ = htonl(0); /* offset is 64-bit long, so fill with 0 */\n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t}\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_NFS, NFS_READ, data, len);\n}\n\n/**************************************************************************\nRPC request dispatcher\n**************************************************************************/\nstatic void nfs_send(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_MOUNT, 1);\n\t\telse  /* NFSV3_FLAG */\n\t\t\trpc_lookup_req(PROG_MOUNT, 3);\n\t\tbreak;\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_NFS, 2);\n\t\telse  /* NFSV3_FLAG */\n\t\t\trpc_lookup_req(PROG_NFS, 3);\n\t\tbreak;\n\tcase STATE_MOUNT_REQ:\n\t\tnfs_mount_req(nfs_path);\n\t\tbreak;\n\tcase STATE_UMOUNT_REQ:\n\t\tnfs_umountall_req();\n\t\tbreak;\n\tcase STATE_LOOKUP_REQ:\n\t\tnfs_lookup_req(nfs_filename);\n\t\tbreak;\n\tcase STATE_READ_REQ:\n\t\tnfs_read_req(nfs_offset, nfs_len);\n\t\tbreak;\n\tcase STATE_READLINK_REQ:\n\t\tnfs_readlink_req();\n\t\tbreak;\n\t}\n}\n\n/**************************************************************************\nHandlers for the reply from server\n**************************************************************************/\n\nstatic int rpc_lookup_reply(int prog, uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tdebug(\"%s\\n\", __func__);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\n\tswitch (prog) {\n\tcase PROG_MOUNT:\n\t\tnfs_server_mount_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\tcase PROG_NFS:\n\t\tnfs_server_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfs_mount_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\n\tfs_mounted = 1;\n\t/*  NFSv2 and NFSv3 use same structure */\n\tmemcpy(dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\n\treturn 0;\n}\n\nstatic int nfs_umountall_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\n\tfs_mounted = 0;\n\tmemset(dirfh, 0, sizeof(dirfh));\n\n\treturn 0;\n}\n\nstatic int nfs_lookup_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tswitch (ntohl(rpc_pkt.u.reply.astatus)) {\n\t\tcase NFS_RPC_SUCCESS: /* Not an error */\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_MISMATCH:\n\t\t\t/* Remote can't support NFS version */\n\t\t\tswitch (ntohl(rpc_pkt.u.reply.data[0])) {\n\t\t\t/* Minimal supported NFS version */\n\t\t\tcase 3:\n\t\t\t\tdebug(\"*** Warning: NFS version not supported: Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tdebug(\"Will retry with NFSv3\\n\");\n\t\t\t\t/* Clear NFSV2_FLAG from supported versions */\n\t\t\t\tsupported_nfs_versions &= ~NFSV2_FLAG;\n\t\t\t\treturn -NFS_RPC_PROG_MISMATCH;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tputs(\"*** ERROR: NFS version not supported\");\n\t\t\t\tdebug(\": Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tputs(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_UNAVAIL:\n\t\tcase NFS_RPC_PROC_UNAVAIL:\n\t\tcase NFS_RPC_GARBAGE_ARGS:\n\t\tcase NFS_RPC_SYSTEM_ERR:\n\t\tdefault: /* Unknown error on 'accept state' flag */\n\t\t\tdebug(\"*** ERROR: accept state error (%d)\\n\",\n\t\t\t      ntohl(rpc_pkt.u.reply.astatus));\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\t} else {  /* NFSV3_FLAG */\n\t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\t\tif (filefh3_length > NFS3_FHSIZE)\n\t\t\tfilefh3_length  = NFS3_FHSIZE;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfs3_get_attributes_offset(uint32_t *data)\n{\n\tif (ntohl(data[1]) != 0) {\n\t\t/* 'attributes_follow' flag is TRUE,\n\t\t * so we have attributes on 21 dwords */\n\t\t/* Skip unused values :\n\t\t\ttype;\t32 bits value,\n\t\t\tmode;\t32 bits value,\n\t\t\tnlink;\t32 bits value,\n\t\t\tuid;\t32 bits value,\n\t\t\tgid;\t32 bits value,\n\t\t\tsize;\t64 bits value,\n\t\t\tused;\t64 bits value,\n\t\t\trdev;\t64 bits value,\n\t\t\tfsid;\t64 bits value,\n\t\t\tfileid;\t64 bits value,\n\t\t\tatime;\t64 bits value,\n\t\t\tmtime;\t64 bits value,\n\t\t\tctime;\t64 bits value,\n\t\t*/\n\t\treturn 22;\n\t} else {\n\t\t/* 'attributes_follow' flag is FALSE,\n\t\t * so we don't have any attributes */\n\t\treturn 1;\n\t}\n}\n\nstatic int nfs_readlink_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tint nfsv3_data_offset = 0;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy((unsigned char *)&rpc_pkt, pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\n\tif (!(supported_nfs_versions & NFSV2_FLAG)) { /* NFSV3_FLAG */\n\t\tnfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t}\n\n\t/* new path length */\n\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {\n\t\tint pathlen;\n\n\t\tstrcat(nfs_path, \"/\");\n\t\tpathlen = strlen(nfs_path);\n\t\tmemcpy(nfs_path + pathlen,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[pathlen + rlen] = 0;\n\t} else {\n\t\tmemcpy(nfs_path,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n\treturn 0;\n}\n\nstatic int nfs_read_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tuchar *data_ptr;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, sizeof(rpc_pkt.u.reply));\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tif (rpc_pkt.u.reply.rstatus)\n\t\t\treturn -9999;\n\t\tif (rpc_pkt.u.reply.astatus)\n\t\t\treturn -9999;\n\t\treturn -ntohl(rpc_pkt.u.reply.data[0]);\n\t}\n\n\tif ((nfs_offset != 0) && !((nfs_offset) %\n\t\t\t(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))\n\t\tputs(\"\\n\\t \");\n\tif (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))\n\t\tputc('#');\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\trlen = ntohl(rpc_pkt.u.reply.data[18]);\n\t\tdata_ptr = (uchar *)&(rpc_pkt.u.reply.data[19]);\n\t} else {  /* NFSV3_FLAG */\n\t\tint nfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\n\t\t/* count value */\n\t\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\t\t/* Skip unused values :\n\t\t\tEOF:\t\t32 bits value,\n\t\t\tdata_size:\t32 bits value,\n\t\t*/\n\t\tdata_ptr = (uchar *)\n\t\t\t&(rpc_pkt.u.reply.data[4 + nfsv3_data_offset]);\n\t}\n\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\t\treturn -9999;\n\n\tif (store_block(data_ptr, nfs_offset, rlen))\n\t\t\treturn -9999;\n\n\treturn rlen;\n}\n\n/**************************************************************************\nInterfaces of U-BOOT\n**************************************************************************/\nstatic void nfs_timeout_handler(void)\n{\n\tif (++nfs_timeout_count > NFS_RETRY_COUNT) {\n\t\tputs(\"\\nRetry count exceeded; starting again\\n\");\n\t\tnet_start_again();\n\t} else {\n\t\tputs(\"T \");\n\t\tnet_set_timeout_handler(nfs_timeout +\n\t\t\t\t\tNFS_TIMEOUT * nfs_timeout_count,\n\t\t\t\t\tnfs_timeout_handler);\n\t\tnfs_send();\n\t}\n}\n\nstatic void nfs_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n\t\t\tunsigned src, unsigned len)\n{\n\tint rlen;\n\tint reply;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tif (len > sizeof(struct rpc_t))\n\t\treturn;\n\n\tif (dest != nfs_our_port)\n\t\treturn;\n\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (rpc_lookup_reply(PROG_MOUNT, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_PRCLOOKUP_PROG_NFS_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (rpc_lookup_reply(PROG_NFS, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_MOUNT_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\n\tcase STATE_MOUNT_REQ:\n\t\treply = nfs_mount_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Cannot mount\\n\");\n\t\t\t/* just to be sure... */\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_LOOKUP_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_UMOUNT_REQ:\n\t\treply = nfs_umountall_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tdebug(\"*** ERROR: Cannot umount\\n\");\n\t\t\tnet_set_state(NETLOOP_FAIL);\n\t\t} else {\n\t\t\tputs(\"\\ndone\\n\");\n\t\t\tnet_set_state(nfs_download_state);\n\t\t}\n\t\tbreak;\n\n\tcase STATE_LOOKUP_REQ:\n\t\treply = nfs_lookup_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: File lookup fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else if (reply == -NFS_RPC_PROG_MISMATCH &&\n\t\t\t   supported_nfs_versions != 0) {\n\t\t\t/* umount */\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t\t/* And retry with another supported version */\n\t\t\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_READ_REQ;\n\t\t\tnfs_offset = 0;\n\t\t\tnfs_len = NFS_READ_SIZE;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_READLINK_REQ:\n\t\treply = nfs_readlink_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Symlink fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tdebug(\"Symlink --> %s\\n\", nfs_path);\n\t\t\tnfs_filename = basename(nfs_path);\n\t\t\tnfs_path     = dirname(nfs_path);\n\n\t\t\tnfs_state = STATE_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_READ_REQ:\n\t\trlen = nfs_read_reply(pkt, len);\n\t\tif (rlen == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\t\tif (rlen > 0) {\n\t\t\tnfs_offset += rlen;\n\t\t\tnfs_send();\n\t\t} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {\n\t\t\t/* symbolic link */\n\t\t\tnfs_state = STATE_READLINK_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tif (!rlen)\n\t\t\t\tnfs_download_state = NETLOOP_SUCCESS;\n\t\t\tif (rlen < 0)\n\t\t\t\tdebug(\"NFS READ error (%d)\\n\", rlen);\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid nfs_start(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\tnfs_download_state = NETLOOP_FAIL;\n\n\tnfs_server_ip = net_server_ip;\n\tnfs_path = (char *)nfs_path_buff;\n\n\tif (nfs_path == NULL) {\n\t\tnet_set_state(NETLOOP_FAIL);\n\t\tprintf(\"*** ERROR: Fail allocate memory\\n\");\n\t\treturn;\n\t}\n\n\tif (!net_parse_bootfile(&nfs_server_ip, nfs_path,\n\t\t\t\tsizeof(nfs_path_buff))) {\n\t\tsprintf(nfs_path, \"/nfsroot/%02X%02X%02X%02X.img\",\n\t\t\tnet_ip.s_addr & 0xFF,\n\t\t\t(net_ip.s_addr >>  8) & 0xFF,\n\t\t\t(net_ip.s_addr >> 16) & 0xFF,\n\t\t\t(net_ip.s_addr >> 24) & 0xFF);\n\n\t\tprintf(\"*** Warning: no boot file name; using '%s'\\n\",\n\t\t       nfs_path);\n\t}\n\n\tnfs_filename = basename(nfs_path);\n\tnfs_path     = dirname(nfs_path);\n\n\tprintf(\"Using %s device\\n\", eth_get_name());\n\n\tprintf(\"File transfer via NFS from server %pI4; our IP address is %pI4\",\n\t       &nfs_server_ip, &net_ip);\n\n\t/* Check if we need to send across this subnet */\n\tif (net_gateway.s_addr && net_netmask.s_addr) {\n\t\tstruct in_addr our_net;\n\t\tstruct in_addr server_net;\n\n\t\tour_net.s_addr = net_ip.s_addr & net_netmask.s_addr;\n\t\tserver_net.s_addr = nfs_server_ip.s_addr & net_netmask.s_addr;\n\t\tif (our_net.s_addr != server_net.s_addr)\n\t\t\tprintf(\"; sending through gateway %pI4\",\n\t\t\t       &net_gateway);\n\t}\n\tprintf(\"\\nFilename '%s/%s'.\", nfs_path, nfs_filename);\n\n\tif (net_boot_file_expected_size_in_blocks) {\n\t\tprintf(\" Size is 0x%x Bytes = \",\n\t\t       net_boot_file_expected_size_in_blocks << 9);\n\t\tprint_size(net_boot_file_expected_size_in_blocks << 9, \"\");\n\t}\n\tprintf(\"\\nLoad address: 0x%lx\\nLoading: *\\b\", load_addr);\n\n\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\tnet_set_udp_handler(nfs_handler);\n\n\tnfs_timeout_count = 0;\n\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\n\t/*nfs_our_port = 4096 + (get_ticks() % 3072);*/\n\t/*FIX ME !!!*/\n\tnfs_our_port = 1000;\n\n\t/* zero out server ether in case the server ip has changed */\n\tmemset(net_server_ethaddr, 0, 6);\n\n\tnfs_send();\n}\n"], "fixing_code": ["/*\n * NFS support driver - based on etherboot and U-BOOT's tftp.c\n *\n * Masami Komiya <mkomiya@sonare.it> 2004\n *\n */\n\n/* NOTE: the NFS code is heavily inspired by the NetBSD netboot code (read:\n * large portions are copied verbatim) as distributed in OSKit 0.97.  A few\n * changes were necessary to adapt the code to Etherboot and to fix several\n * inconsistencies.  Also the RPC message preparation is done \"by hand\" to\n * avoid adding netsprintf() which I find hard to understand and use.  */\n\n/* NOTE 2: Etherboot does not care about things beyond the kernel image, so\n * it loads the kernel image off the boot server (ARP_SERVER) and does not\n * access the client root disk (root-path in dhcpd.conf), which would use\n * ARP_ROOTSERVER.  The root disk is something the operating system we are\n * about to load needs to use.\tThis is different from the OSKit 0.97 logic.  */\n\n/* NOTE 3: Symlink handling introduced by Anselm M Hoffmeister, 2003-July-14\n * If a symlink is encountered, it is followed as far as possible (recursion\n * possible, maximum 16 steps). There is no clearing of \"..\"'s inside the\n * path, so please DON'T DO THAT. thx. */\n\n/* NOTE 4: NFSv3 support added by Guillaume GARDET, 2016-June-20.\n * NFSv2 is still used by default. But if server does not support NFSv2, then\n * NFSv3 is used, if available on NFS server. */\n\n#include <common.h>\n#include <command.h>\n#include <net.h>\n#include <malloc.h>\n#include <mapmem.h>\n#include \"nfs.h\"\n#include \"bootp.h\"\n\n#define HASHES_PER_LINE 65\t/* Number of \"loading\" hashes per line\t*/\n#define NFS_RETRY_COUNT 30\n#ifndef CONFIG_NFS_TIMEOUT\n# define NFS_TIMEOUT 2000UL\n#else\n# define NFS_TIMEOUT CONFIG_NFS_TIMEOUT\n#endif\n\n#define NFS_RPC_ERR\t1\n#define NFS_RPC_DROP\t124\n\nstatic int fs_mounted;\nstatic unsigned long rpc_id;\nstatic int nfs_offset = -1;\nstatic int nfs_len;\nstatic ulong nfs_timeout = NFS_TIMEOUT;\n\nstatic char dirfh[NFS_FHSIZE];\t/* NFSv2 / NFSv3 file handle of directory */\nstatic char filefh[NFS3_FHSIZE]; /* NFSv2 / NFSv3 file handle */\nstatic int filefh3_length;\t/* (variable) length of filefh when NFSv3 */\n\nstatic enum net_loop_state nfs_download_state;\nstatic struct in_addr nfs_server_ip;\nstatic int nfs_server_mount_port;\nstatic int nfs_server_port;\nstatic int nfs_our_port;\nstatic int nfs_timeout_count;\nstatic int nfs_state;\n#define STATE_PRCLOOKUP_PROG_MOUNT_REQ\t1\n#define STATE_PRCLOOKUP_PROG_NFS_REQ\t2\n#define STATE_MOUNT_REQ\t\t\t3\n#define STATE_UMOUNT_REQ\t\t4\n#define STATE_LOOKUP_REQ\t\t5\n#define STATE_READ_REQ\t\t\t6\n#define STATE_READLINK_REQ\t\t7\n\nstatic char *nfs_filename;\nstatic char *nfs_path;\nstatic char nfs_path_buff[2048];\n\n#define NFSV2_FLAG 1\n#define NFSV3_FLAG 1 << 1\nstatic char supported_nfs_versions = NFSV2_FLAG | NFSV3_FLAG;\n\nstatic inline int store_block(uchar *src, unsigned offset, unsigned len)\n{\n\tulong newsize = offset + len;\n#ifdef CONFIG_SYS_DIRECT_FLASH_NFS\n\tint i, rc = 0;\n\n\tfor (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {\n\t\t/* start address in flash? */\n\t\tif (load_addr + offset >= flash_info[i].start[0]) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) { /* Flash is destination for this packet */\n\t\trc = flash_write((uchar *)src, (ulong)(load_addr+offset), len);\n\t\tif (rc) {\n\t\t\tflash_perror(rc);\n\t\t\treturn -1;\n\t\t}\n\t} else\n#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */\n\t{\n\t\tvoid *ptr = map_sysmem(load_addr + offset, len);\n\n\t\tmemcpy(ptr, src, len);\n\t\tunmap_sysmem(ptr);\n\t}\n\n\tif (net_boot_file_size < (offset + len))\n\t\tnet_boot_file_size = newsize;\n\treturn 0;\n}\n\nstatic char *basename(char *path)\n{\n\tchar *fname;\n\n\tfname = path + strlen(path) - 1;\n\twhile (fname >= path) {\n\t\tif (*fname == '/') {\n\t\t\tfname++;\n\t\t\tbreak;\n\t\t}\n\t\tfname--;\n\t}\n\treturn fname;\n}\n\nstatic char *dirname(char *path)\n{\n\tchar *fname;\n\n\tfname = basename(path);\n\t--fname;\n\t*fname = '\\0';\n\treturn path;\n}\n\n/**************************************************************************\nRPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries\n**************************************************************************/\nstatic uint32_t *rpc_add_credentials(uint32_t *p)\n{\n\t/* Here's the executive summary on authentication requirements of the\n\t * various NFS server implementations:\tLinux accepts both AUTH_NONE\n\t * and AUTH_UNIX authentication (also accepts an empty hostname field\n\t * in the AUTH_UNIX scheme).  *BSD refuses AUTH_NONE, but accepts\n\t * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX\n\t * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have\n\t * it (if the BOOTP/DHCP reply didn't give one, just use an empty\n\t * hostname).  */\n\n\t/* Provide an AUTH_UNIX credential.  */\n\t*p++ = htonl(1);\t\t/* AUTH_UNIX */\n\t*p++ = htonl(20);\t\t/* auth length */\n\t*p++ = 0;\t\t\t/* stamp */\n\t*p++ = 0;\t\t\t/* hostname string */\n\t*p++ = 0;\t\t\t/* uid */\n\t*p++ = 0;\t\t\t/* gid */\n\t*p++ = 0;\t\t\t/* auxiliary gid list */\n\n\t/* Provide an AUTH_NONE verifier.  */\n\t*p++ = 0;\t\t\t/* AUTH_NONE */\n\t*p++ = 0;\t\t\t/* auth length */\n\n\treturn p;\n}\n\n/**************************************************************************\nRPC_LOOKUP - Lookup RPC Port numbers\n**************************************************************************/\nstatic void rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)\n{\n\tstruct rpc_t rpc_pkt;\n\tunsigned long id;\n\tuint32_t *p;\n\tint pktlen;\n\tint sport;\n\n\tid = ++rpc_id;\n\trpc_pkt.u.call.id = htonl(id);\n\trpc_pkt.u.call.type = htonl(MSG_CALL);\n\trpc_pkt.u.call.rpcvers = htonl(2);\t/* use RPC version 2 */\n\trpc_pkt.u.call.prog = htonl(rpc_prog);\n\tswitch (rpc_prog) {\n\tcase PROG_NFS:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_pkt.u.call.vers = htonl(2);\t/* NFS v2 */\n\t\telse /* NFSV3_FLAG */\n\t\t\trpc_pkt.u.call.vers = htonl(3);\t/* NFS v3 */\n\t\tbreak;\n\tcase PROG_PORTMAP:\n\tcase PROG_MOUNT:\n\tdefault:\n\t\trpc_pkt.u.call.vers = htonl(2);\t/* portmapper is version 2 */\n\t}\n\trpc_pkt.u.call.proc = htonl(rpc_proc);\n\tp = (uint32_t *)&(rpc_pkt.u.call.data);\n\n\tif (datalen)\n\t\tmemcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));\n\n\tpktlen = (char *)p + datalen * sizeof(uint32_t) - (char *)&rpc_pkt;\n\n\tmemcpy((char *)net_tx_packet + net_eth_hdr_size() + IP_UDP_HDR_SIZE,\n\t       &rpc_pkt.u.data[0], pktlen);\n\n\tif (rpc_prog == PROG_PORTMAP)\n\t\tsport = SUNRPC_PORT;\n\telse if (rpc_prog == PROG_MOUNT)\n\t\tsport = nfs_server_mount_port;\n\telse\n\t\tsport = nfs_server_port;\n\n\tnet_send_udp_packet(net_server_ethaddr, nfs_server_ip, sport,\n\t\t\t    nfs_our_port, pktlen);\n}\n\n/**************************************************************************\nRPC_LOOKUP - Lookup RPC Port numbers\n**************************************************************************/\nstatic void rpc_lookup_req(int prog, int ver)\n{\n\tuint32_t data[16];\n\n\tdata[0] = 0; data[1] = 0;\t/* auth credential */\n\tdata[2] = 0; data[3] = 0;\t/* auth verifier */\n\tdata[4] = htonl(prog);\n\tdata[5] = htonl(ver);\n\tdata[6] = htonl(17);\t/* IP_UDP */\n\tdata[7] = 0;\n\trpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);\n}\n\n/**************************************************************************\nNFS_MOUNT - Mount an NFS Filesystem\n**************************************************************************/\nstatic void nfs_mount_req(char *path)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint pathlen;\n\n\tpathlen = strlen(path);\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\t*p++ = htonl(pathlen);\n\tif (pathlen & 3)\n\t\t*(p + pathlen / 4) = 0;\n\tmemcpy(p, path, pathlen);\n\tp += (pathlen + 3) / 4;\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);\n}\n\n/**************************************************************************\nNFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server\n**************************************************************************/\nstatic void nfs_umountall_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tif ((nfs_server_mount_port == -1) || (!fs_mounted))\n\t\t/* Nothing mounted, nothing to umount */\n\t\treturn;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);\n}\n\n/***************************************************************************\n * NFS_READLINK (AH 2003-07-14)\n * This procedure is called when read of the first block fails -\n * this probably happens when it's a directory or a symlink\n * In case of successful readlink(), the dirname is manipulated,\n * so that inside the nfs() function a recursion can be done.\n **************************************************************************/\nstatic void nfs_readlink_req(void)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t} else { /* NFSV3_FLAG */\n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t}\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_NFS, NFS_READLINK, data, len);\n}\n\n/**************************************************************************\nNFS_LOOKUP - Lookup Pathname\n**************************************************************************/\nstatic void nfs_lookup_req(char *fname)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\tint fnamelen;\n\n\tfnamelen = strlen(fname);\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\t\trpc_req(PROG_NFS, NFS_LOOKUP, data, len);\n\t} else {  /* NFSV3_FLAG */\n\t\t*p++ = htonl(NFS_FHSIZE);\t/* Dir handle length */\n\t\tmemcpy(p, dirfh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(fnamelen);\n\t\tif (fnamelen & 3)\n\t\t\t*(p + fnamelen / 4) = 0;\n\t\tmemcpy(p, fname, fnamelen);\n\t\tp += (fnamelen + 3) / 4;\n\n\t\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\t\trpc_req(PROG_NFS, NFS3PROC_LOOKUP, data, len);\n\t}\n}\n\n/**************************************************************************\nNFS_READ - Read File on NFS Server\n**************************************************************************/\nstatic void nfs_read_req(int offset, int readlen)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tint len;\n\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tmemcpy(p, filefh, NFS_FHSIZE);\n\t\tp += (NFS_FHSIZE / 4);\n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t} else { /* NFSV3_FLAG */\n\t\t*p++ = htonl(filefh3_length);\n\t\tmemcpy(p, filefh, filefh3_length);\n\t\tp += (filefh3_length / 4);\n\t\t*p++ = htonl(0); /* offset is 64-bit long, so fill with 0 */\n\t\t*p++ = htonl(offset);\n\t\t*p++ = htonl(readlen);\n\t\t*p++ = 0;\n\t}\n\n\tlen = (uint32_t *)p - (uint32_t *)&(data[0]);\n\n\trpc_req(PROG_NFS, NFS_READ, data, len);\n}\n\n/**************************************************************************\nRPC request dispatcher\n**************************************************************************/\nstatic void nfs_send(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_MOUNT, 1);\n\t\telse  /* NFSV3_FLAG */\n\t\t\trpc_lookup_req(PROG_MOUNT, 3);\n\t\tbreak;\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (supported_nfs_versions & NFSV2_FLAG)\n\t\t\trpc_lookup_req(PROG_NFS, 2);\n\t\telse  /* NFSV3_FLAG */\n\t\t\trpc_lookup_req(PROG_NFS, 3);\n\t\tbreak;\n\tcase STATE_MOUNT_REQ:\n\t\tnfs_mount_req(nfs_path);\n\t\tbreak;\n\tcase STATE_UMOUNT_REQ:\n\t\tnfs_umountall_req();\n\t\tbreak;\n\tcase STATE_LOOKUP_REQ:\n\t\tnfs_lookup_req(nfs_filename);\n\t\tbreak;\n\tcase STATE_READ_REQ:\n\t\tnfs_read_req(nfs_offset, nfs_len);\n\t\tbreak;\n\tcase STATE_READLINK_REQ:\n\t\tnfs_readlink_req();\n\t\tbreak;\n\t}\n}\n\n/**************************************************************************\nHandlers for the reply from server\n**************************************************************************/\n\nstatic int rpc_lookup_reply(int prog, uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tdebug(\"%s\\n\", __func__);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\n\tswitch (prog) {\n\tcase PROG_MOUNT:\n\t\tnfs_server_mount_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\tcase PROG_NFS:\n\t\tnfs_server_port = ntohl(rpc_pkt.u.reply.data[0]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfs_mount_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\n\tfs_mounted = 1;\n\t/*  NFSv2 and NFSv3 use same structure */\n\tmemcpy(dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\n\treturn 0;\n}\n\nstatic int nfs_umountall_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus)\n\t\treturn -1;\n\n\tfs_mounted = 0;\n\tmemset(dirfh, 0, sizeof(dirfh));\n\n\treturn 0;\n}\n\nstatic int nfs_lookup_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tswitch (ntohl(rpc_pkt.u.reply.astatus)) {\n\t\tcase NFS_RPC_SUCCESS: /* Not an error */\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_MISMATCH:\n\t\t\t/* Remote can't support NFS version */\n\t\t\tswitch (ntohl(rpc_pkt.u.reply.data[0])) {\n\t\t\t/* Minimal supported NFS version */\n\t\t\tcase 3:\n\t\t\t\tdebug(\"*** Warning: NFS version not supported: Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tdebug(\"Will retry with NFSv3\\n\");\n\t\t\t\t/* Clear NFSV2_FLAG from supported versions */\n\t\t\t\tsupported_nfs_versions &= ~NFSV2_FLAG;\n\t\t\t\treturn -NFS_RPC_PROG_MISMATCH;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tputs(\"*** ERROR: NFS version not supported\");\n\t\t\t\tdebug(\": Requested: V%d, accepted: min V%d - max V%d\\n\",\n\t\t\t\t      (supported_nfs_versions & NFSV2_FLAG) ?\n\t\t\t\t\t\t2 : 3,\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[0]),\n\t\t\t\t      ntohl(rpc_pkt.u.reply.data[1]));\n\t\t\t\tputs(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS_RPC_PROG_UNAVAIL:\n\t\tcase NFS_RPC_PROC_UNAVAIL:\n\t\tcase NFS_RPC_GARBAGE_ARGS:\n\t\tcase NFS_RPC_SYSTEM_ERR:\n\t\tdefault: /* Unknown error on 'accept state' flag */\n\t\t\tdebug(\"*** ERROR: accept state error (%d)\\n\",\n\t\t\t      ntohl(rpc_pkt.u.reply.astatus));\n\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + NFS_FHSIZE) > len)\n\t\t\treturn -NFS_RPC_DROP;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);\n\t} else {  /* NFSV3_FLAG */\n\t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\t\tif (filefh3_length > NFS3_FHSIZE)\n\t\t\tfilefh3_length  = NFS3_FHSIZE;\n\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + filefh3_length) > len)\n\t\t\treturn -NFS_RPC_DROP;\n\t\tmemcpy(filefh, rpc_pkt.u.reply.data + 2, filefh3_length);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfs3_get_attributes_offset(uint32_t *data)\n{\n\tif (ntohl(data[1]) != 0) {\n\t\t/* 'attributes_follow' flag is TRUE,\n\t\t * so we have attributes on 21 dwords */\n\t\t/* Skip unused values :\n\t\t\ttype;\t32 bits value,\n\t\t\tmode;\t32 bits value,\n\t\t\tnlink;\t32 bits value,\n\t\t\tuid;\t32 bits value,\n\t\t\tgid;\t32 bits value,\n\t\t\tsize;\t64 bits value,\n\t\t\tused;\t64 bits value,\n\t\t\trdev;\t64 bits value,\n\t\t\tfsid;\t64 bits value,\n\t\t\tfileid;\t64 bits value,\n\t\t\tatime;\t64 bits value,\n\t\t\tmtime;\t64 bits value,\n\t\t\tctime;\t64 bits value,\n\t\t*/\n\t\treturn 22;\n\t} else {\n\t\t/* 'attributes_follow' flag is FALSE,\n\t\t * so we don't have any attributes */\n\t\treturn 1;\n\t}\n}\n\nstatic int nfs_readlink_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tint nfsv3_data_offset = 0;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy((unsigned char *)&rpc_pkt, pkt, len);\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0])\n\t\treturn -1;\n\n\tif (!(supported_nfs_versions & NFSV2_FLAG)) { /* NFSV3_FLAG */\n\t\tnfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\t}\n\n\t/* new path length */\n\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (*((char *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset])) != '/') {\n\t\tint pathlen;\n\n\t\tstrcat(nfs_path, \"/\");\n\t\tpathlen = strlen(nfs_path);\n\t\tmemcpy(nfs_path + pathlen,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[pathlen + rlen] = 0;\n\t} else {\n\t\tmemcpy(nfs_path,\n\t\t       (uchar *)&(rpc_pkt.u.reply.data[2 + nfsv3_data_offset]),\n\t\t       rlen);\n\t\tnfs_path[rlen] = 0;\n\t}\n\treturn 0;\n}\n\nstatic int nfs_read_reply(uchar *pkt, unsigned len)\n{\n\tstruct rpc_t rpc_pkt;\n\tint rlen;\n\tuchar *data_ptr;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tmemcpy(&rpc_pkt.u.data[0], pkt, sizeof(rpc_pkt.u.reply));\n\n\tif (ntohl(rpc_pkt.u.reply.id) > rpc_id)\n\t\treturn -NFS_RPC_ERR;\n\telse if (ntohl(rpc_pkt.u.reply.id) < rpc_id)\n\t\treturn -NFS_RPC_DROP;\n\n\tif (rpc_pkt.u.reply.rstatus  ||\n\t    rpc_pkt.u.reply.verifier ||\n\t    rpc_pkt.u.reply.astatus  ||\n\t    rpc_pkt.u.reply.data[0]) {\n\t\tif (rpc_pkt.u.reply.rstatus)\n\t\t\treturn -9999;\n\t\tif (rpc_pkt.u.reply.astatus)\n\t\t\treturn -9999;\n\t\treturn -ntohl(rpc_pkt.u.reply.data[0]);\n\t}\n\n\tif ((nfs_offset != 0) && !((nfs_offset) %\n\t\t\t(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))\n\t\tputs(\"\\n\\t \");\n\tif (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))\n\t\tputc('#');\n\n\tif (supported_nfs_versions & NFSV2_FLAG) {\n\t\trlen = ntohl(rpc_pkt.u.reply.data[18]);\n\t\tdata_ptr = (uchar *)&(rpc_pkt.u.reply.data[19]);\n\t} else {  /* NFSV3_FLAG */\n\t\tint nfsv3_data_offset =\n\t\t\tnfs3_get_attributes_offset(rpc_pkt.u.reply.data);\n\n\t\t/* count value */\n\t\trlen = ntohl(rpc_pkt.u.reply.data[1 + nfsv3_data_offset]);\n\t\t/* Skip unused values :\n\t\t\tEOF:\t\t32 bits value,\n\t\t\tdata_size:\t32 bits value,\n\t\t*/\n\t\tdata_ptr = (uchar *)\n\t\t\t&(rpc_pkt.u.reply.data[4 + nfsv3_data_offset]);\n\t}\n\n\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + rlen) > len)\n\t\t\treturn -9999;\n\n\tif (store_block(data_ptr, nfs_offset, rlen))\n\t\t\treturn -9999;\n\n\treturn rlen;\n}\n\n/**************************************************************************\nInterfaces of U-BOOT\n**************************************************************************/\nstatic void nfs_timeout_handler(void)\n{\n\tif (++nfs_timeout_count > NFS_RETRY_COUNT) {\n\t\tputs(\"\\nRetry count exceeded; starting again\\n\");\n\t\tnet_start_again();\n\t} else {\n\t\tputs(\"T \");\n\t\tnet_set_timeout_handler(nfs_timeout +\n\t\t\t\t\tNFS_TIMEOUT * nfs_timeout_count,\n\t\t\t\t\tnfs_timeout_handler);\n\t\tnfs_send();\n\t}\n}\n\nstatic void nfs_handler(uchar *pkt, unsigned dest, struct in_addr sip,\n\t\t\tunsigned src, unsigned len)\n{\n\tint rlen;\n\tint reply;\n\n\tdebug(\"%s\\n\", __func__);\n\n\tif (len > sizeof(struct rpc_t))\n\t\treturn;\n\n\tif (dest != nfs_our_port)\n\t\treturn;\n\n\tswitch (nfs_state) {\n\tcase STATE_PRCLOOKUP_PROG_MOUNT_REQ:\n\t\tif (rpc_lookup_reply(PROG_MOUNT, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_PRCLOOKUP_PROG_NFS_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\n\tcase STATE_PRCLOOKUP_PROG_NFS_REQ:\n\t\tif (rpc_lookup_reply(PROG_NFS, pkt, len) == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnfs_state = STATE_MOUNT_REQ;\n\t\tnfs_send();\n\t\tbreak;\n\n\tcase STATE_MOUNT_REQ:\n\t\treply = nfs_mount_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Cannot mount\\n\");\n\t\t\t/* just to be sure... */\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_LOOKUP_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_UMOUNT_REQ:\n\t\treply = nfs_umountall_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tdebug(\"*** ERROR: Cannot umount\\n\");\n\t\t\tnet_set_state(NETLOOP_FAIL);\n\t\t} else {\n\t\t\tputs(\"\\ndone\\n\");\n\t\t\tnet_set_state(nfs_download_state);\n\t\t}\n\t\tbreak;\n\n\tcase STATE_LOOKUP_REQ:\n\t\treply = nfs_lookup_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: File lookup fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else if (reply == -NFS_RPC_PROG_MISMATCH &&\n\t\t\t   supported_nfs_versions != 0) {\n\t\t\t/* umount */\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t\t/* And retry with another supported version */\n\t\t\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tnfs_state = STATE_READ_REQ;\n\t\t\tnfs_offset = 0;\n\t\t\tnfs_len = NFS_READ_SIZE;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_READLINK_REQ:\n\t\treply = nfs_readlink_reply(pkt, len);\n\t\tif (reply == -NFS_RPC_DROP) {\n\t\t\tbreak;\n\t\t} else if (reply == -NFS_RPC_ERR) {\n\t\t\tputs(\"*** ERROR: Symlink fail\\n\");\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tdebug(\"Symlink --> %s\\n\", nfs_path);\n\t\t\tnfs_filename = basename(nfs_path);\n\t\t\tnfs_path     = dirname(nfs_path);\n\n\t\t\tnfs_state = STATE_MOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\n\tcase STATE_READ_REQ:\n\t\trlen = nfs_read_reply(pkt, len);\n\t\tif (rlen == -NFS_RPC_DROP)\n\t\t\tbreak;\n\t\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\t\tif (rlen > 0) {\n\t\t\tnfs_offset += rlen;\n\t\t\tnfs_send();\n\t\t} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {\n\t\t\t/* symbolic link */\n\t\t\tnfs_state = STATE_READLINK_REQ;\n\t\t\tnfs_send();\n\t\t} else {\n\t\t\tif (!rlen)\n\t\t\t\tnfs_download_state = NETLOOP_SUCCESS;\n\t\t\tif (rlen < 0)\n\t\t\t\tdebug(\"NFS READ error (%d)\\n\", rlen);\n\t\t\tnfs_state = STATE_UMOUNT_REQ;\n\t\t\tnfs_send();\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid nfs_start(void)\n{\n\tdebug(\"%s\\n\", __func__);\n\tnfs_download_state = NETLOOP_FAIL;\n\n\tnfs_server_ip = net_server_ip;\n\tnfs_path = (char *)nfs_path_buff;\n\n\tif (nfs_path == NULL) {\n\t\tnet_set_state(NETLOOP_FAIL);\n\t\tprintf(\"*** ERROR: Fail allocate memory\\n\");\n\t\treturn;\n\t}\n\n\tif (!net_parse_bootfile(&nfs_server_ip, nfs_path,\n\t\t\t\tsizeof(nfs_path_buff))) {\n\t\tsprintf(nfs_path, \"/nfsroot/%02X%02X%02X%02X.img\",\n\t\t\tnet_ip.s_addr & 0xFF,\n\t\t\t(net_ip.s_addr >>  8) & 0xFF,\n\t\t\t(net_ip.s_addr >> 16) & 0xFF,\n\t\t\t(net_ip.s_addr >> 24) & 0xFF);\n\n\t\tprintf(\"*** Warning: no boot file name; using '%s'\\n\",\n\t\t       nfs_path);\n\t}\n\n\tnfs_filename = basename(nfs_path);\n\tnfs_path     = dirname(nfs_path);\n\n\tprintf(\"Using %s device\\n\", eth_get_name());\n\n\tprintf(\"File transfer via NFS from server %pI4; our IP address is %pI4\",\n\t       &nfs_server_ip, &net_ip);\n\n\t/* Check if we need to send across this subnet */\n\tif (net_gateway.s_addr && net_netmask.s_addr) {\n\t\tstruct in_addr our_net;\n\t\tstruct in_addr server_net;\n\n\t\tour_net.s_addr = net_ip.s_addr & net_netmask.s_addr;\n\t\tserver_net.s_addr = nfs_server_ip.s_addr & net_netmask.s_addr;\n\t\tif (our_net.s_addr != server_net.s_addr)\n\t\t\tprintf(\"; sending through gateway %pI4\",\n\t\t\t       &net_gateway);\n\t}\n\tprintf(\"\\nFilename '%s/%s'.\", nfs_path, nfs_filename);\n\n\tif (net_boot_file_expected_size_in_blocks) {\n\t\tprintf(\" Size is 0x%x Bytes = \",\n\t\t       net_boot_file_expected_size_in_blocks << 9);\n\t\tprint_size(net_boot_file_expected_size_in_blocks << 9, \"\");\n\t}\n\tprintf(\"\\nLoad address: 0x%lx\\nLoading: *\\b\", load_addr);\n\n\tnet_set_timeout_handler(nfs_timeout, nfs_timeout_handler);\n\tnet_set_udp_handler(nfs_handler);\n\n\tnfs_timeout_count = 0;\n\tnfs_state = STATE_PRCLOOKUP_PROG_MOUNT_REQ;\n\n\t/*nfs_our_port = 4096 + (get_ticks() % 3072);*/\n\t/*FIX ME !!!*/\n\tnfs_our_port = 1000;\n\n\t/* zero out server ether in case the server ip has changed */\n\tmemset(net_server_ethaddr, 0, 6);\n\n\tnfs_send();\n}\n"], "filenames": ["net/nfs.c"], "buggy_code_start_loc": [568], "buggy_code_end_loc": [573], "fixing_code_start_loc": [569], "fixing_code_end_loc": [578], "type": "CWE-120", "message": "nfs_lookup_reply in net/nfs.c in Das U-Boot through 2022.04 (and through 2022.07-rc2) has an unbounded memcpy with a failed length check, leading to a buffer overflow. NOTE: this issue exists because of an incorrect fix for CVE-2019-14196.", "other": {"cve": {"id": "CVE-2022-30767", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-16T03:15:07.563", "lastModified": "2022-10-27T20:02:37.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nfs_lookup_reply in net/nfs.c in Das U-Boot through 2022.04 (and through 2022.07-rc2) has an unbounded memcpy with a failed length check, leading to a buffer overflow. NOTE: this issue exists because of an incorrect fix for CVE-2019-14196."}, {"lang": "es", "value": "La funci\u00f3n nfs_lookup_reply en el archivo net/nfs.c en Das U-Boot hasta 2022.04 (y hasta 2022.07-rc2), presenta un memcpy no limitado con una comprobaci\u00f3n de longitud fallida, conllevando a un desbordamiento del b\u00fafer. NOTA: este problema se presenta debido a una correcci\u00f3n incorrecta de CVE-2019-14196"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2022.04", "matchCriteriaId": "629B9DBB-E371-4813-BA04-3076B0CDD1DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc1:*:*:*:*:*:*", "matchCriteriaId": "D173B461-EBA5-4A85-8002-6A5B557917D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:denx:u-boot:2022.07:rc2:*:*:*:*:*:*", "matchCriteriaId": "3E3EDD31-1721-467F-B6E5-EA357D7DD8AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/u-boot/u-boot/commit/5d14ee4e53a81055d34ba280cb8fd90330f22a96", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.denx.de/pipermail/u-boot/2022-May/483952.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DF62MVMH3QUGMBDCB3DY2ERQ6EBHTADB/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/research/uboot-rce-nfs-vulnerability/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://source.denx.de/u-boot/u-boot/-/commit/bdbf7a05e26f3c5fd437c99e2755ffde186ddc80", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/u-boot/u-boot/commit/5d14ee4e53a81055d34ba280cb8fd90330f22a96"}}