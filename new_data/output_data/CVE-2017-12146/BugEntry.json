{"buggy_code": ["/*\n * platform.c - platform 'pseudo' bus for legacy devices\n *\n * Copyright (c) 2002-3 Patrick Mochel\n * Copyright (c) 2002-3 Open Source Development Labs\n *\n * This file is released under the GPLv2\n *\n * Please see Documentation/driver-model/platform.txt for more\n * information.\n */\n\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/bootmem.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/idr.h>\n#include <linux/acpi.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/limits.h>\n#include <linux/property.h>\n\n#include \"base.h\"\n#include \"power/power.h\"\n\n/* For automatically allocated device IDs */\nstatic DEFINE_IDA(platform_devid_ida);\n\nstruct device platform_bus = {\n\t.init_name\t= \"platform\",\n};\nEXPORT_SYMBOL_GPL(platform_bus);\n\n/**\n * arch_setup_pdev_archdata - Allow manipulation of archdata before its used\n * @pdev: platform device\n *\n * This is called before platform_device_add() such that any pdev_archdata may\n * be setup before the platform_notifier is called.  So if a user needs to\n * manipulate any relevant information in the pdev_archdata they can do:\n *\n *\tplatform_device_alloc()\n *\t... manipulate ...\n *\tplatform_device_add()\n *\n * And if they don't care they can just call platform_device_register() and\n * everything will just work out.\n */\nvoid __weak arch_setup_pdev_archdata(struct platform_device *pdev)\n{\n}\n\n/**\n * platform_get_resource - get a resource for a device\n * @dev: platform device\n * @type: resource type\n * @num: resource index\n */\nstruct resource *platform_get_resource(struct platform_device *dev,\n\t\t\t\t       unsigned int type, unsigned int num)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (type == resource_type(r) && num-- == 0)\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource);\n\n/**\n * platform_get_irq - get an IRQ for a device\n * @dev: platform device\n * @num: IRQ number index\n */\nint platform_get_irq(struct platform_device *dev, unsigned int num)\n{\n#ifdef CONFIG_SPARC\n\t/* sparc does not have irqs represented as IORESOURCE_IRQ resources */\n\tif (!dev || num >= dev->archdata.num_irqs)\n\t\treturn -ENXIO;\n\treturn dev->archdata.irqs[num];\n#else\n\tstruct resource *r;\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get(dev->dev.of_node, num);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, num);\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tif (r && r->flags & IORESOURCE_DISABLED) {\n\t\t\tint ret;\n\n\t\t\tret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * The resources may pass trigger flags to the irqs that need\n\t * to be set up. It so happens that the trigger flags for\n\t * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*\n\t * settings.\n\t */\n\tif (r && r->flags & IORESOURCE_BITS) {\n\t\tstruct irq_data *irqd;\n\n\t\tirqd = irq_get_irq_data(r->start);\n\t\tif (!irqd)\n\t\t\treturn -ENXIO;\n\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t}\n\n\treturn r ? r->start : -ENXIO;\n#endif\n}\nEXPORT_SYMBOL_GPL(platform_get_irq);\n\n/**\n * platform_irq_count - Count the number of IRQs a platform device uses\n * @dev: platform device\n *\n * Return: Number of IRQs a platform device uses or EPROBE_DEFER\n */\nint platform_irq_count(struct platform_device *dev)\n{\n\tint ret, nr = 0;\n\n\twhile ((ret = platform_get_irq(dev, nr)) >= 0)\n\t\tnr++;\n\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\treturn nr;\n}\nEXPORT_SYMBOL_GPL(platform_irq_count);\n\n/**\n * platform_get_resource_byname - get a resource for a device by name\n * @dev: platform device\n * @type: resource type\n * @name: resource name\n */\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\n\t\t\t\t\t      unsigned int type,\n\t\t\t\t\t      const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (unlikely(!r->name))\n\t\t\tcontinue;\n\n\t\tif (type == resource_type(r) && !strcmp(r->name, name))\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n\n/**\n * platform_get_irq_byname - get an IRQ for a device by name\n * @dev: platform device\n * @name: IRQ name\n */\nint platform_get_irq_byname(struct platform_device *dev, const char *name)\n{\n\tstruct resource *r;\n\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get_byname(dev->dev.of_node, name);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);\n\treturn r ? r->start : -ENXIO;\n}\nEXPORT_SYMBOL_GPL(platform_get_irq_byname);\n\n/**\n * platform_add_devices - add a numbers of platform devices\n * @devs: array of platform devices to add\n * @num: number of platform devices in array\n */\nint platform_add_devices(struct platform_device **devs, int num)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = platform_device_register(devs[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tplatform_device_unregister(devs[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_add_devices);\n\nstruct platform_object {\n\tstruct platform_device pdev;\n\tchar name[];\n};\n\n/**\n * platform_device_put - destroy a platform device\n * @pdev: platform device to free\n *\n * Free all memory associated with a platform device.  This function must\n * _only_ be externally called in error cases.  All other usage is a bug.\n */\nvoid platform_device_put(struct platform_device *pdev)\n{\n\tif (pdev)\n\t\tput_device(&pdev->dev);\n}\nEXPORT_SYMBOL_GPL(platform_device_put);\n\nstatic void platform_device_release(struct device *dev)\n{\n\tstruct platform_object *pa = container_of(dev, struct platform_object,\n\t\t\t\t\t\t  pdev.dev);\n\n\tof_device_node_put(&pa->pdev.dev);\n\tkfree(pa->pdev.dev.platform_data);\n\tkfree(pa->pdev.mfd_cell);\n\tkfree(pa->pdev.resource);\n\tkfree(pa->pdev.driver_override);\n\tkfree(pa);\n}\n\n/**\n * platform_device_alloc - create a platform device\n * @name: base name of the device we're adding\n * @id: instance id\n *\n * Create a platform device object which can have other objects attached\n * to it, and which will have attached objects freed when it is released.\n */\nstruct platform_device *platform_device_alloc(const char *name, int id)\n{\n\tstruct platform_object *pa;\n\n\tpa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);\n\tif (pa) {\n\t\tstrcpy(pa->name, name);\n\t\tpa->pdev.name = pa->name;\n\t\tpa->pdev.id = id;\n\t\tdevice_initialize(&pa->pdev.dev);\n\t\tpa->pdev.dev.release = platform_device_release;\n\t\tarch_setup_pdev_archdata(&pa->pdev);\n\t}\n\n\treturn pa ? &pa->pdev : NULL;\n}\nEXPORT_SYMBOL_GPL(platform_device_alloc);\n\n/**\n * platform_device_add_resources - add resources to a platform device\n * @pdev: platform device allocated by platform_device_alloc to add resources to\n * @res: set of resources that needs to be allocated for the device\n * @num: number of resources\n *\n * Add a copy of the resources to the platform device.  The memory\n * associated with the resources will be freed when the platform device is\n * released.\n */\nint platform_device_add_resources(struct platform_device *pdev,\n\t\t\t\t  const struct resource *res, unsigned int num)\n{\n\tstruct resource *r = NULL;\n\n\tif (res) {\n\t\tr = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);\n\t\tif (!r)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->resource);\n\tpdev->resource = r;\n\tpdev->num_resources = num;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_resources);\n\n/**\n * platform_device_add_data - add platform-specific data to a platform device\n * @pdev: platform device allocated by platform_device_alloc to add resources to\n * @data: platform specific data for this platform device\n * @size: size of platform specific data\n *\n * Add a copy of platform specific data to the platform device's\n * platform_data pointer.  The memory associated with the platform data\n * will be freed when the platform device is released.\n */\nint platform_device_add_data(struct platform_device *pdev, const void *data,\n\t\t\t     size_t size)\n{\n\tvoid *d = NULL;\n\n\tif (data) {\n\t\td = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!d)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->dev.platform_data);\n\tpdev->dev.platform_data = d;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_data);\n\n/**\n * platform_device_add_properties - add built-in properties to a platform device\n * @pdev: platform device to add properties to\n * @properties: null terminated array of properties to add\n *\n * The function will take deep copy of @properties and attach the copy to the\n * platform device. The memory associated with properties will be freed when the\n * platform device is released.\n */\nint platform_device_add_properties(struct platform_device *pdev,\n\t\t\t\t   struct property_entry *properties)\n{\n\treturn device_add_properties(&pdev->dev, properties);\n}\nEXPORT_SYMBOL_GPL(platform_device_add_properties);\n\n/**\n * platform_device_add - add a platform device to device hierarchy\n * @pdev: platform device we're adding\n *\n * This is part 2 of platform_device_register(), though may be called\n * separately _iff_ pdev was allocated by platform_device_alloc().\n */\nint platform_device_add(struct platform_device *pdev)\n{\n\tint i, ret;\n\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tif (!pdev->dev.parent)\n\t\tpdev->dev.parent = &platform_bus;\n\n\tpdev->dev.bus = &platform_bus_type;\n\n\tswitch (pdev->id) {\n\tdefault:\n\t\tdev_set_name(&pdev->dev, \"%s.%d\", pdev->name,  pdev->id);\n\t\tbreak;\n\tcase PLATFORM_DEVID_NONE:\n\t\tdev_set_name(&pdev->dev, \"%s\", pdev->name);\n\t\tbreak;\n\tcase PLATFORM_DEVID_AUTO:\n\t\t/*\n\t\t * Automatically allocated device ID. We mark it as such so\n\t\t * that we remember it must be freed, and we append a suffix\n\t\t * to avoid namespace collision with explicit IDs.\n\t\t */\n\t\tret = ida_simple_get(&platform_devid_ida, 0, 0, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\t\tpdev->id = ret;\n\t\tpdev->id_auto = true;\n\t\tdev_set_name(&pdev->dev, \"%s.%d.auto\", pdev->name, pdev->id);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\tstruct resource *p, *r = &pdev->resource[i];\n\n\t\tif (r->name == NULL)\n\t\t\tr->name = dev_name(&pdev->dev);\n\n\t\tp = r->parent;\n\t\tif (!p) {\n\t\t\tif (resource_type(r) == IORESOURCE_MEM)\n\t\t\t\tp = &iomem_resource;\n\t\t\telse if (resource_type(r) == IORESOURCE_IO)\n\t\t\t\tp = &ioport_resource;\n\t\t}\n\n\t\tif (p && insert_resource(p, r)) {\n\t\t\tdev_err(&pdev->dev, \"failed to claim resource %d: %pR\\n\", i, r);\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tpr_debug(\"Registering platform device '%s'. Parent at %s\\n\",\n\t\t dev_name(&pdev->dev), dev_name(pdev->dev.parent));\n\n\tret = device_add(&pdev->dev);\n\tif (ret == 0)\n\t\treturn ret;\n\n failed:\n\tif (pdev->id_auto) {\n\t\tida_simple_remove(&platform_devid_ida, pdev->id);\n\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t}\n\n\twhile (--i >= 0) {\n\t\tstruct resource *r = &pdev->resource[i];\n\t\tif (r->parent)\n\t\t\trelease_resource(r);\n\t}\n\n err_out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_device_add);\n\n/**\n * platform_device_del - remove a platform-level device\n * @pdev: platform device we're removing\n *\n * Note that this function will also release all memory- and port-based\n * resources owned by the device (@dev->resource).  This function must\n * _only_ be externally called in error cases.  All other usage is a bug.\n */\nvoid platform_device_del(struct platform_device *pdev)\n{\n\tint i;\n\n\tif (pdev) {\n\t\tdevice_remove_properties(&pdev->dev);\n\t\tdevice_del(&pdev->dev);\n\n\t\tif (pdev->id_auto) {\n\t\t\tida_simple_remove(&platform_devid_ida, pdev->id);\n\t\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t\t}\n\n\t\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\t\tstruct resource *r = &pdev->resource[i];\n\t\t\tif (r->parent)\n\t\t\t\trelease_resource(r);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_device_del);\n\n/**\n * platform_device_register - add a platform-level device\n * @pdev: platform device we're adding\n */\nint platform_device_register(struct platform_device *pdev)\n{\n\tdevice_initialize(&pdev->dev);\n\tarch_setup_pdev_archdata(pdev);\n\treturn platform_device_add(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_register);\n\n/**\n * platform_device_unregister - unregister a platform-level device\n * @pdev: platform device we're unregistering\n *\n * Unregistration is done in 2 steps. First we release all resources\n * and remove it from the subsystem, then we drop reference count by\n * calling platform_device_put().\n */\nvoid platform_device_unregister(struct platform_device *pdev)\n{\n\tplatform_device_del(pdev);\n\tplatform_device_put(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_unregister);\n\n/**\n * platform_device_register_full - add a platform-level device with\n * resources and platform-specific data\n *\n * @pdevinfo: data used to create device\n *\n * Returns &struct platform_device pointer on success, or ERR_PTR() on error.\n */\nstruct platform_device *platform_device_register_full(\n\t\tconst struct platform_device_info *pdevinfo)\n{\n\tint ret = -ENOMEM;\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);\n\tif (!pdev)\n\t\tgoto err_alloc;\n\n\tpdev->dev.parent = pdevinfo->parent;\n\tpdev->dev.fwnode = pdevinfo->fwnode;\n\n\tif (pdevinfo->dma_mask) {\n\t\t/*\n\t\t * This memory isn't freed when the device is put,\n\t\t * I don't have a nice idea for that though.  Conceptually\n\t\t * dma_mask in struct device should not be a pointer.\n\t\t * See http://thread.gmane.org/gmane.linux.kernel.pci/9081\n\t\t */\n\t\tpdev->dev.dma_mask =\n\t\t\tkmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);\n\t\tif (!pdev->dev.dma_mask)\n\t\t\tgoto err;\n\n\t\t*pdev->dev.dma_mask = pdevinfo->dma_mask;\n\t\tpdev->dev.coherent_dma_mask = pdevinfo->dma_mask;\n\t}\n\n\tret = platform_device_add_resources(pdev,\n\t\t\tpdevinfo->res, pdevinfo->num_res);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_data(pdev,\n\t\t\tpdevinfo->data, pdevinfo->size_data);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pdevinfo->properties) {\n\t\tret = platform_device_add_properties(pdev,\n\t\t\t\t\t\t     pdevinfo->properties);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\nerr:\n\t\tACPI_COMPANION_SET(&pdev->dev, NULL);\n\t\tkfree(pdev->dev.dma_mask);\n\nerr_alloc:\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pdev;\n}\nEXPORT_SYMBOL_GPL(platform_device_register_full);\n\nstatic int platform_drv_probe(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tint ret;\n\n\tret = of_clk_set_defaults(_dev->of_node, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dev_pm_domain_attach(_dev, true);\n\tif (ret != -EPROBE_DEFER) {\n\t\tif (drv->probe) {\n\t\t\tret = drv->probe(dev);\n\t\t\tif (ret)\n\t\t\t\tdev_pm_domain_detach(_dev, true);\n\t\t} else {\n\t\t\t/* don't fail if just dev_pm_domain_attach failed */\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {\n\t\tdev_warn(_dev, \"probe deferral not supported\\n\");\n\t\tret = -ENXIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int platform_drv_probe_fail(struct device *_dev)\n{\n\treturn -ENXIO;\n}\n\nstatic int platform_drv_remove(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tint ret = 0;\n\n\tif (drv->remove)\n\t\tret = drv->remove(dev);\n\tdev_pm_domain_detach(_dev, true);\n\n\treturn ret;\n}\n\nstatic void platform_drv_shutdown(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n}\n\n/**\n * __platform_driver_register - register a driver for platform-level devices\n * @drv: platform driver structure\n * @owner: owning module/driver\n */\nint __platform_driver_register(struct platform_driver *drv,\n\t\t\t\tstruct module *owner)\n{\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &platform_bus_type;\n\tdrv->driver.probe = platform_drv_probe;\n\tdrv->driver.remove = platform_drv_remove;\n\tdrv->driver.shutdown = platform_drv_shutdown;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__platform_driver_register);\n\n/**\n * platform_driver_unregister - unregister a driver for platform-level devices\n * @drv: platform driver structure\n */\nvoid platform_driver_unregister(struct platform_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(platform_driver_unregister);\n\n/**\n * __platform_driver_probe - register driver for non-hotpluggable device\n * @drv: platform driver structure\n * @probe: the driver probe routine, probably from an __init section\n * @module: module which will be the owner of the driver\n *\n * Use this instead of platform_driver_register() when you know the device\n * is not hotpluggable and has already been registered, and you want to\n * remove its run-once probe() infrastructure from memory after the driver\n * has bound to the device.\n *\n * One typical use for this would be with drivers for controllers integrated\n * into system-on-chip processors, where the controller devices have been\n * configured as part of board setup.\n *\n * Note that this is incompatible with deferred probing.\n *\n * Returns zero if the driver registered and bound to a device, else returns\n * a negative error code and with the driver not registered.\n */\nint __init_or_module __platform_driver_probe(struct platform_driver *drv,\n\t\tint (*probe)(struct platform_device *), struct module *module)\n{\n\tint retval, code;\n\n\tif (drv->driver.probe_type == PROBE_PREFER_ASYNCHRONOUS) {\n\t\tpr_err(\"%s: drivers registered with %s can not be probed asynchronously\\n\",\n\t\t\t drv->driver.name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * We have to run our probes synchronously because we check if\n\t * we find any devices to bind to and exit with error if there\n\t * are any.\n\t */\n\tdrv->driver.probe_type = PROBE_FORCE_SYNCHRONOUS;\n\n\t/*\n\t * Prevent driver from requesting probe deferral to avoid further\n\t * futile probe attempts.\n\t */\n\tdrv->prevent_deferred_probe = true;\n\n\t/* make sure driver won't have bind/unbind attributes */\n\tdrv->driver.suppress_bind_attrs = true;\n\n\t/* temporary section violation during probe() */\n\tdrv->probe = probe;\n\tretval = code = __platform_driver_register(drv, module);\n\n\t/*\n\t * Fixup that section violation, being paranoid about code scanning\n\t * the list of drivers in order to probe new devices.  Check to see\n\t * if the probe was successful, and make sure any forced probes of\n\t * new devices fail.\n\t */\n\tspin_lock(&drv->driver.bus->p->klist_drivers.k_lock);\n\tdrv->probe = NULL;\n\tif (code == 0 && list_empty(&drv->driver.p->klist_devices.k_list))\n\t\tretval = -ENODEV;\n\tdrv->driver.probe = platform_drv_probe_fail;\n\tspin_unlock(&drv->driver.bus->p->klist_drivers.k_lock);\n\n\tif (code != retval)\n\t\tplatform_driver_unregister(drv);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(__platform_driver_probe);\n\n/**\n * __platform_create_bundle - register driver and create corresponding device\n * @driver: platform driver structure\n * @probe: the driver probe routine, probably from an __init section\n * @res: set of resources that needs to be allocated for the device\n * @n_res: number of resources\n * @data: platform specific data for this platform device\n * @size: size of platform specific data\n * @module: module which will be the owner of the driver\n *\n * Use this in legacy-style modules that probe hardware directly and\n * register a single platform device and corresponding platform driver.\n *\n * Returns &struct platform_device pointer on success, or ERR_PTR() on error.\n */\nstruct platform_device * __init_or_module __platform_create_bundle(\n\t\t\tstruct platform_driver *driver,\n\t\t\tint (*probe)(struct platform_device *),\n\t\t\tstruct resource *res, unsigned int n_res,\n\t\t\tconst void *data, size_t size, struct module *module)\n{\n\tstruct platform_device *pdev;\n\tint error;\n\n\tpdev = platform_device_alloc(driver->driver.name, -1);\n\tif (!pdev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terror = platform_device_add_resources(pdev, res, n_res);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add_data(pdev, data, size);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add(pdev);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = __platform_driver_probe(driver, probe, module);\n\tif (error)\n\t\tgoto err_pdev_del;\n\n\treturn pdev;\n\nerr_pdev_del:\n\tplatform_device_del(pdev);\nerr_pdev_put:\n\tplatform_device_put(pdev);\nerr_out:\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL_GPL(__platform_create_bundle);\n\n/**\n * __platform_register_drivers - register an array of platform drivers\n * @drivers: an array of drivers to register\n * @count: the number of drivers to register\n * @owner: module owning the drivers\n *\n * Registers platform drivers specified by an array. On failure to register a\n * driver, all previously registered drivers will be unregistered. Callers of\n * this API should use platform_unregister_drivers() to unregister drivers in\n * the reverse order.\n *\n * Returns: 0 on success or a negative error code on failure.\n */\nint __platform_register_drivers(struct platform_driver * const *drivers,\n\t\t\t\tunsigned int count, struct module *owner)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"registering platform driver %ps\\n\", drivers[i]);\n\n\t\terr = __platform_driver_register(drivers[i], owner);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"failed to register platform driver %ps: %d\\n\",\n\t\t\t       drivers[i], err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[i]);\n\t\tplatform_driver_unregister(drivers[i]);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__platform_register_drivers);\n\n/**\n * platform_unregister_drivers - unregister an array of platform drivers\n * @drivers: an array of drivers to unregister\n * @count: the number of drivers to unregister\n *\n * Unegisters platform drivers specified by an array. This is typically used\n * to complement an earlier call to platform_register_drivers(). Drivers are\n * unregistered in the reverse order in which they were registered.\n */\nvoid platform_unregister_drivers(struct platform_driver * const *drivers,\n\t\t\t\t unsigned int count)\n{\n\twhile (count--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[count]);\n\t\tplatform_driver_unregister(drivers[count]);\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_unregister_drivers);\n\n/* modalias support enables more hands-off userspace setup:\n * (a) environment variable lets new-style hotplug events work once system is\n *     fully running:  \"modprobe $MODALIAS\"\n * (b) sysfs attribute lets new-style coldplug recover from hotplug events\n *     mishandled before system is fully running:  \"modprobe $(cat modalias)\"\n */\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct platform_device\t*pdev = to_platform_device(dev);\n\tint len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE -1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"platform:%s\\n\", pdev->name);\n\n\treturn (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\n\tkfree(old);\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\n\nstatic struct attribute *platform_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(platform_dev);\n\nstatic int platform_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct platform_device\t*pdev = to_platform_device(dev);\n\tint rc;\n\n\t/* Some devices have extra OF data and an OF-style MODALIAS */\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\tadd_uevent_var(env, \"MODALIAS=%s%s\", PLATFORM_MODULE_PREFIX,\n\t\t\tpdev->name);\n\treturn 0;\n}\n\nstatic const struct platform_device_id *platform_match_id(\n\t\t\tconst struct platform_device_id *id,\n\t\t\tstruct platform_device *pdev)\n{\n\twhile (id->name[0]) {\n\t\tif (strcmp(pdev->name, id->name) == 0) {\n\t\t\tpdev->id_entry = id;\n\t\t\treturn id;\n\t\t}\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\n/**\n * platform_match - bind platform device to platform driver.\n * @dev: device.\n * @drv: driver.\n *\n * Platform device IDs are assumed to be encoded like this:\n * \"<name><instance>\", where <name> is a short description of the type of\n * device, like \"pci\" or \"floppy\", and <instance> is the enumerated\n * instance of the device, like '0' or '42'.  Driver IDs are simply\n * \"<name>\".  So, extract the <name> from the platform_device structure,\n * and compare it against the name of the driver. Return whether they match\n * or not.\n */\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct platform_driver *pdrv = to_platform_driver(drv);\n\n\t/* When driver_override is set, only bind to the matching driver */\n\tif (pdev->driver_override)\n\t\treturn !strcmp(pdev->driver_override, drv->name);\n\n\t/* Attempt an OF style match first */\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t/* Then try ACPI style match */\n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t/* Then try to match against the id table */\n\tif (pdrv->id_table)\n\t\treturn platform_match_id(pdrv->id_table, pdev) != NULL;\n\n\t/* fall-back to driver name match */\n\treturn (strcmp(pdev->name, drv->name) == 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int platform_legacy_suspend(struct device *dev, pm_message_t mesg)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->suspend)\n\t\tret = pdrv->suspend(pdev, mesg);\n\n\treturn ret;\n}\n\nstatic int platform_legacy_resume(struct device *dev)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->resume)\n\t\tret = pdrv->resume(pdev);\n\n\treturn ret;\n}\n\n#endif /* CONFIG_PM_SLEEP */\n\n#ifdef CONFIG_SUSPEND\n\nint platform_pm_suspend(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->suspend)\n\t\t\tret = drv->pm->suspend(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_SUSPEND);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_resume(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->resume)\n\t\t\tret = drv->pm->resume(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif /* CONFIG_SUSPEND */\n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\n\nint platform_pm_freeze(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->freeze)\n\t\t\tret = drv->pm->freeze(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_FREEZE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_thaw(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->thaw)\n\t\t\tret = drv->pm->thaw(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_poweroff(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->poweroff)\n\t\t\tret = drv->pm->poweroff(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_HIBERNATE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_restore(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->restore)\n\t\t\tret = drv->pm->restore(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif /* CONFIG_HIBERNATE_CALLBACKS */\n\nstatic const struct dev_pm_ops platform_dev_pm_ops = {\n\t.runtime_suspend = pm_generic_runtime_suspend,\n\t.runtime_resume = pm_generic_runtime_resume,\n\tUSE_PLATFORM_PM_SLEEP_OPS\n};\n\nstruct bus_type platform_bus_type = {\n\t.name\t\t= \"platform\",\n\t.dev_groups\t= platform_dev_groups,\n\t.match\t\t= platform_match,\n\t.uevent\t\t= platform_uevent,\n\t.pm\t\t= &platform_dev_pm_ops,\n};\nEXPORT_SYMBOL_GPL(platform_bus_type);\n\nint __init platform_bus_init(void)\n{\n\tint error;\n\n\tearly_platform_cleanup();\n\n\terror = device_register(&platform_bus);\n\tif (error)\n\t\treturn error;\n\terror =  bus_register(&platform_bus_type);\n\tif (error)\n\t\tdevice_unregister(&platform_bus);\n\tof_platform_register_reconfig_notifier();\n\treturn error;\n}\n\n#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK\nu64 dma_get_required_mask(struct device *dev)\n{\n\tu32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);\n\tu32 high_totalram = ((max_pfn - 1) >> (32 - PAGE_SHIFT));\n\tu64 mask;\n\n\tif (!high_totalram) {\n\t\t/* convert to mask just covering totalram */\n\t\tlow_totalram = (1 << (fls(low_totalram) - 1));\n\t\tlow_totalram += low_totalram - 1;\n\t\tmask = low_totalram;\n\t} else {\n\t\thigh_totalram = (1 << (fls(high_totalram) - 1));\n\t\thigh_totalram += high_totalram - 1;\n\t\tmask = (((u64)high_totalram) << 32) + 0xffffffff;\n\t}\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(dma_get_required_mask);\n#endif\n\nstatic __initdata LIST_HEAD(early_platform_driver_list);\nstatic __initdata LIST_HEAD(early_platform_device_list);\n\n/**\n * early_platform_driver_register - register early platform driver\n * @epdrv: early_platform driver structure\n * @buf: string passed from early_param()\n *\n * Helper function for early_platform_init() / early_platform_init_buffer()\n */\nint __init early_platform_driver_register(struct early_platform_driver *epdrv,\n\t\t\t\t\t  char *buf)\n{\n\tchar *tmp;\n\tint n;\n\n\t/* Simply add the driver to the end of the global list.\n\t * Drivers will by default be put on the list in compiled-in order.\n\t */\n\tif (!epdrv->list.next) {\n\t\tINIT_LIST_HEAD(&epdrv->list);\n\t\tlist_add_tail(&epdrv->list, &early_platform_driver_list);\n\t}\n\n\t/* If the user has specified device then make sure the driver\n\t * gets prioritized. The driver of the last device specified on\n\t * command line will be put first on the list.\n\t */\n\tn = strlen(epdrv->pdrv->driver.name);\n\tif (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {\n\t\tlist_move(&epdrv->list, &early_platform_driver_list);\n\n\t\t/* Allow passing parameters after device name */\n\t\tif (buf[n] == '\\0' || buf[n] == ',')\n\t\t\tepdrv->requested_id = -1;\n\t\telse {\n\t\t\tepdrv->requested_id = simple_strtoul(&buf[n + 1],\n\t\t\t\t\t\t\t     &tmp, 10);\n\n\t\t\tif (buf[n] != '.' || (tmp == &buf[n + 1])) {\n\t\t\t\tepdrv->requested_id = EARLY_PLATFORM_ID_ERROR;\n\t\t\t\tn = 0;\n\t\t\t} else\n\t\t\t\tn += strcspn(&buf[n + 1], \",\") + 1;\n\t\t}\n\n\t\tif (buf[n] == ',')\n\t\t\tn++;\n\n\t\tif (epdrv->bufsize) {\n\t\t\tmemcpy(epdrv->buffer, &buf[n],\n\t\t\t       min_t(int, epdrv->bufsize, strlen(&buf[n]) + 1));\n\t\t\tepdrv->buffer[epdrv->bufsize - 1] = '\\0';\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * early_platform_add_devices - adds a number of early platform devices\n * @devs: array of early platform devices to add\n * @num: number of early platform devices in array\n *\n * Used by early architecture code to register early platform devices and\n * their platform data.\n */\nvoid __init early_platform_add_devices(struct platform_device **devs, int num)\n{\n\tstruct device *dev;\n\tint i;\n\n\t/* simply add the devices to list */\n\tfor (i = 0; i < num; i++) {\n\t\tdev = &devs[i]->dev;\n\n\t\tif (!dev->devres_head.next) {\n\t\t\tpm_runtime_early_init(dev);\n\t\t\tINIT_LIST_HEAD(&dev->devres_head);\n\t\t\tlist_add_tail(&dev->devres_head,\n\t\t\t\t      &early_platform_device_list);\n\t\t}\n\t}\n}\n\n/**\n * early_platform_driver_register_all - register early platform drivers\n * @class_str: string to identify early platform driver class\n *\n * Used by architecture code to register all early platform drivers\n * for a certain class. If omitted then only early platform drivers\n * with matching kernel command line class parameters will be registered.\n */\nvoid __init early_platform_driver_register_all(char *class_str)\n{\n\t/* The \"class_str\" parameter may or may not be present on the kernel\n\t * command line. If it is present then there may be more than one\n\t * matching parameter.\n\t *\n\t * Since we register our early platform drivers using early_param()\n\t * we need to make sure that they also get registered in the case\n\t * when the parameter is missing from the kernel command line.\n\t *\n\t * We use parse_early_options() to make sure the early_param() gets\n\t * called at least once. The early_param() may be called more than\n\t * once since the name of the preferred device may be specified on\n\t * the kernel command line. early_platform_driver_register() handles\n\t * this case for us.\n\t */\n\tparse_early_options(class_str);\n}\n\n/**\n * early_platform_match - find early platform device matching driver\n * @epdrv: early platform driver structure\n * @id: id to match against\n */\nstatic struct platform_device * __init\nearly_platform_match(struct early_platform_driver *epdrv, int id)\n{\n\tstruct platform_device *pd;\n\n\tlist_for_each_entry(pd, &early_platform_device_list, dev.devres_head)\n\t\tif (platform_match(&pd->dev, &epdrv->pdrv->driver))\n\t\t\tif (pd->id == id)\n\t\t\t\treturn pd;\n\n\treturn NULL;\n}\n\n/**\n * early_platform_left - check if early platform driver has matching devices\n * @epdrv: early platform driver structure\n * @id: return true if id or above exists\n */\nstatic int __init early_platform_left(struct early_platform_driver *epdrv,\n\t\t\t\t       int id)\n{\n\tstruct platform_device *pd;\n\n\tlist_for_each_entry(pd, &early_platform_device_list, dev.devres_head)\n\t\tif (platform_match(&pd->dev, &epdrv->pdrv->driver))\n\t\t\tif (pd->id >= id)\n\t\t\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * early_platform_driver_probe_id - probe drivers matching class_str and id\n * @class_str: string to identify early platform driver class\n * @id: id to match against\n * @nr_probe: number of platform devices to successfully probe before exiting\n */\nstatic int __init early_platform_driver_probe_id(char *class_str,\n\t\t\t\t\t\t int id,\n\t\t\t\t\t\t int nr_probe)\n{\n\tstruct early_platform_driver *epdrv;\n\tstruct platform_device *match;\n\tint match_id;\n\tint n = 0;\n\tint left = 0;\n\n\tlist_for_each_entry(epdrv, &early_platform_driver_list, list) {\n\t\t/* only use drivers matching our class_str */\n\t\tif (strcmp(class_str, epdrv->class_str))\n\t\t\tcontinue;\n\n\t\tif (id == -2) {\n\t\t\tmatch_id = epdrv->requested_id;\n\t\t\tleft = 1;\n\n\t\t} else {\n\t\t\tmatch_id = id;\n\t\t\tleft += early_platform_left(epdrv, id);\n\n\t\t\t/* skip requested id */\n\t\t\tswitch (epdrv->requested_id) {\n\t\t\tcase EARLY_PLATFORM_ID_ERROR:\n\t\t\tcase EARLY_PLATFORM_ID_UNSET:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (epdrv->requested_id == id)\n\t\t\t\t\tmatch_id = EARLY_PLATFORM_ID_UNSET;\n\t\t\t}\n\t\t}\n\n\t\tswitch (match_id) {\n\t\tcase EARLY_PLATFORM_ID_ERROR:\n\t\t\tpr_warn(\"%s: unable to parse %s parameter\\n\",\n\t\t\t\tclass_str, epdrv->pdrv->driver.name);\n\t\t\t/* fall-through */\n\t\tcase EARLY_PLATFORM_ID_UNSET:\n\t\t\tmatch = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmatch = early_platform_match(epdrv, match_id);\n\t\t}\n\n\t\tif (match) {\n\t\t\t/*\n\t\t\t * Set up a sensible init_name to enable\n\t\t\t * dev_name() and others to be used before the\n\t\t\t * rest of the driver core is initialized.\n\t\t\t */\n\t\t\tif (!match->dev.init_name && slab_is_available()) {\n\t\t\t\tif (match->id != -1)\n\t\t\t\t\tmatch->dev.init_name =\n\t\t\t\t\t\tkasprintf(GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t\t\t  match->name,\n\t\t\t\t\t\t\t  match->id);\n\t\t\t\telse\n\t\t\t\t\tmatch->dev.init_name =\n\t\t\t\t\t\tkasprintf(GFP_KERNEL, \"%s\",\n\t\t\t\t\t\t\t  match->name);\n\n\t\t\t\tif (!match->dev.init_name)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tif (epdrv->pdrv->probe(match))\n\t\t\t\tpr_warn(\"%s: unable to probe %s early.\\n\",\n\t\t\t\t\tclass_str, match->name);\n\t\t\telse\n\t\t\t\tn++;\n\t\t}\n\n\t\tif (n >= nr_probe)\n\t\t\tbreak;\n\t}\n\n\tif (left)\n\t\treturn n;\n\telse\n\t\treturn -ENODEV;\n}\n\n/**\n * early_platform_driver_probe - probe a class of registered drivers\n * @class_str: string to identify early platform driver class\n * @nr_probe: number of platform devices to successfully probe before exiting\n * @user_only: only probe user specified early platform devices\n *\n * Used by architecture code to probe registered early platform drivers\n * within a certain class. For probe to happen a registered early platform\n * device matching a registered early platform driver is needed.\n */\nint __init early_platform_driver_probe(char *class_str,\n\t\t\t\t       int nr_probe,\n\t\t\t\t       int user_only)\n{\n\tint k, n, i;\n\n\tn = 0;\n\tfor (i = -2; n < nr_probe; i++) {\n\t\tk = early_platform_driver_probe_id(class_str, i, nr_probe - n);\n\n\t\tif (k < 0)\n\t\t\tbreak;\n\n\t\tn += k;\n\n\t\tif (user_only)\n\t\t\tbreak;\n\t}\n\n\treturn n;\n}\n\n/**\n * early_platform_cleanup - clean up early platform code\n */\nvoid __init early_platform_cleanup(void)\n{\n\tstruct platform_device *pd, *pd2;\n\n\t/* clean up the devres list used to chain devices */\n\tlist_for_each_entry_safe(pd, pd2, &early_platform_device_list,\n\t\t\t\t dev.devres_head) {\n\t\tlist_del(&pd->dev.devres_head);\n\t\tmemset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));\n\t}\n}\n\n"], "fixing_code": ["/*\n * platform.c - platform 'pseudo' bus for legacy devices\n *\n * Copyright (c) 2002-3 Patrick Mochel\n * Copyright (c) 2002-3 Open Source Development Labs\n *\n * This file is released under the GPLv2\n *\n * Please see Documentation/driver-model/platform.txt for more\n * information.\n */\n\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/bootmem.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/idr.h>\n#include <linux/acpi.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/limits.h>\n#include <linux/property.h>\n\n#include \"base.h\"\n#include \"power/power.h\"\n\n/* For automatically allocated device IDs */\nstatic DEFINE_IDA(platform_devid_ida);\n\nstruct device platform_bus = {\n\t.init_name\t= \"platform\",\n};\nEXPORT_SYMBOL_GPL(platform_bus);\n\n/**\n * arch_setup_pdev_archdata - Allow manipulation of archdata before its used\n * @pdev: platform device\n *\n * This is called before platform_device_add() such that any pdev_archdata may\n * be setup before the platform_notifier is called.  So if a user needs to\n * manipulate any relevant information in the pdev_archdata they can do:\n *\n *\tplatform_device_alloc()\n *\t... manipulate ...\n *\tplatform_device_add()\n *\n * And if they don't care they can just call platform_device_register() and\n * everything will just work out.\n */\nvoid __weak arch_setup_pdev_archdata(struct platform_device *pdev)\n{\n}\n\n/**\n * platform_get_resource - get a resource for a device\n * @dev: platform device\n * @type: resource type\n * @num: resource index\n */\nstruct resource *platform_get_resource(struct platform_device *dev,\n\t\t\t\t       unsigned int type, unsigned int num)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (type == resource_type(r) && num-- == 0)\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource);\n\n/**\n * platform_get_irq - get an IRQ for a device\n * @dev: platform device\n * @num: IRQ number index\n */\nint platform_get_irq(struct platform_device *dev, unsigned int num)\n{\n#ifdef CONFIG_SPARC\n\t/* sparc does not have irqs represented as IORESOURCE_IRQ resources */\n\tif (!dev || num >= dev->archdata.num_irqs)\n\t\treturn -ENXIO;\n\treturn dev->archdata.irqs[num];\n#else\n\tstruct resource *r;\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get(dev->dev.of_node, num);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, num);\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tif (r && r->flags & IORESOURCE_DISABLED) {\n\t\t\tint ret;\n\n\t\t\tret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * The resources may pass trigger flags to the irqs that need\n\t * to be set up. It so happens that the trigger flags for\n\t * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*\n\t * settings.\n\t */\n\tif (r && r->flags & IORESOURCE_BITS) {\n\t\tstruct irq_data *irqd;\n\n\t\tirqd = irq_get_irq_data(r->start);\n\t\tif (!irqd)\n\t\t\treturn -ENXIO;\n\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t}\n\n\treturn r ? r->start : -ENXIO;\n#endif\n}\nEXPORT_SYMBOL_GPL(platform_get_irq);\n\n/**\n * platform_irq_count - Count the number of IRQs a platform device uses\n * @dev: platform device\n *\n * Return: Number of IRQs a platform device uses or EPROBE_DEFER\n */\nint platform_irq_count(struct platform_device *dev)\n{\n\tint ret, nr = 0;\n\n\twhile ((ret = platform_get_irq(dev, nr)) >= 0)\n\t\tnr++;\n\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\treturn nr;\n}\nEXPORT_SYMBOL_GPL(platform_irq_count);\n\n/**\n * platform_get_resource_byname - get a resource for a device by name\n * @dev: platform device\n * @type: resource type\n * @name: resource name\n */\nstruct resource *platform_get_resource_byname(struct platform_device *dev,\n\t\t\t\t\t      unsigned int type,\n\t\t\t\t\t      const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (unlikely(!r->name))\n\t\t\tcontinue;\n\n\t\tif (type == resource_type(r) && !strcmp(r->name, name))\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n\n/**\n * platform_get_irq_byname - get an IRQ for a device by name\n * @dev: platform device\n * @name: IRQ name\n */\nint platform_get_irq_byname(struct platform_device *dev, const char *name)\n{\n\tstruct resource *r;\n\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get_byname(dev->dev.of_node, name);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);\n\treturn r ? r->start : -ENXIO;\n}\nEXPORT_SYMBOL_GPL(platform_get_irq_byname);\n\n/**\n * platform_add_devices - add a numbers of platform devices\n * @devs: array of platform devices to add\n * @num: number of platform devices in array\n */\nint platform_add_devices(struct platform_device **devs, int num)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = platform_device_register(devs[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tplatform_device_unregister(devs[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_add_devices);\n\nstruct platform_object {\n\tstruct platform_device pdev;\n\tchar name[];\n};\n\n/**\n * platform_device_put - destroy a platform device\n * @pdev: platform device to free\n *\n * Free all memory associated with a platform device.  This function must\n * _only_ be externally called in error cases.  All other usage is a bug.\n */\nvoid platform_device_put(struct platform_device *pdev)\n{\n\tif (pdev)\n\t\tput_device(&pdev->dev);\n}\nEXPORT_SYMBOL_GPL(platform_device_put);\n\nstatic void platform_device_release(struct device *dev)\n{\n\tstruct platform_object *pa = container_of(dev, struct platform_object,\n\t\t\t\t\t\t  pdev.dev);\n\n\tof_device_node_put(&pa->pdev.dev);\n\tkfree(pa->pdev.dev.platform_data);\n\tkfree(pa->pdev.mfd_cell);\n\tkfree(pa->pdev.resource);\n\tkfree(pa->pdev.driver_override);\n\tkfree(pa);\n}\n\n/**\n * platform_device_alloc - create a platform device\n * @name: base name of the device we're adding\n * @id: instance id\n *\n * Create a platform device object which can have other objects attached\n * to it, and which will have attached objects freed when it is released.\n */\nstruct platform_device *platform_device_alloc(const char *name, int id)\n{\n\tstruct platform_object *pa;\n\n\tpa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);\n\tif (pa) {\n\t\tstrcpy(pa->name, name);\n\t\tpa->pdev.name = pa->name;\n\t\tpa->pdev.id = id;\n\t\tdevice_initialize(&pa->pdev.dev);\n\t\tpa->pdev.dev.release = platform_device_release;\n\t\tarch_setup_pdev_archdata(&pa->pdev);\n\t}\n\n\treturn pa ? &pa->pdev : NULL;\n}\nEXPORT_SYMBOL_GPL(platform_device_alloc);\n\n/**\n * platform_device_add_resources - add resources to a platform device\n * @pdev: platform device allocated by platform_device_alloc to add resources to\n * @res: set of resources that needs to be allocated for the device\n * @num: number of resources\n *\n * Add a copy of the resources to the platform device.  The memory\n * associated with the resources will be freed when the platform device is\n * released.\n */\nint platform_device_add_resources(struct platform_device *pdev,\n\t\t\t\t  const struct resource *res, unsigned int num)\n{\n\tstruct resource *r = NULL;\n\n\tif (res) {\n\t\tr = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);\n\t\tif (!r)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->resource);\n\tpdev->resource = r;\n\tpdev->num_resources = num;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_resources);\n\n/**\n * platform_device_add_data - add platform-specific data to a platform device\n * @pdev: platform device allocated by platform_device_alloc to add resources to\n * @data: platform specific data for this platform device\n * @size: size of platform specific data\n *\n * Add a copy of platform specific data to the platform device's\n * platform_data pointer.  The memory associated with the platform data\n * will be freed when the platform device is released.\n */\nint platform_device_add_data(struct platform_device *pdev, const void *data,\n\t\t\t     size_t size)\n{\n\tvoid *d = NULL;\n\n\tif (data) {\n\t\td = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!d)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->dev.platform_data);\n\tpdev->dev.platform_data = d;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_data);\n\n/**\n * platform_device_add_properties - add built-in properties to a platform device\n * @pdev: platform device to add properties to\n * @properties: null terminated array of properties to add\n *\n * The function will take deep copy of @properties and attach the copy to the\n * platform device. The memory associated with properties will be freed when the\n * platform device is released.\n */\nint platform_device_add_properties(struct platform_device *pdev,\n\t\t\t\t   struct property_entry *properties)\n{\n\treturn device_add_properties(&pdev->dev, properties);\n}\nEXPORT_SYMBOL_GPL(platform_device_add_properties);\n\n/**\n * platform_device_add - add a platform device to device hierarchy\n * @pdev: platform device we're adding\n *\n * This is part 2 of platform_device_register(), though may be called\n * separately _iff_ pdev was allocated by platform_device_alloc().\n */\nint platform_device_add(struct platform_device *pdev)\n{\n\tint i, ret;\n\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tif (!pdev->dev.parent)\n\t\tpdev->dev.parent = &platform_bus;\n\n\tpdev->dev.bus = &platform_bus_type;\n\n\tswitch (pdev->id) {\n\tdefault:\n\t\tdev_set_name(&pdev->dev, \"%s.%d\", pdev->name,  pdev->id);\n\t\tbreak;\n\tcase PLATFORM_DEVID_NONE:\n\t\tdev_set_name(&pdev->dev, \"%s\", pdev->name);\n\t\tbreak;\n\tcase PLATFORM_DEVID_AUTO:\n\t\t/*\n\t\t * Automatically allocated device ID. We mark it as such so\n\t\t * that we remember it must be freed, and we append a suffix\n\t\t * to avoid namespace collision with explicit IDs.\n\t\t */\n\t\tret = ida_simple_get(&platform_devid_ida, 0, 0, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\t\tpdev->id = ret;\n\t\tpdev->id_auto = true;\n\t\tdev_set_name(&pdev->dev, \"%s.%d.auto\", pdev->name, pdev->id);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\tstruct resource *p, *r = &pdev->resource[i];\n\n\t\tif (r->name == NULL)\n\t\t\tr->name = dev_name(&pdev->dev);\n\n\t\tp = r->parent;\n\t\tif (!p) {\n\t\t\tif (resource_type(r) == IORESOURCE_MEM)\n\t\t\t\tp = &iomem_resource;\n\t\t\telse if (resource_type(r) == IORESOURCE_IO)\n\t\t\t\tp = &ioport_resource;\n\t\t}\n\n\t\tif (p && insert_resource(p, r)) {\n\t\t\tdev_err(&pdev->dev, \"failed to claim resource %d: %pR\\n\", i, r);\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tpr_debug(\"Registering platform device '%s'. Parent at %s\\n\",\n\t\t dev_name(&pdev->dev), dev_name(pdev->dev.parent));\n\n\tret = device_add(&pdev->dev);\n\tif (ret == 0)\n\t\treturn ret;\n\n failed:\n\tif (pdev->id_auto) {\n\t\tida_simple_remove(&platform_devid_ida, pdev->id);\n\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t}\n\n\twhile (--i >= 0) {\n\t\tstruct resource *r = &pdev->resource[i];\n\t\tif (r->parent)\n\t\t\trelease_resource(r);\n\t}\n\n err_out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_device_add);\n\n/**\n * platform_device_del - remove a platform-level device\n * @pdev: platform device we're removing\n *\n * Note that this function will also release all memory- and port-based\n * resources owned by the device (@dev->resource).  This function must\n * _only_ be externally called in error cases.  All other usage is a bug.\n */\nvoid platform_device_del(struct platform_device *pdev)\n{\n\tint i;\n\n\tif (pdev) {\n\t\tdevice_remove_properties(&pdev->dev);\n\t\tdevice_del(&pdev->dev);\n\n\t\tif (pdev->id_auto) {\n\t\t\tida_simple_remove(&platform_devid_ida, pdev->id);\n\t\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t\t}\n\n\t\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\t\tstruct resource *r = &pdev->resource[i];\n\t\t\tif (r->parent)\n\t\t\t\trelease_resource(r);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_device_del);\n\n/**\n * platform_device_register - add a platform-level device\n * @pdev: platform device we're adding\n */\nint platform_device_register(struct platform_device *pdev)\n{\n\tdevice_initialize(&pdev->dev);\n\tarch_setup_pdev_archdata(pdev);\n\treturn platform_device_add(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_register);\n\n/**\n * platform_device_unregister - unregister a platform-level device\n * @pdev: platform device we're unregistering\n *\n * Unregistration is done in 2 steps. First we release all resources\n * and remove it from the subsystem, then we drop reference count by\n * calling platform_device_put().\n */\nvoid platform_device_unregister(struct platform_device *pdev)\n{\n\tplatform_device_del(pdev);\n\tplatform_device_put(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_unregister);\n\n/**\n * platform_device_register_full - add a platform-level device with\n * resources and platform-specific data\n *\n * @pdevinfo: data used to create device\n *\n * Returns &struct platform_device pointer on success, or ERR_PTR() on error.\n */\nstruct platform_device *platform_device_register_full(\n\t\tconst struct platform_device_info *pdevinfo)\n{\n\tint ret = -ENOMEM;\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);\n\tif (!pdev)\n\t\tgoto err_alloc;\n\n\tpdev->dev.parent = pdevinfo->parent;\n\tpdev->dev.fwnode = pdevinfo->fwnode;\n\n\tif (pdevinfo->dma_mask) {\n\t\t/*\n\t\t * This memory isn't freed when the device is put,\n\t\t * I don't have a nice idea for that though.  Conceptually\n\t\t * dma_mask in struct device should not be a pointer.\n\t\t * See http://thread.gmane.org/gmane.linux.kernel.pci/9081\n\t\t */\n\t\tpdev->dev.dma_mask =\n\t\t\tkmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);\n\t\tif (!pdev->dev.dma_mask)\n\t\t\tgoto err;\n\n\t\t*pdev->dev.dma_mask = pdevinfo->dma_mask;\n\t\tpdev->dev.coherent_dma_mask = pdevinfo->dma_mask;\n\t}\n\n\tret = platform_device_add_resources(pdev,\n\t\t\tpdevinfo->res, pdevinfo->num_res);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_data(pdev,\n\t\t\tpdevinfo->data, pdevinfo->size_data);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pdevinfo->properties) {\n\t\tret = platform_device_add_properties(pdev,\n\t\t\t\t\t\t     pdevinfo->properties);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\nerr:\n\t\tACPI_COMPANION_SET(&pdev->dev, NULL);\n\t\tkfree(pdev->dev.dma_mask);\n\nerr_alloc:\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pdev;\n}\nEXPORT_SYMBOL_GPL(platform_device_register_full);\n\nstatic int platform_drv_probe(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tint ret;\n\n\tret = of_clk_set_defaults(_dev->of_node, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dev_pm_domain_attach(_dev, true);\n\tif (ret != -EPROBE_DEFER) {\n\t\tif (drv->probe) {\n\t\t\tret = drv->probe(dev);\n\t\t\tif (ret)\n\t\t\t\tdev_pm_domain_detach(_dev, true);\n\t\t} else {\n\t\t\t/* don't fail if just dev_pm_domain_attach failed */\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {\n\t\tdev_warn(_dev, \"probe deferral not supported\\n\");\n\t\tret = -ENXIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int platform_drv_probe_fail(struct device *_dev)\n{\n\treturn -ENXIO;\n}\n\nstatic int platform_drv_remove(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tint ret = 0;\n\n\tif (drv->remove)\n\t\tret = drv->remove(dev);\n\tdev_pm_domain_detach(_dev, true);\n\n\treturn ret;\n}\n\nstatic void platform_drv_shutdown(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n}\n\n/**\n * __platform_driver_register - register a driver for platform-level devices\n * @drv: platform driver structure\n * @owner: owning module/driver\n */\nint __platform_driver_register(struct platform_driver *drv,\n\t\t\t\tstruct module *owner)\n{\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &platform_bus_type;\n\tdrv->driver.probe = platform_drv_probe;\n\tdrv->driver.remove = platform_drv_remove;\n\tdrv->driver.shutdown = platform_drv_shutdown;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__platform_driver_register);\n\n/**\n * platform_driver_unregister - unregister a driver for platform-level devices\n * @drv: platform driver structure\n */\nvoid platform_driver_unregister(struct platform_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(platform_driver_unregister);\n\n/**\n * __platform_driver_probe - register driver for non-hotpluggable device\n * @drv: platform driver structure\n * @probe: the driver probe routine, probably from an __init section\n * @module: module which will be the owner of the driver\n *\n * Use this instead of platform_driver_register() when you know the device\n * is not hotpluggable and has already been registered, and you want to\n * remove its run-once probe() infrastructure from memory after the driver\n * has bound to the device.\n *\n * One typical use for this would be with drivers for controllers integrated\n * into system-on-chip processors, where the controller devices have been\n * configured as part of board setup.\n *\n * Note that this is incompatible with deferred probing.\n *\n * Returns zero if the driver registered and bound to a device, else returns\n * a negative error code and with the driver not registered.\n */\nint __init_or_module __platform_driver_probe(struct platform_driver *drv,\n\t\tint (*probe)(struct platform_device *), struct module *module)\n{\n\tint retval, code;\n\n\tif (drv->driver.probe_type == PROBE_PREFER_ASYNCHRONOUS) {\n\t\tpr_err(\"%s: drivers registered with %s can not be probed asynchronously\\n\",\n\t\t\t drv->driver.name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * We have to run our probes synchronously because we check if\n\t * we find any devices to bind to and exit with error if there\n\t * are any.\n\t */\n\tdrv->driver.probe_type = PROBE_FORCE_SYNCHRONOUS;\n\n\t/*\n\t * Prevent driver from requesting probe deferral to avoid further\n\t * futile probe attempts.\n\t */\n\tdrv->prevent_deferred_probe = true;\n\n\t/* make sure driver won't have bind/unbind attributes */\n\tdrv->driver.suppress_bind_attrs = true;\n\n\t/* temporary section violation during probe() */\n\tdrv->probe = probe;\n\tretval = code = __platform_driver_register(drv, module);\n\n\t/*\n\t * Fixup that section violation, being paranoid about code scanning\n\t * the list of drivers in order to probe new devices.  Check to see\n\t * if the probe was successful, and make sure any forced probes of\n\t * new devices fail.\n\t */\n\tspin_lock(&drv->driver.bus->p->klist_drivers.k_lock);\n\tdrv->probe = NULL;\n\tif (code == 0 && list_empty(&drv->driver.p->klist_devices.k_list))\n\t\tretval = -ENODEV;\n\tdrv->driver.probe = platform_drv_probe_fail;\n\tspin_unlock(&drv->driver.bus->p->klist_drivers.k_lock);\n\n\tif (code != retval)\n\t\tplatform_driver_unregister(drv);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(__platform_driver_probe);\n\n/**\n * __platform_create_bundle - register driver and create corresponding device\n * @driver: platform driver structure\n * @probe: the driver probe routine, probably from an __init section\n * @res: set of resources that needs to be allocated for the device\n * @n_res: number of resources\n * @data: platform specific data for this platform device\n * @size: size of platform specific data\n * @module: module which will be the owner of the driver\n *\n * Use this in legacy-style modules that probe hardware directly and\n * register a single platform device and corresponding platform driver.\n *\n * Returns &struct platform_device pointer on success, or ERR_PTR() on error.\n */\nstruct platform_device * __init_or_module __platform_create_bundle(\n\t\t\tstruct platform_driver *driver,\n\t\t\tint (*probe)(struct platform_device *),\n\t\t\tstruct resource *res, unsigned int n_res,\n\t\t\tconst void *data, size_t size, struct module *module)\n{\n\tstruct platform_device *pdev;\n\tint error;\n\n\tpdev = platform_device_alloc(driver->driver.name, -1);\n\tif (!pdev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terror = platform_device_add_resources(pdev, res, n_res);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add_data(pdev, data, size);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add(pdev);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = __platform_driver_probe(driver, probe, module);\n\tif (error)\n\t\tgoto err_pdev_del;\n\n\treturn pdev;\n\nerr_pdev_del:\n\tplatform_device_del(pdev);\nerr_pdev_put:\n\tplatform_device_put(pdev);\nerr_out:\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL_GPL(__platform_create_bundle);\n\n/**\n * __platform_register_drivers - register an array of platform drivers\n * @drivers: an array of drivers to register\n * @count: the number of drivers to register\n * @owner: module owning the drivers\n *\n * Registers platform drivers specified by an array. On failure to register a\n * driver, all previously registered drivers will be unregistered. Callers of\n * this API should use platform_unregister_drivers() to unregister drivers in\n * the reverse order.\n *\n * Returns: 0 on success or a negative error code on failure.\n */\nint __platform_register_drivers(struct platform_driver * const *drivers,\n\t\t\t\tunsigned int count, struct module *owner)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"registering platform driver %ps\\n\", drivers[i]);\n\n\t\terr = __platform_driver_register(drivers[i], owner);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"failed to register platform driver %ps: %d\\n\",\n\t\t\t       drivers[i], err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[i]);\n\t\tplatform_driver_unregister(drivers[i]);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__platform_register_drivers);\n\n/**\n * platform_unregister_drivers - unregister an array of platform drivers\n * @drivers: an array of drivers to unregister\n * @count: the number of drivers to unregister\n *\n * Unegisters platform drivers specified by an array. This is typically used\n * to complement an earlier call to platform_register_drivers(). Drivers are\n * unregistered in the reverse order in which they were registered.\n */\nvoid platform_unregister_drivers(struct platform_driver * const *drivers,\n\t\t\t\t unsigned int count)\n{\n\twhile (count--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[count]);\n\t\tplatform_driver_unregister(drivers[count]);\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_unregister_drivers);\n\n/* modalias support enables more hands-off userspace setup:\n * (a) environment variable lets new-style hotplug events work once system is\n *     fully running:  \"modprobe $MODALIAS\"\n * (b) sysfs attribute lets new-style coldplug recover from hotplug events\n *     mishandled before system is fully running:  \"modprobe $(cat modalias)\"\n */\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct platform_device\t*pdev = to_platform_device(dev);\n\tint len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE -1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"platform:%s\\n\", pdev->name);\n\n\treturn (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tdevice_lock(dev);\n\told = pdev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tdevice_unlock(dev);\n\n\tkfree(old);\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);\n\tdevice_unlock(dev);\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\n\nstatic struct attribute *platform_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(platform_dev);\n\nstatic int platform_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct platform_device\t*pdev = to_platform_device(dev);\n\tint rc;\n\n\t/* Some devices have extra OF data and an OF-style MODALIAS */\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\tadd_uevent_var(env, \"MODALIAS=%s%s\", PLATFORM_MODULE_PREFIX,\n\t\t\tpdev->name);\n\treturn 0;\n}\n\nstatic const struct platform_device_id *platform_match_id(\n\t\t\tconst struct platform_device_id *id,\n\t\t\tstruct platform_device *pdev)\n{\n\twhile (id->name[0]) {\n\t\tif (strcmp(pdev->name, id->name) == 0) {\n\t\t\tpdev->id_entry = id;\n\t\t\treturn id;\n\t\t}\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\n/**\n * platform_match - bind platform device to platform driver.\n * @dev: device.\n * @drv: driver.\n *\n * Platform device IDs are assumed to be encoded like this:\n * \"<name><instance>\", where <name> is a short description of the type of\n * device, like \"pci\" or \"floppy\", and <instance> is the enumerated\n * instance of the device, like '0' or '42'.  Driver IDs are simply\n * \"<name>\".  So, extract the <name> from the platform_device structure,\n * and compare it against the name of the driver. Return whether they match\n * or not.\n */\nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct platform_driver *pdrv = to_platform_driver(drv);\n\n\t/* When driver_override is set, only bind to the matching driver */\n\tif (pdev->driver_override)\n\t\treturn !strcmp(pdev->driver_override, drv->name);\n\n\t/* Attempt an OF style match first */\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t/* Then try ACPI style match */\n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t/* Then try to match against the id table */\n\tif (pdrv->id_table)\n\t\treturn platform_match_id(pdrv->id_table, pdev) != NULL;\n\n\t/* fall-back to driver name match */\n\treturn (strcmp(pdev->name, drv->name) == 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int platform_legacy_suspend(struct device *dev, pm_message_t mesg)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->suspend)\n\t\tret = pdrv->suspend(pdev, mesg);\n\n\treturn ret;\n}\n\nstatic int platform_legacy_resume(struct device *dev)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->resume)\n\t\tret = pdrv->resume(pdev);\n\n\treturn ret;\n}\n\n#endif /* CONFIG_PM_SLEEP */\n\n#ifdef CONFIG_SUSPEND\n\nint platform_pm_suspend(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->suspend)\n\t\t\tret = drv->pm->suspend(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_SUSPEND);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_resume(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->resume)\n\t\t\tret = drv->pm->resume(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif /* CONFIG_SUSPEND */\n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\n\nint platform_pm_freeze(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->freeze)\n\t\t\tret = drv->pm->freeze(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_FREEZE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_thaw(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->thaw)\n\t\t\tret = drv->pm->thaw(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_poweroff(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->poweroff)\n\t\t\tret = drv->pm->poweroff(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_HIBERNATE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_restore(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->restore)\n\t\t\tret = drv->pm->restore(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif /* CONFIG_HIBERNATE_CALLBACKS */\n\nstatic const struct dev_pm_ops platform_dev_pm_ops = {\n\t.runtime_suspend = pm_generic_runtime_suspend,\n\t.runtime_resume = pm_generic_runtime_resume,\n\tUSE_PLATFORM_PM_SLEEP_OPS\n};\n\nstruct bus_type platform_bus_type = {\n\t.name\t\t= \"platform\",\n\t.dev_groups\t= platform_dev_groups,\n\t.match\t\t= platform_match,\n\t.uevent\t\t= platform_uevent,\n\t.pm\t\t= &platform_dev_pm_ops,\n};\nEXPORT_SYMBOL_GPL(platform_bus_type);\n\nint __init platform_bus_init(void)\n{\n\tint error;\n\n\tearly_platform_cleanup();\n\n\terror = device_register(&platform_bus);\n\tif (error)\n\t\treturn error;\n\terror =  bus_register(&platform_bus_type);\n\tif (error)\n\t\tdevice_unregister(&platform_bus);\n\tof_platform_register_reconfig_notifier();\n\treturn error;\n}\n\n#ifndef ARCH_HAS_DMA_GET_REQUIRED_MASK\nu64 dma_get_required_mask(struct device *dev)\n{\n\tu32 low_totalram = ((max_pfn - 1) << PAGE_SHIFT);\n\tu32 high_totalram = ((max_pfn - 1) >> (32 - PAGE_SHIFT));\n\tu64 mask;\n\n\tif (!high_totalram) {\n\t\t/* convert to mask just covering totalram */\n\t\tlow_totalram = (1 << (fls(low_totalram) - 1));\n\t\tlow_totalram += low_totalram - 1;\n\t\tmask = low_totalram;\n\t} else {\n\t\thigh_totalram = (1 << (fls(high_totalram) - 1));\n\t\thigh_totalram += high_totalram - 1;\n\t\tmask = (((u64)high_totalram) << 32) + 0xffffffff;\n\t}\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(dma_get_required_mask);\n#endif\n\nstatic __initdata LIST_HEAD(early_platform_driver_list);\nstatic __initdata LIST_HEAD(early_platform_device_list);\n\n/**\n * early_platform_driver_register - register early platform driver\n * @epdrv: early_platform driver structure\n * @buf: string passed from early_param()\n *\n * Helper function for early_platform_init() / early_platform_init_buffer()\n */\nint __init early_platform_driver_register(struct early_platform_driver *epdrv,\n\t\t\t\t\t  char *buf)\n{\n\tchar *tmp;\n\tint n;\n\n\t/* Simply add the driver to the end of the global list.\n\t * Drivers will by default be put on the list in compiled-in order.\n\t */\n\tif (!epdrv->list.next) {\n\t\tINIT_LIST_HEAD(&epdrv->list);\n\t\tlist_add_tail(&epdrv->list, &early_platform_driver_list);\n\t}\n\n\t/* If the user has specified device then make sure the driver\n\t * gets prioritized. The driver of the last device specified on\n\t * command line will be put first on the list.\n\t */\n\tn = strlen(epdrv->pdrv->driver.name);\n\tif (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {\n\t\tlist_move(&epdrv->list, &early_platform_driver_list);\n\n\t\t/* Allow passing parameters after device name */\n\t\tif (buf[n] == '\\0' || buf[n] == ',')\n\t\t\tepdrv->requested_id = -1;\n\t\telse {\n\t\t\tepdrv->requested_id = simple_strtoul(&buf[n + 1],\n\t\t\t\t\t\t\t     &tmp, 10);\n\n\t\t\tif (buf[n] != '.' || (tmp == &buf[n + 1])) {\n\t\t\t\tepdrv->requested_id = EARLY_PLATFORM_ID_ERROR;\n\t\t\t\tn = 0;\n\t\t\t} else\n\t\t\t\tn += strcspn(&buf[n + 1], \",\") + 1;\n\t\t}\n\n\t\tif (buf[n] == ',')\n\t\t\tn++;\n\n\t\tif (epdrv->bufsize) {\n\t\t\tmemcpy(epdrv->buffer, &buf[n],\n\t\t\t       min_t(int, epdrv->bufsize, strlen(&buf[n]) + 1));\n\t\t\tepdrv->buffer[epdrv->bufsize - 1] = '\\0';\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * early_platform_add_devices - adds a number of early platform devices\n * @devs: array of early platform devices to add\n * @num: number of early platform devices in array\n *\n * Used by early architecture code to register early platform devices and\n * their platform data.\n */\nvoid __init early_platform_add_devices(struct platform_device **devs, int num)\n{\n\tstruct device *dev;\n\tint i;\n\n\t/* simply add the devices to list */\n\tfor (i = 0; i < num; i++) {\n\t\tdev = &devs[i]->dev;\n\n\t\tif (!dev->devres_head.next) {\n\t\t\tpm_runtime_early_init(dev);\n\t\t\tINIT_LIST_HEAD(&dev->devres_head);\n\t\t\tlist_add_tail(&dev->devres_head,\n\t\t\t\t      &early_platform_device_list);\n\t\t}\n\t}\n}\n\n/**\n * early_platform_driver_register_all - register early platform drivers\n * @class_str: string to identify early platform driver class\n *\n * Used by architecture code to register all early platform drivers\n * for a certain class. If omitted then only early platform drivers\n * with matching kernel command line class parameters will be registered.\n */\nvoid __init early_platform_driver_register_all(char *class_str)\n{\n\t/* The \"class_str\" parameter may or may not be present on the kernel\n\t * command line. If it is present then there may be more than one\n\t * matching parameter.\n\t *\n\t * Since we register our early platform drivers using early_param()\n\t * we need to make sure that they also get registered in the case\n\t * when the parameter is missing from the kernel command line.\n\t *\n\t * We use parse_early_options() to make sure the early_param() gets\n\t * called at least once. The early_param() may be called more than\n\t * once since the name of the preferred device may be specified on\n\t * the kernel command line. early_platform_driver_register() handles\n\t * this case for us.\n\t */\n\tparse_early_options(class_str);\n}\n\n/**\n * early_platform_match - find early platform device matching driver\n * @epdrv: early platform driver structure\n * @id: id to match against\n */\nstatic struct platform_device * __init\nearly_platform_match(struct early_platform_driver *epdrv, int id)\n{\n\tstruct platform_device *pd;\n\n\tlist_for_each_entry(pd, &early_platform_device_list, dev.devres_head)\n\t\tif (platform_match(&pd->dev, &epdrv->pdrv->driver))\n\t\t\tif (pd->id == id)\n\t\t\t\treturn pd;\n\n\treturn NULL;\n}\n\n/**\n * early_platform_left - check if early platform driver has matching devices\n * @epdrv: early platform driver structure\n * @id: return true if id or above exists\n */\nstatic int __init early_platform_left(struct early_platform_driver *epdrv,\n\t\t\t\t       int id)\n{\n\tstruct platform_device *pd;\n\n\tlist_for_each_entry(pd, &early_platform_device_list, dev.devres_head)\n\t\tif (platform_match(&pd->dev, &epdrv->pdrv->driver))\n\t\t\tif (pd->id >= id)\n\t\t\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * early_platform_driver_probe_id - probe drivers matching class_str and id\n * @class_str: string to identify early platform driver class\n * @id: id to match against\n * @nr_probe: number of platform devices to successfully probe before exiting\n */\nstatic int __init early_platform_driver_probe_id(char *class_str,\n\t\t\t\t\t\t int id,\n\t\t\t\t\t\t int nr_probe)\n{\n\tstruct early_platform_driver *epdrv;\n\tstruct platform_device *match;\n\tint match_id;\n\tint n = 0;\n\tint left = 0;\n\n\tlist_for_each_entry(epdrv, &early_platform_driver_list, list) {\n\t\t/* only use drivers matching our class_str */\n\t\tif (strcmp(class_str, epdrv->class_str))\n\t\t\tcontinue;\n\n\t\tif (id == -2) {\n\t\t\tmatch_id = epdrv->requested_id;\n\t\t\tleft = 1;\n\n\t\t} else {\n\t\t\tmatch_id = id;\n\t\t\tleft += early_platform_left(epdrv, id);\n\n\t\t\t/* skip requested id */\n\t\t\tswitch (epdrv->requested_id) {\n\t\t\tcase EARLY_PLATFORM_ID_ERROR:\n\t\t\tcase EARLY_PLATFORM_ID_UNSET:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (epdrv->requested_id == id)\n\t\t\t\t\tmatch_id = EARLY_PLATFORM_ID_UNSET;\n\t\t\t}\n\t\t}\n\n\t\tswitch (match_id) {\n\t\tcase EARLY_PLATFORM_ID_ERROR:\n\t\t\tpr_warn(\"%s: unable to parse %s parameter\\n\",\n\t\t\t\tclass_str, epdrv->pdrv->driver.name);\n\t\t\t/* fall-through */\n\t\tcase EARLY_PLATFORM_ID_UNSET:\n\t\t\tmatch = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmatch = early_platform_match(epdrv, match_id);\n\t\t}\n\n\t\tif (match) {\n\t\t\t/*\n\t\t\t * Set up a sensible init_name to enable\n\t\t\t * dev_name() and others to be used before the\n\t\t\t * rest of the driver core is initialized.\n\t\t\t */\n\t\t\tif (!match->dev.init_name && slab_is_available()) {\n\t\t\t\tif (match->id != -1)\n\t\t\t\t\tmatch->dev.init_name =\n\t\t\t\t\t\tkasprintf(GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t\t\t  match->name,\n\t\t\t\t\t\t\t  match->id);\n\t\t\t\telse\n\t\t\t\t\tmatch->dev.init_name =\n\t\t\t\t\t\tkasprintf(GFP_KERNEL, \"%s\",\n\t\t\t\t\t\t\t  match->name);\n\n\t\t\t\tif (!match->dev.init_name)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tif (epdrv->pdrv->probe(match))\n\t\t\t\tpr_warn(\"%s: unable to probe %s early.\\n\",\n\t\t\t\t\tclass_str, match->name);\n\t\t\telse\n\t\t\t\tn++;\n\t\t}\n\n\t\tif (n >= nr_probe)\n\t\t\tbreak;\n\t}\n\n\tif (left)\n\t\treturn n;\n\telse\n\t\treturn -ENODEV;\n}\n\n/**\n * early_platform_driver_probe - probe a class of registered drivers\n * @class_str: string to identify early platform driver class\n * @nr_probe: number of platform devices to successfully probe before exiting\n * @user_only: only probe user specified early platform devices\n *\n * Used by architecture code to probe registered early platform drivers\n * within a certain class. For probe to happen a registered early platform\n * device matching a registered early platform driver is needed.\n */\nint __init early_platform_driver_probe(char *class_str,\n\t\t\t\t       int nr_probe,\n\t\t\t\t       int user_only)\n{\n\tint k, n, i;\n\n\tn = 0;\n\tfor (i = -2; n < nr_probe; i++) {\n\t\tk = early_platform_driver_probe_id(class_str, i, nr_probe - n);\n\n\t\tif (k < 0)\n\t\t\tbreak;\n\n\t\tn += k;\n\n\t\tif (user_only)\n\t\t\tbreak;\n\t}\n\n\treturn n;\n}\n\n/**\n * early_platform_cleanup - clean up early platform code\n */\nvoid __init early_platform_cleanup(void)\n{\n\tstruct platform_device *pd, *pd2;\n\n\t/* clean up the devres list used to chain devices */\n\tlist_for_each_entry_safe(pd, pd2, &early_platform_device_list,\n\t\t\t\t dev.devres_head) {\n\t\tlist_del(&pd->dev.devres_head);\n\t\tmemset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));\n\t}\n}\n\n"], "filenames": ["drivers/base/platform.c"], "buggy_code_start_loc": [869], "buggy_code_end_loc": [900], "fixing_code_start_loc": [869], "fixing_code_end_loc": [907], "type": "CWE-362", "message": "The driver_override implementation in drivers/base/platform.c in the Linux kernel before 4.12.1 allows local users to gain privileges by leveraging a race condition between a read operation and a store operation that involve different overrides.", "other": {"cve": {"id": "CVE-2017-12146", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-08T19:29:00.207", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The driver_override implementation in drivers/base/platform.c in the Linux kernel before 4.12.1 allows local users to gain privileges by leveraging a race condition between a read operation and a store operation that involve different overrides."}, {"lang": "es", "value": "La implementaci\u00f3n driver_override en drivers/base/platform.c en el kernel de Linux en versiones anteriores a la 4.12.1 permite que los usuarios locales obtengan privilegios mediante el uso de una condici\u00f3n de carrera causada por una operaci\u00f3n de lectura y otra de almacenamiento que involucren diferentes sobrescrituras de la memoria."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.12", "matchCriteriaId": "117361C7-9835-4C8A-AA22-B2A0AF08D09F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6265539776a0810b7ce6398c27866ddb9c6bd154", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3981", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.12.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/100651", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1489078", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1057474", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-09-01", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154"}}