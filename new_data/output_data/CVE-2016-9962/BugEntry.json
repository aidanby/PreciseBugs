{"buggy_code": ["// +build linux\n\npackage libcontainer\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/vishvananda/netlink\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid int `json:\"pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string         `json:\"args\"`\n\tEnv              []string         `json:\"env\"`\n\tCwd              string           `json:\"cwd\"`\n\tCapabilities     []string         `json:\"capabilities\"`\n\tProcessLabel     string           `json:\"process_label\"`\n\tAppArmorProfile  string           `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool             `json:\"no_new_privileges\"`\n\tUser             string           `json:\"user\"`\n\tAdditionalGroups []string         `json:\"additional_groups\"`\n\tConfig           *configs.Config  `json:\"config\"`\n\tConsole          string           `json:\"console\"`\n\tNetworks         []*network       `json:\"network\"`\n\tPassedFilesCount int              `json:\"passed_files_count\"`\n\tContainerId      string           `json:\"containerid\"`\n\tRlimits          []configs.Rlimit `json:\"rlimits\"`\n\tExecFifoPath     string           `json:\"start_pipe_path\"`\n}\n\ntype initer interface {\n\tInit() error\n}\n\nfunc newContainerInit(t initType, pipe *os.File, stateDirFD int) (initer, error) {\n\tvar config *initConfig\n\tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch t {\n\tcase initSetns:\n\t\treturn &linuxSetnsInit{\n\t\t\tconfig: config,\n\t\t}, nil\n\tcase initStandard:\n\t\treturn &linuxStandardInit{\n\t\t\tpipe:       pipe,\n\t\t\tparentPid:  syscall.Getppid(),\n\t\t\tconfig:     config,\n\t\t\tstateDirFD: stateDirFD,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid environment '%v'\", pair)\n\t\t}\n\t\tif err := os.Setenv(p[0], p[1]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn err\n\t}\n\n\tcapabilities := config.Config.Capabilities\n\tif config.Capabilities != nil {\n\t\tcapabilities = config.Capabilities\n\t}\n\tw, err := newCapWhitelist(capabilities)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.dropBoundingSet(); err != nil {\n\t\treturn err\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn err\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn err\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn err\n\t}\n\t// drop all other capabilities\n\tif err := w.drop(); err != nil {\n\t\treturn err\n\t}\n\tif config.Cwd != \"\" {\n\t\tif err := syscall.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %v\", config.Cwd, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := utils.WriteJSON(pipe, syncT{procReady}); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\tvar procSync syncT\n\tif err := json.NewDecoder(pipe).Decode(&procSync); err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn fmt.Errorf(\"parent closed synchronisation channel\")\n\t\t}\n\t\tif procSync.Type != procRun {\n\t\t\treturn fmt.Errorf(\"invalid synchronisation flag from parent\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := utils.WriteJSON(pipe, syncT{procHooks}); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\tvar procSync syncT\n\tif err := json.NewDecoder(pipe).Decode(&procSync); err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn fmt.Errorf(\"parent closed synchronisation channel\")\n\t\t}\n\t\tif procSync.Type != procResume {\n\t\t\treturn fmt.Errorf(\"invalid synchronisation flag from parent\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  syscall.Getuid(),\n\t\tGid:  syscall.Getgid(),\n\t\tHome: \"/\",\n\t}\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// before we change to the container's user make sure that the processes STDIO\n\t// is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(execUser); err != nil {\n\t\treturn err\n\t}\n\tsuppGroups := append(execUser.Sgids, addGroups...)\n\tif err := syscall.Setgroups(suppGroups); err != nil {\n\t\treturn err\n\t}\n\n\tif err := system.Setgid(execUser.Gid); err != nil {\n\t\treturn err\n\t}\n\tif err := system.Setuid(execUser.Uid); err != nil {\n\t\treturn err\n\t}\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(u *user.ExecUser) error {\n\tvar null syscall.Stat_t\n\tif err := syscall.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn err\n\t}\n\tfor _, fd := range []uintptr{\n\t\tos.Stdin.Fd(),\n\t\tos.Stderr.Fd(),\n\t\tos.Stdout.Fd(),\n\t} {\n\t\tvar s syscall.Stat_t\n\t\tif err := syscall.Fstat(int(fd), &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// skip chown of /dev/null if it was used as one of the STDIO fds.\n\t\tif s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\t\tif err := syscall.Fchown(int(fd), u.Uid, u.Gid); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := system.Prlimit(pid, rlimit.Type, syscall.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %v\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setOomScoreAdj(oomScoreAdj int, pid int) error {\n\tpath := fmt.Sprintf(\"/proc/%d/oom_score_adj\", pid)\n\n\treturn ioutil.WriteFile(path, []byte(strconv.Itoa(oomScoreAdj)), 0600)\n}\n\n// killCgroupProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending a SIGKILL to each process then waiting for them to\n// exit.\nfunc killCgroupProcesses(m cgroups.Manager) error {\n\tvar procs []*os.Process\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tm.Freeze(configs.Thawed)\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t\tcontinue\n\t\t}\n\t\tprocs = append(procs, p)\n\t\tif err := p.Kill(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tfor _, p := range procs {\n\t\tif _, err := p.Wait(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\treturn nil\n}\n", "#define _GNU_SOURCE\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n\n#define SYNC_VAL 0x42\n#define JUMP_VAL 0x43\n\n/* Assume the stack grows down, so arguments should be above it. */\nstruct clone_arg {\n\t/*\n\t * Reserve some space for clone() to locate arguments\n\t * and retcode in this place\n\t */\n\tchar stack[4096] __attribute__ ((aligned(16)));\n\tchar stack_ptr[0];\n\tjmp_buf *env;\n};\n\nstruct nlconfig_t {\n\tchar *data;\n\tuint32_t cloneflags;\n\tchar *uidmap;\n\tint uidmap_len;\n\tchar *gidmap;\n\tint gidmap_len;\n\tuint8_t is_setgroup;\n\tint consolefd;\n};\n\n/*\n * List of netlink message types sent to us as part of bootstrapping the init.\n * These constants are defined in libcontainer/message_linux.go.\n */\n#define INIT_MSG\t\t62000\n#define CLONE_FLAGS_ATTR\t27281\n#define CONSOLE_PATH_ATTR\t27282\n#define NS_PATHS_ATTR\t\t27283\n#define UIDMAP_ATTR\t\t27284\n#define GIDMAP_ATTR\t\t27285\n#define SETGROUP_ATTR\t\t27286\n\n/*\n * Use the raw syscall for versions of glibc which don't include a function for\n * it, namely (glibc 2.12).\n */\n#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 14\n#\tdefine _GNU_SOURCE\n#\tinclude \"syscall.h\"\n#\tif !defined(SYS_setns) && defined(__NR_setns)\n#\t\tdefine SYS_setns __NR_setns\n#\tendif\n\n#ifndef SYS_setns\n#\terror \"setns(2) syscall not supported by glibc version\"\n#endif\n\nint setns(int fd, int nstype)\n{\n\treturn syscall(SYS_setns, fd, nstype);\n}\n#endif\n\n/* TODO(cyphar): Fix this so it correctly deals with syncT. */\n#define bail(fmt, ...)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tfprintf(stderr, \"nsenter: \" fmt \": %m\\n\", ##__VA_ARGS__); \\\n\t\texit(__COUNTER__ + 1);\t\t\t\t\t\\\n\t} while(0)\n\nstatic int child_func(void *arg)\n{\n\tstruct clone_arg *ca = (struct clone_arg *)arg;\n\tlongjmp(*ca->env, JUMP_VAL);\n}\n\nstatic int clone_parent(jmp_buf *env, int flags) __attribute__ ((noinline));\nstatic int clone_parent(jmp_buf *env, int flags)\n{\n\tint child;\n\tstruct clone_arg ca = {\n\t\t.env = env,\n\t};\n\n\tchild = clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD | flags, &ca);\n\n\t/*\n\t * On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so we have\n\t * to unshare(2) before clone(2) in order to do this. This was fixed in\n\t * upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e.\n\t *\n\t * As far as we're aware, the last mainline kernel which had this bug was\n\t * Linux 3.12. However, we cannot comment on which kernels the broken patch\n\t * was backported to.\n\t */\n\tif (errno == EINVAL) {\n\t\tif (unshare(flags) < 0)\n\t\t\tbail(\"unable to unshare namespaces\");\n\t\tchild = clone(child_func, ca.stack_ptr, SIGCHLD | CLONE_PARENT, &ca);\n\t}\n\n\treturn child;\n}\n\n/*\n * Gets the init pipe fd from the environment, which is used to read the\n * bootstrap data and tell the parent what the new pid is after we finish\n * setting up the environment.\n */\nstatic int initpipe(void)\n{\n\tint pipenum;\n\tchar *initpipe, *endptr;\n\n\tinitpipe = getenv(\"_LIBCONTAINER_INITPIPE\");\n\tif (initpipe == NULL || *initpipe == '\\0')\n\t\treturn -1;\n\n\terrno = 0;\n\tpipenum = strtol(initpipe, &endptr, 10);\n\tif (errno != 0 || *endptr != '\\0')\n\t\tbail(\"unable to parse _LIBCONTAINER_INITPIPE\");\n\n\treturn pipenum;\n}\n\nstatic uint32_t readint32(char *buf)\n{\n\treturn *(uint32_t *) buf;\n}\n\nstatic uint8_t readint8(char *buf)\n{\n\treturn *(uint8_t *) buf;\n}\n\nstatic int write_file(char *data, size_t data_len, char *pathfmt, ...)\n{\n\tint fd, len, ret = 0;\n\tchar path[PATH_MAX];\n\n\tva_list ap;\n\tva_start(ap, pathfmt);\n\tlen = vsnprintf(path, PATH_MAX, pathfmt, ap);\n\tva_end(ap);\n\tif (len < 0)\n\t\treturn -1;\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tlen = write(fd, data, data_len);\n\tif (len != data_len) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\n#define SETGROUPS_ALLOW \"allow\"\n#define SETGROUPS_DENY  \"deny\"\n\n/* This *must* be called before we touch gid_map. */\nstatic void update_setgroups(int pid, bool setgroup)\n{\n\tchar *policy;\n\n\tif (setgroup)\n\t\tpolicy = SETGROUPS_ALLOW;\n\telse\n\t\tpolicy = SETGROUPS_DENY;\n\n\tif (write_file(policy, strlen(policy), \"/proc/%d/setgroups\", pid) < 0) {\n\t\t/*\n\t\t * If the kernel is too old to support /proc/pid/setgroups,\n\t\t * open(2) or write(2) will return ENOENT. This is fine.\n\t\t */\n\t\tif (errno != ENOENT)\n\t\t\tbail(\"failed to write '%s' to /proc/%d/setgroups\", policy, pid);\n\t}\n}\n\nstatic void update_uidmap(int pid, char *map, int map_len)\n{\n\tif (map == NULL || map_len <= 0)\n\t\treturn;\n\n\tif (write_file(map, map_len, \"/proc/%d/uid_map\", pid) < 0)\n\t\tbail(\"failed to update /proc/%d/uid_map\", pid);\n}\n\nstatic void update_gidmap(int pid, char *map, int map_len)\n{\n\tif (map == NULL || map_len <= 0)\n\t\treturn;\n\n\tif (write_file(map, map_len, \"/proc/%d/gid_map\", pid) < 0)\n\t\tbail(\"failed to update /proc/%d/gid_map\", pid);\n}\n\n#define JSON_MAX 4096\n\nstatic void start_child(int pipenum, jmp_buf *env, int syncpipe[2], struct nlconfig_t *config)\n{\n\tint len, childpid;\n\tchar buf[JSON_MAX];\n\tuint8_t syncval;\n\n\t/*\n\t * We must fork to actually enter the PID namespace, and use\n\t * CLONE_PARENT so that the child init can have the right parent\n\t * (the bootstrap process). Also so we don't need to forward the\n\t * child's exit code or resend its death signal.\n\t */\n\tchildpid = clone_parent(env, config->cloneflags);\n\tif (childpid < 0)\n\t\tbail(\"unable to fork\");\n\n\t/* Update setgroups, uid_map and gid_map for the process if provided. */\n\tif (config->is_setgroup)\n\t\tupdate_setgroups(childpid, true);\n\tupdate_uidmap(childpid, config->uidmap, config->uidmap_len);\n\tupdate_gidmap(childpid, config->gidmap, config->gidmap_len);\n\n\t/* Send the sync signal to the child. */\n\tclose(syncpipe[0]);\n\tsyncval = SYNC_VAL;\n\tif (write(syncpipe[1], &syncval, sizeof(syncval)) != sizeof(syncval))\n\t\tbail(\"failed to write sync byte to child\");\n\n\t/* Send the child pid back to our parent */\n\tlen = snprintf(buf, JSON_MAX, \"{\\\"pid\\\": %d}\\n\", childpid);\n\tif (len < 0 || write(pipenum, buf, len) != len) {\n\t\tkill(childpid, SIGKILL);\n\t\tbail(\"unable to send a child pid\");\n\t}\n\n\texit(0);\n}\n\nstatic void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %lu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %lu != %lu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\tconfig->consolefd = -1;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase CONSOLE_PATH_ATTR:\n\t\t\t/*\n\t\t\t * The context in which this is done (before or after we\n\t\t\t * join the other namespaces) will affect how the path\n\t\t\t * resolution of the console works. This order is not\n\t\t\t * decided here, but rather in container_linux.go. We just\n\t\t\t * follow the order given by the netlink message.\n\t\t\t */\n\t\t\tconfig->consolefd = open(current, O_RDWR);\n\t\t\tif (config->consolefd < 0)\n\t\t\t\tbail(\"failed to open console %s\", current);\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:{\n\t\t\t\t/*\n\t\t\t\t * Open each namespace path and setns it in the\n\t\t\t\t * order provided to us. We currently don't have\n\t\t\t\t * any context for what kind of namespace we're\n\t\t\t\t * joining, so just blindly do it.\n\t\t\t\t */\n\t\t\t\tchar *saveptr = NULL;\n\t\t\t\tchar *ns = strtok_r(current, \",\", &saveptr);\n\t\t\t\tint *fds = NULL, num = 0, i;\n\t\t\t\tchar **paths = NULL;\n\n\t\t\t\tif (!ns || !strlen(current))\n\t\t\t\t\tbail(\"ns paths are empty\");\n\n\t\t\t\t/*\n\t\t\t\t * We have to open the file descriptors first, since after\n\t\t\t\t * we join the mnt namespace we might no longer be able to\n\t\t\t\t * access the paths.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tint fd;\n\n\t\t\t\t\t/* Resize fds. */\n\t\t\t\t\tnum++;\n\t\t\t\t\tfds = realloc(fds, num * sizeof(int));\n\t\t\t\t\tpaths = realloc(paths, num * sizeof(char *));\n\n\t\t\t\t\tfd = open(ns, O_RDONLY);\n\t\t\t\t\tif (fd < 0)\n\t\t\t\t\t\tbail(\"failed to open %s\", ns);\n\n\t\t\t\t\tfds[num - 1] = fd;\n\t\t\t\t\tpaths[num - 1] = ns;\n\t\t\t\t} while ((ns = strtok_r(NULL, \",\", &saveptr)) != NULL);\n\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tint fd = fds[i];\n\t\t\t\t\tchar *path = paths[i];\n\n\t\t\t\t\tif (setns(fd, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to setns to %s\", path);\n\n\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\n\t\t\t\tfree(fds);\n\t\t\t\tfree(paths);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}\n\nvoid nl_free(struct nlconfig_t *config)\n{\n\tfree(config->data);\n}\n\nvoid nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint syncpipe[2];\n\tstruct nlconfig_t config = {0};\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* clone(2) flags are mandatory. */\n\tif (config.cloneflags == -1)\n\t\tbail(\"missing clone_flags\");\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (pipe(syncpipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/* Set up the jump point. */\n\tif (setjmp(env) == JUMP_VAL) {\n\t\t/*\n\t\t * We're inside the child now, having jumped from the\n\t\t * start_child() code after forking in the parent.\n\t\t */\n\t\tuint8_t s = 0;\n\t\tint consolefd = config.consolefd;\n\n\t\t/* Close the writing side of pipe. */\n\t\tclose(syncpipe[1]);\n\n\t\t/* Sync with parent. */\n\t\tif (read(syncpipe[0], &s, sizeof(s)) != sizeof(s) || s != SYNC_VAL)\n\t\t\tbail(\"failed to read sync byte from parent\");\n\n\t\tif (setsid() < 0)\n\t\t\tbail(\"setsid failed\");\n\n\t\tif (setuid(0) < 0)\n\t\t\tbail(\"setuid failed\");\n\n\t\tif (setgid(0) < 0)\n\t\t\tbail(\"setgid failed\");\n\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\tbail(\"setgroups failed\");\n\n\t\tif (consolefd != -1) {\n\t\t\tif (ioctl(consolefd, TIOCSCTTY, 0) < 0)\n\t\t\t\tbail(\"ioctl TIOCSCTTY failed\");\n\t\t\tif (dup3(consolefd, STDIN_FILENO, 0) != STDIN_FILENO)\n\t\t\t\tbail(\"failed to dup stdin\");\n\t\t\tif (dup3(consolefd, STDOUT_FILENO, 0) != STDOUT_FILENO)\n\t\t\t\tbail(\"failed to dup stdout\");\n\t\t\tif (dup3(consolefd, STDERR_FILENO, 0) != STDERR_FILENO)\n\t\t\t\tbail(\"failed to dup stderr\");\n\t\t}\n\n\t\t/* Free netlink data. */\n\t\tnl_free(&config);\n\n\t\t/* Finish executing, let the Go runtime take over. */\n\t\treturn;\n\t}\n\n\t/* Run the parent code. */\n\tstart_child(pipenum, &env, syncpipe, &config);\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/label\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\n// linuxSetnsInit performs the container's initialization for running a new process\n// inside an existing container.\ntype linuxSetnsInit struct {\n\tconfig *initConfig\n}\n\nfunc (l *linuxSetnsInit) getSessionRingName() string {\n\treturn fmt.Sprintf(\"_ses.%s\", l.config.ContainerId)\n}\n\nfunc (l *linuxSetnsInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\t// do not inherit the parent's session keyring\n\t\tif _, err := keys.JoinSessionKeyring(l.getSessionRingName()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.Config.Seccomp != nil {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\treturn system.Execv(l.config.Args[0], l.config.Args[0:], os.Environ())\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/label\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\ntype linuxStandardInit struct {\n\tpipe       io.ReadWriteCloser\n\tparentPid  int\n\tstateDirFD int\n\tconfig     *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// with user ns we need 'other' search permissions\n\t\tnewperms = 0x8\n\t} else {\n\t\t// without user ns we need 'UID' search permissions\n\t\tnewperms = 0x80000\n\t}\n\n\t// create a unique per session container name that we can\n\t// join in setns; however, other containers can also join it\n\treturn fmt.Sprintf(\"_ses.%s\", l.config.ContainerId), 0xffffffff, newperms\n}\n\n// PR_SET_NO_NEW_PRIVS isn't exposed in Golang so we define it ourselves copying the value\n// the kernel\nconst PR_SET_NO_NEW_PRIVS = 0x26\n\nfunc (l *linuxStandardInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// do not inherit the parent's session keyring\n\t\tsessKeyId, err := keys.JoinSessionKeyring(ringname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// make session keyring searcheable\n\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar console *linuxConsole\n\tif l.config.Console != \"\" {\n\t\tconsole = newConsoleFromPath(l.config.Console)\n\t\tif err := console.dupStdio(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif console != nil {\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\tlabel.Init()\n\t// InitializeMountNamespace() can be executed only for a new mount namespace\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := setupRootfs(l.config.Config, console, l.pipe); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := syscall.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := remountReadonly(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn err\n\t}\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn err\n\t}\n\t// compare the parent from the inital start of the init process and make sure that it did not change.\n\t// if the parent changes that means it died and we were reparented to something else so we should\n\t// just kill ourself and not cause problems for someone else.\n\tif syscall.Getppid() != l.parentPid {\n\t\treturn syscall.Kill(syscall.Getpid(), syscall.SIGKILL)\n\t}\n\t// check for the arg before waiting to make sure it exists and it is returned\n\t// as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// close the pipe to signal that we have completed our init.\n\tl.pipe.Close()\n\t// wait for the fifo to be opened on the other side before\n\t// exec'ing the users process.\n\tfd, err := syscall.Openat(l.stateDirFD, execFifoFilename, os.O_WRONLY|syscall.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"openat exec fifo\")\n\t}\n\tif _, err := syscall.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"write 0 exec fifo\")\n\t}\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"init seccomp\")\n\t\t}\n\t}\n\tif err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"exec user process\")\n\t}\n\treturn nil\n}\n"], "fixing_code": ["// +build linux\n\npackage libcontainer\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/vishvananda/netlink\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid int `json:\"pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string         `json:\"args\"`\n\tEnv              []string         `json:\"env\"`\n\tCwd              string           `json:\"cwd\"`\n\tCapabilities     []string         `json:\"capabilities\"`\n\tProcessLabel     string           `json:\"process_label\"`\n\tAppArmorProfile  string           `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool             `json:\"no_new_privileges\"`\n\tUser             string           `json:\"user\"`\n\tAdditionalGroups []string         `json:\"additional_groups\"`\n\tConfig           *configs.Config  `json:\"config\"`\n\tConsole          string           `json:\"console\"`\n\tNetworks         []*network       `json:\"network\"`\n\tPassedFilesCount int              `json:\"passed_files_count\"`\n\tContainerId      string           `json:\"containerid\"`\n\tRlimits          []configs.Rlimit `json:\"rlimits\"`\n\tExecFifoPath     string           `json:\"start_pipe_path\"`\n}\n\ntype initer interface {\n\tInit() error\n}\n\nfunc newContainerInit(t initType, pipe *os.File, stateDirFD int) (initer, error) {\n\tvar config *initConfig\n\tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch t {\n\tcase initSetns:\n\t\treturn &linuxSetnsInit{\n\t\t\tconfig:     config,\n\t\t\tstateDirFD: stateDirFD,\n\t\t}, nil\n\tcase initStandard:\n\t\treturn &linuxStandardInit{\n\t\t\tpipe:       pipe,\n\t\t\tparentPid:  syscall.Getppid(),\n\t\t\tconfig:     config,\n\t\t\tstateDirFD: stateDirFD,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid environment '%v'\", pair)\n\t\t}\n\t\tif err := os.Setenv(p[0], p[1]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn err\n\t}\n\n\tcapabilities := config.Config.Capabilities\n\tif config.Capabilities != nil {\n\t\tcapabilities = config.Capabilities\n\t}\n\tw, err := newCapWhitelist(capabilities)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.dropBoundingSet(); err != nil {\n\t\treturn err\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn err\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn err\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn err\n\t}\n\t// drop all other capabilities\n\tif err := w.drop(); err != nil {\n\t\treturn err\n\t}\n\tif config.Cwd != \"\" {\n\t\tif err := syscall.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %v\", config.Cwd, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := utils.WriteJSON(pipe, syncT{procReady}); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\tvar procSync syncT\n\tif err := json.NewDecoder(pipe).Decode(&procSync); err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn fmt.Errorf(\"parent closed synchronisation channel\")\n\t\t}\n\t\tif procSync.Type != procRun {\n\t\t\treturn fmt.Errorf(\"invalid synchronisation flag from parent\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := utils.WriteJSON(pipe, syncT{procHooks}); err != nil {\n\t\treturn err\n\t}\n\t// Wait for parent to give the all-clear.\n\tvar procSync syncT\n\tif err := json.NewDecoder(pipe).Decode(&procSync); err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn fmt.Errorf(\"parent closed synchronisation channel\")\n\t\t}\n\t\tif procSync.Type != procResume {\n\t\t\treturn fmt.Errorf(\"invalid synchronisation flag from parent\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  syscall.Getuid(),\n\t\tGid:  syscall.Getgid(),\n\t\tHome: \"/\",\n\t}\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// before we change to the container's user make sure that the processes STDIO\n\t// is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(execUser); err != nil {\n\t\treturn err\n\t}\n\tsuppGroups := append(execUser.Sgids, addGroups...)\n\tif err := syscall.Setgroups(suppGroups); err != nil {\n\t\treturn err\n\t}\n\n\tif err := system.Setgid(execUser.Gid); err != nil {\n\t\treturn err\n\t}\n\tif err := system.Setuid(execUser.Uid); err != nil {\n\t\treturn err\n\t}\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(u *user.ExecUser) error {\n\tvar null syscall.Stat_t\n\tif err := syscall.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn err\n\t}\n\tfor _, fd := range []uintptr{\n\t\tos.Stdin.Fd(),\n\t\tos.Stderr.Fd(),\n\t\tos.Stdout.Fd(),\n\t} {\n\t\tvar s syscall.Stat_t\n\t\tif err := syscall.Fstat(int(fd), &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// skip chown of /dev/null if it was used as one of the STDIO fds.\n\t\tif s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\t\tif err := syscall.Fchown(int(fd), u.Uid, u.Gid); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := system.Prlimit(pid, rlimit.Type, syscall.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %v\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setOomScoreAdj(oomScoreAdj int, pid int) error {\n\tpath := fmt.Sprintf(\"/proc/%d/oom_score_adj\", pid)\n\n\treturn ioutil.WriteFile(path, []byte(strconv.Itoa(oomScoreAdj)), 0600)\n}\n\n// killCgroupProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending a SIGKILL to each process then waiting for them to\n// exit.\nfunc killCgroupProcesses(m cgroups.Manager) error {\n\tvar procs []*os.Process\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tm.Freeze(configs.Thawed)\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t\tcontinue\n\t\t}\n\t\tprocs = append(procs, p)\n\t\tif err := p.Kill(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tfor _, p := range procs {\n\t\tif _, err := p.Wait(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\treturn nil\n}\n", "#define _GNU_SOURCE\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n\n#define SYNC_VAL 0x42\n#define JUMP_VAL 0x43\n\n/* Assume the stack grows down, so arguments should be above it. */\nstruct clone_arg {\n\t/*\n\t * Reserve some space for clone() to locate arguments\n\t * and retcode in this place\n\t */\n\tchar stack[4096] __attribute__ ((aligned(16)));\n\tchar stack_ptr[0];\n\tjmp_buf *env;\n};\n\nstruct nlconfig_t {\n\tchar *data;\n\tuint32_t cloneflags;\n\tchar *uidmap;\n\tint uidmap_len;\n\tchar *gidmap;\n\tint gidmap_len;\n\tuint8_t is_setgroup;\n\tint consolefd;\n};\n\n/*\n * List of netlink message types sent to us as part of bootstrapping the init.\n * These constants are defined in libcontainer/message_linux.go.\n */\n#define INIT_MSG\t\t62000\n#define CLONE_FLAGS_ATTR\t27281\n#define CONSOLE_PATH_ATTR\t27282\n#define NS_PATHS_ATTR\t\t27283\n#define UIDMAP_ATTR\t\t27284\n#define GIDMAP_ATTR\t\t27285\n#define SETGROUP_ATTR\t\t27286\n\n/*\n * Use the raw syscall for versions of glibc which don't include a function for\n * it, namely (glibc 2.12).\n */\n#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 14\n#\tdefine _GNU_SOURCE\n#\tinclude \"syscall.h\"\n#\tif !defined(SYS_setns) && defined(__NR_setns)\n#\t\tdefine SYS_setns __NR_setns\n#\tendif\n\n#ifndef SYS_setns\n#\terror \"setns(2) syscall not supported by glibc version\"\n#endif\n\nint setns(int fd, int nstype)\n{\n\treturn syscall(SYS_setns, fd, nstype);\n}\n#endif\n\n/* TODO(cyphar): Fix this so it correctly deals with syncT. */\n#define bail(fmt, ...)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tfprintf(stderr, \"nsenter: \" fmt \": %m\\n\", ##__VA_ARGS__); \\\n\t\texit(__COUNTER__ + 1);\t\t\t\t\t\\\n\t} while(0)\n\nstatic int child_func(void *arg)\n{\n\tstruct clone_arg *ca = (struct clone_arg *)arg;\n\tlongjmp(*ca->env, JUMP_VAL);\n}\n\nstatic int clone_parent(jmp_buf *env, int flags) __attribute__ ((noinline));\nstatic int clone_parent(jmp_buf *env, int flags)\n{\n\tint child;\n\tstruct clone_arg ca = {\n\t\t.env = env,\n\t};\n\n\tchild = clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD | flags, &ca);\n\n\t/*\n\t * On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so we have\n\t * to unshare(2) before clone(2) in order to do this. This was fixed in\n\t * upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e.\n\t *\n\t * As far as we're aware, the last mainline kernel which had this bug was\n\t * Linux 3.12. However, we cannot comment on which kernels the broken patch\n\t * was backported to.\n\t */\n\tif (errno == EINVAL) {\n\t\tif (unshare(flags) < 0)\n\t\t\tbail(\"unable to unshare namespaces\");\n\t\tchild = clone(child_func, ca.stack_ptr, SIGCHLD | CLONE_PARENT, &ca);\n\t}\n\n\treturn child;\n}\n\n/*\n * Gets the init pipe fd from the environment, which is used to read the\n * bootstrap data and tell the parent what the new pid is after we finish\n * setting up the environment.\n */\nstatic int initpipe(void)\n{\n\tint pipenum;\n\tchar *initpipe, *endptr;\n\n\tinitpipe = getenv(\"_LIBCONTAINER_INITPIPE\");\n\tif (initpipe == NULL || *initpipe == '\\0')\n\t\treturn -1;\n\n\terrno = 0;\n\tpipenum = strtol(initpipe, &endptr, 10);\n\tif (errno != 0 || *endptr != '\\0')\n\t\tbail(\"unable to parse _LIBCONTAINER_INITPIPE\");\n\n\treturn pipenum;\n}\n\nstatic uint32_t readint32(char *buf)\n{\n\treturn *(uint32_t *) buf;\n}\n\nstatic uint8_t readint8(char *buf)\n{\n\treturn *(uint8_t *) buf;\n}\n\nstatic int write_file(char *data, size_t data_len, char *pathfmt, ...)\n{\n\tint fd, len, ret = 0;\n\tchar path[PATH_MAX];\n\n\tva_list ap;\n\tva_start(ap, pathfmt);\n\tlen = vsnprintf(path, PATH_MAX, pathfmt, ap);\n\tva_end(ap);\n\tif (len < 0)\n\t\treturn -1;\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tlen = write(fd, data, data_len);\n\tif (len != data_len) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\n#define SETGROUPS_ALLOW \"allow\"\n#define SETGROUPS_DENY  \"deny\"\n\n/* This *must* be called before we touch gid_map. */\nstatic void update_setgroups(int pid, bool setgroup)\n{\n\tchar *policy;\n\n\tif (setgroup)\n\t\tpolicy = SETGROUPS_ALLOW;\n\telse\n\t\tpolicy = SETGROUPS_DENY;\n\n\tif (write_file(policy, strlen(policy), \"/proc/%d/setgroups\", pid) < 0) {\n\t\t/*\n\t\t * If the kernel is too old to support /proc/pid/setgroups,\n\t\t * open(2) or write(2) will return ENOENT. This is fine.\n\t\t */\n\t\tif (errno != ENOENT)\n\t\t\tbail(\"failed to write '%s' to /proc/%d/setgroups\", policy, pid);\n\t}\n}\n\nstatic void update_uidmap(int pid, char *map, int map_len)\n{\n\tif (map == NULL || map_len <= 0)\n\t\treturn;\n\n\tif (write_file(map, map_len, \"/proc/%d/uid_map\", pid) < 0)\n\t\tbail(\"failed to update /proc/%d/uid_map\", pid);\n}\n\nstatic void update_gidmap(int pid, char *map, int map_len)\n{\n\tif (map == NULL || map_len <= 0)\n\t\treturn;\n\n\tif (write_file(map, map_len, \"/proc/%d/gid_map\", pid) < 0)\n\t\tbail(\"failed to update /proc/%d/gid_map\", pid);\n}\n\n#define JSON_MAX 4096\n\nstatic void start_child(int pipenum, jmp_buf *env, int syncpipe[2], struct nlconfig_t *config)\n{\n\tint len, childpid;\n\tchar buf[JSON_MAX];\n\tuint8_t syncval;\n\n\t/*\n\t * We must fork to actually enter the PID namespace, and use\n\t * CLONE_PARENT so that the child init can have the right parent\n\t * (the bootstrap process). Also so we don't need to forward the\n\t * child's exit code or resend its death signal.\n\t */\n\tchildpid = clone_parent(env, config->cloneflags);\n\tif (childpid < 0)\n\t\tbail(\"unable to fork\");\n\n\t/* Update setgroups, uid_map and gid_map for the process if provided. */\n\tif (config->is_setgroup)\n\t\tupdate_setgroups(childpid, true);\n\tupdate_uidmap(childpid, config->uidmap, config->uidmap_len);\n\tupdate_gidmap(childpid, config->gidmap, config->gidmap_len);\n\n\t/* Send the sync signal to the child. */\n\tclose(syncpipe[0]);\n\tsyncval = SYNC_VAL;\n\tif (write(syncpipe[1], &syncval, sizeof(syncval)) != sizeof(syncval))\n\t\tbail(\"failed to write sync byte to child\");\n\n\t/* Send the child pid back to our parent */\n\tlen = snprintf(buf, JSON_MAX, \"{\\\"pid\\\": %d}\\n\", childpid);\n\tif (len < 0 || write(pipenum, buf, len) != len) {\n\t\tkill(childpid, SIGKILL);\n\t\tbail(\"unable to send a child pid\");\n\t}\n\n\texit(0);\n}\n\nstatic void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %lu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %lu != %lu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\tconfig->consolefd = -1;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase CONSOLE_PATH_ATTR:\n\t\t\t/*\n\t\t\t * The context in which this is done (before or after we\n\t\t\t * join the other namespaces) will affect how the path\n\t\t\t * resolution of the console works. This order is not\n\t\t\t * decided here, but rather in container_linux.go. We just\n\t\t\t * follow the order given by the netlink message.\n\t\t\t */\n\t\t\tconfig->consolefd = open(current, O_RDWR);\n\t\t\tif (config->consolefd < 0)\n\t\t\t\tbail(\"failed to open console %s\", current);\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:{\n\t\t\t\t/*\n\t\t\t\t * Open each namespace path and setns it in the\n\t\t\t\t * order provided to us. We currently don't have\n\t\t\t\t * any context for what kind of namespace we're\n\t\t\t\t * joining, so just blindly do it.\n\t\t\t\t */\n\t\t\t\tchar *saveptr = NULL;\n\t\t\t\tchar *ns = strtok_r(current, \",\", &saveptr);\n\t\t\t\tint *fds = NULL, num = 0, i;\n\t\t\t\tchar **paths = NULL;\n\n\t\t\t\tif (!ns || !strlen(current))\n\t\t\t\t\tbail(\"ns paths are empty\");\n\n\t\t\t\t/*\n\t\t\t\t * We have to open the file descriptors first, since after\n\t\t\t\t * we join the mnt namespace we might no longer be able to\n\t\t\t\t * access the paths.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\tint fd;\n\n\t\t\t\t\t/* Resize fds. */\n\t\t\t\t\tnum++;\n\t\t\t\t\tfds = realloc(fds, num * sizeof(int));\n\t\t\t\t\tpaths = realloc(paths, num * sizeof(char *));\n\n\t\t\t\t\tfd = open(ns, O_RDONLY);\n\t\t\t\t\tif (fd < 0)\n\t\t\t\t\t\tbail(\"failed to open %s\", ns);\n\n\t\t\t\t\tfds[num - 1] = fd;\n\t\t\t\t\tpaths[num - 1] = ns;\n\t\t\t\t} while ((ns = strtok_r(NULL, \",\", &saveptr)) != NULL);\n\n\t\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\t\tint fd = fds[i];\n\t\t\t\t\tchar *path = paths[i];\n\n\t\t\t\t\tif (setns(fd, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to setns to %s\", path);\n\n\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\n\t\t\t\tfree(fds);\n\t\t\t\tfree(paths);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}\n\nvoid nl_free(struct nlconfig_t *config)\n{\n\tfree(config->data);\n}\n\nvoid nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint syncpipe[2];\n\tstruct nlconfig_t config = {0};\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/* make the process non-dumpable */\n\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) != 0) {\n\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* clone(2) flags are mandatory. */\n\tif (config.cloneflags == -1)\n\t\tbail(\"missing clone_flags\");\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (pipe(syncpipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/* Set up the jump point. */\n\tif (setjmp(env) == JUMP_VAL) {\n\t\t/*\n\t\t * We're inside the child now, having jumped from the\n\t\t * start_child() code after forking in the parent.\n\t\t */\n\t\tuint8_t s = 0;\n\t\tint consolefd = config.consolefd;\n\n\t\t/* Close the writing side of pipe. */\n\t\tclose(syncpipe[1]);\n\n\t\t/* Sync with parent. */\n\t\tif (read(syncpipe[0], &s, sizeof(s)) != sizeof(s) || s != SYNC_VAL)\n\t\t\tbail(\"failed to read sync byte from parent\");\n\n\t\tif (setsid() < 0)\n\t\t\tbail(\"setsid failed\");\n\n\t\tif (setuid(0) < 0)\n\t\t\tbail(\"setuid failed\");\n\n\t\tif (setgid(0) < 0)\n\t\t\tbail(\"setgid failed\");\n\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\tbail(\"setgroups failed\");\n\n\t\tif (consolefd != -1) {\n\t\t\tif (ioctl(consolefd, TIOCSCTTY, 0) < 0)\n\t\t\t\tbail(\"ioctl TIOCSCTTY failed\");\n\t\t\tif (dup3(consolefd, STDIN_FILENO, 0) != STDIN_FILENO)\n\t\t\t\tbail(\"failed to dup stdin\");\n\t\t\tif (dup3(consolefd, STDOUT_FILENO, 0) != STDOUT_FILENO)\n\t\t\t\tbail(\"failed to dup stdout\");\n\t\t\tif (dup3(consolefd, STDERR_FILENO, 0) != STDERR_FILENO)\n\t\t\t\tbail(\"failed to dup stderr\");\n\t\t}\n\n\t\t/* Free netlink data. */\n\t\tnl_free(&config);\n\n\t\t/* Finish executing, let the Go runtime take over. */\n\t\treturn;\n\t}\n\n\t/* Run the parent code. */\n\tstart_child(pipenum, &env, syncpipe, &config);\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/label\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\n// linuxSetnsInit performs the container's initialization for running a new process\n// inside an existing container.\ntype linuxSetnsInit struct {\n\tconfig     *initConfig\n\tstateDirFD int\n}\n\nfunc (l *linuxSetnsInit) getSessionRingName() string {\n\treturn fmt.Sprintf(\"_ses.%s\", l.config.ContainerId)\n}\n\nfunc (l *linuxSetnsInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\t// do not inherit the parent's session keyring\n\t\tif _, err := keys.JoinSessionKeyring(l.getSessionRingName()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif l.config.Config.Seccomp != nil {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\t// close the statedir fd before exec because the kernel resets dumpable in the wrong order\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\tsyscall.Close(l.stateDirFD)\n\treturn system.Execv(l.config.Args[0], l.config.Args[0:], os.Environ())\n}\n", "// +build linux\n\npackage libcontainer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/label\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\ntype linuxStandardInit struct {\n\tpipe       io.ReadWriteCloser\n\tparentPid  int\n\tstateDirFD int\n\tconfig     *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// with user ns we need 'other' search permissions\n\t\tnewperms = 0x8\n\t} else {\n\t\t// without user ns we need 'UID' search permissions\n\t\tnewperms = 0x80000\n\t}\n\n\t// create a unique per session container name that we can\n\t// join in setns; however, other containers can also join it\n\treturn fmt.Sprintf(\"_ses.%s\", l.config.ContainerId), 0xffffffff, newperms\n}\n\n// PR_SET_NO_NEW_PRIVS isn't exposed in Golang so we define it ourselves copying the value\n// the kernel\nconst PR_SET_NO_NEW_PRIVS = 0x26\n\nfunc (l *linuxStandardInit) Init() error {\n\tif !l.config.Config.NoNewKeyring {\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// do not inherit the parent's session keyring\n\t\tsessKeyId, err := keys.JoinSessionKeyring(ringname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// make session keyring searcheable\n\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar console *linuxConsole\n\tif l.config.Console != \"\" {\n\t\tconsole = newConsoleFromPath(l.config.Console)\n\t\tif err := console.dupStdio(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif console != nil {\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\tlabel.Init()\n\t// InitializeMountNamespace() can be executed only for a new mount namespace\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := setupRootfs(l.config.Config, console, l.pipe); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := syscall.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn err\n\t}\n\tif err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {\n\t\treturn err\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := remountReadonly(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn err\n\t}\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn err\n\t}\n\t// compare the parent from the inital start of the init process and make sure that it did not change.\n\t// if the parent changes that means it died and we were reparented to something else so we should\n\t// just kill ourself and not cause problems for someone else.\n\tif syscall.Getppid() != l.parentPid {\n\t\treturn syscall.Kill(syscall.Getpid(), syscall.SIGKILL)\n\t}\n\t// check for the arg before waiting to make sure it exists and it is returned\n\t// as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// close the pipe to signal that we have completed our init.\n\tl.pipe.Close()\n\t// wait for the fifo to be opened on the other side before\n\t// exec'ing the users process.\n\tfd, err := syscall.Openat(l.stateDirFD, execFifoFilename, os.O_WRONLY|syscall.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn newSystemErrorWithCause(err, \"openat exec fifo\")\n\t}\n\tif _, err := syscall.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"write 0 exec fifo\")\n\t}\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tif err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {\n\t\t\treturn newSystemErrorWithCause(err, \"init seccomp\")\n\t\t}\n\t}\n\t// close the statedir fd before exec because the kernel resets dumpable in the wrong order\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\tsyscall.Close(l.stateDirFD)\n\tif err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil {\n\t\treturn newSystemErrorWithCause(err, \"exec user process\")\n\t}\n\treturn nil\n}\n"], "filenames": ["libcontainer/init_linux.go", "libcontainer/nsenter/nsexec.c", "libcontainer/setns_init_linux.go", "libcontainer/standard_init_linux.go"], "buggy_code_start_loc": [80, 410, 7, 173], "buggy_code_end_loc": [81, 410, 51, 173], "fixing_code_start_loc": [80, 411, 8, 174], "fixing_code_end_loc": [82, 416, 57, 177], "type": "CWE-362", "message": "RunC allowed additional container processes via 'runc exec' to be ptraced by the pid 1 of the container.  This allows the main processes of the container, if running as root, to gain access to file-descriptors of these new processes during the initialization and can lead to container escapes or modification of runC state before the process is fully placed inside the container.", "other": {"cve": {"id": "CVE-2016-9962", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-31T22:59:01.783", "lastModified": "2018-10-09T20:01:00.837", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RunC allowed additional container processes via 'runc exec' to be ptraced by the pid 1 of the container.  This allows the main processes of the container, if running as root, to gain access to file-descriptors of these new processes during the initialization and can lead to container escapes or modification of runC state before the process is fully placed inside the container."}, {"lang": "es", "value": "RunC permiti\u00f3 procesos de contenedores adicionales a trav\u00e9s de 'runc exec' para ser ptraced por el pid 1 del contenedor. Esto permite a los principales procesos del contenedor, si se ejecutan como root, obtener acceso a los descriptores de archivo de estos nuevos procesos durante la inicializaci\u00f3n y puede conducir a escapes de contenedores o modificaci\u00f3n del estado de runC antes de que el proceso sea totalmente ubicado dentro del contenedor."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:docker:docker:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.0", "versionEndExcluding": "1.12.6", "matchCriteriaId": "53E74F64-38C7-4907-9C6F-954CE37CEF24"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2017-0116.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0123.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0127.html", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2017/Jan/21", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2017/Jan/29", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/archive/1/540001/100/0/threaded", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/95361", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/security/vulnerabilities/cve-2016-9962", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1012568#c6", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/docker/docker/releases/tag/v1.12.6", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/opencontainers/runc/commit/50a19c6ff828c58e5dab13830bd3dacde268afe5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BQAXJMMLRU7DD2IMG47SR2K4BOFFG7FZ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FINGBFMIXBG6B6ZWYH3TMRP5V3PDBNXR/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UVM7FCOQMPKOFLDTUYSS4ES76DDM56VP/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WUQ3MQNEL5IBZZLMLR72Q4YDCL2SCKRK/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-34", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/50a19c6ff828c58e5dab13830bd3dacde268afe5"}}