{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) International Business Machines Corp., 2000-2004\n *   Portions Copyright (C) Tino Reichardt, 2012\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_discard.h\"\n\n/*\n *\tSERIALIZATION of the Block Allocation Map.\n *\n *\tthe working state of the block allocation map is accessed in\n *\ttwo directions:\n *\n *\t1) allocation and free requests that start at the dmap\n *\t   level and move up through the dmap control pages (i.e.\n *\t   the vast majority of requests).\n *\n *\t2) allocation requests that start at dmap control page\n *\t   level and work down towards the dmaps.\n *\n *\tthe serialization scheme used here is as follows.\n *\n *\trequests which start at the bottom are serialized against each\n *\tother through buffers and each requests holds onto its buffers\n *\tas it works it way up from a single dmap to the required level\n *\tof dmap control page.\n *\trequests that start at the top are serialized against each other\n *\tand request that start from the bottom by the multiple read/single\n *\twrite inode lock of the bmap inode. requests starting at the top\n *\ttake this lock in write mode while request starting at the bottom\n *\ttake the lock in read mode.  a single top-down request may proceed\n *\texclusively while multiple bottoms-up requests may proceed\n *\tsimultaneously (under the protection of busy buffers).\n *\n *\tin addition to information found in dmaps and dmap control pages,\n *\tthe working state of the block allocation map also includes read/\n *\twrite information maintained in the bmap descriptor (i.e. total\n *\tfree block count, allocation group level free block counts).\n *\ta single exclusive lock (BMAP_LOCK) is used to guard this information\n *\tin the face of multiple-bottoms up requests.\n *\t(lock ordering: IREAD_LOCK, BMAP_LOCK);\n *\n *\taccesses to the persistent state of the block allocation map (limited\n *\tto the persistent bitmaps in dmaps) is guarded by (busy) buffers.\n */\n\n#define BMAP_LOCK_INIT(bmp)\tmutex_init(&bmp->db_bmaplock)\n#define BMAP_LOCK(bmp)\t\tmutex_lock(&bmp->db_bmaplock)\n#define BMAP_UNLOCK(bmp)\tmutex_unlock(&bmp->db_bmaplock)\n\n/*\n * forward references\n */\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbMaxBud(u8 * cp);\nstatic int blkstol2(s64 nb);\n\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\n/*\n *\tbuddy table\n *\n * table used for determining buddy sizes within characters of\n * dmap bitmap words.  the characters themselves serve as indexes\n * into the table, with the table elements yielding the maximum\n * binary buddy of free bits within the character.\n */\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\n/*\n * NAME:\tdbMount()\n *\n * FUNCTION:\tinitializate the block allocation map.\n *\n *\t\tmemory is allocated for the in-core bmap descriptor and\n *\t\tthe in-core descriptor is initialized from disk.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOMEM\t- insufficient memory\n *\t-EIO\t- i/o error\n *\t-EINVAL - wrong bmap data\n */\nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tif (!bmp->db_numag) {\n\t\trelease_metapage(mp);\n\t\tkfree(bmp);\n\t\treturn -EINVAL;\n\t}\n\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbUnmount()\n *\n * FUNCTION:\tterminate the block allocation map in preparation for\n *\t\tfile system unmount.\n *\n *\t\tthe in-core bmap descriptor is written to disk and\n *\t\tthe memory for this descriptor is freed.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}\n\n/*\n *\tdbSync()\n */\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}\n\n/*\n * NAME:\tdbFree()\n *\n * FUNCTION:\tfree the specified block range from the working block\n *\t\tallocation map.\n *\n *\t\tthe blocks will be free from the working map one dmap\n *\t\tat a time.\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\tblkno\t- starting block number to be freed.\n *\tnblocks\t- number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbUpdatePMap()\n *\n * FUNCTION:\tupdate the allocation state (free or allocate) of the\n *\t\tspecified block range in the persistent block allocation map.\n *\n *\t\tthe blocks will be updated in the persistent map one\n *\t\tdmap at a time.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\tfree\t- 'true' if block range is to be freed from the persistent\n *\t\t  map; 'false' if it is to be allocated.\n *\tblkno\t- starting block number of the range.\n *\tnblocks\t- number of contiguous blocks in the range.\n *\ttblk\t- transaction block;\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbNextAG()\n *\n * FUNCTION:\tfind the preferred allocation group for new allocations.\n *\n *\t\tWithin the allocation groups, we maintain a preferred\n *\t\tallocation group which consists of a group with at least\n *\t\taverage free space.  It is the preferred group that we target\n *\t\tnew inode allocation towards.  The tie-in between inode\n *\t\tallocation and block allocation occurs as we allocate the\n *\t\tfirst (data) block of an inode and specify the inode (block)\n *\t\tas the allocation hint for this block.\n *\n *\t\tWe try to avoid having more than one open file growing in\n *\t\tan allocation group, as this will lead to fragmentation.\n *\t\tThis differs from the old OS/2 method of trying to keep\n *\t\tempty ags around for large allocations.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\tthe preferred allocation group number.\n */\nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}\n\n/*\n * NAME:\tdbAlloc()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous free\n *\t\tblocks from the working allocation block map.\n *\n *\t\tthe block allocation policy uses hints and a multi-step\n *\t\tapproach.\n *\n *\t\tfor allocation requests smaller than the number of blocks\n *\t\tper dmap, we first try to allocate the new blocks\n *\t\timmediately following the hint.  if these blocks are not\n *\t\tavailable, we try to allocate blocks near the hint.  if\n *\t\tno blocks near the hint are available, we next try to\n *\t\tallocate within the same dmap as contains the hint.\n *\n *\t\tif no blocks are available in the dmap or the allocation\n *\t\trequest is larger than the dmap size, we try to allocate\n *\t\twithin the same allocation group as contains the hint. if\n *\t\tthis does not succeed, we finally try to allocate anywhere\n *\t\twithin the aggregate.\n *\n *\t\twe also try to allocate anywhere within the aggregate\n *\t\tfor allocation requests larger than the allocation group\n *\t\tsize or requests that specify no hint value.\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\thint\t- allocation hint.\n *\tnblocks\t- number of contiguous blocks in the range.\n *\tresults\t- on successful return, set to the starting block number\n *\t\t  of the newly allocated contiguous range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\n{\n\tint rc, agno;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp;\n\tstruct metapage *mp;\n\ts64 lblkno, blkno;\n\tstruct dmap *dp;\n\tint l2nb;\n\ts64 mapSize;\n\tint writers;\n\n\t/* assert that nblocks is valid */\n\tassert(nblocks > 0);\n\n\t/* get the log2 number of blocks to be allocated.\n\t * if the number of blocks is not a log2 multiple,\n\t * it will be rounded up to the next log2 multiple.\n\t */\n\tl2nb = BLKSTOL2(nblocks);\n\n\tbmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tmapSize = bmp->db_mapsize;\n\n\t/* the hint should be within the map */\n\tif (hint >= mapSize) {\n\t\tjfs_error(ip->i_sb, \"the hint is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* if the number of blocks to be allocated is greater than the\n\t * allocation group size, try to allocate anywhere.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n\t\tgoto write_unlock;\n\t}\n\n\t/*\n\t * If no hint, let dbNextAG recommend an allocation group\n\t */\n\tif (hint == 0)\n\t\tgoto pref_ag;\n\n\t/* we would like to allocate close to the hint.  adjust the\n\t * hint to the block following the hint since the allocators\n\t * will start looking for free space starting at this point.\n\t */\n\tblkno = hint + 1;\n\n\tif (blkno >= bmp->db_mapsize)\n\t\tgoto pref_ag;\n\n\tagno = blkno >> bmp->db_agl2size;\n\n\t/* check if blkno crosses over into a new allocation group.\n\t * if so, check if we should allow allocations within this\n\t * allocation group.\n\t */\n\tif ((blkno & (bmp->db_agsize - 1)) == 0)\n\t\t/* check if the AG is currently being written to.\n\t\t * if so, call dbNextAG() to find a non-busy\n\t\t * AG with sufficient free space.\n\t\t */\n\t\tif (atomic_read(&bmp->db_active[agno]))\n\t\t\tgoto pref_ag;\n\n\t/* check if the allocation request size can be satisfied from a\n\t * single dmap.  if so, try to allocate from the dmap containing\n\t * the hint using a tiered strategy.\n\t */\n\tif (nblocks <= BPERDMAP) {\n\t\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\t/* get the buffer for the dmap containing the hint.\n\t\t */\n\t\trc = -EIO;\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\tgoto read_unlock;\n\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* first, try to satisfy the allocation request with the\n\t\t * blocks beginning at the hint.\n\t\t */\n\t\tif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0) {\n\t\t\t\t*results = blkno;\n\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t}\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\twriters = atomic_read(&bmp->db_active[agno]);\n\t\tif ((writers > 1) ||\n\t\t    ((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\n\t\t\t/*\n\t\t\t * Someone else is writing in this allocation\n\t\t\t * group.  To avoid fragmenting, try another ag\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\tgoto pref_ag;\n\t\t}\n\n\t\t/* next, try to satisfy the allocation request with blocks\n\t\t * near the hint.\n\t\t */\n\t\tif ((rc =\n\t\t     dbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\t/* try to satisfy the allocation request with blocks within\n\t\t * the same dmap as the hint.\n\t\t */\n\t\tif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipbmap);\n\t}\n\n\t/* try to satisfy the allocation request with blocks within\n\t * the same allocation group as the hint.\n\t */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\n\t\tgoto write_unlock;\n\n\tIWRITE_UNLOCK(ipbmap);\n\n\n      pref_ag:\n\t/*\n\t * Let dbNextAG recommend a preferred allocation group\n\t */\n\tagno = dbNextAG(ipbmap);\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* Try to allocate within this allocation group.  if that fails, try to\n\t * allocate anywhere in the map.\n\t */\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n      write_unlock:\n\tIWRITE_UNLOCK(ipbmap);\n\n\treturn (rc);\n\n      read_unlock:\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (rc);\n}\n\n#ifdef _NOTYET\n/*\n * NAME:\tdbAllocExact()\n *\n * FUNCTION:\ttry to allocate the requested extent;\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\tblkno\t- extent address;\n *\tnblocks\t- extent length;\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint dbAllocExact(struct inode *ip, s64 blkno, int nblocks)\n{\n\tint rc;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct dmap *dp;\n\ts64 lblkno;\n\tstruct metapage *mp;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/*\n\t * validate extent request:\n\t *\n\t * note: defragfs policy:\n\t *  max 64 blocks will be moved.\n\t *  allocation request size must be satisfied from a single dmap.\n\t */\n\tif (nblocks <= 0 || nblocks > BPERDMAP || blkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nblocks > ((s64) 1 << bmp->db_maxfreebud)) {\n\t\t/* the free space is no longer available */\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* read in the dmap covering the extent */\n\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the requested extent */\n\trc = dbAllocNext(bmp, dp, blkno, nblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\tif (rc == 0)\n\t\tmark_metapage_dirty(mp);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}\n#endif /* _NOTYET */\n\n/*\n * NAME:\tdbReAlloc()\n *\n * FUNCTION:\tattempt to extend a current allocation by a specified\n *\t\tnumber of blocks.\n *\n *\t\tthis routine attempts to satisfy the allocation request\n *\t\tby first trying to extend the existing allocation in\n *\t\tplace by allocating the additional blocks as the blocks\n *\t\timmediately following the current allocation.  if these\n *\t\tblocks are not available, this routine will attempt to\n *\t\tallocate a new set of contiguous blocks large enough\n *\t\tto cover the existing allocation plus the additional\n *\t\tnumber of blocks required.\n *\n * PARAMETERS:\n *\tip\t    -  pointer to in-core inode requiring allocation.\n *\tblkno\t    -  starting block of the current allocation.\n *\tnblocks\t    -  number of contiguous blocks within the current\n *\t\t       allocation.\n *\taddnblocks  -  number of blocks to add to the allocation.\n *\tresults\t-      on successful return, set to the starting block number\n *\t\t       of the existing allocation if the existing allocation\n *\t\t       was extended in place or to a newly allocated contiguous\n *\t\t       range if the existing allocation could not be extended\n *\t\t       in place.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}\n\n\n/*\n * NAME:\tdbExtend()\n *\n * FUNCTION:\tattempt to extend a current allocation by a specified\n *\t\tnumber of blocks.\n *\n *\t\tthis routine attempts to satisfy the allocation request\n *\t\tby first trying to extend the existing allocation in\n *\t\tplace by allocating the additional blocks as the blocks\n *\t\timmediately following the current allocation.\n *\n * PARAMETERS:\n *\tip\t    -  pointer to in-core inode requiring allocation.\n *\tblkno\t    -  starting block of the current allocation.\n *\tnblocks\t    -  number of contiguous blocks within the current\n *\t\t       allocation.\n *\taddnblocks  -  number of blocks to add to the allocation.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocNext()\n *\n * FUNCTION:\tattempt to allocate the blocks of the specified block\n *\t\trange within a dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap.\n *\tblkno\t-  starting block number of the range.\n *\tnblocks\t-  number of contiguous free blocks of the range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}\n\n\n/*\n * NAME:\tdbAllocNear()\n *\n * FUNCTION:\tattempt to allocate a number of contiguous free blocks near\n *\t\ta specified block (hint) within a dmap.\n *\n *\t\tstarting with the dmap leaf that covers the hint, we'll\n *\t\tcheck the next four contiguous leaves for sufficient free\n *\t\tspace.  if sufficient free space is found, we'll allocate\n *\t\tthe desired free space.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap.\n *\tblkno\t-  block number to allocate near.\n *\tnblocks\t-  actual number of contiguous free blocks desired.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}\n\n\n/*\n * NAME:\tdbAllocAG()\n *\n * FUNCTION:\tattempt to allocate the specified number of contiguous\n *\t\tfree blocks within the specified allocation group.\n *\n *\t\tunless the allocation group size is equal to the number\n *\t\tof blocks per dmap, the dmap control pages will be used to\n *\t\tfind the required free space, if available.  we start the\n *\t\tsearch at the highest dmap control page level which\n *\t\tdistinctly describes the allocation group's free space\n *\t\t(i.e. the highest level at which the allocation group's\n *\t\tfree space is not mixed in with that of any other group).\n *\t\tin addition, we start the search within this level at a\n *\t\theight of the dmapctl dmtree at which the nodes distinctly\n *\t\tdescribe the allocation group's free space.  at this height,\n *\t\tthe allocation group's free space may be represented by 1\n *\t\tor two sub-trees, depending on the allocation group size.\n *\t\twe search the top nodes of these subtrees left to right for\n *\t\tsufficient free space.  if sufficient free space is found,\n *\t\tthe subtree is searched to find the leftmost leaf that\n *\t\thas free space.  once we have made it to the leaf, we\n *\t\tmove the search to the next lower level dmap control page\n *\t\tcorresponding to this leaf.  we continue down the dmap control\n *\t\tpages until we find the dmap that contains or starts the\n *\t\tsufficient free space and we allocate at this dmap.\n *\n *\t\tif the allocation group size is equal to the dmap size,\n *\t\twe'll start at the dmap corresponding to the allocation\n *\t\tgroup and attempt the allocation at this level.\n *\n *\t\tthe dmap control page search is also not performed if the\n *\t\tallocation group is completely free and we go to the first\n *\t\tdmap of the allocation group to do the allocation.  this is\n *\t\tdone because the allocation group may be part (not the first\n *\t\tpart) of a larger binary buddy system, causing the dmap\n *\t\tcontrol pages to indicate no free space (NOFREE) within\n *\t\tthe allocation group.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tagno\t- allocation group number.\n *\tnblocks\t-  actual number of contiguous free blocks desired.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * note: IWRITE_LOCK(ipmap) held on entry/exit;\n */\nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}\n\n\n/*\n * NAME:\tdbAllocAny()\n *\n * FUNCTION:\tattempt to allocate the specified number of contiguous\n *\t\tfree blocks anywhere in the file system.\n *\n *\t\tdbAllocAny() attempts to find the sufficient free space by\n *\t\tsearching down the dmap control pages, starting with the\n *\t\thighest level (i.e. L0, L1, L2) control page.  if free space\n *\t\tlarge enough to satisfy the desired free space is found, the\n *\t\tdesired free space is allocated.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tnblocks\t -  actual number of contiguous free blocks desired.\n *\tl2nb\t -  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbDiscardAG()\n *\n * FUNCTION:\tattempt to discard (TRIM) all free blocks of specific AG\n *\n *\t\talgorithm:\n *\t\t1) allocate blocks, as large as possible and save them\n *\t\t   while holding IWRITE_LOCK on ipbmap\n *\t\t2) trim all these saved block/length values\n *\t\t3) mark the blocks free again\n *\n *\t\tbenefit:\n *\t\t- we work only on one ag at some time, minimizing how long we\n *\t\t  need to lock ipbmap\n *\t\t- reading / writing the fs is possible most time, even on\n *\t\t  trimming\n *\n *\t\tdownside:\n *\t\t- we write two times to the dmapctl and dmap pages\n *\t\t- but for me, this seems the best way, better ideas?\n *\t\t/TR 2012\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode\n *\tagno\t- ag to trim\n *\tminlen\t- minimum value of contiguous blocks\n *\n * RETURN VALUES:\n *\ts64\t- actual number of blocks trimmed\n */\ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc_array(range_cnt, sizeof(struct range2trim), GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1LL << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}\n\n/*\n * NAME:\tdbFindCtl()\n *\n * FUNCTION:\tstarting at a specified dmap control page level and block\n *\t\tnumber, search down the dmap control levels for a range of\n *\t\tcontiguous free blocks large enough to satisfy an allocation\n *\t\trequest for the specified number of free blocks.\n *\n *\t\tif sufficient contiguous free blocks are found, this routine\n *\t\treturns the starting block number within a dmap page that\n *\t\tcontains or starts a range of contiqious free blocks that\n *\t\tis sufficient in size.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tlevel\t-  starting dmap control page level.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\t*blkno\t-  on entry, starting block number for conducting the search.\n *\t\t   on successful return, the first block within a dmap page\n *\t\t   that contains or starts a range of contiguous free blocks.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbAllocCtl()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous\n *\t\tblocks starting within a specific dmap.\n *\n *\t\tthis routine is called by higher level routines that search\n *\t\tthe dmap control pages above the actual dmaps for contiguous\n *\t\tfree space.  the result of successful searches by these\n *\t\troutines are the starting block numbers within dmaps, with\n *\t\tthe dmaps themselves containing the desired contiguous free\n *\t\tspace or starting a contiguous free space of desired size\n *\t\tthat is made up of the blocks of one or more dmaps. these\n *\t\tcalls should not fail due to insufficent resources.\n *\n *\t\tthis routine is called in some cases where it is not known\n *\t\twhether it will fail due to insufficient resources.  more\n *\t\tspecifically, this occurs when allocating from an allocation\n *\t\tgroup whose size is equal to the number of blocks per dmap.\n *\t\tin this case, the dmap control pages are not examined prior\n *\t\tto calling this routine (to save pathlength) and the call\n *\t\tmight fail.\n *\n *\t\tfor a request size that fits within a dmap, this routine relies\n *\t\tupon the dmap's dmtree to find the requested contiguous free\n *\t\tspace.  for request sizes that are larger than a dmap, the\n *\t\trequested free space will start at the first block of the\n *\t\tfirst dmap (i.e. blkno).\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tnblocks\t -  actual number of contiguous free blocks to allocate.\n *\tl2nb\t -  log2 number of contiguous free blocks to allocate.\n *\tblkno\t -  starting block number of the dmap to start the allocation\n *\t\t    from.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocDmapLev()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous blocks\n *\t\tfrom a specified dmap.\n *\n *\t\tthis routine checks if the contiguous blocks are available.\n *\t\tif so, nblocks of blocks are allocated; otherwise, ENOSPC is\n *\t\treturned.\n *\n * PARAMETERS:\n *\tmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to attempt to allocate blocks from.\n *\tl2nb\t-  log2 number of contiguous block desired.\n *\tnblocks\t-  actual number of contiguous block desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap), e.g., from dbAlloc(), or\n *\tIWRITE_LOCK(ipbmap), e.g., dbAllocCtl(), held on entry/exit;\n */\nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocDmap()\n *\n * FUNCTION:\tadjust the disk allocation map to reflect the allocation\n *\t\tof a specified block range within a dmap.\n *\n *\t\tthis routine allocates the specified blocks from the dmap\n *\t\tthrough a call to dbAllocBits(). if the allocation of the\n *\t\tblock range causes the maximum string of free blocks within\n *\t\tthe dmap to change (i.e. the value of the root of the dmap's\n *\t\tdmtree), this routine will cause this change to be reflected\n *\t\tup through the appropriate levels of the dmap control pages\n *\t\tby a call to dbAdjCtl() for the L0 dmap control page that\n *\t\tcovers this dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to allocate the block range from.\n *\tblkno\t-  starting block number of the block to be allocated.\n *\tnblocks\t-  number of blocks to be allocated.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\ts8 oldroot;\n\tint rc;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* allocate the specified (blocks) bits */\n\tdbAllocBits(bmp, dp, blkno, nblocks);\n\n\t/* if the root has not changed, done. */\n\tif (dp->tree.stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbFreeDmap()\n *\n * FUNCTION:\tadjust the disk allocation map to reflect the allocation\n *\t\tof a specified block range within a dmap.\n *\n *\t\tthis routine frees the specified blocks from the dmap through\n *\t\ta call to dbFreeBits(). if the deallocation of the block range\n *\t\tcauses the maximum string of free blocks within the dmap to\n *\t\tchange (i.e. the value of the root of the dmap's dmtree), this\n *\t\troutine will cause this change to be reflected up through the\n *\t\tappropriate levels of the dmap control pages by a call to\n *\t\tdbAdjCtl() for the L0 dmap control page that covers this dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to free the block range from.\n *\tblkno\t-  starting block number of the block to be freed.\n *\tnblocks\t-  number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocBits()\n *\n * FUNCTION:\tallocate a specified block range from a dmap.\n *\n *\t\tthis routine updates the dmap to reflect the working\n *\t\tstate allocation of the specified block range. it directly\n *\t\tupdates the bits of the working map and causes the adjustment\n *\t\tof the binary buddy system described by the dmap's dmtree\n *\t\tleaves to reflect the bits allocated.  it also causes the\n *\t\tdmap's dmtree, as a whole, to reflect the allocated range.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to allocate bits from.\n *\tblkno\t-  starting block number of the bits to be allocated.\n *\tnblocks\t-  number of bits to be allocated.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}\n\n\n/*\n * NAME:\tdbFreeBits()\n *\n * FUNCTION:\tfree a specified block range from a dmap.\n *\n *\t\tthis routine updates the dmap to reflect the working\n *\t\tstate allocation of the specified block range. it directly\n *\t\tupdates the bits of the working map and causes the adjustment\n *\t\tof the binary buddy system described by the dmap's dmtree\n *\t\tleaves to reflect the bits freed.  it also causes the dmap's\n *\t\tdmtree, as a whole, to reflect the deallocated range.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to free bits from.\n *\tblkno\t-  starting block number of the bits to be freed.\n *\tnblocks\t-  number of bits to be freed.\n *\n * RETURN VALUES: 0 for success\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbAdjCtl()\n *\n * FUNCTION:\tadjust a dmap control page at a specified level to reflect\n *\t\tthe change in a lower level dmap or dmap control page's\n *\t\tmaximum string of free blocks (i.e. a change in the root\n *\t\tof the lower level object's dmtree) due to the allocation\n *\t\tor deallocation of a range of blocks with a single dmap.\n *\n *\t\ton entry, this routine is provided with the new value of\n *\t\tthe lower level dmap or dmap control page root and the\n *\t\tstarting block number of the block range whose allocation\n *\t\tor deallocation resulted in the root change.  this range\n *\t\tis respresented by a single leaf of the current dmapctl\n *\t\tand the leaf will be updated with this value, possibly\n *\t\tcausing a binary buddy system within the leaves to be\n *\t\tsplit or joined.  the update may also cause the dmapctl's\n *\t\tdmtree to be updated.\n *\n *\t\tif the adjustment of the dmap control page, itself, causes its\n *\t\troot to change, this change will be bubbled up to the next dmap\n *\t\tcontrol level by a recursive call to this routine, specifying\n *\t\tthe new root value and the next dmap control page level to\n *\t\tbe adjusted.\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tblkno\t-  the first block of a block range within a dmap.  it is\n *\t\t   the allocation or deallocation of this block range that\n *\t\t   requires the dmap control page to be adjusted.\n *\tnewval\t-  the new value of the lower level dmap or dmap control\n *\t\t   page root.\n *\talloc\t-  'true' if adjustment is due to an allocation.\n *\tlevel\t-  current level of dmap control page (i.e. L0, L1, L2) to\n *\t\t   be adjusted.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc) {\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc) {\n\t\t\trelease_metapage(mp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbSplit()\n *\n * FUNCTION:\tupdate the leaf of a dmtree with a new value, splitting\n *\t\tthe leaf from the binary buddy system of the dmtree's\n *\t\tleaves, as required.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\tsplitsz\t- the size the binary buddy system starting at the leaf\n *\t\t  must be split to, specified as the log2 number of blocks.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}\n\n\n/*\n * NAME:\tdbBackSplit()\n *\n * FUNCTION:\tback split the binary buddy system of dmtree leaves\n *\t\tthat hold a specified leaf until the specified leaf\n *\t\tstarts its own binary buddy system.\n *\n *\t\tthe allocators typically perform allocations at the start\n *\t\tof binary buddy systems and dbSplit() is used to accomplish\n *\t\tany required splits.  in some cases, however, allocation\n *\t\tmay occur in the middle of a binary system and requires a\n *\t\tback split, with the split proceeding out from the middle of\n *\t\tthe system (less efficient) rather than the start of the\n *\t\tsystem (more efficient).  the cases in which a back split\n *\t\tis required are rare and are limited to the first allocation\n *\t\twithin an allocation group which is a part (not first part)\n *\t\tof a larger binary buddy system and a few exception cases\n *\t\tin which a previous join operation must be backed out.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbJoin()\n *\n * FUNCTION:\tupdate the leaf of a dmtree with a new value, joining\n *\t\tthe leaf with other leaves of the dmtree into a multi-leaf\n *\t\tbinary buddy system, as required.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n */\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbAdjTree()\n *\n * FUNCTION:\tupdate a leaf of a dmtree with a new value, adjusting\n *\t\tthe dmtree, as required, to reflect the new leaf value.\n *\t\tthe combination of any buddies must already be done before\n *\t\tthis is called.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree to be adjusted.\n *\tleafno\t- the number of the leaf to be updated.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n */\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}\n\n\n/*\n * NAME:\tdbFindLeaf()\n *\n * FUNCTION:\tsearch a dmtree_t for sufficient free blocks, returning\n *\t\tthe index of a leaf describing the free blocks if\n *\t\tsufficient free blocks are found.\n *\n *\t\tthe search starts at the top of the dmtree_t tree and\n *\t\tproceeds down the tree to the leftmost leaf with sufficient\n *\t\tfree space.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree to be searched.\n *\tl2nb\t- log2 number of free blocks to search for.\n *\tleafidx\t- return pointer to be set to the index of the leaf\n *\t\t  describing at least l2nb free blocks if sufficient\n *\t\t  free blocks are found.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient free blocks.\n */\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbFindBits()\n *\n * FUNCTION:\tfind a specified number of binary buddy free bits within a\n *\t\tdmap bitmap word value.\n *\n *\t\tthis routine searches the bitmap value for (1 << l2nb) free\n *\t\tbits at (1 << l2nb) alignments within the value.\n *\n * PARAMETERS:\n *\tword\t-  dmap bitmap word value.\n *\tl2nb\t-  number of free bits specified as a log2 number.\n *\n * RETURN VALUES:\n *\tstarting bit number of free bits.\n */\nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}\n\n\n/*\n * NAME:\tdbMaxBud(u8 *cp)\n *\n * FUNCTION:\tdetermine the largest binary buddy string of free\n *\t\tbits within 32-bits of the map.\n *\n * PARAMETERS:\n *\tcp\t-  pointer to the 32-bit value.\n *\n * RETURN VALUES:\n *\tlargest binary buddy of free bits within a dmap word.\n */\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}\n\n\n/*\n * NAME:\tcnttz(uint word)\n *\n * FUNCTION:\tdetermine the number of trailing zeros within a 32-bit\n *\t\tvalue.\n *\n * PARAMETERS:\n *\tvalue\t-  32-bit value to be examined.\n *\n * RETURN VALUES:\n *\tcount of trailing zeros\n */\nstatic int cnttz(u32 word)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, word >>= 1) {\n\t\tif (word & 0x01)\n\t\t\tbreak;\n\t}\n\n\treturn (n);\n}\n\n\n/*\n * NAME:\tcntlz(u32 value)\n *\n * FUNCTION:\tdetermine the number of leading zeros within a 32-bit\n *\t\tvalue.\n *\n * PARAMETERS:\n *\tvalue\t-  32-bit value to be examined.\n *\n * RETURN VALUES:\n *\tcount of leading zeros\n */\nstatic int cntlz(u32 value)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, value <<= 1) {\n\t\tif (value & HIGHORDER)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}\n\n\n/*\n * NAME:\tblkstol2(s64 nb)\n *\n * FUNCTION:\tconvert a block count to its log2 value. if the block\n *\t\tcount is not a l2 multiple, it is rounded up to the next\n *\t\tlarger l2 multiple.\n *\n * PARAMETERS:\n *\tnb\t-  number of blocks\n *\n * RETURN VALUES:\n *\tlog2 number of blocks\n */\nstatic int blkstol2(s64 nb)\n{\n\tint l2nb;\n\ts64 mask;\t\t/* meant to be signed */\n\n\tmask = (s64) 1 << (64 - 1);\n\n\t/* count the leading bits.\n\t */\n\tfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\n\t\t/* leading bit found.\n\t\t */\n\t\tif (nb & mask) {\n\t\t\t/* determine the l2 value.\n\t\t\t */\n\t\t\tl2nb = (64 - 1) - l2nb;\n\n\t\t\t/* check if we need to round up.\n\t\t\t */\n\t\t\tif (~mask & nb)\n\t\t\t\tl2nb++;\n\n\t\t\treturn (l2nb);\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\t\t/* fix compiler warning */\n}\n\n\n/*\n * NAME:\tdbAllocBottomUp()\n *\n * FUNCTION:\talloc the specified block range from the working block\n *\t\tallocation map.\n *\n *\t\tthe blocks will be alloc from the working map one dmap\n *\t\tat a time.\n *\n * PARAMETERS:\n *\tip\t-  pointer to in-core inode;\n *\tblkno\t-  starting block number to be freed.\n *\tnblocks\t-  number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbExtendFS()\n *\n * FUNCTION:\textend bmap from blkno for nblocks;\n *\t\tdbExtendFS() updates bmap ready for dbAllocBottomUp();\n *\n * L2\n *  |\n *   L1---------------------------------L1\n *    |\t\t\t\t\t |\n *     L0---------L0---------L0\t\t  L0---------L0---------L0\n *      |\t   |\t      |\t\t   |\t      |\t\t |\n *\t d0,...,dn  d0,...,dn  d0,...,dn    d0,...,dn  d0,...,dn  d0,.,dm;\n * L2L1L0d0,...,dnL0d0,...,dnL0d0,...,dnL1L0d0,...,dnL0d0,...,dnL0d0,..dm\n *\n * <---old---><----------------------------extend----------------------->\n */\nint dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}\n\n\n/*\n *\tdbFinalizeBmap()\n */\nvoid dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inactive ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}\n\n\n/*\n * NAME:\tdbInitDmap()/ujfs_idmap_page()\n *\n * FUNCTION:\tinitialize working/persistent bitmap of the dmap page\n *\t\tfor the specified number of blocks:\n *\n *\t\tat entry, the bitmaps had been initialized as free (ZEROS);\n *\t\tThe number of blocks will only account for the actually\n *\t\texisting blocks. Blocks which don't actually exist in\n *\t\tthe aggregate will be marked as allocated (ONES);\n *\n * PARAMETERS:\n *\tdp\t- pointer to page of map\n *\tnblocks\t- number of blocks this page\n *\n * RETURNS: NONE\n */\nstatic int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\n{\n\tint blkno, w, b, r, nw, nb, i;\n\n\t/* starting block number within the dmap */\n\tblkno = Blkno & (BPERDMAP - 1);\n\n\tif (blkno == 0) {\n\t\tdp->nblocks = dp->nfree = cpu_to_le32(nblocks);\n\t\tdp->start = cpu_to_le64(Blkno);\n\n\t\tif (nblocks == BPERDMAP) {\n\t\t\tmemset(&dp->wmap[0], 0, LPERDMAP * 4);\n\t\t\tmemset(&dp->pmap[0], 0, LPERDMAP * 4);\n\t\t\tgoto initTree;\n\t\t}\n\t} else {\n\t\tle32_add_cpu(&dp->nblocks, nblocks);\n\t\tle32_add_cpu(&dp->nfree, nblocks);\n\t}\n\n\t/* word number containing start block number */\n\tw = blkno >> L2DBWORD;\n\n\t/*\n\t * free the bits corresponding to the block range (ZEROS):\n\t * note: not all bits of the first and last words may be contained\n\t * within the block range.\n\t */\n\tfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\n\t\t/* number of bits preceding range to be freed in the word */\n\t\tb = blkno & (DBWORD - 1);\n\t\t/* number of bits to free in the word */\n\t\tnb = min(r, DBWORD - b);\n\n\t\t/* is partial word to be freed ? */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (set to 0) from the bitmap word */\n\t\t\tdp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\t\t\tdp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\n\t\t\t/* skip the word freed */\n\t\t\tw++;\n\t\t} else {\n\t\t\t/* free (set to 0) contiguous bitmap words */\n\t\t\tnw = r >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[w], 0, nw * 4);\n\t\t\tmemset(&dp->pmap[w], 0, nw * 4);\n\n\t\t\t/* skip the words freed */\n\t\t\tnb = nw << L2DBWORD;\n\t\t\tw += nw;\n\t\t}\n\t}\n\n\t/*\n\t * mark bits following the range to be freed (non-existing\n\t * blocks) as allocated (ONES)\n\t */\n\n\tif (blkno == BPERDMAP)\n\t\tgoto initTree;\n\n\t/* the first word beyond the end of existing blocks */\n\tw = blkno >> L2DBWORD;\n\n\t/* does nblocks fall on a 32-bit boundary ? */\n\tb = blkno & (DBWORD - 1);\n\tif (b) {\n\t\t/* mark a partial word allocated */\n\t\tdp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\n\t\tw++;\n\t}\n\n\t/* set the rest of the words in the page to allocated (ONES) */\n\tfor (i = w; i < LPERDMAP; i++)\n\t\tdp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\n\n\t/*\n\t * init tree\n\t */\n      initTree:\n\treturn (dbInitDmapTree(dp));\n}\n\n\n/*\n * NAME:\tdbInitDmapTree()/ujfs_complete_dmap()\n *\n * FUNCTION:\tinitialize summary tree of the specified dmap:\n *\n *\t\tat entry, bitmap of the dmap has been initialized;\n *\n * PARAMETERS:\n *\tdp\t- dmap to complete\n *\tblkno\t- starting block number for this dmap\n *\ttreemax\t- will be filled in with max free for this dmap\n *\n * RETURNS:\tmax free string at the root of the tree\n */\nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}\n\n\n/*\n * NAME:\tdbInitTree()/ujfs_adjtree()\n *\n * FUNCTION:\tinitialize binary buddy summary tree of a dmap or dmapctl.\n *\n *\t\tat entry, the leaves of the tree has been initialized\n *\t\tfrom corresponding bitmap word or root of summary tree\n *\t\tof the child control page;\n *\t\tconfigure binary buddy system at the leaf level, then\n *\t\tbubble up the values of the leaf nodes up the tree.\n *\n * PARAMETERS:\n *\tcp\t- Pointer to the root of the tree\n *\tl2leaves- Number of leaf nodes as a power of 2\n *\tl2min\t- Number of blocks that can be covered by a leaf\n *\t\t  as a power of 2\n *\n * RETURNS: max free string at the root of the tree\n */\nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}\n\n\n/*\n *\tdbInitDmapCtl()\n *\n * function: initialize dmapctl page\n */\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}\n\n\n/*\n * NAME:\tdbGetL2AGSize()/ujfs_getagl2size()\n *\n * FUNCTION:\tDetermine log2(allocation group size) from aggregate size\n *\n * PARAMETERS:\n *\tnblocks\t- Number of blocks in aggregate\n *\n * RETURNS: log2(allocation group size) in aggregate blocks\n */\nstatic int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}\n\n\n/*\n * NAME:\tdbMapFileSizeToMapSize()\n *\n * FUNCTION:\tcompute number of blocks the block allocation map file\n *\t\tcan cover from the map file size;\n *\n * RETURNS:\tNumber of blocks which can be covered by this block map file;\n */\n\n/*\n * maximum number of map pages at each level including control pages\n */\n#define MAXL0PAGES\t(1 + LPERCTL)\n#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)\n\n/*\n * convert number of map pages to the zero origin top dmapctl level\n */\n#define BMAPPGTOLEV(npages)\t\\\n\t(((npages) <= 3 + MAXL0PAGES) ? 0 : \\\n\t ((npages) <= 2 + MAXL1PAGES) ? 1 : 2)\n\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) International Business Machines Corp., 2000-2004\n *   Portions Copyright (C) Tino Reichardt, 2012\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"jfs_incore.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_discard.h\"\n\n/*\n *\tSERIALIZATION of the Block Allocation Map.\n *\n *\tthe working state of the block allocation map is accessed in\n *\ttwo directions:\n *\n *\t1) allocation and free requests that start at the dmap\n *\t   level and move up through the dmap control pages (i.e.\n *\t   the vast majority of requests).\n *\n *\t2) allocation requests that start at dmap control page\n *\t   level and work down towards the dmaps.\n *\n *\tthe serialization scheme used here is as follows.\n *\n *\trequests which start at the bottom are serialized against each\n *\tother through buffers and each requests holds onto its buffers\n *\tas it works it way up from a single dmap to the required level\n *\tof dmap control page.\n *\trequests that start at the top are serialized against each other\n *\tand request that start from the bottom by the multiple read/single\n *\twrite inode lock of the bmap inode. requests starting at the top\n *\ttake this lock in write mode while request starting at the bottom\n *\ttake the lock in read mode.  a single top-down request may proceed\n *\texclusively while multiple bottoms-up requests may proceed\n *\tsimultaneously (under the protection of busy buffers).\n *\n *\tin addition to information found in dmaps and dmap control pages,\n *\tthe working state of the block allocation map also includes read/\n *\twrite information maintained in the bmap descriptor (i.e. total\n *\tfree block count, allocation group level free block counts).\n *\ta single exclusive lock (BMAP_LOCK) is used to guard this information\n *\tin the face of multiple-bottoms up requests.\n *\t(lock ordering: IREAD_LOCK, BMAP_LOCK);\n *\n *\taccesses to the persistent state of the block allocation map (limited\n *\tto the persistent bitmaps in dmaps) is guarded by (busy) buffers.\n */\n\n#define BMAP_LOCK_INIT(bmp)\tmutex_init(&bmp->db_bmaplock)\n#define BMAP_LOCK(bmp)\t\tmutex_lock(&bmp->db_bmaplock)\n#define BMAP_UNLOCK(bmp)\tmutex_unlock(&bmp->db_bmaplock)\n\n/*\n * forward references\n */\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval);\nstatic int dbBackSplit(dmtree_t * tp, int leafno);\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval);\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindBits(u32 word, int l2nb);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbMaxBud(u8 * cp);\nstatic int blkstol2(s64 nb);\n\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitTree(struct dmaptree * dtp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\n/*\n *\tbuddy table\n *\n * table used for determining buddy sizes within characters of\n * dmap bitmap words.  the characters themselves serve as indexes\n * into the table, with the table elements yielding the maximum\n * binary buddy of free bits within the character.\n */\nstatic const s8 budtab[256] = {\n\t3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,\n\t2, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -1\n};\n\n/*\n * NAME:\tdbMount()\n *\n * FUNCTION:\tinitializate the block allocation map.\n *\n *\t\tmemory is allocated for the in-core bmap descriptor and\n *\t\tthe in-core descriptor is initialized from disk.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOMEM\t- insufficient memory\n *\t-EIO\t- i/o error\n *\t-EINVAL - wrong bmap data\n */\nint dbMount(struct inode *ipbmap)\n{\n\tstruct bmap *bmp;\n\tstruct dbmap_disk *dbmp_le;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * allocate/initialize the in-memory bmap descriptor\n\t */\n\t/* allocate memory for the in-memory bmap descriptor */\n\tbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\n\tif (bmp == NULL)\n\t\treturn -ENOMEM;\n\n\t/* read the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\t/* copy the on-disk bmap descriptor to its in-memory version. */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\n\tbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\n\tbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\n\tbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\n\tif (!bmp->db_numag) {\n\t\trelease_metapage(mp);\n\t\tkfree(bmp);\n\t\treturn -EINVAL;\n\t}\n\n\tbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\n\tbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\n\tbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\n\tbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\n\tbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\n\tbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\n\tbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\n\tbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\n\tbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\n\tbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\n\n\t/* release the buffer. */\n\trelease_metapage(mp);\n\n\t/* bind the bmap inode and the bmap descriptor to each other. */\n\tbmp->db_ipbmap = ipbmap;\n\tJFS_SBI(ipbmap->i_sb)->bmap = bmp;\n\n\tmemset(bmp->db_active, 0, sizeof(bmp->db_active));\n\n\t/*\n\t * allocate/initialize the bmap lock\n\t */\n\tBMAP_LOCK_INIT(bmp);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbUnmount()\n *\n * FUNCTION:\tterminate the block allocation map in preparation for\n *\t\tfile system unmount.\n *\n *\t\tthe in-core bmap descriptor is written to disk and\n *\t\tthe memory for this descriptor is freed.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbUnmount(struct inode *ipbmap, int mounterror)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tif (!(mounterror || isReadOnly(ipbmap)))\n\t\tdbSync(ipbmap);\n\n\t/*\n\t * Invalidate the page cache buffers\n\t */\n\ttruncate_inode_pages(ipbmap->i_mapping, 0);\n\n\t/* free the memory for the in-memory bmap. */\n\tkfree(bmp);\n\n\treturn (0);\n}\n\n/*\n *\tdbSync()\n */\nint dbSync(struct inode *ipbmap)\n{\n\tstruct dbmap_disk *dbmp_le;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tstruct metapage *mp;\n\tint i;\n\n\t/*\n\t * write bmap global control page\n\t */\n\t/* get the buffer for the on-disk bmap descriptor. */\n\tmp = read_metapage(ipbmap,\n\t\t\t   BMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\n\t\t\t   PSIZE, 0);\n\tif (mp == NULL) {\n\t\tjfs_err(\"dbSync: read_metapage failed!\");\n\t\treturn -EIO;\n\t}\n\t/* copy the in-memory version of the bmap to the on-disk version */\n\tdbmp_le = (struct dbmap_disk *) mp->data;\n\tdbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\n\tdbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\n\tdbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\n\tdbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\n\tdbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\n\tdbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\n\tdbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\n\tdbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\n\tdbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\n\tdbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\n\tdbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\n\tdbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\n\tfor (i = 0; i < MAXAG; i++)\n\t\tdbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\n\tdbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\n\tdbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\n\n\t/* write the buffer */\n\twrite_metapage(mp);\n\n\t/*\n\t * write out dirty pages of bmap\n\t */\n\tfilemap_write_and_wait(ipbmap->i_mapping);\n\n\tdiWriteSpecial(ipbmap, 0);\n\n\treturn (0);\n}\n\n/*\n * NAME:\tdbFree()\n *\n * FUNCTION:\tfree the specified block range from the working block\n *\t\tallocation map.\n *\n *\t\tthe blocks will be free from the working map one dmap\n *\t\tat a time.\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\tblkno\t- starting block number to be freed.\n *\tnblocks\t- number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\tif (mp)\n\t\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbUpdatePMap()\n *\n * FUNCTION:\tupdate the allocation state (free or allocate) of the\n *\t\tspecified block range in the persistent block allocation map.\n *\n *\t\tthe blocks will be updated in the persistent map one\n *\t\tdmap at a time.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\tfree\t- 'true' if block range is to be freed from the persistent\n *\t\t  map; 'false' if it is to be allocated.\n *\tblkno\t- starting block number of the range.\n *\tnblocks\t- number of contiguous blocks in the range.\n *\ttblk\t- transaction block;\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint\ndbUpdatePMap(struct inode *ipbmap,\n\t     int free, s64 blkno, s64 nblocks, struct tblock * tblk)\n{\n\tint nblks, dbitno, wbitno, rbits;\n\tint word, nbits, nwords;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\ts64 lblkno, rem, lastlblkno;\n\tu32 mask;\n\tstruct dmap *dp;\n\tstruct metapage *mp;\n\tstruct jfs_log *log;\n\tint lsn, difft, diffp;\n\tunsigned long flags;\n\n\t/* the blocks better be within the mapsize. */\n\tif (blkno + nblocks > bmp->db_mapsize) {\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ipbmap->i_sb, \"blocks are outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute delta of transaction lsn from log syncpt */\n\tlsn = tblk->lsn;\n\tlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\n\tlogdiff(difft, lsn, log);\n\n\t/*\n\t * update the block state a dmap at a time.\n\t */\n\tmp = NULL;\n\tlastlblkno = 0;\n\tfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tif (lblkno != lastlblkno) {\n\t\t\tif (mp) {\n\t\t\t\twrite_metapage(mp);\n\t\t\t}\n\n\t\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\n\t\t\t\t\t   0);\n\t\t\tif (mp == NULL)\n\t\t\t\treturn -EIO;\n\t\t\tmetapage_wait_for_io(mp);\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the bit number and word within the dmap of\n\t\t * the starting block.  also determine how many blocks\n\t\t * are to be updated within this dmap.\n\t\t */\n\t\tdbitno = blkno & (BPERDMAP - 1);\n\t\tword = dbitno >> L2DBWORD;\n\t\tnblks = min(rem, (s64)BPERDMAP - dbitno);\n\n\t\t/* update the bits of the dmap words. the first and last\n\t\t * words may only have a subset of their bits updated. if\n\t\t * this is the case, we'll work against that word (i.e.\n\t\t * partial first and/or last) only in a single pass.  a\n\t\t * single pass will also be used to update all words that\n\t\t * are to have all their bits updated.\n\t\t */\n\t\tfor (rbits = nblks; rbits > 0;\n\t\t     rbits -= nbits, dbitno += nbits) {\n\t\t\t/* determine the bit number within the word and\n\t\t\t * the number of bits within the word.\n\t\t\t */\n\t\t\twbitno = dbitno & (DBWORD - 1);\n\t\t\tnbits = min(rbits, DBWORD - wbitno);\n\n\t\t\t/* check if only part of the word is to be updated. */\n\t\t\tif (nbits < DBWORD) {\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in this word.\n\t\t\t\t */\n\t\t\t\tmask =\n\t\t\t\t    (ONES << (DBWORD - nbits) >> wbitno);\n\t\t\t\tif (free)\n\t\t\t\t\tdp->pmap[word] &=\n\t\t\t\t\t    cpu_to_le32(~mask);\n\t\t\t\telse\n\t\t\t\t\tdp->pmap[word] |=\n\t\t\t\t\t    cpu_to_le32(mask);\n\n\t\t\t\tword += 1;\n\t\t\t} else {\n\t\t\t\t/* one or more words are to have all\n\t\t\t\t * their bits updated.  determine how\n\t\t\t\t * many words and how many bits.\n\t\t\t\t */\n\t\t\t\tnwords = rbits >> L2DBWORD;\n\t\t\t\tnbits = nwords << L2DBWORD;\n\n\t\t\t\t/* update (free or allocate) the bits\n\t\t\t\t * in these words.\n\t\t\t\t */\n\t\t\t\tif (free)\n\t\t\t\t\tmemset(&dp->pmap[word], 0,\n\t\t\t\t\t       nwords * 4);\n\t\t\t\telse\n\t\t\t\t\tmemset(&dp->pmap[word], (int) ONES,\n\t\t\t\t\t       nwords * 4);\n\n\t\t\t\tword += nwords;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * update dmap lsn\n\t\t */\n\t\tif (lblkno == lastlblkno)\n\t\t\tcontinue;\n\n\t\tlastlblkno = lblkno;\n\n\t\tLOGSYNC_LOCK(log, flags);\n\t\tif (mp->lsn != 0) {\n\t\t\t/* inherit older/smaller lsn */\n\t\t\tlogdiff(diffp, mp->lsn, log);\n\t\t\tif (difft < diffp) {\n\t\t\t\tmp->lsn = lsn;\n\n\t\t\t\t/* move bp after tblock in logsync list */\n\t\t\t\tlist_move(&mp->synclist, &tblk->synclist);\n\t\t\t}\n\n\t\t\t/* inherit younger/larger clsn */\n\t\t\tlogdiff(difft, tblk->clsn, log);\n\t\t\tlogdiff(diffp, mp->clsn, log);\n\t\t\tif (difft > diffp)\n\t\t\t\tmp->clsn = tblk->clsn;\n\t\t} else {\n\t\t\tmp->log = log;\n\t\t\tmp->lsn = lsn;\n\n\t\t\t/* insert bp after tblock in logsync list */\n\t\t\tlog->count++;\n\t\t\tlist_add(&mp->synclist, &tblk->synclist);\n\n\t\t\tmp->clsn = tblk->clsn;\n\t\t}\n\t\tLOGSYNC_UNLOCK(log, flags);\n\t}\n\n\t/* write the last buffer. */\n\tif (mp) {\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbNextAG()\n *\n * FUNCTION:\tfind the preferred allocation group for new allocations.\n *\n *\t\tWithin the allocation groups, we maintain a preferred\n *\t\tallocation group which consists of a group with at least\n *\t\taverage free space.  It is the preferred group that we target\n *\t\tnew inode allocation towards.  The tie-in between inode\n *\t\tallocation and block allocation occurs as we allocate the\n *\t\tfirst (data) block of an inode and specify the inode (block)\n *\t\tas the allocation hint for this block.\n *\n *\t\tWe try to avoid having more than one open file growing in\n *\t\tan allocation group, as this will lead to fragmentation.\n *\t\tThis differs from the old OS/2 method of trying to keep\n *\t\tempty ags around for large allocations.\n *\n * PARAMETERS:\n *\tipbmap\t- pointer to in-core inode for the block map.\n *\n * RETURN VALUES:\n *\tthe preferred allocation group number.\n */\nint dbNextAG(struct inode *ipbmap)\n{\n\ts64 avgfree;\n\tint agpref;\n\ts64 hwm = 0;\n\tint i;\n\tint next_best = -1;\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\n\tBMAP_LOCK(bmp);\n\n\t/* determine the average number of free blocks within the ags. */\n\tavgfree = (u32)bmp->db_nfree / bmp->db_numag;\n\n\t/*\n\t * if the current preferred ag does not have an active allocator\n\t * and has at least average freespace, return it\n\t */\n\tagpref = bmp->db_agpref;\n\tif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\n\t    (bmp->db_agfree[agpref] >= avgfree))\n\t\tgoto unlock;\n\n\t/* From the last preferred ag, find the next one with at least\n\t * average free space.\n\t */\n\tfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\n\t\tif (agpref == bmp->db_numag)\n\t\t\tagpref = 0;\n\n\t\tif (atomic_read(&bmp->db_active[agpref]))\n\t\t\t/* open file is currently growing in this ag */\n\t\t\tcontinue;\n\t\tif (bmp->db_agfree[agpref] >= avgfree) {\n\t\t\t/* Return this one */\n\t\t\tbmp->db_agpref = agpref;\n\t\t\tgoto unlock;\n\t\t} else if (bmp->db_agfree[agpref] > hwm) {\n\t\t\t/* Less than avg. freespace, but best so far */\n\t\t\thwm = bmp->db_agfree[agpref];\n\t\t\tnext_best = agpref;\n\t\t}\n\t}\n\n\t/*\n\t * If no inactive ag was found with average freespace, use the\n\t * next best\n\t */\n\tif (next_best != -1)\n\t\tbmp->db_agpref = next_best;\n\t/* else leave db_agpref unchanged */\nunlock:\n\tBMAP_UNLOCK(bmp);\n\n\t/* return the preferred group.\n\t */\n\treturn (bmp->db_agpref);\n}\n\n/*\n * NAME:\tdbAlloc()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous free\n *\t\tblocks from the working allocation block map.\n *\n *\t\tthe block allocation policy uses hints and a multi-step\n *\t\tapproach.\n *\n *\t\tfor allocation requests smaller than the number of blocks\n *\t\tper dmap, we first try to allocate the new blocks\n *\t\timmediately following the hint.  if these blocks are not\n *\t\tavailable, we try to allocate blocks near the hint.  if\n *\t\tno blocks near the hint are available, we next try to\n *\t\tallocate within the same dmap as contains the hint.\n *\n *\t\tif no blocks are available in the dmap or the allocation\n *\t\trequest is larger than the dmap size, we try to allocate\n *\t\twithin the same allocation group as contains the hint. if\n *\t\tthis does not succeed, we finally try to allocate anywhere\n *\t\twithin the aggregate.\n *\n *\t\twe also try to allocate anywhere within the aggregate\n *\t\tfor allocation requests larger than the allocation group\n *\t\tsize or requests that specify no hint value.\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\thint\t- allocation hint.\n *\tnblocks\t- number of contiguous blocks in the range.\n *\tresults\t- on successful return, set to the starting block number\n *\t\t  of the newly allocated contiguous range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\n{\n\tint rc, agno;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp;\n\tstruct metapage *mp;\n\ts64 lblkno, blkno;\n\tstruct dmap *dp;\n\tint l2nb;\n\ts64 mapSize;\n\tint writers;\n\n\t/* assert that nblocks is valid */\n\tassert(nblocks > 0);\n\n\t/* get the log2 number of blocks to be allocated.\n\t * if the number of blocks is not a log2 multiple,\n\t * it will be rounded up to the next log2 multiple.\n\t */\n\tl2nb = BLKSTOL2(nblocks);\n\n\tbmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tmapSize = bmp->db_mapsize;\n\n\t/* the hint should be within the map */\n\tif (hint >= mapSize) {\n\t\tjfs_error(ip->i_sb, \"the hint is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* if the number of blocks to be allocated is greater than the\n\t * allocation group size, try to allocate anywhere.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n\t\tgoto write_unlock;\n\t}\n\n\t/*\n\t * If no hint, let dbNextAG recommend an allocation group\n\t */\n\tif (hint == 0)\n\t\tgoto pref_ag;\n\n\t/* we would like to allocate close to the hint.  adjust the\n\t * hint to the block following the hint since the allocators\n\t * will start looking for free space starting at this point.\n\t */\n\tblkno = hint + 1;\n\n\tif (blkno >= bmp->db_mapsize)\n\t\tgoto pref_ag;\n\n\tagno = blkno >> bmp->db_agl2size;\n\n\t/* check if blkno crosses over into a new allocation group.\n\t * if so, check if we should allow allocations within this\n\t * allocation group.\n\t */\n\tif ((blkno & (bmp->db_agsize - 1)) == 0)\n\t\t/* check if the AG is currently being written to.\n\t\t * if so, call dbNextAG() to find a non-busy\n\t\t * AG with sufficient free space.\n\t\t */\n\t\tif (atomic_read(&bmp->db_active[agno]))\n\t\t\tgoto pref_ag;\n\n\t/* check if the allocation request size can be satisfied from a\n\t * single dmap.  if so, try to allocate from the dmap containing\n\t * the hint using a tiered strategy.\n\t */\n\tif (nblocks <= BPERDMAP) {\n\t\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t\t/* get the buffer for the dmap containing the hint.\n\t\t */\n\t\trc = -EIO;\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\tgoto read_unlock;\n\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* first, try to satisfy the allocation request with the\n\t\t * blocks beginning at the hint.\n\t\t */\n\t\tif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0) {\n\t\t\t\t*results = blkno;\n\t\t\t\tmark_metapage_dirty(mp);\n\t\t\t}\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\twriters = atomic_read(&bmp->db_active[agno]);\n\t\tif ((writers > 1) ||\n\t\t    ((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\n\t\t\t/*\n\t\t\t * Someone else is writing in this allocation\n\t\t\t * group.  To avoid fragmenting, try another ag\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\tgoto pref_ag;\n\t\t}\n\n\t\t/* next, try to satisfy the allocation request with blocks\n\t\t * near the hint.\n\t\t */\n\t\tif ((rc =\n\t\t     dbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\t/* try to satisfy the allocation request with blocks within\n\t\t * the same dmap as the hint.\n\t\t */\n\t\tif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\n\t\t    != -ENOSPC) {\n\t\t\tif (rc == 0)\n\t\t\t\tmark_metapage_dirty(mp);\n\n\t\t\trelease_metapage(mp);\n\t\t\tgoto read_unlock;\n\t\t}\n\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipbmap);\n\t}\n\n\t/* try to satisfy the allocation request with blocks within\n\t * the same allocation group as the hint.\n\t */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\n\t\tgoto write_unlock;\n\n\tIWRITE_UNLOCK(ipbmap);\n\n\n      pref_ag:\n\t/*\n\t * Let dbNextAG recommend a preferred allocation group\n\t */\n\tagno = dbNextAG(ipbmap);\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* Try to allocate within this allocation group.  if that fails, try to\n\t * allocate anywhere in the map.\n\t */\n\tif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\n\t\trc = dbAllocAny(bmp, nblocks, l2nb, results);\n\n      write_unlock:\n\tIWRITE_UNLOCK(ipbmap);\n\n\treturn (rc);\n\n      read_unlock:\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (rc);\n}\n\n#ifdef _NOTYET\n/*\n * NAME:\tdbAllocExact()\n *\n * FUNCTION:\ttry to allocate the requested extent;\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode;\n *\tblkno\t- extent address;\n *\tnblocks\t- extent length;\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint dbAllocExact(struct inode *ip, s64 blkno, int nblocks)\n{\n\tint rc;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct dmap *dp;\n\ts64 lblkno;\n\tstruct metapage *mp;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/*\n\t * validate extent request:\n\t *\n\t * note: defragfs policy:\n\t *  max 64 blocks will be moved.\n\t *  allocation request size must be satisfied from a single dmap.\n\t */\n\tif (nblocks <= 0 || nblocks > BPERDMAP || blkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nblocks > ((s64) 1 << bmp->db_maxfreebud)) {\n\t\t/* the free space is no longer available */\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* read in the dmap covering the extent */\n\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the requested extent */\n\trc = dbAllocNext(bmp, dp, blkno, nblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\tif (rc == 0)\n\t\tmark_metapage_dirty(mp);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}\n#endif /* _NOTYET */\n\n/*\n * NAME:\tdbReAlloc()\n *\n * FUNCTION:\tattempt to extend a current allocation by a specified\n *\t\tnumber of blocks.\n *\n *\t\tthis routine attempts to satisfy the allocation request\n *\t\tby first trying to extend the existing allocation in\n *\t\tplace by allocating the additional blocks as the blocks\n *\t\timmediately following the current allocation.  if these\n *\t\tblocks are not available, this routine will attempt to\n *\t\tallocate a new set of contiguous blocks large enough\n *\t\tto cover the existing allocation plus the additional\n *\t\tnumber of blocks required.\n *\n * PARAMETERS:\n *\tip\t    -  pointer to in-core inode requiring allocation.\n *\tblkno\t    -  starting block of the current allocation.\n *\tnblocks\t    -  number of contiguous blocks within the current\n *\t\t       allocation.\n *\taddnblocks  -  number of blocks to add to the allocation.\n *\tresults\t-      on successful return, set to the starting block number\n *\t\t       of the existing allocation if the existing allocation\n *\t\t       was extended in place or to a newly allocated contiguous\n *\t\t       range if the existing allocation could not be extended\n *\t\t       in place.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nint\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}\n\n\n/*\n * NAME:\tdbExtend()\n *\n * FUNCTION:\tattempt to extend a current allocation by a specified\n *\t\tnumber of blocks.\n *\n *\t\tthis routine attempts to satisfy the allocation request\n *\t\tby first trying to extend the existing allocation in\n *\t\tplace by allocating the additional blocks as the blocks\n *\t\timmediately following the current allocation.\n *\n * PARAMETERS:\n *\tip\t    -  pointer to in-core inode requiring allocation.\n *\tblkno\t    -  starting block of the current allocation.\n *\tnblocks\t    -  number of contiguous blocks within the current\n *\t\t       allocation.\n *\taddnblocks  -  number of blocks to add to the allocation.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n */\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 lblkno, lastblkno, extblkno;\n\tuint rel_block;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint rc;\n\tstruct inode *ipbmap = sbi->ipbmap;\n\tstruct bmap *bmp;\n\n\t/*\n\t * We don't want a non-aligned extent to cross a page boundary\n\t */\n\tif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\n\t    (rel_block + nblocks + addnblocks > sbi->nbperpage))\n\t\treturn -ENOSPC;\n\n\t/* get the last block of the current allocation */\n\tlastblkno = blkno + nblocks - 1;\n\n\t/* determine the block number of the block following\n\t * the existing allocation.\n\t */\n\textblkno = lastblkno + 1;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* better be within the file system */\n\tbmp = sbi->bmap;\n\tif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tjfs_error(ip->i_sb, \"the block is outside the filesystem\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* we'll attempt to extend the current allocation in place by\n\t * allocating the additional blocks as the blocks immediately\n\t * following the current allocation.  we only try to extend the\n\t * current allocation in place if the number of additional blocks\n\t * can fit into a dmap, the last block of the current allocation\n\t * is not the last block of the file system, and the start of the\n\t * inplace extension is not on an allocation group boundary.\n\t */\n\tif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\n\t    (extblkno & (bmp->db_agsize - 1)) == 0) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* get the buffer for the dmap containing the first block\n\t * of the extension.\n\t */\n\tlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\n\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\treturn -EIO;\n\t}\n\n\tdp = (struct dmap *) mp->data;\n\n\t/* try to allocate the blocks immediately following the\n\t * current allocation.\n\t */\n\trc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\t/* were we successful ? */\n\tif (rc == 0)\n\t\twrite_metapage(mp);\n\telse\n\t\t/* we were not successful */\n\t\trelease_metapage(mp);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocNext()\n *\n * FUNCTION:\tattempt to allocate the blocks of the specified block\n *\t\trange within a dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap.\n *\tblkno\t-  starting block number of the range.\n *\tnblocks\t-  number of contiguous free blocks of the range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw;\n\tint l2size;\n\ts8 *leaf;\n\tu32 mask;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* pick up a pointer to the leaves of the dmap tree.\n\t */\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* check if the specified block range is contained within\n\t * this dmap.\n\t */\n\tif (dbitno + nblocks > BPERDMAP)\n\t\treturn -ENOSPC;\n\n\t/* check if the starting leaf indicates that anything\n\t * is free.\n\t */\n\tif (leaf[word] == NOFREE)\n\t\treturn -ENOSPC;\n\n\t/* check the dmaps words corresponding to block range to see\n\t * if the block range is free.  not all bits of the first and\n\t * last words may be contained within the block range.  if this\n\t * is the case, we'll work against those words (i.e. partial first\n\t * and/or last) on an individual basis (a single pass) and examine\n\t * the actual bits to determine if they are free.  a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the leaves of the dmap\n\t * tree will be examined to determine if the blocks are free. a\n\t * single leaf may describe the free space of multiple dmap\n\t * words, so we may visit only a subset of the actual leaves\n\t * corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of the word is to be examined.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* check if the bits are free.\n\t\t\t */\n\t\t\tmask = (ONES << (DBWORD - nb) >> wbitno);\n\t\t\tif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and how many bits.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now examine the appropriate leaves to determine\n\t\t\t * if the blocks are free.\n\t\t\t */\n\t\t\twhile (nwords > 0) {\n\t\t\t\t/* does the leaf describe any free space ?\n\t\t\t\t */\n\t\t\t\tif (leaf[word] < BUDMIN)\n\t\t\t\t\treturn -ENOSPC;\n\n\t\t\t\t/* determine the l2 number of bits provided\n\t\t\t\t * by this leaf.\n\t\t\t\t */\n\t\t\t\tl2size =\n\t\t\t\t    min_t(int, leaf[word], NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* determine how many words were handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(l2size, BUDMIN);\n\n\t\t\t\tnwords -= nw;\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* allocate the blocks.\n\t */\n\treturn (dbAllocDmap(bmp, dp, blkno, nblocks));\n}\n\n\n/*\n * NAME:\tdbAllocNear()\n *\n * FUNCTION:\tattempt to allocate a number of contiguous free blocks near\n *\t\ta specified block (hint) within a dmap.\n *\n *\t\tstarting with the dmap leaf that covers the hint, we'll\n *\t\tcheck the next four contiguous leaves for sufficient free\n *\t\tspace.  if sufficient free space is found, we'll allocate\n *\t\tthe desired free space.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap.\n *\tblkno\t-  block number to allocate near.\n *\tnblocks\t-  actual number of contiguous free blocks desired.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAllocNear(struct bmap * bmp,\n\t    struct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\n{\n\tint word, lword, rc;\n\ts8 *leaf;\n\n\tif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmap page\\n\");\n\t\treturn -EIO;\n\t}\n\n\tleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\n\n\t/* determine the word within the dmap that holds the hint\n\t * (i.e. blkno).  also, determine the last word in the dmap\n\t * that we'll include in our examination.\n\t */\n\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\tlword = min(word + 4, LPERDMAP);\n\n\t/* examine the leaves for sufficient free space.\n\t */\n\tfor (; word < lword; word++) {\n\t\t/* does the leaf describe sufficient free space ?\n\t\t */\n\t\tif (leaf[word] < l2nb)\n\t\t\tcontinue;\n\n\t\t/* determine the block number within the file system\n\t\t * of the first block described by this dmap word.\n\t\t */\n\t\tblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\n\n\t\t/* if not all bits of the dmap word are free, get the\n\t\t * starting bit number within the dmap word of the required\n\t\t * string of free bits and adjust the block number with the\n\t\t * value.\n\t\t */\n\t\tif (leaf[word] < BUDMIN)\n\t\t\tblkno +=\n\t\t\t    dbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t\t*results = blkno;\n\n\t\treturn (rc);\n\t}\n\n\treturn -ENOSPC;\n}\n\n\n/*\n * NAME:\tdbAllocAG()\n *\n * FUNCTION:\tattempt to allocate the specified number of contiguous\n *\t\tfree blocks within the specified allocation group.\n *\n *\t\tunless the allocation group size is equal to the number\n *\t\tof blocks per dmap, the dmap control pages will be used to\n *\t\tfind the required free space, if available.  we start the\n *\t\tsearch at the highest dmap control page level which\n *\t\tdistinctly describes the allocation group's free space\n *\t\t(i.e. the highest level at which the allocation group's\n *\t\tfree space is not mixed in with that of any other group).\n *\t\tin addition, we start the search within this level at a\n *\t\theight of the dmapctl dmtree at which the nodes distinctly\n *\t\tdescribe the allocation group's free space.  at this height,\n *\t\tthe allocation group's free space may be represented by 1\n *\t\tor two sub-trees, depending on the allocation group size.\n *\t\twe search the top nodes of these subtrees left to right for\n *\t\tsufficient free space.  if sufficient free space is found,\n *\t\tthe subtree is searched to find the leftmost leaf that\n *\t\thas free space.  once we have made it to the leaf, we\n *\t\tmove the search to the next lower level dmap control page\n *\t\tcorresponding to this leaf.  we continue down the dmap control\n *\t\tpages until we find the dmap that contains or starts the\n *\t\tsufficient free space and we allocate at this dmap.\n *\n *\t\tif the allocation group size is equal to the dmap size,\n *\t\twe'll start at the dmap corresponding to the allocation\n *\t\tgroup and attempt the allocation at this level.\n *\n *\t\tthe dmap control page search is also not performed if the\n *\t\tallocation group is completely free and we go to the first\n *\t\tdmap of the allocation group to do the allocation.  this is\n *\t\tdone because the allocation group may be part (not the first\n *\t\tpart) of a larger binary buddy system, causing the dmap\n *\t\tcontrol pages to indicate no free space (NOFREE) within\n *\t\tthe allocation group.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tagno\t- allocation group number.\n *\tnblocks\t-  actual number of contiguous free blocks desired.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * note: IWRITE_LOCK(ipmap) held on entry/exit;\n */\nstatic int\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\n{\n\tstruct metapage *mp;\n\tstruct dmapctl *dcp;\n\tint rc, ti, i, k, m, n, agperlev;\n\ts64 blkno, lblkno;\n\tint budmin;\n\n\t/* allocation request should not be for more than the\n\t * allocation group size.\n\t */\n\tif (l2nb > bmp->db_agl2size) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t  \"allocation request is larger than the allocation group size\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* determine the starting block number of the allocation\n\t * group.\n\t */\n\tblkno = (s64) agno << bmp->db_agl2size;\n\n\t/* check if the allocation group size is the minimum allocation\n\t * group size or if the allocation group is completely free. if\n\t * the allocation group size is the minimum size of BPERDMAP (i.e.\n\t * 1 dmap), there is no need to search the dmap control page (below)\n\t * that fully describes the allocation group since the allocation\n\t * group is already fully described by a dmap.  in this case, we\n\t * just call dbAllocCtl() to search the dmap tree and allocate the\n\t * required space if available.\n\t *\n\t * if the allocation group is completely free, dbAllocCtl() is\n\t * also called to allocate the required space.  this is done for\n\t * two reasons.  first, it makes no sense searching the dmap control\n\t * pages for free space when we know that free space exists.  second,\n\t * the dmap control pages may indicate that the allocation group\n\t * has no free space if the allocation group is part (not the first\n\t * part) of a larger binary buddy system.\n\t */\n\tif (bmp->db_agsize == BPERDMAP\n\t    || bmp->db_agfree[agno] == bmp->db_agsize) {\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif ((rc == -ENOSPC) &&\n\t\t    (bmp->db_agfree[agno] == bmp->db_agsize)) {\n\t\t\tprintk(KERN_ERR \"blkno = %Lx, blocks = %Lx\\n\",\n\t\t\t       (unsigned long long) blkno,\n\t\t\t       (unsigned long long) nblocks);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"dbAllocCtl failed in free AG\\n\");\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* the buffer for the dmap control page that fully describes the\n\t * allocation group.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\tbudmin = dcp->budmin;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* search the subtree(s) of the dmap control page that describes\n\t * the allocation group, looking for sufficient free space.  to begin,\n\t * determine how many allocation groups are represented in a dmap\n\t * control page at the control page level (i.e. L0, L1, L2) that\n\t * fully describes an allocation group. next, determine the starting\n\t * tree index of this allocation group within the control page.\n\t */\n\tagperlev =\n\t    (1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\n\tti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\n\n\t/* dmap control page trees fan-out by 4 and a single allocation\n\t * group may be described by 1 or 2 subtrees within the ag level\n\t * dmap control page, depending upon the ag size. examine the ag's\n\t * subtrees for sufficient free space, starting with the leftmost\n\t * subtree.\n\t */\n\tfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\n\t\t/* is there sufficient free space ?\n\t\t */\n\t\tif (l2nb > dcp->stree[ti])\n\t\t\tcontinue;\n\n\t\t/* sufficient free space found in a subtree. now search down\n\t\t * the subtree to find the leftmost leaf that describes this\n\t\t * free space.\n\t\t */\n\t\tfor (k = bmp->db_agheight; k > 0; k--) {\n\t\t\tfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\n\t\t\t\tif (l2nb <= dcp->stree[m + n]) {\n\t\t\t\t\tti = m + n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n == 4) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"failed descending stree\\n\");\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t/* determine the block number within the file system\n\t\t * that corresponds to this leaf.\n\t\t */\n\t\tif (bmp->db_aglevel == 2)\n\t\t\tblkno = 0;\n\t\telse if (bmp->db_aglevel == 1)\n\t\t\tblkno &= ~(MAXL1SIZE - 1);\n\t\telse\t\t/* bmp->db_aglevel == 0 */\n\t\t\tblkno &= ~(MAXL0SIZE - 1);\n\n\t\tblkno +=\n\t\t    ((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\n\n\t\t/* release the buffer in preparation for going down\n\t\t * the next level of dmap control pages.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* check if we need to continue to search down the lower\n\t\t * level dmap control pages.  we need to if the number of\n\t\t * blocks required is less than maximum number of blocks\n\t\t * described at the next lower level.\n\t\t */\n\t\tif (l2nb < budmin) {\n\n\t\t\t/* search the lower level dmap control pages to get\n\t\t\t * the starting block number of the dmap that\n\t\t\t * contains or starts off the free space.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\n\t\t\t\t       &blkno))) {\n\t\t\t\tif (rc == -ENOSPC) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"control page inconsistent\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\t/* allocate the blocks.\n\t\t */\n\t\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\t\tif (rc == -ENOSPC) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"unable to allocate blocks\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\treturn (rc);\n\t}\n\n\t/* no space in the allocation group.  release the buffer and\n\t * return -ENOSPC.\n\t */\n\trelease_metapage(mp);\n\n\treturn -ENOSPC;\n}\n\n\n/*\n * NAME:\tdbAllocAny()\n *\n * FUNCTION:\tattempt to allocate the specified number of contiguous\n *\t\tfree blocks anywhere in the file system.\n *\n *\t\tdbAllocAny() attempts to find the sufficient free space by\n *\t\tsearching down the dmap control pages, starting with the\n *\t\thighest level (i.e. L0, L1, L2) control page.  if free space\n *\t\tlarge enough to satisfy the desired free space is found, the\n *\t\tdesired free space is allocated.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tnblocks\t -  actual number of contiguous free blocks desired.\n *\tl2nb\t -  log2 number of contiguous free blocks desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\n{\n\tint rc;\n\ts64 blkno = 0;\n\n\t/* starting with the top level dmap control page, search\n\t * down the dmap control levels for sufficient free space.\n\t * if free space is found, dbFindCtl() returns the starting\n\t * block number of the dmap that contains or starts off the\n\t * range of free space.\n\t */\n\tif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\n\t\treturn (rc);\n\n\t/* allocate the blocks.\n\t */\n\trc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\n\tif (rc == -ENOSPC) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"unable to allocate blocks\\n\");\n\t\treturn -EIO;\n\t}\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbDiscardAG()\n *\n * FUNCTION:\tattempt to discard (TRIM) all free blocks of specific AG\n *\n *\t\talgorithm:\n *\t\t1) allocate blocks, as large as possible and save them\n *\t\t   while holding IWRITE_LOCK on ipbmap\n *\t\t2) trim all these saved block/length values\n *\t\t3) mark the blocks free again\n *\n *\t\tbenefit:\n *\t\t- we work only on one ag at some time, minimizing how long we\n *\t\t  need to lock ipbmap\n *\t\t- reading / writing the fs is possible most time, even on\n *\t\t  trimming\n *\n *\t\tdownside:\n *\t\t- we write two times to the dmapctl and dmap pages\n *\t\t- but for me, this seems the best way, better ideas?\n *\t\t/TR 2012\n *\n * PARAMETERS:\n *\tip\t- pointer to in-core inode\n *\tagno\t- ag to trim\n *\tminlen\t- minimum value of contiguous blocks\n *\n * RETURN VALUES:\n *\ts64\t- actual number of blocks trimmed\n */\ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc_array(range_cnt, sizeof(struct range2trim), GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tnblocks = 1LL << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}\n\n/*\n * NAME:\tdbFindCtl()\n *\n * FUNCTION:\tstarting at a specified dmap control page level and block\n *\t\tnumber, search down the dmap control levels for a range of\n *\t\tcontiguous free blocks large enough to satisfy an allocation\n *\t\trequest for the specified number of free blocks.\n *\n *\t\tif sufficient contiguous free blocks are found, this routine\n *\t\treturns the starting block number within a dmap page that\n *\t\tcontains or starts a range of contiqious free blocks that\n *\t\tis sufficient in size.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tlevel\t-  starting dmap control page level.\n *\tl2nb\t-  log2 number of contiguous free blocks desired.\n *\t*blkno\t-  on entry, starting block number for conducting the search.\n *\t\t   on successful return, the first block within a dmap page\n *\t\t   that contains or starts a range of contiguous free blocks.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\n{\n\tint rc, leafidx, lev;\n\ts64 b, lblkno;\n\tstruct dmapctl *dcp;\n\tint budmin;\n\tstruct metapage *mp;\n\n\t/* starting at the specified dmap control page level and block\n\t * number, search down the dmap control levels for the starting\n\t * block number of a dmap page that contains or starts off\n\t * sufficient free blocks.\n\t */\n\tfor (lev = level, b = *blkno; lev >= 0; lev--) {\n\t\t/* get the buffer of the dmap control page for the block\n\t\t * number and level (i.e. L0, L1, L2).\n\t\t */\n\t\tlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdcp = (struct dmapctl *) mp->data;\n\t\tbudmin = dcp->budmin;\n\n\t\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"Corrupt dmapctl page\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* search the tree within the dmap control page for\n\t\t * sufficient free space.  if sufficient free space is found,\n\t\t * dbFindLeaf() returns the index of the leaf at which\n\t\t * free space was found.\n\t\t */\n\t\trc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\n\n\t\t/* release the buffer.\n\t\t */\n\t\trelease_metapage(mp);\n\n\t\t/* space found ?\n\t\t */\n\t\tif (rc) {\n\t\t\tif (lev != level) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"dmap inconsistent\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t/* adjust the block number to reflect the location within\n\t\t * the dmap control page (i.e. the leaf) at which free\n\t\t * space was found.\n\t\t */\n\t\tb += (((s64) leafidx) << budmin);\n\n\t\t/* we stop the search at this dmap control page level if\n\t\t * the number of blocks required is greater than or equal\n\t\t * to the maximum number of blocks described at the next\n\t\t * (lower) level.\n\t\t */\n\t\tif (l2nb >= budmin)\n\t\t\tbreak;\n\t}\n\n\t*blkno = b;\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbAllocCtl()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous\n *\t\tblocks starting within a specific dmap.\n *\n *\t\tthis routine is called by higher level routines that search\n *\t\tthe dmap control pages above the actual dmaps for contiguous\n *\t\tfree space.  the result of successful searches by these\n *\t\troutines are the starting block numbers within dmaps, with\n *\t\tthe dmaps themselves containing the desired contiguous free\n *\t\tspace or starting a contiguous free space of desired size\n *\t\tthat is made up of the blocks of one or more dmaps. these\n *\t\tcalls should not fail due to insufficent resources.\n *\n *\t\tthis routine is called in some cases where it is not known\n *\t\twhether it will fail due to insufficient resources.  more\n *\t\tspecifically, this occurs when allocating from an allocation\n *\t\tgroup whose size is equal to the number of blocks per dmap.\n *\t\tin this case, the dmap control pages are not examined prior\n *\t\tto calling this routine (to save pathlength) and the call\n *\t\tmight fail.\n *\n *\t\tfor a request size that fits within a dmap, this routine relies\n *\t\tupon the dmap's dmtree to find the requested contiguous free\n *\t\tspace.  for request sizes that are larger than a dmap, the\n *\t\trequested free space will start at the first block of the\n *\t\tfirst dmap (i.e. blkno).\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tnblocks\t -  actual number of contiguous free blocks to allocate.\n *\tl2nb\t -  log2 number of contiguous free blocks to allocate.\n *\tblkno\t -  starting block number of the dmap to start the allocation\n *\t\t    from.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\n{\n\tint rc, nb;\n\ts64 b, lblkno, n;\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\n\t/* check if the allocation request is confined to a single dmap.\n\t */\n\tif (l2nb <= L2BPERDMAP) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL)\n\t\t\treturn -EIO;\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* try to allocate the blocks.\n\t\t */\n\t\trc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\n\t\tif (rc == 0)\n\t\t\tmark_metapage_dirty(mp);\n\n\t\trelease_metapage(mp);\n\n\t\treturn (rc);\n\t}\n\n\t/* allocation request involving multiple dmaps. it must start on\n\t * a dmap boundary.\n\t */\n\tassert((blkno & (BPERDMAP - 1)) == 0);\n\n\t/* allocate the blocks dmap by dmap.\n\t */\n\tfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\n\t\t/* get the buffer for the dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* the dmap better be all free.\n\t\t */\n\t\tif (dp->tree.stree[ROOT] != L2BPERDMAP) {\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"the dmap is not all free\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* determine how many blocks to allocate from this dmap.\n\t\t */\n\t\tnb = min_t(s64, n, BPERDMAP);\n\n\t\t/* allocate the blocks from the dmap.\n\t\t */\n\t\tif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tgoto backout;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\t/* set the results (starting block number) and return.\n\t */\n\t*results = blkno;\n\treturn (0);\n\n\t/* something failed in handling an allocation request involving\n\t * multiple dmaps.  we'll try to clean up by backing out any\n\t * allocation that has already happened for this request.  if\n\t * we fail in backing out the allocation, we'll mark the file\n\t * system to indicate that blocks have been leaked.\n\t */\n      backout:\n\n\t/* try to backout the allocations dmap by dmap.\n\t */\n\tfor (n = nblocks - n, b = blkno; n > 0;\n\t     n -= BPERDMAP, b += BPERDMAP) {\n\t\t/* get the buffer for this dmap.\n\t\t */\n\t\tlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t  \"I/O Error: Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* free the blocks is this dmap.\n\t\t */\n\t\tif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\n\t\t\t/* could not back out.  mark the file system\n\t\t\t * to indicate that we have leaked blocks.\n\t\t\t */\n\t\t\trelease_metapage(mp);\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Block Leakage\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* write the buffer.\n\t\t */\n\t\twrite_metapage(mp);\n\t}\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocDmapLev()\n *\n * FUNCTION:\tattempt to allocate a specified number of contiguous blocks\n *\t\tfrom a specified dmap.\n *\n *\t\tthis routine checks if the contiguous blocks are available.\n *\t\tif so, nblocks of blocks are allocated; otherwise, ENOSPC is\n *\t\treturned.\n *\n * PARAMETERS:\n *\tmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to attempt to allocate blocks from.\n *\tl2nb\t-  log2 number of contiguous block desired.\n *\tnblocks\t-  actual number of contiguous block desired.\n *\tresults\t-  on successful return, set to the starting block number\n *\t\t   of the newly allocated range.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient disk resources\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap), e.g., from dbAlloc(), or\n *\tIWRITE_LOCK(ipbmap), e.g., dbAllocCtl(), held on entry/exit;\n */\nstatic int\ndbAllocDmapLev(struct bmap * bmp,\n\t       struct dmap * dp, int nblocks, int l2nb, s64 * results)\n{\n\ts64 blkno;\n\tint leafidx, rc;\n\n\t/* can't be more than a dmaps worth of blocks */\n\tassert(l2nb <= L2BPERDMAP);\n\n\t/* search the tree within the dmap page for sufficient\n\t * free space.  if sufficient free space is found, dbFindLeaf()\n\t * returns the index of the leaf at which free space was found.\n\t */\n\tif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\n\t\treturn -ENOSPC;\n\n\t/* determine the block number within the file system corresponding\n\t * to the leaf at which free space was found.\n\t */\n\tblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\n\n\t/* if not all bits of the dmap word are free, get the starting\n\t * bit number within the dmap word of the required string of free\n\t * bits and adjust the block number with this value.\n\t */\n\tif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\n\t\tblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\n\n\t/* allocate the blocks */\n\tif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\n\t\t*results = blkno;\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocDmap()\n *\n * FUNCTION:\tadjust the disk allocation map to reflect the allocation\n *\t\tof a specified block range within a dmap.\n *\n *\t\tthis routine allocates the specified blocks from the dmap\n *\t\tthrough a call to dbAllocBits(). if the allocation of the\n *\t\tblock range causes the maximum string of free blocks within\n *\t\tthe dmap to change (i.e. the value of the root of the dmap's\n *\t\tdmtree), this routine will cause this change to be reflected\n *\t\tup through the appropriate levels of the dmap control pages\n *\t\tby a call to dbAdjCtl() for the L0 dmap control page that\n *\t\tcovers this dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to allocate the block range from.\n *\tblkno\t-  starting block number of the block to be allocated.\n *\tnblocks\t-  number of blocks to be allocated.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\ts8 oldroot;\n\tint rc;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* allocate the specified (blocks) bits */\n\tdbAllocBits(bmp, dp, blkno, nblocks);\n\n\t/* if the root has not changed, done. */\n\tif (dp->tree.stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbFreeDmap()\n *\n * FUNCTION:\tadjust the disk allocation map to reflect the allocation\n *\t\tof a specified block range within a dmap.\n *\n *\t\tthis routine frees the specified blocks from the dmap through\n *\t\ta call to dbFreeBits(). if the deallocation of the block range\n *\t\tcauses the maximum string of free blocks within the dmap to\n *\t\tchange (i.e. the value of the root of the dmap's dmtree), this\n *\t\troutine will cause this change to be reflected up through the\n *\t\tappropriate levels of the dmap control pages by a call to\n *\t\tdbAdjCtl() for the L0 dmap control page that covers this dmap.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to free the block range from.\n *\tblkno\t-  starting block number of the block to be freed.\n *\tnblocks\t-  number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks)\n{\n\ts8 oldroot;\n\tint rc = 0, word;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = dp->tree.stree[ROOT];\n\n\t/* free the specified (blocks) bits */\n\trc = dbFreeBits(bmp, dp, blkno, nblocks);\n\n\t/* if error or the root has not changed, done. */\n\tif (rc || (dp->tree.stree[ROOT] == oldroot))\n\t\treturn (rc);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the deallocation.\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\n\t\tword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\n\n\t\t/* as part of backing out the deallocation, we will have\n\t\t * to back split the dmap tree if the deallocation caused\n\t\t * the freed blocks to become part of a larger binary buddy\n\t\t * system.\n\t\t */\n\t\tif (dp->tree.stree[word] == NOFREE)\n\t\t\tdbBackSplit((dmtree_t *) & dp->tree, word);\n\n\t\tdbAllocBits(bmp, dp, blkno, nblocks);\n\t}\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbAllocBits()\n *\n * FUNCTION:\tallocate a specified block range from a dmap.\n *\n *\t\tthis routine updates the dmap to reflect the working\n *\t\tstate allocation of the specified block range. it directly\n *\t\tupdates the bits of the working map and causes the adjustment\n *\t\tof the binary buddy system described by the dmap's dmtree\n *\t\tleaves to reflect the bits allocated.  it also causes the\n *\t\tdmap's dmtree, as a whole, to reflect the allocated range.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to allocate bits from.\n *\tblkno\t-  starting block number of the bits to be allocated.\n *\tnblocks\t-  number of bits to be allocated.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint size;\n\ts8 *leaf;\n\n\t/* pick up a pointer to the leaves of the dmap tree */\n\tleaf = dp->tree.stree + LEAFIND;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\t/* update the leaf for this dmap word. in addition\n\t\t\t * to setting the leaf value to the binary buddy max\n\t\t\t * of the updated dmap word, dbSplit() will split\n\t\t\t * the binary system of the leaves if need be.\n\t\t\t */\n\t\t\tdbSplit(tp, word, BUDMIN,\n\t\t\t\tdbMaxBud((u8 *) & dp->wmap[word]));\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the allocated words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\tif (leaf[word] < BUDMIN) {\n\t\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t\t  \"leaf page corrupt\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being allocated and the l2 number\n\t\t\t\t * of bits currently described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize = min_t(int, leaf[word],\n\t\t\t\t\t     NLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf to reflect the allocation.\n\t\t\t\t * in addition to setting the leaf value to\n\t\t\t\t * NOFREE, dbSplit() will split the binary\n\t\t\t\t * system of the leaves to reflect the current\n\t\t\t\t * allocation (size).\n\t\t\t\t */\n\t\t\t\tdbSplit(tp, word, size, NOFREE);\n\n\t\t\t\t/* get the number of dmap words handled */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the maximum allocation group number if this allocation\n\t * group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n}\n\n\n/*\n * NAME:\tdbFreeBits()\n *\n * FUNCTION:\tfree a specified block range from a dmap.\n *\n *\t\tthis routine updates the dmap to reflect the working\n *\t\tstate allocation of the specified block range. it directly\n *\t\tupdates the bits of the working map and causes the adjustment\n *\t\tof the binary buddy system described by the dmap's dmtree\n *\t\tleaves to reflect the bits freed.  it also causes the dmap's\n *\t\tdmtree, as a whole, to reflect the deallocated range.\n *\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tdp\t-  pointer to dmap to free bits from.\n *\tblkno\t-  starting block number of the bits to be freed.\n *\tnblocks\t-  number of bits to be freed.\n *\n * RETURN VALUES: 0 for success\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks)\n{\n\tint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\n\tdmtree_t *tp = (dmtree_t *) & dp->tree;\n\tint rc = 0;\n\tint size;\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap.\n\t */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* free the bits of the dmaps words corresponding to the block range.\n\t * not all bits of the first and last words may be contained within\n\t * the block range.  if this is the case, we'll work against those\n\t * words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), freeing the bits of interest by hand and updating\n\t * the leaf corresponding to the dmap word. a single pass will be used\n\t * for all dmap words fully contained within the specified range.\n\t * within this pass, the bits of all fully contained dmap words will\n\t * be marked as free in a single shot and the leaves will be updated. a\n\t * single leaf may describe the free space of multiple dmap words,\n\t * so we may update only a subset of the actual leaves corresponding\n\t * to the dmap words of the block range.\n\t *\n\t * dbJoin() is used to update leaf values and will join the binary\n\t * buddy system of the leaves if the new leaf values indicate this\n\t * should be done.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be freed.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (zero) the appropriate bits within this\n\t\t\t * dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] &=\n\t\t\t    cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t  >> wbitno));\n\n\t\t\t/* update the leaf for this dmap word.\n\t\t\t */\n\t\t\trc = dbJoin(tp, word,\n\t\t\t\t    dbMaxBud((u8 *) & dp->wmap[word]));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tword += 1;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and free (zero) the bits of these words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], 0, nwords * 4);\n\n\t\t\t/* determine how many bits.\n\t\t\t */\n\t\t\tnb = nwords << L2DBWORD;\n\n\t\t\t/* now update the appropriate leaves to reflect\n\t\t\t * the freed words.\n\t\t\t */\n\t\t\tfor (; nwords > 0; nwords -= nw) {\n\t\t\t\t/* determine what the leaf value should be\n\t\t\t\t * updated to as the minimum of the l2 number\n\t\t\t\t * of bits being freed and the l2 (max) number\n\t\t\t\t * of bits that can be described by this leaf.\n\t\t\t\t */\n\t\t\t\tsize =\n\t\t\t\t    min(LITOL2BSZ\n\t\t\t\t\t(word, L2LPERDMAP, BUDMIN),\n\t\t\t\t\tNLSTOL2BSZ(nwords));\n\n\t\t\t\t/* update the leaf.\n\t\t\t\t */\n\t\t\t\trc = dbJoin(tp, word, size);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t/* get the number of dmap words handled.\n\t\t\t\t */\n\t\t\t\tnw = BUDSIZE(size, BUDMIN);\n\t\t\t\tword += nw;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update the free count for this dmap.\n\t */\n\tle32_add_cpu(&dp->nfree, nblocks);\n\n\tBMAP_LOCK(bmp);\n\n\t/* update the free count for the allocation group and\n\t * map.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tbmp->db_nfree += nblocks;\n\tbmp->db_agfree[agno] += nblocks;\n\n\t/* check if this allocation group is not completely free and\n\t * if it is currently the maximum (rightmost) allocation group.\n\t * if so, establish the new maximum allocation group number by\n\t * searching left for the first allocation group with allocation.\n\t */\n\tif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\n\t    (agno == bmp->db_numag - 1 &&\n\t     bmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\n\t\twhile (bmp->db_maxag > 0) {\n\t\t\tbmp->db_maxag -= 1;\n\t\t\tif (bmp->db_agfree[bmp->db_maxag] !=\n\t\t\t    bmp->db_agsize)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* re-establish the allocation group preference if the\n\t\t * current preference is right of the maximum allocation\n\t\t * group.\n\t\t */\n\t\tif (bmp->db_agpref > bmp->db_maxag)\n\t\t\tbmp->db_agpref = bmp->db_maxag;\n\t}\n\n\tBMAP_UNLOCK(bmp);\n\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbAdjCtl()\n *\n * FUNCTION:\tadjust a dmap control page at a specified level to reflect\n *\t\tthe change in a lower level dmap or dmap control page's\n *\t\tmaximum string of free blocks (i.e. a change in the root\n *\t\tof the lower level object's dmtree) due to the allocation\n *\t\tor deallocation of a range of blocks with a single dmap.\n *\n *\t\ton entry, this routine is provided with the new value of\n *\t\tthe lower level dmap or dmap control page root and the\n *\t\tstarting block number of the block range whose allocation\n *\t\tor deallocation resulted in the root change.  this range\n *\t\tis respresented by a single leaf of the current dmapctl\n *\t\tand the leaf will be updated with this value, possibly\n *\t\tcausing a binary buddy system within the leaves to be\n *\t\tsplit or joined.  the update may also cause the dmapctl's\n *\t\tdmtree to be updated.\n *\n *\t\tif the adjustment of the dmap control page, itself, causes its\n *\t\troot to change, this change will be bubbled up to the next dmap\n *\t\tcontrol level by a recursive call to this routine, specifying\n *\t\tthe new root value and the next dmap control page level to\n *\t\tbe adjusted.\n * PARAMETERS:\n *\tbmp\t-  pointer to bmap descriptor\n *\tblkno\t-  the first block of a block range within a dmap.  it is\n *\t\t   the allocation or deallocation of this block range that\n *\t\t   requires the dmap control page to be adjusted.\n *\tnewval\t-  the new value of the lower level dmap or dmap control\n *\t\t   page root.\n *\talloc\t-  'true' if adjustment is due to an allocation.\n *\tlevel\t-  current level of dmap control page (i.e. L0, L1, L2) to\n *\t\t   be adjusted.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\n{\n\tstruct metapage *mp;\n\ts8 oldroot;\n\tint oldval;\n\ts64 lblkno;\n\tstruct dmapctl *dcp;\n\tint rc, leafno, ti;\n\n\t/* get the buffer for the dmap control page for the specified\n\t * block number and control page level.\n\t */\n\tlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\n\tmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\n\tif (mp == NULL)\n\t\treturn -EIO;\n\tdcp = (struct dmapctl *) mp->data;\n\n\tif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"Corrupt dmapctl page\\n\");\n\t\trelease_metapage(mp);\n\t\treturn -EIO;\n\t}\n\n\t/* determine the leaf number corresponding to the block and\n\t * the index within the dmap control tree.\n\t */\n\tleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\n\tti = leafno + le32_to_cpu(dcp->leafidx);\n\n\t/* save the current leaf value and the current root level (i.e.\n\t * maximum l2 free string described by this dmapctl).\n\t */\n\toldval = dcp->stree[ti];\n\toldroot = dcp->stree[ROOT];\n\n\t/* check if this is a control page update for an allocation.\n\t * if so, update the leaf to reflect the new leaf value using\n\t * dbSplit(); otherwise (deallocation), use dbJoin() to update\n\t * the leaf with the new value.  in addition to updating the\n\t * leaf, dbSplit() will also split the binary buddy system of\n\t * the leaves, if required, and bubble new values within the\n\t * dmapctl tree, if required.  similarly, dbJoin() will join\n\t * the binary buddy system of leaves and bubble new values up\n\t * the dmapctl tree as required by the new leaf value.\n\t */\n\tif (alloc) {\n\t\t/* check if we are in the middle of a binary buddy\n\t\t * system.  this happens when we are performing the\n\t\t * first allocation out of an allocation group that\n\t\t * is part (not the first part) of a larger binary\n\t\t * buddy system.  if we are in the middle, back split\n\t\t * the system prior to calling dbSplit() which assumes\n\t\t * that it is at the front of a binary buddy system.\n\t\t */\n\t\tif (oldval == NOFREE) {\n\t\t\trc = dbBackSplit((dmtree_t *) dcp, leafno);\n\t\t\tif (rc) {\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\toldval = dcp->stree[ti];\n\t\t}\n\t\tdbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\n\t} else {\n\t\trc = dbJoin((dmtree_t *) dcp, leafno, newval);\n\t\tif (rc) {\n\t\t\trelease_metapage(mp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* check if the root of the current dmap control page changed due\n\t * to the update and if the current dmap control page is not at\n\t * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.\n\t * root changed and this is not the top level), call this routine\n\t * again (recursion) for the next higher level of the mapping to\n\t * reflect the change in root for the current dmap control page.\n\t */\n\tif (dcp->stree[ROOT] != oldroot) {\n\t\t/* are we below the top level of the map.  if so,\n\t\t * bubble the root up to the next higher level.\n\t\t */\n\t\tif (level < bmp->db_maxlevel) {\n\t\t\t/* bubble up the new root of this dmap control page to\n\t\t\t * the next level.\n\t\t\t */\n\t\t\tif ((rc =\n\t\t\t     dbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\n\t\t\t\t      level + 1))) {\n\t\t\t\t/* something went wrong in bubbling up the new\n\t\t\t\t * root value, so backout the changes to the\n\t\t\t\t * current dmap control page.\n\t\t\t\t */\n\t\t\t\tif (alloc) {\n\t\t\t\t\tdbJoin((dmtree_t *) dcp, leafno,\n\t\t\t\t\t       oldval);\n\t\t\t\t} else {\n\t\t\t\t\t/* the dbJoin() above might have\n\t\t\t\t\t * caused a larger binary buddy system\n\t\t\t\t\t * to form and we may now be in the\n\t\t\t\t\t * middle of it.  if this is the case,\n\t\t\t\t\t * back split the buddies.\n\t\t\t\t\t */\n\t\t\t\t\tif (dcp->stree[ti] == NOFREE)\n\t\t\t\t\t\tdbBackSplit((dmtree_t *)\n\t\t\t\t\t\t\t    dcp, leafno);\n\t\t\t\t\tdbSplit((dmtree_t *) dcp, leafno,\n\t\t\t\t\t\tdcp->budmin, oldval);\n\t\t\t\t}\n\n\t\t\t\t/* release the buffer and return the error.\n\t\t\t\t */\n\t\t\t\trelease_metapage(mp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t} else {\n\t\t\t/* we're at the top level of the map. update\n\t\t\t * the bmap control page to reflect the size\n\t\t\t * of the maximum free buddy system.\n\t\t\t */\n\t\t\tassert(level == bmp->db_maxlevel);\n\t\t\tif (bmp->db_maxfreebud != oldroot) {\n\t\t\t\tjfs_error(bmp->db_ipbmap->i_sb,\n\t\t\t\t\t  \"the maximum free buddy is not the old root\\n\");\n\t\t\t}\n\t\t\tbmp->db_maxfreebud = dcp->stree[ROOT];\n\t\t}\n\t}\n\n\t/* write the buffer.\n\t */\n\twrite_metapage(mp);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbSplit()\n *\n * FUNCTION:\tupdate the leaf of a dmtree with a new value, splitting\n *\t\tthe leaf from the binary buddy system of the dmtree's\n *\t\tleaves, as required.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\tsplitsz\t- the size the binary buddy system starting at the leaf\n *\t\t  must be split to, specified as the log2 number of blocks.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\n{\n\tint budsz;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* check if the leaf needs to be split.\n\t */\n\tif (leaf[leafno] > tp->dmt_budmin) {\n\t\t/* the split occurs by cutting the buddy system in half\n\t\t * at the specified leaf until we reach the specified\n\t\t * size.  pick up the starting split size (current size\n\t\t * - 1 in l2) and the corresponding buddy size.\n\t\t */\n\t\tcursz = leaf[leafno] - 1;\n\t\tbudsz = BUDSIZE(cursz, tp->dmt_budmin);\n\n\t\t/* split until we reach the specified size.\n\t\t */\n\t\twhile (cursz >= splitsz) {\n\t\t\t/* update the buddy's leaf with its new value.\n\t\t\t */\n\t\t\tdbAdjTree(tp, leafno ^ budsz, cursz);\n\n\t\t\t/* on to the next size and buddy.\n\t\t\t */\n\t\t\tcursz -= 1;\n\t\t\tbudsz >>= 1;\n\t\t}\n\t}\n\n\t/* adjust the dmap tree to reflect the specified leaf's new\n\t * value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n}\n\n\n/*\n * NAME:\tdbBackSplit()\n *\n * FUNCTION:\tback split the binary buddy system of dmtree leaves\n *\t\tthat hold a specified leaf until the specified leaf\n *\t\tstarts its own binary buddy system.\n *\n *\t\tthe allocators typically perform allocations at the start\n *\t\tof binary buddy systems and dbSplit() is used to accomplish\n *\t\tany required splits.  in some cases, however, allocation\n *\t\tmay occur in the middle of a binary system and requires a\n *\t\tback split, with the split proceeding out from the middle of\n *\t\tthe system (less efficient) rather than the start of the\n *\t\tsystem (more efficient).  the cases in which a back split\n *\t\tis required are rare and are limited to the first allocation\n *\t\twithin an allocation group which is a part (not first part)\n *\t\tof a larger binary buddy system and a few exception cases\n *\t\tin which a previous join operation must be backed out.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\n * RETURN VALUES: none\n *\n * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;\n */\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\n{\n\tint budsz, bud, w, bsz, size;\n\tint cursz;\n\ts8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* leaf should be part (not first part) of a binary\n\t * buddy system.\n\t */\n\tassert(leaf[leafno] == NOFREE);\n\n\t/* the back split is accomplished by iteratively finding the leaf\n\t * that starts the buddy system that contains the specified leaf and\n\t * splitting that system in two.  this iteration continues until\n\t * the specified leaf becomes the start of a buddy system.\n\t *\n\t * determine maximum possible l2 size for the specified leaf.\n\t */\n\tsize =\n\t    LITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\n\t\t      tp->dmt_budmin);\n\n\t/* determine the number of leaves covered by this size.  this\n\t * is the buddy size that we will start with as we search for\n\t * the buddy system that contains the specified leaf.\n\t */\n\tbudsz = BUDSIZE(size, tp->dmt_budmin);\n\n\t/* back split.\n\t */\n\twhile (leaf[leafno] == NOFREE) {\n\t\t/* find the leftmost buddy leaf.\n\t\t */\n\t\tfor (w = leafno, bsz = budsz;; bsz <<= 1,\n\t\t     w = (w < bud) ? w : bud) {\n\t\t\tif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t\tjfs_err(\"JFS: block map error in dbBackSplit\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t/* determine the buddy.\n\t\t\t */\n\t\t\tbud = w ^ bsz;\n\n\t\t\t/* check if this buddy is the start of the system.\n\t\t\t */\n\t\t\tif (leaf[bud] != NOFREE) {\n\t\t\t\t/* split the leaf at the start of the\n\t\t\t\t * system in two.\n\t\t\t\t */\n\t\t\t\tcursz = leaf[bud] - 1;\n\t\t\t\tdbSplit(tp, bud, cursz, cursz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (leaf[leafno] != size) {\n\t\tjfs_err(\"JFS: wrong leaf value in dbBackSplit\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbJoin()\n *\n * FUNCTION:\tupdate the leaf of a dmtree with a new value, joining\n *\t\tthe leaf with other leaves of the dmtree into a multi-leaf\n *\t\tbinary buddy system, as required.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree containing the leaf.\n *\tleafno\t- the number of the leaf to be updated.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n */\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\n{\n\tint budsz, buddy;\n\ts8 *leaf;\n\n\t/* can the new leaf value require a join with other leaves ?\n\t */\n\tif (newval >= tp->dmt_budmin) {\n\t\t/* pickup a pointer to the leaves of the tree.\n\t\t */\n\t\tleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\n\n\t\t/* try to join the specified leaf into a large binary\n\t\t * buddy system.  the join proceeds by attempting to join\n\t\t * the specified leafno with its buddy (leaf) at new value.\n\t\t * if the join occurs, we attempt to join the left leaf\n\t\t * of the joined buddies with its buddy at new value + 1.\n\t\t * we continue to join until we find a buddy that cannot be\n\t\t * joined (does not have a value equal to the size of the\n\t\t * last join) or until all leaves have been joined into a\n\t\t * single system.\n\t\t *\n\t\t * get the buddy size (number of words covered) of\n\t\t * the new value.\n\t\t */\n\t\tbudsz = BUDSIZE(newval, tp->dmt_budmin);\n\n\t\t/* try to join.\n\t\t */\n\t\twhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\n\t\t\t/* get the buddy leaf.\n\t\t\t */\n\t\t\tbuddy = leafno ^ budsz;\n\n\t\t\t/* if the leaf's new value is greater than its\n\t\t\t * buddy's value, we join no more.\n\t\t\t */\n\t\t\tif (newval > leaf[buddy])\n\t\t\t\tbreak;\n\n\t\t\t/* It shouldn't be less */\n\t\t\tif (newval < leaf[buddy])\n\t\t\t\treturn -EIO;\n\n\t\t\t/* check which (leafno or buddy) is the left buddy.\n\t\t\t * the left buddy gets to claim the blocks resulting\n\t\t\t * from the join while the right gets to claim none.\n\t\t\t * the left buddy is also eligible to participate in\n\t\t\t * a join at the next higher level while the right\n\t\t\t * is not.\n\t\t\t *\n\t\t\t */\n\t\t\tif (leafno < buddy) {\n\t\t\t\t/* leafno is the left buddy.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, buddy, NOFREE);\n\t\t\t} else {\n\t\t\t\t/* buddy is the left buddy and becomes\n\t\t\t\t * leafno.\n\t\t\t\t */\n\t\t\t\tdbAdjTree(tp, leafno, NOFREE);\n\t\t\t\tleafno = buddy;\n\t\t\t}\n\n\t\t\t/* on to try the next join.\n\t\t\t */\n\t\t\tnewval += 1;\n\t\t\tbudsz <<= 1;\n\t\t}\n\t}\n\n\t/* update the leaf value.\n\t */\n\tdbAdjTree(tp, leafno, newval);\n\n\treturn 0;\n}\n\n\n/*\n * NAME:\tdbAdjTree()\n *\n * FUNCTION:\tupdate a leaf of a dmtree with a new value, adjusting\n *\t\tthe dmtree, as required, to reflect the new leaf value.\n *\t\tthe combination of any buddies must already be done before\n *\t\tthis is called.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree to be adjusted.\n *\tleafno\t- the number of the leaf to be updated.\n *\tnewval\t- the new value for the leaf.\n *\n * RETURN VALUES: none\n */\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\n{\n\tint lp, pp, k;\n\tint max;\n\n\t/* pick up the index of the leaf for this leafno.\n\t */\n\tlp = leafno + le32_to_cpu(tp->dmt_leafidx);\n\n\t/* is the current value the same as the old value ?  if so,\n\t * there is nothing to do.\n\t */\n\tif (tp->dmt_stree[lp] == newval)\n\t\treturn;\n\n\t/* set the new value.\n\t */\n\ttp->dmt_stree[lp] = newval;\n\n\t/* bubble the new value up the tree as required.\n\t */\n\tfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\n\t\t/* get the index of the first leaf of the 4 leaf\n\t\t * group containing the specified leaf (leafno).\n\t\t */\n\t\tlp = ((lp - 1) & ~0x03) + 1;\n\n\t\t/* get the index of the parent of this 4 leaf group.\n\t\t */\n\t\tpp = (lp - 1) >> 2;\n\n\t\t/* determine the maximum of the 4 leaves.\n\t\t */\n\t\tmax = TREEMAX(&tp->dmt_stree[lp]);\n\n\t\t/* if the maximum of the 4 is the same as the\n\t\t * parent's value, we're done.\n\t\t */\n\t\tif (tp->dmt_stree[pp] == max)\n\t\t\tbreak;\n\n\t\t/* parent gets new value.\n\t\t */\n\t\ttp->dmt_stree[pp] = max;\n\n\t\t/* parent becomes leaf for next go-round.\n\t\t */\n\t\tlp = pp;\n\t}\n}\n\n\n/*\n * NAME:\tdbFindLeaf()\n *\n * FUNCTION:\tsearch a dmtree_t for sufficient free blocks, returning\n *\t\tthe index of a leaf describing the free blocks if\n *\t\tsufficient free blocks are found.\n *\n *\t\tthe search starts at the top of the dmtree_t tree and\n *\t\tproceeds down the tree to the leftmost leaf with sufficient\n *\t\tfree space.\n *\n * PARAMETERS:\n *\ttp\t- pointer to the tree to be searched.\n *\tl2nb\t- log2 number of free blocks to search for.\n *\tleafidx\t- return pointer to be set to the index of the leaf\n *\t\t  describing at least l2nb free blocks if sufficient\n *\t\t  free blocks are found.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-ENOSPC\t- insufficient free blocks.\n */\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\n{\n\tint ti, n = 0, k, x = 0;\n\n\t/* first check the root of the tree to see if there is\n\t * sufficient free space.\n\t */\n\tif (l2nb > tp->dmt_stree[ROOT])\n\t\treturn -ENOSPC;\n\n\t/* sufficient free space available. now search down the tree\n\t * starting at the next level for the leftmost leaf that\n\t * describes sufficient free space.\n\t */\n\tfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\n\t     k > 0; k--, ti = ((ti + n) << 2) + 1) {\n\t\t/* search the four nodes at this level, starting from\n\t\t * the left.\n\t\t */\n\t\tfor (x = ti, n = 0; n < 4; n++) {\n\t\t\t/* sufficient free space found.  move to the next\n\t\t\t * level (or quit if this is the last level).\n\t\t\t */\n\t\t\tif (l2nb <= tp->dmt_stree[x + n])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* better have found something since the higher\n\t\t * levels of the tree said it was here.\n\t\t */\n\t\tassert(n < 4);\n\t}\n\n\t/* set the return to the leftmost leaf describing sufficient\n\t * free space.\n\t */\n\t*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\n\n\treturn (0);\n}\n\n\n/*\n * NAME:\tdbFindBits()\n *\n * FUNCTION:\tfind a specified number of binary buddy free bits within a\n *\t\tdmap bitmap word value.\n *\n *\t\tthis routine searches the bitmap value for (1 << l2nb) free\n *\t\tbits at (1 << l2nb) alignments within the value.\n *\n * PARAMETERS:\n *\tword\t-  dmap bitmap word value.\n *\tl2nb\t-  number of free bits specified as a log2 number.\n *\n * RETURN VALUES:\n *\tstarting bit number of free bits.\n */\nstatic int dbFindBits(u32 word, int l2nb)\n{\n\tint bitno, nb;\n\tu32 mask;\n\n\t/* get the number of bits.\n\t */\n\tnb = 1 << l2nb;\n\tassert(nb <= DBWORD);\n\n\t/* complement the word so we can use a mask (i.e. 0s represent\n\t * free bits) and compute the mask.\n\t */\n\tword = ~word;\n\tmask = ONES << (DBWORD - nb);\n\n\t/* scan the word for nb free bits at nb alignments.\n\t */\n\tfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\n\t\tif ((mask & word) == mask)\n\t\t\tbreak;\n\t}\n\n\tASSERT(bitno < 32);\n\n\t/* return the bit number.\n\t */\n\treturn (bitno);\n}\n\n\n/*\n * NAME:\tdbMaxBud(u8 *cp)\n *\n * FUNCTION:\tdetermine the largest binary buddy string of free\n *\t\tbits within 32-bits of the map.\n *\n * PARAMETERS:\n *\tcp\t-  pointer to the 32-bit value.\n *\n * RETURN VALUES:\n *\tlargest binary buddy of free bits within a dmap word.\n */\nstatic int dbMaxBud(u8 * cp)\n{\n\tsigned char tmp1, tmp2;\n\n\t/* check if the wmap word is all free. if so, the\n\t * free buddy size is BUDMIN.\n\t */\n\tif (*((uint *) cp) == 0)\n\t\treturn (BUDMIN);\n\n\t/* check if the wmap word is half free. if so, the\n\t * free buddy size is BUDMIN-1.\n\t */\n\tif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\n\t\treturn (BUDMIN - 1);\n\n\t/* not all free or half free. determine the free buddy\n\t * size thru table lookup using quarters of the wmap word.\n\t */\n\ttmp1 = max(budtab[cp[2]], budtab[cp[3]]);\n\ttmp2 = max(budtab[cp[0]], budtab[cp[1]]);\n\treturn (max(tmp1, tmp2));\n}\n\n\n/*\n * NAME:\tcnttz(uint word)\n *\n * FUNCTION:\tdetermine the number of trailing zeros within a 32-bit\n *\t\tvalue.\n *\n * PARAMETERS:\n *\tvalue\t-  32-bit value to be examined.\n *\n * RETURN VALUES:\n *\tcount of trailing zeros\n */\nstatic int cnttz(u32 word)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, word >>= 1) {\n\t\tif (word & 0x01)\n\t\t\tbreak;\n\t}\n\n\treturn (n);\n}\n\n\n/*\n * NAME:\tcntlz(u32 value)\n *\n * FUNCTION:\tdetermine the number of leading zeros within a 32-bit\n *\t\tvalue.\n *\n * PARAMETERS:\n *\tvalue\t-  32-bit value to be examined.\n *\n * RETURN VALUES:\n *\tcount of leading zeros\n */\nstatic int cntlz(u32 value)\n{\n\tint n;\n\n\tfor (n = 0; n < 32; n++, value <<= 1) {\n\t\tif (value & HIGHORDER)\n\t\t\tbreak;\n\t}\n\treturn (n);\n}\n\n\n/*\n * NAME:\tblkstol2(s64 nb)\n *\n * FUNCTION:\tconvert a block count to its log2 value. if the block\n *\t\tcount is not a l2 multiple, it is rounded up to the next\n *\t\tlarger l2 multiple.\n *\n * PARAMETERS:\n *\tnb\t-  number of blocks\n *\n * RETURN VALUES:\n *\tlog2 number of blocks\n */\nstatic int blkstol2(s64 nb)\n{\n\tint l2nb;\n\ts64 mask;\t\t/* meant to be signed */\n\n\tmask = (s64) 1 << (64 - 1);\n\n\t/* count the leading bits.\n\t */\n\tfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\n\t\t/* leading bit found.\n\t\t */\n\t\tif (nb & mask) {\n\t\t\t/* determine the l2 value.\n\t\t\t */\n\t\t\tl2nb = (64 - 1) - l2nb;\n\n\t\t\t/* check if we need to round up.\n\t\t\t */\n\t\t\tif (~mask & nb)\n\t\t\t\tl2nb++;\n\n\t\t\treturn (l2nb);\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\t\t/* fix compiler warning */\n}\n\n\n/*\n * NAME:\tdbAllocBottomUp()\n *\n * FUNCTION:\talloc the specified block range from the working block\n *\t\tallocation map.\n *\n *\t\tthe blocks will be alloc from the working map one dmap\n *\t\tat a time.\n *\n * PARAMETERS:\n *\tip\t-  pointer to in-core inode;\n *\tblkno\t-  starting block number to be freed.\n *\tnblocks\t-  number of blocks to be freed.\n *\n * RETURN VALUES:\n *\t0\t- success\n *\t-EIO\t- i/o error\n */\nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be allocated better be within the mapsize. */\n\tASSERT(nblocks <= bmp->db_mapsize - blkno);\n\n\t/*\n\t * allocate the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be allocated from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* allocate the blocks. */\n\t\tif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}\n\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}\n\n\n/*\n * NAME:\tdbExtendFS()\n *\n * FUNCTION:\textend bmap from blkno for nblocks;\n *\t\tdbExtendFS() updates bmap ready for dbAllocBottomUp();\n *\n * L2\n *  |\n *   L1---------------------------------L1\n *    |\t\t\t\t\t |\n *     L0---------L0---------L0\t\t  L0---------L0---------L0\n *      |\t   |\t      |\t\t   |\t      |\t\t |\n *\t d0,...,dn  d0,...,dn  d0,...,dn    d0,...,dn  d0,...,dn  d0,.,dm;\n * L2L1L0d0,...,dnL0d0,...,dnL0d0,...,dnL1L0d0,...,dnL0d0,...,dnL0d0,..dm\n *\n * <---old---><----------------------------extend----------------------->\n */\nint dbExtendFS(struct inode *ipbmap, s64 blkno,\ts64 nblocks)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\n\tint nbperpage = sbi->nbperpage;\n\tint i, i0 = true, j, j0 = true, k, n;\n\ts64 newsize;\n\ts64 p;\n\tstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\n\tstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\n\tstruct dmap *dp;\n\ts8 *l0leaf, *l1leaf, *l2leaf;\n\tstruct bmap *bmp = sbi->bmap;\n\tint agno, l2agsize, oldl2agsize;\n\ts64 ag_rem;\n\n\tnewsize = blkno + nblocks;\n\n\tjfs_info(\"dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld\",\n\t\t (long long) blkno, (long long) nblocks, (long long) newsize);\n\n\t/*\n\t *\tinitialize bmap control page.\n\t *\n\t * all the data in bmap control page should exclude\n\t * the mkfs hidden dmap page.\n\t */\n\n\t/* update mapsize */\n\tbmp->db_mapsize = newsize;\n\tbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\n\n\t/* compute new AG size */\n\tl2agsize = dbGetL2AGSize(newsize);\n\toldl2agsize = bmp->db_agl2size;\n\n\tbmp->db_agl2size = l2agsize;\n\tbmp->db_agsize = 1 << l2agsize;\n\n\t/* compute new number of AG */\n\tagno = bmp->db_numag;\n\tbmp->db_numag = newsize >> l2agsize;\n\tbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\n\n\t/*\n\t *\treconfigure db_agfree[]\n\t * from old AG configuration to new AG configuration;\n\t *\n\t * coalesce contiguous k (newAGSize/oldAGSize) AGs;\n\t * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;\n\t * note: new AG size = old AG size * (2**x).\n\t */\n\tif (l2agsize == oldl2agsize)\n\t\tgoto extend;\n\tk = 1 << (l2agsize - oldl2agsize);\n\tag_rem = bmp->db_agfree[0];\t/* save agfree[0] */\n\tfor (i = 0, n = 0; i < agno; n++) {\n\t\tbmp->db_agfree[n] = 0;\t/* init collection point */\n\n\t\t/* coalesce contiguous k AGs; */\n\t\tfor (j = 0; j < k && i < agno; j++, i++) {\n\t\t\t/* merge AGi to AGn */\n\t\t\tbmp->db_agfree[n] += bmp->db_agfree[i];\n\t\t}\n\t}\n\tbmp->db_agfree[0] += ag_rem;\t/* restore agfree[0] */\n\n\tfor (; n < MAXAG; n++)\n\t\tbmp->db_agfree[n] = 0;\n\n\t/*\n\t * update highest active ag number\n\t */\n\n\tbmp->db_maxag = bmp->db_maxag / k;\n\n\t/*\n\t *\textend bmap\n\t *\n\t * update bit maps and corresponding level control pages;\n\t * global control page db_nfree, db_agfree[agno], db_maxfreebud;\n\t */\n      extend:\n\t/* get L2 page */\n\tp = BMAPBLKNO + nbperpage;\t/* L2 page */\n\tl2mp = read_metapage(ipbmap, p, PSIZE, 0);\n\tif (!l2mp) {\n\t\tjfs_error(ipbmap->i_sb, \"L2 page could not be read\\n\");\n\t\treturn -EIO;\n\t}\n\tl2dcp = (struct dmapctl *) l2mp->data;\n\n\t/* compute start L1 */\n\tk = blkno >> L2MAXL1SIZE;\n\tl2leaf = l2dcp->stree + CTLLEAFIND + k;\n\tp = BLKTOL1(blkno, sbi->l2nbperpage);\t/* L1 page */\n\n\t/*\n\t * extend each L1 in L2\n\t */\n\tfor (; k < LPERCTL; k++, p += nbperpage) {\n\t\t/* get L1 page */\n\t\tif (j0) {\n\t\t\t/* read in L1 page: (blkno & (MAXL1SIZE - 1)) */\n\t\t\tl1mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND + j;\n\t\t\tp = BLKTOL0(blkno, sbi->l2nbperpage);\n\t\t\tj0 = false;\n\t\t} else {\n\t\t\t/* assign/init L1 page */\n\t\t\tl1mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\tif (l1mp == NULL)\n\t\t\t\tgoto errout;\n\n\t\t\tl1dcp = (struct dmapctl *) l1mp->data;\n\n\t\t\t/* compute start L0 */\n\t\t\tj = 0;\n\t\t\tl1leaf = l1dcp->stree + CTLLEAFIND;\n\t\t\tp += nbperpage;\t/* 1st L0 of L1.k */\n\t\t}\n\n\t\t/*\n\t\t * extend each L0 in L1\n\t\t */\n\t\tfor (; j < LPERCTL; j++) {\n\t\t\t/* get L0 page */\n\t\t\tif (i0) {\n\t\t\t\t/* read in L0 page: (blkno & (MAXL0SIZE - 1)) */\n\n\t\t\t\tl0mp = read_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = (blkno & (MAXL0SIZE - 1)) >>\n\t\t\t\t    L2BPERDMAP;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND + i;\n\t\t\t\tp = BLKTODMAP(blkno,\n\t\t\t\t\t      sbi->l2nbperpage);\n\t\t\t\ti0 = false;\n\t\t\t} else {\n\t\t\t\t/* assign/init L0 page */\n\t\t\t\tl0mp = get_metapage(ipbmap, p, PSIZE, 0);\n\t\t\t\tif (l0mp == NULL)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tl0dcp = (struct dmapctl *) l0mp->data;\n\n\t\t\t\t/* compute start dmap */\n\t\t\t\ti = 0;\n\t\t\t\tl0leaf = l0dcp->stree + CTLLEAFIND;\n\t\t\t\tp += nbperpage;\t/* 1st dmap of L0.j */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * extend each dmap in L0\n\t\t\t */\n\t\t\tfor (; i < LPERCTL; i++) {\n\t\t\t\t/*\n\t\t\t\t * reconstruct the dmap page, and\n\t\t\t\t * initialize corresponding parent L0 leaf\n\t\t\t\t */\n\t\t\t\tif ((n = blkno & (BPERDMAP - 1))) {\n\t\t\t\t\t/* read in dmap page: */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tn = min(nblocks, (s64)BPERDMAP - n);\n\t\t\t\t} else {\n\t\t\t\t\t/* assign/init dmap page */\n\t\t\t\t\tmp = read_metapage(ipbmap, p,\n\t\t\t\t\t\t\t   PSIZE, 0);\n\t\t\t\t\tif (mp == NULL)\n\t\t\t\t\t\tgoto errout;\n\n\t\t\t\t\tn = min_t(s64, nblocks, BPERDMAP);\n\t\t\t\t}\n\n\t\t\t\tdp = (struct dmap *) mp->data;\n\t\t\t\t*l0leaf = dbInitDmap(dp, blkno, n);\n\n\t\t\t\tbmp->db_nfree += n;\n\t\t\t\tagno = le64_to_cpu(dp->start) >> l2agsize;\n\t\t\t\tbmp->db_agfree[agno] += n;\n\n\t\t\t\twrite_metapage(mp);\n\n\t\t\t\tl0leaf++;\n\t\t\t\tp += nbperpage;\n\n\t\t\t\tblkno += n;\n\t\t\t\tnblocks -= n;\n\t\t\t\tif (nblocks == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\t/* for each dmap in a L0 */\n\n\t\t\t/*\n\t\t\t * build current L0 page from its leaves, and\n\t\t\t * initialize corresponding parent L1 leaf\n\t\t\t */\n\t\t\t*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\n\t\t\twrite_metapage(l0mp);\n\t\t\tl0mp = NULL;\n\n\t\t\tif (nblocks)\n\t\t\t\tl1leaf++;\t/* continue for next L0 */\n\t\t\telse {\n\t\t\t\t/* more than 1 L0 ? */\n\t\t\t\tif (j > 0)\n\t\t\t\t\tbreak;\t/* build L1 page */\n\t\t\t\telse {\n\t\t\t\t\t/* summarize in global bmap page */\n\t\t\t\t\tbmp->db_maxfreebud = *l1leaf;\n\t\t\t\t\trelease_metapage(l1mp);\n\t\t\t\t\trelease_metapage(l2mp);\n\t\t\t\t\tgoto finalize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t/* for each L0 in a L1 */\n\n\t\t/*\n\t\t * build current L1 page from its leaves, and\n\t\t * initialize corresponding parent L2 leaf\n\t\t */\n\t\t*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\n\t\twrite_metapage(l1mp);\n\t\tl1mp = NULL;\n\n\t\tif (nblocks)\n\t\t\tl2leaf++;\t/* continue for next L1 */\n\t\telse {\n\t\t\t/* more than 1 L1 ? */\n\t\t\tif (k > 0)\n\t\t\t\tbreak;\t/* build L2 page */\n\t\t\telse {\n\t\t\t\t/* summarize in global bmap page */\n\t\t\t\tbmp->db_maxfreebud = *l2leaf;\n\t\t\t\trelease_metapage(l2mp);\n\t\t\t\tgoto finalize;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* for each L1 in a L2 */\n\n\tjfs_error(ipbmap->i_sb, \"function has not returned as expected\\n\");\nerrout:\n\tif (l0mp)\n\t\trelease_metapage(l0mp);\n\tif (l1mp)\n\t\trelease_metapage(l1mp);\n\trelease_metapage(l2mp);\n\treturn -EIO;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\nfinalize:\n\n\treturn 0;\n}\n\n\n/*\n *\tdbFinalizeBmap()\n */\nvoid dbFinalizeBmap(struct inode *ipbmap)\n{\n\tstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\n\tint actags, inactags, l2nl;\n\ts64 ag_rem, actfree, inactfree, avgfree;\n\tint i, n;\n\n\t/*\n\t *\tfinalize bmap control page\n\t */\n//finalize:\n\t/*\n\t * compute db_agpref: preferred ag to allocate from\n\t * (the leftmost ag with average free space in it);\n\t */\n//agpref:\n\t/* get the number of active ags and inactive ags */\n\tactags = bmp->db_maxag + 1;\n\tinactags = bmp->db_numag - actags;\n\tag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\t/* ??? */\n\n\t/* determine how many blocks are in the inactive allocation\n\t * groups. in doing this, we must account for the fact that\n\t * the rightmost group might be a partial group (i.e. file\n\t * system size is not a multiple of the group size).\n\t */\n\tinactfree = (inactags && ag_rem) ?\n\t    ((inactags - 1) << bmp->db_agl2size) + ag_rem\n\t    : inactags << bmp->db_agl2size;\n\n\t/* determine how many free blocks are in the active\n\t * allocation groups plus the average number of free blocks\n\t * within the active ags.\n\t */\n\tactfree = bmp->db_nfree - inactfree;\n\tavgfree = (u32) actfree / (u32) actags;\n\n\t/* if the preferred allocation group has not average free space.\n\t * re-establish the preferred group as the leftmost\n\t * group with average free space.\n\t */\n\tif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\n\t\tfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\n\t\t     bmp->db_agpref++) {\n\t\t\tif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bmp->db_agpref >= bmp->db_numag) {\n\t\t\tjfs_error(ipbmap->i_sb,\n\t\t\t\t  \"cannot find ag with average freespace\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * compute db_aglevel, db_agheight, db_width, db_agstart:\n\t * an ag is covered in aglevel dmapctl summary tree,\n\t * at agheight level height (from leaf) with agwidth number of nodes\n\t * each, which starts at agstart index node of the smmary tree node\n\t * array;\n\t */\n\tbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\n\tl2nl =\n\t    bmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\n\tbmp->db_agheight = l2nl >> 1;\n\tbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\n\tfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\n\t     i--) {\n\t\tbmp->db_agstart += n;\n\t\tn <<= 2;\n\t}\n\n}\n\n\n/*\n * NAME:\tdbInitDmap()/ujfs_idmap_page()\n *\n * FUNCTION:\tinitialize working/persistent bitmap of the dmap page\n *\t\tfor the specified number of blocks:\n *\n *\t\tat entry, the bitmaps had been initialized as free (ZEROS);\n *\t\tThe number of blocks will only account for the actually\n *\t\texisting blocks. Blocks which don't actually exist in\n *\t\tthe aggregate will be marked as allocated (ONES);\n *\n * PARAMETERS:\n *\tdp\t- pointer to page of map\n *\tnblocks\t- number of blocks this page\n *\n * RETURNS: NONE\n */\nstatic int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\n{\n\tint blkno, w, b, r, nw, nb, i;\n\n\t/* starting block number within the dmap */\n\tblkno = Blkno & (BPERDMAP - 1);\n\n\tif (blkno == 0) {\n\t\tdp->nblocks = dp->nfree = cpu_to_le32(nblocks);\n\t\tdp->start = cpu_to_le64(Blkno);\n\n\t\tif (nblocks == BPERDMAP) {\n\t\t\tmemset(&dp->wmap[0], 0, LPERDMAP * 4);\n\t\t\tmemset(&dp->pmap[0], 0, LPERDMAP * 4);\n\t\t\tgoto initTree;\n\t\t}\n\t} else {\n\t\tle32_add_cpu(&dp->nblocks, nblocks);\n\t\tle32_add_cpu(&dp->nfree, nblocks);\n\t}\n\n\t/* word number containing start block number */\n\tw = blkno >> L2DBWORD;\n\n\t/*\n\t * free the bits corresponding to the block range (ZEROS):\n\t * note: not all bits of the first and last words may be contained\n\t * within the block range.\n\t */\n\tfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\n\t\t/* number of bits preceding range to be freed in the word */\n\t\tb = blkno & (DBWORD - 1);\n\t\t/* number of bits to free in the word */\n\t\tnb = min(r, DBWORD - b);\n\n\t\t/* is partial word to be freed ? */\n\t\tif (nb < DBWORD) {\n\t\t\t/* free (set to 0) from the bitmap word */\n\t\t\tdp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\t\t\tdp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\n\t\t\t\t\t\t     >> b));\n\n\t\t\t/* skip the word freed */\n\t\t\tw++;\n\t\t} else {\n\t\t\t/* free (set to 0) contiguous bitmap words */\n\t\t\tnw = r >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[w], 0, nw * 4);\n\t\t\tmemset(&dp->pmap[w], 0, nw * 4);\n\n\t\t\t/* skip the words freed */\n\t\t\tnb = nw << L2DBWORD;\n\t\t\tw += nw;\n\t\t}\n\t}\n\n\t/*\n\t * mark bits following the range to be freed (non-existing\n\t * blocks) as allocated (ONES)\n\t */\n\n\tif (blkno == BPERDMAP)\n\t\tgoto initTree;\n\n\t/* the first word beyond the end of existing blocks */\n\tw = blkno >> L2DBWORD;\n\n\t/* does nblocks fall on a 32-bit boundary ? */\n\tb = blkno & (DBWORD - 1);\n\tif (b) {\n\t\t/* mark a partial word allocated */\n\t\tdp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\n\t\tw++;\n\t}\n\n\t/* set the rest of the words in the page to allocated (ONES) */\n\tfor (i = w; i < LPERDMAP; i++)\n\t\tdp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\n\n\t/*\n\t * init tree\n\t */\n      initTree:\n\treturn (dbInitDmapTree(dp));\n}\n\n\n/*\n * NAME:\tdbInitDmapTree()/ujfs_complete_dmap()\n *\n * FUNCTION:\tinitialize summary tree of the specified dmap:\n *\n *\t\tat entry, bitmap of the dmap has been initialized;\n *\n * PARAMETERS:\n *\tdp\t- dmap to complete\n *\tblkno\t- starting block number for this dmap\n *\ttreemax\t- will be filled in with max free for this dmap\n *\n * RETURNS:\tmax free string at the root of the tree\n */\nstatic int dbInitDmapTree(struct dmap * dp)\n{\n\tstruct dmaptree *tp;\n\ts8 *cp;\n\tint i;\n\n\t/* init fixed info of tree */\n\ttp = &dp->tree;\n\ttp->nleafs = cpu_to_le32(LPERDMAP);\n\ttp->l2nleafs = cpu_to_le32(L2LPERDMAP);\n\ttp->leafidx = cpu_to_le32(LEAFIND);\n\ttp->height = cpu_to_le32(4);\n\ttp->budmin = BUDMIN;\n\n\t/* init each leaf from corresponding wmap word:\n\t * note: leaf is set to NOFREE(-1) if all blocks of corresponding\n\t * bitmap word are allocated.\n\t */\n\tcp = tp->stree + le32_to_cpu(tp->leafidx);\n\tfor (i = 0; i < LPERDMAP; i++)\n\t\t*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree(tp));\n}\n\n\n/*\n * NAME:\tdbInitTree()/ujfs_adjtree()\n *\n * FUNCTION:\tinitialize binary buddy summary tree of a dmap or dmapctl.\n *\n *\t\tat entry, the leaves of the tree has been initialized\n *\t\tfrom corresponding bitmap word or root of summary tree\n *\t\tof the child control page;\n *\t\tconfigure binary buddy system at the leaf level, then\n *\t\tbubble up the values of the leaf nodes up the tree.\n *\n * PARAMETERS:\n *\tcp\t- Pointer to the root of the tree\n *\tl2leaves- Number of leaf nodes as a power of 2\n *\tl2min\t- Number of blocks that can be covered by a leaf\n *\t\t  as a power of 2\n *\n * RETURNS: max free string at the root of the tree\n */\nstatic int dbInitTree(struct dmaptree * dtp)\n{\n\tint l2max, l2free, bsize, nextb, i;\n\tint child, parent, nparent;\n\ts8 *tp, *cp, *cp1;\n\n\ttp = dtp->stree;\n\n\t/* Determine the maximum free string possible for the leaves */\n\tl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\n\n\t/*\n\t * configure the leaf levevl into binary buddy system\n\t *\n\t * Try to combine buddies starting with a buddy size of 1\n\t * (i.e. two leaves). At a buddy size of 1 two buddy leaves\n\t * can be combined if both buddies have a maximum free of l2min;\n\t * the combination will result in the left-most buddy leaf having\n\t * a maximum free of l2min+1.\n\t * After processing all buddies for a given size, process buddies\n\t * at the next higher buddy size (i.e. current size * 2) and\n\t * the next maximum free (current free + 1).\n\t * This continues until the maximum possible buddy combination\n\t * yields maximum free.\n\t */\n\tfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\n\t     l2free++, bsize = nextb) {\n\t\t/* get next buddy size == current buddy pair size */\n\t\tnextb = bsize << 1;\n\n\t\t/* scan each adjacent buddy pair at current buddy size */\n\t\tfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\n\t\t     i < le32_to_cpu(dtp->nleafs);\n\t\t     i += nextb, cp += nextb) {\n\t\t\t/* coalesce if both adjacent buddies are max free */\n\t\t\tif (*cp == l2free && *(cp + bsize) == l2free) {\n\t\t\t\t*cp = l2free + 1;\t/* left take right */\n\t\t\t\t*(cp + bsize) = -1;\t/* right give left */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * bubble summary information of leaves up the tree.\n\t *\n\t * Starting at the leaf node level, the four nodes described by\n\t * the higher level parent node are compared for a maximum free and\n\t * this maximum becomes the value of the parent node.\n\t * when all lower level nodes are processed in this fashion then\n\t * move up to the next level (parent becomes a lower level node) and\n\t * continue the process for that level.\n\t */\n\tfor (child = le32_to_cpu(dtp->leafidx),\n\t     nparent = le32_to_cpu(dtp->nleafs) >> 2;\n\t     nparent > 0; nparent >>= 2, child = parent) {\n\t\t/* get index of 1st node of parent level */\n\t\tparent = (child - 1) >> 2;\n\n\t\t/* set the value of the parent node as the maximum\n\t\t * of the four nodes of the current level.\n\t\t */\n\t\tfor (i = 0, cp = tp + child, cp1 = tp + parent;\n\t\t     i < nparent; i++, cp += 4, cp1++)\n\t\t\t*cp1 = TREEMAX(cp);\n\t}\n\n\treturn (*tp);\n}\n\n\n/*\n *\tdbInitDmapCtl()\n *\n * function: initialize dmapctl page\n */\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\n{\t\t\t\t/* start leaf index not covered by range */\n\ts8 *cp;\n\n\tdcp->nleafs = cpu_to_le32(LPERCTL);\n\tdcp->l2nleafs = cpu_to_le32(L2LPERCTL);\n\tdcp->leafidx = cpu_to_le32(CTLLEAFIND);\n\tdcp->height = cpu_to_le32(5);\n\tdcp->budmin = L2BPERDMAP + L2LPERCTL * level;\n\n\t/*\n\t * initialize the leaves of current level that were not covered\n\t * by the specified input block range (i.e. the leaves have no\n\t * low level dmapctl or dmap).\n\t */\n\tcp = &dcp->stree[CTLLEAFIND + i];\n\tfor (; i < LPERCTL; i++)\n\t\t*cp++ = NOFREE;\n\n\t/* build the dmap's binary buddy summary tree */\n\treturn (dbInitTree((struct dmaptree *) dcp));\n}\n\n\n/*\n * NAME:\tdbGetL2AGSize()/ujfs_getagl2size()\n *\n * FUNCTION:\tDetermine log2(allocation group size) from aggregate size\n *\n * PARAMETERS:\n *\tnblocks\t- Number of blocks in aggregate\n *\n * RETURNS: log2(allocation group size) in aggregate blocks\n */\nstatic int dbGetL2AGSize(s64 nblocks)\n{\n\ts64 sz;\n\ts64 m;\n\tint l2sz;\n\n\tif (nblocks < BPERDMAP * MAXAG)\n\t\treturn (L2BPERDMAP);\n\n\t/* round up aggregate size to power of 2 */\n\tm = ((u64) 1 << (64 - 1));\n\tfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\n\t\tif (m & nblocks)\n\t\t\tbreak;\n\t}\n\n\tsz = (s64) 1 << l2sz;\n\tif (sz < nblocks)\n\t\tl2sz += 1;\n\n\t/* agsize = roundupSize/max_number_of_ag */\n\treturn (l2sz - L2MAXAG);\n}\n\n\n/*\n * NAME:\tdbMapFileSizeToMapSize()\n *\n * FUNCTION:\tcompute number of blocks the block allocation map file\n *\t\tcan cover from the map file size;\n *\n * RETURNS:\tNumber of blocks which can be covered by this block map file;\n */\n\n/*\n * maximum number of map pages at each level including control pages\n */\n#define MAXL0PAGES\t(1 + LPERCTL)\n#define MAXL1PAGES\t(1 + LPERCTL * MAXL0PAGES)\n\n/*\n * convert number of map pages to the zero origin top dmapctl level\n */\n#define BMAPPGTOLEV(npages)\t\\\n\t(((npages) <= 3 + MAXL0PAGES) ? 0 : \\\n\t ((npages) <= 2 + MAXL1PAGES) ? 1 : 2)\n\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\n{\n\tstruct super_block *sb = ipbmap->i_sb;\n\ts64 nblocks;\n\ts64 npages, ndmaps;\n\tint level, i;\n\tint complete, factor;\n\n\tnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\n\tnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\n\tlevel = BMAPPGTOLEV(npages);\n\n\t/* At each level, accumulate the number of dmap pages covered by\n\t * the number of full child levels below it;\n\t * repeat for the last incomplete child level.\n\t */\n\tndmaps = 0;\n\tnpages--;\t\t/* skip the first global control page */\n\t/* skip higher level control pages above top level covered by map */\n\tnpages -= (2 - level);\n\tnpages--;\t\t/* skip top level's control page */\n\tfor (i = level; i >= 0; i--) {\n\t\tfactor =\n\t\t    (i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\n\t\tcomplete = (u32) npages / factor;\n\t\tndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\n\t\t\t\t      ((i == 1) ? LPERCTL : 1));\n\n\t\t/* pages in last/incomplete child */\n\t\tnpages = (u32) npages % factor;\n\t\t/* skip incomplete child's level control page */\n\t\tnpages--;\n\t}\n\n\t/* convert the number of dmaps into the number of blocks\n\t * which can be covered by the dmaps;\n\t */\n\tnblocks = ndmaps << L2BPERDMAP;\n\n\treturn (nblocks);\n}\n"], "filenames": ["fs/jfs/jfs_dmap.c"], "buggy_code_start_loc": [388], "buggy_code_end_loc": [389], "fixing_code_start_loc": [388], "fixing_code_end_loc": [390], "type": "CWE-476", "message": "A NULL pointer dereference flaw was found in dbFree in fs/jfs/jfs_dmap.c in the journaling file system (JFS) in the Linux Kernel. This issue may allow a local attacker to crash the system due to a missing sanity check.", "other": {"cve": {"id": "CVE-2023-4385", "sourceIdentifier": "secalert@redhat.com", "published": "2023-08-16T17:15:11.327", "lastModified": "2023-11-07T04:22:29.887", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference flaw was found in dbFree in fs/jfs/jfs_dmap.c in the journaling file system (JFS) in the Linux Kernel. This issue may allow a local attacker to crash the system due to a missing sanity check."}, {"lang": "es", "value": "Se ha encontrado un fallo de desviaci\u00f3n de puntero NULL en dbFree en fs/jfs/jfs_dmap.c en el sistema de archivos de registro diario (JFS) en el Kernel de Linux. Este problema puede permitir a un atacante local bloquear el sistema debido a la falta de una comprobaci\u00f3n de sanidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.18.19", "matchCriteriaId": "0D276816-D731-4671-829E-2DEF083D10E4"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-4385", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2219272", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0d4837fdb796f99369cf7691d33de1b856bcaf1f", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0d4837fdb796f99369cf7691d33de1b856bcaf1f"}}