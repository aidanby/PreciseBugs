{"buggy_code": ["\nv0.12.7\n-------\n\n.format() and Babel-Tower interop, exposing stringKit.format.modes\n\n\nv0.12.6\n-------\n\n.format() and Babel-Tower interop, exposing stringKit.format.modes\n\n\nv0.12.5\n-------\n\n.format(): %n/%N improvements\n\n\nv0.12.4\n-------\n\n.format(): new Scientific Notation (e.g. 1.23 \u00d7 10\u00b2)\n\n\nv0.12.3\n-------\n\n.format()'s new float mode: 'g' for group separator (thousands)\n\n\nv0.12.2\n-------\n\n.format(): new %P/%p format for absolute/relative percent\n\n\nv0.12.1\n-------\n\n.inspect() new option: 'minimalPlusConstructor' and 'noTypeButConstructor' (for displaying non-trivial constructor)\n\n\nv0.12.0\n-------\n\n[Maybe breaking] .format() now use the new StringNumber class, used for number formatting\n\n\nv0.11.10\n--------\n\nFix format %X to respect unicode\n\n\nv0.11.9\n-------\n\nNew format argument: %X, turning a string into its hexadecimal representation\n\n\nv0.11.8\n-------\n\nstring.unicode.getLastTruncateWidth()\n\n\nv0.11.7\n-------\n\n.format() %n and %N sort object keys\n\n\nv0.11.6\n-------\n\n.format(): new inspection argument 's' for max string length\n.inspect(): new option 'useInpectPropertyBlackList' that use target object own blacklist\n\n\nv0.11.5\n-------\n\n.format(): new inspect argument 'l' for outputMaxLength\n\n\nv0.11.4\n-------\n\n.format(): new inspect argument 'l' for outputMaxLength\n\n\nv0.11.3\n-------\n\nMinor .inspectError() tweaks\n\n\nv0.11.2\n-------\n\n.inpectError() improved (support for new elements in the latest Node.js stack trace)\n\n\nv0.11.1\n-------\n\n.format(): Add %m specifier for degrees/minutes/seconds notation\n\n\nv0.11.0\n-------\n\n.format() big improvements: generic parameters (parameters common to multiple specifiers), better API, more documentation. Also BREAKING change: %f zero-paddingdo not use the 'p' parameter but the 'z' (like Zero). Removed the 'P' parameter which would break the new standard of upper-case = generic parameter, and it is useless since any specifier can use the 'L' and 'R' parameter.\n\n\nv0.10.6\n-------\n\nAdd number format space padding\n\n\nv0.10.5\n-------\n\nFix format number 0 padding and negative numbers\n\n\nv0.10.4\n-------\n\nNew: .format() %s now support padding\n\n\nv0.10.3\n-------\n\n.format(): improvement on the new %n/%N natural formatting\n\n\nv0.10.2\n-------\n\nNew format %n and %N (WIP: behavior)\n\n\nv0.10.1\n-------\n\nNew options 'indexOf' for fuzzy matcher\n\n\nv0.10.0\n-------\n\nBREAKING: fixing occurrenceCount() spelling, and add the overlap option\n\n\nv0.9.12\n-------\n\nFuzzy string matcher improvements, more unit tests\n\n\nv0.9.11\n-------\n\nNew: fuzzy string matcher\n\n\nv0.9.10\n-------\n\nFix .wordwarp() options to the correct name: widthFn -> charWidthFn\n\n\nv0.9.9\n------\n\nNew: .camelCaseToSeparated(): like .camelCaseToDashed() but with a customizable separator (default to space)\n\n\nv0.9.8\n------\n\nescape.unicodePercentEncode()\n\n\nv0.9.7\n------\n\n.format() %t option for time duration\n\n\nv0.9.6\n------\n\n.format(): %f mode greatly improved, new %e mode for scientific notation\n\n\nv0.9.5\n------\n\n.inspectError() now follow error.from\n\n\nv0.9.4\n------\n\n.inpect(): now correctly handle truncated output for style:color\n\n\nv0.9.3\n------\n\nNew: .naturalSort()\n\n\nv0.9.2\n------\n\nNew: .inspect() now support %S formatting: a string where ^ formatting is interpreted\n\n\nv0.9.1\n------\n\n.inspect() now detects holes in array\n\n\nv0.9.0\n------\n\nBreaking: removing xregexp\n\n\nv0.8.15\n-------\n\n.format() Node v6.x compatibility fix (PR #2)\n\n\nv0.8.14\n-------\n\n.inspect() fixing the missing new line for special object that turn to a string\n\n\nv0.8.13\n-------\n\nFormat: J mode (json) now returns 'null' for undefined, instead on crashing when sanitizing\n\n\nv0.8.12\n-------\n\n.toCamelCase() uppercase preservation option\n\n\nv0.8.11\n-------\n\n.format(): new %r format (like %s, with no sanitize)\n\n\nv0.8.10\n-------\n\n.inspect(): inspection of rejected promise (with an error) improved\n\n\nv0.8.9\n------\n\n.inspect() now supports Promise inspection (Node.js only)\n\n\nv0.8.8\n------\n\nFix a regression (since 0.7.14) with .format() and %I, %Y and %E format, when color: true\n\n\nv0.8.7\n------\n\n.toCells()/.fromCells() private API changed (again)\n\n\nv0.8.6\n------\n\n.toCells()/.fromCells() private API changed\n\n\nv0.8.5\n------\n\n.unicode.toCells(): tabs filler fixed\n\n\nv0.8.4\n------\n\n.unicode.toCells(): added a fourth argument (the initial position in the line)\n\n\nv0.8.3\n------\n\nNew: .unicode.toCells() and .unicode.fromCells()\n\n\nv0.8.2\n------\n\nFix in the private API: .wordwrap()'s 'regroupFn' option (again)\n\n\nv0.8.1\n------\n\nFix in the private API: .wordwrap()'s 'regroupFn' option\n\n\nv0.8.0\n------\n\nPrivate API breaking change: .wordwrap() option 'sequenceSkip' is now 'skipFn' ; more .wordwrap() private options ; New: .unicode.codePointWidth() and .unicode.charWidth()\n\n\nv0.7.18\n-------\n\nDeprecate .unicode.widthLimit() in favor of .unicode.truncateWidth()\n\n\nv0.7.17\n-------\n\nInternal improvements\n\n\nv0.7.16\n-------\n\n.format() new option: 'noMarkup'\n\n\nv0.7.15\n-------\n\n.format() Fix extension issues\n\n\nv0.7.14\n-------\n\n.format() Fixing control chars in non-function arguments\n\n\nv0.7.13\n-------\n\nNew: .unicode.firstCodePoint(), .unicode.firstChar()\n\n\nv0.7.12\n-------\n\n.format() %Y now has 'useInspect' option on\n\n\nv0.7.11\n-------\n\n.inspect(): new options 'useInspect' that use object .inspect() method if available\n\n\nv0.7.10\n-------\n\nFixed .inspect() on empty array\n\n\nv0.7.9\n------\n\nNew: .widthLimit()\n\n\nv0.7.8\n------\n\n.wordwrap() width fixed ; new option 'fill' that add space at the right to fill lines\n\n\nv0.7.7\n------\n\nNew: .format() now has the %k formatter (metric prefix)\n\n\nv0.7.6\n------\n\nNew: unicode.arrayWidth() has a second argument (limit)\n\n\nv0.7.5\n------\n\nNew: unicode.arrayWidth()\n\n\nv0.7.4\n------\n\n.inspect(): raise string inspection default limit from 200 to 250, since all people have big screens\n\n\nv0.7.3\n------\n\nFixed .wordwrap() edge-case behavior with spaces at the end of lines and explicit new lines (plus the noTrim option to controle it)\n\n\nv0.7.2\n------\n\n.wordwrap() API issues fixed\n\n\nv0.7.1\n------\n\nFix .wordwrap() behavior with offset and first word wrapping\n\n\nv0.7.0\n------\n\nBreaking change: .wordwrap() signature changed, either .wordwrap( str , width )  or .wordwrap( str, optionObject ) \n\n\nv0.6.18\n-------\n\nNew: .wordwrap() now support a 4th argument, a function used to skip some special chars (e.g.: useful for skipping ANSI colors)\n\n\nv0.6.17\n-------\n\nFixed an exception in .inspect() when an object has no constructor\n\n\nv0.6.16\n-------\n\nUnit tests are now using Tea-Time and its builtin 'expect' assertion\n\n\nv0.6.15\n-------\n\n.inspect() now display RegExp with .toString()\n\n\nv0.6.14\n-------\n\nAaaargh, a console.log() was left\n\n\nv0.6.13\n-------\n\noutputMaxLength option for .inspect() ; documentation\n\n\nv0.6.12\n-------\n\n.inspect() improved -- new style: inline, new option: noArrayProperty\n\n\nv0.6.11\n-------\n\n.wordwrap() is now french typography aware\n\n\nv0.6.10\n-------\n\n.wordwrap() is now unicode aware and full-width aware\n\n\nv0.6.9\n------\n\n.inspect() now has a 'maxLength' option that truncates big strings (default: 200)\n\n\nv0.6.8\n------\n\n.inspect(): proper display for String instances\n\n\nv0.6.7\n------\n\nNew function: .occurenceCount() -- count occurences of a substring\n\n\nv0.6.6\n------\n\nAdding a 'propertyBlackList' options to .inspect() to prevent to skip properties based by name ; documentation has been updated\n\n\nv0.6.5\n------\n\nAdding a 'protoBlackList' options to .inspect() to prevent from recursing inside some objects based on their prototype\n\n\nv0.6.4\n------\n\ncamelCaseToDash() alias of camelCaseToDashed()\n\n\nv0.6.3\n------\n\nMerging pull request #1: .inspect() now supports passing an object to customize the style\n\n\nv0.6.2\n------\n\n.toTitleCase(): mino refacto\n\n\nv0.6.1\n------\n\nRemoved tree-kit dependency, using ES6 Object.assign() instead\n\n\nv0.6.0\n------\n\nBreaking change: require node >= 6. Punycode module independance, unicode sub-module performance improved\n\n\nv0.5.27\n-------\n\nNew: string.unicode.width() that return the width of a string when displayed on a terminal or when using a monospace font\n\n\nv0.5.26\n-------\n\ninspectError() non-error fallback to inspect()\n\n\nv0.5.25\n-------\n\ninspectError() fix: now return '(not an error)' if it was not inspecting an error\n\n\nv0.5.24\n-------\n\n.toTitleCase() improved\n\n\nv0.5.23\n-------\n\nNew: .toTitleCase()\n\n\nv0.5.22\n-------\n\nNew: .format() accept %z and %Z that transform to base64 and base64url\n\n\nv0.5.21\n-------\n\nNew: .wordwrap()\n\n\nv0.5.20\n-------\n\nAdded XRegExp as a dependency\n\n\nv0.5.19\n-------\n\nMarkup: starting markup reset option\n\n\nv0.5.18\n-------\n\nMarkup shift/modifier documentation\n\n\nv0.5.17 - v0.5.16\n-----------------\n\nMarkup: shift\n\n\nv0.5.15\n-------\n\n.format() option %I and %Y accept a 'depth' integer argument\n\n\nv0.5.14\n-------\n\nNew: escape.jsSingleQuote() and escape.jsDoubleQuote()\n\n\nv0.5.13\n-------\n\nNew: .resize()\n\n\nv0.5.12\n-------\n\nDocumentation fixed, unit tests fixed for node v6\n\n\nv0.5.11\n-------\n\n.format() now supports %Y, like %I but without non-enum, func, and descriptor\n\n\nv0.5.10\n-------\n\nStack trace inspector fixed for anonymous function in V8\n\n\nv0.5.9\n------\n\nNew: string.markup(), a stand-alone version of the markup existing in string.format()\n\n\nv0.5.8\n------\n\nDependencies\n\n\nv0.5.6 - v0.5.7\n---------------\n\ninspectError(): firefox stack trace improvements\n\n\nv0.5.5\n------\n\ninspectError(): 'browser' option\n\n\nv0.5.4\n------\n\nHtml error inspector improvements\n\n\nv0.5.3\n------\n\nDependency organization\n\n\nv0.5.2\n------\n\n.inspect(): 'sort' option that sort keys\n\n\nv0.5.1\n------\n\nAbort the home-made diff algorithm project in .inspect().\n\n\nv0.5.0\n------\n\nBreaking changes: more options to .inspect().\n\n\nv0.4.4\n------\n\nNew function: latinize().\n\n\nv0.4.3\n------\n\n\"use strict\" everywhere.\n\n\nv0.4.2\n------\n\n\"use strict\" everywhere.\n\n\nv0.4.1\n------\n\n.format(): .format.count() and .format.hasFormatting() have had bugs with the new v0.4.0 format syntax\n\n\nv0.4.0\n------\n\nBreaking changes: format() now uses a generic %L and %[]L where L is any letter, so %[func:%a%a] is now %[func:%a%a]F and %/F1/f is now %[f1]f\n\n\nv0.3.14\n-------\n\nBreaking changes: format() now uses a generic %L and %[]L where L is any letter, so %[func:%a%a] is now %[func:%a%a]F and %/F1/f is now %[f1]f\n\n\nv0.3.13\n-------\n\nformat(): custom formatter gains more flexibility\n\n\nv0.3.12\n-------\n\nFormat cleanup\n\n\nv0.3.11\n-------\n\n.inspect() now inspect Date instance\n\n\nv0.3.10\n-------\n\n.inspect() now inspect ES6 Set & Map, and MongoDB ObjectID\n\n\nv0.3.9\n------\n\nstring.unicode.isFullWidth(): check if the given char is a full-width char or not\n\n\nv0.3.8\n------\n\nstring.unicode.surrogatePair(): it does not check input anymore, to gain perfs\n\n\nv0.3.7\n------\n\nstring.unicode.toFullWidth(): convert normal ASCII chars to their full-width counterpart\n\n\nv0.3.6\n------\n\nBugfix on the new .format()'s style markup feature\n\n\nv0.3.5\n------\n\nDocumentation.\n\n\nv0.3.4\n------\n\nDocumentation: precision on .format() and style markup.\n\n\nv0.3.3\n------\n\nDocumentation on the new caret ^ feature (style markup) for the .format() method.\n\n\nv0.3.2\n------\n\nExpose the default formatter option.\n\n\nv0.3.1\n------\n\n.format(): fixing a bug when no markup exists in the object.\n\n\nv0.3.0\n------\n\nNew [breaking compatibilities]: .format() now accepts style markup using the caret ^ sign.\n\n\n\nv0.2.10\n-------\n\nNew method: .camelCaseToDashed().\n\n\nv0.2.3 - v0.2.9\n---------------\n\n.inspectError() improvement and bugfixes.\n.inspectStack() that just inspect a stack string.\n\n\nv0.2.0 - v0.2.2\n---------------\n\nformat(): custom filters should use formatMethod() instead.\n\n\nv0.1.21\n-------\n\nOption %E for format(): call inspectError() on the argument.\n\n\nv0.1.20\n-------\n\nNew method: inspectError().\n\n\nv0.1.19\n-------\n\nOption %I for format(): call inspect() on the argument.\n\n\nv0.1.18\n-------\n\nDependencies.\n\n\nv0.1.15 - v0.1.17\n-----------------\n\nIntroducing the .toCamelCase() method.\n\n\nv0.1.13 - v0.1.14\n-----------------\n\nAdding few MDN polyfill for the native String object.\n\n\nv0.1.12\n--------\n\nImprovement on the unicode submodule.\n\n\nv0.1.11\n--------\n\nNew submodule: 'unicode'. Still a work in progress, so no doc and no API contract for instance.\n\n\nv0.1.10\n-------\n\n.inspect() displays empty keys between quotes.\n\n\nv0.1.9\n------\n\nNew submodule: 'regexp'. Still a work in progress, so no doc and no API contract for instance.\n\n\nv0.1.8\n------\n\n.inspect() with 'proto' option now reports correctly prototype of empty objects.\n\n\nv0.1.7\n------\n\nDependencies.\n\n\nv0.1.6\n------\n\n* .ansi now contains code for dim and inverse.\n\n\nv0.1.5\n------\n\n* Bugfix: .format.count() now works correctly when indexed formating are in use.\n\n\nv0.1.4\n------\n\n* NEW! .ansi contains an object with ansi code, e.g. .ansi.red is the ansi code for red, etc.\n\n\nv0.1.3\n------\n\n* .inspect(): fixed a bug displaying false circular references when dealing with arrays (because of .concat() unexpected behaviour)\n\n\nv0.1.1 - v0.1.2\n---------------\n\n* .inspect() should handle exception when dealing with native object that raise exceptions when accessing properties.\ne.g.: \"Uncaught SecurityError: Failed to read the 'cookie' property from 'Document': Access is denied for this document.\"\nraised by Chromium.\n\n* Upgraded dependencies.\n\n\nv0.1.0\n------\n\nRefactoring.\n\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n * Natural Sort algorithm for Javascript - Version 0.8 - Released under MIT license\n * Author: Jim Palmer (based on chunking idea from Dave Koelle)\n */\nmodule.exports = function( a , b ) {\n\tvar re = /(^([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?$|^0x[\\da-fA-F]+$|\\d+)/g ,\n\t\tsre = /^\\s+|\\s+$/g ,   // trim pre-post whitespace\n\t\tsnre = /\\s+/g ,        // normalize all whitespace to single ' ' character\n\t\tdre = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[/-]\\d{1,4}[/-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/ ,\n\t\thre = /^0x[0-9a-f]+$/i ,\n\t\tore = /^0/ ,\n\t\ti = function( s ) {\n\t\t\treturn ( '' + s ).toLowerCase().replace( sre , '' ) ;\n\t\t} ,\n\t\t// convert all to strings strip whitespace\n\t\tx = i( a ) || '' ,\n\t\ty = i( b ) || '' ,\n\t\t// chunk/tokenize\n\t\txN = x.replace( re , '\\0$1\\0' ).replace( /\\0$/ , '' )\n\t\t\t.replace( /^\\0/ , '' )\n\t\t\t.split( '\\0' ) ,\n\t\tyN = y.replace( re , '\\0$1\\0' ).replace( /\\0$/ , '' )\n\t\t\t.replace( /^\\0/ , '' )\n\t\t\t.split( '\\0' ) ,\n\t\t// numeric, hex or date detection\n\t\txD = parseInt( x.match( hre ) , 16 ) || ( xN.length !== 1 && Date.parse( x ) ) ,\n\t\tyD = parseInt( y.match( hre ) , 16 ) || xD && y.match( dre ) && Date.parse( y ) || null ,\n\t\tnormChunk = function( s , l ) {\n\t\t\t// normalize spaces; find floats not starting with '0', string or 0 if not defined (Clint Priest)\n\t\t\treturn ( ! s.match( ore ) || l === 1 ) && parseFloat( s ) || s.replace( snre , ' ' ).replace( sre , '' ) || 0 ;\t// jshint ignore:line\n\t\t} ,\n\t\toFxNcL , oFyNcL ;\n\t// first try and sort Hex codes or Dates\n\tif ( yD ) {\n\t\tif ( xD < yD ) { return -1 ; }\n\t\telse if ( xD > yD ) { return 1 ; }\n\t}\n\t// natural sorting through split numeric strings and default strings\n\tfor( var cLoc = 0 , xNl = xN.length , yNl = yN.length , numS = Math.max( xNl , yNl ) ; cLoc < numS ; cLoc ++ ) {\n\t\toFxNcL = normChunk( xN[cLoc] , xNl ) ;\n\t\toFyNcL = normChunk( yN[cLoc] , yNl ) ;\n\t\t// handle numeric vs string comparison - number < string - (Kyle Adams)\n\t\tif ( isNaN( oFxNcL ) !== isNaN( oFyNcL ) ) { return ( isNaN( oFxNcL ) ) ? 1 : -1 ; }\n\t\t// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\n\t\telse if ( typeof oFxNcL !== typeof oFyNcL ) {\n\t\t\toFxNcL += '' ;\n\t\t\toFyNcL += '' ;\n\t\t}\n\t\tif ( oFxNcL < oFyNcL ) { return -1 ; }\n\t\tif ( oFxNcL > oFyNcL ) { return 1 ; }\n\t}\n\treturn 0 ;\n} ;\n\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar stringKit = {} ;\nmodule.exports = stringKit ;\n\n\n\n// Tier 0: add polyfills to stringKit\nvar fn_ ;\nvar polyfill = require( './polyfill.js' ) ;\n\nfor ( fn_ in polyfill ) {\n\tstringKit[ fn_ ] = function( str , ... args ) {\n\t\treturn polyfill[ fn_ ].call( str , ... args ) ;\n\t} ;\n}\n\n\n\nObject.assign( stringKit ,\n\n\t// Tier 1\n\t{ escape: require( './escape.js' ) } ,\n\t{ ansi: require( './ansi.js' ) } ,\n\t{ unicode: require( './unicode.js' ) }\n) ;\n\n\n\nObject.assign( stringKit ,\n\n\t// Tier 2\n\trequire( './format.js' ) ,\n\n\t// Tier 3\n\trequire( './misc.js' ) ,\n\trequire( './inspect.js' ) ,\n\trequire( './regexp.js' ) ,\n\trequire( './camel.js' ) ,\n\t{\n\t\tlatinize: require( './latinize.js' ) ,\n\t\ttoTitleCase: require( './toTitleCase.js' ) ,\n\t\twordwrap: require( './wordwrap.js' ) ,\n\t\tnaturalSort: require( './naturalSort.js' ) ,\n\t\tfuzzy: require( './fuzzy.js' ) ,\n\t\tStringNumber: require( './StringNumber.js' )\n\t}\n) ;\n\n\n\n// Install all polyfill into String.prototype\nstringKit.installPolyfills = function installPolyfills() {\n\tvar fn ;\n\n\tfor ( fn in polyfill ) {\n\t\tif ( ! String.prototype[ fn ] ) {\n\t\t\tString.prototype[ fn ] = polyfill[ fn ] ;\n\t\t}\n\t}\n} ;\n\n", "{\n  \"name\": \"string-kit\",\n  \"version\": \"0.12.7\",\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  },\n  \"description\": \"A string manipulation toolbox, featuring a string formatter (inspired by sprintf), a variable inspector (output featuring ANSI colors and HTML) and various escape functions (shell argument, regexp, html, etc).\",\n  \"main\": \"lib/string.js\",\n  \"directories\": {\n    \"test\": \"test\",\n    \"bench\": \"bench\"\n  },\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"tea-time -R dot\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/cronvel/string-kit.git\"\n  },\n  \"keywords\": [\n    \"string\",\n    \"manipulation\",\n    \"format\",\n    \"sprintf\",\n    \"printf\",\n    \"inspect\",\n    \"color\",\n    \"debug\",\n    \"dump\",\n    \"escape\",\n    \"shell\",\n    \"regexp\",\n    \"html\"\n  ],\n  \"author\": \"C\u00e9dric Ronvel\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cronvel/string-kit/issues\"\n  },\n  \"config\": {\n    \"tea-time\": {\n      \"coverDir\": [\n        \"lib\"\n      ]\n    }\n  },\n  \"copyright\": {\n    \"title\": \"String Kit\",\n    \"years\": [\n      2014,\n      2021\n    ],\n    \"owner\": \"C\u00e9dric Ronvel\"\n  }\n}\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n/* global describe, it, expect */\n\n\"use strict\" ;\n\n\n\nconst string = require( '..' ) ;\n\n\n\ndescribe( \"format()\" , () => {\n\n\tvar ansi = string.ansi ;\n\tvar format = string.format ;\n\tvar formatMethod = string.formatMethod ;\n\n\tit( \"should perform basic examples\" , () => {\n\t\texpect( format( 'Hello world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s' , 'world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , 'Joe' , 'Doe' ) ).to.be( 'Hello Joe Doe, how are you?' ) ;\n\t\texpect( format( 'I have %i cookies.' , 3 ) ).to.be( 'I have 3 cookies.' ) ;\n\t\texpect( format( 'This company regains %d%% of market share.' , 36 ) ).to.be( 'This company regains 36% of market share.' ) ;\n\t\texpect( format( '11/8=%f' , 11 / 8 ) ).to.be( '11/8=1.375' ) ;\n\t\texpect( format( 'Binary %b %b' , 11 , 123 ) ).to.be( 'Binary 1011 1111011' ) ;\n\t\texpect( format( 'Octal %o %o' , 11 , 123 ) ).to.be( 'Octal 13 173' ) ;\n\t\texpect( format( 'Hexa %h %x %x' , 11 , 11 , 123 ) ).to.be( 'Hexa b 0b 7b' ) ;\n\t\texpect( format( 'JSON %J' , { hello: 'world' , here: 'is' , my: { wonderful: 'object' } } ) ).to.be( 'JSON {\"hello\":\"world\",\"here\":\"is\",\"my\":{\"wonderful\":\"object\"}}' ) ;\n\t\texpect( format( 'Inspect %I' , { hello: 'world' , here: 'is' , my: { wonderful: 'object' } } ) ).to.be( 'Inspect <Object> <object> {\\n    hello: \"world\" <string>(5)\\n    here: \"is\" <string>(2)\\n    my: <Object> <object> {\\n        wonderful: \"object\" <string>(6)\\n    }\\n}\\n' ) ;\n\t\t//expect( format( 'Inspect %E' , new Error( 'Some error' ) ) ).to.be( '' ) ;\n\t} ) ;\n\n\tit( \"%s should format string\" , () => {\n\t\texpect( format( 'Hello %s' , 'world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , 'Joe' , 'Doe' ) ).to.be( 'Hello Joe Doe, how are you?' ) ;\n\n\t\t// Should ignore formatting: taking it as literal\n\t\texpect( format( 'Hello %s' , 'w^bor^:ld' ) ).to.be( 'Hello w^bor^:ld' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , '^rJ^go^be' , '^rD^go^be' ) ).to.be( 'Hello ^rJ^go^be ^rD^go^be, how are you?' ) ;\n\t} ) ;\n\n\tit( \"%s padding syntax\" , () => {\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. #2' ) ).to.be( 'Cat. #1   Cat. #2' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. #2' ) ).to.be( 'Cat. #1Cat. #2   ' ) ;\n\t\t\n\t\t// Truncate\n\t\texpect( format( 'Cat. #1%[L10]s' , 'this is way to big' ) ).to.be( 'Cat. #1this is w\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[L10]s' , 'that was way to big' ) ).to.be( 'Cat. #1 that was\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'this is way to big' ) ).to.be( 'Cat. #1this is w\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'that was way to big' ) ).to.be( 'Cat. #1that was\u2026 ' ) ;\n\n\t\t// Unicode length/width\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. \ud87e\udc09' ) ).to.be( 'Cat. #1   Cat. \ud87e\udc09' ) ;\t// \ud87e\udc09 have length and width of 2\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. \uff20' ) ).to.be( 'Cat. #1   Cat. \uff20' ) ;\t// \uff20 have length of 1 but width of 2\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. \ud87e\udc09' ) ).to.be( 'Cat. #1Cat. \ud87e\udc09   ' ) ;\t// \ud87e\udc09 have length and width of 2\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. \uff20' ) ).to.be( 'Cat. #1Cat. \uff20   ' ) ;\t// \uff20 have length of 1 but width of 2\n\t} ) ;\n\n\tit( \"common mode arg padding\" , () => {\n\t\texpect( format( '%[L6]f' , 12.34 ) ).to.be( ' 12.34' ) ;\n\t\texpect( format( '%[L6]f' , -12.34 ) ).to.be( '-12.34' ) ;\n\t\texpect( format( '%[L8z3]f' , 12.34 ) ).to.be( '  012.34' ) ;\n\t\texpect( format( '%[L8z3]f' , -12.34 ) ).to.be( ' -012.34' ) ;\n\t\texpect( format( '%[.0L5]f' , 12.34 ) ).to.be( '   12' ) ;\n\t\texpect( format( '%[.0L5]f' , -12.34 ) ).to.be( '  -12' ) ;\n\n\t\texpect( format( '%[R6]f' , 12.34 ) ).to.be( '12.34 ' ) ;\n\t\texpect( format( '%[R6]f' , -12.34 ) ).to.be( '-12.34' ) ;\n\t\texpect( format( '%[R8z3]f' , 12.34 ) ).to.be( '012.34  ' ) ;\n\t\texpect( format( '%[R8z3]f' , -12.34 ) ).to.be( '-012.34 ' ) ;\n\t\texpect( format( '%[.0R5]f' , 12.34 ) ).to.be( '12   ' ) ;\n\t\texpect( format( '%[.0R5]f' , -12.34 ) ).to.be( '-12  ' ) ;\n\t} ) ;\n\t\n\tit( \"%S should format string and interpret ^ formatting\" , () => {\n\t\texpect( format( 'Hello %S' , 'w^bor^:ld' ) ).to.be( 'Hello w\\x1b[34mor\\x1b[0mld\\x1b[0m' ) ;\n\t\texpect( format( 'Hello %S %S, how are you?' , '^rJ^go^be' , '^rD^go^be' ) ).to.be( 'Hello \\x1b[31mJ\\x1b[32mo\\x1b[34me\\x1b[0m \\x1b[31mD\\x1b[32mo\\x1b[34me\\x1b[0m, how are you?' ) ;\n\t} ) ;\n\n\tit( \"%X should turn a string into hexadecimal\" , () => {\n\t\texpect( format( '%X' , 'hello' ) ).to.be( '68656c6c6f' ) ;\n\t\texpect( format( 'Hello %X' , 'w' ) ).to.be( 'Hello 77' ) ;\n\t\texpect( format( 'Hello %X' , 'world' ) ).to.be( 'Hello 776f726c64' ) ;\n\t\texpect( format( 'Hello %X' , 'C\u00e9dric' ) ).to.be( 'Hello 43c3a964726963' ) ;\n\t\texpect( format( 'Hello %X' , Buffer.from( 'C\u00e9dric' ) ) ).to.be( 'Hello 43c3a964726963' ) ;\n\t} ) ;\n\n\tit( \"argument sanitizing\" , () => {\n\t\texpect( format( 'Some string: %s' , 'one\\ntwo' ) ).to.be( 'Some string: one\\ntwo' ) ;\n\t\texpect( format( 'Some string: %s' , 'one\\x00two' ) ).to.be( 'Some string: one\\\\x00two' ) ;\n\t\texpect( format( 'Some string: %s' , 'one\\n\\x00two' ) ).to.be( 'Some string: one\\n\\\\x00two' ) ;\n\t} ) ;\n\n\tit( \"%u should format unsigned integer\" , () => {\n\t\texpect( format( '%u' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%u' , 0 ) ).to.be( '0' ) ;\n\t\texpect( format( '%u' , -123 ) ).to.be( '0' ) ;\n\t\texpect( format( '%u' ) ).to.be( '0' ) ;\n\t} ) ;\n\n\tit( \"%U should format *positive* unsigned integer\" , () => {\n\t\texpect( format( '%U' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%U' , 0 ) ).to.be( '1' ) ;\n\t\texpect( format( '%U' , -123 ) ).to.be( '1' ) ;\n\t\texpect( format( '%U' ) ).to.be( '1' ) ;\n\t} ) ;\n\n\tit( \"%f should format floating point numbers\" , () => {\n\t\texpect( format( '%f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\t\texpect( format( '%f' , 0.00123456789 ) ).to.be( '0.00123456789' ) ;\n\t} ) ;\n\t\n\tit( \"%f group separator syntax\" , () => {\n\t\texpect( format( '%[g]f' , 12345.6789 ) ).to.be( '12 345.6789' ) ;\n\t\texpect( format( '%[g ]f' , 12345.6789 ) ).to.be( '12 345.6789' ) ;\n\t\texpect( format( '%[g,]f' , 12345.6789 ) ).to.be( '12,345.6789' ) ;\n\t\texpect( format( \"%[g']f\" , 12345.6789 ) ).to.be( \"12'345.6789\" ) ;\n\t\texpect( format( '%[g_]f' , 12345.6789 ) ).to.be( '12_345.6789' ) ;\n\n\t\texpect( format( '%[g]f' , 1 ) ).to.be( '1' ) ;\n\t\texpect( format( '%[g]f' , 12 ) ).to.be( '12' ) ;\n\t\texpect( format( '%[g]f' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%[g]f' , 1234 ) ).to.be( '1 234' ) ;\n\t\texpect( format( '%[g]f' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%[g]f' , 123456 ) ).to.be( '123 456' ) ;\n\t\texpect( format( '%[g]f' , 1234567 ) ).to.be( '1 234 567' ) ;\n\t\texpect( format( '%[g]f' , 12345678 ) ).to.be( '12 345 678' ) ;\n\t\texpect( format( '%[g]f' , 123456789 ) ).to.be( '123 456 789' ) ;\n\t\texpect( format( '%[g]f' , 1234567891 ) ).to.be( '1 234 567 891' ) ;\n\n\t\texpect( format( '%[g]f' , 0.1234 ) ).to.be( '0.1234' ) ;\n\t} ) ;\n\t\n\tit( \"%f precision syntax\" , () => {\n\t\texpect( format( '%[1]f' , 12345.6789 ) ).to.be( '10000' ) ;\n\t\texpect( format( '%[2]f' , 12345.6789 ) ).to.be( '12000' ) ;\n\t\texpect( format( '%[3]f' , 12345.6789 ) ).to.be( '12300' ) ;\n\t\texpect( format( '%[4]f' , 12345.6789 ) ).to.be( '12350' ) ;\n\t\texpect( format( '%[5]f' , 12345.6789 ) ).to.be( '12346' ) ;\n\t\texpect( format( '%[6]f' , 12345.6789 ) ).to.be( '12345.7' ) ;\n\t\texpect( format( '%[7]f' , 12345.6789 ) ).to.be( '12345.68' ) ;\n\t\texpect( format( '%[8]f' , 12345.6789 ) ).to.be( '12345.679' ) ;\n\t\texpect( format( '%[9]f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\t\texpect( format( '%[10]f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\n\t\texpect( format( '%[1]f' , 0.1234 ) ).to.be( '0.1' ) ;\n\t\texpect( format( '%[2]f' , 0.1234 ) ).to.be( '0.12' ) ;\n\t\texpect( format( '%[3]f' , 0.1234 ) ).to.be( '0.123' ) ;\n\n\t\texpect( format( '%[1]f' , 0.001234 ) ).to.be( '0.001' ) ;\n\t\texpect( format( '%[2]f' , 0.001234 ) ).to.be( '0.0012' ) ;\n\t\texpect( format( '%[3]f' , 0.001234 ) ).to.be( '0.00123' ) ;\n\t} ) ;\n\t\n\tit( \"%f integer rounding syntax\" , () => {\n\t\texpect( format( '%[1.]f' , 12345.6789 ) ).to.be( '12350' ) ;\n\t\texpect( format( '%[2.]f' , 12345.6789 ) ).to.be( '12300' ) ;\n\t\texpect( format( '%[3.]f' , 12345.6789 ) ).to.be( '12000' ) ;\n\t\texpect( format( '%[4.]f' , 12345.6789 ) ).to.be( '10000' ) ;\n\t\texpect( format( '%[5.]f' , 12345.6789 ) ).to.be( '0' ) ;\n\t} ) ;\n\t\n\tit( \"%f decimal rounding syntax\" , () => {\n\t\texpect( format( '%[.0]f' , 12345.6789 ) ).to.be( '12346' ) ;\n\t\texpect( format( '%[.1]f' , 12345.6789 ) ).to.be( '12345.7' ) ;\n\t\texpect( format( '%[.2]f' , 12345.6789 ) ).to.be( '12345.68' ) ;\n\t\texpect( format( '%[.3]f' , 12345.6789 ) ).to.be( '12345.679' ) ;\n\n\t\texpect( format( '%[.2]f' , 12345 ) ).to.be( '12345' ) ;\n\t\texpect( format( '%[.2]f' , 12345.6 ) ).to.be( '12345.6' ) ;\n\t} ) ;\n\n\tit( \"%f decimal rounding artifact\" , () => {\n\t\t// JS artifact, without the StringNumber class, it is impossible to get this working unless breaking anything else:\n\t\texpect( format( '%[.5]f' , 1000000 ) ).to.be( '1000000' ) ;\n\t} ) ;\n\t\n\tit( \"%f decimal rounding syntax forcing 0 padding after decimal\" , () => {\n\t\texpect( format( '%[.2!]f' , 12.523 ) ).to.be( '12.52' ) ;\n\t\texpect( format( '%[.2!]f' , 12.5 ) ).to.be( '12.50' ) ;\n\t\texpect( format( '%[.2!]f' , 12 ) ).to.be( '12.00' ) ;\n\t} ) ;\n\n\tit( \"%f decimal rounding syntax forcing 0 padding after decimal only if there is decimal\" , () => {\n\t\texpect( format( '%[.2?]f' , 12.523 ) ).to.be( '12.52' ) ;\n\t\texpect( format( '%[.2?]f' , 12.5 ) ).to.be( '12.50' ) ;\n\t\texpect( format( '%[.2?]f' , 12 ) ).to.be( '12' ) ;\n\t} ) ;\n\t\n\tit( \"%f zero-left-padding syntax\" , () => {\n\t\texpect( format( '%[z3]f' , 12.34 ) ).to.be( '012.34' ) ;\n\t\texpect( format( '%[z5]f' , 12.34 ) ).to.be( '00012.34' ) ;\n\t\texpect( format( '%[.0z5]f' , 12.34 ) ).to.be( '00012' ) ;\n\t\t\n\t\t// That nasty minus bug...\n\t\texpect( format( '%[z3]f' , -12.34 ) ).to.be( '-012.34' ) ;\n\t\texpect( format( '%[z5]f' , -12.34 ) ).to.be( '-00012.34' ) ;\n\t\texpect( format( '%[.0z5]f' , -12.34 ) ).to.be( '-00012' ) ;\n\n\t\t// Forcing no zero before the dot\n\t\texpect( format( '%[z0]f' , 0.1234 ) ).to.be( '.1234' ) ;\n\t\texpect( format( '%[z0]f' , 0.001234 ) ).to.be( '.001234' ) ;\n\t} ) ;\n\t\n\tit( \"%e exponential notation\" , () => {\n\t\texpect( format( '%e' , 0.001234 ) ).to.be( '1.234e-3' ) ;\n\t\texpect( format( '%e' , 0.01234 ) ).to.be( '1.234e-2' ) ;\n\t\texpect( format( '%e' , 0.1234 ) ).to.be( '1.234e-1' ) ;\n\t\texpect( format( '%e' , 1.234 ) ).to.be( '1.234e+0' ) ;\n\t\texpect( format( '%e' , 12.34 ) ).to.be( '1.234e+1' ) ;\n\t\texpect( format( '%e' , 123.4 ) ).to.be( '1.234e+2' ) ;\n\t\texpect( format( '%e' , 1234 ) ).to.be( '1.234e+3' ) ;\n\n\t\t// Precision\n\t\texpect( format( '%[2]e' , 123.4 ) ).to.be( '1.2e+2' ) ;\n\t\texpect( format( '%[3]e' , 123.4 ) ).to.be( '1.23e+2' ) ;\n\n\t\t// With padding\n\t\texpect( format( '%[2L7]e' , 123.4 ) ).to.be( ' 1.2e+2' ) ;\n\n\t\t// Rounding (make no sense with scientific notation, but it works)\n\t\texpect( format( '%[.2]e' , 123.4567 ) ).to.be( '1.2346e+2' ) ;\n\t\texpect( format( '%[.1]e' , 123.4567 ) ).to.be( '1.235e+2' ) ;\n\t\texpect( format( '%[1.]e' , 123.4567 ) ).to.be( '1.2e+2' ) ;\n\t} ) ;\n\t\n\tit( \"%K scientific notation\" , () => {\n\t\texpect( format( '%K' , 0.001234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b3' ) ;\n\t\texpect( format( '%K' , 0.01234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b2' ) ;\n\t\texpect( format( '%K' , 0.1234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b9' ) ;\n\t\texpect( format( '%K' , 1.234 ) ).to.be( '1.234 \u00d7 10\u2070' ) ;\n\t\texpect( format( '%K' , 12.34 ) ).to.be( '1.234 \u00d7 10\u00b9' ) ;\n\t\texpect( format( '%K' , 123.4 ) ).to.be( '1.234 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%K' , 1234 ) ).to.be( '1.234 \u00d7 10\u00b3' ) ;\n\n\t\t// Precision\n\t\texpect( format( '%[2]K' , 123.4 ) ).to.be( '1.2 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[3]K' , 123.4 ) ).to.be( '1.23 \u00d7 10\u00b2' ) ;\n\n\t\t// With padding\n\t\texpect( format( '%[2L11]K' , 123.4 ) ).to.be( '  1.2 \u00d7 10\u00b2' ) ;\n\n\t\t// Rounding (make no sense with scientific notation, but it works)\n\t\texpect( format( '%[.2]K' , 123.4567 ) ).to.be( '1.2346 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[.1]K' , 123.4567 ) ).to.be( '1.235 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[1.]K' , 123.4567 ) ).to.be( '1.2 \u00d7 10\u00b2' ) ;\n\t} ) ;\n\t\n\tit( \"%P should format with (absolute) percent\" , () => {\n\t\texpect( format( '%P' , 2 ) ).to.be( '200%' ) ;\n\t\texpect( format( '%P' , 1 ) ).to.be( '100%' ) ;\n\t\texpect( format( '%P' , 0 ) ).to.be( '0%' ) ;\n\t\texpect( format( '%P' , -1 ) ).to.be( '-100%' ) ;\n\t\texpect( format( '%P' , 1.23 ) ).to.be( '123%' ) ;\n\t\texpect( format( '%P' , 0.45 ) ).to.be( '45%' ) ;\n\n\t\texpect( format( '%P' , 0.12345 ) ).to.be( '12%' ) ;\n\t\texpect( format( '%[.1]P' , 0.12345 ) ).to.be( '12.3%' ) ;\n\n\t\texpect( format( '%[.1]P' , 0.00345 ) ).to.be( '0.3%' ) ;\n\t\texpect( format( '%[.1z0]P' , 0.00345 ) ).to.be( '.3%' ) ;\n\n\t\t// Check that setting up precision bypass the default rounding\n\t\texpect( format( '%[4]P' , 0.9975 ) ).to.be( '99.75%' ) ;\n\t\texpect( format( '%[5]P' , 1.2345 ) ).to.be( '123.45%' ) ;\n\t} ) ;\n\n\tit( \"%p should format with relative percent\" , () => {\n\t\texpect( format( '%p' , 2 ) ).to.be( '+100%' ) ;\n\t\texpect( format( '%p' , 1 ) ).to.be( '+0%' ) ;\n\t\texpect( format( '%p' , 0 ) ).to.be( '-100%' ) ;\n\t\texpect( format( '%p' , -1 ) ).to.be( '-200%' ) ;\n\t\texpect( format( '%p' , 1.23 ) ).to.be( '+23%' ) ;\n\t\texpect( format( '%p' , 0.45 ) ).to.be( '-55%' ) ;\n\n\t\texpect( format( '%p' , 1.2345 ) ).to.be( '+23%' ) ;\n\t\texpect( format( '%[.1]p' , 1.2345 ) ).to.be( '+23.4%' ) ;\n\t\texpect( format( '%p' , 0.12345 ) ).to.be( '-88%' ) ;\n\t\texpect( format( '%[.1]p' , 0.12345 ) ).to.be( '-87.7%' ) ;\n\n\t\texpect( format( '%[.1]p' , 1.00345 ) ).to.be( '+0.3%' ) ;\n\t\texpect( format( '%[.1z0]p' , 1.00345 ) ).to.be( '+.3%' ) ;\n\t\texpect( format( '%[.1]p' , 0.997 ) ).to.be( '-0.3%' ) ;\n\t\texpect( format( '%[.1z0]p' , 0.997 ) ).to.be( '-.3%' ) ;\n\n\t\t// Check that setting up precision bypass the default rounding\n\t\texpect( format( '%[4]p' , 0.9975 ) ).to.be( '-0.25%' ) ;\n\t\texpect( format( '%[5]p' , 1.2345 ) ).to.be( '+23.45%' ) ;\n\t} ) ;\n\n\tit( \"%k should format with multipliers\" , () => {\n\t\texpect( format( '%k' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%k' , 1234 ) ).to.be( '1.23k' ) ;\n\t\texpect( format( '%k' , 12345 ) ).to.be( '12.3k' ) ;\n\t\texpect( format( '%k' , 123456 ) ).to.be( '123k' ) ;\n\t\texpect( format( '%k' , 1.2345 ) ).to.be( '1.23' ) ;\n\t\texpect( format( '%k' , 12.345 ) ).to.be( '12.3' ) ;\n\t\texpect( format( '%k' , 123.45 ) ).to.be( '123' ) ;\n\t\texpect( format( '%k' , 1000 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 1001 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 1005 ) ).to.be( '1.01k' ) ;\n\t\texpect( format( '%k' , 999.999 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 999.499 ) ).to.be( '999' ) ;\n\t\texpect( format( '%k' , 0.999 ) ).to.be( '999m' ) ;\n\t\texpect( format( '%k' , 0.0999 ) ).to.be( '99.9m' ) ;\n\t\texpect( format( '%k' , 0.00999 ) ).to.be( '9.99m' ) ;\n\t\texpect( format( '%k' , 0.000999 ) ).to.be( '999\u00b5' ) ;\n\t\texpect( format( '%k' , 0.0000999 ) ).to.be( '99.9\u00b5' ) ;\n\t\texpect( format( '%k' , 0.00000999 ) ).to.be( '9.99\u00b5' ) ;\n\t\texpect( format( '%k' , 0.00000000999 ) ).to.be( '9.99n' ) ;\n\t\texpect( format( '%k' , 0.00000000000999 ) ).to.be( '9.99p' ) ;\n\t\texpect( format( '%k' , 0.00000000000000999 ) ).to.be( '9.99f' ) ;\n\t\texpect( format( '%k' , 123400 ) ).to.be( '123k' ) ;\n\t\texpect( format( '%k' , 123400000 ) ).to.be( '123M' ) ;\n\t\texpect( format( '%k' , 123400000000 ) ).to.be( '123G' ) ;\n\t\texpect( format( '%k' , 123400000000000 ) ).to.be( '123T' ) ;\n\t\texpect( format( '%k' , 123400000000000000 ) ).to.be( '123P' ) ;\n\t\texpect( format( '%k' , 123400000000000000000 ) ).to.be( '123E' ) ;\n\t\texpect( format( '%k' , -12.345 ) ).to.be( '-12.3' ) ;\n\t\texpect( format( '%k' , -123400000 ) ).to.be( '-123M' ) ;\n\t\texpect( format( '%k' , -0.00000000999 ) ).to.be( '-9.99n' ) ;\n\n\t\t// With modes\n\t\texpect( format( '%[4]k' , 1234 ) ).to.be( '1.234k' ) ;\n\t} ) ;\n\n\tit( \"%m degree minute seconds notation\" , () => {\n\t\texpect( format( '%m' , 0 ) ).to.be( '0\u00b0' ) ;\n\t\texpect( format( '%m' , 10 ) ).to.be( '10\u00b0' ) ;\n\t\texpect( format( '%m' , -10 ) ).to.be( '-10\u00b0' ) ;\n\t\texpect( format( '%m' , 1 + 17 / 60 ) ).to.be( '1\u00b017\u2032' ) ;\n\t\texpect( format( '%m' , 1 + 1 / 60 + 1 / 3600 ) ).to.be( '1\u00b001\u203201\u2033' ) ;\n\t\texpect( format( '%m' , 1 + 59 / 60 + 59 / 3600 ) ).to.be( '1\u00b059\u203259\u2033' ) ;\n\t\texpect( format( '%m' , - ( 1 + 59 / 60 + 59 / 3600 ) ) ).to.be( '-1\u00b059\u203259\u2033' ) ;\n\t} ) ;\n\t\n\tit( \"%t should format time duration\" , () => {\n\t\texpect( format( '%t' , 1000 ) ).to.be( '1s' ) ;\n\t\texpect( format( '%t' , 1234 ) ).to.be( '1s' ) ;\n\t\texpect( format( '%t' , 56789 ) ).to.be( '56s' ) ;\n\t\texpect( format( '%t' , 60000 ) ).to.be( '1min00s' ) ;\n\t\texpect( format( '%t' , 123456 ) ).to.be( '2min03s' ) ;\n\t\texpect( format( '%t' , 3600000 ) ).to.be( '1h00min00s' ) ;\n\t\texpect( format( '%t' , 3599999 ) ).to.be( '59min59s' ) ;\n\t\texpect( format( '%t' , 7890000 ) ).to.be( '2h11min30s' ) ;\n\t} ) ;\n\n\tit( \"%z should format as base64\" , () => {\n\t\texpect( format( '%z' , 'some text' ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%z' , Buffer.from( 'some text' ) ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%z' , 'some longer text' ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA==' ) ;\n\t\texpect( format( '%z' , Buffer.from( 'some longer text' ) ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA==' ) ;\n\t\texpect( format( '%z' , Buffer.from( '+/c=' , 'base64' ) ) ).to.be( '+/c=' ) ;\n\t} ) ;\n\n\tit( \"%Z should format as base64-url\" , () => {\n\t\texpect( format( '%Z' , 'some text' ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%Z' , Buffer.from( 'some text' ) ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%Z' , 'some longer text' ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA' ) ;\n\t\texpect( format( '%Z' , Buffer.from( 'some longer text' ) ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA' ) ;\n\t\texpect( format( '%Z' , Buffer.from( '+/c=' , 'base64' ) ) ).to.be( '-_c' ) ;\n\t} ) ;\n\n\tit( \"should perform well the argument's index feature\" , () => {\n\t\texpect( format( '%s%s%s' , 'A' , 'B' , 'C' ) ).to.be( 'ABC' ) ;\n\t\texpect( format( '%+1s%-1s%s' , 'A' , 'B' , 'C' ) ).to.be( 'BAC' ) ;\n\t\texpect( format( '%3s%s' , 'A' , 'B' , 'C' ) ).to.be( 'CBC' ) ;\n\t} ) ;\n\n\tit( \"%n natural\" , () => {\n\t\texpect( format( '%n' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%n' , 1.23456789 ) ).to.be( '1.235' ) ;\n\t\texpect( format( '%n' , true ) ).to.be( 'true' ) ;\n\t\texpect( format( '%n' , false ) ).to.be( 'false' ) ;\n\t\texpect( format( '%n' , null ) ).to.be( 'null' ) ;\n\n\t\texpect( format( '%n' , [ 'one' , 'two' , 'three' ] ) ).to.be( '[one,two,three]' ) ;\n\t\t\n\t\t// Object and key sorting\n\t\texpect( format( '%n' , { bob: 3 , alice: 4 , john: 2 , jack: 3 } ) ).to.be( '{alice: 4, bob: 3, jack: 3, john: 2}' ) ;\n\t} ) ;\n\n\tit( \"%N more natural\" , () => {\n\t\texpect( format( '%N' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%N' , 1.23456789 ) ).to.be( '1.235' ) ;\n\t\texpect( format( '%N' , true ) ).to.be( 'true' ) ;\n\t\texpect( format( '%N' , false ) ).to.be( 'false' ) ;\n\t\texpect( format( '%N' , null ) ).to.be( 'null' ) ;\n\n\t\texpect( format( '%N' , [ 'one' , 'two' , 'three' ] ) ).to.be( 'one, two, three' ) ;\n\n\t\t// Object and key sorting\n\t\texpect( format( '%N' , { bob: 3 , alice: 4 , john: 2 , jack: 3 } ) ).to.be( 'alice: 4, bob: 3, jack: 3, john: 2' ) ;\n\t} ) ;\n\t\n\tit( \"format.count() should count the number of arguments found\" , () => {\n\t\texpect( format.count( 'blah blih blah' ) ).to.be( 0 ) ;\n\t\texpect( format.count( 'blah blih %% blah' ) ).to.be( 0 ) ;\n\t\texpect( format.count( '%i %s' ) ).to.be( 2 ) ;\n\t\texpect( format.count( '%1i %1s' ) ).to.be( 1 ) ;\n\t\texpect( format.count( '%5i' ) ).to.be( 5 ) ;\n\t\texpect( format.count( '%[unexistant]F' ) ).to.be( 0 ) ;\n\t\texpect( format.count( '%[unexistant:%a%a]F' ) ).to.be( 2 ) ;\n\t} ) ;\n\n\tit( \"format.hasFormatting() should return true if the string has formatting and thus need to be interpreted, or false otherwise\" , () => {\n\t\texpect( format.hasFormatting( 'blah blih blah' ) ).to.be( false ) ;\n\t\texpect( format.hasFormatting( 'blah blih %% blah' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%i %s' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%[unexistant]F' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%[unexistant:%a%a]F' ) ).to.be( true ) ;\n\t} ) ;\n\n\tit( \"when using a filter object as the *this* context, the %[functionName]F format should use a custom function to format the input\" , () => {\n\t\tvar customFormat = string.createFormatter( {\n\t\t\tfn: {\n\t\t\t\tfixed: function() { return 'f' ; } ,\n\t\t\t\tdouble: function( str ) { return '' + str + str ; } ,\n\t\t\t\tfxy: function( a , b ) { return '' + ( a * a + b ) ; }\n\t\t\t}\n\t\t} ) ;\n\n\t\texpect( customFormat( '%[fixed]F' ) ).to.be( 'f' ) ;\n\t\texpect( customFormat( '%[fixed]F%s%s%s' , 'A' , 'B' , 'C' ) ).to.be( 'fABC' ) ;\n\t\texpect( customFormat( '%s%[fxy:%a%a]F' , 'f(x,y)=' , 5 , 3 ) ).to.be( 'f(x,y)=28' ) ;\n\t\texpect( customFormat( '%s%[fxy:%+1a%-1a]F' , 'f(x,y)=' , 5 , 3 ) ).to.be( 'f(x,y)=14' ) ;\n\t\texpect( customFormat( '%[unexistant]F' ) ).to.be( '' ) ;\n\t} ) ;\n\n\tit( \"'^' should add markup, defaulting to ansi markup\" , () => {\n\t\texpect( format( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( format( 'this is ^_underlined^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^_underlined^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^_underlined^:this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + 'this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^Bblue^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^Bblue^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"'^' markups are ignored when then 'noMarkup' option is on\" , () => {\n\t\tvar customFormat = string.createFormatter( { noMarkup: true } ) ;\n\n\t\texpect( customFormat( 'this is ^^ a caret' ) ).to.be( 'this is ^^ a caret' ) ;\n\t\texpect( customFormat( 'this is ^_underlined' ) ).to.be( 'this is ^_underlined' ) ;\n\t\texpect( customFormat( 'this is ^_underlined^: nope' ) ).to.be( 'this is ^_underlined^: nope' ) ;\n\t} ) ;\n\n\tit( \"'^' markup: shift feature\" , () => {\n\t\texpect( format( 'this background is ^#^bblue^ this is ^wwhite' ) )\n\t\t\t.to.be( 'this background is ' + ansi.bgBlue + 'blue' + ansi.reset + ' this is ' + ansi.white + 'white' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"should expose a stand-alone markup only method\" , () => {\n\t\texpect( string.markup( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( string.markup( 'this is ^_underlined^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^_underlined^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^_underlined^:this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + 'this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^Bblue^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^Bblue^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\n\t\t// format syntax should be ignored\n\t\texpect( string.markup( 'this is ^Bblue^ this is not %d' , 5 ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not %d' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"should expose a stand-alone markup only method\" , () => {\n\t\tvar wwwFormatter = {\n\t\t\tendingMarkupReset: true ,\n\t\t\tmarkupReset: function( markupStack ) {\n\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\treturn str ;\n\t\t\t} ,\n\t\t\tmarkup: {\n\t\t\t\t\":\": function( markupStack ) {\n\t\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\t\treturn str ;\n\t\t\t\t} ,\n\t\t\t\t\" \": function( markupStack ) {\n\t\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\t\treturn str + ' ' ;\n\t\t\t\t} ,\n\n\t\t\t\t\"+\": '<span style=\"font-weight:bold\">' ,\n\t\t\t\t\"b\": '<span style=\"color:blue\">'\n\t\t\t}\n\t\t} ;\n\n\t\tvar wwwMarkup = string.markupMethod.bind( wwwFormatter ) ;\n\t\tvar wwwFormat = string.formatMethod.bind( wwwFormatter ) ;\n\n\t\texpect( wwwMarkup( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^: this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span> this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^ this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span> this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^:this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span>this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^b^+blue bold' ) )\n\t\t\t.to.be( 'this is <span style=\"color:blue\"><span style=\"font-weight:bold\">blue bold</span></span>' ) ;\n\n\t\texpect( wwwFormat( 'this is ^b^+blue bold' ) )\n\t\t\t.to.be( 'this is <span style=\"color:blue\"><span style=\"font-weight:bold\">blue bold</span></span>' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Escape collection\" , () => {\n\n\tit( \"escape.control() should escape control characters\" , () => {\n\t\texpect( string.escape.control( 'Hello\\n\\t... world!' ) ).to.be( 'Hello\\\\n\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\n\\\\t... world!' ) ).to.be( 'Hello\\\\n\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\\\n\\\\\\t... world!' ) ).to.be( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ).to.be( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ;\n\n\t\texpect( string.escape.control( 'Nasty\\x00chars\\x1bhere\\x7f!' ) ).to.be( 'Nasty\\\\x00chars\\\\x1bhere\\\\x7f!' ) ;\n\t\texpect( string.escape.control( 'Nasty\\n\\x00chars\\t\\x1bhere\\x7f!' ) ).to.be( 'Nasty\\\\n\\\\x00chars\\\\t\\\\x1bhere\\\\x7f!' ) ;\n\n\t\texpect( string.escape.control( 'Hello\\n\\t... world!' , true ) ).to.be( 'Hello\\n\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Nasty\\n\\x00chars\\t\\x1bhere\\x7f!' , true ) ).to.be( 'Nasty\\n\\\\x00chars\\t\\\\x1bhere\\\\x7f!' ) ;\n\t} ) ;\n\n\tit( \"escape.shellArg() should escape a string so that it will be suitable as a shell command's argument\" , () => {\n\t\t//console.log( 'Shell arg:' , string.escape.shellArg( \"Here's my shell's argument\" ) ) ;\n\t\texpect( string.escape.shellArg( \"Here's my shell's argument\" ) ).to.be( \"'Here'\\\\''s my shell'\\\\''s argument'\" ) ;\n\t} ) ;\n\n\tit( \"escape.jsSingleQuote() should escape a string so that it will be suitable as a JS string code\" , () => {\n\t\texpect( string.escape.jsSingleQuote( \"A string with 'single' quotes\" ) ).to.be( \"A string with \\\\'single\\\\' quotes\" ) ;\n\t\texpect( string.escape.jsSingleQuote( \"A string with 'single' quotes\\nand new\\nlines\" ) ).to.be( \"A string with \\\\'single\\\\' quotes\\\\nand new\\\\nlines\" ) ;\n\t} ) ;\n\n\tit( \"escape.jsDoubleQuote() should escape a string so that it will be suitable as a JS string code\" , () => {\n\t\texpect( string.escape.jsDoubleQuote( 'A string with \"double\" quotes' ) ).to.be( 'A string with \\\\\"double\\\\\" quotes' ) ;\n\t\texpect( string.escape.jsDoubleQuote( 'A string with \"double\" quotes\\nand new\\nlines' ) ).to.be( 'A string with \\\\\"double\\\\\" quotes\\\\nand new\\\\nlines' ) ;\n\t} ) ;\n\n\tit( \"escape.regExp() should escape a string so that it will be suitable as a literal string into a regular expression pattern\" , () => {\n\t\t//console.log( 'String in RegExp:' , string.escape.regExp( \"(This) {is} [my] ^$tring^... +doesn't+ *it*? |yes| \\\\no\\\\ /maybe/\" ) ) ;\n\t\texpect( string.escape.regExp( \"(This) {is} [my] ^$tring^... +doesn't+ *it*? |yes| \\\\no\\\\ /maybe/\" ) )\n\t\t\t.to.be( \"\\\\(This\\\\) \\\\{is\\\\} \\\\[my\\\\] \\\\^\\\\$tring\\\\^\\\\.\\\\.\\\\. \\\\+doesn't\\\\+ \\\\*it\\\\*\\\\? \\\\|yes\\\\| \\\\\\\\no\\\\\\\\ \\\\/maybe\\\\/\" ) ;\n\t} ) ;\n\n\tit( \"escape.regExpReplacement() should escape a string so that it will be suitable as a literal string into a regular expression replacement\" , () => {\n\t\texpect( string.escape.regExpReplacement( \"$he love$ dollar$ $$$\" ) ).to.be( \"$$he love$$ dollar$$ $$$$$$\" ) ;\n\n\t\texpect(\n\t\t\t'$he love$ dollar$ $$$'.replace(\n\t\t\t\tnew RegExp( string.escape.regExp( '$' ) , 'g' ) ,\n\t\t\t\tstring.escape.regExpReplacement( '$1' )\n\t\t\t)\n\t\t).to.be( \"$1he love$1 dollar$1 $1$1$1\" ) ;\n\t} ) ;\n\n\tit( \"escape.html() should escape a string so that it will be suitable as HTML content\" , () => {\n\t\t//console.log( string.escape.html( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.html( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn't \\\"R&amp;D\\\"\" ) ;\n\t} ) ;\n\n\tit( \"escape.htmlAttr() should escape a string so that it will be suitable as an HTML tag attribute's value\" , () => {\n\t\t//console.log( string.escape.htmlAttr( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.htmlAttr( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn't &quot;R&amp;D&quot;\" ) ;\n\t} ) ;\n\n\tit( \"escape.htmlSpecialChars() should escape all HTML special characters\" , () => {\n\t\t//console.log( string.escape.htmlSpecialChars( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.htmlSpecialChars( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn&#039;t &quot;R&amp;D&quot;\" ) ;\n\t} ) ;\n\n\tit( \"escape.unicodePercentEncoding() should escape all control chars and codepoint greater than 255 using percent encoding\" , () => {\n\t\texpect( string.escape.unicodePercentEncode( \"regular\" ) ).to.be( \"regular\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"some \u00absp\u20ac\u00a2ial\u00bb\" ) ).to.be( \"some \u00absp%E2%82%AC\u00a2ial\u00bb\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"percent % encoding\" ) ).to.be( \"percent %25 encoding\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"\\n\\t\\r\" ) ).to.be( \"%0A%09%0D\" ) ;\n\t} ) ;\n\n\tit( \"escape.httpHeaderValue()\" , () => {\n\t\texpect( string.escape.httpHeaderValue( \"regular\" ) ).to.be( \"regular\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"some \u00absp\u20ac\u00a2ial\u00bb\" ) ).to.be( \"some \u00absp%E2%82%AC\u00a2ial\u00bb\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"percent % encoding\" ) ).to.be( \"percent %25 encoding\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"\\n\\t\\r\" ) ).to.be( \"%0A%09%0D\" ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Camel case\" , () => {\n\n\tit( \".toCamelCase() should transform a string composed of alphanum - minus - underscore to a camelCase string\" , () => {\n\t\texpect( string.toCamelCase( 'one-two-three' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'one_two_three' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'OnE-tWo_tHree' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'ONE-TWO-THREE' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'a-b-c' ) ).to.be( 'aBC' ) ;\n\t} ) ;\n\n\tit( \".toCamelCase() with uppercase preservation on\" , () => {\n\t\texpect( string.toCamelCase( 'one-two-three' , true ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'one_two_three' , true ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'OnE-tWo_tHree' , true ) ).to.be( 'OnETWoTHree' ) ;\n\t\texpect( string.toCamelCase( 'onE-TWo_tHree' , true ) ).to.be( 'onETWoTHree' ) ;\n\t\texpect( string.toCamelCase( 'ONE-TWO-THREE' , true ) ).to.be( 'ONETWOTHREE' ) ;\n\t\texpect( string.toCamelCase( 'a-b-c' , true ) ).to.be( 'aBC' ) ;\n\t} ) ;\n\n\tit( \".toCamelCase() edge cases\" , () => {\n\t\texpect( string.toCamelCase( '' ) ).to.be( '' ) ;\n\t\texpect( string.toCamelCase() ).to.be( '' ) ;\n\t\texpect( string.toCamelCase( 'u' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( 'U' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( 'U-b' ) ).to.be( 'uB' ) ;\n\t\texpect( string.toCamelCase( 'U-' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( '-U' ) ).to.be( 'u' ) ;\n\t} ) ;\n\n\tit( \".camelCaseToDashed() should transform a string composed of alphanum - minus - underscore to a camelCase string\" , () => {\n\t\texpect( string.camelCaseToDashed( 'oneTwoThree' ) ).to.be( 'one-two-three' ) ;\n\t\texpect( string.camelCaseToDashed( 'OneTwoThree' ) ).to.be( 'one-two-three' ) ;\n\t\texpect( string.camelCaseToDashed( 'aBC' ) ).to.be( 'a-b-c' ) ;\n\t} ) ;\n\n\t//it( \".camelCaseToDashed() edge cases\" , function() {} ) ;\n} ) ;\n\n\n\ndescribe( \"Latinize\" , () => {\n\n\tit( \".latinize() should transform to regular latin letters without any accent\" , () => {\n\t\texpect( string.latinize( '\u00e9\u00e0\u00e8\u00f9\u00e2\u00ea\u00ee\u00f4\u00fb\u00c2\u00ca\u00ce\u00d4\u00db\u00e4\u00eb\u00ef\u00f6\u00fc\u00c4\u00cb\u00cf\u00d6\u00dc\u00e6\u00c6\u0167\u00f8\u00fe\u00df\u00f0\u0111\u0127\u0142' ) )\n\t\t\t.to.be( 'eaeuaeiouAEIOUaeiouAEIOUaeAEtothssdhdhl' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Wordwrap\" , () => {\n\n\tit( \".wordwrap() should wrap words\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , 10 ) ).to.be( 'one two\\nthree four\\nfive six\\nseven' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six seven' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six seven' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six seven' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six   ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix   ' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should preserve explicit new lines\" , () => {\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n\\n' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n\\n' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n ' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n ' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should right-trim all lines except the last\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six   ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix   ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n\\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three! four five! six \\n' , 10 ) ).to.be( '   one\\ntwo three!\\nfour five!\\nsix\\n' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should preserve space before breaking-lines\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , { width: 10 , noTrim: true } ) ).to.be( '   one    \\ntwo three\\nfour five\\nsix \\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three! four five! six \\n' , { width: 10 , noTrim: true } ) ).to.be( '   one    \\ntwo three!\\nfour five!\\nsix \\n' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'fill' option\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix       \\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( 'onetwo three four five six' , { width: 10 , fill: true } ) ).to.be( 'onetwo    \\nthree four\\nfive six' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'offset' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , offset: 5 } ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'offset' and 'updateOffset' options\" , () => {\n\t\tvar column = { width: 10 , offset: 5 , updateOffset: true } ;\n\t\texpect( string.wordwrap( 'one two three four five six seven' , column ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( column.offset ).to.be( 9 ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'glue' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , glue: '<br />\\n' } ) ).to.be( 'one two<br />\\nthree four<br />\\nfive six<br />\\nseven' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'noJoin' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , noJoin: true } ) ).to.equal( [ 'one two' , 'three four' , 'five six' , 'seven' ] ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and surrogate pairs\" , () => {\n\t\texpect( string.wordwrap( '\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06' , 9 ) ).to.be( '\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and fullwidth chars\" , () => {\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09' ) ;\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09' ) ;\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09 \ud87e\udc09 \ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\\n\ud87e\udc09 \ud87e\udc09 \ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and french typography rules with '!', '?', ':' and ';'\" , () => {\n\t\texpect( string.wordwrap( 'un ! deux ? trois : quatre ; cinq !' , 10 ) ).to.be( 'un !\\ndeux ?\\ntrois :\\nquatre ;\\ncinq !' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"inspect()\" , () => {\n\n\tit( \"should inspect a variable with default options accordingly\" , () => {\n\t\tvar MyClass = function MyClass() {\n\t\t\tthis.variable = 1 ;\n\t\t} ;\n\n\t\tMyClass.prototype.report = function report() { console.log( 'Variable value:' , this.variable ) ; } ;\n\t\tMyClass.staticFunc = function staticFunc() { console.log( 'Static function.' ) ; } ;\n\n\t\tvar sparseArray = [] ;\n\t\tsparseArray[ 3 ] = 'three' ;\n\t\tsparseArray[ 10 ] = 'ten' ;\n\t\tsparseArray[ 20 ] = 'twenty' ;\n\t\tsparseArray.customProperty = 'customProperty' ;\n\n\t\tvar object = {\n\t\t\ta: 'A' ,\n\t\t\tb: 2 ,\n\t\t\tstr: 'Woot\\nWoot\\rWoot\\tWoot' ,\n\t\t\tsub: {\n\t\t\t\tu: undefined ,\n\t\t\t\tn: null ,\n\t\t\t\tt: true ,\n\t\t\t\tf: false\n\t\t\t} ,\n\t\t\temptyString: '' ,\n\t\t\temptyObject: {} ,\n\t\t\tlist: [ 'one' , 'two' , 'three' ] ,\n\t\t\temptyList: [] ,\n\t\t\tsparseArray: sparseArray ,\n\t\t\thello: function hello() { console.log( 'Hello!' ) ; } ,\n\t\t\tanonymous: function() { console.log( 'anonymous...' ) ; } ,\n\t\t\tclass: MyClass ,\n\t\t\tinstance: new MyClass() ,\n\t\t\tbuf: Buffer.from( 'This is a buffer!' )\n\t\t} ;\n\n\t\tobject.sub.circular = object ;\n\n\t\tObject.defineProperties( object , {\n\t\t\tc: { value: '3' } ,\n\t\t\td: {\n\t\t\t\tget: function() { throw new Error( 'Should not be called by the test' ) ; } ,\n\t\t\t\tset: function( value ) {}\n\t\t\t}\n\t\t} ) ;\n\n\t\t//console.log( '>>>>>' , string.escape.control( string.inspect( object ) ) ) ;\n\t\t//console.log( string.inspect( { style: 'color' } , object ) ) ;\n\t\tvar actual = string.inspect( object ) ;\n\t\tvar expected = '<Object> <object> {\\n    a: \"A\" <string>(1)\\n    b: 2 <number>\\n    str: \"Woot\\\\nWoot\\\\rWoot\\\\tWoot\" <string>(19)\\n    sub: <Object> <object> {\\n        u: undefined\\n        n: null\\n        t: true\\n        f: false\\n        circular: <Object> <object> [circular]\\n    }\\n    emptyString: \"\" <string>(0)\\n    emptyObject: <Object> <object> {}\\n    list: <Array>(3) <object> [\\n        [0] \"one\" <string>(3)\\n        [1] \"two\" <string>(3)\\n        [2] \"three\" <string>(5)\\n        length: 3 <number> <-conf -enum>\\n    ]\\n    emptyList: <Array>(0) <object> [\\n        length: 0 <number> <-conf -enum>\\n    ]\\n    sparseArray: <Array>(21) <object> [\\n        [3] \"three\" <string>(5)\\n        [10] \"ten\" <string>(3)\\n        [20] \"twenty\" <string>(6)\\n        length: 21 <number> <-conf -enum>\\n        customProperty: \"customProperty\" <string>(14)\\n    ]\\n    hello: <Function> hello(0) <function>\\n    anonymous: <Function> anonymous(0) <function>\\n    class: <Function> MyClass(0) <function>\\n    instance: <MyClass> <object> {\\n        variable: 1 <number>\\n    }\\n    buf: <Buffer 54 68 69 73 20 69 73 20 61 20 62 75 66 66 65 72 21> <Buffer>(17)\\n    c: \"3\" <string>(1) <-conf -enum -w>\\n    d: <getter/setter> {\\n        get: <Function> get(0) <function>\\n        set: <Function> set(1) <function>\\n    }\\n}\\n' ;\n\t\t//console.log( '\\n' + expected + '\\n\\n' + actual + '\\n\\n' ) ;\n\t\texpect( actual ).to.be( expected ) ;\n\t\t//console.log( string.inspect( { style: 'color' } , object ) ) ;\n\t} ) ;\n\n\tit( \"should pass the Array circular references bug\" , () => {\n\t\tvar array = [ [ 1 ] ] ;\n\t\texpect( string.inspect( array ) ).to.be( '<Array>(1) <object> [\\n    [0] <Array>(1) <object> [\\n        [0] 1 <number>\\n        length: 1 <number> <-conf -enum>\\n    ]\\n    length: 1 <number> <-conf -enum>\\n]\\n' ) ;\n\t} ) ;\n\n\tit( \"should inspect object with no constructor\" , () => {\n\t\texpect( string.inspect( Object.assign( Object.create( null ) , { a: 1 , b: 2 } ) ) ).to.be( '<(no constructor)> <object> {\\n    a: 1 <number>\\n    b: 2 <number>\\n}\\n' ) ;\n\t} ) ;\n\n\tit( \"should use target-specified's object substitution (.inspect method) when the option 'useInspect' is set\" , () => {\n\t\tfunction Obj() {\n\t\t\tthis.name = 'bob' ;\n\t\t}\n\n\t\tObj.prototype.inspect = function() { return '<' + this.name + '>' ; } ;\n\n\t\texpect( string.inspect( { useInspect: true } , new Obj() ) ).to.be( '<Obj> <object> => <bob>\\n' ) ;\n\t} ) ;\n\n\tit( \"should use target-specified's blacklist (.inspectPropertyBlackList is a Set) when the option 'useInspectPropertyBlackList' is set\" , () => {\n\t\tfunction Obj() {\n\t\t\tthis.name = 'bob' ;\n\t\t\tthis.app = {} ;\n\t\t}\n\n\t\tObj.prototype.inspectPropertyBlackList = new Set( [ 'app' ] ) ;\n\n\t\texpect( string.inspect( { useInspectPropertyBlackList: true } , new Obj() ) ).to.be( '<Obj> <object> {\\n    name: \"bob\" <string>(3)\\n}\\n' ) ;\n\t} ) ;\n\n\tit( \"special objects tests (ES6 Set & Map, MongoDB ObjectID)\" ) ;\n} ) ;\n\n\n\ndescribe( \"Title case\" , () => {\n\n\tit( \"Basic .toTitleCase() usages\" , () => {\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell Jean-Michel' ) ;\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' , { zealous: true } ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 Allcaps Mcdowell Jean-Michel' ) ;\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' , { zealous: true , preserveAllCaps: true } ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS Mcdowell Jean-Michel' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Fuzzy string matching\" , () => {\n\n\tconst continents = [ 'africa' , 'america' , 'australia' , 'asia' , 'europe' ] ;\n\t\n\tconst things = [\n\t\t'the elven sword' ,\n\t\t'a jewel-encrusted egg' ,\n\t\t'a brass lantern' ,\n\t\t'a bag' ,\n\t\t'a lunch' ,\n\t\t'a rope' ,\n\t\t'a knife' ,\n\t\t'a throwing knife' ,\n\t\t'a bottle of water' ,\n\t\t'a rattle' ,\n\t\t'a helm' ,\n\t\t'a crossbow' ,\n\t\t'a bolt'\n\t] ;\n\t\n\tit( \"Levenshtein\" , () => {\n\t\texpect( string.fuzzy.levenshtein( 'amrica' , 'africa' ) ).to.be( 1 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'amrica' ) ).to.be( 1 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'armorica' ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'amierca' ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'bottle' , 'rattle' ) ).to.be( 2 ) ;\n\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'america' ) ).to.be( 0 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , '' ) ).to.be( 7 ) ;\n\t\texpect( string.fuzzy.levenshtein( '' , 'america' ) ).to.be( 7 ) ;\n\t\texpect( string.fuzzy.levenshtein( '' , '' ) ).to.be( 0 ) ;\n\t} ) ;\n\n\tit( \"Score\" , () => {\n\t\texpect( string.fuzzy.score( 'armorica' , 'america' ) ).to.be.around( 5 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'amrica' , 'africa' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'amrica' , 'america' ) ).to.be.around( 6 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'amierca' , 'america' ) ).to.be.around( 5 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'austia' , 'australia' ) ).to.be.around( 6 / 9 ) ;\n\t\texpect( string.fuzzy.score( 'austia' , 'asia' ) ).to.be.around( 2 / 4 ) ;\n\t\texpect( string.fuzzy.score( 'random' , 'australia' ) ).to.be.around( 1 / 9 ) ;\n\t\texpect( string.fuzzy.score( 'random' , 'africa' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( 'walter' , 'a bottle of water' ) ).to.be.around( 4 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'walter' , 'a brass lantern' ) ).to.be.around( 5 / 15 ) ;\n\t\texpect( string.fuzzy.score( 'bottle' , 'a bottle of water' ) ).to.be.around( 6 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'rattle' , 'a bottle of water' ) ).to.be.around( 4 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'rottle' , 'bottle' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'battle' , 'bottle' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'lunctern' , 'a brass lantern' ) ).to.be.around( 5 / 15 ) ;\n\t\texpect( string.fuzzy.score( 'lunctern' , 'lantern' ) ).to.be.around( 5 / 7 ) ;\n\t\t\n\t\texpect( string.fuzzy.score( 'america' , 'america' ) ).to.be.around( 1 ) ;\n\t\texpect( string.fuzzy.score( 'america' , '' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( '' , 'america' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( '' , '' ) ).to.be.around( 1 ) ;\n\t} ) ;\n\n\tit( \"Best match\" , () => {\n\t\texpect( string.fuzzy.bestMatch( 'arica' , continents ) ).to.be( 'africa' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armorica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'austrica' , continents ) ).to.be( 'australia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'ausia' , continents ) ).to.be( 'asia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'austia' , continents ) ).to.be( 'australia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'astia' , continents ) ).to.be( 'asia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'random' , continents ) ).to.be( 'australia' ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'sword' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'word' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lantern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'luntern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'luncten' , things ) ).to.be( 'a lunch' ) ;\n\t\t//expect( string.fuzzy.bestMatch( 'bottle' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'bottle' , things ) ).to.be( 'a rattle' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'water' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'walter' , things ) ).to.be( 'a brass lantern' ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'knife' , things ) ).to.be( 'a knife' ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestMatch( 'sword' , things , { indexOf: true } ) ).to.be( 0 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { indexOf: true } ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'bottle' , things , { indexOf: true } ) ).to.be( 9 ) ;\n\t} ) ;\n\n\tit( \"Best match with scoreLimit\" , () => {\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.3 } ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.4 } ) ).to.be( null ) ;\n\t\t\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.7 } ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents , { scoreLimit: 0.7 } ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.4 , indexOf: true } ) ).to.be( -1 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.7 , indexOf: true } ) ).to.be( 1 ) ;\n\t} ) ;\n\n\tit( \"Best token match\" , () => {\n\t\texpect( string.fuzzy.bestTokenMatch( 'sword' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'word' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lantern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'luntern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'luncten' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'bottle' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'water' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'a walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'some walter' , things ) ).to.be( 'a bottle of water' ) ;\n\n\t\texpect( string.fuzzy.bestTokenMatch( 'knife' , things ) ).to.be( 'a knife' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'throwing knife' , things ) ).to.be( 'a throwing knife' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'throwing' , things ) ).to.be( 'a throwing knife' ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestTokenMatch( 'some walter' , things , { indexOf: true } ) ).to.be( 8 ) ;\n\t} ) ;\n\n\tit( \"Best token match with scoreLimit\" , () => {\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things , { scoreLimit: 0.6 } ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things , { scoreLimit: 0.7 } ) ).to.be( null ) ;\n\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.7 } ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.7 , indexOf: true } ) ).to.be( 8 ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.8 , indexOf: true } ) ).to.be( -1 ) ;\n\t} ) ;\n\n\tit( \"Top match\" , () => {\n\t\texpect( string.fuzzy.topMatch( 'arica' , continents ) ).to.equal( [ 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'amrica' , continents ) ).to.equal( [ 'america' , 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'armorica' , continents ) ).to.equal( [ 'america' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'armrica' , continents ) ).to.equal( [ 'america' , 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'austrica' , continents ) ).to.equal( [ 'australia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'ausia' , continents ) ).to.equal( [ 'asia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'austia' , continents ) ).to.equal( [ 'australia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'astia' , continents ) ).to.equal( [ 'asia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'random' , continents ) ).to.equal( [ 'australia' ] ) ;\n\n\t\texpect( string.fuzzy.topMatch( 'sword' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'word' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'lantern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'luntern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'lunctern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'luncten' , things ) ).to.equal( [ 'a lunch' , 'a brass lantern' ] ) ;\n\t\t//expect( string.fuzzy.topMatch( 'bottle' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'bottle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'water' , things ) ).to.equal( [ 'a bottle of water' , 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'walter' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\n\t\texpect( string.fuzzy.topMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topMatch( 'water' , things , { indexOf: true } ) ).to.equal( [ 8 , 2 ] ) ;\n\t} ) ;\n\n\tit( \"Top token match\" , () => {\n\t\texpect( string.fuzzy.topTokenMatch( 'sword' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'word' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'lantern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'luntern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'lunctern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'luncten' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'bottle' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'rattle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'rottle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'cottle' , things ) ).to.equal( [ 'a bottle of water' , 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'cattle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'water' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'a walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'some walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topTokenMatch( 'cottle' , things , { indexOf: true } ) ).to.equal( [ 8 , 9 ] ) ;\n\t} ) ;\n\n\tit( \"Top token match with deltaRate\" , () => {\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things , { deltaRate: 0.9 } ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things , { deltaRate: 0.8 } ) ).to.equal( [ 'a knife' , 'a throwing knife' ] ) ;\n\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.6 } ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.4 } ) ).to.equal( [ 'a throwing knife' , 'a knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.4 , indexOf: true } ) ).to.equal( [ 7 , 6 ] ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Misc\" , () => {\n\n\tit( \".resize()\" , () => {\n\t\texpect( string.resize( 'bobby' , 3 ) ).to.be( 'bob' ) ;\n\t\texpect( string.resize( 'bobby' , 5 ) ).to.be( 'bobby' ) ;\n\t\texpect( string.resize( 'bobby' , 8 ) ).to.be( 'bobby   ' ) ;\n\t} ) ;\n\n\tit( \".naturalSort()\" , () => {\n\t\texpect( [ 'one' , 'two' , 'three' ].sort( string.naturalSort ) ).to.equal( [ 'one' , 'three' , 'two' ] ) ;\n\t\texpect( [ 'one' , 'two' , 'Three' ].sort( string.naturalSort ) ).to.equal( [ 'one' , 'Three' , 'two' ] ) ;\n\t\texpect( [ 'One' , 'Two' , 'three' ].sort( string.naturalSort ) ).to.equal( [ 'One' , 'three' , 'Two' ] ) ;\n\t} ) ;\n\n\tit( \".occurrenceCount()\" , () => {\n\t\texpect( string.occurrenceCount( '' , '' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'three' , '' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( '' , 'o' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( '' , 'omg' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'three' , 'o' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'o' , 'o' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'ooo' , 'o' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'ooo' , 'oo' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'aooo' , 'oo' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'aoooo' , 'oo' ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'one two three four' , 'o' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'one one one' , 'one' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'one' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'oneone' ) ).to.be( 1 ) ;\n\t} ) ;\n\n\tit( \".occurrenceCount() with overlap\" , () => {\n\t\texpect( string.occurrenceCount( 'ooo' , 'oo' , true ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'aooo' , 'oo' , true ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'oneone' , true ) ).to.be( 2 ) ;\n\t} ) ;\n} ) ;\n\n"], "fixing_code": ["\nv0.12.8\n-------\n\nBrand new .naturalSort() code, it was previously borrowed code that was slow and vulnerable to RegExp DoS, the new code is made by myself, has no RegExp, only matching forward, is more flexible and easiest to maintain (#3)\n\n\nv0.12.7\n-------\n\n.format() and Babel-Tower interop, exposing stringKit.format.modes\n\n\nv0.12.6\n-------\n\n.format() and Babel-Tower interop, exposing stringKit.format.modes\n\n\nv0.12.5\n-------\n\n.format(): %n/%N improvements\n\n\nv0.12.4\n-------\n\n.format(): new Scientific Notation (e.g. 1.23 \u00d7 10\u00b2)\n\n\nv0.12.3\n-------\n\n.format()'s new float mode: 'g' for group separator (thousands)\n\n\nv0.12.2\n-------\n\n.format(): new %P/%p format for absolute/relative percent\n\n\nv0.12.1\n-------\n\n.inspect() new option: 'minimalPlusConstructor' and 'noTypeButConstructor' (for displaying non-trivial constructor)\n\n\nv0.12.0\n-------\n\n[Maybe breaking] .format() now use the new StringNumber class, used for number formatting\n\n\nv0.11.10\n--------\n\nFix format %X to respect unicode\n\n\nv0.11.9\n-------\n\nNew format argument: %X, turning a string into its hexadecimal representation\n\n\nv0.11.8\n-------\n\nstring.unicode.getLastTruncateWidth()\n\n\nv0.11.7\n-------\n\n.format() %n and %N sort object keys\n\n\nv0.11.6\n-------\n\n.format(): new inspection argument 's' for max string length\n.inspect(): new option 'useInpectPropertyBlackList' that use target object own blacklist\n\n\nv0.11.5\n-------\n\n.format(): new inspect argument 'l' for outputMaxLength\n\n\nv0.11.4\n-------\n\n.format(): new inspect argument 'l' for outputMaxLength\n\n\nv0.11.3\n-------\n\nMinor .inspectError() tweaks\n\n\nv0.11.2\n-------\n\n.inpectError() improved (support for new elements in the latest Node.js stack trace)\n\n\nv0.11.1\n-------\n\n.format(): Add %m specifier for degrees/minutes/seconds notation\n\n\nv0.11.0\n-------\n\n.format() big improvements: generic parameters (parameters common to multiple specifiers), better API, more documentation. Also BREAKING change: %f zero-paddingdo not use the 'p' parameter but the 'z' (like Zero). Removed the 'P' parameter which would break the new standard of upper-case = generic parameter, and it is useless since any specifier can use the 'L' and 'R' parameter.\n\n\nv0.10.6\n-------\n\nAdd number format space padding\n\n\nv0.10.5\n-------\n\nFix format number 0 padding and negative numbers\n\n\nv0.10.4\n-------\n\nNew: .format() %s now support padding\n\n\nv0.10.3\n-------\n\n.format(): improvement on the new %n/%N natural formatting\n\n\nv0.10.2\n-------\n\nNew format %n and %N (WIP: behavior)\n\n\nv0.10.1\n-------\n\nNew options 'indexOf' for fuzzy matcher\n\n\nv0.10.0\n-------\n\nBREAKING: fixing occurrenceCount() spelling, and add the overlap option\n\n\nv0.9.12\n-------\n\nFuzzy string matcher improvements, more unit tests\n\n\nv0.9.11\n-------\n\nNew: fuzzy string matcher\n\n\nv0.9.10\n-------\n\nFix .wordwarp() options to the correct name: widthFn -> charWidthFn\n\n\nv0.9.9\n------\n\nNew: .camelCaseToSeparated(): like .camelCaseToDashed() but with a customizable separator (default to space)\n\n\nv0.9.8\n------\n\nescape.unicodePercentEncode()\n\n\nv0.9.7\n------\n\n.format() %t option for time duration\n\n\nv0.9.6\n------\n\n.format(): %f mode greatly improved, new %e mode for scientific notation\n\n\nv0.9.5\n------\n\n.inspectError() now follow error.from\n\n\nv0.9.4\n------\n\n.inpect(): now correctly handle truncated output for style:color\n\n\nv0.9.3\n------\n\nNew: .naturalSort()\n\n\nv0.9.2\n------\n\nNew: .inspect() now support %S formatting: a string where ^ formatting is interpreted\n\n\nv0.9.1\n------\n\n.inspect() now detects holes in array\n\n\nv0.9.0\n------\n\nBreaking: removing xregexp\n\n\nv0.8.15\n-------\n\n.format() Node v6.x compatibility fix (PR #2)\n\n\nv0.8.14\n-------\n\n.inspect() fixing the missing new line for special object that turn to a string\n\n\nv0.8.13\n-------\n\nFormat: J mode (json) now returns 'null' for undefined, instead on crashing when sanitizing\n\n\nv0.8.12\n-------\n\n.toCamelCase() uppercase preservation option\n\n\nv0.8.11\n-------\n\n.format(): new %r format (like %s, with no sanitize)\n\n\nv0.8.10\n-------\n\n.inspect(): inspection of rejected promise (with an error) improved\n\n\nv0.8.9\n------\n\n.inspect() now supports Promise inspection (Node.js only)\n\n\nv0.8.8\n------\n\nFix a regression (since 0.7.14) with .format() and %I, %Y and %E format, when color: true\n\n\nv0.8.7\n------\n\n.toCells()/.fromCells() private API changed (again)\n\n\nv0.8.6\n------\n\n.toCells()/.fromCells() private API changed\n\n\nv0.8.5\n------\n\n.unicode.toCells(): tabs filler fixed\n\n\nv0.8.4\n------\n\n.unicode.toCells(): added a fourth argument (the initial position in the line)\n\n\nv0.8.3\n------\n\nNew: .unicode.toCells() and .unicode.fromCells()\n\n\nv0.8.2\n------\n\nFix in the private API: .wordwrap()'s 'regroupFn' option (again)\n\n\nv0.8.1\n------\n\nFix in the private API: .wordwrap()'s 'regroupFn' option\n\n\nv0.8.0\n------\n\nPrivate API breaking change: .wordwrap() option 'sequenceSkip' is now 'skipFn' ; more .wordwrap() private options ; New: .unicode.codePointWidth() and .unicode.charWidth()\n\n\nv0.7.18\n-------\n\nDeprecate .unicode.widthLimit() in favor of .unicode.truncateWidth()\n\n\nv0.7.17\n-------\n\nInternal improvements\n\n\nv0.7.16\n-------\n\n.format() new option: 'noMarkup'\n\n\nv0.7.15\n-------\n\n.format() Fix extension issues\n\n\nv0.7.14\n-------\n\n.format() Fixing control chars in non-function arguments\n\n\nv0.7.13\n-------\n\nNew: .unicode.firstCodePoint(), .unicode.firstChar()\n\n\nv0.7.12\n-------\n\n.format() %Y now has 'useInspect' option on\n\n\nv0.7.11\n-------\n\n.inspect(): new options 'useInspect' that use object .inspect() method if available\n\n\nv0.7.10\n-------\n\nFixed .inspect() on empty array\n\n\nv0.7.9\n------\n\nNew: .widthLimit()\n\n\nv0.7.8\n------\n\n.wordwrap() width fixed ; new option 'fill' that add space at the right to fill lines\n\n\nv0.7.7\n------\n\nNew: .format() now has the %k formatter (metric prefix)\n\n\nv0.7.6\n------\n\nNew: unicode.arrayWidth() has a second argument (limit)\n\n\nv0.7.5\n------\n\nNew: unicode.arrayWidth()\n\n\nv0.7.4\n------\n\n.inspect(): raise string inspection default limit from 200 to 250, since all people have big screens\n\n\nv0.7.3\n------\n\nFixed .wordwrap() edge-case behavior with spaces at the end of lines and explicit new lines (plus the noTrim option to controle it)\n\n\nv0.7.2\n------\n\n.wordwrap() API issues fixed\n\n\nv0.7.1\n------\n\nFix .wordwrap() behavior with offset and first word wrapping\n\n\nv0.7.0\n------\n\nBreaking change: .wordwrap() signature changed, either .wordwrap( str , width )  or .wordwrap( str, optionObject ) \n\n\nv0.6.18\n-------\n\nNew: .wordwrap() now support a 4th argument, a function used to skip some special chars (e.g.: useful for skipping ANSI colors)\n\n\nv0.6.17\n-------\n\nFixed an exception in .inspect() when an object has no constructor\n\n\nv0.6.16\n-------\n\nUnit tests are now using Tea-Time and its builtin 'expect' assertion\n\n\nv0.6.15\n-------\n\n.inspect() now display RegExp with .toString()\n\n\nv0.6.14\n-------\n\nAaaargh, a console.log() was left\n\n\nv0.6.13\n-------\n\noutputMaxLength option for .inspect() ; documentation\n\n\nv0.6.12\n-------\n\n.inspect() improved -- new style: inline, new option: noArrayProperty\n\n\nv0.6.11\n-------\n\n.wordwrap() is now french typography aware\n\n\nv0.6.10\n-------\n\n.wordwrap() is now unicode aware and full-width aware\n\n\nv0.6.9\n------\n\n.inspect() now has a 'maxLength' option that truncates big strings (default: 200)\n\n\nv0.6.8\n------\n\n.inspect(): proper display for String instances\n\n\nv0.6.7\n------\n\nNew function: .occurenceCount() -- count occurences of a substring\n\n\nv0.6.6\n------\n\nAdding a 'propertyBlackList' options to .inspect() to prevent to skip properties based by name ; documentation has been updated\n\n\nv0.6.5\n------\n\nAdding a 'protoBlackList' options to .inspect() to prevent from recursing inside some objects based on their prototype\n\n\nv0.6.4\n------\n\ncamelCaseToDash() alias of camelCaseToDashed()\n\n\nv0.6.3\n------\n\nMerging pull request #1: .inspect() now supports passing an object to customize the style\n\n\nv0.6.2\n------\n\n.toTitleCase(): mino refacto\n\n\nv0.6.1\n------\n\nRemoved tree-kit dependency, using ES6 Object.assign() instead\n\n\nv0.6.0\n------\n\nBreaking change: require node >= 6. Punycode module independance, unicode sub-module performance improved\n\n\nv0.5.27\n-------\n\nNew: string.unicode.width() that return the width of a string when displayed on a terminal or when using a monospace font\n\n\nv0.5.26\n-------\n\ninspectError() non-error fallback to inspect()\n\n\nv0.5.25\n-------\n\ninspectError() fix: now return '(not an error)' if it was not inspecting an error\n\n\nv0.5.24\n-------\n\n.toTitleCase() improved\n\n\nv0.5.23\n-------\n\nNew: .toTitleCase()\n\n\nv0.5.22\n-------\n\nNew: .format() accept %z and %Z that transform to base64 and base64url\n\n\nv0.5.21\n-------\n\nNew: .wordwrap()\n\n\nv0.5.20\n-------\n\nAdded XRegExp as a dependency\n\n\nv0.5.19\n-------\n\nMarkup: starting markup reset option\n\n\nv0.5.18\n-------\n\nMarkup shift/modifier documentation\n\n\nv0.5.17 - v0.5.16\n-----------------\n\nMarkup: shift\n\n\nv0.5.15\n-------\n\n.format() option %I and %Y accept a 'depth' integer argument\n\n\nv0.5.14\n-------\n\nNew: escape.jsSingleQuote() and escape.jsDoubleQuote()\n\n\nv0.5.13\n-------\n\nNew: .resize()\n\n\nv0.5.12\n-------\n\nDocumentation fixed, unit tests fixed for node v6\n\n\nv0.5.11\n-------\n\n.format() now supports %Y, like %I but without non-enum, func, and descriptor\n\n\nv0.5.10\n-------\n\nStack trace inspector fixed for anonymous function in V8\n\n\nv0.5.9\n------\n\nNew: string.markup(), a stand-alone version of the markup existing in string.format()\n\n\nv0.5.8\n------\n\nDependencies\n\n\nv0.5.6 - v0.5.7\n---------------\n\ninspectError(): firefox stack trace improvements\n\n\nv0.5.5\n------\n\ninspectError(): 'browser' option\n\n\nv0.5.4\n------\n\nHtml error inspector improvements\n\n\nv0.5.3\n------\n\nDependency organization\n\n\nv0.5.2\n------\n\n.inspect(): 'sort' option that sort keys\n\n\nv0.5.1\n------\n\nAbort the home-made diff algorithm project in .inspect().\n\n\nv0.5.0\n------\n\nBreaking changes: more options to .inspect().\n\n\nv0.4.4\n------\n\nNew function: latinize().\n\n\nv0.4.3\n------\n\n\"use strict\" everywhere.\n\n\nv0.4.2\n------\n\n\"use strict\" everywhere.\n\n\nv0.4.1\n------\n\n.format(): .format.count() and .format.hasFormatting() have had bugs with the new v0.4.0 format syntax\n\n\nv0.4.0\n------\n\nBreaking changes: format() now uses a generic %L and %[]L where L is any letter, so %[func:%a%a] is now %[func:%a%a]F and %/F1/f is now %[f1]f\n\n\nv0.3.14\n-------\n\nBreaking changes: format() now uses a generic %L and %[]L where L is any letter, so %[func:%a%a] is now %[func:%a%a]F and %/F1/f is now %[f1]f\n\n\nv0.3.13\n-------\n\nformat(): custom formatter gains more flexibility\n\n\nv0.3.12\n-------\n\nFormat cleanup\n\n\nv0.3.11\n-------\n\n.inspect() now inspect Date instance\n\n\nv0.3.10\n-------\n\n.inspect() now inspect ES6 Set & Map, and MongoDB ObjectID\n\n\nv0.3.9\n------\n\nstring.unicode.isFullWidth(): check if the given char is a full-width char or not\n\n\nv0.3.8\n------\n\nstring.unicode.surrogatePair(): it does not check input anymore, to gain perfs\n\n\nv0.3.7\n------\n\nstring.unicode.toFullWidth(): convert normal ASCII chars to their full-width counterpart\n\n\nv0.3.6\n------\n\nBugfix on the new .format()'s style markup feature\n\n\nv0.3.5\n------\n\nDocumentation.\n\n\nv0.3.4\n------\n\nDocumentation: precision on .format() and style markup.\n\n\nv0.3.3\n------\n\nDocumentation on the new caret ^ feature (style markup) for the .format() method.\n\n\nv0.3.2\n------\n\nExpose the default formatter option.\n\n\nv0.3.1\n------\n\n.format(): fixing a bug when no markup exists in the object.\n\n\nv0.3.0\n------\n\nNew [breaking compatibilities]: .format() now accepts style markup using the caret ^ sign.\n\n\n\nv0.2.10\n-------\n\nNew method: .camelCaseToDashed().\n\n\nv0.2.3 - v0.2.9\n---------------\n\n.inspectError() improvement and bugfixes.\n.inspectStack() that just inspect a stack string.\n\n\nv0.2.0 - v0.2.2\n---------------\n\nformat(): custom filters should use formatMethod() instead.\n\n\nv0.1.21\n-------\n\nOption %E for format(): call inspectError() on the argument.\n\n\nv0.1.20\n-------\n\nNew method: inspectError().\n\n\nv0.1.19\n-------\n\nOption %I for format(): call inspect() on the argument.\n\n\nv0.1.18\n-------\n\nDependencies.\n\n\nv0.1.15 - v0.1.17\n-----------------\n\nIntroducing the .toCamelCase() method.\n\n\nv0.1.13 - v0.1.14\n-----------------\n\nAdding few MDN polyfill for the native String object.\n\n\nv0.1.12\n--------\n\nImprovement on the unicode submodule.\n\n\nv0.1.11\n--------\n\nNew submodule: 'unicode'. Still a work in progress, so no doc and no API contract for instance.\n\n\nv0.1.10\n-------\n\n.inspect() displays empty keys between quotes.\n\n\nv0.1.9\n------\n\nNew submodule: 'regexp'. Still a work in progress, so no doc and no API contract for instance.\n\n\nv0.1.8\n------\n\n.inspect() with 'proto' option now reports correctly prototype of empty objects.\n\n\nv0.1.7\n------\n\nDependencies.\n\n\nv0.1.6\n------\n\n* .ansi now contains code for dim and inverse.\n\n\nv0.1.5\n------\n\n* Bugfix: .format.count() now works correctly when indexed formating are in use.\n\n\nv0.1.4\n------\n\n* NEW! .ansi contains an object with ansi code, e.g. .ansi.red is the ansi code for red, etc.\n\n\nv0.1.3\n------\n\n* .inspect(): fixed a bug displaying false circular references when dealing with arrays (because of .concat() unexpected behaviour)\n\n\nv0.1.1 - v0.1.2\n---------------\n\n* .inspect() should handle exception when dealing with native object that raise exceptions when accessing properties.\ne.g.: \"Uncaught SecurityError: Failed to read the 'cookie' property from 'Document': Access is denied for this document.\"\nraised by Chromium.\n\n* Upgraded dependencies.\n\n\nv0.1.0\n------\n\nRefactoring.\n\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nconst CONTROL_CLASS = 1 ;\nconst WORD_SEPARATOR_CLASS = 2 ;\nconst LETTER_CLASS = 3 ;\nconst NUMBER_CLASS = 4 ;\nconst SYMBOL_CLASS = 5 ;\n\n\n\nfunction getCharacterClass( char , code ) {\n\tif ( isWordSeparator( code ) ) { return WORD_SEPARATOR_CLASS ; }\n\tif ( code <= 0x1f || code === 0x7f ) { return CONTROL_CLASS ; }\n\tif ( isNumber( code ) ) { return NUMBER_CLASS ; }\n\t// Here we assume that a letter is a char with a \u201ccase\u201d\n\tif ( char.toUpperCase() !== char.toLowerCase() ) { return LETTER_CLASS ; }\n\treturn SYMBOL_CLASS ;\n}\n\n\n\nfunction isWordSeparator( code ) {\n\tif (\n\t\t// space, tab, no-break space\n\t\tcode === 0x20 || code === 0x09 || code === 0xa0 ||\n\t\t// hyphen, underscore\n\t\tcode === 0x2d || code === 0x5f\n\t) {\n\t\treturn true ;\n\t}\n\n\treturn false ;\n}\n\n\n\nfunction isNumber( code ) {\n\tif ( code >= 0x30 && code <= 0x39 ) { return true ; }\n\treturn false ;\n}\n\n\n\nfunction naturalSort( a , b ) {\n\ta = '' + a ;\n\tb = '' + b ;\n\n\tvar aIndex , aEndIndex , aChar , aCode , aClass , aCharLc , aNumber ,\n\t\taTrim = a.trim() ,\n\t\taLength = aTrim.length ,\n\t\tbIndex , bEndIndex , bChar , bCode , bClass , bCharLc , bNumber ,\n\t\tbTrim = b.trim() ,\n\t\tbLength = bTrim.length ,\n\t\tadvantage = 0 ;\n\n\tfor ( aIndex = bIndex = 0 ; aIndex < aLength && bIndex < bLength ; aIndex ++ , bIndex ++ ) {\n\t\taChar = aTrim[ aIndex ] ;\n\t\tbChar = bTrim[ bIndex ] ;\n\t\taCode = aTrim.charCodeAt( aIndex ) ;\n\t\tbCode = bTrim.charCodeAt( bIndex ) ;\n\t\taClass = getCharacterClass( aChar , aCode ) ;\n\t\tbClass = getCharacterClass( bChar , bCode ) ;\n\t\tif ( aClass !== bClass ) { return aClass - bClass ; }\n\n\t\tswitch ( aClass ) {\n\t\t\tcase WORD_SEPARATOR_CLASS :\n\t\t\t\t// Eat all white chars and continue\n\t\t\t\twhile ( isWordSeparator( aTrim.charCodeAt( aIndex + 1 ) ) ) { aIndex ++ ; }\n\t\t\t\twhile ( isWordSeparator( bTrim.charCodeAt( bIndex + 1 ) ) ) { bIndex ++ ; }\n\t\t\t\tbreak ;\n\n\t\t\tcase CONTROL_CLASS :\n\t\t\tcase SYMBOL_CLASS :\n\t\t\t\tif ( aCode !== bCode ) { return aCode - bCode ; }\n\t\t\t\tbreak ;\n\n\t\t\tcase LETTER_CLASS :\n\t\t\t\taCharLc = aChar.toLowerCase() ;\n\t\t\t\tbCharLc = bChar.toLowerCase() ;\n\t\t\t\tif ( aCharLc !== bCharLc ) { return aCharLc > bCharLc ? 1 : -1 ; }\n\n\t\t\t\t// As a last resort, we would sort uppercase first\n\t\t\t\tif ( ! advantage && aChar !== bChar ) { advantage = aChar !== aCharLc ? -1 : 1 ; }\n\n\t\t\t\tbreak ;\n\n\t\t\tcase NUMBER_CLASS :\n\t\t\t\t// Lookup for a whole number and parse it\n\t\t\t\taEndIndex = aIndex + 1 ;\n\t\t\t\twhile ( isNumber( aTrim.charCodeAt( aEndIndex ) ) ) { aEndIndex ++ ; }\n\t\t\t\taNumber = parseFloat( aTrim.slice( aIndex , aEndIndex ) ) ;\n\n\t\t\t\tbEndIndex = bIndex + 1 ;\n\t\t\t\twhile ( isNumber( bTrim.charCodeAt( bEndIndex ) ) ) { bEndIndex ++ ; }\n\t\t\t\tbNumber = parseFloat( bTrim.slice( bIndex , bEndIndex ) ) ;\n\n\t\t\t\tif ( aNumber !== bNumber ) { return aNumber - bNumber ; }\n\n\t\t\t\t// As a last resort, we would sort the number with the less char first\n\t\t\t\tif ( ! advantage && aEndIndex - aIndex !== bEndIndex - bIndex ) { advantage = ( aEndIndex - aIndex ) - ( bEndIndex - bIndex ) ; }\n\n\t\t\t\t// Advance the index at the end of the number area\n\t\t\t\taIndex = aEndIndex - 1 ;\n\t\t\t\tbIndex = bEndIndex - 1 ;\n\t\t\t\tbreak ;\n\t\t}\n\t}\n\n\t// If there was an \u201cadvantage\u201d, use it now\n\tif ( advantage ) { return advantage ; }\n\n\t// Finally, sort by remaining char, or by trimmed length or by full length\n\treturn ( aLength - aIndex ) - ( bLength - bIndex ) || aLength - bLength || a.length - b.length ;\n}\n\nmodule.exports = naturalSort ;\n\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nconst stringKit = {} ;\nmodule.exports = stringKit ;\n\n\n\n// Tier 0: add polyfills to stringKit\nvar fn_ ;\nvar polyfill = require( './polyfill.js' ) ;\n\nfor ( fn_ in polyfill ) {\n\tstringKit[ fn_ ] = function( str , ... args ) {\n\t\treturn polyfill[ fn_ ].call( str , ... args ) ;\n\t} ;\n}\n\n\n\nObject.assign( stringKit ,\n\n\t// Tier 1\n\t{ escape: require( './escape.js' ) } ,\n\t{ ansi: require( './ansi.js' ) } ,\n\t{ unicode: require( './unicode.js' ) }\n) ;\n\n\n\nObject.assign( stringKit ,\n\n\t// Tier 2\n\trequire( './format.js' ) ,\n\n\t// Tier 3\n\trequire( './misc.js' ) ,\n\trequire( './inspect.js' ) ,\n\trequire( './regexp.js' ) ,\n\trequire( './camel.js' ) ,\n\t{\n\t\tlatinize: require( './latinize.js' ) ,\n\t\ttoTitleCase: require( './toTitleCase.js' ) ,\n\t\twordwrap: require( './wordwrap.js' ) ,\n\t\tnaturalSort: require( './naturalSort.js' ) ,\n\t\tfuzzy: require( './fuzzy.js' ) ,\n\t\tStringNumber: require( './StringNumber.js' )\n\t}\n) ;\n\n\n\n// Install all polyfill into String.prototype\nstringKit.installPolyfills = function installPolyfills() {\n\tvar fn ;\n\n\tfor ( fn in polyfill ) {\n\t\tif ( ! String.prototype[ fn ] ) {\n\t\t\tString.prototype[ fn ] = polyfill[ fn ] ;\n\t\t}\n\t}\n} ;\n\n", "{\n  \"name\": \"string-kit\",\n  \"version\": \"0.12.8\",\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  },\n  \"description\": \"A string manipulation toolbox, featuring a string formatter (inspired by sprintf), a variable inspector (output featuring ANSI colors and HTML) and various escape functions (shell argument, regexp, html, etc).\",\n  \"main\": \"lib/string.js\",\n  \"directories\": {\n    \"test\": \"test\",\n    \"bench\": \"bench\"\n  },\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"tea-time -R dot\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/cronvel/string-kit.git\"\n  },\n  \"keywords\": [\n    \"string\",\n    \"manipulation\",\n    \"format\",\n    \"sprintf\",\n    \"printf\",\n    \"inspect\",\n    \"color\",\n    \"debug\",\n    \"dump\",\n    \"escape\",\n    \"shell\",\n    \"regexp\",\n    \"html\"\n  ],\n  \"author\": \"C\u00e9dric Ronvel\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cronvel/string-kit/issues\"\n  },\n  \"config\": {\n    \"tea-time\": {\n      \"coverDir\": [\n        \"lib\"\n      ]\n    }\n  },\n  \"copyright\": {\n    \"title\": \"String Kit\",\n    \"years\": [\n      2014,\n      2021\n    ],\n    \"owner\": \"C\u00e9dric Ronvel\"\n  }\n}\n", "/*\n\tString Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n/* global describe, it, expect */\n\n\"use strict\" ;\n\n\n\nconst string = require( '..' ) ;\n\n\n\ndescribe( \"format()\" , () => {\n\n\tvar ansi = string.ansi ;\n\tvar format = string.format ;\n\tvar formatMethod = string.formatMethod ;\n\n\tit( \"should perform basic examples\" , () => {\n\t\texpect( format( 'Hello world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s' , 'world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , 'Joe' , 'Doe' ) ).to.be( 'Hello Joe Doe, how are you?' ) ;\n\t\texpect( format( 'I have %i cookies.' , 3 ) ).to.be( 'I have 3 cookies.' ) ;\n\t\texpect( format( 'This company regains %d%% of market share.' , 36 ) ).to.be( 'This company regains 36% of market share.' ) ;\n\t\texpect( format( '11/8=%f' , 11 / 8 ) ).to.be( '11/8=1.375' ) ;\n\t\texpect( format( 'Binary %b %b' , 11 , 123 ) ).to.be( 'Binary 1011 1111011' ) ;\n\t\texpect( format( 'Octal %o %o' , 11 , 123 ) ).to.be( 'Octal 13 173' ) ;\n\t\texpect( format( 'Hexa %h %x %x' , 11 , 11 , 123 ) ).to.be( 'Hexa b 0b 7b' ) ;\n\t\texpect( format( 'JSON %J' , { hello: 'world' , here: 'is' , my: { wonderful: 'object' } } ) ).to.be( 'JSON {\"hello\":\"world\",\"here\":\"is\",\"my\":{\"wonderful\":\"object\"}}' ) ;\n\t\texpect( format( 'Inspect %I' , { hello: 'world' , here: 'is' , my: { wonderful: 'object' } } ) ).to.be( 'Inspect <Object> <object> {\\n    hello: \"world\" <string>(5)\\n    here: \"is\" <string>(2)\\n    my: <Object> <object> {\\n        wonderful: \"object\" <string>(6)\\n    }\\n}\\n' ) ;\n\t\t//expect( format( 'Inspect %E' , new Error( 'Some error' ) ) ).to.be( '' ) ;\n\t} ) ;\n\n\tit( \"%s should format string\" , () => {\n\t\texpect( format( 'Hello %s' , 'world' ) ).to.be( 'Hello world' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , 'Joe' , 'Doe' ) ).to.be( 'Hello Joe Doe, how are you?' ) ;\n\n\t\t// Should ignore formatting: taking it as literal\n\t\texpect( format( 'Hello %s' , 'w^bor^:ld' ) ).to.be( 'Hello w^bor^:ld' ) ;\n\t\texpect( format( 'Hello %s %s, how are you?' , '^rJ^go^be' , '^rD^go^be' ) ).to.be( 'Hello ^rJ^go^be ^rD^go^be, how are you?' ) ;\n\t} ) ;\n\n\tit( \"%s padding syntax\" , () => {\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. #2' ) ).to.be( 'Cat. #1   Cat. #2' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. #2' ) ).to.be( 'Cat. #1Cat. #2   ' ) ;\n\t\t\n\t\t// Truncate\n\t\texpect( format( 'Cat. #1%[L10]s' , 'this is way to big' ) ).to.be( 'Cat. #1this is w\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[L10]s' , 'that was way to big' ) ).to.be( 'Cat. #1 that was\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'this is way to big' ) ).to.be( 'Cat. #1this is w\u2026' ) ;\n\t\texpect( format( 'Cat. #1%[R10]s' , 'that was way to big' ) ).to.be( 'Cat. #1that was\u2026 ' ) ;\n\n\t\t// Unicode length/width\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. \ud87e\udc09' ) ).to.be( 'Cat. #1   Cat. \ud87e\udc09' ) ;\t// \ud87e\udc09 have length and width of 2\n\t\texpect( format( 'Cat. #1%[L10]s' , 'Cat. \uff20' ) ).to.be( 'Cat. #1   Cat. \uff20' ) ;\t// \uff20 have length of 1 but width of 2\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. \ud87e\udc09' ) ).to.be( 'Cat. #1Cat. \ud87e\udc09   ' ) ;\t// \ud87e\udc09 have length and width of 2\n\t\texpect( format( 'Cat. #1%[R10]s' , 'Cat. \uff20' ) ).to.be( 'Cat. #1Cat. \uff20   ' ) ;\t// \uff20 have length of 1 but width of 2\n\t} ) ;\n\n\tit( \"common mode arg padding\" , () => {\n\t\texpect( format( '%[L6]f' , 12.34 ) ).to.be( ' 12.34' ) ;\n\t\texpect( format( '%[L6]f' , -12.34 ) ).to.be( '-12.34' ) ;\n\t\texpect( format( '%[L8z3]f' , 12.34 ) ).to.be( '  012.34' ) ;\n\t\texpect( format( '%[L8z3]f' , -12.34 ) ).to.be( ' -012.34' ) ;\n\t\texpect( format( '%[.0L5]f' , 12.34 ) ).to.be( '   12' ) ;\n\t\texpect( format( '%[.0L5]f' , -12.34 ) ).to.be( '  -12' ) ;\n\n\t\texpect( format( '%[R6]f' , 12.34 ) ).to.be( '12.34 ' ) ;\n\t\texpect( format( '%[R6]f' , -12.34 ) ).to.be( '-12.34' ) ;\n\t\texpect( format( '%[R8z3]f' , 12.34 ) ).to.be( '012.34  ' ) ;\n\t\texpect( format( '%[R8z3]f' , -12.34 ) ).to.be( '-012.34 ' ) ;\n\t\texpect( format( '%[.0R5]f' , 12.34 ) ).to.be( '12   ' ) ;\n\t\texpect( format( '%[.0R5]f' , -12.34 ) ).to.be( '-12  ' ) ;\n\t} ) ;\n\t\n\tit( \"%S should format string and interpret ^ formatting\" , () => {\n\t\texpect( format( 'Hello %S' , 'w^bor^:ld' ) ).to.be( 'Hello w\\x1b[34mor\\x1b[0mld\\x1b[0m' ) ;\n\t\texpect( format( 'Hello %S %S, how are you?' , '^rJ^go^be' , '^rD^go^be' ) ).to.be( 'Hello \\x1b[31mJ\\x1b[32mo\\x1b[34me\\x1b[0m \\x1b[31mD\\x1b[32mo\\x1b[34me\\x1b[0m, how are you?' ) ;\n\t} ) ;\n\n\tit( \"%X should turn a string into hexadecimal\" , () => {\n\t\texpect( format( '%X' , 'hello' ) ).to.be( '68656c6c6f' ) ;\n\t\texpect( format( 'Hello %X' , 'w' ) ).to.be( 'Hello 77' ) ;\n\t\texpect( format( 'Hello %X' , 'world' ) ).to.be( 'Hello 776f726c64' ) ;\n\t\texpect( format( 'Hello %X' , 'C\u00e9dric' ) ).to.be( 'Hello 43c3a964726963' ) ;\n\t\texpect( format( 'Hello %X' , Buffer.from( 'C\u00e9dric' ) ) ).to.be( 'Hello 43c3a964726963' ) ;\n\t} ) ;\n\n\tit( \"argument sanitizing\" , () => {\n\t\texpect( format( 'Some string: %s' , 'one\\ntwo' ) ).to.be( 'Some string: one\\ntwo' ) ;\n\t\texpect( format( 'Some string: %s' , 'one\\x00two' ) ).to.be( 'Some string: one\\\\x00two' ) ;\n\t\texpect( format( 'Some string: %s' , 'one\\n\\x00two' ) ).to.be( 'Some string: one\\n\\\\x00two' ) ;\n\t} ) ;\n\n\tit( \"%u should format unsigned integer\" , () => {\n\t\texpect( format( '%u' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%u' , 0 ) ).to.be( '0' ) ;\n\t\texpect( format( '%u' , -123 ) ).to.be( '0' ) ;\n\t\texpect( format( '%u' ) ).to.be( '0' ) ;\n\t} ) ;\n\n\tit( \"%U should format *positive* unsigned integer\" , () => {\n\t\texpect( format( '%U' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%U' , 0 ) ).to.be( '1' ) ;\n\t\texpect( format( '%U' , -123 ) ).to.be( '1' ) ;\n\t\texpect( format( '%U' ) ).to.be( '1' ) ;\n\t} ) ;\n\n\tit( \"%f should format floating point numbers\" , () => {\n\t\texpect( format( '%f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\t\texpect( format( '%f' , 0.00123456789 ) ).to.be( '0.00123456789' ) ;\n\t} ) ;\n\t\n\tit( \"%f group separator syntax\" , () => {\n\t\texpect( format( '%[g]f' , 12345.6789 ) ).to.be( '12 345.6789' ) ;\n\t\texpect( format( '%[g ]f' , 12345.6789 ) ).to.be( '12 345.6789' ) ;\n\t\texpect( format( '%[g,]f' , 12345.6789 ) ).to.be( '12,345.6789' ) ;\n\t\texpect( format( \"%[g']f\" , 12345.6789 ) ).to.be( \"12'345.6789\" ) ;\n\t\texpect( format( '%[g_]f' , 12345.6789 ) ).to.be( '12_345.6789' ) ;\n\n\t\texpect( format( '%[g]f' , 1 ) ).to.be( '1' ) ;\n\t\texpect( format( '%[g]f' , 12 ) ).to.be( '12' ) ;\n\t\texpect( format( '%[g]f' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%[g]f' , 1234 ) ).to.be( '1 234' ) ;\n\t\texpect( format( '%[g]f' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%[g]f' , 123456 ) ).to.be( '123 456' ) ;\n\t\texpect( format( '%[g]f' , 1234567 ) ).to.be( '1 234 567' ) ;\n\t\texpect( format( '%[g]f' , 12345678 ) ).to.be( '12 345 678' ) ;\n\t\texpect( format( '%[g]f' , 123456789 ) ).to.be( '123 456 789' ) ;\n\t\texpect( format( '%[g]f' , 1234567891 ) ).to.be( '1 234 567 891' ) ;\n\n\t\texpect( format( '%[g]f' , 0.1234 ) ).to.be( '0.1234' ) ;\n\t} ) ;\n\t\n\tit( \"%f precision syntax\" , () => {\n\t\texpect( format( '%[1]f' , 12345.6789 ) ).to.be( '10000' ) ;\n\t\texpect( format( '%[2]f' , 12345.6789 ) ).to.be( '12000' ) ;\n\t\texpect( format( '%[3]f' , 12345.6789 ) ).to.be( '12300' ) ;\n\t\texpect( format( '%[4]f' , 12345.6789 ) ).to.be( '12350' ) ;\n\t\texpect( format( '%[5]f' , 12345.6789 ) ).to.be( '12346' ) ;\n\t\texpect( format( '%[6]f' , 12345.6789 ) ).to.be( '12345.7' ) ;\n\t\texpect( format( '%[7]f' , 12345.6789 ) ).to.be( '12345.68' ) ;\n\t\texpect( format( '%[8]f' , 12345.6789 ) ).to.be( '12345.679' ) ;\n\t\texpect( format( '%[9]f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\t\texpect( format( '%[10]f' , 12345.6789 ) ).to.be( '12345.6789' ) ;\n\n\t\texpect( format( '%[1]f' , 0.1234 ) ).to.be( '0.1' ) ;\n\t\texpect( format( '%[2]f' , 0.1234 ) ).to.be( '0.12' ) ;\n\t\texpect( format( '%[3]f' , 0.1234 ) ).to.be( '0.123' ) ;\n\n\t\texpect( format( '%[1]f' , 0.001234 ) ).to.be( '0.001' ) ;\n\t\texpect( format( '%[2]f' , 0.001234 ) ).to.be( '0.0012' ) ;\n\t\texpect( format( '%[3]f' , 0.001234 ) ).to.be( '0.00123' ) ;\n\t} ) ;\n\t\n\tit( \"%f integer rounding syntax\" , () => {\n\t\texpect( format( '%[1.]f' , 12345.6789 ) ).to.be( '12350' ) ;\n\t\texpect( format( '%[2.]f' , 12345.6789 ) ).to.be( '12300' ) ;\n\t\texpect( format( '%[3.]f' , 12345.6789 ) ).to.be( '12000' ) ;\n\t\texpect( format( '%[4.]f' , 12345.6789 ) ).to.be( '10000' ) ;\n\t\texpect( format( '%[5.]f' , 12345.6789 ) ).to.be( '0' ) ;\n\t} ) ;\n\t\n\tit( \"%f decimal rounding syntax\" , () => {\n\t\texpect( format( '%[.0]f' , 12345.6789 ) ).to.be( '12346' ) ;\n\t\texpect( format( '%[.1]f' , 12345.6789 ) ).to.be( '12345.7' ) ;\n\t\texpect( format( '%[.2]f' , 12345.6789 ) ).to.be( '12345.68' ) ;\n\t\texpect( format( '%[.3]f' , 12345.6789 ) ).to.be( '12345.679' ) ;\n\n\t\texpect( format( '%[.2]f' , 12345 ) ).to.be( '12345' ) ;\n\t\texpect( format( '%[.2]f' , 12345.6 ) ).to.be( '12345.6' ) ;\n\t} ) ;\n\n\tit( \"%f decimal rounding artifact\" , () => {\n\t\t// JS artifact, without the StringNumber class, it is impossible to get this working unless breaking anything else:\n\t\texpect( format( '%[.5]f' , 1000000 ) ).to.be( '1000000' ) ;\n\t} ) ;\n\t\n\tit( \"%f decimal rounding syntax forcing 0 padding after decimal\" , () => {\n\t\texpect( format( '%[.2!]f' , 12.523 ) ).to.be( '12.52' ) ;\n\t\texpect( format( '%[.2!]f' , 12.5 ) ).to.be( '12.50' ) ;\n\t\texpect( format( '%[.2!]f' , 12 ) ).to.be( '12.00' ) ;\n\t} ) ;\n\n\tit( \"%f decimal rounding syntax forcing 0 padding after decimal only if there is decimal\" , () => {\n\t\texpect( format( '%[.2?]f' , 12.523 ) ).to.be( '12.52' ) ;\n\t\texpect( format( '%[.2?]f' , 12.5 ) ).to.be( '12.50' ) ;\n\t\texpect( format( '%[.2?]f' , 12 ) ).to.be( '12' ) ;\n\t} ) ;\n\t\n\tit( \"%f zero-left-padding syntax\" , () => {\n\t\texpect( format( '%[z3]f' , 12.34 ) ).to.be( '012.34' ) ;\n\t\texpect( format( '%[z5]f' , 12.34 ) ).to.be( '00012.34' ) ;\n\t\texpect( format( '%[.0z5]f' , 12.34 ) ).to.be( '00012' ) ;\n\t\t\n\t\t// That nasty minus bug...\n\t\texpect( format( '%[z3]f' , -12.34 ) ).to.be( '-012.34' ) ;\n\t\texpect( format( '%[z5]f' , -12.34 ) ).to.be( '-00012.34' ) ;\n\t\texpect( format( '%[.0z5]f' , -12.34 ) ).to.be( '-00012' ) ;\n\n\t\t// Forcing no zero before the dot\n\t\texpect( format( '%[z0]f' , 0.1234 ) ).to.be( '.1234' ) ;\n\t\texpect( format( '%[z0]f' , 0.001234 ) ).to.be( '.001234' ) ;\n\t} ) ;\n\t\n\tit( \"%e exponential notation\" , () => {\n\t\texpect( format( '%e' , 0.001234 ) ).to.be( '1.234e-3' ) ;\n\t\texpect( format( '%e' , 0.01234 ) ).to.be( '1.234e-2' ) ;\n\t\texpect( format( '%e' , 0.1234 ) ).to.be( '1.234e-1' ) ;\n\t\texpect( format( '%e' , 1.234 ) ).to.be( '1.234e+0' ) ;\n\t\texpect( format( '%e' , 12.34 ) ).to.be( '1.234e+1' ) ;\n\t\texpect( format( '%e' , 123.4 ) ).to.be( '1.234e+2' ) ;\n\t\texpect( format( '%e' , 1234 ) ).to.be( '1.234e+3' ) ;\n\n\t\t// Precision\n\t\texpect( format( '%[2]e' , 123.4 ) ).to.be( '1.2e+2' ) ;\n\t\texpect( format( '%[3]e' , 123.4 ) ).to.be( '1.23e+2' ) ;\n\n\t\t// With padding\n\t\texpect( format( '%[2L7]e' , 123.4 ) ).to.be( ' 1.2e+2' ) ;\n\n\t\t// Rounding (make no sense with scientific notation, but it works)\n\t\texpect( format( '%[.2]e' , 123.4567 ) ).to.be( '1.2346e+2' ) ;\n\t\texpect( format( '%[.1]e' , 123.4567 ) ).to.be( '1.235e+2' ) ;\n\t\texpect( format( '%[1.]e' , 123.4567 ) ).to.be( '1.2e+2' ) ;\n\t} ) ;\n\t\n\tit( \"%K scientific notation\" , () => {\n\t\texpect( format( '%K' , 0.001234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b3' ) ;\n\t\texpect( format( '%K' , 0.01234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b2' ) ;\n\t\texpect( format( '%K' , 0.1234 ) ).to.be( '1.234 \u00d7 10\u207b\u00b9' ) ;\n\t\texpect( format( '%K' , 1.234 ) ).to.be( '1.234 \u00d7 10\u2070' ) ;\n\t\texpect( format( '%K' , 12.34 ) ).to.be( '1.234 \u00d7 10\u00b9' ) ;\n\t\texpect( format( '%K' , 123.4 ) ).to.be( '1.234 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%K' , 1234 ) ).to.be( '1.234 \u00d7 10\u00b3' ) ;\n\n\t\t// Precision\n\t\texpect( format( '%[2]K' , 123.4 ) ).to.be( '1.2 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[3]K' , 123.4 ) ).to.be( '1.23 \u00d7 10\u00b2' ) ;\n\n\t\t// With padding\n\t\texpect( format( '%[2L11]K' , 123.4 ) ).to.be( '  1.2 \u00d7 10\u00b2' ) ;\n\n\t\t// Rounding (make no sense with scientific notation, but it works)\n\t\texpect( format( '%[.2]K' , 123.4567 ) ).to.be( '1.2346 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[.1]K' , 123.4567 ) ).to.be( '1.235 \u00d7 10\u00b2' ) ;\n\t\texpect( format( '%[1.]K' , 123.4567 ) ).to.be( '1.2 \u00d7 10\u00b2' ) ;\n\t} ) ;\n\t\n\tit( \"%P should format with (absolute) percent\" , () => {\n\t\texpect( format( '%P' , 2 ) ).to.be( '200%' ) ;\n\t\texpect( format( '%P' , 1 ) ).to.be( '100%' ) ;\n\t\texpect( format( '%P' , 0 ) ).to.be( '0%' ) ;\n\t\texpect( format( '%P' , -1 ) ).to.be( '-100%' ) ;\n\t\texpect( format( '%P' , 1.23 ) ).to.be( '123%' ) ;\n\t\texpect( format( '%P' , 0.45 ) ).to.be( '45%' ) ;\n\n\t\texpect( format( '%P' , 0.12345 ) ).to.be( '12%' ) ;\n\t\texpect( format( '%[.1]P' , 0.12345 ) ).to.be( '12.3%' ) ;\n\n\t\texpect( format( '%[.1]P' , 0.00345 ) ).to.be( '0.3%' ) ;\n\t\texpect( format( '%[.1z0]P' , 0.00345 ) ).to.be( '.3%' ) ;\n\n\t\t// Check that setting up precision bypass the default rounding\n\t\texpect( format( '%[4]P' , 0.9975 ) ).to.be( '99.75%' ) ;\n\t\texpect( format( '%[5]P' , 1.2345 ) ).to.be( '123.45%' ) ;\n\t} ) ;\n\n\tit( \"%p should format with relative percent\" , () => {\n\t\texpect( format( '%p' , 2 ) ).to.be( '+100%' ) ;\n\t\texpect( format( '%p' , 1 ) ).to.be( '+0%' ) ;\n\t\texpect( format( '%p' , 0 ) ).to.be( '-100%' ) ;\n\t\texpect( format( '%p' , -1 ) ).to.be( '-200%' ) ;\n\t\texpect( format( '%p' , 1.23 ) ).to.be( '+23%' ) ;\n\t\texpect( format( '%p' , 0.45 ) ).to.be( '-55%' ) ;\n\n\t\texpect( format( '%p' , 1.2345 ) ).to.be( '+23%' ) ;\n\t\texpect( format( '%[.1]p' , 1.2345 ) ).to.be( '+23.4%' ) ;\n\t\texpect( format( '%p' , 0.12345 ) ).to.be( '-88%' ) ;\n\t\texpect( format( '%[.1]p' , 0.12345 ) ).to.be( '-87.7%' ) ;\n\n\t\texpect( format( '%[.1]p' , 1.00345 ) ).to.be( '+0.3%' ) ;\n\t\texpect( format( '%[.1z0]p' , 1.00345 ) ).to.be( '+.3%' ) ;\n\t\texpect( format( '%[.1]p' , 0.997 ) ).to.be( '-0.3%' ) ;\n\t\texpect( format( '%[.1z0]p' , 0.997 ) ).to.be( '-.3%' ) ;\n\n\t\t// Check that setting up precision bypass the default rounding\n\t\texpect( format( '%[4]p' , 0.9975 ) ).to.be( '-0.25%' ) ;\n\t\texpect( format( '%[5]p' , 1.2345 ) ).to.be( '+23.45%' ) ;\n\t} ) ;\n\n\tit( \"%k should format with multipliers\" , () => {\n\t\texpect( format( '%k' , 123 ) ).to.be( '123' ) ;\n\t\texpect( format( '%k' , 1234 ) ).to.be( '1.23k' ) ;\n\t\texpect( format( '%k' , 12345 ) ).to.be( '12.3k' ) ;\n\t\texpect( format( '%k' , 123456 ) ).to.be( '123k' ) ;\n\t\texpect( format( '%k' , 1.2345 ) ).to.be( '1.23' ) ;\n\t\texpect( format( '%k' , 12.345 ) ).to.be( '12.3' ) ;\n\t\texpect( format( '%k' , 123.45 ) ).to.be( '123' ) ;\n\t\texpect( format( '%k' , 1000 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 1001 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 1005 ) ).to.be( '1.01k' ) ;\n\t\texpect( format( '%k' , 999.999 ) ).to.be( '1k' ) ;\n\t\texpect( format( '%k' , 999.499 ) ).to.be( '999' ) ;\n\t\texpect( format( '%k' , 0.999 ) ).to.be( '999m' ) ;\n\t\texpect( format( '%k' , 0.0999 ) ).to.be( '99.9m' ) ;\n\t\texpect( format( '%k' , 0.00999 ) ).to.be( '9.99m' ) ;\n\t\texpect( format( '%k' , 0.000999 ) ).to.be( '999\u00b5' ) ;\n\t\texpect( format( '%k' , 0.0000999 ) ).to.be( '99.9\u00b5' ) ;\n\t\texpect( format( '%k' , 0.00000999 ) ).to.be( '9.99\u00b5' ) ;\n\t\texpect( format( '%k' , 0.00000000999 ) ).to.be( '9.99n' ) ;\n\t\texpect( format( '%k' , 0.00000000000999 ) ).to.be( '9.99p' ) ;\n\t\texpect( format( '%k' , 0.00000000000000999 ) ).to.be( '9.99f' ) ;\n\t\texpect( format( '%k' , 123400 ) ).to.be( '123k' ) ;\n\t\texpect( format( '%k' , 123400000 ) ).to.be( '123M' ) ;\n\t\texpect( format( '%k' , 123400000000 ) ).to.be( '123G' ) ;\n\t\texpect( format( '%k' , 123400000000000 ) ).to.be( '123T' ) ;\n\t\texpect( format( '%k' , 123400000000000000 ) ).to.be( '123P' ) ;\n\t\texpect( format( '%k' , 123400000000000000000 ) ).to.be( '123E' ) ;\n\t\texpect( format( '%k' , -12.345 ) ).to.be( '-12.3' ) ;\n\t\texpect( format( '%k' , -123400000 ) ).to.be( '-123M' ) ;\n\t\texpect( format( '%k' , -0.00000000999 ) ).to.be( '-9.99n' ) ;\n\n\t\t// With modes\n\t\texpect( format( '%[4]k' , 1234 ) ).to.be( '1.234k' ) ;\n\t} ) ;\n\n\tit( \"%m degree minute seconds notation\" , () => {\n\t\texpect( format( '%m' , 0 ) ).to.be( '0\u00b0' ) ;\n\t\texpect( format( '%m' , 10 ) ).to.be( '10\u00b0' ) ;\n\t\texpect( format( '%m' , -10 ) ).to.be( '-10\u00b0' ) ;\n\t\texpect( format( '%m' , 1 + 17 / 60 ) ).to.be( '1\u00b017\u2032' ) ;\n\t\texpect( format( '%m' , 1 + 1 / 60 + 1 / 3600 ) ).to.be( '1\u00b001\u203201\u2033' ) ;\n\t\texpect( format( '%m' , 1 + 59 / 60 + 59 / 3600 ) ).to.be( '1\u00b059\u203259\u2033' ) ;\n\t\texpect( format( '%m' , - ( 1 + 59 / 60 + 59 / 3600 ) ) ).to.be( '-1\u00b059\u203259\u2033' ) ;\n\t} ) ;\n\t\n\tit( \"%t should format time duration\" , () => {\n\t\texpect( format( '%t' , 1000 ) ).to.be( '1s' ) ;\n\t\texpect( format( '%t' , 1234 ) ).to.be( '1s' ) ;\n\t\texpect( format( '%t' , 56789 ) ).to.be( '56s' ) ;\n\t\texpect( format( '%t' , 60000 ) ).to.be( '1min00s' ) ;\n\t\texpect( format( '%t' , 123456 ) ).to.be( '2min03s' ) ;\n\t\texpect( format( '%t' , 3600000 ) ).to.be( '1h00min00s' ) ;\n\t\texpect( format( '%t' , 3599999 ) ).to.be( '59min59s' ) ;\n\t\texpect( format( '%t' , 7890000 ) ).to.be( '2h11min30s' ) ;\n\t} ) ;\n\n\tit( \"%z should format as base64\" , () => {\n\t\texpect( format( '%z' , 'some text' ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%z' , Buffer.from( 'some text' ) ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%z' , 'some longer text' ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA==' ) ;\n\t\texpect( format( '%z' , Buffer.from( 'some longer text' ) ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA==' ) ;\n\t\texpect( format( '%z' , Buffer.from( '+/c=' , 'base64' ) ) ).to.be( '+/c=' ) ;\n\t} ) ;\n\n\tit( \"%Z should format as base64-url\" , () => {\n\t\texpect( format( '%Z' , 'some text' ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%Z' , Buffer.from( 'some text' ) ) ).to.be( 'c29tZSB0ZXh0' ) ;\n\t\texpect( format( '%Z' , 'some longer text' ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA' ) ;\n\t\texpect( format( '%Z' , Buffer.from( 'some longer text' ) ) ).to.be( 'c29tZSBsb25nZXIgdGV4dA' ) ;\n\t\texpect( format( '%Z' , Buffer.from( '+/c=' , 'base64' ) ) ).to.be( '-_c' ) ;\n\t} ) ;\n\n\tit( \"should perform well the argument's index feature\" , () => {\n\t\texpect( format( '%s%s%s' , 'A' , 'B' , 'C' ) ).to.be( 'ABC' ) ;\n\t\texpect( format( '%+1s%-1s%s' , 'A' , 'B' , 'C' ) ).to.be( 'BAC' ) ;\n\t\texpect( format( '%3s%s' , 'A' , 'B' , 'C' ) ).to.be( 'CBC' ) ;\n\t} ) ;\n\n\tit( \"%n natural\" , () => {\n\t\texpect( format( '%n' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%n' , 1.23456789 ) ).to.be( '1.235' ) ;\n\t\texpect( format( '%n' , true ) ).to.be( 'true' ) ;\n\t\texpect( format( '%n' , false ) ).to.be( 'false' ) ;\n\t\texpect( format( '%n' , null ) ).to.be( 'null' ) ;\n\n\t\texpect( format( '%n' , [ 'one' , 'two' , 'three' ] ) ).to.be( '[one,two,three]' ) ;\n\t\t\n\t\t// Object and key sorting\n\t\texpect( format( '%n' , { bob: 3 , alice: 4 , john: 2 , jack: 3 } ) ).to.be( '{alice: 4, bob: 3, jack: 3, john: 2}' ) ;\n\t} ) ;\n\n\tit( \"%N more natural\" , () => {\n\t\texpect( format( '%N' , 12345 ) ).to.be( '12 345' ) ;\n\t\texpect( format( '%N' , 1.23456789 ) ).to.be( '1.235' ) ;\n\t\texpect( format( '%N' , true ) ).to.be( 'true' ) ;\n\t\texpect( format( '%N' , false ) ).to.be( 'false' ) ;\n\t\texpect( format( '%N' , null ) ).to.be( 'null' ) ;\n\n\t\texpect( format( '%N' , [ 'one' , 'two' , 'three' ] ) ).to.be( 'one, two, three' ) ;\n\n\t\t// Object and key sorting\n\t\texpect( format( '%N' , { bob: 3 , alice: 4 , john: 2 , jack: 3 } ) ).to.be( 'alice: 4, bob: 3, jack: 3, john: 2' ) ;\n\t} ) ;\n\t\n\tit( \"format.count() should count the number of arguments found\" , () => {\n\t\texpect( format.count( 'blah blih blah' ) ).to.be( 0 ) ;\n\t\texpect( format.count( 'blah blih %% blah' ) ).to.be( 0 ) ;\n\t\texpect( format.count( '%i %s' ) ).to.be( 2 ) ;\n\t\texpect( format.count( '%1i %1s' ) ).to.be( 1 ) ;\n\t\texpect( format.count( '%5i' ) ).to.be( 5 ) ;\n\t\texpect( format.count( '%[unexistant]F' ) ).to.be( 0 ) ;\n\t\texpect( format.count( '%[unexistant:%a%a]F' ) ).to.be( 2 ) ;\n\t} ) ;\n\n\tit( \"format.hasFormatting() should return true if the string has formatting and thus need to be interpreted, or false otherwise\" , () => {\n\t\texpect( format.hasFormatting( 'blah blih blah' ) ).to.be( false ) ;\n\t\texpect( format.hasFormatting( 'blah blih %% blah' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%i %s' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%[unexistant]F' ) ).to.be( true ) ;\n\t\texpect( format.hasFormatting( '%[unexistant:%a%a]F' ) ).to.be( true ) ;\n\t} ) ;\n\n\tit( \"when using a filter object as the *this* context, the %[functionName]F format should use a custom function to format the input\" , () => {\n\t\tvar customFormat = string.createFormatter( {\n\t\t\tfn: {\n\t\t\t\tfixed: function() { return 'f' ; } ,\n\t\t\t\tdouble: function( str ) { return '' + str + str ; } ,\n\t\t\t\tfxy: function( a , b ) { return '' + ( a * a + b ) ; }\n\t\t\t}\n\t\t} ) ;\n\n\t\texpect( customFormat( '%[fixed]F' ) ).to.be( 'f' ) ;\n\t\texpect( customFormat( '%[fixed]F%s%s%s' , 'A' , 'B' , 'C' ) ).to.be( 'fABC' ) ;\n\t\texpect( customFormat( '%s%[fxy:%a%a]F' , 'f(x,y)=' , 5 , 3 ) ).to.be( 'f(x,y)=28' ) ;\n\t\texpect( customFormat( '%s%[fxy:%+1a%-1a]F' , 'f(x,y)=' , 5 , 3 ) ).to.be( 'f(x,y)=14' ) ;\n\t\texpect( customFormat( '%[unexistant]F' ) ).to.be( '' ) ;\n\t} ) ;\n\n\tit( \"'^' should add markup, defaulting to ansi markup\" , () => {\n\t\texpect( format( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( format( 'this is ^_underlined^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^_underlined^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^_underlined^:this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + 'this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^Bblue^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( format( 'this is ^Bblue^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"'^' markups are ignored when then 'noMarkup' option is on\" , () => {\n\t\tvar customFormat = string.createFormatter( { noMarkup: true } ) ;\n\n\t\texpect( customFormat( 'this is ^^ a caret' ) ).to.be( 'this is ^^ a caret' ) ;\n\t\texpect( customFormat( 'this is ^_underlined' ) ).to.be( 'this is ^_underlined' ) ;\n\t\texpect( customFormat( 'this is ^_underlined^: nope' ) ).to.be( 'this is ^_underlined^: nope' ) ;\n\t} ) ;\n\n\tit( \"'^' markup: shift feature\" , () => {\n\t\texpect( format( 'this background is ^#^bblue^ this is ^wwhite' ) )\n\t\t\t.to.be( 'this background is ' + ansi.bgBlue + 'blue' + ansi.reset + ' this is ' + ansi.white + 'white' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"should expose a stand-alone markup only method\" , () => {\n\t\texpect( string.markup( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( string.markup( 'this is ^_underlined^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^_underlined^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^_underlined^:this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.underline + 'underlined' + ansi.reset + 'this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^Bblue^: this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\t\texpect( string.markup( 'this is ^Bblue^ this is not' ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not' + ansi.reset ) ;\n\n\t\t// format syntax should be ignored\n\t\texpect( string.markup( 'this is ^Bblue^ this is not %d' , 5 ) )\n\t\t\t.to.be( 'this is ' + ansi.brightBlue + 'blue' + ansi.reset + ' this is not %d' + ansi.reset ) ;\n\t} ) ;\n\n\tit( \"should expose a stand-alone markup only method\" , () => {\n\t\tvar wwwFormatter = {\n\t\t\tendingMarkupReset: true ,\n\t\t\tmarkupReset: function( markupStack ) {\n\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\treturn str ;\n\t\t\t} ,\n\t\t\tmarkup: {\n\t\t\t\t\":\": function( markupStack ) {\n\t\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\t\treturn str ;\n\t\t\t\t} ,\n\t\t\t\t\" \": function( markupStack ) {\n\t\t\t\t\tvar str = '</span>'.repeat( markupStack.length ) ;\n\t\t\t\t\tmarkupStack.length = 0 ;\n\t\t\t\t\treturn str + ' ' ;\n\t\t\t\t} ,\n\n\t\t\t\t\"+\": '<span style=\"font-weight:bold\">' ,\n\t\t\t\t\"b\": '<span style=\"color:blue\">'\n\t\t\t}\n\t\t} ;\n\n\t\tvar wwwMarkup = string.markupMethod.bind( wwwFormatter ) ;\n\t\tvar wwwFormat = string.formatMethod.bind( wwwFormatter ) ;\n\n\t\texpect( wwwMarkup( 'this is ^^ a caret' ) ).to.be( 'this is ^ a caret' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^: this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span> this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^ this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span> this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^+bold^:this is not' ) )\n\t\t\t.to.be( 'this is <span style=\"font-weight:bold\">bold</span>this is not' ) ;\n\t\texpect( wwwMarkup( 'this is ^b^+blue bold' ) )\n\t\t\t.to.be( 'this is <span style=\"color:blue\"><span style=\"font-weight:bold\">blue bold</span></span>' ) ;\n\n\t\texpect( wwwFormat( 'this is ^b^+blue bold' ) )\n\t\t\t.to.be( 'this is <span style=\"color:blue\"><span style=\"font-weight:bold\">blue bold</span></span>' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Escape collection\" , () => {\n\n\tit( \"escape.control() should escape control characters\" , () => {\n\t\texpect( string.escape.control( 'Hello\\n\\t... world!' ) ).to.be( 'Hello\\\\n\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\n\\\\t... world!' ) ).to.be( 'Hello\\\\n\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\\\n\\\\\\t... world!' ) ).to.be( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ).to.be( 'Hello\\\\\\\\n\\\\\\\\t... world!' ) ;\n\n\t\texpect( string.escape.control( 'Nasty\\x00chars\\x1bhere\\x7f!' ) ).to.be( 'Nasty\\\\x00chars\\\\x1bhere\\\\x7f!' ) ;\n\t\texpect( string.escape.control( 'Nasty\\n\\x00chars\\t\\x1bhere\\x7f!' ) ).to.be( 'Nasty\\\\n\\\\x00chars\\\\t\\\\x1bhere\\\\x7f!' ) ;\n\n\t\texpect( string.escape.control( 'Hello\\n\\t... world!' , true ) ).to.be( 'Hello\\n\\t... world!' ) ;\n\t\texpect( string.escape.control( 'Nasty\\n\\x00chars\\t\\x1bhere\\x7f!' , true ) ).to.be( 'Nasty\\n\\\\x00chars\\t\\\\x1bhere\\\\x7f!' ) ;\n\t} ) ;\n\n\tit( \"escape.shellArg() should escape a string so that it will be suitable as a shell command's argument\" , () => {\n\t\t//console.log( 'Shell arg:' , string.escape.shellArg( \"Here's my shell's argument\" ) ) ;\n\t\texpect( string.escape.shellArg( \"Here's my shell's argument\" ) ).to.be( \"'Here'\\\\''s my shell'\\\\''s argument'\" ) ;\n\t} ) ;\n\n\tit( \"escape.jsSingleQuote() should escape a string so that it will be suitable as a JS string code\" , () => {\n\t\texpect( string.escape.jsSingleQuote( \"A string with 'single' quotes\" ) ).to.be( \"A string with \\\\'single\\\\' quotes\" ) ;\n\t\texpect( string.escape.jsSingleQuote( \"A string with 'single' quotes\\nand new\\nlines\" ) ).to.be( \"A string with \\\\'single\\\\' quotes\\\\nand new\\\\nlines\" ) ;\n\t} ) ;\n\n\tit( \"escape.jsDoubleQuote() should escape a string so that it will be suitable as a JS string code\" , () => {\n\t\texpect( string.escape.jsDoubleQuote( 'A string with \"double\" quotes' ) ).to.be( 'A string with \\\\\"double\\\\\" quotes' ) ;\n\t\texpect( string.escape.jsDoubleQuote( 'A string with \"double\" quotes\\nand new\\nlines' ) ).to.be( 'A string with \\\\\"double\\\\\" quotes\\\\nand new\\\\nlines' ) ;\n\t} ) ;\n\n\tit( \"escape.regExp() should escape a string so that it will be suitable as a literal string into a regular expression pattern\" , () => {\n\t\t//console.log( 'String in RegExp:' , string.escape.regExp( \"(This) {is} [my] ^$tring^... +doesn't+ *it*? |yes| \\\\no\\\\ /maybe/\" ) ) ;\n\t\texpect( string.escape.regExp( \"(This) {is} [my] ^$tring^... +doesn't+ *it*? |yes| \\\\no\\\\ /maybe/\" ) )\n\t\t\t.to.be( \"\\\\(This\\\\) \\\\{is\\\\} \\\\[my\\\\] \\\\^\\\\$tring\\\\^\\\\.\\\\.\\\\. \\\\+doesn't\\\\+ \\\\*it\\\\*\\\\? \\\\|yes\\\\| \\\\\\\\no\\\\\\\\ \\\\/maybe\\\\/\" ) ;\n\t} ) ;\n\n\tit( \"escape.regExpReplacement() should escape a string so that it will be suitable as a literal string into a regular expression replacement\" , () => {\n\t\texpect( string.escape.regExpReplacement( \"$he love$ dollar$ $$$\" ) ).to.be( \"$$he love$$ dollar$$ $$$$$$\" ) ;\n\n\t\texpect(\n\t\t\t'$he love$ dollar$ $$$'.replace(\n\t\t\t\tnew RegExp( string.escape.regExp( '$' ) , 'g' ) ,\n\t\t\t\tstring.escape.regExpReplacement( '$1' )\n\t\t\t)\n\t\t).to.be( \"$1he love$1 dollar$1 $1$1$1\" ) ;\n\t} ) ;\n\n\tit( \"escape.html() should escape a string so that it will be suitable as HTML content\" , () => {\n\t\t//console.log( string.escape.html( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.html( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn't \\\"R&amp;D\\\"\" ) ;\n\t} ) ;\n\n\tit( \"escape.htmlAttr() should escape a string so that it will be suitable as an HTML tag attribute's value\" , () => {\n\t\t//console.log( string.escape.htmlAttr( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.htmlAttr( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn't &quot;R&amp;D&quot;\" ) ;\n\t} ) ;\n\n\tit( \"escape.htmlSpecialChars() should escape all HTML special characters\" , () => {\n\t\t//console.log( string.escape.htmlSpecialChars( \"<This> isn't \\\"R&D\\\"\" ) ) ;\n\t\texpect( string.escape.htmlSpecialChars( \"<This> isn't \\\"R&D\\\"\" ) ).to.be( \"&lt;This&gt; isn&#039;t &quot;R&amp;D&quot;\" ) ;\n\t} ) ;\n\n\tit( \"escape.unicodePercentEncoding() should escape all control chars and codepoint greater than 255 using percent encoding\" , () => {\n\t\texpect( string.escape.unicodePercentEncode( \"regular\" ) ).to.be( \"regular\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"some \u00absp\u20ac\u00a2ial\u00bb\" ) ).to.be( \"some \u00absp%E2%82%AC\u00a2ial\u00bb\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"percent % encoding\" ) ).to.be( \"percent %25 encoding\" ) ;\n\t\texpect( string.escape.unicodePercentEncode( \"\\n\\t\\r\" ) ).to.be( \"%0A%09%0D\" ) ;\n\t} ) ;\n\n\tit( \"escape.httpHeaderValue()\" , () => {\n\t\texpect( string.escape.httpHeaderValue( \"regular\" ) ).to.be( \"regular\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"some \u00absp\u20ac\u00a2ial\u00bb\" ) ).to.be( \"some \u00absp%E2%82%AC\u00a2ial\u00bb\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"percent % encoding\" ) ).to.be( \"percent %25 encoding\" ) ;\n\t\texpect( string.escape.httpHeaderValue( \"\\n\\t\\r\" ) ).to.be( \"%0A%09%0D\" ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Camel case\" , () => {\n\n\tit( \".toCamelCase() should transform a string composed of alphanum - minus - underscore to a camelCase string\" , () => {\n\t\texpect( string.toCamelCase( 'one-two-three' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'one_two_three' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'OnE-tWo_tHree' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'ONE-TWO-THREE' ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'a-b-c' ) ).to.be( 'aBC' ) ;\n\t} ) ;\n\n\tit( \".toCamelCase() with uppercase preservation on\" , () => {\n\t\texpect( string.toCamelCase( 'one-two-three' , true ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'one_two_three' , true ) ).to.be( 'oneTwoThree' ) ;\n\t\texpect( string.toCamelCase( 'OnE-tWo_tHree' , true ) ).to.be( 'OnETWoTHree' ) ;\n\t\texpect( string.toCamelCase( 'onE-TWo_tHree' , true ) ).to.be( 'onETWoTHree' ) ;\n\t\texpect( string.toCamelCase( 'ONE-TWO-THREE' , true ) ).to.be( 'ONETWOTHREE' ) ;\n\t\texpect( string.toCamelCase( 'a-b-c' , true ) ).to.be( 'aBC' ) ;\n\t} ) ;\n\n\tit( \".toCamelCase() edge cases\" , () => {\n\t\texpect( string.toCamelCase( '' ) ).to.be( '' ) ;\n\t\texpect( string.toCamelCase() ).to.be( '' ) ;\n\t\texpect( string.toCamelCase( 'u' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( 'U' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( 'U-b' ) ).to.be( 'uB' ) ;\n\t\texpect( string.toCamelCase( 'U-' ) ).to.be( 'u' ) ;\n\t\texpect( string.toCamelCase( '-U' ) ).to.be( 'u' ) ;\n\t} ) ;\n\n\tit( \".camelCaseToDashed() should transform a string composed of alphanum - minus - underscore to a camelCase string\" , () => {\n\t\texpect( string.camelCaseToDashed( 'oneTwoThree' ) ).to.be( 'one-two-three' ) ;\n\t\texpect( string.camelCaseToDashed( 'OneTwoThree' ) ).to.be( 'one-two-three' ) ;\n\t\texpect( string.camelCaseToDashed( 'aBC' ) ).to.be( 'a-b-c' ) ;\n\t} ) ;\n\n\t//it( \".camelCaseToDashed() edge cases\" , function() {} ) ;\n} ) ;\n\n\n\ndescribe( \"Latinize\" , () => {\n\n\tit( \".latinize() should transform to regular latin letters without any accent\" , () => {\n\t\texpect( string.latinize( '\u00e9\u00e0\u00e8\u00f9\u00e2\u00ea\u00ee\u00f4\u00fb\u00c2\u00ca\u00ce\u00d4\u00db\u00e4\u00eb\u00ef\u00f6\u00fc\u00c4\u00cb\u00cf\u00d6\u00dc\u00e6\u00c6\u0167\u00f8\u00fe\u00df\u00f0\u0111\u0127\u0142' ) )\n\t\t\t.to.be( 'eaeuaeiouAEIOUaeiouAEIOUaeAEtothssdhdhl' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Wordwrap\" , () => {\n\n\tit( \".wordwrap() should wrap words\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , 10 ) ).to.be( 'one two\\nthree four\\nfive six\\nseven' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six seven' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six seven' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six seven' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six   ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix   ' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should preserve explicit new lines\" , () => {\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n\\n' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n\\n' ) ;\n\t\texpect( string.wordwrap( 'one\\ntwo three four five six\\n ' , 10 ) ).to.be( 'one\\ntwo three\\nfour five\\nsix\\n ' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should right-trim all lines except the last\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six   ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix   ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n ' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n ' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six\\n\\n' , 10 ) ).to.be( '   one\\ntwo three\\nfour five\\nsix\\n\\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three! four five! six \\n' , 10 ) ).to.be( '   one\\ntwo three!\\nfour five!\\nsix\\n' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() should preserve space before breaking-lines\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , { width: 10 , noTrim: true } ) ).to.be( '   one    \\ntwo three\\nfour five\\nsix \\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three! four five! six \\n' , { width: 10 , noTrim: true } ) ).to.be( '   one    \\ntwo three!\\nfour five!\\nsix \\n' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'fill' option\" , () => {\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six \\n' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix       \\n' ) ;\n\t\texpect( string.wordwrap( '   one        \\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( '   one\\ntwo three four five six' , { width: 10 , fill: true } ) ).to.be( '   one    \\ntwo three \\nfour five \\nsix' ) ;\n\t\texpect( string.wordwrap( 'onetwo three four five six' , { width: 10 , fill: true } ) ).to.be( 'onetwo    \\nthree four\\nfive six' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'offset' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , offset: 5 } ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'offset' and 'updateOffset' options\" , () => {\n\t\tvar column = { width: 10 , offset: 5 , updateOffset: true } ;\n\t\texpect( string.wordwrap( 'one two three four five six seven' , column ) ).to.be( 'one\\ntwo three\\nfour five\\nsix seven' ) ;\n\t\texpect( column.offset ).to.be( 9 ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'glue' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , glue: '<br />\\n' } ) ).to.be( 'one two<br />\\nthree four<br />\\nfive six<br />\\nseven' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and the 'noJoin' option\" , () => {\n\t\texpect( string.wordwrap( 'one two three four five six seven' , { width: 10 , noJoin: true } ) ).to.equal( [ 'one two' , 'three four' , 'five six' , 'seven' ] ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and surrogate pairs\" , () => {\n\t\texpect( string.wordwrap( '\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06' , 9 ) ).to.be( '\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\\n\ud834\udf06\ud834\udf06\ud834\udf06 \ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06\ud834\udf06' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and fullwidth chars\" , () => {\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09' ) ;\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09' ) ;\n\t\texpect( string.wordwrap( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09 \ud87e\udc09 \ud87e\udc09 \ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\ud87e\udc09' , 10 ) ).to.be( '\ud87e\udc09\ud87e\udc09 \ud87e\udc09\ud87e\udc09\\n\ud87e\udc09 \ud87e\udc09 \ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\\n\ud87e\udc09\ud87e\udc09\ud87e\udc09' ) ;\n\t} ) ;\n\n\tit( \".wordwrap() and french typography rules with '!', '?', ':' and ';'\" , () => {\n\t\texpect( string.wordwrap( 'un ! deux ? trois : quatre ; cinq !' , 10 ) ).to.be( 'un !\\ndeux ?\\ntrois :\\nquatre ;\\ncinq !' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"inspect()\" , () => {\n\n\tit( \"should inspect a variable with default options accordingly\" , () => {\n\t\tvar MyClass = function MyClass() {\n\t\t\tthis.variable = 1 ;\n\t\t} ;\n\n\t\tMyClass.prototype.report = function report() { console.log( 'Variable value:' , this.variable ) ; } ;\n\t\tMyClass.staticFunc = function staticFunc() { console.log( 'Static function.' ) ; } ;\n\n\t\tvar sparseArray = [] ;\n\t\tsparseArray[ 3 ] = 'three' ;\n\t\tsparseArray[ 10 ] = 'ten' ;\n\t\tsparseArray[ 20 ] = 'twenty' ;\n\t\tsparseArray.customProperty = 'customProperty' ;\n\n\t\tvar object = {\n\t\t\ta: 'A' ,\n\t\t\tb: 2 ,\n\t\t\tstr: 'Woot\\nWoot\\rWoot\\tWoot' ,\n\t\t\tsub: {\n\t\t\t\tu: undefined ,\n\t\t\t\tn: null ,\n\t\t\t\tt: true ,\n\t\t\t\tf: false\n\t\t\t} ,\n\t\t\temptyString: '' ,\n\t\t\temptyObject: {} ,\n\t\t\tlist: [ 'one' , 'two' , 'three' ] ,\n\t\t\temptyList: [] ,\n\t\t\tsparseArray: sparseArray ,\n\t\t\thello: function hello() { console.log( 'Hello!' ) ; } ,\n\t\t\tanonymous: function() { console.log( 'anonymous...' ) ; } ,\n\t\t\tclass: MyClass ,\n\t\t\tinstance: new MyClass() ,\n\t\t\tbuf: Buffer.from( 'This is a buffer!' )\n\t\t} ;\n\n\t\tobject.sub.circular = object ;\n\n\t\tObject.defineProperties( object , {\n\t\t\tc: { value: '3' } ,\n\t\t\td: {\n\t\t\t\tget: function() { throw new Error( 'Should not be called by the test' ) ; } ,\n\t\t\t\tset: function( value ) {}\n\t\t\t}\n\t\t} ) ;\n\n\t\t//console.log( '>>>>>' , string.escape.control( string.inspect( object ) ) ) ;\n\t\t//console.log( string.inspect( { style: 'color' } , object ) ) ;\n\t\tvar actual = string.inspect( object ) ;\n\t\tvar expected = '<Object> <object> {\\n    a: \"A\" <string>(1)\\n    b: 2 <number>\\n    str: \"Woot\\\\nWoot\\\\rWoot\\\\tWoot\" <string>(19)\\n    sub: <Object> <object> {\\n        u: undefined\\n        n: null\\n        t: true\\n        f: false\\n        circular: <Object> <object> [circular]\\n    }\\n    emptyString: \"\" <string>(0)\\n    emptyObject: <Object> <object> {}\\n    list: <Array>(3) <object> [\\n        [0] \"one\" <string>(3)\\n        [1] \"two\" <string>(3)\\n        [2] \"three\" <string>(5)\\n        length: 3 <number> <-conf -enum>\\n    ]\\n    emptyList: <Array>(0) <object> [\\n        length: 0 <number> <-conf -enum>\\n    ]\\n    sparseArray: <Array>(21) <object> [\\n        [3] \"three\" <string>(5)\\n        [10] \"ten\" <string>(3)\\n        [20] \"twenty\" <string>(6)\\n        length: 21 <number> <-conf -enum>\\n        customProperty: \"customProperty\" <string>(14)\\n    ]\\n    hello: <Function> hello(0) <function>\\n    anonymous: <Function> anonymous(0) <function>\\n    class: <Function> MyClass(0) <function>\\n    instance: <MyClass> <object> {\\n        variable: 1 <number>\\n    }\\n    buf: <Buffer 54 68 69 73 20 69 73 20 61 20 62 75 66 66 65 72 21> <Buffer>(17)\\n    c: \"3\" <string>(1) <-conf -enum -w>\\n    d: <getter/setter> {\\n        get: <Function> get(0) <function>\\n        set: <Function> set(1) <function>\\n    }\\n}\\n' ;\n\t\t//console.log( '\\n' + expected + '\\n\\n' + actual + '\\n\\n' ) ;\n\t\texpect( actual ).to.be( expected ) ;\n\t\t//console.log( string.inspect( { style: 'color' } , object ) ) ;\n\t} ) ;\n\n\tit( \"should pass the Array circular references bug\" , () => {\n\t\tvar array = [ [ 1 ] ] ;\n\t\texpect( string.inspect( array ) ).to.be( '<Array>(1) <object> [\\n    [0] <Array>(1) <object> [\\n        [0] 1 <number>\\n        length: 1 <number> <-conf -enum>\\n    ]\\n    length: 1 <number> <-conf -enum>\\n]\\n' ) ;\n\t} ) ;\n\n\tit( \"should inspect object with no constructor\" , () => {\n\t\texpect( string.inspect( Object.assign( Object.create( null ) , { a: 1 , b: 2 } ) ) ).to.be( '<(no constructor)> <object> {\\n    a: 1 <number>\\n    b: 2 <number>\\n}\\n' ) ;\n\t} ) ;\n\n\tit( \"should use target-specified's object substitution (.inspect method) when the option 'useInspect' is set\" , () => {\n\t\tfunction Obj() {\n\t\t\tthis.name = 'bob' ;\n\t\t}\n\n\t\tObj.prototype.inspect = function() { return '<' + this.name + '>' ; } ;\n\n\t\texpect( string.inspect( { useInspect: true } , new Obj() ) ).to.be( '<Obj> <object> => <bob>\\n' ) ;\n\t} ) ;\n\n\tit( \"should use target-specified's blacklist (.inspectPropertyBlackList is a Set) when the option 'useInspectPropertyBlackList' is set\" , () => {\n\t\tfunction Obj() {\n\t\t\tthis.name = 'bob' ;\n\t\t\tthis.app = {} ;\n\t\t}\n\n\t\tObj.prototype.inspectPropertyBlackList = new Set( [ 'app' ] ) ;\n\n\t\texpect( string.inspect( { useInspectPropertyBlackList: true } , new Obj() ) ).to.be( '<Obj> <object> {\\n    name: \"bob\" <string>(3)\\n}\\n' ) ;\n\t} ) ;\n\n\tit( \"special objects tests (ES6 Set & Map, MongoDB ObjectID)\" ) ;\n} ) ;\n\n\n\ndescribe( \"Title case\" , () => {\n\n\tit( \"Basic .toTitleCase() usages\" , () => {\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell Jean-Michel' ) ;\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' , { zealous: true } ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 Allcaps Mcdowell Jean-Michel' ) ;\n\t\texpect( string.toTitleCase( 'bob bill booo \u00e9lectron h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS McDowell jean-michel' , { zealous: true , preserveAllCaps: true } ) )\n\t\t\t.to.be( 'Bob Bill Booo \u00c9lectron H\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9 ALLCAPS Mcdowell Jean-Michel' ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Fuzzy string matching\" , () => {\n\n\tconst continents = [ 'africa' , 'america' , 'australia' , 'asia' , 'europe' ] ;\n\t\n\tconst things = [\n\t\t'the elven sword' ,\n\t\t'a jewel-encrusted egg' ,\n\t\t'a brass lantern' ,\n\t\t'a bag' ,\n\t\t'a lunch' ,\n\t\t'a rope' ,\n\t\t'a knife' ,\n\t\t'a throwing knife' ,\n\t\t'a bottle of water' ,\n\t\t'a rattle' ,\n\t\t'a helm' ,\n\t\t'a crossbow' ,\n\t\t'a bolt'\n\t] ;\n\t\n\tit( \"Levenshtein\" , () => {\n\t\texpect( string.fuzzy.levenshtein( 'amrica' , 'africa' ) ).to.be( 1 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'amrica' ) ).to.be( 1 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'armorica' ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'amierca' ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'bottle' , 'rattle' ) ).to.be( 2 ) ;\n\n\t\texpect( string.fuzzy.levenshtein( 'america' , 'america' ) ).to.be( 0 ) ;\n\t\texpect( string.fuzzy.levenshtein( 'america' , '' ) ).to.be( 7 ) ;\n\t\texpect( string.fuzzy.levenshtein( '' , 'america' ) ).to.be( 7 ) ;\n\t\texpect( string.fuzzy.levenshtein( '' , '' ) ).to.be( 0 ) ;\n\t} ) ;\n\n\tit( \"Score\" , () => {\n\t\texpect( string.fuzzy.score( 'armorica' , 'america' ) ).to.be.around( 5 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'amrica' , 'africa' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'amrica' , 'america' ) ).to.be.around( 6 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'amierca' , 'america' ) ).to.be.around( 5 / 7 ) ;\n\t\texpect( string.fuzzy.score( 'austia' , 'australia' ) ).to.be.around( 6 / 9 ) ;\n\t\texpect( string.fuzzy.score( 'austia' , 'asia' ) ).to.be.around( 2 / 4 ) ;\n\t\texpect( string.fuzzy.score( 'random' , 'australia' ) ).to.be.around( 1 / 9 ) ;\n\t\texpect( string.fuzzy.score( 'random' , 'africa' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( 'walter' , 'a bottle of water' ) ).to.be.around( 4 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'walter' , 'a brass lantern' ) ).to.be.around( 5 / 15 ) ;\n\t\texpect( string.fuzzy.score( 'bottle' , 'a bottle of water' ) ).to.be.around( 6 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'rattle' , 'a bottle of water' ) ).to.be.around( 4 / 17 ) ;\n\t\texpect( string.fuzzy.score( 'rottle' , 'bottle' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'battle' , 'bottle' ) ).to.be.around( 5 / 6 ) ;\n\t\texpect( string.fuzzy.score( 'lunctern' , 'a brass lantern' ) ).to.be.around( 5 / 15 ) ;\n\t\texpect( string.fuzzy.score( 'lunctern' , 'lantern' ) ).to.be.around( 5 / 7 ) ;\n\t\t\n\t\texpect( string.fuzzy.score( 'america' , 'america' ) ).to.be.around( 1 ) ;\n\t\texpect( string.fuzzy.score( 'america' , '' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( '' , 'america' ) ).to.be.around( 0 ) ;\n\t\texpect( string.fuzzy.score( '' , '' ) ).to.be.around( 1 ) ;\n\t} ) ;\n\n\tit( \"Best match\" , () => {\n\t\texpect( string.fuzzy.bestMatch( 'arica' , continents ) ).to.be( 'africa' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armorica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'austrica' , continents ) ).to.be( 'australia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'ausia' , continents ) ).to.be( 'asia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'austia' , continents ) ).to.be( 'australia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'astia' , continents ) ).to.be( 'asia' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'random' , continents ) ).to.be( 'australia' ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'sword' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'word' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lantern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'luntern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'luncten' , things ) ).to.be( 'a lunch' ) ;\n\t\t//expect( string.fuzzy.bestMatch( 'bottle' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'bottle' , things ) ).to.be( 'a rattle' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'water' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'walter' , things ) ).to.be( 'a brass lantern' ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'knife' , things ) ).to.be( 'a knife' ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestMatch( 'sword' , things , { indexOf: true } ) ).to.be( 0 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { indexOf: true } ) ).to.be( 2 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'bottle' , things , { indexOf: true } ) ).to.be( 9 ) ;\n\t} ) ;\n\n\tit( \"Best match with scoreLimit\" , () => {\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.3 } ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.4 } ) ).to.be( null ) ;\n\t\t\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.7 } ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents , { scoreLimit: 0.7 } ) ).to.be( 'america' ) ;\n\t\texpect( string.fuzzy.bestMatch( 'amierca' , continents , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestMatch( 'lunctern' , things , { scoreLimit: 0.4 , indexOf: true } ) ).to.be( -1 ) ;\n\t\texpect( string.fuzzy.bestMatch( 'armrica' , continents , { scoreLimit: 0.7 , indexOf: true } ) ).to.be( 1 ) ;\n\t} ) ;\n\n\tit( \"Best token match\" , () => {\n\t\texpect( string.fuzzy.bestTokenMatch( 'sword' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'word' , things ) ).to.be( 'the elven sword' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lantern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'luntern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'luncten' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'bottle' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'water' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'a walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'some walter' , things ) ).to.be( 'a bottle of water' ) ;\n\n\t\texpect( string.fuzzy.bestTokenMatch( 'knife' , things ) ).to.be( 'a knife' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'throwing knife' , things ) ).to.be( 'a throwing knife' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'throwing' , things ) ).to.be( 'a throwing knife' ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestTokenMatch( 'some walter' , things , { indexOf: true } ) ).to.be( 8 ) ;\n\t} ) ;\n\n\tit( \"Best token match with scoreLimit\" , () => {\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things , { scoreLimit: 0.6 } ) ).to.be( 'a brass lantern' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'lunctern' , things , { scoreLimit: 0.7 } ) ).to.be( null ) ;\n\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.7 } ) ).to.be( 'a bottle of water' ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.8 } ) ).to.be( null ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.7 , indexOf: true } ) ).to.be( 8 ) ;\n\t\texpect( string.fuzzy.bestTokenMatch( 'walter' , things , { scoreLimit: 0.8 , indexOf: true } ) ).to.be( -1 ) ;\n\t} ) ;\n\n\tit( \"Top match\" , () => {\n\t\texpect( string.fuzzy.topMatch( 'arica' , continents ) ).to.equal( [ 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'amrica' , continents ) ).to.equal( [ 'america' , 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'armorica' , continents ) ).to.equal( [ 'america' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'armrica' , continents ) ).to.equal( [ 'america' , 'africa' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'austrica' , continents ) ).to.equal( [ 'australia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'ausia' , continents ) ).to.equal( [ 'asia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'austia' , continents ) ).to.equal( [ 'australia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'astia' , continents ) ).to.equal( [ 'asia' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'random' , continents ) ).to.equal( [ 'australia' ] ) ;\n\n\t\texpect( string.fuzzy.topMatch( 'sword' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'word' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'lantern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'luntern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'lunctern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'luncten' , things ) ).to.equal( [ 'a lunch' , 'a brass lantern' ] ) ;\n\t\t//expect( string.fuzzy.topMatch( 'bottle' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'bottle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'water' , things ) ).to.equal( [ 'a bottle of water' , 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topMatch( 'walter' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\n\t\texpect( string.fuzzy.topMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topMatch( 'water' , things , { indexOf: true } ) ).to.equal( [ 8 , 2 ] ) ;\n\t} ) ;\n\n\tit( \"Top token match\" , () => {\n\t\texpect( string.fuzzy.topTokenMatch( 'sword' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'word' , things ) ).to.equal( [ 'the elven sword' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'lantern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'luntern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'lunctern' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'luncten' , things ) ).to.equal( [ 'a brass lantern' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'bottle' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'rattle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'rottle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'cottle' , things ) ).to.equal( [ 'a bottle of water' , 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'cattle' , things ) ).to.equal( [ 'a rattle' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'water' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'a walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'some walter' , things ) ).to.equal( [ 'a bottle of water' ] ) ;\n\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topTokenMatch( 'cottle' , things , { indexOf: true } ) ).to.equal( [ 8 , 9 ] ) ;\n\t} ) ;\n\n\tit( \"Top token match with deltaRate\" , () => {\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things , { deltaRate: 0.9 } ) ).to.equal( [ 'a knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'knife' , things , { deltaRate: 0.8 } ) ).to.equal( [ 'a knife' , 'a throwing knife' ] ) ;\n\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.6 } ) ).to.equal( [ 'a throwing knife' ] ) ;\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.4 } ) ).to.equal( [ 'a throwing knife' , 'a knife' ] ) ;\n\n\t\t// Using indexOf option\n\t\texpect( string.fuzzy.topTokenMatch( 'throwing knife' , things , { deltaRate: 0.4 , indexOf: true } ) ).to.equal( [ 7 , 6 ] ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Natural sort\" , () => {\n\n\tit( \"basic natural sort tests\" , () => {\n\t\texpect( [ 'one' , 'two' , 'three' ].sort( string.naturalSort ) ).to.equal( [ 'one' , 'three' , 'two' ] ) ;\n\t\t\n\t\t// Case insensitive\n\t\texpect( [ 'one' , 'two' , 'Three' ].sort( string.naturalSort ) ).to.equal( [ 'one' , 'Three' , 'two' ] ) ;\n\t\texpect( [ 'One' , 'Two' , 'three' ].sort( string.naturalSort ) ).to.equal( [ 'One' , 'three' , 'Two' ] ) ;\n\t\t\n\t\t// Uppercase first as a tie-breaker\n\t\texpect( [ 'one' , 'One' , 'two' , 'Two' , 'Three' , 'three' ].sort( string.naturalSort ) ).to.equal( [ 'One' , 'one' , 'Three' , 'three' , 'Two' , 'two' ] ) ;\n\t\t\n\t\t// Lesser number first\n\t\texpect( [ 'abc121' , 'abc17' , 'abc12' , 'abc134' ].sort( string.naturalSort ) ).to.equal( [ 'abc12' , 'abc17' , 'abc121' , 'abc134' ] ) ;\n\t\t\n\t\t// White space / word separator insensitive\n\t\texpect( [ '  One  ' , '   Two   ' , 'three' ].sort( string.naturalSort ) ).to.equal( [ '  One  ' , 'three' , '   Two   ' ] ) ;\n\t\texpect( [ 'abc   121' , 'abc 17' , 'abc  12' , 'abc    134' ].sort( string.naturalSort ) ).to.equal( [ 'abc  12' , 'abc 17' , 'abc   121' , 'abc    134' ] ) ;\n\t\texpect( [ 'a-123-a' , 'a_12_a' , 'a 18 a' ].sort( string.naturalSort ) ).to.equal( [ 'a_12_a' , 'a 18 a' , 'a-123-a' ] ) ;\n\t\texpect( [ 'a_123_a' , 'a-12-a' , 'a 18 a' ].sort( string.naturalSort ) ).to.equal( [ 'a-12-a' , 'a 18 a' , 'a_123_a' ] ) ;\n\t\t\n\t\t// Number with shorter char-width as a tie-breaker\n\t\texpect( [ 'abc00012' , 'abc012' , 'abc017' , 'abc12' , 'abc134' ].sort( string.naturalSort ) ).to.equal( [ 'abc12' , 'abc012' , 'abc00012' , 'abc017' , 'abc134' ] ) ;\n\t\t\n\t\t// Symbols\n\t\texpect( [ ';+$' , '!:;,' , '\u201c\u201d' ].sort( string.naturalSort ) ).to.equal( [ \"!:;,\" , \";+$\" , \"\u201c\u201d\" ] ) ;\n\t} ) ;\n} ) ;\n\n\n\ndescribe( \"Misc\" , () => {\n\n\tit( \".resize()\" , () => {\n\t\texpect( string.resize( 'bobby' , 3 ) ).to.be( 'bob' ) ;\n\t\texpect( string.resize( 'bobby' , 5 ) ).to.be( 'bobby' ) ;\n\t\texpect( string.resize( 'bobby' , 8 ) ).to.be( 'bobby   ' ) ;\n\t} ) ;\n\n\tit( \".occurrenceCount()\" , () => {\n\t\texpect( string.occurrenceCount( '' , '' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'three' , '' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( '' , 'o' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( '' , 'omg' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'three' , 'o' ) ).to.be( 0 ) ;\n\t\texpect( string.occurrenceCount( 'o' , 'o' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'ooo' , 'o' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'ooo' , 'oo' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'aooo' , 'oo' ) ).to.be( 1 ) ;\n\t\texpect( string.occurrenceCount( 'aoooo' , 'oo' ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'one two three four' , 'o' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'one one one' , 'one' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'one' ) ).to.be( 3 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'oneone' ) ).to.be( 1 ) ;\n\t} ) ;\n\n\tit( \".occurrenceCount() with overlap\" , () => {\n\t\texpect( string.occurrenceCount( 'ooo' , 'oo' , true ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'aooo' , 'oo' , true ) ).to.be( 2 ) ;\n\t\texpect( string.occurrenceCount( 'oneoneone' , 'oneone' , true ) ).to.be( 2 ) ;\n\t} ) ;\n} ) ;\n\n"], "filenames": ["CHANGELOG", "lib/naturalSort.js", "lib/string.js", "package.json", "test/string-test.js"], "buggy_code_start_loc": [0, 31, 31, 3, 1065], "buggy_code_end_loc": [0, 84, 32, 4, 1078], "fixing_code_start_loc": [1, 31, 31, 3, 1066], "fixing_code_end_loc": [7, 146, 32, 4, 1102], "type": "CWE-1333", "message": "A vulnerability classified as problematic was found in cronvel string-kit up to 0.12.7. This vulnerability affects the function naturalSort of the file lib/naturalSort.js. The manipulation leads to inefficient regular expression complexity. The attack can be initiated remotely. Upgrading to version 0.12.8 is able to address this issue. The name of the patch is 9cac4c298ee92c1695b0695951f1488884a7ca73. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217180.", "other": {"cve": {"id": "CVE-2021-4299", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-02T08:15:10.277", "lastModified": "2023-01-09T17:22:22.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic was found in cronvel string-kit up to 0.12.7. This vulnerability affects the function naturalSort of the file lib/naturalSort.js. The manipulation leads to inefficient regular expression complexity. The attack can be initiated remotely. Upgrading to version 0.12.8 is able to address this issue. The name of the patch is 9cac4c298ee92c1695b0695951f1488884a7ca73. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217180."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:string_kit_project:string_kit:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.12.8", "matchCriteriaId": "5DDD2BF2-F860-413C-A33F-8D5F3E02D4EA"}]}]}], "references": [{"url": "https://github.com/cronvel/string-kit/commit/9cac4c298ee92c1695b0695951f1488884a7ca73", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cronvel/string-kit/releases/tag/v0.12.8", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217180", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217180", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cronvel/string-kit/commit/9cac4c298ee92c1695b0695951f1488884a7ca73"}}