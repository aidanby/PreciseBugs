{"buggy_code": ["/*\n * Linux Socket Filter - Kernel level socket filtering\n *\n * Based on the design of the Berkeley Packet Filter. The new\n * internal format has been designed by PLUMgrid:\n *\n *\tCopyright (c) 2011 - 2014 PLUMgrid, http://plumgrid.com\n *\n * Authors:\n *\n *\tJay Schulist <jschlst@samba.org>\n *\tAlexei Starovoitov <ast@plumgrid.com>\n *\tDaniel Borkmann <dborkman@redhat.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * Andi Kleen - Fix a few bad bugs and races.\n * Kris Katterjohn - Added many additional checks in sk_chk_filter()\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_packet.h>\n#include <linux/gfp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/netlink.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <asm/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/filter.h>\n#include <linux/ratelimit.h>\n#include <linux/seccomp.h>\n#include <linux/if_vlan.h>\n\n/* No hurry in this branch\n *\n * Exported for the bpf jit load helper.\n */\nvoid *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb, int k, unsigned int size)\n{\n\tu8 *ptr = NULL;\n\n\tif (k >= SKF_NET_OFF)\n\t\tptr = skb_network_header(skb) + k - SKF_NET_OFF;\n\telse if (k >= SKF_LL_OFF)\n\t\tptr = skb_mac_header(skb) + k - SKF_LL_OFF;\n\n\tif (ptr >= skb->head && ptr + size <= skb_tail_pointer(skb))\n\t\treturn ptr;\n\treturn NULL;\n}\n\nstatic inline void *load_pointer(const struct sk_buff *skb, int k,\n\t\t\t\t unsigned int size, void *buffer)\n{\n\tif (k >= 0)\n\t\treturn skb_header_pointer(skb, k, size, buffer);\n\treturn bpf_internal_load_pointer_neg_helper(skb, k, size);\n}\n\n/**\n *\tsk_filter - run a packet through a socket filter\n *\t@sk: sock associated with &sk_buff\n *\t@skb: buffer to filter\n *\n * Run the filter code and then cut skb->data to correct size returned by\n * sk_run_filter. If pkt_len is 0 we toss packet. If skb->len is smaller\n * than pkt_len we keep whole skb->data. This is the socket level\n * wrapper to sk_run_filter. It returns 0 if the packet should\n * be accepted or -EPERM if the packet should be tossed.\n *\n */\nint sk_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\tstruct sk_filter *filter;\n\n\t/*\n\t * If the skb was allocated from pfmemalloc reserves, only\n\t * allow SOCK_MEMALLOC sockets to use it as this socket is\n\t * helping free memory\n\t */\n\tif (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC))\n\t\treturn -ENOMEM;\n\n\terr = security_sock_rcv_skb(sk, skb);\n\tif (err)\n\t\treturn err;\n\n\trcu_read_lock();\n\tfilter = rcu_dereference(sk->sk_filter);\n\tif (filter) {\n\t\tunsigned int pkt_len = SK_RUN_FILTER(filter, skb);\n\n\t\terr = pkt_len ? pskb_trim(skb, pkt_len) : -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\nEXPORT_SYMBOL(sk_filter);\n\n/* Base function for offset calculation. Needs to go into .text section,\n * therefore keeping it non-static as well; will also be used by JITs\n * anyway later on, so do not let the compiler omit it.\n */\nnoinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n{\n\treturn 0;\n}\n\n/**\n *\t__sk_run_filter - run a filter on a given context\n *\t@ctx: buffer to run the filter on\n *\t@insn: filter to apply\n *\n * Decode and apply filter instructions to the skb->data. Return length to\n * keep, 0 for none. @ctx is the data we are operating on, @insn is the\n * array of filter instructions.\n */\nunsigned int __sk_run_filter(void *ctx, const struct sock_filter_int *insn)\n{\n\tu64 stack[MAX_BPF_STACK / sizeof(u64)];\n\tu64 regs[MAX_BPF_REG], tmp;\n\tvoid *ptr;\n\tint off;\n\n#define K  insn->imm\n#define A  regs[insn->a_reg]\n#define X  regs[insn->x_reg]\n#define R0 regs[0]\n\n#define CONT\t ({insn++; goto select_insn; })\n#define CONT_JMP ({insn++; goto select_insn; })\n\n\tstatic const void *jumptable[256] = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n#define DL(A, B, C)\t[A|B|C] = &&A##_##B##_##C\n\t\tDL(BPF_ALU, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU, BPF_NEG, 0),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_BE),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_LE),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_NEG, 0),\n\t\tDL(BPF_JMP, BPF_CALL, 0),\n\t\tDL(BPF_JMP, BPF_JA, 0),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_X),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_K),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_K),\n\t\tDL(BPF_JMP, BPF_EXIT, 0),\n\t\tDL(BPF_STX, BPF_MEM, BPF_B),\n\t\tDL(BPF_STX, BPF_MEM, BPF_H),\n\t\tDL(BPF_STX, BPF_MEM, BPF_W),\n\t\tDL(BPF_STX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_STX, BPF_XADD, BPF_W),\n\t\tDL(BPF_STX, BPF_XADD, BPF_DW),\n\t\tDL(BPF_ST, BPF_MEM, BPF_B),\n\t\tDL(BPF_ST, BPF_MEM, BPF_H),\n\t\tDL(BPF_ST, BPF_MEM, BPF_W),\n\t\tDL(BPF_ST, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_B),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_H),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_W),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LD, BPF_ABS, BPF_W),\n\t\tDL(BPF_LD, BPF_ABS, BPF_H),\n\t\tDL(BPF_LD, BPF_ABS, BPF_B),\n\t\tDL(BPF_LD, BPF_IND, BPF_W),\n\t\tDL(BPF_LD, BPF_IND, BPF_H),\n\t\tDL(BPF_LD, BPF_IND, BPF_B),\n#undef DL\n\t};\n\n\tregs[FP_REG]  = (u64) (unsigned long) &stack[ARRAY_SIZE(stack)];\n\tregs[ARG1_REG] = (u64) (unsigned long) ctx;\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* ALU */\n#define ALU(OPCODE, OP)\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_X:\t\\\n\t\tA = A OP X;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_X:\t\\\n\t\tA = (u32) A OP (u32) X;\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_K:\t\\\n\t\tA = A OP K;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_K:\t\\\n\t\tA = (u32) A OP (u32) K;\t\\\n\t\tCONT;\n\n\tALU(BPF_ADD,  +)\n\tALU(BPF_SUB,  -)\n\tALU(BPF_AND,  &)\n\tALU(BPF_OR,   |)\n\tALU(BPF_LSH, <<)\n\tALU(BPF_RSH, >>)\n\tALU(BPF_XOR,  ^)\n\tALU(BPF_MUL,  *)\n#undef ALU\n\tBPF_ALU_BPF_NEG_0:\n\t\tA = (u32) -A;\n\t\tCONT;\n\tBPF_ALU64_BPF_NEG_0:\n\t\tA = -A;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_X:\n\t\tA = (u32) X;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_K:\n\t\tA = (u32) K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_X:\n\t\tA = X;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_K:\n\t\tA = K;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_X:\n\t\t(*(s64 *) &A) >>= X;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_K:\n\t\t(*(s64 *) &A) >>= K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = A;\n\t\tA = do_div(tmp, X);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) X);\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_K:\n\t\ttmp = A;\n\t\tA = do_div(tmp, K);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_K:\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) K);\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\tdo_div(A, X);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) X);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_K:\n\t\tdo_div(A, K);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_K:\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) K);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_BE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_be16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_be32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_be64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_LE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_le16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_le32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_le64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tBPF_JMP_BPF_CALL_0:\n\t\t/* Function call scratches R1-R5 registers, preserves R6-R9,\n\t\t * and stores return value into R0.\n\t\t */\n\t\tR0 = (__bpf_call_base + insn->imm)(regs[1], regs[2], regs[3],\n\t\t\t\t\t\t   regs[4], regs[5]);\n\t\tCONT;\n\n\t/* JMP */\n\tBPF_JMP_BPF_JA_0:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_X:\n\t\tif (A == X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_K:\n\t\tif (A == K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_X:\n\t\tif (A != X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_K:\n\t\tif (A != K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_X:\n\t\tif (A > X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_K:\n\t\tif (A > K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_X:\n\t\tif (A >= X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_K:\n\t\tif (A >= K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_X:\n\t\tif (((s64)A) > ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_K:\n\t\tif (((s64)A) > ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_X:\n\t\tif (((s64)A) >= ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_K:\n\t\tif (((s64)A) >= ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_X:\n\t\tif (A & X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_K:\n\t\tif (A & K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_EXIT_0:\n\t\treturn R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\\\n\tBPF_STX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = X;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_ST_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = K;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_LDX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\tA = *(SIZE *)(unsigned long) (X + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(BPF_B,   u8)\n\tLDST(BPF_H,  u16)\n\tLDST(BPF_W,  u32)\n\tLDST(BPF_DW, u64)\n#undef LDST\n\tBPF_STX_BPF_XADD_BPF_W: /* lock xadd *(u32 *)(A + insn->off) += X */\n\t\tatomic_add((u32) X, (atomic_t *)(unsigned long)\n\t\t\t   (A + insn->off));\n\t\tCONT;\n\tBPF_STX_BPF_XADD_BPF_DW: /* lock xadd *(u64 *)(A + insn->off) += X */\n\t\tatomic64_add((u64) X, (atomic64_t *)(unsigned long)\n\t\t\t     (A + insn->off));\n\t\tCONT;\n\tBPF_LD_BPF_ABS_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + K)) */\n\t\toff = K;\nload_word:\n\t\t/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are only\n\t\t * appearing in the programs where ctx == skb. All programs\n\t\t * keep 'ctx' in regs[CTX_REG] == R6, sk_convert_filter()\n\t\t * saves it in R6, internal BPF verifier will check that\n\t\t * R6 == ctx.\n\t\t *\n\t\t * BPF_ABS and BPF_IND are wrappers of function calls, so\n\t\t * they scratch R1-R5 registers, preserve R6-R9, and store\n\t\t * return value into R0.\n\t\t *\n\t\t * Implicit input:\n\t\t *   ctx\n\t\t *\n\t\t * Explicit input:\n\t\t *   X == any register\n\t\t *   K == 32-bit immediate\n\t\t *\n\t\t * Output:\n\t\t *   R0 - 8/16/32-bit skb data converted to cpu endianness\n\t\t */\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 4, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be32(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + K)) */\n\t\toff = K;\nload_half:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 2, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be16(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_B: /* R0 = *(u8 *) (ctx + K) */\n\t\toff = K;\nload_byte:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 1, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = *(u8 *)ptr;\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_IND_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_word;\n\tBPF_LD_BPF_IND_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_half;\n\tBPF_LD_BPF_IND_BPF_B: /* R0 = *(u8 *) (skb->data + X + K) */\n\t\toff = K + X;\n\t\tgoto load_byte;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. */\n\t\tWARN_RATELIMIT(1, \"unknown opcode %02x\\n\", insn->code);\n\t\treturn 0;\n#undef CONT_JMP\n#undef CONT\n\n#undef R0\n#undef X\n#undef A\n#undef K\n}\n\nu32 sk_run_filter_int_seccomp(const struct seccomp_data *ctx,\n\t\t\t      const struct sock_filter_int *insni)\n    __attribute__ ((alias (\"__sk_run_filter\")));\n\nu32 sk_run_filter_int_skb(const struct sk_buff *ctx,\n\t\t\t  const struct sock_filter_int *insni)\n    __attribute__ ((alias (\"__sk_run_filter\")));\nEXPORT_SYMBOL_GPL(sk_run_filter_int_skb);\n\n/* Helper to find the offset of pkt_type in sk_buff structure. We want\n * to make sure its still a 3bit field starting at a byte boundary;\n * taken from arch/x86/net/bpf_jit_comp.c.\n */\n#define PKT_TYPE_MAX\t7\nstatic unsigned int pkt_type_offset(void)\n{\n\tstruct sk_buff skb_probe = { .pkt_type = ~0, };\n\tu8 *ct = (u8 *) &skb_probe;\n\tunsigned int off;\n\n\tfor (off = 0; off < sizeof(struct sk_buff); off++) {\n\t\tif (ct[off] == PKT_TYPE_MAX)\n\t\t\treturn off;\n\t}\n\n\tpr_err_once(\"Please fix %s, as pkt_type couldn't be found!\\n\", __func__);\n\treturn -1;\n}\n\nstatic u64 __skb_get_pay_offset(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\n\treturn __skb_get_poff(skb);\n}\n\nstatic u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n\nstatic u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n\nstatic u64 __get_raw_cpu_id(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\treturn raw_smp_processor_id();\n}\n\n/* Register mappings for user programs. */\n#define A_REG\t\t0\n#define X_REG\t\t7\n#define TMP_REG\t\t8\n#define ARG2_REG\t2\n#define ARG3_REG\t3\n\nstatic bool convert_bpf_extensions(struct sock_filter *fp,\n\t\t\t\t   struct sock_filter_int **insnp)\n{\n\tstruct sock_filter_int *insn = *insnp;\n\n\tswitch (fp->k) {\n\tcase SKF_AD_OFF + SKF_AD_PROTOCOL:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, protocol);\n\t\tinsn++;\n\n\t\t/* A = ntohs(A) [emitting a nop or swap16] */\n\t\tinsn->code = BPF_ALU | BPF_END | BPF_FROM_BE;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = 16;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PKTTYPE:\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_B;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = pkt_type_offset();\n\t\tif (insn->off < 0)\n\t\t\treturn false;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = PKT_TYPE_MAX;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_IFINDEX:\n\tcase SKF_AD_OFF + SKF_AD_HATYPE:\n\t\tif (FIELD_SIZEOF(struct sk_buff, dev) == 8)\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_DW;\n\t\telse\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, dev);\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_JNE | BPF_K;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->imm = 0;\n\t\tinsn->off = 1;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);\n\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = TMP_REG;\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX) {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->off = offsetof(struct net_device, ifindex);\n\t\t} else {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\t\tinsn->off = offsetof(struct net_device, type);\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_MARK:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, mark);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_RXHASH:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, hash);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_QUEUE:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, queue_mapping);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, vlan_tci);\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_VLAN_TAG) {\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = ~VLAN_TAG_PRESENT;\n\t\t} else {\n\t\t\tinsn->code = BPF_ALU | BPF_RSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 12;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 1;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t/* arg1 = ctx */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG1_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn++;\n\n\t\t/* arg2 = A */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG2_REG;\n\t\tinsn->x_reg = A_REG;\n\t\tinsn++;\n\n\t\t/* arg3 = X */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG3_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tinsn++;\n\n\t\t/* Emit call(ctx, arg2=A, arg3=X) */\n\t\tinsn->code = BPF_JMP | BPF_CALL;\n\t\tswitch (fp->k) {\n\t\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\t\t\tinsn->imm = __skb_get_pay_offset - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\t\t\tinsn->imm = __skb_get_nlattr - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\t\t\tinsn->imm = __skb_get_nlattr_nest - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t\tinsn->imm = __get_raw_cpu_id - __bpf_call_base;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_ALU_XOR_X:\n\t\tinsn->code = BPF_ALU | BPF_XOR | BPF_X;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tbreak;\n\n\tdefault:\n\t\t/* This is just a dummy call to avoid letting the compiler\n\t\t * evict __bpf_call_base() as an optimization. Placed here\n\t\t * where no-one bothers.\n\t\t */\n\t\tBUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);\n\t\treturn false;\n\t}\n\n\t*insnp = insn;\n\treturn true;\n}\n\n/**\n *\tsk_convert_filter - convert filter program\n *\t@prog: the user passed filter program\n *\t@len: the length of the user passed filter program\n *\t@new_prog: buffer where converted program will be stored\n *\t@new_len: pointer to store length of converted program\n *\n * Remap 'sock_filter' style BPF instruction set to 'sock_filter_ext' style.\n * Conversion workflow:\n *\n * 1) First pass for calculating the new program length:\n *   sk_convert_filter(old_prog, old_len, NULL, &new_len)\n *\n * 2) 2nd pass to remap in two passes: 1st pass finds new\n *    jump offsets, 2nd pass remapping:\n *   new_prog = kmalloc(sizeof(struct sock_filter_int) * new_len);\n *   sk_convert_filter(old_prog, old_len, new_prog, &new_len);\n *\n * User BPF's register A is mapped to our BPF register 6, user BPF\n * register X is mapped to BPF register 7; frame pointer is always\n * register 10; Context 'void *ctx' is stored in register 1, that is,\n * for socket filters: ctx == 'struct sk_buff *', for seccomp:\n * ctx == 'struct seccomp_data *'.\n */\nint sk_convert_filter(struct sock_filter *prog, int len,\n\t\t      struct sock_filter_int *new_prog, int *new_len)\n{\n\tint new_flen = 0, pass = 0, target, i;\n\tstruct sock_filter_int *new_insn;\n\tstruct sock_filter *fp;\n\tint *addrs = NULL;\n\tu8 bpf_src;\n\n\tBUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);\n\tBUILD_BUG_ON(FP_REG + 1 != MAX_BPF_REG);\n\n\tif (len <= 0 || len >= BPF_MAXINSNS)\n\t\treturn -EINVAL;\n\n\tif (new_prog) {\n\t\taddrs = kzalloc(len * sizeof(*addrs), GFP_KERNEL);\n\t\tif (!addrs)\n\t\t\treturn -ENOMEM;\n\t}\n\ndo_pass:\n\tnew_insn = new_prog;\n\tfp = prog;\n\n\tif (new_insn) {\n\t\tnew_insn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tnew_insn->a_reg = CTX_REG;\n\t\tnew_insn->x_reg = ARG1_REG;\n\t}\n\tnew_insn++;\n\n\tfor (i = 0; i < len; fp++, i++) {\n\t\tstruct sock_filter_int tmp_insns[6] = { };\n\t\tstruct sock_filter_int *insn = tmp_insns;\n\n\t\tif (addrs)\n\t\t\taddrs[i] = new_insn - new_prog;\n\n\t\tswitch (fp->code) {\n\t\t/* All arithmetic insns and skb loads map as-is. */\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_MOD | BPF_X:\n\t\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_ABS | BPF_W:\n\t\tcase BPF_LD | BPF_ABS | BPF_H:\n\t\tcase BPF_LD | BPF_ABS | BPF_B:\n\t\tcase BPF_LD | BPF_IND | BPF_W:\n\t\tcase BPF_LD | BPF_IND | BPF_H:\n\t\tcase BPF_LD | BPF_IND | BPF_B:\n\t\t\t/* Check for overloaded BPF extension and\n\t\t\t * directly convert it if found, otherwise\n\t\t\t * just move on with mapping.\n\t\t\t */\n\t\t\tif (BPF_CLASS(fp->code) == BPF_LD &&\n\t\t\t    BPF_MODE(fp->code) == BPF_ABS &&\n\t\t\t    convert_bpf_extensions(fp, &insn))\n\t\t\t\tbreak;\n\n\t\t\tinsn->code = fp->code;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = X_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tbreak;\n\n\t\t/* Jump opcodes map as-is, but offsets need adjustment. */\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\ttarget = i + fp->k + 1;\n\t\t\tinsn->code = fp->code;\n#define EMIT_JMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (target >= len || target < 0)\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\t\\\n\t\tinsn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;\t\\\n\t\t/* Adjust pc relative offset for 2nd or 3rd insn. */\t\\\n\t\tinsn->off -= insn - tmp_insns;\t\t\t\t\\\n\t} while (0)\n\n\t\t\tEMIT_JMP;\n\t\t\tbreak;\n\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\t\tif (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {\n\t\t\t\t/* BPF immediates are signed, zero extend\n\t\t\t\t * immediate into tmp register and use it\n\t\t\t\t * in compare insn.\n\t\t\t\t */\n\t\t\t\tinsn->code = BPF_ALU | BPF_MOV | BPF_K;\n\t\t\t\tinsn->a_reg = TMP_REG;\n\t\t\t\tinsn->imm = fp->k;\n\t\t\t\tinsn++;\n\n\t\t\t\tinsn->a_reg = A_REG;\n\t\t\t\tinsn->x_reg = TMP_REG;\n\t\t\t\tbpf_src = BPF_X;\n\t\t\t} else {\n\t\t\t\tinsn->a_reg = A_REG;\n\t\t\t\tinsn->x_reg = X_REG;\n\t\t\t\tinsn->imm = fp->k;\n\t\t\t\tbpf_src = BPF_SRC(fp->code);\n\t\t\t}\n\n\t\t\t/* Common case where 'jump_false' is next insn. */\n\t\t\tif (fp->jf == 0) {\n\t\t\t\tinsn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;\n\t\t\t\ttarget = i + fp->jt + 1;\n\t\t\t\tEMIT_JMP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Convert JEQ into JNE when 'jump_true' is next insn. */\n\t\t\tif (fp->jt == 0 && BPF_OP(fp->code) == BPF_JEQ) {\n\t\t\t\tinsn->code = BPF_JMP | BPF_JNE | bpf_src;\n\t\t\t\ttarget = i + fp->jf + 1;\n\t\t\t\tEMIT_JMP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Other jumps are mapped into two insns: Jxx and JA. */\n\t\t\ttarget = i + fp->jt + 1;\n\t\t\tinsn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;\n\t\t\tEMIT_JMP;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_JMP | BPF_JA;\n\t\t\ttarget = i + fp->jf + 1;\n\t\t\tEMIT_JMP;\n\t\t\tbreak;\n\n\t\t/* ldxb 4 * ([14] & 0xf) is remaped into 6 insns. */\n\t\tcase BPF_LDX | BPF_MSH | BPF_B:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = TMP_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_LD | BPF_ABS | BPF_B;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 0xf;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_LSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 2;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = X_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = TMP_REG;\n\t\t\tbreak;\n\n\t\t/* RET_K, RET_A are remaped into 2 insns. */\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_RET | BPF_K:\n\t\t\tinsn->code = BPF_ALU | BPF_MOV |\n\t\t\t\t     (BPF_RVAL(fp->code) == BPF_K ?\n\t\t\t\t      BPF_K : BPF_X);\n\t\t\tinsn->a_reg = 0;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\t\tbreak;\n\n\t\t/* Store to stack. */\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\t\tinsn->code = BPF_STX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = FP_REG;\n\t\t\tinsn->x_reg = fp->code == BPF_ST ? A_REG : X_REG;\n\t\t\tinsn->off = -(BPF_MEMWORDS - fp->k) * 4;\n\t\t\tbreak;\n\n\t\t/* Load from stack. */\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->x_reg = FP_REG;\n\t\t\tinsn->off = -(BPF_MEMWORDS - fp->k) * 4;\n\t\t\tbreak;\n\n\t\t/* A = K or X = K */\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\t\tinsn->code = BPF_ALU | BPF_MOV | BPF_K;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tbreak;\n\n\t\t/* X = A */\n\t\tcase BPF_MISC | BPF_TAX:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = X_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tbreak;\n\n\t\t/* A = X */\n\t\tcase BPF_MISC | BPF_TXA:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = X_REG;\n\t\t\tbreak;\n\n\t\t/* A = skb->len or X = skb->len */\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->x_reg = CTX_REG;\n\t\t\tinsn->off = offsetof(struct sk_buff, len);\n\t\t\tbreak;\n\n\t\t/* access seccomp_data fields */\n\t\tcase BPF_LDX | BPF_ABS | BPF_W:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = CTX_REG;\n\t\t\tinsn->off = fp->k;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\n\t\tinsn++;\n\t\tif (new_prog)\n\t\t\tmemcpy(new_insn, tmp_insns,\n\t\t\t       sizeof(*insn) * (insn - tmp_insns));\n\n\t\tnew_insn += insn - tmp_insns;\n\t}\n\n\tif (!new_prog) {\n\t\t/* Only calculating new length. */\n\t\t*new_len = new_insn - new_prog;\n\t\treturn 0;\n\t}\n\n\tpass++;\n\tif (new_flen != new_insn - new_prog) {\n\t\tnew_flen = new_insn - new_prog;\n\t\tif (pass > 2)\n\t\t\tgoto err;\n\n\t\tgoto do_pass;\n\t}\n\n\tkfree(addrs);\n\tBUG_ON(*new_len != new_flen);\n\treturn 0;\nerr:\n\tkfree(addrs);\n\treturn -EINVAL;\n}\n\n/* Security:\n *\n * A BPF program is able to use 16 cells of memory to store intermediate\n * values (check u32 mem[BPF_MEMWORDS] in sk_run_filter()).\n *\n * As we dont want to clear mem[] array for each packet going through\n * sk_run_filter(), we check that filter loaded by user never try to read\n * a cell if not previously written, and we check all branches to be sure\n * a malicious user doesn't try to abuse us.\n */\nstatic int check_load_and_stores(struct sock_filter *filter, int flen)\n{\n\tu16 *masks, memvalid = 0; /* one bit per cell, 16 cells */\n\tint pc, ret = 0;\n\n\tBUILD_BUG_ON(BPF_MEMWORDS > 16);\n\tmasks = kmalloc(flen * sizeof(*masks), GFP_KERNEL);\n\tif (!masks)\n\t\treturn -ENOMEM;\n\tmemset(masks, 0xff, flen * sizeof(*masks));\n\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tmemvalid &= masks[pc];\n\n\t\tswitch (filter[pc].code) {\n\t\tcase BPF_S_ST:\n\t\tcase BPF_S_STX:\n\t\t\tmemvalid |= (1 << filter[pc].k);\n\t\t\tbreak;\n\t\tcase BPF_S_LD_MEM:\n\t\tcase BPF_S_LDX_MEM:\n\t\t\tif (!(memvalid & (1 << filter[pc].k))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JA:\n\t\t\t/* a jump must set masks on target */\n\t\t\tmasks[pc + 1 + filter[pc].k] &= memvalid;\n\t\t\tmemvalid = ~0;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JEQ_K:\n\t\tcase BPF_S_JMP_JEQ_X:\n\t\tcase BPF_S_JMP_JGE_K:\n\t\tcase BPF_S_JMP_JGE_X:\n\t\tcase BPF_S_JMP_JGT_K:\n\t\tcase BPF_S_JMP_JGT_X:\n\t\tcase BPF_S_JMP_JSET_X:\n\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t/* a jump must set masks on targets */\n\t\t\tmasks[pc + 1 + filter[pc].jt] &= memvalid;\n\t\t\tmasks[pc + 1 + filter[pc].jf] &= memvalid;\n\t\t\tmemvalid = ~0;\n\t\t\tbreak;\n\t\t}\n\t}\nerror:\n\tkfree(masks);\n\treturn ret;\n}\n\n/**\n *\tsk_chk_filter - verify socket filter code\n *\t@filter: filter to verify\n *\t@flen: length of filter\n *\n * Check the user's filter code. If we let some ugly\n * filter code slip through kaboom! The filter must contain\n * no references or jumps that are out of range, no illegal\n * instructions, and must end with a RET instruction.\n *\n * All jumps are forward as they are not signed.\n *\n * Returns 0 if the rule set is legal or -EINVAL if not.\n */\nint sk_chk_filter(struct sock_filter *filter, unsigned int flen)\n{\n\t/*\n\t * Valid instructions are initialized to non-0.\n\t * Invalid instructions are initialized to 0.\n\t */\n\tstatic const u8 codes[] = {\n\t\t[BPF_ALU|BPF_ADD|BPF_K]  = BPF_S_ALU_ADD_K,\n\t\t[BPF_ALU|BPF_ADD|BPF_X]  = BPF_S_ALU_ADD_X,\n\t\t[BPF_ALU|BPF_SUB|BPF_K]  = BPF_S_ALU_SUB_K,\n\t\t[BPF_ALU|BPF_SUB|BPF_X]  = BPF_S_ALU_SUB_X,\n\t\t[BPF_ALU|BPF_MUL|BPF_K]  = BPF_S_ALU_MUL_K,\n\t\t[BPF_ALU|BPF_MUL|BPF_X]  = BPF_S_ALU_MUL_X,\n\t\t[BPF_ALU|BPF_DIV|BPF_X]  = BPF_S_ALU_DIV_X,\n\t\t[BPF_ALU|BPF_MOD|BPF_K]  = BPF_S_ALU_MOD_K,\n\t\t[BPF_ALU|BPF_MOD|BPF_X]  = BPF_S_ALU_MOD_X,\n\t\t[BPF_ALU|BPF_AND|BPF_K]  = BPF_S_ALU_AND_K,\n\t\t[BPF_ALU|BPF_AND|BPF_X]  = BPF_S_ALU_AND_X,\n\t\t[BPF_ALU|BPF_OR|BPF_K]   = BPF_S_ALU_OR_K,\n\t\t[BPF_ALU|BPF_OR|BPF_X]   = BPF_S_ALU_OR_X,\n\t\t[BPF_ALU|BPF_XOR|BPF_K]  = BPF_S_ALU_XOR_K,\n\t\t[BPF_ALU|BPF_XOR|BPF_X]  = BPF_S_ALU_XOR_X,\n\t\t[BPF_ALU|BPF_LSH|BPF_K]  = BPF_S_ALU_LSH_K,\n\t\t[BPF_ALU|BPF_LSH|BPF_X]  = BPF_S_ALU_LSH_X,\n\t\t[BPF_ALU|BPF_RSH|BPF_K]  = BPF_S_ALU_RSH_K,\n\t\t[BPF_ALU|BPF_RSH|BPF_X]  = BPF_S_ALU_RSH_X,\n\t\t[BPF_ALU|BPF_NEG]        = BPF_S_ALU_NEG,\n\t\t[BPF_LD|BPF_W|BPF_ABS]   = BPF_S_LD_W_ABS,\n\t\t[BPF_LD|BPF_H|BPF_ABS]   = BPF_S_LD_H_ABS,\n\t\t[BPF_LD|BPF_B|BPF_ABS]   = BPF_S_LD_B_ABS,\n\t\t[BPF_LD|BPF_W|BPF_LEN]   = BPF_S_LD_W_LEN,\n\t\t[BPF_LD|BPF_W|BPF_IND]   = BPF_S_LD_W_IND,\n\t\t[BPF_LD|BPF_H|BPF_IND]   = BPF_S_LD_H_IND,\n\t\t[BPF_LD|BPF_B|BPF_IND]   = BPF_S_LD_B_IND,\n\t\t[BPF_LD|BPF_IMM]         = BPF_S_LD_IMM,\n\t\t[BPF_LDX|BPF_W|BPF_LEN]  = BPF_S_LDX_W_LEN,\n\t\t[BPF_LDX|BPF_B|BPF_MSH]  = BPF_S_LDX_B_MSH,\n\t\t[BPF_LDX|BPF_IMM]        = BPF_S_LDX_IMM,\n\t\t[BPF_MISC|BPF_TAX]       = BPF_S_MISC_TAX,\n\t\t[BPF_MISC|BPF_TXA]       = BPF_S_MISC_TXA,\n\t\t[BPF_RET|BPF_K]          = BPF_S_RET_K,\n\t\t[BPF_RET|BPF_A]          = BPF_S_RET_A,\n\t\t[BPF_ALU|BPF_DIV|BPF_K]  = BPF_S_ALU_DIV_K,\n\t\t[BPF_LD|BPF_MEM]         = BPF_S_LD_MEM,\n\t\t[BPF_LDX|BPF_MEM]        = BPF_S_LDX_MEM,\n\t\t[BPF_ST]                 = BPF_S_ST,\n\t\t[BPF_STX]                = BPF_S_STX,\n\t\t[BPF_JMP|BPF_JA]         = BPF_S_JMP_JA,\n\t\t[BPF_JMP|BPF_JEQ|BPF_K]  = BPF_S_JMP_JEQ_K,\n\t\t[BPF_JMP|BPF_JEQ|BPF_X]  = BPF_S_JMP_JEQ_X,\n\t\t[BPF_JMP|BPF_JGE|BPF_K]  = BPF_S_JMP_JGE_K,\n\t\t[BPF_JMP|BPF_JGE|BPF_X]  = BPF_S_JMP_JGE_X,\n\t\t[BPF_JMP|BPF_JGT|BPF_K]  = BPF_S_JMP_JGT_K,\n\t\t[BPF_JMP|BPF_JGT|BPF_X]  = BPF_S_JMP_JGT_X,\n\t\t[BPF_JMP|BPF_JSET|BPF_K] = BPF_S_JMP_JSET_K,\n\t\t[BPF_JMP|BPF_JSET|BPF_X] = BPF_S_JMP_JSET_X,\n\t};\n\tint pc;\n\tbool anc_found;\n\n\tif (flen == 0 || flen > BPF_MAXINSNS)\n\t\treturn -EINVAL;\n\n\t/* check the filter code now */\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\n\t\tif (code >= ARRAY_SIZE(codes))\n\t\t\treturn -EINVAL;\n\t\tcode = codes[code];\n\t\tif (!code)\n\t\t\treturn -EINVAL;\n\t\t/* Some instructions need special checks */\n\t\tswitch (code) {\n\t\tcase BPF_S_ALU_DIV_K:\n\t\tcase BPF_S_ALU_MOD_K:\n\t\t\t/* check for division by zero */\n\t\t\tif (ftest->k == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_LD_MEM:\n\t\tcase BPF_S_LDX_MEM:\n\t\tcase BPF_S_ST:\n\t\tcase BPF_S_STX:\n\t\t\t/* check for invalid memory addresses */\n\t\t\tif (ftest->k >= BPF_MEMWORDS)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JA:\n\t\t\t/*\n\t\t\t * Note, the large ftest->k might cause loops.\n\t\t\t * Compare this with conditional jumps below,\n\t\t\t * where offsets are limited. --ANK (981016)\n\t\t\t */\n\t\t\tif (ftest->k >= (unsigned int)(flen-pc-1))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JEQ_K:\n\t\tcase BPF_S_JMP_JEQ_X:\n\t\tcase BPF_S_JMP_JGE_K:\n\t\tcase BPF_S_JMP_JGE_X:\n\t\tcase BPF_S_JMP_JGT_K:\n\t\tcase BPF_S_JMP_JGT_X:\n\t\tcase BPF_S_JMP_JSET_X:\n\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t/* for conditionals both must be safe */\n\t\t\tif (pc + ftest->jt + 1 >= flen ||\n\t\t\t    pc + ftest->jf + 1 >= flen)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\tanc_found = false;\n#define ANCILLARY(CODE) case SKF_AD_OFF + SKF_AD_##CODE:\t\\\n\t\t\t\tcode = BPF_S_ANC_##CODE;\t\\\n\t\t\t\tanc_found = true;\t\t\\\n\t\t\t\tbreak\n\t\t\tswitch (ftest->k) {\n\t\t\tANCILLARY(PROTOCOL);\n\t\t\tANCILLARY(PKTTYPE);\n\t\t\tANCILLARY(IFINDEX);\n\t\t\tANCILLARY(NLATTR);\n\t\t\tANCILLARY(NLATTR_NEST);\n\t\t\tANCILLARY(MARK);\n\t\t\tANCILLARY(QUEUE);\n\t\t\tANCILLARY(HATYPE);\n\t\t\tANCILLARY(RXHASH);\n\t\t\tANCILLARY(CPU);\n\t\t\tANCILLARY(ALU_XOR_X);\n\t\t\tANCILLARY(VLAN_TAG);\n\t\t\tANCILLARY(VLAN_TAG_PRESENT);\n\t\t\tANCILLARY(PAY_OFFSET);\n\t\t\t}\n\n\t\t\t/* ancillary operation unknown or unsupported */\n\t\t\tif (anc_found == false && ftest->k >= SKF_AD_OFF)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tftest->code = code;\n\t}\n\n\t/* last instruction must be a RET code */\n\tswitch (filter[flen - 1].code) {\n\tcase BPF_S_RET_K:\n\tcase BPF_S_RET_A:\n\t\treturn check_load_and_stores(filter, flen);\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(sk_chk_filter);\n\nstatic int sk_store_orig_filter(struct sk_filter *fp,\n\t\t\t\tconst struct sock_fprog *fprog)\n{\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tstruct sock_fprog_kern *fkprog;\n\n\tfp->orig_prog = kmalloc(sizeof(*fkprog), GFP_KERNEL);\n\tif (!fp->orig_prog)\n\t\treturn -ENOMEM;\n\n\tfkprog = fp->orig_prog;\n\tfkprog->len = fprog->len;\n\tfkprog->filter = kmemdup(fp->insns, fsize, GFP_KERNEL);\n\tif (!fkprog->filter) {\n\t\tkfree(fp->orig_prog);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void sk_release_orig_filter(struct sk_filter *fp)\n{\n\tstruct sock_fprog_kern *fprog = fp->orig_prog;\n\n\tif (fprog) {\n\t\tkfree(fprog->filter);\n\t\tkfree(fprog);\n\t}\n}\n\n/**\n * \tsk_filter_release_rcu - Release a socket filter by rcu_head\n *\t@rcu: rcu_head that contains the sk_filter to free\n */\nstatic void sk_filter_release_rcu(struct rcu_head *rcu)\n{\n\tstruct sk_filter *fp = container_of(rcu, struct sk_filter, rcu);\n\n\tsk_release_orig_filter(fp);\n\tbpf_jit_free(fp);\n}\n\n/**\n *\tsk_filter_release - release a socket filter\n *\t@fp: filter to remove\n *\n *\tRemove a filter from a socket and release its resources.\n */\nstatic void sk_filter_release(struct sk_filter *fp)\n{\n\tif (atomic_dec_and_test(&fp->refcnt))\n\t\tcall_rcu(&fp->rcu, sk_filter_release_rcu);\n}\n\nvoid sk_filter_uncharge(struct sock *sk, struct sk_filter *fp)\n{\n\tatomic_sub(sk_filter_size(fp->len), &sk->sk_omem_alloc);\n\tsk_filter_release(fp);\n}\n\nvoid sk_filter_charge(struct sock *sk, struct sk_filter *fp)\n{\n\tatomic_inc(&fp->refcnt);\n\tatomic_add(sk_filter_size(fp->len), &sk->sk_omem_alloc);\n}\n\nstatic struct sk_filter *__sk_migrate_realloc(struct sk_filter *fp,\n\t\t\t\t\t      struct sock *sk,\n\t\t\t\t\t      unsigned int len)\n{\n\tstruct sk_filter *fp_new;\n\n\tif (sk == NULL)\n\t\treturn krealloc(fp, len, GFP_KERNEL);\n\n\tfp_new = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (fp_new) {\n\t\tmemcpy(fp_new, fp, sizeof(struct sk_filter));\n\t\t/* As we're kepping orig_prog in fp_new along,\n\t\t * we need to make sure we're not evicting it\n\t\t * from the old fp.\n\t\t */\n\t\tfp->orig_prog = NULL;\n\t\tsk_filter_uncharge(sk, fp);\n\t}\n\n\treturn fp_new;\n}\n\nstatic struct sk_filter *__sk_migrate_filter(struct sk_filter *fp,\n\t\t\t\t\t     struct sock *sk)\n{\n\tstruct sock_filter *old_prog;\n\tstruct sk_filter *old_fp;\n\tint i, err, new_len, old_len = fp->len;\n\n\t/* We are free to overwrite insns et al right here as it\n\t * won't be used at this point in time anymore internally\n\t * after the migration to the internal BPF instruction\n\t * representation.\n\t */\n\tBUILD_BUG_ON(sizeof(struct sock_filter) !=\n\t\t     sizeof(struct sock_filter_int));\n\n\t/* For now, we need to unfiddle BPF_S_* identifiers in place.\n\t * This can sooner or later on be subject to removal, e.g. when\n\t * JITs have been converted.\n\t */\n\tfor (i = 0; i < fp->len; i++)\n\t\tsk_decode_filter(&fp->insns[i], &fp->insns[i]);\n\n\t/* Conversion cannot happen on overlapping memory areas,\n\t * so we need to keep the user BPF around until the 2nd\n\t * pass. At this time, the user BPF is stored in fp->insns.\n\t */\n\told_prog = kmemdup(fp->insns, old_len * sizeof(struct sock_filter),\n\t\t\t   GFP_KERNEL);\n\tif (!old_prog) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t/* 1st pass: calculate the new program length. */\n\terr = sk_convert_filter(old_prog, old_len, NULL, &new_len);\n\tif (err)\n\t\tgoto out_err_free;\n\n\t/* Expand fp for appending the new filter representation. */\n\told_fp = fp;\n\tfp = __sk_migrate_realloc(old_fp, sk, sk_filter_size(new_len));\n\tif (!fp) {\n\t\t/* The old_fp is still around in case we couldn't\n\t\t * allocate new memory, so uncharge on that one.\n\t\t */\n\t\tfp = old_fp;\n\t\terr = -ENOMEM;\n\t\tgoto out_err_free;\n\t}\n\n\tfp->bpf_func = sk_run_filter_int_skb;\n\tfp->len = new_len;\n\n\t/* 2nd pass: remap sock_filter insns into sock_filter_int insns. */\n\terr = sk_convert_filter(old_prog, old_len, fp->insnsi, &new_len);\n\tif (err)\n\t\t/* 2nd sk_convert_filter() can fail only if it fails\n\t\t * to allocate memory, remapping must succeed. Note,\n\t\t * that at this time old_fp has already been released\n\t\t * by __sk_migrate_realloc().\n\t\t */\n\t\tgoto out_err_free;\n\n\tkfree(old_prog);\n\treturn fp;\n\nout_err_free:\n\tkfree(old_prog);\nout_err:\n\t/* Rollback filter setup. */\n\tif (sk != NULL)\n\t\tsk_filter_uncharge(sk, fp);\n\telse\n\t\tkfree(fp);\n\treturn ERR_PTR(err);\n}\n\nstatic struct sk_filter *__sk_prepare_filter(struct sk_filter *fp,\n\t\t\t\t\t     struct sock *sk)\n{\n\tint err;\n\n\tfp->bpf_func = NULL;\n\tfp->jited = 0;\n\n\terr = sk_chk_filter(fp->insns, fp->len);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* Probe if we can JIT compile the filter and if so, do\n\t * the compilation of the filter.\n\t */\n\tbpf_jit_compile(fp);\n\n\t/* JIT compiler couldn't process this filter, so do the\n\t * internal BPF translation for the optimized interpreter.\n\t */\n\tif (!fp->jited)\n\t\tfp = __sk_migrate_filter(fp, sk);\n\n\treturn fp;\n}\n\n/**\n *\tsk_unattached_filter_create - create an unattached filter\n *\t@fprog: the filter program\n *\t@pfp: the unattached filter that is created\n *\n * Create a filter independent of any socket. We first run some\n * sanity checks on it to make sure it does not explode on us later.\n * If an error occurs or there is insufficient memory for the filter\n * a negative errno code is returned. On success the return is zero.\n */\nint sk_unattached_filter_create(struct sk_filter **pfp,\n\t\t\t\tstruct sock_fprog *fprog)\n{\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tstruct sk_filter *fp;\n\n\t/* Make sure new filter is there and in the right amounts. */\n\tif (fprog->filter == NULL)\n\t\treturn -EINVAL;\n\n\tfp = kmalloc(sk_filter_size(fprog->len), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmemcpy(fp->insns, fprog->filter, fsize);\n\n\tatomic_set(&fp->refcnt, 1);\n\tfp->len = fprog->len;\n\t/* Since unattached filters are not copied back to user\n\t * space through sk_get_filter(), we do not need to hold\n\t * a copy here, and can spare us the work.\n\t */\n\tfp->orig_prog = NULL;\n\n\t/* __sk_prepare_filter() already takes care of uncharging\n\t * memory in case something goes wrong.\n\t */\n\tfp = __sk_prepare_filter(fp, NULL);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\t*pfp = fp;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sk_unattached_filter_create);\n\nvoid sk_unattached_filter_destroy(struct sk_filter *fp)\n{\n\tsk_filter_release(fp);\n}\nEXPORT_SYMBOL_GPL(sk_unattached_filter_destroy);\n\n/**\n *\tsk_attach_filter - attach a socket filter\n *\t@fprog: the filter program\n *\t@sk: the socket to use\n *\n * Attach the user's filter code. We first run some sanity checks on\n * it to make sure it does not explode on us later. If an error\n * occurs or there is insufficient memory for the filter a negative\n * errno code is returned. On success the return is zero.\n */\nint sk_attach_filter(struct sock_fprog *fprog, struct sock *sk)\n{\n\tstruct sk_filter *fp, *old_fp;\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tunsigned int sk_fsize = sk_filter_size(fprog->len);\n\tint err;\n\n\tif (sock_flag(sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\n\t/* Make sure new filter is there and in the right amounts. */\n\tif (fprog->filter == NULL)\n\t\treturn -EINVAL;\n\n\tfp = sock_kmalloc(sk, sk_fsize, GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(fp->insns, fprog->filter, fsize)) {\n\t\tsock_kfree_s(sk, fp, sk_fsize);\n\t\treturn -EFAULT;\n\t}\n\n\tatomic_set(&fp->refcnt, 1);\n\tfp->len = fprog->len;\n\n\terr = sk_store_orig_filter(fp, fprog);\n\tif (err) {\n\t\tsk_filter_uncharge(sk, fp);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* __sk_prepare_filter() already takes care of uncharging\n\t * memory in case something goes wrong.\n\t */\n\tfp = __sk_prepare_filter(fp, sk);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\told_fp = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\trcu_assign_pointer(sk->sk_filter, fp);\n\n\tif (old_fp)\n\t\tsk_filter_uncharge(sk, old_fp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sk_attach_filter);\n\nint sk_detach_filter(struct sock *sk)\n{\n\tint ret = -ENOENT;\n\tstruct sk_filter *filter;\n\n\tif (sock_flag(sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\n\tfilter = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\tif (filter) {\n\t\tRCU_INIT_POINTER(sk->sk_filter, NULL);\n\t\tsk_filter_uncharge(sk, filter);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sk_detach_filter);\n\nvoid sk_decode_filter(struct sock_filter *filt, struct sock_filter *to)\n{\n\tstatic const u16 decodes[] = {\n\t\t[BPF_S_ALU_ADD_K]\t= BPF_ALU|BPF_ADD|BPF_K,\n\t\t[BPF_S_ALU_ADD_X]\t= BPF_ALU|BPF_ADD|BPF_X,\n\t\t[BPF_S_ALU_SUB_K]\t= BPF_ALU|BPF_SUB|BPF_K,\n\t\t[BPF_S_ALU_SUB_X]\t= BPF_ALU|BPF_SUB|BPF_X,\n\t\t[BPF_S_ALU_MUL_K]\t= BPF_ALU|BPF_MUL|BPF_K,\n\t\t[BPF_S_ALU_MUL_X]\t= BPF_ALU|BPF_MUL|BPF_X,\n\t\t[BPF_S_ALU_DIV_X]\t= BPF_ALU|BPF_DIV|BPF_X,\n\t\t[BPF_S_ALU_MOD_K]\t= BPF_ALU|BPF_MOD|BPF_K,\n\t\t[BPF_S_ALU_MOD_X]\t= BPF_ALU|BPF_MOD|BPF_X,\n\t\t[BPF_S_ALU_AND_K]\t= BPF_ALU|BPF_AND|BPF_K,\n\t\t[BPF_S_ALU_AND_X]\t= BPF_ALU|BPF_AND|BPF_X,\n\t\t[BPF_S_ALU_OR_K]\t= BPF_ALU|BPF_OR|BPF_K,\n\t\t[BPF_S_ALU_OR_X]\t= BPF_ALU|BPF_OR|BPF_X,\n\t\t[BPF_S_ALU_XOR_K]\t= BPF_ALU|BPF_XOR|BPF_K,\n\t\t[BPF_S_ALU_XOR_X]\t= BPF_ALU|BPF_XOR|BPF_X,\n\t\t[BPF_S_ALU_LSH_K]\t= BPF_ALU|BPF_LSH|BPF_K,\n\t\t[BPF_S_ALU_LSH_X]\t= BPF_ALU|BPF_LSH|BPF_X,\n\t\t[BPF_S_ALU_RSH_K]\t= BPF_ALU|BPF_RSH|BPF_K,\n\t\t[BPF_S_ALU_RSH_X]\t= BPF_ALU|BPF_RSH|BPF_X,\n\t\t[BPF_S_ALU_NEG]\t\t= BPF_ALU|BPF_NEG,\n\t\t[BPF_S_LD_W_ABS]\t= BPF_LD|BPF_W|BPF_ABS,\n\t\t[BPF_S_LD_H_ABS]\t= BPF_LD|BPF_H|BPF_ABS,\n\t\t[BPF_S_LD_B_ABS]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PROTOCOL]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PKTTYPE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_IFINDEX]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_NLATTR]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_NLATTR_NEST]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_MARK]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_QUEUE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_HATYPE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_RXHASH]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_CPU]\t\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_ALU_XOR_X]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_SECCOMP_LD_W] = BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_VLAN_TAG]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_VLAN_TAG_PRESENT] = BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PAY_OFFSET]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_LD_W_LEN]\t= BPF_LD|BPF_W|BPF_LEN,\n\t\t[BPF_S_LD_W_IND]\t= BPF_LD|BPF_W|BPF_IND,\n\t\t[BPF_S_LD_H_IND]\t= BPF_LD|BPF_H|BPF_IND,\n\t\t[BPF_S_LD_B_IND]\t= BPF_LD|BPF_B|BPF_IND,\n\t\t[BPF_S_LD_IMM]\t\t= BPF_LD|BPF_IMM,\n\t\t[BPF_S_LDX_W_LEN]\t= BPF_LDX|BPF_W|BPF_LEN,\n\t\t[BPF_S_LDX_B_MSH]\t= BPF_LDX|BPF_B|BPF_MSH,\n\t\t[BPF_S_LDX_IMM]\t\t= BPF_LDX|BPF_IMM,\n\t\t[BPF_S_MISC_TAX]\t= BPF_MISC|BPF_TAX,\n\t\t[BPF_S_MISC_TXA]\t= BPF_MISC|BPF_TXA,\n\t\t[BPF_S_RET_K]\t\t= BPF_RET|BPF_K,\n\t\t[BPF_S_RET_A]\t\t= BPF_RET|BPF_A,\n\t\t[BPF_S_ALU_DIV_K]\t= BPF_ALU|BPF_DIV|BPF_K,\n\t\t[BPF_S_LD_MEM]\t\t= BPF_LD|BPF_MEM,\n\t\t[BPF_S_LDX_MEM]\t\t= BPF_LDX|BPF_MEM,\n\t\t[BPF_S_ST]\t\t= BPF_ST,\n\t\t[BPF_S_STX]\t\t= BPF_STX,\n\t\t[BPF_S_JMP_JA]\t\t= BPF_JMP|BPF_JA,\n\t\t[BPF_S_JMP_JEQ_K]\t= BPF_JMP|BPF_JEQ|BPF_K,\n\t\t[BPF_S_JMP_JEQ_X]\t= BPF_JMP|BPF_JEQ|BPF_X,\n\t\t[BPF_S_JMP_JGE_K]\t= BPF_JMP|BPF_JGE|BPF_K,\n\t\t[BPF_S_JMP_JGE_X]\t= BPF_JMP|BPF_JGE|BPF_X,\n\t\t[BPF_S_JMP_JGT_K]\t= BPF_JMP|BPF_JGT|BPF_K,\n\t\t[BPF_S_JMP_JGT_X]\t= BPF_JMP|BPF_JGT|BPF_X,\n\t\t[BPF_S_JMP_JSET_K]\t= BPF_JMP|BPF_JSET|BPF_K,\n\t\t[BPF_S_JMP_JSET_X]\t= BPF_JMP|BPF_JSET|BPF_X,\n\t};\n\tu16 code;\n\n\tcode = filt->code;\n\n\tto->code = decodes[code];\n\tto->jt = filt->jt;\n\tto->jf = filt->jf;\n\tto->k = filt->k;\n}\n\nint sk_get_filter(struct sock *sk, struct sock_filter __user *ubuf,\n\t\t  unsigned int len)\n{\n\tstruct sock_fprog_kern *fprog;\n\tstruct sk_filter *filter;\n\tint ret = 0;\n\n\tlock_sock(sk);\n\tfilter = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\tif (!filter)\n\t\tgoto out;\n\n\t/* We're copying the filter that has been originally attached,\n\t * so no conversion/decode needed anymore.\n\t */\n\tfprog = filter->orig_prog;\n\n\tret = fprog->len;\n\tif (!len)\n\t\t/* User space only enquires number of filter blocks. */\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (len < fprog->len)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(ubuf, fprog->filter, sk_filter_proglen(fprog)))\n\t\tgoto out;\n\n\t/* Instead of bytes, the API requests to return the number\n\t * of filter blocks.\n\t */\n\tret = fprog->len;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * Linux Socket Filter - Kernel level socket filtering\n *\n * Based on the design of the Berkeley Packet Filter. The new\n * internal format has been designed by PLUMgrid:\n *\n *\tCopyright (c) 2011 - 2014 PLUMgrid, http://plumgrid.com\n *\n * Authors:\n *\n *\tJay Schulist <jschlst@samba.org>\n *\tAlexei Starovoitov <ast@plumgrid.com>\n *\tDaniel Borkmann <dborkman@redhat.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * Andi Kleen - Fix a few bad bugs and races.\n * Kris Katterjohn - Added many additional checks in sk_chk_filter()\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_packet.h>\n#include <linux/gfp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/netlink.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <asm/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/filter.h>\n#include <linux/ratelimit.h>\n#include <linux/seccomp.h>\n#include <linux/if_vlan.h>\n\n/* No hurry in this branch\n *\n * Exported for the bpf jit load helper.\n */\nvoid *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb, int k, unsigned int size)\n{\n\tu8 *ptr = NULL;\n\n\tif (k >= SKF_NET_OFF)\n\t\tptr = skb_network_header(skb) + k - SKF_NET_OFF;\n\telse if (k >= SKF_LL_OFF)\n\t\tptr = skb_mac_header(skb) + k - SKF_LL_OFF;\n\n\tif (ptr >= skb->head && ptr + size <= skb_tail_pointer(skb))\n\t\treturn ptr;\n\treturn NULL;\n}\n\nstatic inline void *load_pointer(const struct sk_buff *skb, int k,\n\t\t\t\t unsigned int size, void *buffer)\n{\n\tif (k >= 0)\n\t\treturn skb_header_pointer(skb, k, size, buffer);\n\treturn bpf_internal_load_pointer_neg_helper(skb, k, size);\n}\n\n/**\n *\tsk_filter - run a packet through a socket filter\n *\t@sk: sock associated with &sk_buff\n *\t@skb: buffer to filter\n *\n * Run the filter code and then cut skb->data to correct size returned by\n * sk_run_filter. If pkt_len is 0 we toss packet. If skb->len is smaller\n * than pkt_len we keep whole skb->data. This is the socket level\n * wrapper to sk_run_filter. It returns 0 if the packet should\n * be accepted or -EPERM if the packet should be tossed.\n *\n */\nint sk_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\tstruct sk_filter *filter;\n\n\t/*\n\t * If the skb was allocated from pfmemalloc reserves, only\n\t * allow SOCK_MEMALLOC sockets to use it as this socket is\n\t * helping free memory\n\t */\n\tif (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC))\n\t\treturn -ENOMEM;\n\n\terr = security_sock_rcv_skb(sk, skb);\n\tif (err)\n\t\treturn err;\n\n\trcu_read_lock();\n\tfilter = rcu_dereference(sk->sk_filter);\n\tif (filter) {\n\t\tunsigned int pkt_len = SK_RUN_FILTER(filter, skb);\n\n\t\terr = pkt_len ? pskb_trim(skb, pkt_len) : -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\nEXPORT_SYMBOL(sk_filter);\n\n/* Base function for offset calculation. Needs to go into .text section,\n * therefore keeping it non-static as well; will also be used by JITs\n * anyway later on, so do not let the compiler omit it.\n */\nnoinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n{\n\treturn 0;\n}\n\n/**\n *\t__sk_run_filter - run a filter on a given context\n *\t@ctx: buffer to run the filter on\n *\t@insn: filter to apply\n *\n * Decode and apply filter instructions to the skb->data. Return length to\n * keep, 0 for none. @ctx is the data we are operating on, @insn is the\n * array of filter instructions.\n */\nunsigned int __sk_run_filter(void *ctx, const struct sock_filter_int *insn)\n{\n\tu64 stack[MAX_BPF_STACK / sizeof(u64)];\n\tu64 regs[MAX_BPF_REG], tmp;\n\tvoid *ptr;\n\tint off;\n\n#define K  insn->imm\n#define A  regs[insn->a_reg]\n#define X  regs[insn->x_reg]\n#define R0 regs[0]\n\n#define CONT\t ({insn++; goto select_insn; })\n#define CONT_JMP ({insn++; goto select_insn; })\n\n\tstatic const void *jumptable[256] = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n#define DL(A, B, C)\t[A|B|C] = &&A##_##B##_##C\n\t\tDL(BPF_ALU, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU, BPF_NEG, 0),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_BE),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_LE),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_NEG, 0),\n\t\tDL(BPF_JMP, BPF_CALL, 0),\n\t\tDL(BPF_JMP, BPF_JA, 0),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_X),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_K),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_K),\n\t\tDL(BPF_JMP, BPF_EXIT, 0),\n\t\tDL(BPF_STX, BPF_MEM, BPF_B),\n\t\tDL(BPF_STX, BPF_MEM, BPF_H),\n\t\tDL(BPF_STX, BPF_MEM, BPF_W),\n\t\tDL(BPF_STX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_STX, BPF_XADD, BPF_W),\n\t\tDL(BPF_STX, BPF_XADD, BPF_DW),\n\t\tDL(BPF_ST, BPF_MEM, BPF_B),\n\t\tDL(BPF_ST, BPF_MEM, BPF_H),\n\t\tDL(BPF_ST, BPF_MEM, BPF_W),\n\t\tDL(BPF_ST, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_B),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_H),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_W),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LD, BPF_ABS, BPF_W),\n\t\tDL(BPF_LD, BPF_ABS, BPF_H),\n\t\tDL(BPF_LD, BPF_ABS, BPF_B),\n\t\tDL(BPF_LD, BPF_IND, BPF_W),\n\t\tDL(BPF_LD, BPF_IND, BPF_H),\n\t\tDL(BPF_LD, BPF_IND, BPF_B),\n#undef DL\n\t};\n\n\tregs[FP_REG]  = (u64) (unsigned long) &stack[ARRAY_SIZE(stack)];\n\tregs[ARG1_REG] = (u64) (unsigned long) ctx;\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* ALU */\n#define ALU(OPCODE, OP)\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_X:\t\\\n\t\tA = A OP X;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_X:\t\\\n\t\tA = (u32) A OP (u32) X;\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_K:\t\\\n\t\tA = A OP K;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_K:\t\\\n\t\tA = (u32) A OP (u32) K;\t\\\n\t\tCONT;\n\n\tALU(BPF_ADD,  +)\n\tALU(BPF_SUB,  -)\n\tALU(BPF_AND,  &)\n\tALU(BPF_OR,   |)\n\tALU(BPF_LSH, <<)\n\tALU(BPF_RSH, >>)\n\tALU(BPF_XOR,  ^)\n\tALU(BPF_MUL,  *)\n#undef ALU\n\tBPF_ALU_BPF_NEG_0:\n\t\tA = (u32) -A;\n\t\tCONT;\n\tBPF_ALU64_BPF_NEG_0:\n\t\tA = -A;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_X:\n\t\tA = (u32) X;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_K:\n\t\tA = (u32) K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_X:\n\t\tA = X;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_K:\n\t\tA = K;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_X:\n\t\t(*(s64 *) &A) >>= X;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_K:\n\t\t(*(s64 *) &A) >>= K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = A;\n\t\tA = do_div(tmp, X);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) X);\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_K:\n\t\ttmp = A;\n\t\tA = do_div(tmp, K);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_K:\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) K);\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\tdo_div(A, X);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) X);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_K:\n\t\tdo_div(A, K);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_K:\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) K);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_BE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_be16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_be32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_be64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_LE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_le16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_le32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_le64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tBPF_JMP_BPF_CALL_0:\n\t\t/* Function call scratches R1-R5 registers, preserves R6-R9,\n\t\t * and stores return value into R0.\n\t\t */\n\t\tR0 = (__bpf_call_base + insn->imm)(regs[1], regs[2], regs[3],\n\t\t\t\t\t\t   regs[4], regs[5]);\n\t\tCONT;\n\n\t/* JMP */\n\tBPF_JMP_BPF_JA_0:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_X:\n\t\tif (A == X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_K:\n\t\tif (A == K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_X:\n\t\tif (A != X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_K:\n\t\tif (A != K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_X:\n\t\tif (A > X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_K:\n\t\tif (A > K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_X:\n\t\tif (A >= X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_K:\n\t\tif (A >= K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_X:\n\t\tif (((s64)A) > ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_K:\n\t\tif (((s64)A) > ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_X:\n\t\tif (((s64)A) >= ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_K:\n\t\tif (((s64)A) >= ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_X:\n\t\tif (A & X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_K:\n\t\tif (A & K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_EXIT_0:\n\t\treturn R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\\\n\tBPF_STX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = X;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_ST_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = K;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_LDX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\tA = *(SIZE *)(unsigned long) (X + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(BPF_B,   u8)\n\tLDST(BPF_H,  u16)\n\tLDST(BPF_W,  u32)\n\tLDST(BPF_DW, u64)\n#undef LDST\n\tBPF_STX_BPF_XADD_BPF_W: /* lock xadd *(u32 *)(A + insn->off) += X */\n\t\tatomic_add((u32) X, (atomic_t *)(unsigned long)\n\t\t\t   (A + insn->off));\n\t\tCONT;\n\tBPF_STX_BPF_XADD_BPF_DW: /* lock xadd *(u64 *)(A + insn->off) += X */\n\t\tatomic64_add((u64) X, (atomic64_t *)(unsigned long)\n\t\t\t     (A + insn->off));\n\t\tCONT;\n\tBPF_LD_BPF_ABS_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + K)) */\n\t\toff = K;\nload_word:\n\t\t/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are only\n\t\t * appearing in the programs where ctx == skb. All programs\n\t\t * keep 'ctx' in regs[CTX_REG] == R6, sk_convert_filter()\n\t\t * saves it in R6, internal BPF verifier will check that\n\t\t * R6 == ctx.\n\t\t *\n\t\t * BPF_ABS and BPF_IND are wrappers of function calls, so\n\t\t * they scratch R1-R5 registers, preserve R6-R9, and store\n\t\t * return value into R0.\n\t\t *\n\t\t * Implicit input:\n\t\t *   ctx\n\t\t *\n\t\t * Explicit input:\n\t\t *   X == any register\n\t\t *   K == 32-bit immediate\n\t\t *\n\t\t * Output:\n\t\t *   R0 - 8/16/32-bit skb data converted to cpu endianness\n\t\t */\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 4, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be32(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + K)) */\n\t\toff = K;\nload_half:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 2, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be16(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_B: /* R0 = *(u8 *) (ctx + K) */\n\t\toff = K;\nload_byte:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 1, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = *(u8 *)ptr;\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_IND_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_word;\n\tBPF_LD_BPF_IND_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_half;\n\tBPF_LD_BPF_IND_BPF_B: /* R0 = *(u8 *) (skb->data + X + K) */\n\t\toff = K + X;\n\t\tgoto load_byte;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. */\n\t\tWARN_RATELIMIT(1, \"unknown opcode %02x\\n\", insn->code);\n\t\treturn 0;\n#undef CONT_JMP\n#undef CONT\n\n#undef R0\n#undef X\n#undef A\n#undef K\n}\n\nu32 sk_run_filter_int_seccomp(const struct seccomp_data *ctx,\n\t\t\t      const struct sock_filter_int *insni)\n    __attribute__ ((alias (\"__sk_run_filter\")));\n\nu32 sk_run_filter_int_skb(const struct sk_buff *ctx,\n\t\t\t  const struct sock_filter_int *insni)\n    __attribute__ ((alias (\"__sk_run_filter\")));\nEXPORT_SYMBOL_GPL(sk_run_filter_int_skb);\n\n/* Helper to find the offset of pkt_type in sk_buff structure. We want\n * to make sure its still a 3bit field starting at a byte boundary;\n * taken from arch/x86/net/bpf_jit_comp.c.\n */\n#define PKT_TYPE_MAX\t7\nstatic unsigned int pkt_type_offset(void)\n{\n\tstruct sk_buff skb_probe = { .pkt_type = ~0, };\n\tu8 *ct = (u8 *) &skb_probe;\n\tunsigned int off;\n\n\tfor (off = 0; off < sizeof(struct sk_buff); off++) {\n\t\tif (ct[off] == PKT_TYPE_MAX)\n\t\t\treturn off;\n\t}\n\n\tpr_err_once(\"Please fix %s, as pkt_type couldn't be found!\\n\", __func__);\n\treturn -1;\n}\n\nstatic u64 __skb_get_pay_offset(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\n\treturn __skb_get_poff(skb);\n}\n\nstatic u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n\nstatic u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n\nstatic u64 __get_raw_cpu_id(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\treturn raw_smp_processor_id();\n}\n\n/* Register mappings for user programs. */\n#define A_REG\t\t0\n#define X_REG\t\t7\n#define TMP_REG\t\t8\n#define ARG2_REG\t2\n#define ARG3_REG\t3\n\nstatic bool convert_bpf_extensions(struct sock_filter *fp,\n\t\t\t\t   struct sock_filter_int **insnp)\n{\n\tstruct sock_filter_int *insn = *insnp;\n\n\tswitch (fp->k) {\n\tcase SKF_AD_OFF + SKF_AD_PROTOCOL:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, protocol);\n\t\tinsn++;\n\n\t\t/* A = ntohs(A) [emitting a nop or swap16] */\n\t\tinsn->code = BPF_ALU | BPF_END | BPF_FROM_BE;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = 16;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PKTTYPE:\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_B;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = pkt_type_offset();\n\t\tif (insn->off < 0)\n\t\t\treturn false;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = PKT_TYPE_MAX;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_IFINDEX:\n\tcase SKF_AD_OFF + SKF_AD_HATYPE:\n\t\tif (FIELD_SIZEOF(struct sk_buff, dev) == 8)\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_DW;\n\t\telse\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, dev);\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_JNE | BPF_K;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->imm = 0;\n\t\tinsn->off = 1;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);\n\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = TMP_REG;\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX) {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->off = offsetof(struct net_device, ifindex);\n\t\t} else {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\t\tinsn->off = offsetof(struct net_device, type);\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_MARK:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, mark);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_RXHASH:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, hash);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_QUEUE:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, queue_mapping);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, vlan_tci);\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_VLAN_TAG) {\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = ~VLAN_TAG_PRESENT;\n\t\t} else {\n\t\t\tinsn->code = BPF_ALU | BPF_RSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 12;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 1;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t/* arg1 = ctx */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG1_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn++;\n\n\t\t/* arg2 = A */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG2_REG;\n\t\tinsn->x_reg = A_REG;\n\t\tinsn++;\n\n\t\t/* arg3 = X */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG3_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tinsn++;\n\n\t\t/* Emit call(ctx, arg2=A, arg3=X) */\n\t\tinsn->code = BPF_JMP | BPF_CALL;\n\t\tswitch (fp->k) {\n\t\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\t\t\tinsn->imm = __skb_get_pay_offset - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\t\t\tinsn->imm = __skb_get_nlattr - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\t\t\tinsn->imm = __skb_get_nlattr_nest - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t\tinsn->imm = __get_raw_cpu_id - __bpf_call_base;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_ALU_XOR_X:\n\t\tinsn->code = BPF_ALU | BPF_XOR | BPF_X;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tbreak;\n\n\tdefault:\n\t\t/* This is just a dummy call to avoid letting the compiler\n\t\t * evict __bpf_call_base() as an optimization. Placed here\n\t\t * where no-one bothers.\n\t\t */\n\t\tBUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);\n\t\treturn false;\n\t}\n\n\t*insnp = insn;\n\treturn true;\n}\n\n/**\n *\tsk_convert_filter - convert filter program\n *\t@prog: the user passed filter program\n *\t@len: the length of the user passed filter program\n *\t@new_prog: buffer where converted program will be stored\n *\t@new_len: pointer to store length of converted program\n *\n * Remap 'sock_filter' style BPF instruction set to 'sock_filter_ext' style.\n * Conversion workflow:\n *\n * 1) First pass for calculating the new program length:\n *   sk_convert_filter(old_prog, old_len, NULL, &new_len)\n *\n * 2) 2nd pass to remap in two passes: 1st pass finds new\n *    jump offsets, 2nd pass remapping:\n *   new_prog = kmalloc(sizeof(struct sock_filter_int) * new_len);\n *   sk_convert_filter(old_prog, old_len, new_prog, &new_len);\n *\n * User BPF's register A is mapped to our BPF register 6, user BPF\n * register X is mapped to BPF register 7; frame pointer is always\n * register 10; Context 'void *ctx' is stored in register 1, that is,\n * for socket filters: ctx == 'struct sk_buff *', for seccomp:\n * ctx == 'struct seccomp_data *'.\n */\nint sk_convert_filter(struct sock_filter *prog, int len,\n\t\t      struct sock_filter_int *new_prog, int *new_len)\n{\n\tint new_flen = 0, pass = 0, target, i;\n\tstruct sock_filter_int *new_insn;\n\tstruct sock_filter *fp;\n\tint *addrs = NULL;\n\tu8 bpf_src;\n\n\tBUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);\n\tBUILD_BUG_ON(FP_REG + 1 != MAX_BPF_REG);\n\n\tif (len <= 0 || len >= BPF_MAXINSNS)\n\t\treturn -EINVAL;\n\n\tif (new_prog) {\n\t\taddrs = kzalloc(len * sizeof(*addrs), GFP_KERNEL);\n\t\tif (!addrs)\n\t\t\treturn -ENOMEM;\n\t}\n\ndo_pass:\n\tnew_insn = new_prog;\n\tfp = prog;\n\n\tif (new_insn) {\n\t\tnew_insn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tnew_insn->a_reg = CTX_REG;\n\t\tnew_insn->x_reg = ARG1_REG;\n\t}\n\tnew_insn++;\n\n\tfor (i = 0; i < len; fp++, i++) {\n\t\tstruct sock_filter_int tmp_insns[6] = { };\n\t\tstruct sock_filter_int *insn = tmp_insns;\n\n\t\tif (addrs)\n\t\t\taddrs[i] = new_insn - new_prog;\n\n\t\tswitch (fp->code) {\n\t\t/* All arithmetic insns and skb loads map as-is. */\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_MOD | BPF_X:\n\t\tcase BPF_ALU | BPF_MOD | BPF_K:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_ABS | BPF_W:\n\t\tcase BPF_LD | BPF_ABS | BPF_H:\n\t\tcase BPF_LD | BPF_ABS | BPF_B:\n\t\tcase BPF_LD | BPF_IND | BPF_W:\n\t\tcase BPF_LD | BPF_IND | BPF_H:\n\t\tcase BPF_LD | BPF_IND | BPF_B:\n\t\t\t/* Check for overloaded BPF extension and\n\t\t\t * directly convert it if found, otherwise\n\t\t\t * just move on with mapping.\n\t\t\t */\n\t\t\tif (BPF_CLASS(fp->code) == BPF_LD &&\n\t\t\t    BPF_MODE(fp->code) == BPF_ABS &&\n\t\t\t    convert_bpf_extensions(fp, &insn))\n\t\t\t\tbreak;\n\n\t\t\tinsn->code = fp->code;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = X_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tbreak;\n\n\t\t/* Jump opcodes map as-is, but offsets need adjustment. */\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\ttarget = i + fp->k + 1;\n\t\t\tinsn->code = fp->code;\n#define EMIT_JMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (target >= len || target < 0)\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\t\\\n\t\tinsn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;\t\\\n\t\t/* Adjust pc relative offset for 2nd or 3rd insn. */\t\\\n\t\tinsn->off -= insn - tmp_insns;\t\t\t\t\\\n\t} while (0)\n\n\t\t\tEMIT_JMP;\n\t\t\tbreak;\n\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\t\tif (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {\n\t\t\t\t/* BPF immediates are signed, zero extend\n\t\t\t\t * immediate into tmp register and use it\n\t\t\t\t * in compare insn.\n\t\t\t\t */\n\t\t\t\tinsn->code = BPF_ALU | BPF_MOV | BPF_K;\n\t\t\t\tinsn->a_reg = TMP_REG;\n\t\t\t\tinsn->imm = fp->k;\n\t\t\t\tinsn++;\n\n\t\t\t\tinsn->a_reg = A_REG;\n\t\t\t\tinsn->x_reg = TMP_REG;\n\t\t\t\tbpf_src = BPF_X;\n\t\t\t} else {\n\t\t\t\tinsn->a_reg = A_REG;\n\t\t\t\tinsn->x_reg = X_REG;\n\t\t\t\tinsn->imm = fp->k;\n\t\t\t\tbpf_src = BPF_SRC(fp->code);\n\t\t\t}\n\n\t\t\t/* Common case where 'jump_false' is next insn. */\n\t\t\tif (fp->jf == 0) {\n\t\t\t\tinsn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;\n\t\t\t\ttarget = i + fp->jt + 1;\n\t\t\t\tEMIT_JMP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Convert JEQ into JNE when 'jump_true' is next insn. */\n\t\t\tif (fp->jt == 0 && BPF_OP(fp->code) == BPF_JEQ) {\n\t\t\t\tinsn->code = BPF_JMP | BPF_JNE | bpf_src;\n\t\t\t\ttarget = i + fp->jf + 1;\n\t\t\t\tEMIT_JMP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Other jumps are mapped into two insns: Jxx and JA. */\n\t\t\ttarget = i + fp->jt + 1;\n\t\t\tinsn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;\n\t\t\tEMIT_JMP;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_JMP | BPF_JA;\n\t\t\ttarget = i + fp->jf + 1;\n\t\t\tEMIT_JMP;\n\t\t\tbreak;\n\n\t\t/* ldxb 4 * ([14] & 0xf) is remaped into 6 insns. */\n\t\tcase BPF_LDX | BPF_MSH | BPF_B:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = TMP_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_LD | BPF_ABS | BPF_B;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 0xf;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_LSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 2;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = X_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = TMP_REG;\n\t\t\tbreak;\n\n\t\t/* RET_K, RET_A are remaped into 2 insns. */\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_RET | BPF_K:\n\t\t\tinsn->code = BPF_ALU | BPF_MOV |\n\t\t\t\t     (BPF_RVAL(fp->code) == BPF_K ?\n\t\t\t\t      BPF_K : BPF_X);\n\t\t\tinsn->a_reg = 0;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\t\tbreak;\n\n\t\t/* Store to stack. */\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\t\tinsn->code = BPF_STX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = FP_REG;\n\t\t\tinsn->x_reg = fp->code == BPF_ST ? A_REG : X_REG;\n\t\t\tinsn->off = -(BPF_MEMWORDS - fp->k) * 4;\n\t\t\tbreak;\n\n\t\t/* Load from stack. */\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->x_reg = FP_REG;\n\t\t\tinsn->off = -(BPF_MEMWORDS - fp->k) * 4;\n\t\t\tbreak;\n\n\t\t/* A = K or X = K */\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\t\tinsn->code = BPF_ALU | BPF_MOV | BPF_K;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->imm = fp->k;\n\t\t\tbreak;\n\n\t\t/* X = A */\n\t\tcase BPF_MISC | BPF_TAX:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = X_REG;\n\t\t\tinsn->x_reg = A_REG;\n\t\t\tbreak;\n\n\t\t/* A = X */\n\t\tcase BPF_MISC | BPF_TXA:\n\t\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = X_REG;\n\t\t\tbreak;\n\n\t\t/* A = skb->len or X = skb->len */\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?\n\t\t\t\t      A_REG : X_REG;\n\t\t\tinsn->x_reg = CTX_REG;\n\t\t\tinsn->off = offsetof(struct sk_buff, len);\n\t\t\tbreak;\n\n\t\t/* access seccomp_data fields */\n\t\tcase BPF_LDX | BPF_ABS | BPF_W:\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->x_reg = CTX_REG;\n\t\t\tinsn->off = fp->k;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\n\t\tinsn++;\n\t\tif (new_prog)\n\t\t\tmemcpy(new_insn, tmp_insns,\n\t\t\t       sizeof(*insn) * (insn - tmp_insns));\n\n\t\tnew_insn += insn - tmp_insns;\n\t}\n\n\tif (!new_prog) {\n\t\t/* Only calculating new length. */\n\t\t*new_len = new_insn - new_prog;\n\t\treturn 0;\n\t}\n\n\tpass++;\n\tif (new_flen != new_insn - new_prog) {\n\t\tnew_flen = new_insn - new_prog;\n\t\tif (pass > 2)\n\t\t\tgoto err;\n\n\t\tgoto do_pass;\n\t}\n\n\tkfree(addrs);\n\tBUG_ON(*new_len != new_flen);\n\treturn 0;\nerr:\n\tkfree(addrs);\n\treturn -EINVAL;\n}\n\n/* Security:\n *\n * A BPF program is able to use 16 cells of memory to store intermediate\n * values (check u32 mem[BPF_MEMWORDS] in sk_run_filter()).\n *\n * As we dont want to clear mem[] array for each packet going through\n * sk_run_filter(), we check that filter loaded by user never try to read\n * a cell if not previously written, and we check all branches to be sure\n * a malicious user doesn't try to abuse us.\n */\nstatic int check_load_and_stores(struct sock_filter *filter, int flen)\n{\n\tu16 *masks, memvalid = 0; /* one bit per cell, 16 cells */\n\tint pc, ret = 0;\n\n\tBUILD_BUG_ON(BPF_MEMWORDS > 16);\n\tmasks = kmalloc(flen * sizeof(*masks), GFP_KERNEL);\n\tif (!masks)\n\t\treturn -ENOMEM;\n\tmemset(masks, 0xff, flen * sizeof(*masks));\n\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tmemvalid &= masks[pc];\n\n\t\tswitch (filter[pc].code) {\n\t\tcase BPF_S_ST:\n\t\tcase BPF_S_STX:\n\t\t\tmemvalid |= (1 << filter[pc].k);\n\t\t\tbreak;\n\t\tcase BPF_S_LD_MEM:\n\t\tcase BPF_S_LDX_MEM:\n\t\t\tif (!(memvalid & (1 << filter[pc].k))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JA:\n\t\t\t/* a jump must set masks on target */\n\t\t\tmasks[pc + 1 + filter[pc].k] &= memvalid;\n\t\t\tmemvalid = ~0;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JEQ_K:\n\t\tcase BPF_S_JMP_JEQ_X:\n\t\tcase BPF_S_JMP_JGE_K:\n\t\tcase BPF_S_JMP_JGE_X:\n\t\tcase BPF_S_JMP_JGT_K:\n\t\tcase BPF_S_JMP_JGT_X:\n\t\tcase BPF_S_JMP_JSET_X:\n\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t/* a jump must set masks on targets */\n\t\t\tmasks[pc + 1 + filter[pc].jt] &= memvalid;\n\t\t\tmasks[pc + 1 + filter[pc].jf] &= memvalid;\n\t\t\tmemvalid = ~0;\n\t\t\tbreak;\n\t\t}\n\t}\nerror:\n\tkfree(masks);\n\treturn ret;\n}\n\n/**\n *\tsk_chk_filter - verify socket filter code\n *\t@filter: filter to verify\n *\t@flen: length of filter\n *\n * Check the user's filter code. If we let some ugly\n * filter code slip through kaboom! The filter must contain\n * no references or jumps that are out of range, no illegal\n * instructions, and must end with a RET instruction.\n *\n * All jumps are forward as they are not signed.\n *\n * Returns 0 if the rule set is legal or -EINVAL if not.\n */\nint sk_chk_filter(struct sock_filter *filter, unsigned int flen)\n{\n\t/*\n\t * Valid instructions are initialized to non-0.\n\t * Invalid instructions are initialized to 0.\n\t */\n\tstatic const u8 codes[] = {\n\t\t[BPF_ALU|BPF_ADD|BPF_K]  = BPF_S_ALU_ADD_K,\n\t\t[BPF_ALU|BPF_ADD|BPF_X]  = BPF_S_ALU_ADD_X,\n\t\t[BPF_ALU|BPF_SUB|BPF_K]  = BPF_S_ALU_SUB_K,\n\t\t[BPF_ALU|BPF_SUB|BPF_X]  = BPF_S_ALU_SUB_X,\n\t\t[BPF_ALU|BPF_MUL|BPF_K]  = BPF_S_ALU_MUL_K,\n\t\t[BPF_ALU|BPF_MUL|BPF_X]  = BPF_S_ALU_MUL_X,\n\t\t[BPF_ALU|BPF_DIV|BPF_X]  = BPF_S_ALU_DIV_X,\n\t\t[BPF_ALU|BPF_MOD|BPF_K]  = BPF_S_ALU_MOD_K,\n\t\t[BPF_ALU|BPF_MOD|BPF_X]  = BPF_S_ALU_MOD_X,\n\t\t[BPF_ALU|BPF_AND|BPF_K]  = BPF_S_ALU_AND_K,\n\t\t[BPF_ALU|BPF_AND|BPF_X]  = BPF_S_ALU_AND_X,\n\t\t[BPF_ALU|BPF_OR|BPF_K]   = BPF_S_ALU_OR_K,\n\t\t[BPF_ALU|BPF_OR|BPF_X]   = BPF_S_ALU_OR_X,\n\t\t[BPF_ALU|BPF_XOR|BPF_K]  = BPF_S_ALU_XOR_K,\n\t\t[BPF_ALU|BPF_XOR|BPF_X]  = BPF_S_ALU_XOR_X,\n\t\t[BPF_ALU|BPF_LSH|BPF_K]  = BPF_S_ALU_LSH_K,\n\t\t[BPF_ALU|BPF_LSH|BPF_X]  = BPF_S_ALU_LSH_X,\n\t\t[BPF_ALU|BPF_RSH|BPF_K]  = BPF_S_ALU_RSH_K,\n\t\t[BPF_ALU|BPF_RSH|BPF_X]  = BPF_S_ALU_RSH_X,\n\t\t[BPF_ALU|BPF_NEG]        = BPF_S_ALU_NEG,\n\t\t[BPF_LD|BPF_W|BPF_ABS]   = BPF_S_LD_W_ABS,\n\t\t[BPF_LD|BPF_H|BPF_ABS]   = BPF_S_LD_H_ABS,\n\t\t[BPF_LD|BPF_B|BPF_ABS]   = BPF_S_LD_B_ABS,\n\t\t[BPF_LD|BPF_W|BPF_LEN]   = BPF_S_LD_W_LEN,\n\t\t[BPF_LD|BPF_W|BPF_IND]   = BPF_S_LD_W_IND,\n\t\t[BPF_LD|BPF_H|BPF_IND]   = BPF_S_LD_H_IND,\n\t\t[BPF_LD|BPF_B|BPF_IND]   = BPF_S_LD_B_IND,\n\t\t[BPF_LD|BPF_IMM]         = BPF_S_LD_IMM,\n\t\t[BPF_LDX|BPF_W|BPF_LEN]  = BPF_S_LDX_W_LEN,\n\t\t[BPF_LDX|BPF_B|BPF_MSH]  = BPF_S_LDX_B_MSH,\n\t\t[BPF_LDX|BPF_IMM]        = BPF_S_LDX_IMM,\n\t\t[BPF_MISC|BPF_TAX]       = BPF_S_MISC_TAX,\n\t\t[BPF_MISC|BPF_TXA]       = BPF_S_MISC_TXA,\n\t\t[BPF_RET|BPF_K]          = BPF_S_RET_K,\n\t\t[BPF_RET|BPF_A]          = BPF_S_RET_A,\n\t\t[BPF_ALU|BPF_DIV|BPF_K]  = BPF_S_ALU_DIV_K,\n\t\t[BPF_LD|BPF_MEM]         = BPF_S_LD_MEM,\n\t\t[BPF_LDX|BPF_MEM]        = BPF_S_LDX_MEM,\n\t\t[BPF_ST]                 = BPF_S_ST,\n\t\t[BPF_STX]                = BPF_S_STX,\n\t\t[BPF_JMP|BPF_JA]         = BPF_S_JMP_JA,\n\t\t[BPF_JMP|BPF_JEQ|BPF_K]  = BPF_S_JMP_JEQ_K,\n\t\t[BPF_JMP|BPF_JEQ|BPF_X]  = BPF_S_JMP_JEQ_X,\n\t\t[BPF_JMP|BPF_JGE|BPF_K]  = BPF_S_JMP_JGE_K,\n\t\t[BPF_JMP|BPF_JGE|BPF_X]  = BPF_S_JMP_JGE_X,\n\t\t[BPF_JMP|BPF_JGT|BPF_K]  = BPF_S_JMP_JGT_K,\n\t\t[BPF_JMP|BPF_JGT|BPF_X]  = BPF_S_JMP_JGT_X,\n\t\t[BPF_JMP|BPF_JSET|BPF_K] = BPF_S_JMP_JSET_K,\n\t\t[BPF_JMP|BPF_JSET|BPF_X] = BPF_S_JMP_JSET_X,\n\t};\n\tint pc;\n\tbool anc_found;\n\n\tif (flen == 0 || flen > BPF_MAXINSNS)\n\t\treturn -EINVAL;\n\n\t/* check the filter code now */\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\n\t\tif (code >= ARRAY_SIZE(codes))\n\t\t\treturn -EINVAL;\n\t\tcode = codes[code];\n\t\tif (!code)\n\t\t\treturn -EINVAL;\n\t\t/* Some instructions need special checks */\n\t\tswitch (code) {\n\t\tcase BPF_S_ALU_DIV_K:\n\t\tcase BPF_S_ALU_MOD_K:\n\t\t\t/* check for division by zero */\n\t\t\tif (ftest->k == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_LD_MEM:\n\t\tcase BPF_S_LDX_MEM:\n\t\tcase BPF_S_ST:\n\t\tcase BPF_S_STX:\n\t\t\t/* check for invalid memory addresses */\n\t\t\tif (ftest->k >= BPF_MEMWORDS)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JA:\n\t\t\t/*\n\t\t\t * Note, the large ftest->k might cause loops.\n\t\t\t * Compare this with conditional jumps below,\n\t\t\t * where offsets are limited. --ANK (981016)\n\t\t\t */\n\t\t\tif (ftest->k >= (unsigned int)(flen-pc-1))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_JMP_JEQ_K:\n\t\tcase BPF_S_JMP_JEQ_X:\n\t\tcase BPF_S_JMP_JGE_K:\n\t\tcase BPF_S_JMP_JGE_X:\n\t\tcase BPF_S_JMP_JGT_K:\n\t\tcase BPF_S_JMP_JGT_X:\n\t\tcase BPF_S_JMP_JSET_X:\n\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t/* for conditionals both must be safe */\n\t\t\tif (pc + ftest->jt + 1 >= flen ||\n\t\t\t    pc + ftest->jf + 1 >= flen)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\tanc_found = false;\n#define ANCILLARY(CODE) case SKF_AD_OFF + SKF_AD_##CODE:\t\\\n\t\t\t\tcode = BPF_S_ANC_##CODE;\t\\\n\t\t\t\tanc_found = true;\t\t\\\n\t\t\t\tbreak\n\t\t\tswitch (ftest->k) {\n\t\t\tANCILLARY(PROTOCOL);\n\t\t\tANCILLARY(PKTTYPE);\n\t\t\tANCILLARY(IFINDEX);\n\t\t\tANCILLARY(NLATTR);\n\t\t\tANCILLARY(NLATTR_NEST);\n\t\t\tANCILLARY(MARK);\n\t\t\tANCILLARY(QUEUE);\n\t\t\tANCILLARY(HATYPE);\n\t\t\tANCILLARY(RXHASH);\n\t\t\tANCILLARY(CPU);\n\t\t\tANCILLARY(ALU_XOR_X);\n\t\t\tANCILLARY(VLAN_TAG);\n\t\t\tANCILLARY(VLAN_TAG_PRESENT);\n\t\t\tANCILLARY(PAY_OFFSET);\n\t\t\t}\n\n\t\t\t/* ancillary operation unknown or unsupported */\n\t\t\tif (anc_found == false && ftest->k >= SKF_AD_OFF)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tftest->code = code;\n\t}\n\n\t/* last instruction must be a RET code */\n\tswitch (filter[flen - 1].code) {\n\tcase BPF_S_RET_K:\n\tcase BPF_S_RET_A:\n\t\treturn check_load_and_stores(filter, flen);\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(sk_chk_filter);\n\nstatic int sk_store_orig_filter(struct sk_filter *fp,\n\t\t\t\tconst struct sock_fprog *fprog)\n{\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tstruct sock_fprog_kern *fkprog;\n\n\tfp->orig_prog = kmalloc(sizeof(*fkprog), GFP_KERNEL);\n\tif (!fp->orig_prog)\n\t\treturn -ENOMEM;\n\n\tfkprog = fp->orig_prog;\n\tfkprog->len = fprog->len;\n\tfkprog->filter = kmemdup(fp->insns, fsize, GFP_KERNEL);\n\tif (!fkprog->filter) {\n\t\tkfree(fp->orig_prog);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void sk_release_orig_filter(struct sk_filter *fp)\n{\n\tstruct sock_fprog_kern *fprog = fp->orig_prog;\n\n\tif (fprog) {\n\t\tkfree(fprog->filter);\n\t\tkfree(fprog);\n\t}\n}\n\n/**\n * \tsk_filter_release_rcu - Release a socket filter by rcu_head\n *\t@rcu: rcu_head that contains the sk_filter to free\n */\nstatic void sk_filter_release_rcu(struct rcu_head *rcu)\n{\n\tstruct sk_filter *fp = container_of(rcu, struct sk_filter, rcu);\n\n\tsk_release_orig_filter(fp);\n\tbpf_jit_free(fp);\n}\n\n/**\n *\tsk_filter_release - release a socket filter\n *\t@fp: filter to remove\n *\n *\tRemove a filter from a socket and release its resources.\n */\nstatic void sk_filter_release(struct sk_filter *fp)\n{\n\tif (atomic_dec_and_test(&fp->refcnt))\n\t\tcall_rcu(&fp->rcu, sk_filter_release_rcu);\n}\n\nvoid sk_filter_uncharge(struct sock *sk, struct sk_filter *fp)\n{\n\tatomic_sub(sk_filter_size(fp->len), &sk->sk_omem_alloc);\n\tsk_filter_release(fp);\n}\n\nvoid sk_filter_charge(struct sock *sk, struct sk_filter *fp)\n{\n\tatomic_inc(&fp->refcnt);\n\tatomic_add(sk_filter_size(fp->len), &sk->sk_omem_alloc);\n}\n\nstatic struct sk_filter *__sk_migrate_realloc(struct sk_filter *fp,\n\t\t\t\t\t      struct sock *sk,\n\t\t\t\t\t      unsigned int len)\n{\n\tstruct sk_filter *fp_new;\n\n\tif (sk == NULL)\n\t\treturn krealloc(fp, len, GFP_KERNEL);\n\n\tfp_new = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (fp_new) {\n\t\tmemcpy(fp_new, fp, sizeof(struct sk_filter));\n\t\t/* As we're kepping orig_prog in fp_new along,\n\t\t * we need to make sure we're not evicting it\n\t\t * from the old fp.\n\t\t */\n\t\tfp->orig_prog = NULL;\n\t\tsk_filter_uncharge(sk, fp);\n\t}\n\n\treturn fp_new;\n}\n\nstatic struct sk_filter *__sk_migrate_filter(struct sk_filter *fp,\n\t\t\t\t\t     struct sock *sk)\n{\n\tstruct sock_filter *old_prog;\n\tstruct sk_filter *old_fp;\n\tint i, err, new_len, old_len = fp->len;\n\n\t/* We are free to overwrite insns et al right here as it\n\t * won't be used at this point in time anymore internally\n\t * after the migration to the internal BPF instruction\n\t * representation.\n\t */\n\tBUILD_BUG_ON(sizeof(struct sock_filter) !=\n\t\t     sizeof(struct sock_filter_int));\n\n\t/* For now, we need to unfiddle BPF_S_* identifiers in place.\n\t * This can sooner or later on be subject to removal, e.g. when\n\t * JITs have been converted.\n\t */\n\tfor (i = 0; i < fp->len; i++)\n\t\tsk_decode_filter(&fp->insns[i], &fp->insns[i]);\n\n\t/* Conversion cannot happen on overlapping memory areas,\n\t * so we need to keep the user BPF around until the 2nd\n\t * pass. At this time, the user BPF is stored in fp->insns.\n\t */\n\told_prog = kmemdup(fp->insns, old_len * sizeof(struct sock_filter),\n\t\t\t   GFP_KERNEL);\n\tif (!old_prog) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t/* 1st pass: calculate the new program length. */\n\terr = sk_convert_filter(old_prog, old_len, NULL, &new_len);\n\tif (err)\n\t\tgoto out_err_free;\n\n\t/* Expand fp for appending the new filter representation. */\n\told_fp = fp;\n\tfp = __sk_migrate_realloc(old_fp, sk, sk_filter_size(new_len));\n\tif (!fp) {\n\t\t/* The old_fp is still around in case we couldn't\n\t\t * allocate new memory, so uncharge on that one.\n\t\t */\n\t\tfp = old_fp;\n\t\terr = -ENOMEM;\n\t\tgoto out_err_free;\n\t}\n\n\tfp->bpf_func = sk_run_filter_int_skb;\n\tfp->len = new_len;\n\n\t/* 2nd pass: remap sock_filter insns into sock_filter_int insns. */\n\terr = sk_convert_filter(old_prog, old_len, fp->insnsi, &new_len);\n\tif (err)\n\t\t/* 2nd sk_convert_filter() can fail only if it fails\n\t\t * to allocate memory, remapping must succeed. Note,\n\t\t * that at this time old_fp has already been released\n\t\t * by __sk_migrate_realloc().\n\t\t */\n\t\tgoto out_err_free;\n\n\tkfree(old_prog);\n\treturn fp;\n\nout_err_free:\n\tkfree(old_prog);\nout_err:\n\t/* Rollback filter setup. */\n\tif (sk != NULL)\n\t\tsk_filter_uncharge(sk, fp);\n\telse\n\t\tkfree(fp);\n\treturn ERR_PTR(err);\n}\n\nstatic struct sk_filter *__sk_prepare_filter(struct sk_filter *fp,\n\t\t\t\t\t     struct sock *sk)\n{\n\tint err;\n\n\tfp->bpf_func = NULL;\n\tfp->jited = 0;\n\n\terr = sk_chk_filter(fp->insns, fp->len);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* Probe if we can JIT compile the filter and if so, do\n\t * the compilation of the filter.\n\t */\n\tbpf_jit_compile(fp);\n\n\t/* JIT compiler couldn't process this filter, so do the\n\t * internal BPF translation for the optimized interpreter.\n\t */\n\tif (!fp->jited)\n\t\tfp = __sk_migrate_filter(fp, sk);\n\n\treturn fp;\n}\n\n/**\n *\tsk_unattached_filter_create - create an unattached filter\n *\t@fprog: the filter program\n *\t@pfp: the unattached filter that is created\n *\n * Create a filter independent of any socket. We first run some\n * sanity checks on it to make sure it does not explode on us later.\n * If an error occurs or there is insufficient memory for the filter\n * a negative errno code is returned. On success the return is zero.\n */\nint sk_unattached_filter_create(struct sk_filter **pfp,\n\t\t\t\tstruct sock_fprog *fprog)\n{\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tstruct sk_filter *fp;\n\n\t/* Make sure new filter is there and in the right amounts. */\n\tif (fprog->filter == NULL)\n\t\treturn -EINVAL;\n\n\tfp = kmalloc(sk_filter_size(fprog->len), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tmemcpy(fp->insns, fprog->filter, fsize);\n\n\tatomic_set(&fp->refcnt, 1);\n\tfp->len = fprog->len;\n\t/* Since unattached filters are not copied back to user\n\t * space through sk_get_filter(), we do not need to hold\n\t * a copy here, and can spare us the work.\n\t */\n\tfp->orig_prog = NULL;\n\n\t/* __sk_prepare_filter() already takes care of uncharging\n\t * memory in case something goes wrong.\n\t */\n\tfp = __sk_prepare_filter(fp, NULL);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\t*pfp = fp;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sk_unattached_filter_create);\n\nvoid sk_unattached_filter_destroy(struct sk_filter *fp)\n{\n\tsk_filter_release(fp);\n}\nEXPORT_SYMBOL_GPL(sk_unattached_filter_destroy);\n\n/**\n *\tsk_attach_filter - attach a socket filter\n *\t@fprog: the filter program\n *\t@sk: the socket to use\n *\n * Attach the user's filter code. We first run some sanity checks on\n * it to make sure it does not explode on us later. If an error\n * occurs or there is insufficient memory for the filter a negative\n * errno code is returned. On success the return is zero.\n */\nint sk_attach_filter(struct sock_fprog *fprog, struct sock *sk)\n{\n\tstruct sk_filter *fp, *old_fp;\n\tunsigned int fsize = sk_filter_proglen(fprog);\n\tunsigned int sk_fsize = sk_filter_size(fprog->len);\n\tint err;\n\n\tif (sock_flag(sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\n\t/* Make sure new filter is there and in the right amounts. */\n\tif (fprog->filter == NULL)\n\t\treturn -EINVAL;\n\n\tfp = sock_kmalloc(sk, sk_fsize, GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(fp->insns, fprog->filter, fsize)) {\n\t\tsock_kfree_s(sk, fp, sk_fsize);\n\t\treturn -EFAULT;\n\t}\n\n\tatomic_set(&fp->refcnt, 1);\n\tfp->len = fprog->len;\n\n\terr = sk_store_orig_filter(fp, fprog);\n\tif (err) {\n\t\tsk_filter_uncharge(sk, fp);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* __sk_prepare_filter() already takes care of uncharging\n\t * memory in case something goes wrong.\n\t */\n\tfp = __sk_prepare_filter(fp, sk);\n\tif (IS_ERR(fp))\n\t\treturn PTR_ERR(fp);\n\n\told_fp = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\trcu_assign_pointer(sk->sk_filter, fp);\n\n\tif (old_fp)\n\t\tsk_filter_uncharge(sk, old_fp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sk_attach_filter);\n\nint sk_detach_filter(struct sock *sk)\n{\n\tint ret = -ENOENT;\n\tstruct sk_filter *filter;\n\n\tif (sock_flag(sk, SOCK_FILTER_LOCKED))\n\t\treturn -EPERM;\n\n\tfilter = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\tif (filter) {\n\t\tRCU_INIT_POINTER(sk->sk_filter, NULL);\n\t\tsk_filter_uncharge(sk, filter);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sk_detach_filter);\n\nvoid sk_decode_filter(struct sock_filter *filt, struct sock_filter *to)\n{\n\tstatic const u16 decodes[] = {\n\t\t[BPF_S_ALU_ADD_K]\t= BPF_ALU|BPF_ADD|BPF_K,\n\t\t[BPF_S_ALU_ADD_X]\t= BPF_ALU|BPF_ADD|BPF_X,\n\t\t[BPF_S_ALU_SUB_K]\t= BPF_ALU|BPF_SUB|BPF_K,\n\t\t[BPF_S_ALU_SUB_X]\t= BPF_ALU|BPF_SUB|BPF_X,\n\t\t[BPF_S_ALU_MUL_K]\t= BPF_ALU|BPF_MUL|BPF_K,\n\t\t[BPF_S_ALU_MUL_X]\t= BPF_ALU|BPF_MUL|BPF_X,\n\t\t[BPF_S_ALU_DIV_X]\t= BPF_ALU|BPF_DIV|BPF_X,\n\t\t[BPF_S_ALU_MOD_K]\t= BPF_ALU|BPF_MOD|BPF_K,\n\t\t[BPF_S_ALU_MOD_X]\t= BPF_ALU|BPF_MOD|BPF_X,\n\t\t[BPF_S_ALU_AND_K]\t= BPF_ALU|BPF_AND|BPF_K,\n\t\t[BPF_S_ALU_AND_X]\t= BPF_ALU|BPF_AND|BPF_X,\n\t\t[BPF_S_ALU_OR_K]\t= BPF_ALU|BPF_OR|BPF_K,\n\t\t[BPF_S_ALU_OR_X]\t= BPF_ALU|BPF_OR|BPF_X,\n\t\t[BPF_S_ALU_XOR_K]\t= BPF_ALU|BPF_XOR|BPF_K,\n\t\t[BPF_S_ALU_XOR_X]\t= BPF_ALU|BPF_XOR|BPF_X,\n\t\t[BPF_S_ALU_LSH_K]\t= BPF_ALU|BPF_LSH|BPF_K,\n\t\t[BPF_S_ALU_LSH_X]\t= BPF_ALU|BPF_LSH|BPF_X,\n\t\t[BPF_S_ALU_RSH_K]\t= BPF_ALU|BPF_RSH|BPF_K,\n\t\t[BPF_S_ALU_RSH_X]\t= BPF_ALU|BPF_RSH|BPF_X,\n\t\t[BPF_S_ALU_NEG]\t\t= BPF_ALU|BPF_NEG,\n\t\t[BPF_S_LD_W_ABS]\t= BPF_LD|BPF_W|BPF_ABS,\n\t\t[BPF_S_LD_H_ABS]\t= BPF_LD|BPF_H|BPF_ABS,\n\t\t[BPF_S_LD_B_ABS]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PROTOCOL]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PKTTYPE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_IFINDEX]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_NLATTR]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_NLATTR_NEST]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_MARK]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_QUEUE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_HATYPE]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_RXHASH]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_CPU]\t\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_ALU_XOR_X]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_SECCOMP_LD_W] = BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_VLAN_TAG]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_VLAN_TAG_PRESENT] = BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_ANC_PAY_OFFSET]\t= BPF_LD|BPF_B|BPF_ABS,\n\t\t[BPF_S_LD_W_LEN]\t= BPF_LD|BPF_W|BPF_LEN,\n\t\t[BPF_S_LD_W_IND]\t= BPF_LD|BPF_W|BPF_IND,\n\t\t[BPF_S_LD_H_IND]\t= BPF_LD|BPF_H|BPF_IND,\n\t\t[BPF_S_LD_B_IND]\t= BPF_LD|BPF_B|BPF_IND,\n\t\t[BPF_S_LD_IMM]\t\t= BPF_LD|BPF_IMM,\n\t\t[BPF_S_LDX_W_LEN]\t= BPF_LDX|BPF_W|BPF_LEN,\n\t\t[BPF_S_LDX_B_MSH]\t= BPF_LDX|BPF_B|BPF_MSH,\n\t\t[BPF_S_LDX_IMM]\t\t= BPF_LDX|BPF_IMM,\n\t\t[BPF_S_MISC_TAX]\t= BPF_MISC|BPF_TAX,\n\t\t[BPF_S_MISC_TXA]\t= BPF_MISC|BPF_TXA,\n\t\t[BPF_S_RET_K]\t\t= BPF_RET|BPF_K,\n\t\t[BPF_S_RET_A]\t\t= BPF_RET|BPF_A,\n\t\t[BPF_S_ALU_DIV_K]\t= BPF_ALU|BPF_DIV|BPF_K,\n\t\t[BPF_S_LD_MEM]\t\t= BPF_LD|BPF_MEM,\n\t\t[BPF_S_LDX_MEM]\t\t= BPF_LDX|BPF_MEM,\n\t\t[BPF_S_ST]\t\t= BPF_ST,\n\t\t[BPF_S_STX]\t\t= BPF_STX,\n\t\t[BPF_S_JMP_JA]\t\t= BPF_JMP|BPF_JA,\n\t\t[BPF_S_JMP_JEQ_K]\t= BPF_JMP|BPF_JEQ|BPF_K,\n\t\t[BPF_S_JMP_JEQ_X]\t= BPF_JMP|BPF_JEQ|BPF_X,\n\t\t[BPF_S_JMP_JGE_K]\t= BPF_JMP|BPF_JGE|BPF_K,\n\t\t[BPF_S_JMP_JGE_X]\t= BPF_JMP|BPF_JGE|BPF_X,\n\t\t[BPF_S_JMP_JGT_K]\t= BPF_JMP|BPF_JGT|BPF_K,\n\t\t[BPF_S_JMP_JGT_X]\t= BPF_JMP|BPF_JGT|BPF_X,\n\t\t[BPF_S_JMP_JSET_K]\t= BPF_JMP|BPF_JSET|BPF_K,\n\t\t[BPF_S_JMP_JSET_X]\t= BPF_JMP|BPF_JSET|BPF_X,\n\t};\n\tu16 code;\n\n\tcode = filt->code;\n\n\tto->code = decodes[code];\n\tto->jt = filt->jt;\n\tto->jf = filt->jf;\n\tto->k = filt->k;\n}\n\nint sk_get_filter(struct sock *sk, struct sock_filter __user *ubuf,\n\t\t  unsigned int len)\n{\n\tstruct sock_fprog_kern *fprog;\n\tstruct sk_filter *filter;\n\tint ret = 0;\n\n\tlock_sock(sk);\n\tfilter = rcu_dereference_protected(sk->sk_filter,\n\t\t\t\t\t   sock_owned_by_user(sk));\n\tif (!filter)\n\t\tgoto out;\n\n\t/* We're copying the filter that has been originally attached,\n\t * so no conversion/decode needed anymore.\n\t */\n\tfprog = filter->orig_prog;\n\n\tret = fprog->len;\n\tif (!len)\n\t\t/* User space only enquires number of filter blocks. */\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (len < fprog->len)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(ubuf, fprog->filter, sk_filter_proglen(fprog)))\n\t\tgoto out;\n\n\t/* Instead of bytes, the API requests to return the number\n\t * of filter blocks.\n\t */\n\tret = fprog->len;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}\n"], "filenames": ["net/core/filter.c"], "buggy_code_start_loc": [602], "buggy_code_end_loc": [626], "fixing_code_start_loc": [603], "fixing_code_end_loc": [632], "type": "CWE-125", "message": "The BPF_S_ANC_NLATTR_NEST extension implementation in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 uses the reverse order in a certain subtraction, which allows local users to cause a denial of service (over-read and system crash) via crafted BPF instructions. NOTE: the affected code was moved to the __skb_get_nlattr_nest function before the vulnerability was announced.", "other": {"cve": {"id": "CVE-2014-3145", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-11T21:55:06.187", "lastModified": "2023-02-13T00:39:05.753", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The BPF_S_ANC_NLATTR_NEST extension implementation in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 uses the reverse order in a certain subtraction, which allows local users to cause a denial of service (over-read and system crash) via crafted BPF instructions. NOTE: the affected code was moved to the __skb_get_nlattr_nest function before the vulnerability was announced."}, {"lang": "es", "value": "La implementaci\u00f3n de extensi\u00f3n BPF_S_ANC_NLATTR_NEST en la funci\u00f3n sk_run_filter en net/core/filter.c en el kernel de Linux hasta 3.14.3 utiliza el orden inverso en cierta resta, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (sobrelectura y ca\u00edda de sistema) a trav\u00e9s de instrucciones BPF manipuladas. NOTA: el c\u00f3digo afectado fue trasladado a la funci\u00f3n __skb_get_nlattr_nest antes de anunciar la vulnerabilidad."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.14.3", "matchCriteriaId": "B465C548-09E9-4CD5-A1C2-57ED09C9E3F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.10:*:*:*:*:*:*:*", "matchCriteriaId": "7F61F047-129C-41A6-8A27-FFCBB8563E91"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "source": "secalert@redhat.com"}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3052.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59311", "source": "secalert@redhat.com", "tags": ["Not Applicable"]}, {"url": "http://secunia.com/advisories/60613", "source": "secalert@redhat.com", "tags": ["Not Applicable"]}, {"url": "http://www.debian.org/security/2014/dsa-2949", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/05/09/6", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/67321", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038201", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2251-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2252-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2259-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2261-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2262-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2263-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2264-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-04-01", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3"}}