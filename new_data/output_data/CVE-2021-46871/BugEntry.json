{"buggy_code": ["defmodule Phoenix.HTML.Tag do\n  @moduledoc ~S\"\"\"\n  Helpers related to producing HTML tags within templates.\n\n  > Note: the examples in this module use `safe_to_string/1`\n  > imported from `Phoenix.HTML` for readability.\n\n  > Note: with the addition of the HEEx template engine to\n  > Phoenix applications, the functions in this module have\n  > lost a bit of relevance. Whenever possible, prefer to use\n  > the HEEx template engine instead of the functions here.\n  > For example, instead of:\n  >\n  >     <%= content_tag :div, class: @class do %>\n  >       Hello\n  >     <% end %>\n  >\n  > Do:\n  >\n  >     <div class={@class}>\n  >       Hello\n  >     </div>\n  \"\"\"\n\n  import Phoenix.HTML\n\n  @csrf_param \"_csrf_token\"\n\n  @doc ~S\"\"\"\n  Creates an HTML tag with the given name and options.\n\n      iex> safe_to_string tag(:br)\n      \"<br>\"\n      iex> safe_to_string tag(:input, type: \"text\", name: \"user_id\")\n      \"<input name=\\\"user_id\\\" type=\\\"text\\\">\"\n\n  ## Data attributes\n\n  In order to add custom data attributes you need to pass\n  a tuple containing :data atom and a keyword list\n  with data attributes' names and values as the first element\n  in the tag's attributes keyword list:\n\n      iex> safe_to_string tag(:input, [data: [foo: \"bar\"], id: \"some_id\"])\n      \"<input data-foo=\\\"bar\\\" id=\\\"some_id\\\">\"\n\n  ## Boolean values\n\n  In case an attribute contains a boolean value, its key\n  is repeated when it is true, as expected in HTML, or\n  the attribute is completely removed if it is false:\n\n      iex> safe_to_string tag(:audio, autoplay: \"autoplay\")\n      \"<audio autoplay=\\\"autoplay\\\">\"\n      iex> safe_to_string tag(:audio, autoplay: true)\n      \"<audio autoplay>\"\n      iex> safe_to_string tag(:audio, autoplay: false)\n      \"<audio>\"\n\n  If you want the boolean attribute to be sent as is,\n  you can explicitly convert it to a string before.\n  \"\"\"\n  def tag(name), do: tag(name, [])\n\n  def tag(name, attrs) when is_list(attrs) do\n    {:safe, [?<, to_string(name), sorted_attrs(attrs), ?>]}\n  end\n\n  @doc ~S\"\"\"\n  Creates an HTML tag with given name, content, and attributes.\n\n  See `Phoenix.HTML.Tag.tag/2` for more information and examples.\n\n      iex> safe_to_string content_tag(:p, \"Hello\")\n      \"<p>Hello</p>\"\n\n      iex> safe_to_string content_tag(:p, \"<Hello>\", class: \"test\")\n      \"<p class=\\\"test\\\">&lt;Hello&gt;</p>\"\n\n      iex> safe_to_string(content_tag :p, class: \"test\" do\n      ...>   \"Hello\"\n      ...> end)\n      \"<p class=\\\"test\\\">Hello</p>\"\n\n      iex> safe_to_string content_tag(:option, \"Display Value\", [{:data, [foo: \"bar\"]}, value: \"value\"])\n      \"<option data-foo=\\\"bar\\\" value=\\\"value\\\">Display Value</option>\"\n\n  \"\"\"\n  def content_tag(name, do: block) do\n    content_tag(name, block, [])\n  end\n\n  def content_tag(name, content) do\n    content_tag(name, content, [])\n  end\n\n  def content_tag(name, attrs, do: block) when is_list(attrs) do\n    content_tag(name, block, attrs)\n  end\n\n  def content_tag(name, content, attrs) when is_list(attrs) do\n    name = to_string(name)\n    {:safe, escaped} = html_escape(content)\n\n    {:safe, [?<, name, sorted_attrs(attrs), ?>, escaped, ?<, ?/, name, ?>]}\n  end\n\n  @doc ~S\"\"\"\n  Escapes an enumerable of attributes, returning iodata.\n\n  Pay attention that, unlike `tag/2` and `content_tag/2`, this\n  function does not sort the attributes. However if given a map,\n  note also that the key ordering may change.\n\n      iex> safe_to_string attributes_escape(title: \"the title\", id: \"the id\", selected: true)\n      \" title=\\\"the title\\\" id=\\\"the id\\\" selected\"\n\n      iex> safe_to_string attributes_escape(%{data: [phx: [value: [foo: \"bar\"]]], class: \"foo\"})\n      \" class=\\\"foo\\\" data-phx-value-foo=\\\"bar\\\"\"\n\n  \"\"\"\n  def attributes_escape(attrs) when is_list(attrs) do\n    {:safe, build_attrs(attrs)}\n  end\n\n  def attributes_escape(attrs) do\n    {:safe, attrs |> Enum.to_list() |> build_attrs()}\n  end\n\n  defp build_attrs([{\"data\", v} | t]) when is_list(v),\n    do: nested_attrs(v, \" data\", t)\n\n  defp build_attrs([{\"aria\", v} | t]) when is_list(v),\n    do: nested_attrs(v, \" aria\", t)\n\n  defp build_attrs([{\"class\", v} | t]) when is_list(v),\n    do: [\" class=\\\"\", class_value(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([{:data, v} | t]) when is_list(v),\n    do: nested_attrs(v, \" data\", t)\n\n  defp build_attrs([{:aria, v} | t]) when is_list(v),\n    do: nested_attrs(v, \" aria\", t)\n\n  defp build_attrs([{:class, v} | t]) when is_list(v),\n    do: [\" class=\\\"\", class_value(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([{k, true} | t]),\n    do: [?\\s, key_escape(k) | build_attrs(t)]\n\n  defp build_attrs([{_, false} | t]),\n    do: build_attrs(t)\n\n  defp build_attrs([{_, nil} | t]),\n    do: build_attrs(t)\n\n  defp build_attrs([{k, v} | t]),\n    do: [?\\s, key_escape(k), ?=, ?\", attr_escape(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([]), do: []\n\n  defp nested_attrs([{k, v} | kv], attr, t) when is_list(v),\n    do: [nested_attrs(v, \"#{attr}-#{key_escape(k)}\", []) | nested_attrs(kv, attr, t)]\n\n  defp nested_attrs([{k, v} | kv], attr, t),\n    do: [attr, ?-, key_escape(k), ?=, ?\", attr_escape(v), ?\" | nested_attrs(kv, attr, t)]\n\n  defp nested_attrs([], _attr, t),\n    do: build_attrs(t)\n\n  defp class_value(value) when is_list(value) do\n    value\n    |> Enum.filter(& &1)\n    |> Enum.join(\" \")\n  end\n\n  defp class_value(value) do\n    value\n  end\n\n  defp key_escape(value) when is_atom(value), do: String.replace(Atom.to_string(value), \"_\", \"-\")\n  defp key_escape(value), do: attr_escape(value)\n\n  defp attr_escape({:safe, data}), do: data\n  defp attr_escape(nil), do: []\n  defp attr_escape(other) when is_binary(other), do: Phoenix.HTML.Engine.encode_to_iodata!(other)\n  defp attr_escape(other), do: Phoenix.HTML.Safe.to_iodata(other)\n\n  defp sorted_attrs(attrs) when is_list(attrs),\n    do: attrs |> normalize_attrs() |> Enum.sort() |> build_attrs()\n\n  defp sorted_attrs(attrs),\n    do: attrs |> Enum.to_list() |> sorted_attrs()\n\n  defp normalize_attrs([{k, v} | tail]), do: [{k, v} | normalize_attrs(tail)]\n  defp normalize_attrs([k | tail]), do: [{k, true} | normalize_attrs(tail)]\n  defp normalize_attrs([]), do: []\n\n  @doc ~S\"\"\"\n  Generates a form tag.\n\n  This function generates the `<form>` tag without its closing part.\n  Check `form_tag/3` for generating an enclosing tag.\n\n  ## Examples\n\n      form_tag(\"/hello\")\n      <form action=\"/hello\" method=\"post\">\n\n      form_tag(\"/hello\", method: :get)\n      <form action=\"/hello\" method=\"get\">\n\n  ## Options\n\n    * `:method` - the HTTP method. If the method is not \"get\" nor \"post\",\n      an input tag with name `_method` is generated along-side the form tag.\n      Defaults to \"post\".\n\n    * `:multipart` - when true, sets enctype to \"multipart/form-data\".\n      Required when uploading files\n\n    * `:csrf_token` - for \"post\" requests, the form tag will automatically\n      include an input tag with name `_csrf_token`. When set to false, this\n      is disabled\n\n  All other options are passed to the underlying HTML tag.\n\n  ## CSRF Protection\n\n  By default, CSRF tokens are generated through `Plug.CSRFProtection`.\n  \"\"\"\n  def form_tag(action, opts \\\\ [])\n\n  def form_tag(action, do: block) do\n    form_tag(action, [], do: block)\n  end\n\n  def form_tag(action, opts) when is_list(opts) do\n    {:safe, method} = html_escape(Keyword.get(opts, :method, \"post\"))\n\n    {extra, opts} =\n      case method do\n        \"get\" ->\n          {\"\", opts}\n\n        \"post\" ->\n          {csrf, opts} = csrf_form_tag(action, opts)\n          {csrf, Keyword.put(opts, :method, \"post\")}\n\n        _ ->\n          {csrf, opts} = csrf_form_tag(action, opts)\n\n          {[~s'<input name=\"_method\" type=\"hidden\" value=\"', to_string(method), ~s'\">' | csrf],\n           Keyword.put(opts, :method, \"post\")}\n      end\n\n    opts =\n      case Keyword.pop(opts, :multipart, false) do\n        {false, opts} -> opts\n        {true, opts} -> Keyword.put(opts, :enctype, \"multipart/form-data\")\n      end\n\n    html_escape([tag(:form, [action: action] ++ opts), raw(extra)])\n  end\n\n  @doc \"\"\"\n  Generates a form tag with the given contents.\n\n  ## Examples\n\n      form_tag(\"/hello\", method: \"get\") do\n        \"Hello\"\n      end\n      <form action=\"/hello\" method=\"get\">...Hello...</form>\n\n  \"\"\"\n  def form_tag(action, options, do: block) do\n    html_escape([form_tag(action, options), block, raw(\"</form>\")])\n  end\n\n  defp csrf_form_tag(to, opts) do\n    case Keyword.pop(opts, :csrf_token, true) do\n      {csrf_token, opts} when is_binary(csrf_token) ->\n        {[~s'<input name=\"#{@csrf_param}\" type=\"hidden\" value=\"', csrf_token, ~s'\">'], opts}\n\n      {true, opts} ->\n        csrf_token = csrf_token_value(to)\n        {[~s'<input name=\"#{@csrf_param}\" type=\"hidden\" value=\"', csrf_token, ~s'\">'], opts}\n\n      {false, opts} ->\n        {[], opts}\n    end\n  end\n\n  @doc \"\"\"\n  Returns the `csrf_token` value to be used by forms, meta tags, etc.\n\n  By default, CSRF tokens are generated through `Plug.CSRFProtection`\n  which is capable of generating a separate token per host. Therefore\n  it is recommended to pass the `URI` of the destination as argument.\n  If none is given `%URI{host: nil}` is used, which implies a local\n  request is being done.\n  \"\"\"\n  def csrf_token_value(to \\\\ %URI{host: nil}) do\n    {mod, fun, args} = Application.fetch_env!(:phoenix_html, :csrf_token_reader)\n    apply(mod, fun, [to | args])\n  end\n\n  @doc \"\"\"\n  Generates a meta tag with CSRF information.\n\n  Additional options to the tag can be given.\n  \"\"\"\n  def csrf_meta_tag(opts \\\\ []) do\n    tag(:meta, [name: \"csrf-token\", content: csrf_token_value()] ++ opts)\n  end\n\n  @doc \"\"\"\n  Generates a hidden input tag with a CSRF token.\n\n  This could be used when writing a form without the use of tag\n  helpers like `form_tag/3` or `form_for/4`, while maintaining\n  CSRF protection.\n\n  The `to` argument should be the same as the form action.\n\n  ## Example\n\n      <form action=\"/login\" method=\"POST\">\n        <%= csrf_input_tag(\"/login\") %>\n\n        etc.\n      </form>\n\n  Additional options to the tag can be given.\n  \"\"\"\n  def csrf_input_tag(to, opts \\\\ []) do\n    csrf_token = csrf_token_value(to)\n    tag(:input, [type: \"hidden\", name: @csrf_param, value: csrf_token] ++ opts)\n  end\n\n  @doc \"\"\"\n  Generates an img tag with a src.\n\n  ## Examples\n\n      img_tag(user.photo_path)\n      <img src=\"/photo.png\">\n\n      img_tag(user.photo, class: \"image\")\n      <img src=\"/smile.png\" class=\"image\">\n\n  To generate a path to an image hosted in your application \"priv/static\",\n  with the `@conn` endpoint, use `static_path/2` to get a URL with\n  cache control parameters:\n\n      img_tag(Routes.static_path(@conn, \"/logo.png\"))\n      <img src=\"/logo-123456.png?vsn=d\">\n\n  For responsive images, pass a map, list or string through `:srcset`.\n\n      img_tag(\"/logo.png\", srcset: %{\"/logo.png\" => \"1x\", \"/logo-2x.png\" => \"2x\"})\n      <img src=\"/logo.png\" srcset=\"/logo.png 1x, /logo-2x.png 2x\">\n\n      img_tag(\"/logo.png\", srcset: [\"/logo.png\", {\"/logo-2x.png\", \"2x\"}])\n      <img src=\"/logo.png\" srcset=\"/logo.png, /logo-2x.png 2x\">\n\n  \"\"\"\n  def img_tag(src, opts \\\\ []) do\n    opts =\n      case Keyword.pop(opts, :srcset) do\n        {nil, opts} -> opts\n        {srcset, opts} -> [srcset: stringify_srcset(srcset)] ++ opts\n      end\n\n    tag(:img, Keyword.put_new(opts, :src, src))\n  end\n\n  defp stringify_srcset(srcset) when is_map(srcset) or is_list(srcset) do\n    Enum.map_join(srcset, \", \", fn\n      {src, descriptor} -> \"#{src} #{descriptor}\"\n      default -> default\n    end)\n  end\n\n  defp stringify_srcset(srcset) when is_binary(srcset),\n    do: srcset\nend\n", "defmodule Phoenix.HTML.TagTest do\n  use ExUnit.Case, async: true\n\n  import Phoenix.HTML\n  import Phoenix.HTML.Tag\n  doctest Phoenix.HTML.Tag\n\n  describe \"attributes_escape\" do\n    test \"key as atom\" do\n      assert attributes_escape([{:title, \"the title\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\")\n    end\n\n    test \"key as string\" do\n      assert attributes_escape([{\"title\", \"the title\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\")\n    end\n\n    test \"convert snake_case keys into kebab-case when key is atom\" do\n      assert attributes_escape([{:my_attr, \"value\"}]) |> safe_to_string() == ~s( my-attr=\"value\")\n    end\n\n    test \"keep snake_case keys when key is string\" do\n      assert attributes_escape([{\"my_attr\", \"value\"}]) |> safe_to_string() == ~s( my_attr=\"value\")\n    end\n\n    test \"multiple attributes\" do\n      assert attributes_escape([{:title, \"the title\"}, {:id, \"the id\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\" id=\"the id\")\n    end\n\n    test \"handle nested data\" do\n      assert attributes_escape([{\"data\", [a: \"1\", b: \"2\"]}]) |> safe_to_string() ==\n               ~s( data-a=\"1\" data-b=\"2\")\n\n      assert attributes_escape([{\"aria\", [a: \"1\", b: \"2\"]}]) |> safe_to_string() ==\n               ~s( aria-a=\"1\" aria-b=\"2\")\n    end\n\n    test \"handle class value as string\" do\n      assert attributes_escape([{:class, \"btn\"}]) |> safe_to_string() == ~s( class=\"btn\")\n    end\n\n    test \"handle class value as list\" do\n      assert attributes_escape([{:class, [\"btn\", nil, false, \"active\"]}]) |> safe_to_string() ==\n               ~s( class=\"btn active\")\n    end\n\n    test \"handle class key as string\" do\n      assert attributes_escape([{\"class\", \"btn\"}]) |> safe_to_string() == ~s( class=\"btn\")\n    end\n\n    test \"supress attribute when value is falsy\" do\n      assert attributes_escape([{\"title\", nil}]) |> safe_to_string() == ~s()\n      assert attributes_escape([{\"title\", false}]) |> safe_to_string() == ~s()\n    end\n\n    test \"supress value when value is true\" do\n      assert attributes_escape([{\"selected\", true}]) |> safe_to_string() == ~s( selected)\n    end\n  end\n\n  test \"tag\" do\n    assert tag(:br) |> safe_to_string() == ~s(<br>)\n\n    assert tag(:input, name: ~s(\"<3\")) |> safe_to_string() == ~s(<input name=\"&quot;&lt;3&quot;\">)\n    assert tag(:input, name: raw(\"<3\")) |> safe_to_string() == ~s(<input name=\"<3\">)\n    assert tag(:input, name: [\"foo\", raw(\"b<r\")]) |> safe_to_string() == ~s(<input name=\"foob<r\">)\n    assert tag(:input, name: :hello) |> safe_to_string() == ~s(<input name=\"hello\">)\n\n    assert tag(:input, type: \"text\", name: \"user_id\") |> safe_to_string() ==\n             ~s(<input name=\"user_id\" type=\"text\">)\n\n    assert tag(:input, data: [toggle: \"dropdown\"]) |> safe_to_string() ==\n             ~s(<input data-toggle=\"dropdown\">)\n\n    assert tag(:input, my_attr: \"blah\") |> safe_to_string() == ~s(<input my-attr=\"blah\">)\n\n    assert tag(:input, [{\"my_<_attr\", \"blah\"}]) |> safe_to_string() ==\n             ~s(<input my_&lt;_attr=\"blah\">)\n\n    assert tag(:input, [{{:safe, \"my_<_attr\"}, \"blah\"}]) |> safe_to_string() ==\n             ~s(<input my_<_attr=\"blah\">)\n\n    assert tag(:input, data: [my_attr: \"blah\"]) |> safe_to_string() ==\n             ~s(<input data-my-attr=\"blah\">)\n\n    assert tag(:input, data: [toggle: [attr: \"blah\", target: \"#parent\"]]) |> safe_to_string() ==\n             ~s(<input data-toggle-attr=\"blah\" data-toggle-target=\"#parent\">)\n\n    assert tag(:audio, autoplay: \"autoplay\") |> safe_to_string() ==\n             ~s(<audio autoplay=\"autoplay\">)\n\n    assert tag(:audio, autoplay: true) |> safe_to_string() == ~s(<audio autoplay>)\n    assert tag(:audio, autoplay: false) |> safe_to_string() == ~s(<audio>)\n    assert tag(:audio, autoplay: nil) |> safe_to_string() == ~s(<audio>)\n  end\n\n  test \"content_tag\" do\n    assert content_tag(:p, \"Hello\") |> safe_to_string() == \"<p>Hello</p>\"\n\n    assert content_tag(:p, \"Hello\", class: \"dark\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">Hello</p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: \"Hello\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">Hello</p>\"\n\n    assert content_tag(:p, \"<Hello>\") |> safe_to_string() == \"<p>&lt;Hello&gt;</p>\"\n\n    assert content_tag(:p, 13) |> safe_to_string() == \"<p>13</p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: \"<Hello>\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">&lt;Hello&gt;</p>\"\n\n    assert content_tag(:p, raw(\"<Hello>\")) |> safe_to_string() == \"<p><Hello></p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: raw(\"<Hello>\")) |> safe_to_string() ==\n             \"<p class=\\\"dark\\\"><Hello></p>\"\n\n    content =\n      content_tag :form, action: \"/users\", data: [remote: true] do\n        tag(:input, name: \"user[name]\")\n      end\n\n    assert safe_to_string(content) ==\n             ~s(<form action=\"/users\" data-remote=\"true\">) <> ~s(<input name=\"user[name]\"></form>)\n\n    assert content_tag(:p, do: \"Hello\") |> safe_to_string() == \"<p>Hello</p>\"\n\n    content =\n      content_tag :ul do\n        content_tag :li do\n          \"Hello\"\n        end\n      end\n\n    assert safe_to_string(content) == \"<ul><li>Hello</li></ul>\"\n\n    assert content_tag(:p, [\"hello\", ?\\s, \"world\"]) |> safe_to_string() == \"<p>hello world</p>\"\n\n    assert content_tag(:div, [autoplay: \"autoplay\"], do: \"\") |> safe_to_string() ==\n             ~s(<div autoplay=\"autoplay\"></div>)\n\n    assert content_tag(:div, [autoplay: true], do: \"\") |> safe_to_string() ==\n             ~s(<div autoplay></div>)\n\n    assert content_tag(:div, [autoplay: false], do: \"\") |> safe_to_string() == ~s(<div></div>)\n\n    assert content_tag(:div, [autoplay: nil], do: \"\") |> safe_to_string() == ~s(<div></div>)\n\n    assert content_tag(\"custom-tag\", \"Hi\") |> safe_to_string() == ~s(<custom-tag>Hi</custom-tag>)\n  end\n\n  test \"img_tag\" do\n    assert img_tag(\"user.png\") |> safe_to_string() == ~s(<img src=\"user.png\">)\n\n    assert img_tag(\"user.png\", class: \"big\") |> safe_to_string() ==\n             ~s(<img class=\"big\" src=\"user.png\">)\n\n    assert img_tag(\"user.png\", srcset: %{\"big.png\" => \"2x\", \"small.png\" => \"1x\"})\n           |> safe_to_string() ==\n             ~s(<img src=\"user.png\" srcset=\"big.png 2x, small.png 1x\">)\n\n    assert img_tag(\"user.png\", srcset: [{\"big.png\", \"2x\"}, \"small.png\"]) |> safe_to_string() ==\n             ~s(<img src=\"user.png\" srcset=\"big.png 2x, small.png\">)\n\n    assert img_tag(\"user.png\", srcset: \"big.png 2x, small.png\") |> safe_to_string() ==\n             ~s[<img src=\"user.png\" srcset=\"big.png 2x, small.png\">]\n  end\n\n  test \"form_tag for get\" do\n    assert safe_to_string(form_tag(\"/\", method: :get)) ==\n             ~s(<form action=\"/\" method=\"get\">)\n\n    assert safe_to_string(form_tag(\"/\", method: :get)) ==\n             ~s(<form action=\"/\" method=\"get\">)\n  end\n\n  test \"form_tag for post\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(form_tag(\"/\")) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n\n    assert safe_to_string(form_tag(\"/\", method: :post, csrf_token: false, multipart: true)) ==\n             ~s(<form action=\"/\" enctype=\"multipart/form-data\" method=\"post\">)\n  end\n\n  test \"form_tag for other method\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(form_tag(\"/\", method: :put)) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_method\" type=\"hidden\" value=\"put\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n  end\n\n  test \"form_tag with do block\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(\n             form_tag \"/\" do\n               \"<>\"\n             end\n           ) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">) <>\n               ~s(&lt;&gt;) <> ~s(</form>)\n\n    assert safe_to_string(\n             form_tag \"/\", method: :get do\n               \"<>\"\n             end\n           ) ==\n             ~s(<form action=\"/\" method=\"get\">) <>\n               ~s(&lt;&gt;) <> ~s(</form>)\n  end\n\n  test \"csrf_meta_tag\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(csrf_meta_tag()) ==\n             ~s(<meta content=\"#{csrf_token}\" name=\"csrf-token\">)\n\n    assert safe_to_string(csrf_meta_tag(foo: \"bar\")) ==\n             ~s(<meta content=\"#{csrf_token}\" foo=\"bar\" name=\"csrf-token\">)\n  end\n\n  test \"csrf_input_tag\" do\n    url = \"/example\"\n    csrf_token = Plug.CSRFProtection.get_csrf_token_for(url)\n\n    assert safe_to_string(csrf_input_tag(url)) ==\n             ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n\n    assert safe_to_string(csrf_input_tag(url, foo: \"bar\")) ==\n             ~s(<input foo=\"bar\" name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n  end\n\n  describe \"csrf_token_value\" do\n    def custom_csrf(to, extra), do: \"#{extra}:#{to}\"\n\n    test \"with default\" do\n      assert csrf_token_value(\"/\") == Plug.CSRFProtection.get_csrf_token()\n    end\n\n    @default_reader Application.fetch_env!(:phoenix_html, :csrf_token_reader)\n    test \"with configured MFA\" do\n      Application.put_env(\n        :phoenix_html,\n        :csrf_token_reader,\n        {__MODULE__, :custom_csrf, [\"extra\"]}\n      )\n\n      assert csrf_token_value(\"/foo\") == \"extra:/foo\"\n    after\n      Application.put_env(:phoenix_html, :csrf_token_reader, @default_reader)\n    end\n  end\nend\n"], "fixing_code": ["defmodule Phoenix.HTML.Tag do\n  @moduledoc ~S\"\"\"\n  Helpers related to producing HTML tags within templates.\n\n  > Note: the examples in this module use `safe_to_string/1`\n  > imported from `Phoenix.HTML` for readability.\n\n  > Note: with the addition of the HEEx template engine to\n  > Phoenix applications, the functions in this module have\n  > lost a bit of relevance. Whenever possible, prefer to use\n  > the HEEx template engine instead of the functions here.\n  > For example, instead of:\n  >\n  >     <%= content_tag :div, class: @class do %>\n  >       Hello\n  >     <% end %>\n  >\n  > Do:\n  >\n  >     <div class={@class}>\n  >       Hello\n  >     </div>\n  \"\"\"\n\n  import Phoenix.HTML\n\n  @csrf_param \"_csrf_token\"\n\n  @doc ~S\"\"\"\n  Creates an HTML tag with the given name and options.\n\n      iex> safe_to_string tag(:br)\n      \"<br>\"\n      iex> safe_to_string tag(:input, type: \"text\", name: \"user_id\")\n      \"<input name=\\\"user_id\\\" type=\\\"text\\\">\"\n\n  ## Data attributes\n\n  In order to add custom data attributes you need to pass\n  a tuple containing :data atom and a keyword list\n  with data attributes' names and values as the first element\n  in the tag's attributes keyword list:\n\n      iex> safe_to_string tag(:input, [data: [foo: \"bar\"], id: \"some_id\"])\n      \"<input data-foo=\\\"bar\\\" id=\\\"some_id\\\">\"\n\n  ## Boolean values\n\n  In case an attribute contains a boolean value, its key\n  is repeated when it is true, as expected in HTML, or\n  the attribute is completely removed if it is false:\n\n      iex> safe_to_string tag(:audio, autoplay: \"autoplay\")\n      \"<audio autoplay=\\\"autoplay\\\">\"\n      iex> safe_to_string tag(:audio, autoplay: true)\n      \"<audio autoplay>\"\n      iex> safe_to_string tag(:audio, autoplay: false)\n      \"<audio>\"\n\n  If you want the boolean attribute to be sent as is,\n  you can explicitly convert it to a string before.\n  \"\"\"\n  def tag(name), do: tag(name, [])\n\n  def tag(name, attrs) when is_list(attrs) do\n    {:safe, [?<, to_string(name), sorted_attrs(attrs), ?>]}\n  end\n\n  @doc ~S\"\"\"\n  Creates an HTML tag with given name, content, and attributes.\n\n  See `Phoenix.HTML.Tag.tag/2` for more information and examples.\n\n      iex> safe_to_string content_tag(:p, \"Hello\")\n      \"<p>Hello</p>\"\n\n      iex> safe_to_string content_tag(:p, \"<Hello>\", class: \"test\")\n      \"<p class=\\\"test\\\">&lt;Hello&gt;</p>\"\n\n      iex> safe_to_string(content_tag :p, class: \"test\" do\n      ...>   \"Hello\"\n      ...> end)\n      \"<p class=\\\"test\\\">Hello</p>\"\n\n      iex> safe_to_string content_tag(:option, \"Display Value\", [{:data, [foo: \"bar\"]}, value: \"value\"])\n      \"<option data-foo=\\\"bar\\\" value=\\\"value\\\">Display Value</option>\"\n\n  \"\"\"\n  def content_tag(name, do: block) do\n    content_tag(name, block, [])\n  end\n\n  def content_tag(name, content) do\n    content_tag(name, content, [])\n  end\n\n  def content_tag(name, attrs, do: block) when is_list(attrs) do\n    content_tag(name, block, attrs)\n  end\n\n  def content_tag(name, content, attrs) when is_list(attrs) do\n    name = to_string(name)\n    {:safe, escaped} = html_escape(content)\n\n    {:safe, [?<, name, sorted_attrs(attrs), ?>, escaped, ?<, ?/, name, ?>]}\n  end\n\n  @doc ~S\"\"\"\n  Escapes an enumerable of attributes, returning iodata.\n\n  Pay attention that, unlike `tag/2` and `content_tag/2`, this\n  function does not sort the attributes. However if given a map,\n  note also that the key ordering may change.\n\n      iex> safe_to_string attributes_escape(title: \"the title\", id: \"the id\", selected: true)\n      \" title=\\\"the title\\\" id=\\\"the id\\\" selected\"\n\n      iex> safe_to_string attributes_escape(%{data: [phx: [value: [foo: \"bar\"]]], class: \"foo\"})\n      \" class=\\\"foo\\\" data-phx-value-foo=\\\"bar\\\"\"\n\n  \"\"\"\n  def attributes_escape(attrs) when is_list(attrs) do\n    {:safe, build_attrs(attrs)}\n  end\n\n  def attributes_escape(attrs) do\n    {:safe, attrs |> Enum.to_list() |> build_attrs()}\n  end\n\n  defp build_attrs([{k, true} | t]),\n    do: [?\\s, key_escape(k) | build_attrs(t)]\n\n  defp build_attrs([{_, false} | t]),\n    do: build_attrs(t)\n\n  defp build_attrs([{_, nil} | t]),\n    do: build_attrs(t)\n\n  defp build_attrs([{\"data\", v} | t]) when is_list(v),\n    do: nested_attrs(v, \" data\", t)\n\n  defp build_attrs([{\"aria\", v} | t]) when is_list(v),\n    do: nested_attrs(v, \" aria\", t)\n\n  defp build_attrs([{\"class\", v} | t]) when is_list(v),\n    do: [\" class=\\\"\", class_value(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([{:data, v} | t]) when is_list(v),\n    do: nested_attrs(v, \" data\", t)\n\n  defp build_attrs([{:aria, v} | t]) when is_list(v),\n    do: nested_attrs(v, \" aria\", t)\n\n  defp build_attrs([{:class, v} | t]) when is_list(v),\n    do: [\" class=\\\"\", class_value(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([{k, v} | t]),\n    do: [?\\s, key_escape(k), ?=, ?\", attr_escape(v), ?\" | build_attrs(t)]\n\n  defp build_attrs([]), do: []\n\n  defp nested_attrs([{k, v} | kv], attr, t) when is_list(v),\n    do: [nested_attrs(v, \"#{attr}-#{key_escape(k)}\", []) | nested_attrs(kv, attr, t)]\n\n  defp nested_attrs([{k, v} | kv], attr, t),\n    do: [attr, ?-, key_escape(k), ?=, ?\", attr_escape(v), ?\" | nested_attrs(kv, attr, t)]\n\n  defp nested_attrs([], _attr, t),\n    do: build_attrs(t)\n\n  defp class_value(value) when is_list(value) do\n    value\n    |> Enum.filter(& &1)\n    |> Enum.join(\" \")\n    |> attr_escape()\n  end\n\n  defp class_value(value) do\n    attr_escape(value)\n  end\n\n  defp key_escape(value) when is_atom(value), do: String.replace(Atom.to_string(value), \"_\", \"-\")\n  defp key_escape(value), do: attr_escape(value)\n\n  defp attr_escape({:safe, data}), do: data\n  defp attr_escape(nil), do: []\n  defp attr_escape(other) when is_binary(other), do: Phoenix.HTML.Engine.encode_to_iodata!(other)\n  defp attr_escape(other), do: Phoenix.HTML.Safe.to_iodata(other)\n\n  defp sorted_attrs(attrs) when is_list(attrs),\n    do: attrs |> normalize_attrs() |> Enum.sort() |> build_attrs()\n\n  defp sorted_attrs(attrs),\n    do: attrs |> Enum.to_list() |> sorted_attrs()\n\n  defp normalize_attrs([{k, v} | tail]), do: [{k, v} | normalize_attrs(tail)]\n  defp normalize_attrs([k | tail]), do: [{k, true} | normalize_attrs(tail)]\n  defp normalize_attrs([]), do: []\n\n  @doc ~S\"\"\"\n  Generates a form tag.\n\n  This function generates the `<form>` tag without its closing part.\n  Check `form_tag/3` for generating an enclosing tag.\n\n  ## Examples\n\n      form_tag(\"/hello\")\n      <form action=\"/hello\" method=\"post\">\n\n      form_tag(\"/hello\", method: :get)\n      <form action=\"/hello\" method=\"get\">\n\n  ## Options\n\n    * `:method` - the HTTP method. If the method is not \"get\" nor \"post\",\n      an input tag with name `_method` is generated along-side the form tag.\n      Defaults to \"post\".\n\n    * `:multipart` - when true, sets enctype to \"multipart/form-data\".\n      Required when uploading files\n\n    * `:csrf_token` - for \"post\" requests, the form tag will automatically\n      include an input tag with name `_csrf_token`. When set to false, this\n      is disabled\n\n  All other options are passed to the underlying HTML tag.\n\n  ## CSRF Protection\n\n  By default, CSRF tokens are generated through `Plug.CSRFProtection`.\n  \"\"\"\n  def form_tag(action, opts \\\\ [])\n\n  def form_tag(action, do: block) do\n    form_tag(action, [], do: block)\n  end\n\n  def form_tag(action, opts) when is_list(opts) do\n    {:safe, method} = html_escape(Keyword.get(opts, :method, \"post\"))\n\n    {extra, opts} =\n      case method do\n        \"get\" ->\n          {\"\", opts}\n\n        \"post\" ->\n          {csrf, opts} = csrf_form_tag(action, opts)\n          {csrf, Keyword.put(opts, :method, \"post\")}\n\n        _ ->\n          {csrf, opts} = csrf_form_tag(action, opts)\n\n          {[~s'<input name=\"_method\" type=\"hidden\" value=\"', to_string(method), ~s'\">' | csrf],\n           Keyword.put(opts, :method, \"post\")}\n      end\n\n    opts =\n      case Keyword.pop(opts, :multipart, false) do\n        {false, opts} -> opts\n        {true, opts} -> Keyword.put(opts, :enctype, \"multipart/form-data\")\n      end\n\n    html_escape([tag(:form, [action: action] ++ opts), raw(extra)])\n  end\n\n  @doc \"\"\"\n  Generates a form tag with the given contents.\n\n  ## Examples\n\n      form_tag(\"/hello\", method: \"get\") do\n        \"Hello\"\n      end\n      <form action=\"/hello\" method=\"get\">...Hello...</form>\n\n  \"\"\"\n  def form_tag(action, options, do: block) do\n    html_escape([form_tag(action, options), block, raw(\"</form>\")])\n  end\n\n  defp csrf_form_tag(to, opts) do\n    case Keyword.pop(opts, :csrf_token, true) do\n      {csrf_token, opts} when is_binary(csrf_token) ->\n        {[~s'<input name=\"#{@csrf_param}\" type=\"hidden\" value=\"', csrf_token, ~s'\">'], opts}\n\n      {true, opts} ->\n        csrf_token = csrf_token_value(to)\n        {[~s'<input name=\"#{@csrf_param}\" type=\"hidden\" value=\"', csrf_token, ~s'\">'], opts}\n\n      {false, opts} ->\n        {[], opts}\n    end\n  end\n\n  @doc \"\"\"\n  Returns the `csrf_token` value to be used by forms, meta tags, etc.\n\n  By default, CSRF tokens are generated through `Plug.CSRFProtection`\n  which is capable of generating a separate token per host. Therefore\n  it is recommended to pass the `URI` of the destination as argument.\n  If none is given `%URI{host: nil}` is used, which implies a local\n  request is being done.\n  \"\"\"\n  def csrf_token_value(to \\\\ %URI{host: nil}) do\n    {mod, fun, args} = Application.fetch_env!(:phoenix_html, :csrf_token_reader)\n    apply(mod, fun, [to | args])\n  end\n\n  @doc \"\"\"\n  Generates a meta tag with CSRF information.\n\n  Additional options to the tag can be given.\n  \"\"\"\n  def csrf_meta_tag(opts \\\\ []) do\n    tag(:meta, [name: \"csrf-token\", content: csrf_token_value()] ++ opts)\n  end\n\n  @doc \"\"\"\n  Generates a hidden input tag with a CSRF token.\n\n  This could be used when writing a form without the use of tag\n  helpers like `form_tag/3` or `form_for/4`, while maintaining\n  CSRF protection.\n\n  The `to` argument should be the same as the form action.\n\n  ## Example\n\n      <form action=\"/login\" method=\"POST\">\n        <%= csrf_input_tag(\"/login\") %>\n\n        etc.\n      </form>\n\n  Additional options to the tag can be given.\n  \"\"\"\n  def csrf_input_tag(to, opts \\\\ []) do\n    csrf_token = csrf_token_value(to)\n    tag(:input, [type: \"hidden\", name: @csrf_param, value: csrf_token] ++ opts)\n  end\n\n  @doc \"\"\"\n  Generates an img tag with a src.\n\n  ## Examples\n\n      img_tag(user.photo_path)\n      <img src=\"/photo.png\">\n\n      img_tag(user.photo, class: \"image\")\n      <img src=\"/smile.png\" class=\"image\">\n\n  To generate a path to an image hosted in your application \"priv/static\",\n  with the `@conn` endpoint, use `static_path/2` to get a URL with\n  cache control parameters:\n\n      img_tag(Routes.static_path(@conn, \"/logo.png\"))\n      <img src=\"/logo-123456.png?vsn=d\">\n\n  For responsive images, pass a map, list or string through `:srcset`.\n\n      img_tag(\"/logo.png\", srcset: %{\"/logo.png\" => \"1x\", \"/logo-2x.png\" => \"2x\"})\n      <img src=\"/logo.png\" srcset=\"/logo.png 1x, /logo-2x.png 2x\">\n\n      img_tag(\"/logo.png\", srcset: [\"/logo.png\", {\"/logo-2x.png\", \"2x\"}])\n      <img src=\"/logo.png\" srcset=\"/logo.png, /logo-2x.png 2x\">\n\n  \"\"\"\n  def img_tag(src, opts \\\\ []) do\n    opts =\n      case Keyword.pop(opts, :srcset) do\n        {nil, opts} -> opts\n        {srcset, opts} -> [srcset: stringify_srcset(srcset)] ++ opts\n      end\n\n    tag(:img, Keyword.put_new(opts, :src, src))\n  end\n\n  defp stringify_srcset(srcset) when is_map(srcset) or is_list(srcset) do\n    Enum.map_join(srcset, \", \", fn\n      {src, descriptor} -> \"#{src} #{descriptor}\"\n      default -> default\n    end)\n  end\n\n  defp stringify_srcset(srcset) when is_binary(srcset),\n    do: srcset\nend\n", "defmodule Phoenix.HTML.TagTest do\n  use ExUnit.Case, async: true\n\n  import Phoenix.HTML\n  import Phoenix.HTML.Tag\n  doctest Phoenix.HTML.Tag\n\n  describe \"attributes_escape\" do\n    test \"key as atom\" do\n      assert attributes_escape([{:title, \"the title\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\")\n    end\n\n    test \"key as string\" do\n      assert attributes_escape([{\"title\", \"the title\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\")\n    end\n\n    test \"convert snake_case keys into kebab-case when key is atom\" do\n      assert attributes_escape([{:my_attr, \"value\"}]) |> safe_to_string() == ~s( my-attr=\"value\")\n    end\n\n    test \"keep snake_case keys when key is string\" do\n      assert attributes_escape([{\"my_attr\", \"value\"}]) |> safe_to_string() == ~s( my_attr=\"value\")\n    end\n\n    test \"multiple attributes\" do\n      assert attributes_escape([{:title, \"the title\"}, {:id, \"the id\"}]) |> safe_to_string() ==\n               ~s( title=\"the title\" id=\"the id\")\n    end\n\n    test \"handle nested data\" do\n      assert attributes_escape([{\"data\", [a: \"1\", b: \"2\"]}]) |> safe_to_string() ==\n               ~s( data-a=\"1\" data-b=\"2\")\n\n      assert attributes_escape([{\"aria\", [a: \"1\", b: \"2\"]}]) |> safe_to_string() ==\n               ~s( aria-a=\"1\" aria-b=\"2\")\n    end\n\n    test \"handle class value as string\" do\n      assert attributes_escape([{:class, \"btn\"}]) |> safe_to_string() == ~s( class=\"btn\")\n      assert attributes_escape([{:class, \"<active>\"}]) |> safe_to_string() == ~s( class=\"&lt;active&gt;\")\n    end\n\n    test \"handle class value as list\" do\n      assert attributes_escape([{:class, [\"btn\", nil, false, \"<active>\"]}]) |> safe_to_string() ==\n               ~s( class=\"btn &lt;active&gt;\")\n    end\n\n    test \"handle class value as false/nil/true\" do\n      assert attributes_escape([{:class, false}]) |> safe_to_string() == ~s()\n      assert attributes_escape([{:class, nil}]) |> safe_to_string() == ~s()\n      assert attributes_escape([{:class, true}]) |> safe_to_string() == ~s( class)\n    end\n\n    test \"handle class key as string\" do\n      assert attributes_escape([{\"class\", \"btn\"}]) |> safe_to_string() == ~s( class=\"btn\")\n    end\n\n    test \"supress attribute when value is falsy\" do\n      assert attributes_escape([{\"title\", nil}]) |> safe_to_string() == ~s()\n      assert attributes_escape([{\"title\", false}]) |> safe_to_string() == ~s()\n    end\n\n    test \"supress value when value is true\" do\n      assert attributes_escape([{\"selected\", true}]) |> safe_to_string() == ~s( selected)\n    end\n  end\n\n  test \"tag\" do\n    assert tag(:br) |> safe_to_string() == ~s(<br>)\n\n    assert tag(:input, name: ~s(\"<3\")) |> safe_to_string() == ~s(<input name=\"&quot;&lt;3&quot;\">)\n    assert tag(:input, name: raw(\"<3\")) |> safe_to_string() == ~s(<input name=\"<3\">)\n    assert tag(:input, name: [\"foo\", raw(\"b<r\")]) |> safe_to_string() == ~s(<input name=\"foob<r\">)\n    assert tag(:input, name: :hello) |> safe_to_string() == ~s(<input name=\"hello\">)\n\n    assert tag(:input, type: \"text\", name: \"user_id\") |> safe_to_string() ==\n             ~s(<input name=\"user_id\" type=\"text\">)\n\n    assert tag(:input, data: [toggle: \"dropdown\"]) |> safe_to_string() ==\n             ~s(<input data-toggle=\"dropdown\">)\n\n    assert tag(:input, my_attr: \"blah\") |> safe_to_string() == ~s(<input my-attr=\"blah\">)\n\n    assert tag(:input, [{\"my_<_attr\", \"blah\"}]) |> safe_to_string() ==\n             ~s(<input my_&lt;_attr=\"blah\">)\n\n    assert tag(:input, [{{:safe, \"my_<_attr\"}, \"blah\"}]) |> safe_to_string() ==\n             ~s(<input my_<_attr=\"blah\">)\n\n    assert tag(:input, data: [my_attr: \"blah\"]) |> safe_to_string() ==\n             ~s(<input data-my-attr=\"blah\">)\n\n    assert tag(:input, data: [toggle: [attr: \"blah\", target: \"#parent\"]]) |> safe_to_string() ==\n             ~s(<input data-toggle-attr=\"blah\" data-toggle-target=\"#parent\">)\n\n    assert tag(:audio, autoplay: \"autoplay\") |> safe_to_string() ==\n             ~s(<audio autoplay=\"autoplay\">)\n\n    assert tag(:audio, autoplay: true) |> safe_to_string() == ~s(<audio autoplay>)\n    assert tag(:audio, autoplay: false) |> safe_to_string() == ~s(<audio>)\n    assert tag(:audio, autoplay: nil) |> safe_to_string() == ~s(<audio>)\n  end\n\n  test \"content_tag\" do\n    assert content_tag(:p, \"Hello\") |> safe_to_string() == \"<p>Hello</p>\"\n\n    assert content_tag(:p, \"Hello\", class: \"dark\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">Hello</p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: \"Hello\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">Hello</p>\"\n\n    assert content_tag(:p, \"<Hello>\") |> safe_to_string() == \"<p>&lt;Hello&gt;</p>\"\n\n    assert content_tag(:p, 13) |> safe_to_string() == \"<p>13</p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: \"<Hello>\") |> safe_to_string() ==\n             \"<p class=\\\"dark\\\">&lt;Hello&gt;</p>\"\n\n    assert content_tag(:p, raw(\"<Hello>\")) |> safe_to_string() == \"<p><Hello></p>\"\n\n    assert content_tag(:p, [class: \"dark\"], do: raw(\"<Hello>\")) |> safe_to_string() ==\n             \"<p class=\\\"dark\\\"><Hello></p>\"\n\n    content =\n      content_tag :form, action: \"/users\", data: [remote: true] do\n        tag(:input, name: \"user[name]\")\n      end\n\n    assert safe_to_string(content) ==\n             ~s(<form action=\"/users\" data-remote=\"true\">) <> ~s(<input name=\"user[name]\"></form>)\n\n    assert content_tag(:p, do: \"Hello\") |> safe_to_string() == \"<p>Hello</p>\"\n\n    content =\n      content_tag :ul do\n        content_tag :li do\n          \"Hello\"\n        end\n      end\n\n    assert safe_to_string(content) == \"<ul><li>Hello</li></ul>\"\n\n    assert content_tag(:p, [\"hello\", ?\\s, \"world\"]) |> safe_to_string() == \"<p>hello world</p>\"\n\n    assert content_tag(:div, [autoplay: \"autoplay\"], do: \"\") |> safe_to_string() ==\n             ~s(<div autoplay=\"autoplay\"></div>)\n\n    assert content_tag(:div, [autoplay: true], do: \"\") |> safe_to_string() ==\n             ~s(<div autoplay></div>)\n\n    assert content_tag(:div, [autoplay: false], do: \"\") |> safe_to_string() == ~s(<div></div>)\n\n    assert content_tag(:div, [autoplay: nil], do: \"\") |> safe_to_string() == ~s(<div></div>)\n\n    assert content_tag(\"custom-tag\", \"Hi\") |> safe_to_string() == ~s(<custom-tag>Hi</custom-tag>)\n  end\n\n  test \"img_tag\" do\n    assert img_tag(\"user.png\") |> safe_to_string() == ~s(<img src=\"user.png\">)\n\n    assert img_tag(\"user.png\", class: \"big\") |> safe_to_string() ==\n             ~s(<img class=\"big\" src=\"user.png\">)\n\n    assert img_tag(\"user.png\", srcset: %{\"big.png\" => \"2x\", \"small.png\" => \"1x\"})\n           |> safe_to_string() ==\n             ~s(<img src=\"user.png\" srcset=\"big.png 2x, small.png 1x\">)\n\n    assert img_tag(\"user.png\", srcset: [{\"big.png\", \"2x\"}, \"small.png\"]) |> safe_to_string() ==\n             ~s(<img src=\"user.png\" srcset=\"big.png 2x, small.png\">)\n\n    assert img_tag(\"user.png\", srcset: \"big.png 2x, small.png\") |> safe_to_string() ==\n             ~s[<img src=\"user.png\" srcset=\"big.png 2x, small.png\">]\n  end\n\n  test \"form_tag for get\" do\n    assert safe_to_string(form_tag(\"/\", method: :get)) ==\n             ~s(<form action=\"/\" method=\"get\">)\n\n    assert safe_to_string(form_tag(\"/\", method: :get)) ==\n             ~s(<form action=\"/\" method=\"get\">)\n  end\n\n  test \"form_tag for post\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(form_tag(\"/\")) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n\n    assert safe_to_string(form_tag(\"/\", method: :post, csrf_token: false, multipart: true)) ==\n             ~s(<form action=\"/\" enctype=\"multipart/form-data\" method=\"post\">)\n  end\n\n  test \"form_tag for other method\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(form_tag(\"/\", method: :put)) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_method\" type=\"hidden\" value=\"put\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n  end\n\n  test \"form_tag with do block\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(\n             form_tag \"/\" do\n               \"<>\"\n             end\n           ) ==\n             ~s(<form action=\"/\" method=\"post\">) <>\n               ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">) <>\n               ~s(&lt;&gt;) <> ~s(</form>)\n\n    assert safe_to_string(\n             form_tag \"/\", method: :get do\n               \"<>\"\n             end\n           ) ==\n             ~s(<form action=\"/\" method=\"get\">) <>\n               ~s(&lt;&gt;) <> ~s(</form>)\n  end\n\n  test \"csrf_meta_tag\" do\n    csrf_token = Plug.CSRFProtection.get_csrf_token()\n\n    assert safe_to_string(csrf_meta_tag()) ==\n             ~s(<meta content=\"#{csrf_token}\" name=\"csrf-token\">)\n\n    assert safe_to_string(csrf_meta_tag(foo: \"bar\")) ==\n             ~s(<meta content=\"#{csrf_token}\" foo=\"bar\" name=\"csrf-token\">)\n  end\n\n  test \"csrf_input_tag\" do\n    url = \"/example\"\n    csrf_token = Plug.CSRFProtection.get_csrf_token_for(url)\n\n    assert safe_to_string(csrf_input_tag(url)) ==\n             ~s(<input name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n\n    assert safe_to_string(csrf_input_tag(url, foo: \"bar\")) ==\n             ~s(<input foo=\"bar\" name=\"_csrf_token\" type=\"hidden\" value=\"#{csrf_token}\">)\n  end\n\n  describe \"csrf_token_value\" do\n    def custom_csrf(to, extra), do: \"#{extra}:#{to}\"\n\n    test \"with default\" do\n      assert csrf_token_value(\"/\") == Plug.CSRFProtection.get_csrf_token()\n    end\n\n    @default_reader Application.fetch_env!(:phoenix_html, :csrf_token_reader)\n    test \"with configured MFA\" do\n      Application.put_env(\n        :phoenix_html,\n        :csrf_token_reader,\n        {__MODULE__, :custom_csrf, [\"extra\"]}\n      )\n\n      assert csrf_token_value(\"/foo\") == \"extra:/foo\"\n    after\n      Application.put_env(:phoenix_html, :csrf_token_reader, @default_reader)\n    end\n  end\nend\n"], "filenames": ["lib/phoenix_html/tag.ex", "test/phoenix_html/tag_test.exs"], "buggy_code_start_loc": [129, 41], "buggy_code_end_loc": [179, 47], "fixing_code_start_loc": [130, 42], "fixing_code_end_loc": [180, 54], "type": "CWE-79", "message": "tag.ex in Phoenix Phoenix.HTML (aka phoenix_html) before 3.0.4 allows XSS in HEEx class attributes.", "other": {"cve": {"id": "CVE-2021-46871", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-10T06:15:09.870", "lastModified": "2023-01-13T14:16:27.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "tag.ex in Phoenix Phoenix.HTML (aka phoenix_html) before 3.0.4 allows XSS in HEEx class attributes."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phoenixframework:phoenix_html:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.4", "matchCriteriaId": "032E0B62-E510-41E6-A4CD-24B02FC93472"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-j3gg-r6gp-95q2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/phoenixframework/phoenix_html/commit/62a0139fb716bcdce697f6221244bd81d321d620", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phoenixframework/phoenix_html/commit/62a0139fb716bcdce697f6221244bd81d321d620"}}