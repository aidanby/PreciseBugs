{"buggy_code": ["\n/* Copyright 1998, 2011, 2013 by the Massachusetts Institute of Technology.\n * Copyright (C) 2017 - 2018 by Christian Ammer\n * Copyright (C) 2019 by Andrew Selivanov\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of M.I.T. not be used in\n * advertising or publicity pertaining to distribution of the\n * software without specific, written prior permission.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n */\n\n#include \"ares_setup.h\"\n\n#ifdef HAVE_GETSERVBYNAME_R\n#  if !defined(GETSERVBYNAME_R_ARGS) || \\\n     (GETSERVBYNAME_R_ARGS < 4) || (GETSERVBYNAME_R_ARGS > 6)\n#    error \"you MUST specifiy a valid number of arguments for getservbyname_r\"\n#  endif\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n#  include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#  include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#  include <arpa/inet.h>\n#endif\n#ifdef HAVE_ARPA_NAMESER_H\n#  include <arpa/nameser.h>\n#else\n#  include \"nameser.h\"\n#endif\n#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n#  include <arpa/nameser_compat.h>\n#endif\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n#include <assert.h>\n\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#include \"ares.h\"\n#include \"bitncmp.h\"\n#include \"ares_private.h\"\n\n#ifdef WATT32\n#undef WIN32\n#endif\n#ifdef WIN32\n#  include \"ares_platform.h\"\n#endif\n\nstruct host_query\n{\n  ares_channel channel;\n  char *name;\n  unsigned short port; /* in host order */\n  ares_addrinfo_callback callback;\n  void *arg;\n  struct ares_addrinfo_hints hints;\n  int sent_family; /* this family is what was is being used */\n  int timeouts;    /* number of timeouts we saw for this request */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n  struct ares_addrinfo *ai;      /* store results between lookups */\n  int remaining;   /* number of DNS answers waiting for */\n  int next_domain; /* next search domain to try */\n};\n\nstatic const struct ares_addrinfo_hints default_hints = {\n  0,         /* ai_flags */\n  AF_UNSPEC, /* ai_family */\n  0,         /* ai_socktype */\n  0,         /* ai_protocol */\n};\n\nstatic const struct ares_addrinfo_cname empty_addrinfo_cname = {\n  INT_MAX, /* ttl */\n  NULL,    /* alias */\n  NULL,    /* name */\n  NULL,    /* next */\n};\n\nstatic const struct ares_addrinfo_node empty_addrinfo_node = {\n  0,    /* ai_ttl */\n  0,    /* ai_flags */\n  0,    /* ai_family */\n  0,    /* ai_socktype */\n  0,    /* ai_protocol */\n  0,    /* ai_addrlen */\n  NULL, /* ai_addr */\n  NULL  /* ai_next */\n};\n\nstatic const struct ares_addrinfo empty_addrinfo = {\n  NULL, /* cnames */\n  NULL  /* nodes */\n};\n\n/* forward declarations */\nstatic void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen);\nstatic int as_is_first(const struct host_query *hquery);\nstatic int next_dns_lookup(struct host_query *hquery);\n\nstruct ares_addrinfo_cname *ares__malloc_addrinfo_cname()\n{\n  struct ares_addrinfo_cname *cname = ares_malloc(sizeof(struct ares_addrinfo_cname));\n  if (!cname)\n    return NULL;\n\n  *cname = empty_addrinfo_cname;\n  return cname;\n}\n\nstruct ares_addrinfo_cname *ares__append_addrinfo_cname(struct ares_addrinfo_cname **head)\n{\n  struct ares_addrinfo_cname *tail = ares__malloc_addrinfo_cname();\n  struct ares_addrinfo_cname *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return tail;\n    }\n\n  while (last->next)\n    {\n      last = last->next;\n    }\n\n  last->next = tail;\n  return tail;\n}\n\nvoid ares__addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                               struct ares_addrinfo_cname *tail)\n{\n  struct ares_addrinfo_cname *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return;\n    }\n\n  while (last->next)\n    {\n      last = last->next;\n    }\n\n  last->next = tail;\n}\n\nstruct ares_addrinfo *ares__malloc_addrinfo()\n{\n  struct ares_addrinfo *ai = ares_malloc(sizeof(struct ares_addrinfo));\n  if (!ai)\n    return NULL;\n\n  *ai = empty_addrinfo;\n  return ai;\n}\n\nstruct ares_addrinfo_node *ares__malloc_addrinfo_node()\n{\n  struct ares_addrinfo_node *node =\n      ares_malloc(sizeof(struct ares_addrinfo_node));\n  if (!node)\n    return NULL;\n\n  *node = empty_addrinfo_node;\n  return node;\n}\n\n/* Allocate new addrinfo and append to the tail. */\nstruct ares_addrinfo_node *ares__append_addrinfo_node(struct ares_addrinfo_node **head)\n{\n  struct ares_addrinfo_node *tail = ares__malloc_addrinfo_node();\n  struct ares_addrinfo_node *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return tail;\n    }\n\n  while (last->ai_next)\n    {\n      last = last->ai_next;\n    }\n\n  last->ai_next = tail;\n  return tail;\n}\n\nvoid ares__addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                              struct ares_addrinfo_node *tail)\n{\n  struct ares_addrinfo_node *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return;\n    }\n\n  while (last->ai_next)\n    {\n      last = last->ai_next;\n    }\n\n  last->ai_next = tail;\n}\n\n/* Resolve service name into port number given in host byte order.\n * If not resolved, return 0.\n */\nstatic unsigned short lookup_service(const char *service, int flags)\n{\n  const char *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYNAME_R\n  struct servent se;\n  char tmpbuf[4096];\n#endif\n\n  if (service)\n    {\n      if (flags & ARES_NI_UDP)\n        proto = \"udp\";\n      else if (flags & ARES_NI_SCTP)\n        proto = \"sctp\";\n      else if (flags & ARES_NI_DCCP)\n        proto = \"dccp\";\n      else\n        proto = \"tcp\";\n#ifdef HAVE_GETSERVBYNAME_R\n      memset(&se, 0, sizeof(se));\n      sep = &se;\n      memset(tmpbuf, 0, sizeof(tmpbuf));\n#if GETSERVBYNAME_R_ARGS == 6\n      if (getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                          &sep) != 0)\n        sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n#elif GETSERVBYNAME_R_ARGS == 5\n      sep =\n          getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#elif GETSERVBYNAME_R_ARGS == 4\n      if (getservbyname_r(service, proto, &se, (void *)tmpbuf) != 0)\n        sep = NULL;\n#else\n      /* Lets just hope the OS uses TLS! */\n      sep = getservbyname(service, proto);\n#endif\n#else\n        /* Lets just hope the OS uses TLS! */\n#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n      sep = getservbyname(service, (char *)proto);\n#else\n      sep = getservbyname(service, proto);\n#endif\n#endif\n      return (sep ? ntohs((unsigned short)sep->s_port) : 0);\n    }\n  return 0;\n}\n\n/* If the name looks like an IP address or an error occured,\n * fake up a host entry, end the query immediately, and return true.\n * Otherwise return false.\n */\nstatic int fake_addrinfo(const char *name,\n                         unsigned short port,\n                         const struct ares_addrinfo_hints *hints,\n                         struct ares_addrinfo *ai,\n                         ares_addrinfo_callback callback,\n                         void *arg)\n{\n  struct ares_addrinfo_cname *cname;\n  struct ares_addrinfo_node *node;\n  ares_sockaddr addr;\n  size_t addrlen;\n  int result = 0;\n  int family = hints->ai_family;\n  if (family == AF_INET || family == AF_INET6 || family == AF_UNSPEC)\n    {\n      /* It only looks like an IP address if it's all numbers and dots. */\n      int numdots = 0, valid = 1;\n      const char *p;\n      for (p = name; *p; p++)\n        {\n          if (!ISDIGIT(*p) && *p != '.')\n            {\n              valid = 0;\n              break;\n            }\n          else if (*p == '.')\n            {\n              numdots++;\n            }\n        }\n\n      memset(&addr, 0, sizeof(addr));\n\n      /* if we don't have 3 dots, it is illegal\n       * (although inet_pton doesn't think so).\n       */\n      if (numdots != 3 || !valid)\n        result = 0;\n      else\n        result =\n            (ares_inet_pton(AF_INET, name, &addr.sa4.sin_addr) < 1 ? 0 : 1);\n\n      if (result)\n        {\n          family = addr.sa.sa_family = AF_INET;\n          addr.sa4.sin_port = htons(port);\n          addrlen = sizeof(addr.sa4);\n        }\n    }\n\n  if (family == AF_INET6 || family == AF_UNSPEC)\n    {\n      result =\n          (ares_inet_pton(AF_INET6, name, &addr.sa6.sin6_addr) < 1 ? 0 : 1);\n      addr.sa6.sin6_family = AF_INET6;\n      addr.sa6.sin6_port = htons(port);\n      addrlen = sizeof(addr.sa6);\n    }\n\n  if (!result)\n    return 0;\n\n  node = ares__malloc_addrinfo_node();\n  if (!node)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return 1;\n    }\n\n  ai->nodes = node;\n\n  node->ai_addr = ares_malloc(addrlen);\n  if (!node->ai_addr)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return 1;\n    }\n\n  node->ai_addrlen = (unsigned int)addrlen;\n  node->ai_family = addr.sa.sa_family;\n  if (addr.sa.sa_family == AF_INET)\n    memcpy(node->ai_addr, &addr.sa4, sizeof(addr.sa4));\n  else\n    memcpy(node->ai_addr, &addr.sa6, sizeof(addr.sa6));\n\n  if (hints->ai_flags & ARES_AI_CANONNAME)\n    {\n      cname = ares__append_addrinfo_cname(&ai->cnames);\n      if (!cname)\n        {\n          ares_freeaddrinfo(ai);\n          callback(arg, ARES_ENOMEM, 0, NULL);\n          return 1;\n        }\n\n      /* Duplicate the name, to avoid a constness violation. */\n      cname->name = ares_strdup(name);\n      if (!cname->name)\n        {\n          ares_freeaddrinfo(ai);\n          callback(arg, ARES_ENOMEM, 0, NULL);\n          return 1;\n        }\n    }\n\n  callback(arg, ARES_SUCCESS, 0, ai);\n  return 1;\n}\n\nstatic void end_hquery(struct host_query *hquery, int status)\n{\n  struct ares_addrinfo_node sentinel;\n  struct ares_addrinfo_node *next;\n  if (status == ARES_SUCCESS)\n    {\n      if (!(hquery->hints.ai_flags & ARES_AI_NOSORT))\n        {\n          sentinel.ai_next = hquery->ai->nodes;\n          ares__sortaddrinfo(hquery->channel, &sentinel);\n          hquery->ai->nodes = sentinel.ai_next;\n        }\n      next = hquery->ai->nodes;\n      /* Set port into each address (resolved separately). */\n      while (next)\n        {\n          if (next->ai_family == AF_INET)\n            {\n              (CARES_INADDR_CAST(struct sockaddr_in *, next->ai_addr))->sin_port = htons(hquery->port);\n            }\n          else\n            {\n              (CARES_INADDR_CAST(struct sockaddr_in6 *, next->ai_addr))->sin6_port = htons(hquery->port);\n            }\n          next = next->ai_next;\n        }\n    }\n  else\n    {\n      /* Clean up what we have collected by so far. */\n      ares_freeaddrinfo(hquery->ai);\n      hquery->ai = NULL;\n    }\n\n  hquery->callback(hquery->arg, status, hquery->timeouts, hquery->ai);\n  ares_free(hquery->name);\n  ares_free(hquery);\n}\n\nstatic int file_lookup(struct host_query *hquery)\n{\n  FILE *fp;\n  int error;\n  int status;\n  const char *path_hosts = NULL;\n\n  if (hquery->hints.ai_flags & ARES_AI_ENVHOSTS)\n    {\n      path_hosts = getenv(\"CARES_HOSTS\");\n    }\n\n  if (!path_hosts)\n    {\n#ifdef WIN32\n      char PATH_HOSTS[MAX_PATH];\n      win_platform platform;\n\n      PATH_HOSTS[0] = '\\0';\n\n      platform = ares__getplatform();\n\n      if (platform == WIN_NT)\n        {\n          char tmp[MAX_PATH];\n          HKEY hkeyHosts;\n\n          if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n                           &hkeyHosts) == ERROR_SUCCESS)\n            {\n              DWORD dwLength = MAX_PATH;\n              RegQueryValueExA(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n                              &dwLength);\n              ExpandEnvironmentStringsA(tmp, PATH_HOSTS, MAX_PATH);\n              RegCloseKey(hkeyHosts);\n            }\n        }\n      else if (platform == WIN_9X)\n        GetWindowsDirectoryA(PATH_HOSTS, MAX_PATH);\n      else\n        return ARES_ENOTFOUND;\n\n      strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n      path_hosts = PATH_HOSTS;\n\n#elif defined(WATT32)\n      const char *PATH_HOSTS = _w32_GetHostsFile();\n\n      if (!PATH_HOSTS)\n        return ARES_ENOTFOUND;\n#endif\n      path_hosts = PATH_HOSTS;\n    }\n\n  fp = fopen(path_hosts, \"r\");\n  if (!fp)\n    {\n      error = ERRNO;\n      switch (error)\n        {\n        case ENOENT:\n        case ESRCH:\n          return ARES_ENOTFOUND;\n        default:\n          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\", error,\n                         strerror(error)));\n          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", path_hosts));\n          return ARES_EFILE;\n        }\n    }\n  status = ares__readaddrinfo(fp, hquery->name, hquery->port, &hquery->hints, hquery->ai);\n  fclose(fp);\n  return status;\n}\n\nstatic void next_lookup(struct host_query *hquery, int status)\n{\n  switch (*hquery->remaining_lookups)\n    {\n      case 'b':\n          /* DNS lookup */\n          if (next_dns_lookup(hquery))\n            break;\n          hquery->remaining_lookups++;\n          next_lookup(hquery, status);\n          break;\n\n      case 'f':\n          /* Host file lookup */\n          if (file_lookup(hquery) == ARES_SUCCESS)\n            {\n              end_hquery(hquery, ARES_SUCCESS);\n              break;\n            }\n          hquery->remaining_lookups++;\n          next_lookup(hquery, status);\n          break;\n      default:\n          /* No lookup left */\n         end_hquery(hquery, status);\n         break;\n    }\n}\n\nstatic void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n    }\n\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          /* error in parsing result e.g. no memory */\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          /* at least one query ended with ARES_SUCCESS */\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n\n  /* at this point we keep on waiting for the next query to finish */\n}\n\nvoid ares_getaddrinfo(ares_channel channel,\n                      const char* name, const char* service,\n                      const struct ares_addrinfo_hints* hints,\n                      ares_addrinfo_callback callback, void* arg)\n{\n  struct host_query *hquery;\n  unsigned short port = 0;\n  int family;\n  struct ares_addrinfo *ai;\n\n  if (!hints)\n    {\n      hints = &default_hints;\n    }\n\n  family = hints->ai_family;\n\n  /* Right now we only know how to look up Internet addresses\n     and unspec means try both basically. */\n  if (family != AF_INET &&\n      family != AF_INET6 &&\n      family != AF_UNSPEC)\n    {\n      callback(arg, ARES_ENOTIMP, 0, NULL);\n      return;\n    }\n\n  if (ares__is_onion_domain(name))\n    {\n      callback(arg, ARES_ENOTFOUND, 0, NULL);\n      return;\n    }\n\n  if (service)\n    {\n      if (hints->ai_flags & ARES_AI_NUMERICSERV)\n        {\n          port = (unsigned short)strtoul(service, NULL, 0);\n          if (!port)\n            {\n              callback(arg, ARES_ESERVICE, 0, NULL);\n              return;\n            }\n        }\n      else\n        {\n          port = lookup_service(service, 0);\n          if (!port)\n            {\n              port = (unsigned short)strtoul(service, NULL, 0);\n              if (!port)\n                {\n                  callback(arg, ARES_ESERVICE, 0, NULL);\n                  return;\n                }\n            }\n        }\n    }\n\n  ai = ares__malloc_addrinfo();\n  if (!ai)\n    {\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  if (fake_addrinfo(name, port, hints, ai, callback, arg))\n    {\n      return;\n    }\n\n  /* Allocate and fill in the host query structure. */\n  hquery = ares_malloc(sizeof(struct host_query));\n  if (!hquery)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  hquery->name = ares_strdup(name);\n  if (!hquery->name)\n    {\n      ares_free(hquery);\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  hquery->port = port;\n  hquery->channel = channel;\n  hquery->hints = *hints;\n  hquery->sent_family = -1; /* nothing is sent yet */\n  hquery->callback = callback;\n  hquery->arg = arg;\n  hquery->remaining_lookups = channel->lookups;\n  hquery->timeouts = 0;\n  hquery->ai = ai;\n  hquery->next_domain = -1;\n  hquery->remaining = 0;\n\n  /* Start performing lookups according to channel->lookups. */\n  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n}\n\nstatic int next_dns_lookup(struct host_query *hquery)\n{\n  char *s = NULL;\n  int is_s_allocated = 0;\n  int status;\n\n  /* if next_domain == -1 and as_is_first is true, try hquery->name */\n  if (hquery->next_domain == -1)\n    {\n      if (as_is_first(hquery))\n        {\n          s = hquery->name;\n        }\n      hquery->next_domain = 0;\n    }\n\n  /* if as_is_first is false, try hquery->name at last */\n  if (!s && hquery->next_domain == hquery->channel->ndomains) {\n    if (!as_is_first(hquery))\n      {\n        s = hquery->name;\n      }\n    hquery->next_domain++;\n  }\n\n  if (!s && hquery->next_domain < hquery->channel->ndomains)\n    {\n      status = ares__cat_domain(\n          hquery->name,\n          hquery->channel->domains[hquery->next_domain++],\n          &s);\n      if (status == ARES_SUCCESS)\n        {\n          is_s_allocated = 1;\n        }\n    }\n\n  if (s)\n    {\n      switch (hquery->hints.ai_family)\n        {\n          case AF_INET:\n            hquery->remaining += 1;\n            ares_query(hquery->channel, s, C_IN, T_A, host_callback, hquery);\n            break;\n          case AF_INET6:\n            hquery->remaining += 1;\n            ares_query(hquery->channel, s, C_IN, T_AAAA, host_callback, hquery);\n            break;\n          case AF_UNSPEC:\n            hquery->remaining += 2;\n            ares_query(hquery->channel, s, C_IN, T_A, host_callback, hquery);\n            ares_query(hquery->channel, s, C_IN, T_AAAA, host_callback, hquery);\n            break;\n          default: break;\n        }\n      if (is_s_allocated)\n        {\n          ares_free(s);\n        }\n      return 1;\n    }\n  else\n    {\n      assert(!hquery->ai->nodes);\n      return 0;\n    }\n}\n\nstatic int as_is_first(const struct host_query* hquery)\n{\n  char* p;\n  int ndots = 0;\n  for (p = hquery->name; *p; p++)\n    {\n      if (*p == '.')\n        {\n          ndots++;\n        }\n    }\n  return ndots >= hquery->channel->ndots;\n}\n"], "fixing_code": ["\n/* Copyright 1998, 2011, 2013 by the Massachusetts Institute of Technology.\n * Copyright (C) 2017 - 2018 by Christian Ammer\n * Copyright (C) 2019 by Andrew Selivanov\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of M.I.T. not be used in\n * advertising or publicity pertaining to distribution of the\n * software without specific, written prior permission.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n */\n\n#include \"ares_setup.h\"\n\n#ifdef HAVE_GETSERVBYNAME_R\n#  if !defined(GETSERVBYNAME_R_ARGS) || \\\n     (GETSERVBYNAME_R_ARGS < 4) || (GETSERVBYNAME_R_ARGS > 6)\n#    error \"you MUST specifiy a valid number of arguments for getservbyname_r\"\n#  endif\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n#  include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#  include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#  include <arpa/inet.h>\n#endif\n#ifdef HAVE_ARPA_NAMESER_H\n#  include <arpa/nameser.h>\n#else\n#  include \"nameser.h\"\n#endif\n#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n#  include <arpa/nameser_compat.h>\n#endif\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n#include <assert.h>\n\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#include \"ares.h\"\n#include \"bitncmp.h\"\n#include \"ares_private.h\"\n\n#ifdef WATT32\n#undef WIN32\n#endif\n#ifdef WIN32\n#  include \"ares_platform.h\"\n#endif\n\nstruct host_query\n{\n  ares_channel channel;\n  char *name;\n  unsigned short port; /* in host order */\n  ares_addrinfo_callback callback;\n  void *arg;\n  struct ares_addrinfo_hints hints;\n  int sent_family; /* this family is what was is being used */\n  int timeouts;    /* number of timeouts we saw for this request */\n  const char *remaining_lookups; /* types of lookup we need to perform (\"fb\" by\n                                    default, file and dns respectively) */\n  struct ares_addrinfo *ai;      /* store results between lookups */\n  int remaining;   /* number of DNS answers waiting for */\n  int next_domain; /* next search domain to try */\n};\n\nstatic const struct ares_addrinfo_hints default_hints = {\n  0,         /* ai_flags */\n  AF_UNSPEC, /* ai_family */\n  0,         /* ai_socktype */\n  0,         /* ai_protocol */\n};\n\nstatic const struct ares_addrinfo_cname empty_addrinfo_cname = {\n  INT_MAX, /* ttl */\n  NULL,    /* alias */\n  NULL,    /* name */\n  NULL,    /* next */\n};\n\nstatic const struct ares_addrinfo_node empty_addrinfo_node = {\n  0,    /* ai_ttl */\n  0,    /* ai_flags */\n  0,    /* ai_family */\n  0,    /* ai_socktype */\n  0,    /* ai_protocol */\n  0,    /* ai_addrlen */\n  NULL, /* ai_addr */\n  NULL  /* ai_next */\n};\n\nstatic const struct ares_addrinfo empty_addrinfo = {\n  NULL, /* cnames */\n  NULL  /* nodes */\n};\n\n/* forward declarations */\nstatic void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen);\nstatic int as_is_first(const struct host_query *hquery);\nstatic int next_dns_lookup(struct host_query *hquery);\n\nstruct ares_addrinfo_cname *ares__malloc_addrinfo_cname()\n{\n  struct ares_addrinfo_cname *cname = ares_malloc(sizeof(struct ares_addrinfo_cname));\n  if (!cname)\n    return NULL;\n\n  *cname = empty_addrinfo_cname;\n  return cname;\n}\n\nstruct ares_addrinfo_cname *ares__append_addrinfo_cname(struct ares_addrinfo_cname **head)\n{\n  struct ares_addrinfo_cname *tail = ares__malloc_addrinfo_cname();\n  struct ares_addrinfo_cname *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return tail;\n    }\n\n  while (last->next)\n    {\n      last = last->next;\n    }\n\n  last->next = tail;\n  return tail;\n}\n\nvoid ares__addrinfo_cat_cnames(struct ares_addrinfo_cname **head,\n                               struct ares_addrinfo_cname *tail)\n{\n  struct ares_addrinfo_cname *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return;\n    }\n\n  while (last->next)\n    {\n      last = last->next;\n    }\n\n  last->next = tail;\n}\n\nstruct ares_addrinfo *ares__malloc_addrinfo()\n{\n  struct ares_addrinfo *ai = ares_malloc(sizeof(struct ares_addrinfo));\n  if (!ai)\n    return NULL;\n\n  *ai = empty_addrinfo;\n  return ai;\n}\n\nstruct ares_addrinfo_node *ares__malloc_addrinfo_node()\n{\n  struct ares_addrinfo_node *node =\n      ares_malloc(sizeof(struct ares_addrinfo_node));\n  if (!node)\n    return NULL;\n\n  *node = empty_addrinfo_node;\n  return node;\n}\n\n/* Allocate new addrinfo and append to the tail. */\nstruct ares_addrinfo_node *ares__append_addrinfo_node(struct ares_addrinfo_node **head)\n{\n  struct ares_addrinfo_node *tail = ares__malloc_addrinfo_node();\n  struct ares_addrinfo_node *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return tail;\n    }\n\n  while (last->ai_next)\n    {\n      last = last->ai_next;\n    }\n\n  last->ai_next = tail;\n  return tail;\n}\n\nvoid ares__addrinfo_cat_nodes(struct ares_addrinfo_node **head,\n                              struct ares_addrinfo_node *tail)\n{\n  struct ares_addrinfo_node *last = *head;\n  if (!last)\n    {\n      *head = tail;\n      return;\n    }\n\n  while (last->ai_next)\n    {\n      last = last->ai_next;\n    }\n\n  last->ai_next = tail;\n}\n\n/* Resolve service name into port number given in host byte order.\n * If not resolved, return 0.\n */\nstatic unsigned short lookup_service(const char *service, int flags)\n{\n  const char *proto;\n  struct servent *sep;\n#ifdef HAVE_GETSERVBYNAME_R\n  struct servent se;\n  char tmpbuf[4096];\n#endif\n\n  if (service)\n    {\n      if (flags & ARES_NI_UDP)\n        proto = \"udp\";\n      else if (flags & ARES_NI_SCTP)\n        proto = \"sctp\";\n      else if (flags & ARES_NI_DCCP)\n        proto = \"dccp\";\n      else\n        proto = \"tcp\";\n#ifdef HAVE_GETSERVBYNAME_R\n      memset(&se, 0, sizeof(se));\n      sep = &se;\n      memset(tmpbuf, 0, sizeof(tmpbuf));\n#if GETSERVBYNAME_R_ARGS == 6\n      if (getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf),\n                          &sep) != 0)\n        sep = NULL; /* LCOV_EXCL_LINE: buffer large so this never fails */\n#elif GETSERVBYNAME_R_ARGS == 5\n      sep =\n          getservbyname_r(service, proto, &se, (void *)tmpbuf, sizeof(tmpbuf));\n#elif GETSERVBYNAME_R_ARGS == 4\n      if (getservbyname_r(service, proto, &se, (void *)tmpbuf) != 0)\n        sep = NULL;\n#else\n      /* Lets just hope the OS uses TLS! */\n      sep = getservbyname(service, proto);\n#endif\n#else\n        /* Lets just hope the OS uses TLS! */\n#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n      sep = getservbyname(service, (char *)proto);\n#else\n      sep = getservbyname(service, proto);\n#endif\n#endif\n      return (sep ? ntohs((unsigned short)sep->s_port) : 0);\n    }\n  return 0;\n}\n\n/* If the name looks like an IP address or an error occured,\n * fake up a host entry, end the query immediately, and return true.\n * Otherwise return false.\n */\nstatic int fake_addrinfo(const char *name,\n                         unsigned short port,\n                         const struct ares_addrinfo_hints *hints,\n                         struct ares_addrinfo *ai,\n                         ares_addrinfo_callback callback,\n                         void *arg)\n{\n  struct ares_addrinfo_cname *cname;\n  struct ares_addrinfo_node *node;\n  ares_sockaddr addr;\n  size_t addrlen;\n  int result = 0;\n  int family = hints->ai_family;\n  if (family == AF_INET || family == AF_INET6 || family == AF_UNSPEC)\n    {\n      /* It only looks like an IP address if it's all numbers and dots. */\n      int numdots = 0, valid = 1;\n      const char *p;\n      for (p = name; *p; p++)\n        {\n          if (!ISDIGIT(*p) && *p != '.')\n            {\n              valid = 0;\n              break;\n            }\n          else if (*p == '.')\n            {\n              numdots++;\n            }\n        }\n\n      memset(&addr, 0, sizeof(addr));\n\n      /* if we don't have 3 dots, it is illegal\n       * (although inet_pton doesn't think so).\n       */\n      if (numdots != 3 || !valid)\n        result = 0;\n      else\n        result =\n            (ares_inet_pton(AF_INET, name, &addr.sa4.sin_addr) < 1 ? 0 : 1);\n\n      if (result)\n        {\n          family = addr.sa.sa_family = AF_INET;\n          addr.sa4.sin_port = htons(port);\n          addrlen = sizeof(addr.sa4);\n        }\n    }\n\n  if (family == AF_INET6 || family == AF_UNSPEC)\n    {\n      result =\n          (ares_inet_pton(AF_INET6, name, &addr.sa6.sin6_addr) < 1 ? 0 : 1);\n      addr.sa6.sin6_family = AF_INET6;\n      addr.sa6.sin6_port = htons(port);\n      addrlen = sizeof(addr.sa6);\n    }\n\n  if (!result)\n    return 0;\n\n  node = ares__malloc_addrinfo_node();\n  if (!node)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return 1;\n    }\n\n  ai->nodes = node;\n\n  node->ai_addr = ares_malloc(addrlen);\n  if (!node->ai_addr)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return 1;\n    }\n\n  node->ai_addrlen = (unsigned int)addrlen;\n  node->ai_family = addr.sa.sa_family;\n  if (addr.sa.sa_family == AF_INET)\n    memcpy(node->ai_addr, &addr.sa4, sizeof(addr.sa4));\n  else\n    memcpy(node->ai_addr, &addr.sa6, sizeof(addr.sa6));\n\n  if (hints->ai_flags & ARES_AI_CANONNAME)\n    {\n      cname = ares__append_addrinfo_cname(&ai->cnames);\n      if (!cname)\n        {\n          ares_freeaddrinfo(ai);\n          callback(arg, ARES_ENOMEM, 0, NULL);\n          return 1;\n        }\n\n      /* Duplicate the name, to avoid a constness violation. */\n      cname->name = ares_strdup(name);\n      if (!cname->name)\n        {\n          ares_freeaddrinfo(ai);\n          callback(arg, ARES_ENOMEM, 0, NULL);\n          return 1;\n        }\n    }\n\n  callback(arg, ARES_SUCCESS, 0, ai);\n  return 1;\n}\n\nstatic void end_hquery(struct host_query *hquery, int status)\n{\n  struct ares_addrinfo_node sentinel;\n  struct ares_addrinfo_node *next;\n  if (status == ARES_SUCCESS)\n    {\n      if (!(hquery->hints.ai_flags & ARES_AI_NOSORT))\n        {\n          sentinel.ai_next = hquery->ai->nodes;\n          ares__sortaddrinfo(hquery->channel, &sentinel);\n          hquery->ai->nodes = sentinel.ai_next;\n        }\n      next = hquery->ai->nodes;\n      /* Set port into each address (resolved separately). */\n      while (next)\n        {\n          if (next->ai_family == AF_INET)\n            {\n              (CARES_INADDR_CAST(struct sockaddr_in *, next->ai_addr))->sin_port = htons(hquery->port);\n            }\n          else\n            {\n              (CARES_INADDR_CAST(struct sockaddr_in6 *, next->ai_addr))->sin6_port = htons(hquery->port);\n            }\n          next = next->ai_next;\n        }\n    }\n  else\n    {\n      /* Clean up what we have collected by so far. */\n      ares_freeaddrinfo(hquery->ai);\n      hquery->ai = NULL;\n    }\n\n  hquery->callback(hquery->arg, status, hquery->timeouts, hquery->ai);\n  ares_free(hquery->name);\n  ares_free(hquery);\n}\n\nstatic int file_lookup(struct host_query *hquery)\n{\n  FILE *fp;\n  int error;\n  int status;\n  const char *path_hosts = NULL;\n\n  if (hquery->hints.ai_flags & ARES_AI_ENVHOSTS)\n    {\n      path_hosts = getenv(\"CARES_HOSTS\");\n    }\n\n  if (!path_hosts)\n    {\n#ifdef WIN32\n      char PATH_HOSTS[MAX_PATH];\n      win_platform platform;\n\n      PATH_HOSTS[0] = '\\0';\n\n      platform = ares__getplatform();\n\n      if (platform == WIN_NT)\n        {\n          char tmp[MAX_PATH];\n          HKEY hkeyHosts;\n\n          if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n                           &hkeyHosts) == ERROR_SUCCESS)\n            {\n              DWORD dwLength = MAX_PATH;\n              RegQueryValueExA(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n                              &dwLength);\n              ExpandEnvironmentStringsA(tmp, PATH_HOSTS, MAX_PATH);\n              RegCloseKey(hkeyHosts);\n            }\n        }\n      else if (platform == WIN_9X)\n        GetWindowsDirectoryA(PATH_HOSTS, MAX_PATH);\n      else\n        return ARES_ENOTFOUND;\n\n      strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n      path_hosts = PATH_HOSTS;\n\n#elif defined(WATT32)\n      const char *PATH_HOSTS = _w32_GetHostsFile();\n\n      if (!PATH_HOSTS)\n        return ARES_ENOTFOUND;\n#endif\n      path_hosts = PATH_HOSTS;\n    }\n\n  fp = fopen(path_hosts, \"r\");\n  if (!fp)\n    {\n      error = ERRNO;\n      switch (error)\n        {\n        case ENOENT:\n        case ESRCH:\n          return ARES_ENOTFOUND;\n        default:\n          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\", error,\n                         strerror(error)));\n          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", path_hosts));\n          return ARES_EFILE;\n        }\n    }\n  status = ares__readaddrinfo(fp, hquery->name, hquery->port, &hquery->hints, hquery->ai);\n  fclose(fp);\n  return status;\n}\n\nstatic void next_lookup(struct host_query *hquery, int status)\n{\n  switch (*hquery->remaining_lookups)\n    {\n      case 'b':\n          /* DNS lookup */\n          if (next_dns_lookup(hquery))\n            break;\n          hquery->remaining_lookups++;\n          next_lookup(hquery, status);\n          break;\n\n      case 'f':\n          /* Host file lookup */\n          if (file_lookup(hquery) == ARES_SUCCESS)\n            {\n              end_hquery(hquery, ARES_SUCCESS);\n              break;\n            }\n          hquery->remaining_lookups++;\n          next_lookup(hquery, status);\n          break;\n      default:\n          /* No lookup left */\n         end_hquery(hquery, status);\n         break;\n    }\n}\n\nstatic void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n      return;\n    }\n\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          /* error in parsing result e.g. no memory */\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          /* at least one query ended with ARES_SUCCESS */\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n\n  /* at this point we keep on waiting for the next query to finish */\n}\n\nvoid ares_getaddrinfo(ares_channel channel,\n                      const char* name, const char* service,\n                      const struct ares_addrinfo_hints* hints,\n                      ares_addrinfo_callback callback, void* arg)\n{\n  struct host_query *hquery;\n  unsigned short port = 0;\n  int family;\n  struct ares_addrinfo *ai;\n\n  if (!hints)\n    {\n      hints = &default_hints;\n    }\n\n  family = hints->ai_family;\n\n  /* Right now we only know how to look up Internet addresses\n     and unspec means try both basically. */\n  if (family != AF_INET &&\n      family != AF_INET6 &&\n      family != AF_UNSPEC)\n    {\n      callback(arg, ARES_ENOTIMP, 0, NULL);\n      return;\n    }\n\n  if (ares__is_onion_domain(name))\n    {\n      callback(arg, ARES_ENOTFOUND, 0, NULL);\n      return;\n    }\n\n  if (service)\n    {\n      if (hints->ai_flags & ARES_AI_NUMERICSERV)\n        {\n          port = (unsigned short)strtoul(service, NULL, 0);\n          if (!port)\n            {\n              callback(arg, ARES_ESERVICE, 0, NULL);\n              return;\n            }\n        }\n      else\n        {\n          port = lookup_service(service, 0);\n          if (!port)\n            {\n              port = (unsigned short)strtoul(service, NULL, 0);\n              if (!port)\n                {\n                  callback(arg, ARES_ESERVICE, 0, NULL);\n                  return;\n                }\n            }\n        }\n    }\n\n  ai = ares__malloc_addrinfo();\n  if (!ai)\n    {\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  if (fake_addrinfo(name, port, hints, ai, callback, arg))\n    {\n      return;\n    }\n\n  /* Allocate and fill in the host query structure. */\n  hquery = ares_malloc(sizeof(struct host_query));\n  if (!hquery)\n    {\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  hquery->name = ares_strdup(name);\n  if (!hquery->name)\n    {\n      ares_free(hquery);\n      ares_freeaddrinfo(ai);\n      callback(arg, ARES_ENOMEM, 0, NULL);\n      return;\n    }\n\n  hquery->port = port;\n  hquery->channel = channel;\n  hquery->hints = *hints;\n  hquery->sent_family = -1; /* nothing is sent yet */\n  hquery->callback = callback;\n  hquery->arg = arg;\n  hquery->remaining_lookups = channel->lookups;\n  hquery->timeouts = 0;\n  hquery->ai = ai;\n  hquery->next_domain = -1;\n  hquery->remaining = 0;\n\n  /* Start performing lookups according to channel->lookups. */\n  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n}\n\nstatic int next_dns_lookup(struct host_query *hquery)\n{\n  char *s = NULL;\n  int is_s_allocated = 0;\n  int status;\n\n  /* if next_domain == -1 and as_is_first is true, try hquery->name */\n  if (hquery->next_domain == -1)\n    {\n      if (as_is_first(hquery))\n        {\n          s = hquery->name;\n        }\n      hquery->next_domain = 0;\n    }\n\n  /* if as_is_first is false, try hquery->name at last */\n  if (!s && hquery->next_domain == hquery->channel->ndomains) {\n    if (!as_is_first(hquery))\n      {\n        s = hquery->name;\n      }\n    hquery->next_domain++;\n  }\n\n  if (!s && hquery->next_domain < hquery->channel->ndomains)\n    {\n      status = ares__cat_domain(\n          hquery->name,\n          hquery->channel->domains[hquery->next_domain++],\n          &s);\n      if (status == ARES_SUCCESS)\n        {\n          is_s_allocated = 1;\n        }\n    }\n\n  if (s)\n    {\n      switch (hquery->hints.ai_family)\n        {\n          case AF_INET:\n            hquery->remaining += 1;\n            ares_query(hquery->channel, s, C_IN, T_A, host_callback, hquery);\n            break;\n          case AF_INET6:\n            hquery->remaining += 1;\n            ares_query(hquery->channel, s, C_IN, T_AAAA, host_callback, hquery);\n            break;\n          case AF_UNSPEC:\n            hquery->remaining += 2;\n            ares_query(hquery->channel, s, C_IN, T_A, host_callback, hquery);\n            ares_query(hquery->channel, s, C_IN, T_AAAA, host_callback, hquery);\n            break;\n          default: break;\n        }\n      if (is_s_allocated)\n        {\n          ares_free(s);\n        }\n      return 1;\n    }\n  else\n    {\n      assert(!hquery->ai->nodes);\n      return 0;\n    }\n}\n\nstatic int as_is_first(const struct host_query* hquery)\n{\n  char* p;\n  int ndots = 0;\n  for (p = hquery->name; *p; p++)\n    {\n      if (*p == '.')\n        {\n          ndots++;\n        }\n    }\n  return ndots >= hquery->channel->ndots;\n}\n"], "filenames": ["ares_getaddrinfo.c"], "buggy_code_start_loc": [550], "buggy_code_end_loc": [550], "fixing_code_start_loc": [551], "fixing_code_end_loc": [552], "type": "CWE-415", "message": "A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.", "other": {"cve": {"id": "CVE-2020-14354", "sourceIdentifier": "secalert@redhat.com", "published": "2021-05-13T14:15:17.503", "lastModified": "2022-04-26T16:05:04.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability."}, {"lang": "es", "value": "Un posible uso de la memoria previamente liberada y una doble liberaci\u00f3n en c-ares lib versi\u00f3n 1.16.0, si la funci\u00f3n ares_destroy() es llamado antes de completar la funci\u00f3n ares_getaddrinfo().&#xa0;Este fallo posiblemente permite a un atacante bloquear el servicio que usa c-ares lib.&#xa0;La mayor amenaza de esta vulnerabilidad es la disponibilidad de este servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}, {"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:c-ares_project:c-ares:1.16.0:*:*:*:*:*:*:*", "matchCriteriaId": "097AC553-C44C-4A6F-AAEA-3C778958A3CF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1866838", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://c-ares.haxx.se/changelog.html", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4OOYAMJVLLCLXDTHW3V5UXNULZBBK4O6/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://packetstormsecurity.com/files/158755/GS20200804145053.txt", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e"}}