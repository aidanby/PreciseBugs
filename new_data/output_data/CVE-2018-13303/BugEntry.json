{"buggy_code": ["/*\n * AC-3 parser\n * Copyright (c) 2003 Fabrice Bellard\n * Copyright (c) 2003 Michael Niedermayer\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config.h\"\n\n#include \"libavutil/channel_layout.h\"\n#include \"parser.h\"\n#include \"ac3_parser.h\"\n#include \"ac3_parser_internal.h\"\n#include \"aac_ac3_parser.h\"\n#include \"get_bits.h\"\n\n\n#define AC3_HEADER_SIZE 7\n\n#if CONFIG_AC3_PARSER\n\nstatic const uint8_t eac3_blocks[4] = {\n    1, 2, 3, 6\n};\n\n/**\n * Table for center mix levels\n * reference: Section 5.4.2.4 cmixlev\n */\nstatic const uint8_t center_levels[4] = { 4, 5, 6, 5 };\n\n/**\n * Table for surround mix levels\n * reference: Section 5.4.2.5 surmixlev\n */\nstatic const uint8_t surround_levels[4] = { 4, 6, 7, 6 };\n\n\nint ff_ac3_parse_header(GetBitContext *gbc, AC3HeaderInfo *hdr)\n{\n    int frame_size_code;\n\n    memset(hdr, 0, sizeof(*hdr));\n\n    hdr->sync_word = get_bits(gbc, 16);\n    if(hdr->sync_word != 0x0B77)\n        return AAC_AC3_PARSE_ERROR_SYNC;\n\n    /* read ahead to bsid to distinguish between AC-3 and E-AC-3 */\n    hdr->bitstream_id = show_bits_long(gbc, 29) & 0x1F;\n    if(hdr->bitstream_id > 16)\n        return AAC_AC3_PARSE_ERROR_BSID;\n\n    hdr->num_blocks = 6;\n\n    /* set default mix levels */\n    hdr->center_mix_level   = 5;  // -4.5dB\n    hdr->surround_mix_level = 6;  // -6.0dB\n\n    /* set default dolby surround mode */\n    hdr->dolby_surround_mode = AC3_DSURMOD_NOTINDICATED;\n\n    if(hdr->bitstream_id <= 10) {\n        /* Normal AC-3 */\n        hdr->crc1 = get_bits(gbc, 16);\n        hdr->sr_code = get_bits(gbc, 2);\n        if(hdr->sr_code == 3)\n            return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;\n\n        frame_size_code = get_bits(gbc, 6);\n        if(frame_size_code > 37)\n            return AAC_AC3_PARSE_ERROR_FRAME_SIZE;\n\n        skip_bits(gbc, 5); // skip bsid, already got it\n\n        hdr->bitstream_mode = get_bits(gbc, 3);\n        hdr->channel_mode = get_bits(gbc, 3);\n\n        if(hdr->channel_mode == AC3_CHMODE_STEREO) {\n            hdr->dolby_surround_mode = get_bits(gbc, 2);\n        } else {\n            if((hdr->channel_mode & 1) && hdr->channel_mode != AC3_CHMODE_MONO)\n                hdr->  center_mix_level =   center_levels[get_bits(gbc, 2)];\n            if(hdr->channel_mode & 4)\n                hdr->surround_mix_level = surround_levels[get_bits(gbc, 2)];\n        }\n        hdr->lfe_on = get_bits1(gbc);\n\n        hdr->sr_shift = FFMAX(hdr->bitstream_id, 8) - 8;\n        hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code] >> hdr->sr_shift;\n        hdr->bit_rate = (ff_ac3_bitrate_tab[frame_size_code>>1] * 1000) >> hdr->sr_shift;\n        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n        hdr->frame_size = ff_ac3_frame_size_tab[frame_size_code][hdr->sr_code] * 2;\n        hdr->frame_type = EAC3_FRAME_TYPE_AC3_CONVERT; //EAC3_FRAME_TYPE_INDEPENDENT;\n        hdr->substreamid = 0;\n    } else {\n        /* Enhanced AC-3 */\n        hdr->crc1 = 0;\n        hdr->frame_type = get_bits(gbc, 2);\n        if(hdr->frame_type == EAC3_FRAME_TYPE_RESERVED)\n            return AAC_AC3_PARSE_ERROR_FRAME_TYPE;\n\n        hdr->substreamid = get_bits(gbc, 3);\n\n        hdr->frame_size = (get_bits(gbc, 11) + 1) << 1;\n        if(hdr->frame_size < AC3_HEADER_SIZE)\n            return AAC_AC3_PARSE_ERROR_FRAME_SIZE;\n\n        hdr->sr_code = get_bits(gbc, 2);\n        if (hdr->sr_code == 3) {\n            int sr_code2 = get_bits(gbc, 2);\n            if(sr_code2 == 3)\n                return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;\n            hdr->sample_rate = ff_ac3_sample_rate_tab[sr_code2] / 2;\n            hdr->sr_shift = 1;\n        } else {\n            hdr->num_blocks = eac3_blocks[get_bits(gbc, 2)];\n            hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code];\n            hdr->sr_shift = 0;\n        }\n\n        hdr->channel_mode = get_bits(gbc, 3);\n        hdr->lfe_on = get_bits1(gbc);\n\n        hdr->bit_rate = 8LL * hdr->frame_size * hdr->sample_rate /\n                        (hdr->num_blocks * 256);\n        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n    }\n    hdr->channel_layout = avpriv_ac3_channel_layout_tab[hdr->channel_mode];\n    if (hdr->lfe_on)\n        hdr->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n    return 0;\n}\n\n// TODO: Better way to pass AC3HeaderInfo fields to mov muxer.\nint avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}\n\nint av_ac3_parse_header(const uint8_t *buf, size_t size,\n                        uint8_t *bitstream_id, uint16_t *frame_size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo hdr;\n    int err;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, &hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    *bitstream_id = hdr.bitstream_id;\n    *frame_size   = hdr.frame_size;\n\n    return 0;\n}\n\nstatic int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    int err;\n    union {\n        uint64_t u64;\n        uint8_t  u8[8 + AV_INPUT_BUFFER_PADDING_SIZE];\n    } tmp = { av_be2ne64(state) };\n    AC3HeaderInfo hdr;\n    GetBitContext gbc;\n\n    init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54);\n    err = ff_ac3_parse_header(&gbc, &hdr);\n\n    if(err < 0)\n        return 0;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n    hdr_info->bit_rate = hdr.bit_rate;\n    hdr_info->channels = hdr.channels;\n    hdr_info->channel_layout = hdr.channel_layout;\n    hdr_info->samples = hdr.num_blocks * 256;\n    hdr_info->service_type = hdr.bitstream_mode;\n    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)\n        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n    if(hdr.bitstream_id>10)\n        hdr_info->codec_id = AV_CODEC_ID_EAC3;\n    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)\n        hdr_info->codec_id = AV_CODEC_ID_AC3;\n\n    *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);\n    *need_next_header = *new_frame_start || (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);\n    return hdr.frame_size;\n}\n\nstatic av_cold int ac3_parse_init(AVCodecParserContext *s1)\n{\n    AACAC3ParseContext *s = s1->priv_data;\n    s->header_size = AC3_HEADER_SIZE;\n    s->sync = ac3_sync;\n    return 0;\n}\n\n\nAVCodecParser ff_ac3_parser = {\n    .codec_ids      = { AV_CODEC_ID_AC3, AV_CODEC_ID_EAC3 },\n    .priv_data_size = sizeof(AACAC3ParseContext),\n    .parser_init    = ac3_parse_init,\n    .parser_parse   = ff_aac_ac3_parse,\n    .parser_close   = ff_parse_close,\n};\n\n#else\n\nint avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    return AVERROR(ENOSYS);\n}\n\nint av_ac3_parse_header(const uint8_t *buf, size_t size,\n                        uint8_t *bitstream_id, uint16_t *frame_size)\n{\n    return AVERROR(ENOSYS);\n}\n#endif\n"], "fixing_code": ["/*\n * AC-3 parser\n * Copyright (c) 2003 Fabrice Bellard\n * Copyright (c) 2003 Michael Niedermayer\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config.h\"\n\n#include \"libavutil/channel_layout.h\"\n#include \"parser.h\"\n#include \"ac3_parser.h\"\n#include \"ac3_parser_internal.h\"\n#include \"aac_ac3_parser.h\"\n#include \"get_bits.h\"\n\n\n#define AC3_HEADER_SIZE 7\n\n#if CONFIG_AC3_PARSER\n\nstatic const uint8_t eac3_blocks[4] = {\n    1, 2, 3, 6\n};\n\n/**\n * Table for center mix levels\n * reference: Section 5.4.2.4 cmixlev\n */\nstatic const uint8_t center_levels[4] = { 4, 5, 6, 5 };\n\n/**\n * Table for surround mix levels\n * reference: Section 5.4.2.5 surmixlev\n */\nstatic const uint8_t surround_levels[4] = { 4, 6, 7, 6 };\n\n\nint ff_ac3_parse_header(GetBitContext *gbc, AC3HeaderInfo *hdr)\n{\n    int frame_size_code;\n\n    memset(hdr, 0, sizeof(*hdr));\n\n    hdr->sync_word = get_bits(gbc, 16);\n    if(hdr->sync_word != 0x0B77)\n        return AAC_AC3_PARSE_ERROR_SYNC;\n\n    /* read ahead to bsid to distinguish between AC-3 and E-AC-3 */\n    hdr->bitstream_id = show_bits_long(gbc, 29) & 0x1F;\n    if(hdr->bitstream_id > 16)\n        return AAC_AC3_PARSE_ERROR_BSID;\n\n    hdr->num_blocks = 6;\n\n    /* set default mix levels */\n    hdr->center_mix_level   = 5;  // -4.5dB\n    hdr->surround_mix_level = 6;  // -6.0dB\n\n    /* set default dolby surround mode */\n    hdr->dolby_surround_mode = AC3_DSURMOD_NOTINDICATED;\n\n    if(hdr->bitstream_id <= 10) {\n        /* Normal AC-3 */\n        hdr->crc1 = get_bits(gbc, 16);\n        hdr->sr_code = get_bits(gbc, 2);\n        if(hdr->sr_code == 3)\n            return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;\n\n        frame_size_code = get_bits(gbc, 6);\n        if(frame_size_code > 37)\n            return AAC_AC3_PARSE_ERROR_FRAME_SIZE;\n\n        skip_bits(gbc, 5); // skip bsid, already got it\n\n        hdr->bitstream_mode = get_bits(gbc, 3);\n        hdr->channel_mode = get_bits(gbc, 3);\n\n        if(hdr->channel_mode == AC3_CHMODE_STEREO) {\n            hdr->dolby_surround_mode = get_bits(gbc, 2);\n        } else {\n            if((hdr->channel_mode & 1) && hdr->channel_mode != AC3_CHMODE_MONO)\n                hdr->  center_mix_level =   center_levels[get_bits(gbc, 2)];\n            if(hdr->channel_mode & 4)\n                hdr->surround_mix_level = surround_levels[get_bits(gbc, 2)];\n        }\n        hdr->lfe_on = get_bits1(gbc);\n\n        hdr->sr_shift = FFMAX(hdr->bitstream_id, 8) - 8;\n        hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code] >> hdr->sr_shift;\n        hdr->bit_rate = (ff_ac3_bitrate_tab[frame_size_code>>1] * 1000) >> hdr->sr_shift;\n        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n        hdr->frame_size = ff_ac3_frame_size_tab[frame_size_code][hdr->sr_code] * 2;\n        hdr->frame_type = EAC3_FRAME_TYPE_AC3_CONVERT; //EAC3_FRAME_TYPE_INDEPENDENT;\n        hdr->substreamid = 0;\n    } else {\n        /* Enhanced AC-3 */\n        hdr->crc1 = 0;\n        hdr->frame_type = get_bits(gbc, 2);\n        if(hdr->frame_type == EAC3_FRAME_TYPE_RESERVED)\n            return AAC_AC3_PARSE_ERROR_FRAME_TYPE;\n\n        hdr->substreamid = get_bits(gbc, 3);\n\n        hdr->frame_size = (get_bits(gbc, 11) + 1) << 1;\n        if(hdr->frame_size < AC3_HEADER_SIZE)\n            return AAC_AC3_PARSE_ERROR_FRAME_SIZE;\n\n        hdr->sr_code = get_bits(gbc, 2);\n        if (hdr->sr_code == 3) {\n            int sr_code2 = get_bits(gbc, 2);\n            if(sr_code2 == 3)\n                return AAC_AC3_PARSE_ERROR_SAMPLE_RATE;\n            hdr->sample_rate = ff_ac3_sample_rate_tab[sr_code2] / 2;\n            hdr->sr_shift = 1;\n        } else {\n            hdr->num_blocks = eac3_blocks[get_bits(gbc, 2)];\n            hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code];\n            hdr->sr_shift = 0;\n        }\n\n        hdr->channel_mode = get_bits(gbc, 3);\n        hdr->lfe_on = get_bits1(gbc);\n\n        hdr->bit_rate = 8LL * hdr->frame_size * hdr->sample_rate /\n                        (hdr->num_blocks * 256);\n        hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n    }\n    hdr->channel_layout = avpriv_ac3_channel_layout_tab[hdr->channel_mode];\n    if (hdr->lfe_on)\n        hdr->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n    return 0;\n}\n\n// TODO: Better way to pass AC3HeaderInfo fields to mov muxer.\nint avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}\n\nint av_ac3_parse_header(const uint8_t *buf, size_t size,\n                        uint8_t *bitstream_id, uint16_t *frame_size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo hdr;\n    int err;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, &hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    *bitstream_id = hdr.bitstream_id;\n    *frame_size   = hdr.frame_size;\n\n    return 0;\n}\n\nstatic int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    int err;\n    union {\n        uint64_t u64;\n        uint8_t  u8[8 + AV_INPUT_BUFFER_PADDING_SIZE];\n    } tmp = { av_be2ne64(state) };\n    AC3HeaderInfo hdr;\n    GetBitContext gbc;\n\n    init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54);\n    err = ff_ac3_parse_header(&gbc, &hdr);\n\n    if(err < 0)\n        return 0;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n    hdr_info->bit_rate = hdr.bit_rate;\n    hdr_info->channels = hdr.channels;\n    hdr_info->channel_layout = hdr.channel_layout;\n    hdr_info->samples = hdr.num_blocks * 256;\n    hdr_info->service_type = hdr.bitstream_mode;\n    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)\n        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n    if(hdr.bitstream_id>10)\n        hdr_info->codec_id = AV_CODEC_ID_EAC3;\n    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)\n        hdr_info->codec_id = AV_CODEC_ID_AC3;\n\n    *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);\n    *need_next_header = *new_frame_start || (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);\n    return hdr.frame_size;\n}\n\nstatic av_cold int ac3_parse_init(AVCodecParserContext *s1)\n{\n    AACAC3ParseContext *s = s1->priv_data;\n    s->header_size = AC3_HEADER_SIZE;\n    s->sync = ac3_sync;\n    return 0;\n}\n\n\nAVCodecParser ff_ac3_parser = {\n    .codec_ids      = { AV_CODEC_ID_AC3, AV_CODEC_ID_EAC3 },\n    .priv_data_size = sizeof(AACAC3ParseContext),\n    .parser_init    = ac3_parse_init,\n    .parser_parse   = ff_aac_ac3_parse,\n    .parser_close   = ff_parse_close,\n};\n\n#else\n\nint avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    return AVERROR(ENOSYS);\n}\n\nint av_ac3_parse_header(const uint8_t *buf, size_t size,\n                        uint8_t *bitstream_id, uint16_t *frame_size)\n{\n    return AVERROR(ENOSYS);\n}\n#endif\n"], "filenames": ["libavcodec/ac3_parser.c"], "buggy_code_start_loc": [165], "buggy_code_end_loc": [166], "fixing_code_start_loc": [165], "fixing_code_end_loc": [168], "type": "CWE-476", "message": "In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.", "other": {"cve": {"id": "CVE-2018-13303", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T17:29:00.500", "lastModified": "2018-07-18T14:34:01.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service."}, {"lang": "es", "value": "En FFmpeg 4.0.1, debido a una comprobaci\u00f3n faltante de una llamada a init_get_bits8() en la funci\u00f3n avpriv_ac3_parse_header en libavcodec/ac3_parser.c podr\u00eda desencadenar una desreferencia de puntero NULL al convertir un archivo AVI manipulado a MPEG4, lo que conduce a una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "00C5B9B9-CF97-4942-BAE9-7A60B7536056"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104675", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/00e8181bd97c834fe60751b0c511d4bb97875f78", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/00e8181bd97c834fe60751b0c511d4bb97875f78"}}