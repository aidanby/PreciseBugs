{"buggy_code": ["// Copyright (c) 2022 Target Brands, Inc. All rights reserved.\n//\n// Use of this source code is governed by the LICENSE file in this repository.\n\npackage api\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-vela/server/database\"\n\t\"github.com/go-vela/server/router/middleware/org\"\n\t\"github.com/go-vela/server/router/middleware/repo\"\n\t\"github.com/go-vela/server/router/middleware/user\"\n\t\"github.com/go-vela/server/scm\"\n\t\"github.com/go-vela/server/util\"\n\t\"github.com/go-vela/types/constants\"\n\t\"github.com/go-vela/types/library\"\n\t\"github.com/google/uuid\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// swagger:operation POST /api/v1/repos repos CreateRepo\n//\n// Create a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: body\n//   name: body\n//   description: Payload containing the repo to create\n//   required: true\n//   schema:\n//     \"$ref\": \"#/definitions/Repo\"\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '201':\n//     description: Successfully created the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n//   '400':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '403':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '409':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '503':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// CreateRepo represents the API handler to\n// create a repo in the configured backend.\n//\n//nolint:funlen,gocyclo // ignore function length and cyclomatic complexity\nfunc CreateRepo(c *gin.Context) {\n\t// capture middleware values\n\tu := user.Retrieve(c)\n\tallowlist := c.Value(\"allowlist\").([]string)\n\tdefaultBuildLimit := c.Value(\"defaultBuildLimit\").(int64)\n\tdefaultTimeout := c.Value(\"defaultTimeout\").(int64)\n\tmaxBuildLimit := c.Value(\"maxBuildLimit\").(int64)\n\n\t// capture body from API request\n\tinput := new(library.Repo)\n\n\terr := c.Bind(input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to decode JSON for new repo: %w\", err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  input.GetOrg(),\n\t\t\"repo\": input.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"creating new repo %s\", input.GetFullName())\n\n\t// get repo information from the source\n\tr, err := scm.FromContext(c).GetRepo(u, input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to retrieve repo info for %s from source: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update fields in repo object\n\tr.SetUserID(u.GetID())\n\n\t// set the active field based off the input provided\n\tif input.Active == nil {\n\t\t// default active field to true\n\t\tr.SetActive(true)\n\t} else {\n\t\tr.SetActive(input.GetActive())\n\t}\n\n\t// set the build limit field based off the input provided\n\tif input.GetBuildLimit() == 0 {\n\t\t// default build limit to value configured by server\n\t\tr.SetBuildLimit(defaultBuildLimit)\n\t} else if input.GetBuildLimit() > maxBuildLimit {\n\t\t// set build limit to value configured by server to prevent limit from exceeding max\n\t\tr.SetBuildLimit(maxBuildLimit)\n\t} else {\n\t\tr.SetBuildLimit(input.GetBuildLimit())\n\t}\n\n\t// set the timeout field based off the input provided\n\tif input.GetTimeout() == 0 && defaultTimeout == 0 {\n\t\t// default build timeout to 30m\n\t\tr.SetTimeout(constants.BuildTimeoutDefault)\n\t} else if input.GetTimeout() == 0 {\n\t\tr.SetTimeout(defaultTimeout)\n\t} else {\n\t\tr.SetTimeout(input.GetTimeout())\n\t}\n\n\t// set the visibility field based off the input provided\n\tif len(input.GetVisibility()) == 0 {\n\t\t// default visibility field to public\n\t\tr.SetVisibility(constants.VisibilityPublic)\n\t} else {\n\t\tr.SetVisibility(input.GetVisibility())\n\t}\n\n\t// set default events if no events are passed in\n\tif !input.GetAllowPull() && !input.GetAllowPush() &&\n\t\t!input.GetAllowDeploy() && !input.GetAllowTag() &&\n\t\t!input.GetAllowComment() {\n\t\t// default events to push and pull_request\n\t\tr.SetAllowPull(true)\n\t\tr.SetAllowPush(true)\n\t} else {\n\t\tr.SetAllowComment(input.GetAllowComment())\n\t\tr.SetAllowDeploy(input.GetAllowDeploy())\n\t\tr.SetAllowPull(input.GetAllowPull())\n\t\tr.SetAllowPush(input.GetAllowPush())\n\t\tr.SetAllowTag(input.GetAllowTag())\n\t}\n\n\tif len(input.GetPipelineType()) == 0 {\n\t\tr.SetPipelineType(constants.PipelineTypeYAML)\n\t} else {\n\t\t// ensure the pipeline type matches one of the expected values\n\t\tif input.GetPipelineType() != constants.PipelineTypeYAML &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeGo &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeStarlark {\n\t\t\tretErr := fmt.Errorf(\"unable to create new repo %s: invalid pipeline_type provided %s\", r.GetFullName(), input.GetPipelineType())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\t\tr.SetPipelineType(input.GetPipelineType())\n\t}\n\n\t// create unique id for the repo\n\tuid, err := uuid.NewRandom()\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to create UID for repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusServiceUnavailable, retErr)\n\n\t\treturn\n\t}\n\n\tr.SetHash(\n\t\tbase64.StdEncoding.EncodeToString(\n\t\t\t[]byte(strings.TrimSpace(uid.String())),\n\t\t),\n\t)\n\n\t// ensure repo is allowed to be activated\n\tif !checkAllowlist(r, allowlist) {\n\t\tretErr := fmt.Errorf(\"unable to activate repo: %s is not on allowlist\", r.GetFullName())\n\n\t\tutil.HandleError(c, http.StatusForbidden, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to capture the repo from the database\n\tdbRepo, err := database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\tif err == nil && dbRepo.GetActive() {\n\t\tretErr := fmt.Errorf(\"unable to activate repo: %s is already active\", r.GetFullName())\n\n\t\tutil.HandleError(c, http.StatusConflict, retErr)\n\n\t\treturn\n\t}\n\n\t// check if the repo already has a hash created\n\tif len(dbRepo.GetHash()) > 0 {\n\t\t// overwrite the new repo hash with the existing repo hash\n\t\tr.SetHash(dbRepo.GetHash())\n\t}\n\n\t// send API call to create the webhook\n\tif c.Value(\"webhookvalidation\").(bool) {\n\t\t_, err = scm.FromContext(c).Enable(u, r.GetOrg(), r.GetName(), r.GetHash())\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create webhook for %s: %w\", r.GetFullName(), err)\n\n\t\t\tswitch err.Error() {\n\t\t\tcase \"repo already enabled\":\n\t\t\t\tutil.HandleError(c, http.StatusConflict, retErr)\n\t\t\t\treturn\n\t\t\tcase \"repo not found\":\n\t\t\t\tutil.HandleError(c, http.StatusNotFound, retErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\t}\n\n\t// if the repo exists but is inactive\n\tif len(dbRepo.GetOrg()) > 0 && !dbRepo.GetActive() {\n\t\t// update the repo owner\n\t\tdbRepo.SetUserID(u.GetID())\n\t\t// update the default branch\n\t\tdbRepo.SetBranch(r.GetBranch())\n\t\t// activate the repo\n\t\tdbRepo.SetActive(true)\n\n\t\t// send API call to update the repo\n\t\terr = database.FromContext(c).UpdateRepo(dbRepo)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to set repo %s to active: %w\", dbRepo.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\t// send API call to capture the updated repo\n\t\tr, _ = database.FromContext(c).GetRepoForOrg(dbRepo.GetOrg(), dbRepo.GetName())\n\t} else {\n\t\t// send API call to create the repo\n\t\terr = database.FromContext(c).CreateRepo(r)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create new repo %s: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\t// send API call to capture the created repo\n\t\tr, _ = database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\t}\n\n\tc.JSON(http.StatusCreated, r)\n}\n\n// swagger:operation GET /api/v1/repos repos GetRepos\n//\n// Get all repos in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// security:\n//   - ApiKeyAuth: []\n// parameters:\n// - in: query\n//   name: page\n//   description: The page of results to retrieve\n//   type: integer\n//   default: 1\n// - in: query\n//   name: per_page\n//   description: How many results per page to return\n//   type: integer\n//   maximum: 100\n//   default: 10\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       type: array\n//       items:\n//         \"$ref\": \"#/definitions/Repo\"\n//     headers:\n//       X-Total-Count:\n//         description: Total number of results\n//         type: integer\n//       Link:\n//         description: see https://tools.ietf.org/html/rfc5988\n//         type: string\n//   '400':\n//     description: Unable to retrieve the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to retrieve the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// GetRepos represents the API handler to capture a list\n// of repos for a user from the configured backend.\nfunc GetRepos(c *gin.Context) {\n\t// capture middleware values\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repos for user %s\", u.GetName())\n\n\t// capture page query parameter if present\n\tpage, err := strconv.Atoi(c.DefaultQuery(\"page\", \"1\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// capture per_page query parameter if present\n\tperPage, err := strconv.Atoi(c.DefaultQuery(\"per_page\", \"10\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert per_page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// ensure per_page isn't above or below allowed values\n\tperPage = util.MaxInt(1, util.MinInt(100, perPage))\n\n\t// capture the sort_by query parameter if present\n\tsortBy := util.QueryParameter(c, \"sort_by\", \"name\")\n\n\t// capture the query parameters if present:\n\t//\n\t// * active\n\tfilters := map[string]interface{}{\n\t\t\"active\": util.QueryParameter(c, \"active\", \"true\"),\n\t}\n\n\t// send API call to capture the list of repos for the user\n\tr, t, err := database.FromContext(c).ListReposForUser(u, sortBy, filters, page, perPage)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to get repos for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// create pagination object\n\tpagination := Pagination{\n\t\tPage:    page,\n\t\tPerPage: perPage,\n\t\tTotal:   t,\n\t}\n\t// set pagination headers\n\tpagination.SetHeaderLink(c)\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation GET /api/v1/repos/{org} repos GetOrgRepos\n//\n// Get all repos for the provided org in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// security:\n//   - ApiKeyAuth: []\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: query\n//   name: active\n//   description: Filter active repos\n//   type: boolean\n//   default: true\n// - in: query\n//   name: page\n//   description: The page of results to retrieve\n//   type: integer\n//   default: 1\n// - in: query\n//   name: per_page\n//   description: How many results per page to return\n//   type: integer\n//   maximum: 100\n//   default: 10\n// - in: query\n//   name: sort_by\n//   description: How to sort the results\n//   type: string\n//   enum:\n//   - name\n//   - latest\n//   default: name\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       type: array\n//       items:\n//         \"$ref\": \"#/definitions/Repo\"\n//     headers:\n//       X-Total-Count:\n//         description: Total number of results\n//         type: integer\n//       Link:\n//         description: see https://tools.ietf.org/html/rfc5988\n//         type: string\n//   '400':\n//     description: Unable to retrieve the org\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to retrieve the org\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// GetOrgRepos represents the API handler to capture a list\n// of repos for an org from the configured backend.\nfunc GetOrgRepos(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repos for org %s\", o)\n\n\t// capture page query parameter if present\n\tpage, err := strconv.Atoi(c.DefaultQuery(\"page\", \"1\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// capture per_page query parameter if present\n\tperPage, err := strconv.Atoi(c.DefaultQuery(\"per_page\", \"10\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert per_page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// ensure per_page isn't above or below allowed values\n\tperPage = util.MaxInt(1, util.MinInt(100, perPage))\n\n\t// capture the sort_by query parameter if present\n\tsortBy := util.QueryParameter(c, \"sort_by\", \"name\")\n\n\t// capture the query parameters if present:\n\t//\n\t// * active\n\tfilters := map[string]interface{}{\n\t\t\"active\": util.QueryParameter(c, \"active\", \"true\"),\n\t}\n\n\t// See if the user is an org admin to bypass individual permission checks\n\tperm, err := scm.FromContext(c).OrgAccess(u, o)\n\tif err != nil {\n\t\tlogrus.Errorf(\"unable to get user %s access level for org %s\", u.GetName(), o)\n\t}\n\t// Only show public repos to non-admins\n\tif perm != \"admin\" {\n\t\tfilters[\"visibility\"] = constants.VisibilityPublic\n\t}\n\n\t// send API call to capture the list of repos for the org\n\tr, t, err := database.FromContext(c).ListReposForOrg(o, sortBy, filters, page, perPage)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to get repos for org %s: %w\", o, err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// create pagination object\n\tpagination := Pagination{\n\t\tPage:    page,\n\t\tPerPage: perPage,\n\t\tTotal:   t,\n\t}\n\t// set pagination headers\n\tpagination.SetHeaderLink(c)\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation GET /api/v1/repos/{org}/{repo} repos GetRepo\n//\n// Get a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n\n// GetRepo represents the API handler to\n// capture a repo from the configured backend.\nfunc GetRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repo %s\", r.GetFullName())\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation PUT /api/v1/repos/{org}/{repo} repos UpdateRepo\n//\n// Update a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// - in: body\n//   name: body\n//   description: Payload containing the repo to update\n//   required: true\n//   schema:\n//     \"$ref\": \"#/definitions/Repo\"\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully updated the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n//   '400':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '503':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// UpdateRepo represents the API handler to update\n// a repo in the configured backend.\n//\n//nolint:funlen // ignore line length\nfunc UpdateRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\tmaxBuildLimit := c.Value(\"maxBuildLimit\").(int64)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"updating repo %s\", r.GetFullName())\n\n\t// capture body from API request\n\tinput := new(library.Repo)\n\n\terr := c.Bind(input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to decode JSON for repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update repo fields if provided\n\tif len(input.GetBranch()) > 0 {\n\t\t// update branch if set\n\t\tr.SetBranch(input.GetBranch())\n\t}\n\n\t// update build limit if set\n\tif input.GetBuildLimit() > 0 {\n\t\t// allow build limit between 1 - value configured by server\n\t\tr.SetBuildLimit(\n\t\t\tint64(\n\t\t\t\tutil.MaxInt(\n\t\t\t\t\tconstants.BuildLimitMin,\n\t\t\t\t\tutil.MinInt(\n\t\t\t\t\t\tint(input.GetBuildLimit()),\n\t\t\t\t\t\tint(maxBuildLimit),\n\t\t\t\t\t), // clamp max\n\t\t\t\t), // clamp min\n\t\t\t),\n\t\t)\n\t}\n\n\tif input.GetTimeout() > 0 {\n\t\t// update build timeout if set\n\t\tr.SetTimeout(\n\t\t\tint64(\n\t\t\t\tutil.MaxInt(\n\t\t\t\t\tconstants.BuildTimeoutMin,\n\t\t\t\t\tutil.MinInt(\n\t\t\t\t\t\tint(input.GetTimeout()),\n\t\t\t\t\t\tconstants.BuildTimeoutMax,\n\t\t\t\t\t), // clamp max\n\t\t\t\t), // clamp min\n\t\t\t),\n\t\t)\n\t}\n\n\tif input.GetCounter() > 0 {\n\t\tif input.GetCounter() <= r.GetCounter() {\n\t\t\tretErr := fmt.Errorf(\"unable to set counter for repo %s: must be greater than current %d\",\n\t\t\t\tr.GetFullName(), r.GetCounter())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetCounter(input.GetCounter())\n\t}\n\n\tif len(input.GetVisibility()) > 0 {\n\t\t// update visibility if set\n\t\tr.SetVisibility(input.GetVisibility())\n\t}\n\n\tif input.Private != nil {\n\t\t// update private if set\n\t\tr.SetPrivate(input.GetPrivate())\n\t}\n\n\tif input.Active != nil {\n\t\t// update active if set\n\t\tr.SetActive(input.GetActive())\n\t}\n\n\tif input.AllowPull != nil {\n\t\t// update allow_pull if set\n\t\tr.SetAllowPull(input.GetAllowPull())\n\t}\n\n\tif input.AllowPush != nil {\n\t\t// update allow_push if set\n\t\tr.SetAllowPush(input.GetAllowPush())\n\t}\n\n\tif input.AllowDeploy != nil {\n\t\t// update allow_deploy if set\n\t\tr.SetAllowDeploy(input.GetAllowDeploy())\n\t}\n\n\tif input.AllowTag != nil {\n\t\t// update allow_tag if set\n\t\tr.SetAllowTag(input.GetAllowTag())\n\t}\n\n\tif input.AllowComment != nil {\n\t\t// update allow_comment if set\n\t\tr.SetAllowComment(input.GetAllowComment())\n\t}\n\n\t// set default events if no events are enabled\n\tif !r.GetAllowPull() && !r.GetAllowPush() &&\n\t\t!r.GetAllowDeploy() && !r.GetAllowTag() &&\n\t\t!r.GetAllowComment() {\n\t\tr.SetAllowPull(true)\n\t\tr.SetAllowPush(true)\n\t}\n\n\tif len(input.GetPipelineType()) != 0 {\n\t\t// ensure the pipeline type matches one of the expected values\n\t\tif input.GetPipelineType() != constants.PipelineTypeYAML &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeGo &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeStarlark {\n\t\t\tretErr := fmt.Errorf(\"pipeline_type of %s is invalid\", input.GetPipelineType())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetPipelineType(input.GetPipelineType())\n\t}\n\n\t// set hash for repo if no hash is already set\n\tif len(r.GetHash()) == 0 {\n\t\t// create unique id for the repo\n\t\tuid, err := uuid.NewRandom()\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create UID for repo %s: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusServiceUnavailable, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetHash(\n\t\t\tbase64.StdEncoding.EncodeToString(\n\t\t\t\t[]byte(strings.TrimSpace(uid.String())),\n\t\t\t),\n\t\t)\n\t}\n\n\t// send API call to update the repo\n\terr = database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to update repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to capture the updated repo\n\tr, _ = database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation DELETE /api/v1/repos/{org}/{repo} repos DeleteRepo\n//\n// Delete a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully deleted the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to  deleted the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '510':\n//     description: Unable to  deleted the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// DeleteRepo represents the API handler to remove\n// a repo from the configured backend.\nfunc DeleteRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"deleting repo %s\", r.GetFullName())\n\n\t// send API call to remove the webhook\n\terr := scm.FromContext(c).Disable(u, r.GetOrg(), r.GetName())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to delete webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tif err.Error() == \"Repo not found\" {\n\t\t\tutil.HandleError(c, http.StatusNotExtended, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// Mark the the repo as inactive\n\tr.SetActive(false)\n\n\terr = database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to set repo %s to inactive: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// Comment out actual delete until delete mechanism is fleshed out\n\t// err = database.FromContext(c).DeleteRepo(r.ID)\n\t// if err != nil {\n\t// \tretErr := fmt.Errorf(\"Error while deleting repo %s: %w\", r.FullName, err)\n\t// \tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\t// \treturn\n\t// }\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s deleted\", r.GetFullName()))\n}\n\n// swagger:operation PATCH /api/v1/repos/{org}/{repo}/repair repos RepairRepo\n//\n// Remove and recreate the webhook for a repo\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully repaired the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to repair the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// RepairRepo represents the API handler to remove\n// and then create a webhook for a repo.\nfunc RepairRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"repairing repo %s\", r.GetFullName())\n\n\t// send API call to remove the webhook\n\terr := scm.FromContext(c).Disable(u, r.GetOrg(), r.GetName())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to delete webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to create the webhook\n\t_, err = scm.FromContext(c).Enable(u, r.GetOrg(), r.GetName(), r.GetHash())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to create webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// if the repo was previously inactive, mark it as active\n\tif !r.GetActive() {\n\t\tr.SetActive(true)\n\n\t\t// send API call to update the repo\n\t\terr = database.FromContext(c).UpdateRepo(r)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to set repo %s to active: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s repaired\", r.GetFullName()))\n}\n\n// swagger:operation PATCH /api/v1/repos/{org}/{repo}/chown repos ChownRepo\n//\n// Change the owner of the webhook for a repo\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully changed the owner for the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to change the owner for the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// ChownRepo represents the API handler to change\n// the owner of a repo in the configured backend.\nfunc ChownRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"changing owner of repo %s to %s\", r.GetFullName(), u.GetName())\n\n\t// update repo owner\n\tr.SetUserID(u.GetID())\n\n\t// send API call to updated the repo\n\terr := database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to change owner of repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s changed owner\", r.GetFullName()))\n}\n\n// checkAllowlist is a helper function to ensure only repos in the\n// allowlist are allowed to enable repos. If the allowlist is\n// empty then any repo can be enabled.\nfunc checkAllowlist(r *library.Repo, allowlist []string) bool {\n\t// if the allowlist is not set or empty allow any repo to be enabled\n\tif len(allowlist) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, repo := range allowlist {\n\t\t// allow all repos in org\n\t\tif strings.Contains(repo, \"/*\") {\n\t\t\tif strings.HasPrefix(repo, r.GetOrg()) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\t// allow specific repo within org\n\t\tif repo == r.GetFullName() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"], "fixing_code": ["// Copyright (c) 2022 Target Brands, Inc. All rights reserved.\n//\n// Use of this source code is governed by the LICENSE file in this repository.\n\npackage api\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-vela/server/database\"\n\t\"github.com/go-vela/server/router/middleware/org\"\n\t\"github.com/go-vela/server/router/middleware/repo\"\n\t\"github.com/go-vela/server/router/middleware/user\"\n\t\"github.com/go-vela/server/scm\"\n\t\"github.com/go-vela/server/util\"\n\t\"github.com/go-vela/types/constants\"\n\t\"github.com/go-vela/types/library\"\n\t\"github.com/google/uuid\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// swagger:operation POST /api/v1/repos repos CreateRepo\n//\n// Create a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: body\n//   name: body\n//   description: Payload containing the repo to create\n//   required: true\n//   schema:\n//     \"$ref\": \"#/definitions/Repo\"\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '201':\n//     description: Successfully created the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n//   '400':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '403':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '409':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '503':\n//     description: Unable to create the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// CreateRepo represents the API handler to\n// create a repo in the configured backend.\n//\n//nolint:funlen,gocyclo // ignore function length and cyclomatic complexity\nfunc CreateRepo(c *gin.Context) {\n\t// capture middleware values\n\tu := user.Retrieve(c)\n\tallowlist := c.Value(\"allowlist\").([]string)\n\tdefaultBuildLimit := c.Value(\"defaultBuildLimit\").(int64)\n\tdefaultTimeout := c.Value(\"defaultTimeout\").(int64)\n\tmaxBuildLimit := c.Value(\"maxBuildLimit\").(int64)\n\n\t// capture body from API request\n\tinput := new(library.Repo)\n\n\terr := c.Bind(input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to decode JSON for new repo: %w\", err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  input.GetOrg(),\n\t\t\"repo\": input.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"creating new repo %s\", input.GetFullName())\n\n\t// get repo information from the source\n\tr, err := scm.FromContext(c).GetRepo(u, input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to retrieve repo info for %s from source: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update fields in repo object\n\tr.SetUserID(u.GetID())\n\n\t// set the active field based off the input provided\n\tif input.Active == nil {\n\t\t// default active field to true\n\t\tr.SetActive(true)\n\t} else {\n\t\tr.SetActive(input.GetActive())\n\t}\n\n\t// set the build limit field based off the input provided\n\tif input.GetBuildLimit() == 0 {\n\t\t// default build limit to value configured by server\n\t\tr.SetBuildLimit(defaultBuildLimit)\n\t} else if input.GetBuildLimit() > maxBuildLimit {\n\t\t// set build limit to value configured by server to prevent limit from exceeding max\n\t\tr.SetBuildLimit(maxBuildLimit)\n\t} else {\n\t\tr.SetBuildLimit(input.GetBuildLimit())\n\t}\n\n\t// set the timeout field based off the input provided\n\tif input.GetTimeout() == 0 && defaultTimeout == 0 {\n\t\t// default build timeout to 30m\n\t\tr.SetTimeout(constants.BuildTimeoutDefault)\n\t} else if input.GetTimeout() == 0 {\n\t\tr.SetTimeout(defaultTimeout)\n\t} else {\n\t\tr.SetTimeout(input.GetTimeout())\n\t}\n\n\t// set the visibility field based off the input provided\n\tif len(input.GetVisibility()) == 0 {\n\t\t// default visibility field to public\n\t\tr.SetVisibility(constants.VisibilityPublic)\n\t} else {\n\t\tr.SetVisibility(input.GetVisibility())\n\t}\n\n\t// set default events if no events are passed in\n\tif !input.GetAllowPull() && !input.GetAllowPush() &&\n\t\t!input.GetAllowDeploy() && !input.GetAllowTag() &&\n\t\t!input.GetAllowComment() {\n\t\t// default event to push\n\t\tr.SetAllowPush(true)\n\t} else {\n\t\tr.SetAllowComment(input.GetAllowComment())\n\t\tr.SetAllowDeploy(input.GetAllowDeploy())\n\t\tr.SetAllowPull(input.GetAllowPull())\n\t\tr.SetAllowPush(input.GetAllowPush())\n\t\tr.SetAllowTag(input.GetAllowTag())\n\t}\n\n\tif len(input.GetPipelineType()) == 0 {\n\t\tr.SetPipelineType(constants.PipelineTypeYAML)\n\t} else {\n\t\t// ensure the pipeline type matches one of the expected values\n\t\tif input.GetPipelineType() != constants.PipelineTypeYAML &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeGo &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeStarlark {\n\t\t\tretErr := fmt.Errorf(\"unable to create new repo %s: invalid pipeline_type provided %s\", r.GetFullName(), input.GetPipelineType())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\t\tr.SetPipelineType(input.GetPipelineType())\n\t}\n\n\t// create unique id for the repo\n\tuid, err := uuid.NewRandom()\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to create UID for repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusServiceUnavailable, retErr)\n\n\t\treturn\n\t}\n\n\tr.SetHash(\n\t\tbase64.StdEncoding.EncodeToString(\n\t\t\t[]byte(strings.TrimSpace(uid.String())),\n\t\t),\n\t)\n\n\t// ensure repo is allowed to be activated\n\tif !checkAllowlist(r, allowlist) {\n\t\tretErr := fmt.Errorf(\"unable to activate repo: %s is not on allowlist\", r.GetFullName())\n\n\t\tutil.HandleError(c, http.StatusForbidden, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to capture the repo from the database\n\tdbRepo, err := database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\tif err == nil && dbRepo.GetActive() {\n\t\tretErr := fmt.Errorf(\"unable to activate repo: %s is already active\", r.GetFullName())\n\n\t\tutil.HandleError(c, http.StatusConflict, retErr)\n\n\t\treturn\n\t}\n\n\t// check if the repo already has a hash created\n\tif len(dbRepo.GetHash()) > 0 {\n\t\t// overwrite the new repo hash with the existing repo hash\n\t\tr.SetHash(dbRepo.GetHash())\n\t}\n\n\t// send API call to create the webhook\n\tif c.Value(\"webhookvalidation\").(bool) {\n\t\t_, err = scm.FromContext(c).Enable(u, r.GetOrg(), r.GetName(), r.GetHash())\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create webhook for %s: %w\", r.GetFullName(), err)\n\n\t\t\tswitch err.Error() {\n\t\t\tcase \"repo already enabled\":\n\t\t\t\tutil.HandleError(c, http.StatusConflict, retErr)\n\t\t\t\treturn\n\t\t\tcase \"repo not found\":\n\t\t\t\tutil.HandleError(c, http.StatusNotFound, retErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\t}\n\n\t// if the repo exists but is inactive\n\tif len(dbRepo.GetOrg()) > 0 && !dbRepo.GetActive() {\n\t\t// update the repo owner\n\t\tdbRepo.SetUserID(u.GetID())\n\t\t// update the default branch\n\t\tdbRepo.SetBranch(r.GetBranch())\n\t\t// activate the repo\n\t\tdbRepo.SetActive(true)\n\n\t\t// send API call to update the repo\n\t\terr = database.FromContext(c).UpdateRepo(dbRepo)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to set repo %s to active: %w\", dbRepo.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\t// send API call to capture the updated repo\n\t\tr, _ = database.FromContext(c).GetRepoForOrg(dbRepo.GetOrg(), dbRepo.GetName())\n\t} else {\n\t\t// send API call to create the repo\n\t\terr = database.FromContext(c).CreateRepo(r)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create new repo %s: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\t// send API call to capture the created repo\n\t\tr, _ = database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\t}\n\n\tc.JSON(http.StatusCreated, r)\n}\n\n// swagger:operation GET /api/v1/repos repos GetRepos\n//\n// Get all repos in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// security:\n//   - ApiKeyAuth: []\n// parameters:\n// - in: query\n//   name: page\n//   description: The page of results to retrieve\n//   type: integer\n//   default: 1\n// - in: query\n//   name: per_page\n//   description: How many results per page to return\n//   type: integer\n//   maximum: 100\n//   default: 10\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       type: array\n//       items:\n//         \"$ref\": \"#/definitions/Repo\"\n//     headers:\n//       X-Total-Count:\n//         description: Total number of results\n//         type: integer\n//       Link:\n//         description: see https://tools.ietf.org/html/rfc5988\n//         type: string\n//   '400':\n//     description: Unable to retrieve the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to retrieve the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// GetRepos represents the API handler to capture a list\n// of repos for a user from the configured backend.\nfunc GetRepos(c *gin.Context) {\n\t// capture middleware values\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repos for user %s\", u.GetName())\n\n\t// capture page query parameter if present\n\tpage, err := strconv.Atoi(c.DefaultQuery(\"page\", \"1\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// capture per_page query parameter if present\n\tperPage, err := strconv.Atoi(c.DefaultQuery(\"per_page\", \"10\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert per_page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// ensure per_page isn't above or below allowed values\n\tperPage = util.MaxInt(1, util.MinInt(100, perPage))\n\n\t// capture the sort_by query parameter if present\n\tsortBy := util.QueryParameter(c, \"sort_by\", \"name\")\n\n\t// capture the query parameters if present:\n\t//\n\t// * active\n\tfilters := map[string]interface{}{\n\t\t\"active\": util.QueryParameter(c, \"active\", \"true\"),\n\t}\n\n\t// send API call to capture the list of repos for the user\n\tr, t, err := database.FromContext(c).ListReposForUser(u, sortBy, filters, page, perPage)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to get repos for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// create pagination object\n\tpagination := Pagination{\n\t\tPage:    page,\n\t\tPerPage: perPage,\n\t\tTotal:   t,\n\t}\n\t// set pagination headers\n\tpagination.SetHeaderLink(c)\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation GET /api/v1/repos/{org} repos GetOrgRepos\n//\n// Get all repos for the provided org in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// security:\n//   - ApiKeyAuth: []\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: query\n//   name: active\n//   description: Filter active repos\n//   type: boolean\n//   default: true\n// - in: query\n//   name: page\n//   description: The page of results to retrieve\n//   type: integer\n//   default: 1\n// - in: query\n//   name: per_page\n//   description: How many results per page to return\n//   type: integer\n//   maximum: 100\n//   default: 10\n// - in: query\n//   name: sort_by\n//   description: How to sort the results\n//   type: string\n//   enum:\n//   - name\n//   - latest\n//   default: name\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       type: array\n//       items:\n//         \"$ref\": \"#/definitions/Repo\"\n//     headers:\n//       X-Total-Count:\n//         description: Total number of results\n//         type: integer\n//       Link:\n//         description: see https://tools.ietf.org/html/rfc5988\n//         type: string\n//   '400':\n//     description: Unable to retrieve the org\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to retrieve the org\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// GetOrgRepos represents the API handler to capture a list\n// of repos for an org from the configured backend.\nfunc GetOrgRepos(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repos for org %s\", o)\n\n\t// capture page query parameter if present\n\tpage, err := strconv.Atoi(c.DefaultQuery(\"page\", \"1\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// capture per_page query parameter if present\n\tperPage, err := strconv.Atoi(c.DefaultQuery(\"per_page\", \"10\"))\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to convert per_page query parameter for user %s: %w\", u.GetName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// ensure per_page isn't above or below allowed values\n\tperPage = util.MaxInt(1, util.MinInt(100, perPage))\n\n\t// capture the sort_by query parameter if present\n\tsortBy := util.QueryParameter(c, \"sort_by\", \"name\")\n\n\t// capture the query parameters if present:\n\t//\n\t// * active\n\tfilters := map[string]interface{}{\n\t\t\"active\": util.QueryParameter(c, \"active\", \"true\"),\n\t}\n\n\t// See if the user is an org admin to bypass individual permission checks\n\tperm, err := scm.FromContext(c).OrgAccess(u, o)\n\tif err != nil {\n\t\tlogrus.Errorf(\"unable to get user %s access level for org %s\", u.GetName(), o)\n\t}\n\t// Only show public repos to non-admins\n\tif perm != \"admin\" {\n\t\tfilters[\"visibility\"] = constants.VisibilityPublic\n\t}\n\n\t// send API call to capture the list of repos for the org\n\tr, t, err := database.FromContext(c).ListReposForOrg(o, sortBy, filters, page, perPage)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to get repos for org %s: %w\", o, err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// create pagination object\n\tpagination := Pagination{\n\t\tPage:    page,\n\t\tPerPage: perPage,\n\t\tTotal:   t,\n\t}\n\t// set pagination headers\n\tpagination.SetHeaderLink(c)\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation GET /api/v1/repos/{org}/{repo} repos GetRepo\n//\n// Get a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully retrieved the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n\n// GetRepo represents the API handler to\n// capture a repo from the configured backend.\nfunc GetRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"reading repo %s\", r.GetFullName())\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation PUT /api/v1/repos/{org}/{repo} repos UpdateRepo\n//\n// Update a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// - in: body\n//   name: body\n//   description: Payload containing the repo to update\n//   required: true\n//   schema:\n//     \"$ref\": \"#/definitions/Repo\"\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully updated the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Repo\"\n//   '400':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '500':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '503':\n//     description: Unable to update the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// UpdateRepo represents the API handler to update\n// a repo in the configured backend.\n//\n//nolint:funlen // ignore line length\nfunc UpdateRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\tmaxBuildLimit := c.Value(\"maxBuildLimit\").(int64)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"updating repo %s\", r.GetFullName())\n\n\t// capture body from API request\n\tinput := new(library.Repo)\n\n\terr := c.Bind(input)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to decode JSON for repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\treturn\n\t}\n\n\t// update repo fields if provided\n\tif len(input.GetBranch()) > 0 {\n\t\t// update branch if set\n\t\tr.SetBranch(input.GetBranch())\n\t}\n\n\t// update build limit if set\n\tif input.GetBuildLimit() > 0 {\n\t\t// allow build limit between 1 - value configured by server\n\t\tr.SetBuildLimit(\n\t\t\tint64(\n\t\t\t\tutil.MaxInt(\n\t\t\t\t\tconstants.BuildLimitMin,\n\t\t\t\t\tutil.MinInt(\n\t\t\t\t\t\tint(input.GetBuildLimit()),\n\t\t\t\t\t\tint(maxBuildLimit),\n\t\t\t\t\t), // clamp max\n\t\t\t\t), // clamp min\n\t\t\t),\n\t\t)\n\t}\n\n\tif input.GetTimeout() > 0 {\n\t\t// update build timeout if set\n\t\tr.SetTimeout(\n\t\t\tint64(\n\t\t\t\tutil.MaxInt(\n\t\t\t\t\tconstants.BuildTimeoutMin,\n\t\t\t\t\tutil.MinInt(\n\t\t\t\t\t\tint(input.GetTimeout()),\n\t\t\t\t\t\tconstants.BuildTimeoutMax,\n\t\t\t\t\t), // clamp max\n\t\t\t\t), // clamp min\n\t\t\t),\n\t\t)\n\t}\n\n\tif input.GetCounter() > 0 {\n\t\tif input.GetCounter() <= r.GetCounter() {\n\t\t\tretErr := fmt.Errorf(\"unable to set counter for repo %s: must be greater than current %d\",\n\t\t\t\tr.GetFullName(), r.GetCounter())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetCounter(input.GetCounter())\n\t}\n\n\tif len(input.GetVisibility()) > 0 {\n\t\t// update visibility if set\n\t\tr.SetVisibility(input.GetVisibility())\n\t}\n\n\tif input.Private != nil {\n\t\t// update private if set\n\t\tr.SetPrivate(input.GetPrivate())\n\t}\n\n\tif input.Active != nil {\n\t\t// update active if set\n\t\tr.SetActive(input.GetActive())\n\t}\n\n\tif input.AllowPull != nil {\n\t\t// update allow_pull if set\n\t\tr.SetAllowPull(input.GetAllowPull())\n\t}\n\n\tif input.AllowPush != nil {\n\t\t// update allow_push if set\n\t\tr.SetAllowPush(input.GetAllowPush())\n\t}\n\n\tif input.AllowDeploy != nil {\n\t\t// update allow_deploy if set\n\t\tr.SetAllowDeploy(input.GetAllowDeploy())\n\t}\n\n\tif input.AllowTag != nil {\n\t\t// update allow_tag if set\n\t\tr.SetAllowTag(input.GetAllowTag())\n\t}\n\n\tif input.AllowComment != nil {\n\t\t// update allow_comment if set\n\t\tr.SetAllowComment(input.GetAllowComment())\n\t}\n\n\t// set default events if no events are enabled\n\tif !r.GetAllowPull() && !r.GetAllowPush() &&\n\t\t!r.GetAllowDeploy() && !r.GetAllowTag() &&\n\t\t!r.GetAllowComment() {\n\t\tr.SetAllowPull(true)\n\t\tr.SetAllowPush(true)\n\t}\n\n\tif len(input.GetPipelineType()) != 0 {\n\t\t// ensure the pipeline type matches one of the expected values\n\t\tif input.GetPipelineType() != constants.PipelineTypeYAML &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeGo &&\n\t\t\tinput.GetPipelineType() != constants.PipelineTypeStarlark {\n\t\t\tretErr := fmt.Errorf(\"pipeline_type of %s is invalid\", input.GetPipelineType())\n\n\t\t\tutil.HandleError(c, http.StatusBadRequest, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetPipelineType(input.GetPipelineType())\n\t}\n\n\t// set hash for repo if no hash is already set\n\tif len(r.GetHash()) == 0 {\n\t\t// create unique id for the repo\n\t\tuid, err := uuid.NewRandom()\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to create UID for repo %s: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusServiceUnavailable, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tr.SetHash(\n\t\t\tbase64.StdEncoding.EncodeToString(\n\t\t\t\t[]byte(strings.TrimSpace(uid.String())),\n\t\t\t),\n\t\t)\n\t}\n\n\t// send API call to update the repo\n\terr = database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to update repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to capture the updated repo\n\tr, _ = database.FromContext(c).GetRepoForOrg(r.GetOrg(), r.GetName())\n\n\tc.JSON(http.StatusOK, r)\n}\n\n// swagger:operation DELETE /api/v1/repos/{org}/{repo} repos DeleteRepo\n//\n// Delete a repo in the configured backend\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully deleted the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to  deleted the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n//   '510':\n//     description: Unable to  deleted the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// DeleteRepo represents the API handler to remove\n// a repo from the configured backend.\nfunc DeleteRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"deleting repo %s\", r.GetFullName())\n\n\t// send API call to remove the webhook\n\terr := scm.FromContext(c).Disable(u, r.GetOrg(), r.GetName())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to delete webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tif err.Error() == \"Repo not found\" {\n\t\t\tutil.HandleError(c, http.StatusNotExtended, retErr)\n\n\t\t\treturn\n\t\t}\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// Mark the the repo as inactive\n\tr.SetActive(false)\n\n\terr = database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to set repo %s to inactive: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// Comment out actual delete until delete mechanism is fleshed out\n\t// err = database.FromContext(c).DeleteRepo(r.ID)\n\t// if err != nil {\n\t// \tretErr := fmt.Errorf(\"Error while deleting repo %s: %w\", r.FullName, err)\n\t// \tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\t// \treturn\n\t// }\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s deleted\", r.GetFullName()))\n}\n\n// swagger:operation PATCH /api/v1/repos/{org}/{repo}/repair repos RepairRepo\n//\n// Remove and recreate the webhook for a repo\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully repaired the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to repair the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// RepairRepo represents the API handler to remove\n// and then create a webhook for a repo.\nfunc RepairRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"repairing repo %s\", r.GetFullName())\n\n\t// send API call to remove the webhook\n\terr := scm.FromContext(c).Disable(u, r.GetOrg(), r.GetName())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to delete webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// send API call to create the webhook\n\t_, err = scm.FromContext(c).Enable(u, r.GetOrg(), r.GetName(), r.GetHash())\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to create webhook for %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\t// if the repo was previously inactive, mark it as active\n\tif !r.GetActive() {\n\t\tr.SetActive(true)\n\n\t\t// send API call to update the repo\n\t\terr = database.FromContext(c).UpdateRepo(r)\n\t\tif err != nil {\n\t\t\tretErr := fmt.Errorf(\"unable to set repo %s to active: %w\", r.GetFullName(), err)\n\n\t\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s repaired\", r.GetFullName()))\n}\n\n// swagger:operation PATCH /api/v1/repos/{org}/{repo}/chown repos ChownRepo\n//\n// Change the owner of the webhook for a repo\n//\n// ---\n// produces:\n// - application/json\n// parameters:\n// - in: path\n//   name: org\n//   description: Name of the org\n//   required: true\n//   type: string\n// - in: path\n//   name: repo\n//   description: Name of the repo\n//   required: true\n//   type: string\n// security:\n//   - ApiKeyAuth: []\n// responses:\n//   '200':\n//     description: Successfully changed the owner for the repo\n//     schema:\n//       type: string\n//   '500':\n//     description: Unable to change the owner for the repo\n//     schema:\n//       \"$ref\": \"#/definitions/Error\"\n\n// ChownRepo represents the API handler to change\n// the owner of a repo in the configured backend.\nfunc ChownRepo(c *gin.Context) {\n\t// capture middleware values\n\to := org.Retrieve(c)\n\tr := repo.Retrieve(c)\n\tu := user.Retrieve(c)\n\n\t// update engine logger with API metadata\n\t//\n\t// https://pkg.go.dev/github.com/sirupsen/logrus?tab=doc#Entry.WithFields\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"org\":  o,\n\t\t\"repo\": r.GetName(),\n\t\t\"user\": u.GetName(),\n\t}).Infof(\"changing owner of repo %s to %s\", r.GetFullName(), u.GetName())\n\n\t// update repo owner\n\tr.SetUserID(u.GetID())\n\n\t// send API call to updated the repo\n\terr := database.FromContext(c).UpdateRepo(r)\n\tif err != nil {\n\t\tretErr := fmt.Errorf(\"unable to change owner of repo %s: %w\", r.GetFullName(), err)\n\n\t\tutil.HandleError(c, http.StatusInternalServerError, retErr)\n\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, fmt.Sprintf(\"repo %s changed owner\", r.GetFullName()))\n}\n\n// checkAllowlist is a helper function to ensure only repos in the\n// allowlist are allowed to enable repos.\n//\n// a single entry of '*' allows any repo to be enabled.\nfunc checkAllowlist(r *library.Repo, allowlist []string) bool {\n\t// check if all repos are allowed to be enabled\n\tif len(allowlist) == 1 && allowlist[0] == \"*\" {\n\t\treturn true\n\t}\n\n\tfor _, repo := range allowlist {\n\t\t// allow all repos in org\n\t\tif strings.Contains(repo, \"/*\") {\n\t\t\tif strings.HasPrefix(repo, r.GetOrg()) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\t// allow specific repo within org\n\t\tif repo == r.GetFullName() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"], "filenames": ["api/repo.go"], "buggy_code_start_loc": [156], "buggy_code_end_loc": [1052], "fixing_code_start_loc": [156], "fixing_code_end_loc": [1052], "type": "CWE-269", "message": "Vela is a Pipeline Automation (CI/CD) framework built on Linux container technology written in Golang. In Vela Server and Vela Worker prior to version 0.16.0 and Vela UI prior to version 0.17.0, some default configurations for Vela allow exploitation and container breakouts. Users should upgrade to Server 0.16.0, Worker 0.16.0, and UI 0.17.0 to fix the issue. After upgrading, Vela administrators will need to explicitly change the default settings to configure Vela as desired. Some of the fixes will interrupt existing workflows and will require Vela administrators to modify default settings. However, not applying the patch (or workarounds) will continue existing risk exposure. Some workarounds are available. Vela administrators can adjust the worker's `VELA_RUNTIME_PRIVILEGED_IMAGES` setting to be explicitly empty, leverage the `VELA_REPO_ALLOWLIST` setting on the server component to restrict access to a list of repositories that are allowed to be enabled, and/or audit enabled repositories and disable pull_requests if they are not needed.", "other": {"cve": {"id": "CVE-2022-39395", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-10T18:15:10.690", "lastModified": "2022-11-17T16:45:25.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vela is a Pipeline Automation (CI/CD) framework built on Linux container technology written in Golang. In Vela Server and Vela Worker prior to version 0.16.0 and Vela UI prior to version 0.17.0, some default configurations for Vela allow exploitation and container breakouts. Users should upgrade to Server 0.16.0, Worker 0.16.0, and UI 0.17.0 to fix the issue. After upgrading, Vela administrators will need to explicitly change the default settings to configure Vela as desired. Some of the fixes will interrupt existing workflows and will require Vela administrators to modify default settings. However, not applying the patch (or workarounds) will continue existing risk exposure. Some workarounds are available. Vela administrators can adjust the worker's `VELA_RUNTIME_PRIVILEGED_IMAGES` setting to be explicitly empty, leverage the `VELA_REPO_ALLOWLIST` setting on the server component to restrict access to a list of repositories that are allowed to be enabled, and/or audit enabled repositories and disable pull_requests if they are not needed."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-vela:server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.16.0", "matchCriteriaId": "92189644-4057-41AB-BF5A-BFA398413096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:go-vela:ui:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.17.0", "matchCriteriaId": "EF033D57-F835-4EB7-9AA7-6D7B2F1E64BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:go-vela:worker:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.16.0", "matchCriteriaId": "16935176-86CA-42A1-826F-8881FC07AB8A"}]}]}], "references": [{"url": "https://docs.docker.com/engine/security/#docker-daemon-attack-surface", "source": "security-advisories@github.com", "tags": ["Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/go-vela/server/commit/05558ee99d70f7d6f83bed7c8f78ac0b35fa26f4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/go-vela/server/releases/tag/v0.16.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/go-vela/server/security/advisories/GHSA-5m7g-pj8w-7593", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/go-vela/ui/releases/tag/v0.17.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/go-vela/ui/security/advisories/GHSA-xf39-98m2-889v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/go-vela/worker/releases/tag/v0.16.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/go-vela/worker/security/advisories/GHSA-2w78-ffv6-p46w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://go-vela.github.io/docs/installation/server/reference/#vela_repo_allowlist", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://go-vela.github.io/docs/installation/worker/reference/#vela_runtime_privileged_images", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/go-vela/server/commit/05558ee99d70f7d6f83bed7c8f78ac0b35fa26f4"}}