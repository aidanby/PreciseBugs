{"buggy_code": ["1.18.0 (Pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* grpc_stats: the default value for :ref:`stats_for_all_methods <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.stats_for_all_methods>` is switched from true to false, in order to avoid possible memory exhaustion due to an untrusted downstream sending a large number of unique method names. The previous default value was deprecated in version 1.14.0. This only changes the behavior when the value is not set. The previous behavior can be used by setting the value to true. This behavior change by be overridden by setting runtime feature `envoy.deprecated_features.grpc_stats_filter_enable_stats_for_all_methods_by_default`.\n* http: resolving inconsistencies between :scheme and X-Forwarded-Proto. :scheme will now be set for all HTTP/1.1 requests. This changes the behavior of the gRPC access logger, Wasm filters, CSRF filter and oath2 filter for HTTP/1 traffic, where :scheme was previously not set. This change also validates that for front-line Envoys (Envoys configured with  :ref:`xff_num_trusted_hops <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>` set to 0 and :ref:`use_remote_address <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>` set to true) that HTTP/1.1 https schemed requests can not be sent over non-TLS connections. All behavioral changes listed here can be temporarily reverted by setting `envoy.reloadable_features.add_and_validate_scheme_header` to false.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* hds: support custom health check port via :ref:`health_check_config <envoy_v3_api_msg_config.endpoint.v3.endpoint.healthcheckconfig>`.\n* healthcheck: the :ref:`health check filter <config_http_filters_health_check>` now sends the\n  :ref:`x-envoy-immediate-health-check-fail <config_http_filters_router_x-envoy-immediate-health-check-fail>` header\n  for all responses when Envoy is in the health check failed state. Additionally, receiving the\n  :ref:`x-envoy-immediate-health-check-fail <config_http_filters_router_x-envoy-immediate-health-check-fail>`\n  header (either in response to normal traffic or in response to an HTTP :ref:`active health check <arch_overview_health_checking>`) will\n  cause Envoy to immediately :ref:`exclude <arch_overview_load_balancing_excluded>` the host from\n  load balancing calculations. This has the useful property that such hosts, which are being\n  explicitly told to disable traffic, will not be counted for panic routing calculations. See the\n  excluded documentation for more information. This behavior can be temporarily reverted by setting\n  the `envoy.reloadable_features.health_check.immediate_failure_exclude_from_cluster` feature flag\n  to false. Note that the runtime flag covers *both* the health check filter responding with\n  `x-envoy-immediate-health-check-fail` in all cases (versus just non-HC requests) as well as\n  whether receiving `x-envoy-immediate-health-check-fail` will cause exclusion or not. Thus,\n  depending on the Envoy deployment, the feature flag may need to be flipped on both downstream\n  and upstream instances, depending on the reason.\n* http: allow to use path canonicalizer from `googleurl <https://quiche.googlesource.com/googleurl>`_\n  instead of `//source/common/chromium_url`. The new path canonicalizer is enabled by default. To\n  revert to the legacy path canonicalizer, enable the runtime flag\n  `envoy.reloadable_features.remove_forked_chromium_url`.\n* http: increase the maximum allowed number of initial connection WINDOW_UPDATE frames sent by the peer from 1 to 5.\n* http: upstream flood and abuse checks increment the count of opened HTTP/2 streams when Envoy sends\n  initial HEADERS frame for the new stream. Before the counter was incrementred when Envoy received\n  response HEADERS frame with the END_HEADERS flag set from upstream server.\n* oauth filter: added the optional parameter :ref:`auth_scopes <envoy_v3_api_field_extensions.filters.http.oauth2.v3alpha.OAuth2Config.auth_scopes>` with default value of 'user' if not provided. Enables this value to be overridden in the Authorization request to the OAuth provider.\n* perf: allow reading more bytes per operation from raw sockets to improve performance.\n* router: extended custom date formatting to DOWNSTREAM_PEER_CERT_V_START and DOWNSTREAM_PEER_CERT_V_END when using :ref:`custom request/response header formats <config_http_conn_man_headers_custom_request_headers>`.\n* upstream: host weight changes now cause a full load balancer rebuild as opposed to happening\n  atomically inline. This change has been made to support load balancer pre-computation of data\n  structures based on host weight, but may have performance implications if host weight changes\n  are very frequent. This change can be disabled by setting the `envoy.reloadable_features.upstream_host_weight_change_causes_rebuild`\n  feature flag to false. If setting this flag to false is required in a deployment please open an\n  issue against the project.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* active http health checks: properly handles HTTP/2 GOAWAY frames from the upstream. Previously a GOAWAY frame due to a graceful listener drain could cause improper failed health checks due to streams being refused by the upstream on a connection that is going away. To revert to old GOAWAY handling behavior, set the runtime feature `envoy.reloadable_features.health_check.graceful_goaway_handling` to false.\n* buffer: tighten network connection read and write buffer high watermarks in preparation to more careful enforcement of read limits. Buffer high-watermark is now set to the exact configured value; previously it was set to value + 1.\n* fault injection: stop counting as active fault after delay elapsed. Previously fault injection filter continues to count the injected delay as an active fault even after it has elapsed. This produces incorrect output statistics and impacts the max number of consecutive faults allowed (e.g., for long-lived streams). This change decreases the active fault count when the delay fault is the only active and has gone finished.\n* filter_chain: fix filter chain matching with the server name as the case-insensitive way.\n* grpc-web: fix local reply and non-proto-encoded gRPC response handling for small response bodies. This fix can be temporarily reverted by setting `envoy.reloadable_features.grpc_web_fix_non_proto_encoded_response_handling` to false.\n* grpc_http_bridge: the downstream HTTP status is now correctly set for trailers-only responses from the upstream.\n* http: disallowing \"host:\" in request_headers_to_add for behavioral consistency with rejecting :authority header. This behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_host_like_authority` to false.\n* http: reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection failures. The change back to the original behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure` to false.\n* listener: prevent crashing when an unknown listener config proto is received and debug logging is enabled.\n* overload: fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.\n* sni: as the server name in sni should be case-insensitive, envoy will convert the server name as lower case first before any other process inside envoy.\n* tls: fix the subject alternative name of the presented certificate matches the specified matchers as the case-insensitive way when it uses DNS name.\n* upstream: fix handling of moving endpoints between priorities when active health checks are enabled. Previously moving to a higher numbered priority was a NOOP, and moving to a lower numbered priority caused an abort.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_logs: removed legacy unbounded access logs and runtime guard `envoy.reloadable_features.disallow_unbounded_access_logs`.\n* dns: removed legacy buggy wildcard matching path and runtime guard `envoy.reloadable_features.fix_wildcard_matching`.\n* dynamic_forward_proxy: removed `envoy.reloadable_features.enable_dns_cache_circuit_breakers` and legacy code path.\n* http: removed legacy connection close behavior and runtime guard `envoy.reloadable_features.fixed_connection_close`.\n* http: removed legacy HTTP/1.1 error reporting path and runtime guard `envoy.reloadable_features.early_errors_via_hcm`.\n* http: removed legacy sanitization path for upgrade response headers and runtime guard `envoy.reloadable_features.fix_upgrade_response`.\n* http: removed legacy date header overwriting logic and runtime guard `envoy.reloadable_features.preserve_upstream_date deprecation`.\n* listener: removed legacy runtime guard `envoy.reloadable_features.listener_in_place_filterchain_update`.\n* router: removed `envoy.reloadable_features.consume_all_retry_headers` and legacy code path.\n\nNew Features\n------------\n\n* access log: added the :ref:`formatters <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.formatters>` extension point for custom formatters (command operators).\n* access log: support command operator: %FILTER_CHAIN_NAME% for the downstream tcp and http request.\n* access log: support command operator: %REQUEST_HEADERS_BYTES%, %RESPONSE_HEADERS_BYTES%, and %RESPONSE_TRAILERS_BYTES%.\n* compression: add brotli :ref:`compressor <envoy_v3_api_msg_extensions.compression.brotli.compressor.v3.Brotli>` and :ref:`decompressor <envoy_v3_api_msg_extensions.compression.brotli.decompressor.v3.Brotli>`.\n* config: add `envoy.features.fail_on_any_deprecated_feature` runtime key, which matches the behaviour of compile-time flag `ENVOY_DISABLE_DEPRECATED_FEATURES`, i.e. use of deprecated fields will cause a crash.\n* config: the ``Node`` :ref:`dynamic context parameters <envoy_v3_api_field_config.core.v3.Node.dynamic_parameters>` are populated in discovery requests when set on the server instance.\n* dispatcher: supports a stack of `Envoy::ScopeTrackedObject` instead of a single tracked object. This will allow Envoy to dump more debug information on crash.\n* ext_authz: added :ref:`response_headers_to_add <envoy_v3_api_field_service.auth.v3.OkHttpResponse.response_headers_to_add>` to support sending response headers to downstream clients on OK authorization checks via gRPC.\n* ext_authz: added :ref:`allowed_client_headers_on_success <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>` to support sending response headers to downstream clients on OK external authorization checks via HTTP.\n* grpc_json_transcoder: added :ref:`request_validation_options <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.request_validation_options>` to reject invalid requests early.\n* grpc_json_transcoder: filter can now be configured on per-route/per-vhost level as well. Leaving empty list of services in the filter configuration disables transcoding on the specific route.\n* http: added support for `Envoy::ScopeTrackedObject` for HTTP/1 and HTTP/2 dispatching. Crashes while inside the dispatching loop should dump debug information.\n* http: added an option to not add content-length: 0 for requests which should not have bodies. This behavior can be enabled by setting `envoy.reloadable_features.dont_add_content_length_for_bodiless_requests` true.\n* http: added support for :ref:`preconnecting <envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy>`. Preconnecting is off by default, but recommended for clusters serving latency-sensitive traffic, especially if using HTTP/1.1.\n* http: change frame flood and abuse checks to the upstream HTTP/2 codec to ON by default. It can be disabled by setting the `envoy.reloadable_features.upstream_http2_flood_checks` runtime key to false.\n* json: introduced new JSON parser (https://github.com/nlohmann/json) to replace RapidJSON. The new parser is disabled by default. To test the new RapidJSON parser, enable the runtime feature `envoy.reloadable_features.remove_legacy_json`.\n* original_dst: added support for :ref:`Original Destination <config_listener_filters_original_dst>` on Windows. This enables the use of Envoy as a sidecar proxy on Windows.\n* overload: add support for scaling :ref:`transport connection timeouts<envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.TRANSPORT_SOCKET_CONNECT>`. This can be used to reduce the TLS handshake timeout in response to overload.\n* postgres: added ability to :ref:`terminate SSL<envoy_v3_api_field_extensions.filters.network.postgres_proxy.v3alpha.PostgresProxy.terminate_ssl>`.\n* route config: added :ref:`allow_post field <envoy_v3_api_field_config.route.v3.RouteAction.UpgradeConfig.ConnectConfig.allow_post>` for allowing POST payload as raw TCP.\n* route config: added :ref:`max_direct_response_body_size_bytes <envoy_v3_api_field_config.route.v3.RouteConfiguration.max_direct_response_body_size_bytes>` to set maximum :ref:`direct response body <envoy_v3_api_field_config.route.v3.DirectResponseAction.body>` size in bytes. If not specified the default remains 4096 bytes.\n* server: added *fips_mode* to :ref:`server compilation settings <server_compilation_settings_statistics>` related statistic.\n* tcp_proxy: add support for converting raw TCP streams into HTTP/1.1 CONNECT requests. See :ref:`upgrade documentation <tunneling-tcp-over-http>` for details.\n* tcp_proxy: added a :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>` for using HTTP POST to proxy TCP streams.\n* tcp_proxy: added a :ref:`headers_to_add field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.headers_to_add>` for setting additional headers to the HTTP requests for TCP proxing.\n\nDeprecated\n----------\n", "#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"jwt_verify_lib/check_audience.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtProvider;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirement;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirementAndList;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirementOrList;\nusing ::google::jwt_verify::CheckAudience;\nusing ::google::jwt_verify::Status;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\n/**\n * Struct to keep track of verifier completed and responded state for a request.\n */\nstruct CompletionState {\n  // if verifier node has responded to a request or not.\n  bool is_completed_{false};\n  // number of completed inner verifier for an any/all verifier.\n  std::size_t number_completed_children_{0};\n  // A valid error for a RequireAny\n  Status status_;\n};\n\nclass ContextImpl : public Verifier::Context {\npublic:\n  ContextImpl(Http::RequestHeaderMap& headers, Tracing::Span& parent_span,\n              Verifier::Callbacks* callback)\n      : headers_(headers), parent_span_(parent_span), callback_(callback) {}\n\n  Http::RequestHeaderMap& headers() const override { return headers_; }\n\n  Tracing::Span& parentSpan() const override { return parent_span_; }\n\n  Verifier::Callbacks* callback() const override { return callback_; }\n\n  void cancel() override {\n    for (const auto& it : auths_) {\n      it->onDestroy();\n    }\n  }\n\n  // Get Response data which can be used to check if a verifier node has responded or not.\n  CompletionState& getCompletionState(const Verifier* verifier) {\n    return completion_states_[verifier];\n  }\n\n  // Stores an authenticator object for this request.\n  void storeAuth(AuthenticatorPtr&& auth) { auths_.emplace_back(std::move(auth)); }\n\n  // Add a pair of (name, payload), called by Authenticator\n  void addPayload(const std::string& name, const ProtobufWkt::Struct& payload) {\n    *(*payload_.mutable_fields())[name].mutable_struct_value() = payload;\n  }\n\n  void setPayload() {\n    if (!payload_.fields().empty()) {\n      callback_->setPayload(payload_);\n    }\n  }\n\nprivate:\n  Http::RequestHeaderMap& headers_;\n  Tracing::Span& parent_span_;\n  Verifier::Callbacks* callback_;\n  absl::node_hash_map<const Verifier*, CompletionState> completion_states_;\n  std::vector<AuthenticatorPtr> auths_;\n  ProtobufWkt::Struct payload_;\n};\n\n// base verifier for provider_name, provider_and_audiences, and allow_missing_or_failed.\nclass BaseVerifierImpl : public Logger::Loggable<Logger::Id::jwt>, public Verifier {\npublic:\n  BaseVerifierImpl(const BaseVerifierImpl* parent) : parent_(parent) {}\n\n  void completeWithStatus(Status status, ContextImpl& context) const {\n    if (parent_ != nullptr) {\n      auto& completion_state = context.getCompletionState(this);\n      completion_state.status_ = status;\n      return parent_->onComplete(status, context);\n    }\n\n    if (Status::Ok == status) {\n      context.setPayload();\n    }\n    context.callback()->onComplete(status);\n    context.cancel();\n  }\n\n  // Check if next verifier should be notified of status, or if no next verifier exists signal\n  // callback in context.\n  virtual void onComplete(const Status& status, ContextImpl& context) const {\n    auto& completion_state = context.getCompletionState(this);\n    if (!completion_state.is_completed_) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n    }\n  }\n\nprotected:\n  // The parent group verifier.\n  const BaseVerifierImpl* const parent_;\n};\n\n// Provider specific verifier\nclass ProviderVerifierImpl : public BaseVerifierImpl {\npublic:\n  ProviderVerifierImpl(const std::string& provider_name, const AuthFactory& factory,\n                       const JwtProvider& provider, const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(provider)),\n        provider_name_(provider_name) {}\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(getAudienceChecker(), provider_name_, false, false);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprotected:\n  virtual const CheckAudience* getAudienceChecker() const { return nullptr; }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  const ExtractorConstPtr extractor_;\n  const std::string provider_name_;\n};\n\nclass ProviderAndAudienceVerifierImpl : public ProviderVerifierImpl {\npublic:\n  ProviderAndAudienceVerifierImpl(const std::string& provider_name, const AuthFactory& factory,\n                                  const JwtProvider& provider, const BaseVerifierImpl* parent,\n                                  const std::vector<std::string>& config_audiences)\n      : ProviderVerifierImpl(provider_name, factory, provider, parent),\n        check_audience_(std::make_unique<CheckAudience>(config_audiences)) {}\n\nprivate:\n  const CheckAudience* getAudienceChecker() const override { return check_audience_.get(); }\n\n  // Check audience object\n  ::google::jwt_verify::CheckAudiencePtr check_audience_;\n};\n\n// Allow missing or failed verifier\nclass AllowFailedVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowFailedVerifierImpl(const AuthFactory& factory, const JwtProviderList& providers,\n                          const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(providers)) {\n  }\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(nullptr, absl::nullopt, true, true);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  // const Extractor& extractor_;\n  const ExtractorConstPtr extractor_;\n};\n\nclass AllowMissingVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowMissingVerifierImpl(const AuthFactory& factory, const JwtProviderList& providers,\n                           const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(providers)) {\n  }\n\n  void verify(ContextSharedPtr context) const override {\n    ENVOY_LOG(debug, \"Called AllowMissingVerifierImpl.verify : {}\", __func__);\n\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(nullptr, absl::nullopt, false /* allow failed */,\n                                     true /* allow missing */);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  const ExtractorConstPtr extractor_;\n};\n\nVerifierConstPtr innerCreate(const JwtRequirement& requirement,\n                             const Protobuf::Map<std::string, JwtProvider>& providers,\n                             const AuthFactory& factory, const BaseVerifierImpl* parent);\n\n// Base verifier for requires all or any.\nclass BaseGroupVerifierImpl : public BaseVerifierImpl {\npublic:\n  BaseGroupVerifierImpl(const BaseVerifierImpl* parent) : BaseVerifierImpl(parent) {}\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    for (const auto& it : verifiers_) {\n      if (ctximpl.getCompletionState(this).is_completed_) {\n        return;\n      }\n      it->verify(context);\n    }\n  }\n\nprotected:\n  // The list of requirement verifiers\n  std::vector<VerifierConstPtr> verifiers_;\n};\n\n// Requires any verifier.\nclass AnyVerifierImpl : public BaseGroupVerifierImpl {\npublic:\n  AnyVerifierImpl(const JwtRequirementOrList& or_list, const AuthFactory& factory,\n                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                  const BaseVerifierImpl* parent)\n      : BaseGroupVerifierImpl(parent) {\n\n    for (const auto& it : or_list.requirements()) {\n      switch (it.requires_type_case()) {\n      case JwtRequirement::RequiresTypeCase::kAllowMissingOrFailed:\n        is_allow_missing_or_failed_ = true;\n        break;\n      case JwtRequirement::RequiresTypeCase::kAllowMissing:\n        is_allow_missing_ = true;\n        break;\n      default:\n        verifiers_.emplace_back(innerCreate(it, providers, factory, this));\n        break;\n      }\n    }\n\n    // RequiresAny only has one missing or failed requirement.\n    if (verifiers_.empty() && (is_allow_missing_or_failed_ || is_allow_missing_)) {\n      JwtRequirement requirement;\n      if (is_allow_missing_or_failed_) {\n        requirement.mutable_allow_missing_or_failed();\n      } else {\n        requirement.mutable_allow_missing();\n      }\n      verifiers_.emplace_back(innerCreate(requirement, providers, factory, this));\n    }\n  }\n\n  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n\n    // If any of children is OK, return OK\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n\n    // Then wait for all children to be done.\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      // Aggregate all children status into a final status.\n      // JwtMissing should be treated differently than other failure status\n      // since it simply means there is not Jwt token for the required provider.\n      // If there is a failure status other than JwtMissing in the children,\n      // it should be used as the final status.\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        // If a Jwt is extracted from a location not specified by the required provider,\n        // the authenticator returns JwtUnknownIssuer. It should be treated the same as\n        // JwtMissed.\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }\n\nprivate:\n  bool is_allow_missing_or_failed_{false};\n  bool is_allow_missing_{false};\n};\n\n// Requires all verifier\nclass AllVerifierImpl : public BaseGroupVerifierImpl {\npublic:\n  AllVerifierImpl(const JwtRequirementAndList& and_list, const AuthFactory& factory,\n                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                  // const Extractor& extractor_for_allow_fail,\n                  const BaseVerifierImpl* parent)\n      : BaseGroupVerifierImpl(parent) {\n    for (const auto& it : and_list.requirements()) {\n      verifiers_.emplace_back(innerCreate(it, providers, factory, this));\n    }\n  }\n\n  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size() ||\n        Status::Ok != status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n    }\n  }\n};\n\n// Match all, for requirement not set\nclass AllowAllVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowAllVerifierImpl(const BaseVerifierImpl* parent) : BaseVerifierImpl(parent) {}\n\n  void verify(ContextSharedPtr context) const override {\n    completeWithStatus(Status::Ok, static_cast<ContextImpl&>(*context));\n  }\n};\n\nJwtProviderList getAllProvidersAsList(const Protobuf::Map<std::string, JwtProvider>& providers) {\n  JwtProviderList list;\n  for (const auto& it : providers) {\n    list.emplace_back(&it.second);\n  }\n  return list;\n}\n\nVerifierConstPtr innerCreate(const JwtRequirement& requirement,\n                             const Protobuf::Map<std::string, JwtProvider>& providers,\n                             const AuthFactory& factory, const BaseVerifierImpl* parent) {\n  std::string provider_name;\n  std::vector<std::string> audiences;\n  switch (requirement.requires_type_case()) {\n  case JwtRequirement::RequiresTypeCase::kProviderName:\n    provider_name = requirement.provider_name();\n    break;\n  case JwtRequirement::RequiresTypeCase::kProviderAndAudiences:\n    for (const auto& it : requirement.provider_and_audiences().audiences()) {\n      audiences.emplace_back(it);\n    }\n    provider_name = requirement.provider_and_audiences().provider_name();\n    break;\n  case JwtRequirement::RequiresTypeCase::kRequiresAny:\n    return std::make_unique<AnyVerifierImpl>(requirement.requires_any(), factory, providers,\n                                             parent);\n  case JwtRequirement::RequiresTypeCase::kRequiresAll:\n    return std::make_unique<AllVerifierImpl>(requirement.requires_all(), factory, providers,\n                                             parent);\n  case JwtRequirement::RequiresTypeCase::kAllowMissingOrFailed:\n    return std::make_unique<AllowFailedVerifierImpl>(factory, getAllProvidersAsList(providers),\n                                                     parent);\n  case JwtRequirement::RequiresTypeCase::kAllowMissing:\n    return std::make_unique<AllowMissingVerifierImpl>(factory, getAllProvidersAsList(providers),\n                                                      parent);\n  case JwtRequirement::RequiresTypeCase::REQUIRES_TYPE_NOT_SET:\n    return std::make_unique<AllowAllVerifierImpl>(parent);\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n\n  const auto& it = providers.find(provider_name);\n  if (it == providers.end()) {\n    throw EnvoyException(fmt::format(\"Required provider ['{}'] is not configured.\", provider_name));\n  }\n  if (audiences.empty()) {\n    return std::make_unique<ProviderVerifierImpl>(provider_name, factory, it->second, parent);\n  }\n  return std::make_unique<ProviderAndAudienceVerifierImpl>(provider_name, factory, it->second,\n                                                           parent, audiences);\n}\n\n} // namespace\n\nContextSharedPtr Verifier::createContext(Http::RequestHeaderMap& headers,\n                                         Tracing::Span& parent_span, Callbacks* callback) {\n  return std::make_shared<ContextImpl>(headers, parent_span, callback);\n}\n\nVerifierConstPtr Verifier::create(const JwtRequirement& requirement,\n                                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                                  const AuthFactory& factory) {\n  return innerCreate(requirement, providers, factory, nullptr);\n}\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"extensions/filters/http/jwt_authn/filter_config.h\"\n#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"test/extensions/filters/http/jwt_authn/mock.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/string_view.h\"\n#include \"gmock/gmock.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing ::google::jwt_verify::Status;\nusing ::testing::NiceMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconstexpr char kConfigTemplate[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    from_headers:\n    - name: \"x-example\"\n      value_prefix: \"\"\n    forward_payload_header: \"x-example-payload\"\n    forward: true\n    local_jwks:\n      inline_string: \"\"\n  other_provider:\n    issuer: https://other.com\n    from_headers:\n    - name: \"x-other\"\n      value_prefix: \"\"\n    forward_payload_header: \"x-other-payload\"\n    forward: true\n    local_jwks:\n      inline_string: \"\"\nrules:\n- match:\n    path: \"/\"\n)\";\n\nconstexpr char kExampleHeader[] = \"x-example\";\nconstexpr char kOtherHeader[] = \"x-other\";\n\n// Returns true if jwt_header payload exists.\n// Payload is added only after verification was success.\nMATCHER_P(JwtOutputSuccess, jwt_header, \"\") {\n  auto payload_header = absl::StrCat(jwt_header, \"-payload\");\n  return arg.has(payload_header);\n}\n\n// Returns true if the jwt_header payload is empty.\n// Payload is added only after verification was success.\nMATCHER_P(JwtOutputFailedOrIgnore, jwt_header, \"\") {\n  auto payload_header = absl::StrCat(jwt_header, \"-payload\");\n  return !arg.has(payload_header);\n}\n\nclass AllVerifierTest : public testing::Test {\npublic:\n  void SetUp() override {\n    TestUtility::loadFromYaml(kConfigTemplate, proto_config_);\n    for (auto& it : *(proto_config_.mutable_providers())) {\n      it.second.mutable_local_jwks()->set_inline_string(PublicKey);\n    }\n  }\n\n  void createVerifier() {\n    filter_config_ = FilterConfigImpl::create(proto_config_, \"\", mock_factory_ctx_);\n    verifier_ = Verifier::create(proto_config_.rules(0).requires(), proto_config_.providers(),\n                                 *filter_config_);\n  }\n\n  void modifyRequirement(const std::string& yaml) {\n    TestUtility::loadFromYaml(yaml, *proto_config_.mutable_rules(0)->mutable_requires());\n  }\n\n  JwtAuthentication proto_config_;\n  std::shared_ptr<FilterConfigImpl> filter_config_;\n  VerifierConstPtr verifier_;\n  NiceMock<Server::Configuration::MockFactoryContext> mock_factory_ctx_;\n  ContextSharedPtr context_;\n  MockVerifierCallbacks mock_cb_;\n  NiceMock<Tracing::MockSpan> parent_span_;\n};\n\n// tests rule that is just match no requires.\nTEST_F(AllVerifierTest, TestAllAllow) {\n  createVerifier();\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok)).Times(2);\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, \"a\"}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// tests requires allow missing or failed. The `allow_missing_or_failed` is defined in a single\n// requirement by itself.\nclass AllowFailedInSingleRequirementTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    proto_config_.mutable_rules(0)->mutable_requires()->mutable_allow_missing_or_failed();\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInSingleRequirementTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, MissingIssToken) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an OR-list of requirements by itself.\nclass SingleAllowMissingInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_missing_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_missing_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(SingleAllowMissingInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(SingleAllowMissingInOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, MissingIssToken) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an OR-list of requirements.\nclass AllowFailedInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, GoodAndBadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  // Note: the first (provider) requirement is satisfied, so the allow_missing_or_failed has not\n  // kicked in yet.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // Token in x-other is not required, so it will be ignore.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an AND-list of requirements.\nclass AllowFailedInAndListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInAndListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInAndListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {kExampleHeader, GoodToken},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  // The bad, non-required token won't affect the verification status though.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nclass AllowFailedInAndOfOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - allow_missing_or_failed: {}\n  - requires_any:\n      requirements:\n      - provider_name: \"other_provider\"\n      - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInAndOfOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, OtherGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, BadAndGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\n// The `allow_missing` is defined in an OR-list of requirements.\nclass AllowMissingInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInOrListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInOrListTest, OtherGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  // x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowMissingInOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nclass AllowMissingInAndListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInAndListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInAndListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndListTest, GoodJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndListTest, TwoGoodJwts) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nclass AllowMissingInAndOfOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - allow_missing: {}\n  - requires_any:\n      requirements:\n      - provider_name: \"other_provider\"\n      - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInAndOfOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  // Use the token with example.com issuer for x-other.\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // Short-circuit AND, the x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"test/extensions/filters/http/jwt_authn/mock.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing ::google::jwt_verify::Status;\nusing ::testing::NiceMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconst char AllWithAny[] = R\"(\nproviders:\n  provider_1:\n    issuer: iss_1\n  provider_2:\n    issuer: iss_2\n  provider_3:\n    issuer: iss_3\nrules:\n- match: { path: \"/\" }\n  requires:\n    requires_all:\n      requirements:\n      - requires_any:\n          requirements:\n            - provider_name: \"provider_1\"\n            - provider_name: \"provider_2\"\n      - provider_name: \"provider_3\"\n)\";\n\nconst char AnyWithAll[] = R\"(\nproviders:\n  provider_1:\n    issuer: iss_1\n  provider_2:\n    issuer: iss_2\n  provider_3:\n    issuer: iss_3\n  provider_4:\n    issuer: iss_4\nrules:\n- match: { path: \"/\" }\n  requires:\n    requires_any:\n      requirements:\n      - requires_all:\n          requirements:\n            - provider_name: \"provider_1\"\n            - provider_name: \"provider_2\"\n      - requires_all:\n          requirements:\n            - provider_name: \"provider_3\"\n            - provider_name: \"provider_4\"\n)\";\n\nusing StatusMap = absl::node_hash_map<std::string, const Status>;\n\nconstexpr auto allowfailed = \"_allow_failed_\";\n\nclass GroupVerifierTest : public testing::Test {\npublic:\n  void createVerifier() {\n    ON_CALL(mock_factory_, create(_, _, _, _))\n        .WillByDefault(Invoke([&](const ::google::jwt_verify::CheckAudience*,\n                                  const absl::optional<std::string>& provider, bool, bool) {\n          return std::move(mock_auths_[provider ? provider.value() : allowfailed]);\n        }));\n    verifier_ = Verifier::create(proto_config_.rules(0).requires(), proto_config_.providers(),\n                                 mock_factory_);\n  }\n  void createSyncMockAuthsAndVerifier(const StatusMap& statuses) {\n    for (const auto& it : statuses) {\n      auto mock_auth = std::make_unique<MockAuthenticator>();\n      EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _))\n          .WillOnce(Invoke([issuer = it.first, status = it.second](\n                               Http::HeaderMap&, Tracing::Span&, std::vector<JwtLocationConstPtr>*,\n                               SetPayloadCallback set_payload_cb, AuthenticatorCallback callback) {\n            if (status == Status::Ok) {\n              ProtobufWkt::Struct empty_struct;\n              set_payload_cb(issuer, empty_struct);\n            }\n            callback(status);\n          }));\n      EXPECT_CALL(*mock_auth, onDestroy());\n      mock_auths_[it.first] = std::move(mock_auth);\n    }\n    createVerifier();\n  }\n\n  // This expected payload is only for createSyncMockAuthsAndVerifier() function\n  // which set an empty payload struct for each issuer.\n  static ProtobufWkt::Struct getExpectedPayload(const std::vector<std::string>& issuers) {\n    ProtobufWkt::Struct struct_obj;\n    auto* fields = struct_obj.mutable_fields();\n    for (const auto& issuer : issuers) {\n      ProtobufWkt::Struct empty_struct;\n      *(*fields)[issuer].mutable_struct_value() = empty_struct;\n    }\n    return struct_obj;\n  }\n\n  void createAsyncMockAuthsAndVerifier(const std::vector<std::string>& providers) {\n    for (const auto& provider : providers) {\n      auto mock_auth = std::make_unique<MockAuthenticator>();\n      EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _))\n          .WillOnce(Invoke([&, iss = provider](Http::HeaderMap&, Tracing::Span&,\n                                               std::vector<JwtLocationConstPtr>*,\n                                               SetPayloadCallback, AuthenticatorCallback callback) {\n            callbacks_[iss] = std::move(callback);\n          }));\n      EXPECT_CALL(*mock_auth, onDestroy());\n      mock_auths_[provider] = std::move(mock_auth);\n    }\n    createVerifier();\n  }\n\n  JwtAuthentication proto_config_;\n  VerifierConstPtr verifier_;\n  MockVerifierCallbacks mock_cb_;\n  absl::node_hash_map<std::string, std::unique_ptr<MockAuthenticator>> mock_auths_;\n  NiceMock<MockAuthFactory> mock_factory_;\n  ContextSharedPtr context_;\n  NiceMock<Tracing::MockSpan> parent_span_;\n  absl::node_hash_map<std::string, AuthenticatorCallback> callbacks_;\n};\n\n// Deeply nested anys that ends in provider name\nTEST_F(GroupVerifierTest, DeeplyNestedAnys) {\n  const char config[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    forward_payload_header: sec-istio-auth-userinfo\n    from_params:\n    - jwta\n    - jwtb\n    - jwtc\nrules:\n- match: { path: \"/match\" }\n  requires:\n    requires_any:\n      requirements:\n      - requires_any:\n          requirements:\n          - requires_any:\n              requirements:\n              - provider_name: \"example_provider\"\n)\";\n  TestUtility::loadFromYaml(config, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"example_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"sec-istio-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"sec-istio-auth-userinfo\"));\n}\n\n// require alls that just ends\nTEST_F(GroupVerifierTest, CanHandleUnexpectedEnd) {\n  const char config[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    forward_payload_header: sec-istio-auth-userinfo\nrules:\n- match: { path: \"/match\" }\n  requires:\n    requires_all:\n      requirements:\n      - requires_all:\n)\";\n  TestUtility::loadFromYaml(config, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _)).Times(0);\n  mock_auths_[\"example_provider\"] = std::move(mock_auth);\n  createVerifier();\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// test requires all with both auth returning OK\nTEST_F(GroupVerifierTest, TestRequiresAll) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"example_provider\", Status::Ok}, {\"other_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(\n        payload, getExpectedPayload({\"example_provider\", \"other_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// test requires all with first auth returning bad format\nTEST_F(GroupVerifierTest, TestRequiresAllBadFormat) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtBadFormat));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtBadFormat);\n  // can keep invoking callback\n  callbacks_[\"other_provider\"](Status::Ok);\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::Ok);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// test requires all with second auth returning missing jwt\nTEST_F(GroupVerifierTest, TestRequiresAllMissing) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::JwtMissed);\n  // can keep invoking callback\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::Ok);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires all and mock auths simulate cache misses and async return of failure statuses.\nTEST_F(GroupVerifierTest, TestRequiresAllBothFailed) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n  callbacks_[\"example_provider\"](Status::JwtUnknownIssuer);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}\n\n// Test requires any with first auth returning OK.\nTEST_F(GroupVerifierTest, TestRequiresAnyFirstAuthOK) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"example_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_TRUE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with last auth returning OK.\nTEST_F(GroupVerifierTest, TestRequiresAnyLastAuthOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"example_provider\", Status::JwtUnknownIssuer}, {\"other_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"other_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning error. Requires any returns the error last received\n// back to the caller.\nTEST_F(GroupVerifierTest, TestRequiresAnyAllAuthFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtMissed},\n                                           {\"other_provider\", Status::JwtHeaderBadKid}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning errors, last error is JwtMissed.\n// Usually the final error is from the last one.\n// But if a token is not for a provider, that provider auth will either return\n// JwtMissed or JwtUnknownIssuer, such error should not be used for the final\n// error in Any case\nTEST_F(GroupVerifierTest, TestRequiresAnyLastIsJwtMissed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtHeaderBadKid},\n                                           {\"other_provider\", Status::JwtMissed}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning errors: last error is\n// JwtUnknownIssuer\nTEST_F(GroupVerifierTest, TestRequiresAnyLastIsJwtUnknownIssuer) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtHeaderBadKid},\n                                           {\"other_provider\", Status::JwtUnknownIssuer}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates first require any is OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllFirstAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"provider_1\", Status::Ok}, {\"provider_3\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"provider_1\", \"provider_3\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates first require any is OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllLastAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"provider_1\", Status::JwtUnknownIssuer},\n                                           {\"provider_2\", Status::Ok},\n                                           {\"provider_3\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"provider_2\", \"provider_3\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates all require any OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllBothInRequireAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\"});\n\n  // AsyncMockVerifier doesn't set payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::Ok);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates all require any failed and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllBothInRequireAnyFailed) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\"});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwksFetchFail));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::JwksFetchFail);\n  callbacks_[\"provider_2\"](Status::JwksFetchFail);\n  callbacks_[\"provider_3\"](Status::Ok);\n}\n\n// Test contains a requires any which in turn has 2 requires all. Mock auths simulate JWKs cache\n// hits and inline return of errors. Requires any returns the error last received back to the\n// caller.\nTEST_F(GroupVerifierTest, TestAllInAnyBothRequireAllFailed) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"provider_1\", Status::JwksFetchFail}, {\"provider_3\", Status::JwtExpired}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The first inner requires all is\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyFirstAllIsOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  // AsyncMockVerifier doesn't set payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::JwtMissed);\n  callbacks_[\"provider_1\"](Status::Ok);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The last inner requires all is\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyLastAllIsOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_3\"](Status::Ok);\n  callbacks_[\"provider_4\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::JwtExpired);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The both inner requires all are\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyBothRequireAllAreOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::Ok);\n  callbacks_[\"provider_4\"](Status::Ok);\n}\n\n// Test RequiresAny with two providers and allow_failed\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing_or_failed();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtExpired);\n}\n\n// Test RequiresAny with two providers and allow_missing, failed\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtExpired);\n}\n\n// Test RequiresAny with two providers and allow_missing, but OK\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["1.18.0 (Pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* grpc_stats: the default value for :ref:`stats_for_all_methods <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.stats_for_all_methods>` is switched from true to false, in order to avoid possible memory exhaustion due to an untrusted downstream sending a large number of unique method names. The previous default value was deprecated in version 1.14.0. This only changes the behavior when the value is not set. The previous behavior can be used by setting the value to true. This behavior change by be overridden by setting runtime feature `envoy.deprecated_features.grpc_stats_filter_enable_stats_for_all_methods_by_default`.\n* http: resolving inconsistencies between :scheme and X-Forwarded-Proto. :scheme will now be set for all HTTP/1.1 requests. This changes the behavior of the gRPC access logger, Wasm filters, CSRF filter and oath2 filter for HTTP/1 traffic, where :scheme was previously not set. This change also validates that for front-line Envoys (Envoys configured with  :ref:`xff_num_trusted_hops <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>` set to 0 and :ref:`use_remote_address <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>` set to true) that HTTP/1.1 https schemed requests can not be sent over non-TLS connections. All behavioral changes listed here can be temporarily reverted by setting `envoy.reloadable_features.add_and_validate_scheme_header` to false.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* hds: support custom health check port via :ref:`health_check_config <envoy_v3_api_msg_config.endpoint.v3.endpoint.healthcheckconfig>`.\n* healthcheck: the :ref:`health check filter <config_http_filters_health_check>` now sends the\n  :ref:`x-envoy-immediate-health-check-fail <config_http_filters_router_x-envoy-immediate-health-check-fail>` header\n  for all responses when Envoy is in the health check failed state. Additionally, receiving the\n  :ref:`x-envoy-immediate-health-check-fail <config_http_filters_router_x-envoy-immediate-health-check-fail>`\n  header (either in response to normal traffic or in response to an HTTP :ref:`active health check <arch_overview_health_checking>`) will\n  cause Envoy to immediately :ref:`exclude <arch_overview_load_balancing_excluded>` the host from\n  load balancing calculations. This has the useful property that such hosts, which are being\n  explicitly told to disable traffic, will not be counted for panic routing calculations. See the\n  excluded documentation for more information. This behavior can be temporarily reverted by setting\n  the `envoy.reloadable_features.health_check.immediate_failure_exclude_from_cluster` feature flag\n  to false. Note that the runtime flag covers *both* the health check filter responding with\n  `x-envoy-immediate-health-check-fail` in all cases (versus just non-HC requests) as well as\n  whether receiving `x-envoy-immediate-health-check-fail` will cause exclusion or not. Thus,\n  depending on the Envoy deployment, the feature flag may need to be flipped on both downstream\n  and upstream instances, depending on the reason.\n* http: allow to use path canonicalizer from `googleurl <https://quiche.googlesource.com/googleurl>`_\n  instead of `//source/common/chromium_url`. The new path canonicalizer is enabled by default. To\n  revert to the legacy path canonicalizer, enable the runtime flag\n  `envoy.reloadable_features.remove_forked_chromium_url`.\n* http: increase the maximum allowed number of initial connection WINDOW_UPDATE frames sent by the peer from 1 to 5.\n* http: upstream flood and abuse checks increment the count of opened HTTP/2 streams when Envoy sends\n  initial HEADERS frame for the new stream. Before the counter was incrementred when Envoy received\n  response HEADERS frame with the END_HEADERS flag set from upstream server.\n* oauth filter: added the optional parameter :ref:`auth_scopes <envoy_v3_api_field_extensions.filters.http.oauth2.v3alpha.OAuth2Config.auth_scopes>` with default value of 'user' if not provided. Enables this value to be overridden in the Authorization request to the OAuth provider.\n* perf: allow reading more bytes per operation from raw sockets to improve performance.\n* router: extended custom date formatting to DOWNSTREAM_PEER_CERT_V_START and DOWNSTREAM_PEER_CERT_V_END when using :ref:`custom request/response header formats <config_http_conn_man_headers_custom_request_headers>`.\n* upstream: host weight changes now cause a full load balancer rebuild as opposed to happening\n  atomically inline. This change has been made to support load balancer pre-computation of data\n  structures based on host weight, but may have performance implications if host weight changes\n  are very frequent. This change can be disabled by setting the `envoy.reloadable_features.upstream_host_weight_change_causes_rebuild`\n  feature flag to false. If setting this flag to false is required in a deployment please open an\n  issue against the project.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* active http health checks: properly handles HTTP/2 GOAWAY frames from the upstream. Previously a GOAWAY frame due to a graceful listener drain could cause improper failed health checks due to streams being refused by the upstream on a connection that is going away. To revert to old GOAWAY handling behavior, set the runtime feature `envoy.reloadable_features.health_check.graceful_goaway_handling` to false.\n* buffer: tighten network connection read and write buffer high watermarks in preparation to more careful enforcement of read limits. Buffer high-watermark is now set to the exact configured value; previously it was set to value + 1.\n* fault injection: stop counting as active fault after delay elapsed. Previously fault injection filter continues to count the injected delay as an active fault even after it has elapsed. This produces incorrect output statistics and impacts the max number of consecutive faults allowed (e.g., for long-lived streams). This change decreases the active fault count when the delay fault is the only active and has gone finished.\n* filter_chain: fix filter chain matching with the server name as the case-insensitive way.\n* grpc-web: fix local reply and non-proto-encoded gRPC response handling for small response bodies. This fix can be temporarily reverted by setting `envoy.reloadable_features.grpc_web_fix_non_proto_encoded_response_handling` to false.\n* grpc_http_bridge: the downstream HTTP status is now correctly set for trailers-only responses from the upstream.\n* http: disallowing \"host:\" in request_headers_to_add for behavioral consistency with rejecting :authority header. This behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_host_like_authority` to false.\n* http: reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection failures. The change back to the original behavior can be temporarily reverted by setting `envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure` to false.\n* jwt_authn: reject requests with a proper error if JWT has the wrong issuer when allow_missing is used. Before this change, the requests are accepted.\n* listener: prevent crashing when an unknown listener config proto is received and debug logging is enabled.\n* overload: fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.\n* sni: as the server name in sni should be case-insensitive, envoy will convert the server name as lower case first before any other process inside envoy.\n* tls: fix the subject alternative name of the presented certificate matches the specified matchers as the case-insensitive way when it uses DNS name.\n* upstream: fix handling of moving endpoints between priorities when active health checks are enabled. Previously moving to a higher numbered priority was a NOOP, and moving to a lower numbered priority caused an abort.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_logs: removed legacy unbounded access logs and runtime guard `envoy.reloadable_features.disallow_unbounded_access_logs`.\n* dns: removed legacy buggy wildcard matching path and runtime guard `envoy.reloadable_features.fix_wildcard_matching`.\n* dynamic_forward_proxy: removed `envoy.reloadable_features.enable_dns_cache_circuit_breakers` and legacy code path.\n* http: removed legacy connection close behavior and runtime guard `envoy.reloadable_features.fixed_connection_close`.\n* http: removed legacy HTTP/1.1 error reporting path and runtime guard `envoy.reloadable_features.early_errors_via_hcm`.\n* http: removed legacy sanitization path for upgrade response headers and runtime guard `envoy.reloadable_features.fix_upgrade_response`.\n* http: removed legacy date header overwriting logic and runtime guard `envoy.reloadable_features.preserve_upstream_date deprecation`.\n* listener: removed legacy runtime guard `envoy.reloadable_features.listener_in_place_filterchain_update`.\n* router: removed `envoy.reloadable_features.consume_all_retry_headers` and legacy code path.\n\nNew Features\n------------\n\n* access log: added the :ref:`formatters <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.formatters>` extension point for custom formatters (command operators).\n* access log: support command operator: %FILTER_CHAIN_NAME% for the downstream tcp and http request.\n* access log: support command operator: %REQUEST_HEADERS_BYTES%, %RESPONSE_HEADERS_BYTES%, and %RESPONSE_TRAILERS_BYTES%.\n* compression: add brotli :ref:`compressor <envoy_v3_api_msg_extensions.compression.brotli.compressor.v3.Brotli>` and :ref:`decompressor <envoy_v3_api_msg_extensions.compression.brotli.decompressor.v3.Brotli>`.\n* config: add `envoy.features.fail_on_any_deprecated_feature` runtime key, which matches the behaviour of compile-time flag `ENVOY_DISABLE_DEPRECATED_FEATURES`, i.e. use of deprecated fields will cause a crash.\n* config: the ``Node`` :ref:`dynamic context parameters <envoy_v3_api_field_config.core.v3.Node.dynamic_parameters>` are populated in discovery requests when set on the server instance.\n* dispatcher: supports a stack of `Envoy::ScopeTrackedObject` instead of a single tracked object. This will allow Envoy to dump more debug information on crash.\n* ext_authz: added :ref:`response_headers_to_add <envoy_v3_api_field_service.auth.v3.OkHttpResponse.response_headers_to_add>` to support sending response headers to downstream clients on OK authorization checks via gRPC.\n* ext_authz: added :ref:`allowed_client_headers_on_success <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>` to support sending response headers to downstream clients on OK external authorization checks via HTTP.\n* grpc_json_transcoder: added :ref:`request_validation_options <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.request_validation_options>` to reject invalid requests early.\n* grpc_json_transcoder: filter can now be configured on per-route/per-vhost level as well. Leaving empty list of services in the filter configuration disables transcoding on the specific route.\n* http: added support for `Envoy::ScopeTrackedObject` for HTTP/1 and HTTP/2 dispatching. Crashes while inside the dispatching loop should dump debug information.\n* http: added an option to not add content-length: 0 for requests which should not have bodies. This behavior can be enabled by setting `envoy.reloadable_features.dont_add_content_length_for_bodiless_requests` true.\n* http: added support for :ref:`preconnecting <envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy>`. Preconnecting is off by default, but recommended for clusters serving latency-sensitive traffic, especially if using HTTP/1.1.\n* http: change frame flood and abuse checks to the upstream HTTP/2 codec to ON by default. It can be disabled by setting the `envoy.reloadable_features.upstream_http2_flood_checks` runtime key to false.\n* json: introduced new JSON parser (https://github.com/nlohmann/json) to replace RapidJSON. The new parser is disabled by default. To test the new RapidJSON parser, enable the runtime feature `envoy.reloadable_features.remove_legacy_json`.\n* original_dst: added support for :ref:`Original Destination <config_listener_filters_original_dst>` on Windows. This enables the use of Envoy as a sidecar proxy on Windows.\n* overload: add support for scaling :ref:`transport connection timeouts<envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.TRANSPORT_SOCKET_CONNECT>`. This can be used to reduce the TLS handshake timeout in response to overload.\n* postgres: added ability to :ref:`terminate SSL<envoy_v3_api_field_extensions.filters.network.postgres_proxy.v3alpha.PostgresProxy.terminate_ssl>`.\n* route config: added :ref:`allow_post field <envoy_v3_api_field_config.route.v3.RouteAction.UpgradeConfig.ConnectConfig.allow_post>` for allowing POST payload as raw TCP.\n* route config: added :ref:`max_direct_response_body_size_bytes <envoy_v3_api_field_config.route.v3.RouteConfiguration.max_direct_response_body_size_bytes>` to set maximum :ref:`direct response body <envoy_v3_api_field_config.route.v3.DirectResponseAction.body>` size in bytes. If not specified the default remains 4096 bytes.\n* server: added *fips_mode* to :ref:`server compilation settings <server_compilation_settings_statistics>` related statistic.\n* tcp_proxy: add support for converting raw TCP streams into HTTP/1.1 CONNECT requests. See :ref:`upgrade documentation <tunneling-tcp-over-http>` for details.\n* tcp_proxy: added a :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>` for using HTTP POST to proxy TCP streams.\n* tcp_proxy: added a :ref:`headers_to_add field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.headers_to_add>` for setting additional headers to the HTTP requests for TCP proxing.\n\nDeprecated\n----------\n", "#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"jwt_verify_lib/check_audience.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtProvider;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirement;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirementAndList;\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtRequirementOrList;\nusing ::google::jwt_verify::CheckAudience;\nusing ::google::jwt_verify::Status;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\n/**\n * Struct to keep track of verifier completed and responded state for a request.\n */\nstruct CompletionState {\n  // if verifier node has responded to a request or not.\n  bool is_completed_{false};\n  // number of completed inner verifier for an any/all verifier.\n  std::size_t number_completed_children_{0};\n  // A valid error for a RequireAny\n  Status status_;\n};\n\nclass ContextImpl : public Verifier::Context {\npublic:\n  ContextImpl(Http::RequestHeaderMap& headers, Tracing::Span& parent_span,\n              Verifier::Callbacks* callback)\n      : headers_(headers), parent_span_(parent_span), callback_(callback) {}\n\n  Http::RequestHeaderMap& headers() const override { return headers_; }\n\n  Tracing::Span& parentSpan() const override { return parent_span_; }\n\n  Verifier::Callbacks* callback() const override { return callback_; }\n\n  void cancel() override {\n    for (const auto& it : auths_) {\n      it->onDestroy();\n    }\n  }\n\n  // Get Response data which can be used to check if a verifier node has responded or not.\n  CompletionState& getCompletionState(const Verifier* verifier) {\n    return completion_states_[verifier];\n  }\n\n  // Stores an authenticator object for this request.\n  void storeAuth(AuthenticatorPtr&& auth) { auths_.emplace_back(std::move(auth)); }\n\n  // Add a pair of (name, payload), called by Authenticator\n  void addPayload(const std::string& name, const ProtobufWkt::Struct& payload) {\n    *(*payload_.mutable_fields())[name].mutable_struct_value() = payload;\n  }\n\n  void setPayload() {\n    if (!payload_.fields().empty()) {\n      callback_->setPayload(payload_);\n    }\n  }\n\nprivate:\n  Http::RequestHeaderMap& headers_;\n  Tracing::Span& parent_span_;\n  Verifier::Callbacks* callback_;\n  absl::node_hash_map<const Verifier*, CompletionState> completion_states_;\n  std::vector<AuthenticatorPtr> auths_;\n  ProtobufWkt::Struct payload_;\n};\n\n// base verifier for provider_name, provider_and_audiences, and allow_missing_or_failed.\nclass BaseVerifierImpl : public Logger::Loggable<Logger::Id::jwt>, public Verifier {\npublic:\n  BaseVerifierImpl(const BaseVerifierImpl* parent) : parent_(parent) {}\n\n  void completeWithStatus(Status status, ContextImpl& context) const {\n    if (parent_ != nullptr) {\n      auto& completion_state = context.getCompletionState(this);\n      completion_state.status_ = status;\n      return parent_->onComplete(status, context);\n    }\n\n    if (Status::Ok == status) {\n      context.setPayload();\n    }\n    context.callback()->onComplete(status);\n    context.cancel();\n  }\n\n  // Check if next verifier should be notified of status, or if no next verifier exists signal\n  // callback in context.\n  virtual void onComplete(const Status& status, ContextImpl& context) const {\n    auto& completion_state = context.getCompletionState(this);\n    if (!completion_state.is_completed_) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n    }\n  }\n\nprotected:\n  // The parent group verifier.\n  const BaseVerifierImpl* const parent_;\n};\n\n// Provider specific verifier\nclass ProviderVerifierImpl : public BaseVerifierImpl {\npublic:\n  ProviderVerifierImpl(const std::string& provider_name, const AuthFactory& factory,\n                       const JwtProvider& provider, const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(provider)),\n        provider_name_(provider_name) {}\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(getAudienceChecker(), provider_name_, false, false);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprotected:\n  virtual const CheckAudience* getAudienceChecker() const { return nullptr; }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  const ExtractorConstPtr extractor_;\n  const std::string provider_name_;\n};\n\nclass ProviderAndAudienceVerifierImpl : public ProviderVerifierImpl {\npublic:\n  ProviderAndAudienceVerifierImpl(const std::string& provider_name, const AuthFactory& factory,\n                                  const JwtProvider& provider, const BaseVerifierImpl* parent,\n                                  const std::vector<std::string>& config_audiences)\n      : ProviderVerifierImpl(provider_name, factory, provider, parent),\n        check_audience_(std::make_unique<CheckAudience>(config_audiences)) {}\n\nprivate:\n  const CheckAudience* getAudienceChecker() const override { return check_audience_.get(); }\n\n  // Check audience object\n  ::google::jwt_verify::CheckAudiencePtr check_audience_;\n};\n\n// Allow missing or failed verifier\nclass AllowFailedVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowFailedVerifierImpl(const AuthFactory& factory, const JwtProviderList& providers,\n                          const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(providers)) {\n  }\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(nullptr, absl::nullopt, true, true);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  // const Extractor& extractor_;\n  const ExtractorConstPtr extractor_;\n};\n\nclass AllowMissingVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowMissingVerifierImpl(const AuthFactory& factory, const JwtProviderList& providers,\n                           const BaseVerifierImpl* parent)\n      : BaseVerifierImpl(parent), auth_factory_(factory), extractor_(Extractor::create(providers)) {\n  }\n\n  void verify(ContextSharedPtr context) const override {\n    ENVOY_LOG(debug, \"Called AllowMissingVerifierImpl.verify : {}\", __func__);\n\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    auto auth = auth_factory_.create(nullptr, absl::nullopt, false /* allow failed */,\n                                     true /* allow missing */);\n    extractor_->sanitizePayloadHeaders(ctximpl.headers());\n    auth->verify(\n        ctximpl.headers(), ctximpl.parentSpan(), extractor_->extract(ctximpl.headers()),\n        [&ctximpl](const std::string& name, const ProtobufWkt::Struct& payload) {\n          ctximpl.addPayload(name, payload);\n        },\n        [this, context](const Status& status) {\n          onComplete(status, static_cast<ContextImpl&>(*context));\n        });\n    if (!ctximpl.getCompletionState(this).is_completed_) {\n      ctximpl.storeAuth(std::move(auth));\n    } else {\n      auth->onDestroy();\n    }\n  }\n\nprivate:\n  const AuthFactory& auth_factory_;\n  const ExtractorConstPtr extractor_;\n};\n\nVerifierConstPtr innerCreate(const JwtRequirement& requirement,\n                             const Protobuf::Map<std::string, JwtProvider>& providers,\n                             const AuthFactory& factory, const BaseVerifierImpl* parent);\n\n// Base verifier for requires all or any.\nclass BaseGroupVerifierImpl : public BaseVerifierImpl {\npublic:\n  BaseGroupVerifierImpl(const BaseVerifierImpl* parent) : BaseVerifierImpl(parent) {}\n\n  void verify(ContextSharedPtr context) const override {\n    auto& ctximpl = static_cast<ContextImpl&>(*context);\n    for (const auto& it : verifiers_) {\n      if (ctximpl.getCompletionState(this).is_completed_) {\n        return;\n      }\n      it->verify(context);\n    }\n  }\n\nprotected:\n  // The list of requirement verifiers\n  std::vector<VerifierConstPtr> verifiers_;\n};\n\n// Requires any verifier.\nclass AnyVerifierImpl : public BaseGroupVerifierImpl {\npublic:\n  AnyVerifierImpl(const JwtRequirementOrList& or_list, const AuthFactory& factory,\n                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                  const BaseVerifierImpl* parent)\n      : BaseGroupVerifierImpl(parent) {\n\n    for (const auto& it : or_list.requirements()) {\n      switch (it.requires_type_case()) {\n      case JwtRequirement::RequiresTypeCase::kAllowMissingOrFailed:\n        is_allow_missing_or_failed_ = true;\n        break;\n      case JwtRequirement::RequiresTypeCase::kAllowMissing:\n        is_allow_missing_ = true;\n        break;\n      default:\n        verifiers_.emplace_back(innerCreate(it, providers, factory, this));\n        break;\n      }\n    }\n\n    // RequiresAny only has one missing or failed requirement.\n    if (verifiers_.empty() && (is_allow_missing_or_failed_ || is_allow_missing_)) {\n      JwtRequirement requirement;\n      if (is_allow_missing_or_failed_) {\n        requirement.mutable_allow_missing_or_failed();\n      } else {\n        requirement.mutable_allow_missing();\n      }\n      verifiers_.emplace_back(innerCreate(requirement, providers, factory, this));\n    }\n  }\n\n  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n\n    // If any of children is OK, return OK\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n\n    // Then wait for all children to be done.\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      // Aggregate all children status into a final status.\n      // JwtMissed and JwtUnknownIssuer should be treated differently than other errors.\n      // JwtMissed means not Jwt token for the required provider.\n      // JwtUnknownIssuer means wrong issuer for the required provider.\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        // Prefer errors which are not JwtMissed nor JwtUnknownIssuer.\n        // Prefer JwtUnknownIssuer between JwtMissed and JwtUnknownIssuer.\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if ((child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) ||\n            final_status == Status::JwtMissed) {\n          final_status = child_status;\n        }\n      }\n\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }\n\nprivate:\n  bool is_allow_missing_or_failed_{false};\n  bool is_allow_missing_{false};\n};\n\n// Requires all verifier\nclass AllVerifierImpl : public BaseGroupVerifierImpl {\npublic:\n  AllVerifierImpl(const JwtRequirementAndList& and_list, const AuthFactory& factory,\n                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                  // const Extractor& extractor_for_allow_fail,\n                  const BaseVerifierImpl* parent)\n      : BaseGroupVerifierImpl(parent) {\n    for (const auto& it : and_list.requirements()) {\n      verifiers_.emplace_back(innerCreate(it, providers, factory, this));\n    }\n  }\n\n  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size() ||\n        Status::Ok != status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n    }\n  }\n};\n\n// Match all, for requirement not set\nclass AllowAllVerifierImpl : public BaseVerifierImpl {\npublic:\n  AllowAllVerifierImpl(const BaseVerifierImpl* parent) : BaseVerifierImpl(parent) {}\n\n  void verify(ContextSharedPtr context) const override {\n    completeWithStatus(Status::Ok, static_cast<ContextImpl&>(*context));\n  }\n};\n\nJwtProviderList getAllProvidersAsList(const Protobuf::Map<std::string, JwtProvider>& providers) {\n  JwtProviderList list;\n  for (const auto& it : providers) {\n    list.emplace_back(&it.second);\n  }\n  return list;\n}\n\nVerifierConstPtr innerCreate(const JwtRequirement& requirement,\n                             const Protobuf::Map<std::string, JwtProvider>& providers,\n                             const AuthFactory& factory, const BaseVerifierImpl* parent) {\n  std::string provider_name;\n  std::vector<std::string> audiences;\n  switch (requirement.requires_type_case()) {\n  case JwtRequirement::RequiresTypeCase::kProviderName:\n    provider_name = requirement.provider_name();\n    break;\n  case JwtRequirement::RequiresTypeCase::kProviderAndAudiences:\n    for (const auto& it : requirement.provider_and_audiences().audiences()) {\n      audiences.emplace_back(it);\n    }\n    provider_name = requirement.provider_and_audiences().provider_name();\n    break;\n  case JwtRequirement::RequiresTypeCase::kRequiresAny:\n    return std::make_unique<AnyVerifierImpl>(requirement.requires_any(), factory, providers,\n                                             parent);\n  case JwtRequirement::RequiresTypeCase::kRequiresAll:\n    return std::make_unique<AllVerifierImpl>(requirement.requires_all(), factory, providers,\n                                             parent);\n  case JwtRequirement::RequiresTypeCase::kAllowMissingOrFailed:\n    return std::make_unique<AllowFailedVerifierImpl>(factory, getAllProvidersAsList(providers),\n                                                     parent);\n  case JwtRequirement::RequiresTypeCase::kAllowMissing:\n    return std::make_unique<AllowMissingVerifierImpl>(factory, getAllProvidersAsList(providers),\n                                                      parent);\n  case JwtRequirement::RequiresTypeCase::REQUIRES_TYPE_NOT_SET:\n    return std::make_unique<AllowAllVerifierImpl>(parent);\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n\n  const auto& it = providers.find(provider_name);\n  if (it == providers.end()) {\n    throw EnvoyException(fmt::format(\"Required provider ['{}'] is not configured.\", provider_name));\n  }\n  if (audiences.empty()) {\n    return std::make_unique<ProviderVerifierImpl>(provider_name, factory, it->second, parent);\n  }\n  return std::make_unique<ProviderAndAudienceVerifierImpl>(provider_name, factory, it->second,\n                                                           parent, audiences);\n}\n\n} // namespace\n\nContextSharedPtr Verifier::createContext(Http::RequestHeaderMap& headers,\n                                         Tracing::Span& parent_span, Callbacks* callback) {\n  return std::make_shared<ContextImpl>(headers, parent_span, callback);\n}\n\nVerifierConstPtr Verifier::create(const JwtRequirement& requirement,\n                                  const Protobuf::Map<std::string, JwtProvider>& providers,\n                                  const AuthFactory& factory) {\n  return innerCreate(requirement, providers, factory, nullptr);\n}\n\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"extensions/filters/http/jwt_authn/filter_config.h\"\n#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"test/extensions/filters/http/jwt_authn/mock.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/mocks/server/factory_context.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/string_view.h\"\n#include \"gmock/gmock.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing ::google::jwt_verify::Status;\nusing ::testing::NiceMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconstexpr char kConfigTemplate[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    from_headers:\n    - name: \"x-example\"\n      value_prefix: \"\"\n    forward_payload_header: \"x-example-payload\"\n    forward: true\n    local_jwks:\n      inline_string: \"\"\n  other_provider:\n    issuer: https://other.com\n    from_headers:\n    - name: \"x-other\"\n      value_prefix: \"\"\n    forward_payload_header: \"x-other-payload\"\n    forward: true\n    local_jwks:\n      inline_string: \"\"\nrules:\n- match:\n    path: \"/\"\n)\";\n\nconstexpr char kExampleHeader[] = \"x-example\";\nconstexpr char kOtherHeader[] = \"x-other\";\n\n// Returns true if jwt_header payload exists.\n// Payload is added only after verification was success.\nMATCHER_P(JwtOutputSuccess, jwt_header, \"\") {\n  auto payload_header = absl::StrCat(jwt_header, \"-payload\");\n  return arg.has(payload_header);\n}\n\n// Returns true if the jwt_header payload is empty.\n// Payload is added only after verification was success.\nMATCHER_P(JwtOutputFailedOrIgnore, jwt_header, \"\") {\n  auto payload_header = absl::StrCat(jwt_header, \"-payload\");\n  return !arg.has(payload_header);\n}\n\nclass AllVerifierTest : public testing::Test {\npublic:\n  void SetUp() override {\n    TestUtility::loadFromYaml(kConfigTemplate, proto_config_);\n    for (auto& it : *(proto_config_.mutable_providers())) {\n      it.second.mutable_local_jwks()->set_inline_string(PublicKey);\n    }\n  }\n\n  void createVerifier() {\n    filter_config_ = FilterConfigImpl::create(proto_config_, \"\", mock_factory_ctx_);\n    verifier_ = Verifier::create(proto_config_.rules(0).requires(), proto_config_.providers(),\n                                 *filter_config_);\n  }\n\n  void modifyRequirement(const std::string& yaml) {\n    TestUtility::loadFromYaml(yaml, *proto_config_.mutable_rules(0)->mutable_requires());\n  }\n\n  JwtAuthentication proto_config_;\n  std::shared_ptr<FilterConfigImpl> filter_config_;\n  VerifierConstPtr verifier_;\n  NiceMock<Server::Configuration::MockFactoryContext> mock_factory_ctx_;\n  ContextSharedPtr context_;\n  MockVerifierCallbacks mock_cb_;\n  NiceMock<Tracing::MockSpan> parent_span_;\n};\n\n// tests rule that is just match no requires.\nTEST_F(AllVerifierTest, TestAllAllow) {\n  createVerifier();\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok)).Times(2);\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, \"a\"}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// tests requires allow missing or failed. The `allow_missing_or_failed` is defined in a single\n// requirement by itself.\nclass AllowFailedInSingleRequirementTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    proto_config_.mutable_rules(0)->mutable_requires()->mutable_allow_missing_or_failed();\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInSingleRequirementTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, MissingIssToken) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInSingleRequirementTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an OR-list of requirements by itself.\nclass SingleAllowMissingInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_missing_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_missing_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(SingleAllowMissingInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(SingleAllowMissingInOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, MissingIssToken) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(SingleAllowMissingInOrListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an OR-list of requirements.\nclass AllowFailedInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, GoodAndBadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  // Note: the first (provider) requirement is satisfied, so the allow_missing_or_failed has not\n  // kicked in yet.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // Token in x-other is not required, so it will be ignore.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n// The `allow_missing_or_failed` is defined in an AND-list of requirements.\nclass AllowFailedInAndListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInAndListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInAndListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {kExampleHeader, GoodToken},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  // The bad, non-required token won't affect the verification status though.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nclass AllowFailedInAndOfOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - allow_missing_or_failed: {}\n  - requires_any:\n      requirements:\n      - provider_name: \"other_provider\"\n      - allow_missing_or_failed: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowFailedInAndOfOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, BadJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, OtherGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, BadAndGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowFailedInAndOfOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\n// The `allow_missing` is defined in an OR-list of requirements.\nclass AllowMissingInOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_any:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInOrListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInOrListTest, OtherGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  // x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowMissingInOrListTest, WrongIssuer) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  // x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowMissingInOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nclass AllowMissingInAndListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - provider_name: \"example_provider\"\n  - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInAndListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInAndListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndListTest, GoodJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndListTest, TwoGoodJwts) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nclass AllowMissingInAndOfOrListTest : public AllVerifierTest {\nprotected:\n  void SetUp() override {\n    AllVerifierTest::SetUp();\n    const char allow_failed_yaml[] = R\"(\nrequires_all:\n  requirements:\n  - requires_any:\n      requirements:\n      - provider_name: \"example_provider\"\n      - allow_missing: {}\n  - requires_any:\n      requirements:\n      - provider_name: \"other_provider\"\n      - allow_missing: {}\n)\";\n    modifyRequirement(allow_failed_yaml);\n    createVerifier();\n  }\n};\n\nTEST_F(AllowMissingInAndOfOrListTest, NoJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, BadJwt) {\n  // Bad JWT should fail.\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtVerificationFail));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, NonExistKidToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, OneGoodJwt) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, TwoGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputSuccess(kOtherHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, GoodAndBadJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n  // Use the token with example.com issuer for x-other.\n  auto headers =\n      Http::TestRequestHeaderMapImpl{{kExampleHeader, GoodToken}, {kOtherHeader, GoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputSuccess(kExampleHeader));\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\nTEST_F(AllowMissingInAndOfOrListTest, BadAndGoodJwts) {\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ExpiredToken},\n                                                {kOtherHeader, OtherGoodToken}};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));\n  // Short-circuit AND, the x-other JWT should be ignored.\n  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kOtherHeader));\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/extensions/filters/http/jwt_authn/v3/config.pb.h\"\n\n#include \"extensions/filters/http/jwt_authn/verifier.h\"\n\n#include \"test/extensions/filters/http/jwt_authn/mock.h\"\n#include \"test/extensions/filters/http/jwt_authn/test_common.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n\nusing envoy::extensions::filters::http::jwt_authn::v3::JwtAuthentication;\nusing ::google::jwt_verify::Status;\nusing ::testing::NiceMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace HttpFilters {\nnamespace JwtAuthn {\nnamespace {\n\nconst char AllWithAny[] = R\"(\nproviders:\n  provider_1:\n    issuer: iss_1\n  provider_2:\n    issuer: iss_2\n  provider_3:\n    issuer: iss_3\nrules:\n- match: { path: \"/\" }\n  requires:\n    requires_all:\n      requirements:\n      - requires_any:\n          requirements:\n            - provider_name: \"provider_1\"\n            - provider_name: \"provider_2\"\n      - provider_name: \"provider_3\"\n)\";\n\nconst char AnyWithAll[] = R\"(\nproviders:\n  provider_1:\n    issuer: iss_1\n  provider_2:\n    issuer: iss_2\n  provider_3:\n    issuer: iss_3\n  provider_4:\n    issuer: iss_4\nrules:\n- match: { path: \"/\" }\n  requires:\n    requires_any:\n      requirements:\n      - requires_all:\n          requirements:\n            - provider_name: \"provider_1\"\n            - provider_name: \"provider_2\"\n      - requires_all:\n          requirements:\n            - provider_name: \"provider_3\"\n            - provider_name: \"provider_4\"\n)\";\n\nusing StatusMap = absl::node_hash_map<std::string, const Status>;\n\nconstexpr auto allowfailed = \"_allow_failed_\";\n\nclass GroupVerifierTest : public testing::Test {\npublic:\n  void createVerifier() {\n    ON_CALL(mock_factory_, create(_, _, _, _))\n        .WillByDefault(Invoke([&](const ::google::jwt_verify::CheckAudience*,\n                                  const absl::optional<std::string>& provider, bool, bool) {\n          return std::move(mock_auths_[provider ? provider.value() : allowfailed]);\n        }));\n    verifier_ = Verifier::create(proto_config_.rules(0).requires(), proto_config_.providers(),\n                                 mock_factory_);\n  }\n  void createSyncMockAuthsAndVerifier(const StatusMap& statuses) {\n    for (const auto& it : statuses) {\n      auto mock_auth = std::make_unique<MockAuthenticator>();\n      EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _))\n          .WillOnce(Invoke([issuer = it.first, status = it.second](\n                               Http::HeaderMap&, Tracing::Span&, std::vector<JwtLocationConstPtr>*,\n                               SetPayloadCallback set_payload_cb, AuthenticatorCallback callback) {\n            if (status == Status::Ok) {\n              ProtobufWkt::Struct empty_struct;\n              set_payload_cb(issuer, empty_struct);\n            }\n            callback(status);\n          }));\n      EXPECT_CALL(*mock_auth, onDestroy());\n      mock_auths_[it.first] = std::move(mock_auth);\n    }\n    createVerifier();\n  }\n\n  // This expected payload is only for createSyncMockAuthsAndVerifier() function\n  // which set an empty payload struct for each issuer.\n  static ProtobufWkt::Struct getExpectedPayload(const std::vector<std::string>& issuers) {\n    ProtobufWkt::Struct struct_obj;\n    auto* fields = struct_obj.mutable_fields();\n    for (const auto& issuer : issuers) {\n      ProtobufWkt::Struct empty_struct;\n      *(*fields)[issuer].mutable_struct_value() = empty_struct;\n    }\n    return struct_obj;\n  }\n\n  void createAsyncMockAuthsAndVerifier(const std::vector<std::string>& providers) {\n    for (const auto& provider : providers) {\n      auto mock_auth = std::make_unique<MockAuthenticator>();\n      EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _))\n          .WillOnce(Invoke([&, iss = provider](Http::HeaderMap&, Tracing::Span&,\n                                               std::vector<JwtLocationConstPtr>*,\n                                               SetPayloadCallback, AuthenticatorCallback callback) {\n            callbacks_[iss] = std::move(callback);\n          }));\n      EXPECT_CALL(*mock_auth, onDestroy());\n      mock_auths_[provider] = std::move(mock_auth);\n    }\n    createVerifier();\n  }\n\n  JwtAuthentication proto_config_;\n  VerifierConstPtr verifier_;\n  MockVerifierCallbacks mock_cb_;\n  absl::node_hash_map<std::string, std::unique_ptr<MockAuthenticator>> mock_auths_;\n  NiceMock<MockAuthFactory> mock_factory_;\n  ContextSharedPtr context_;\n  NiceMock<Tracing::MockSpan> parent_span_;\n  absl::node_hash_map<std::string, AuthenticatorCallback> callbacks_;\n};\n\n// Deeply nested anys that ends in provider name\nTEST_F(GroupVerifierTest, DeeplyNestedAnys) {\n  const char config[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    forward_payload_header: sec-istio-auth-userinfo\n    from_params:\n    - jwta\n    - jwtb\n    - jwtc\nrules:\n- match: { path: \"/match\" }\n  requires:\n    requires_any:\n      requirements:\n      - requires_any:\n          requirements:\n          - requires_any:\n              requirements:\n              - provider_name: \"example_provider\"\n)\";\n  TestUtility::loadFromYaml(config, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"example_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"sec-istio-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"sec-istio-auth-userinfo\"));\n}\n\n// require alls that just ends\nTEST_F(GroupVerifierTest, CanHandleUnexpectedEnd) {\n  const char config[] = R\"(\nproviders:\n  example_provider:\n    issuer: https://example.com\n    audiences:\n    - example_service\n    - http://example_service1\n    - https://example_service2/\n    remote_jwks:\n      http_uri:\n        uri: https://pubkey_server/pubkey_path\n        cluster: pubkey_cluster\n    forward_payload_header: sec-istio-auth-userinfo\nrules:\n- match: { path: \"/match\" }\n  requires:\n    requires_all:\n      requirements:\n      - requires_all:\n)\";\n  TestUtility::loadFromYaml(config, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  EXPECT_CALL(*mock_auth, doVerify(_, _, _, _, _)).Times(0);\n  mock_auths_[\"example_provider\"] = std::move(mock_auth);\n  createVerifier();\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// test requires all with both auth returning OK\nTEST_F(GroupVerifierTest, TestRequiresAll) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"example_provider\", Status::Ok}, {\"other_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(\n        payload, getExpectedPayload({\"example_provider\", \"other_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// test requires all with first auth returning bad format\nTEST_F(GroupVerifierTest, TestRequiresAllBadFormat) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtBadFormat));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtBadFormat);\n  // can keep invoking callback\n  callbacks_[\"other_provider\"](Status::Ok);\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::Ok);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// test requires all with second auth returning missing jwt\nTEST_F(GroupVerifierTest, TestRequiresAllMissing) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtMissed));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::JwtMissed);\n  // can keep invoking callback\n  callbacks_[\"example_provider\"](Status::Ok);\n  callbacks_[\"other_provider\"](Status::Ok);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires all and mock auths simulate cache misses and async return of failure statuses.\nTEST_F(GroupVerifierTest, TestRequiresAllBothFailed) {\n  TestUtility::loadFromYaml(RequiresAllConfig, proto_config_);\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n  callbacks_[\"example_provider\"](Status::JwtUnknownIssuer);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}\n\n// Test requires any with first auth returning OK.\nTEST_F(GroupVerifierTest, TestRequiresAnyFirstAuthOK) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"example_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_TRUE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with last auth returning OK.\nTEST_F(GroupVerifierTest, TestRequiresAnyLastAuthOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"example_provider\", Status::JwtUnknownIssuer}, {\"other_provider\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"other_provider\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning error. Requires any returns the error last received\n// back to the caller.\nTEST_F(GroupVerifierTest, TestRequiresAnyAllAuthFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtMissed},\n                                           {\"other_provider\", Status::JwtHeaderBadKid}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning errors, last error is JwtMissed.\n// Usually the final error is from the last one.\n// But if a token is not for a provider, that provider auth will either return\n// JwtMissed or JwtUnknownIssuer, such error should not be used for the final\n// error in Any case\nTEST_F(GroupVerifierTest, TestRequiresAnyLastIsJwtMissed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtHeaderBadKid},\n                                           {\"other_provider\", Status::JwtMissed}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test requires any with both auth returning errors: last error is\n// JwtUnknownIssuer\nTEST_F(GroupVerifierTest, TestRequiresAnyLastIsJwtUnknownIssuer) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  auto mock_auth = std::make_unique<MockAuthenticator>();\n  createSyncMockAuthsAndVerifier(StatusMap{{\"example_provider\", Status::JwtHeaderBadKid},\n                                           {\"other_provider\", Status::JwtUnknownIssuer}});\n\n  // onComplete with failure status, not payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtHeaderBadKid));\n  auto headers = Http::TestRequestHeaderMapImpl{\n      {\"example-auth-userinfo\", \"\"},\n      {\"other-auth-userinfo\", \"\"},\n  };\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  EXPECT_FALSE(headers.has(\"example-auth-userinfo\"));\n  EXPECT_FALSE(headers.has(\"other-auth-userinfo\"));\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates first require any is OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllFirstAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"provider_1\", Status::Ok}, {\"provider_3\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"provider_1\", \"provider_3\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates first require any is OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllLastAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createSyncMockAuthsAndVerifier(StatusMap{{\"provider_1\", Status::JwtUnknownIssuer},\n                                           {\"provider_2\", Status::Ok},\n                                           {\"provider_3\", Status::Ok}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).WillOnce(Invoke([](const ProtobufWkt::Struct& payload) {\n    EXPECT_TRUE(TestUtility::protoEqual(payload, getExpectedPayload({\"provider_2\", \"provider_3\"})));\n  }));\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates all require any OK and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllBothInRequireAnyIsOk) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\"});\n\n  // AsyncMockVerifier doesn't set payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::Ok);\n}\n\n// Test contains a 2 provider_name in a require any along with another provider_name in require all.\n// Test simulates all require any failed and provider_name is OK.\nTEST_F(GroupVerifierTest, TestAnyInAllBothInRequireAnyFailed) {\n  TestUtility::loadFromYaml(AllWithAny, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\"});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwksFetchFail));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::JwksFetchFail);\n  callbacks_[\"provider_2\"](Status::JwksFetchFail);\n  callbacks_[\"provider_3\"](Status::Ok);\n}\n\n// Test contains a requires any which in turn has 2 requires all. Mock auths simulate JWKs cache\n// hits and inline return of errors. Requires any returns the error last received back to the\n// caller.\nTEST_F(GroupVerifierTest, TestAllInAnyBothRequireAllFailed) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createSyncMockAuthsAndVerifier(\n      StatusMap{{\"provider_1\", Status::JwksFetchFail}, {\"provider_3\", Status::JwtExpired}});\n\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The first inner requires all is\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyFirstAllIsOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  // AsyncMockVerifier doesn't set payload\n  EXPECT_CALL(mock_cb_, setPayload(_)).Times(0);\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::JwtMissed);\n  callbacks_[\"provider_1\"](Status::Ok);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The last inner requires all is\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyLastAllIsOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_3\"](Status::Ok);\n  callbacks_[\"provider_4\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::JwtExpired);\n}\n\n// Test contains a requires any which in turn has 2 requires all. The both inner requires all are\n// completed with OKs. Mock auths simulate JWKs cache misses and async return of OKs.\nTEST_F(GroupVerifierTest, TestAllInAnyBothRequireAllAreOk) {\n  TestUtility::loadFromYaml(AnyWithAll, proto_config_);\n  createAsyncMockAuthsAndVerifier(\n      std::vector<std::string>{\"provider_1\", \"provider_2\", \"provider_3\", \"provider_4\"});\n\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"provider_1\"](Status::Ok);\n  callbacks_[\"provider_2\"](Status::Ok);\n  callbacks_[\"provider_3\"](Status::Ok);\n  callbacks_[\"provider_4\"](Status::Ok);\n}\n\n// Test RequiresAny with two providers and allow_failed\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing_or_failed();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtExpired);\n}\n\n// Test RequiresAny with two providers and allow_missing, failed\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButFailed) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtExpired));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtExpired);\n}\n\n// Test RequiresAny with two providers and allow_missing, but one returns JwtUnknownIssuer\nTEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButUnknownIssuer) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::JwtUnknownIssuer));\n\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}\n\n} // namespace\n} // namespace JwtAuthn\n} // namespace HttpFilters\n} // namespace Extensions\n} // namespace Envoy\n"], "filenames": ["docs/root/version_history/current.rst", "source/extensions/filters/http/jwt_authn/verifier.cc", "test/extensions/filters/http/jwt_authn/all_verifier_test.cc", "test/extensions/filters/http/jwt_authn/group_verifier_test.cc"], "buggy_code_start_loc": [60, 304, 200, 585], "buggy_code_end_loc": [60, 315, 593, 596], "fixing_code_start_loc": [61, 304, 200, 585], "fixing_code_end_loc": [62, 314, 602, 596], "type": "CWE-287", "message": "Envoy is a cloud-native high-performance edge/middle/service proxy. In Envoy version 1.17.0 an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list when Envoy's JWT Authentication filter is configured with the `allow_missing` requirement under `requires_any` due to a mistake in implementation. Envoy's JWT Authentication filter can be configured with the `allow_missing` requirement that will be satisfied if JWT is missing (JwtMissed error) and fail if JWT is presented or invalid. Due to a mistake in implementation, a JwtUnknownIssuer error was mistakenly converted to JwtMissed when `requires_any` was configured. So if `allow_missing` was configured under `requires_any`, an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list. Integrity may be impacted depending on configuration if the JWT token is used to protect against writes or modifications. This regression was introduced on 2020/11/12 in PR 13839 which fixed handling `allow_missing` under RequiresAny in a JwtRequirement (see issue 13458). The AnyVerifier aggregates the children verifiers' results into a final status where JwtMissing is the default error. However, a JwtUnknownIssuer was mistakenly treated the same as a JwtMissing error and the resulting final aggregation was the default JwtMissing. As a result, `allow_missing` would allow a JWT token with an unknown issuer status. This is fixed in version 1.17.1 by PR 15194. The fix works by preferring JwtUnknownIssuer over a JwtMissing error, fixing the accidental conversion and bypass with `allow_missing`. A user could detect whether a bypass occurred if they have Envoy logs enabled with debug verbosity. Users can enable component level debug logs for JWT. The JWT filter logs will indicate that there is a request with a JWT token and a failure that the JWT token is missing.", "other": {"cve": {"id": "CVE-2021-21378", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-11T03:15:12.163", "lastModified": "2022-10-24T17:11:17.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a cloud-native high-performance edge/middle/service proxy. In Envoy version 1.17.0 an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list when Envoy's JWT Authentication filter is configured with the `allow_missing` requirement under `requires_any` due to a mistake in implementation. Envoy's JWT Authentication filter can be configured with the `allow_missing` requirement that will be satisfied if JWT is missing (JwtMissed error) and fail if JWT is presented or invalid. Due to a mistake in implementation, a JwtUnknownIssuer error was mistakenly converted to JwtMissed when `requires_any` was configured. So if `allow_missing` was configured under `requires_any`, an attacker can bypass authentication by presenting a JWT token with an issuer that is not in the provider list. Integrity may be impacted depending on configuration if the JWT token is used to protect against writes or modifications. This regression was introduced on 2020/11/12 in PR 13839 which fixed handling `allow_missing` under RequiresAny in a JwtRequirement (see issue 13458). The AnyVerifier aggregates the children verifiers' results into a final status where JwtMissing is the default error. However, a JwtUnknownIssuer was mistakenly treated the same as a JwtMissing error and the resulting final aggregation was the default JwtMissing. As a result, `allow_missing` would allow a JWT token with an unknown issuer status. This is fixed in version 1.17.1 by PR 15194. The fix works by preferring JwtUnknownIssuer over a JwtMissing error, fixing the accidental conversion and bypass with `allow_missing`. A user could detect whether a bypass occurred if they have Envoy logs enabled with debug verbosity. Users can enable component level debug logs for JWT. The JWT filter logs will indicate that there is a request with a JWT token and a failure that the JWT token is missing."}, {"lang": "es", "value": "Envoy es un proxy edge/middle/service de servicio de alto rendimiento nativo de la nube.&#xa0;En versi\u00f3n 1.17.0 de Envoy, un atacante puede omitir la autenticaci\u00f3n presentando un token JWT con un emisor que no est\u00e1 en la lista de proveedores cuando el filtro de autenticaci\u00f3n JWT de Envoy est\u00e1 configurado con el requisito \"allow_missing\" en \"require_any\" debido a un error en la implementaci\u00f3n.&#xa0;El filtro de autenticaci\u00f3n JWT de Envoy puede ser configurado con el requisito \"allow_missing\" que se cumplir\u00e1 si falta JWT (error JwtMissed) y presentar\u00e1 un fallo si JWT existe o no es v\u00e1lido.&#xa0;Debido a un error en la implementaci\u00f3n, un error de JwtUnknownIssuer se convirti\u00f3 por error a JwtMissed cuando se configur\u00f3 \"require_any\".&#xa0;Entonces, si se configur\u00f3 \"allow_missing\" en \"require_any\", un atacante puede omitir la autenticaci\u00f3n al presentar un token JWT con un emisor que no est\u00e1 en la lista de proveedores.&#xa0;La integridad puede ser impactada seg\u00fan la configuraci\u00f3n si el token JWT se usa para proteger contra escrituras o modificaciones.&#xa0;Esta regresi\u00f3n fue introducida el 12/11/2020 en PR 13839, que corrigi\u00f3 el manejo de \"allow_missing\" en RequireAny en un JwtRequirement (consulte el problema 13458).&#xa0;AnyVerifier agrega los resultados de los comprobadores secundarios a un estado final donde JwtMissing es el error predeterminado.&#xa0;Sin embargo, un JwtUnknownIssuer se trat\u00f3 por error igual que un error JwtMissing y la agregaci\u00f3n final resultante fue el JwtMissing predeterminado.&#xa0;Como resultado, \"allow_missing\" permitir\u00eda un token JWT con un estado de emisor desconocido.&#xa0;Esto es corregido en versi\u00f3n 1.17.1 por PR 15194. La correcci\u00f3n funciona al preferir JwtUnknownIssuer sobre un error de JwtMissing, corrigiendo la conversi\u00f3n accidental y omitiendo con \"allow_missing\".&#xa0;Un usuario podr\u00eda detectar si se produjo una omisi\u00f3n si posee los registros de Envoy habilitados con verbosidad de depuraci\u00f3n&#xa0;Los usuarios pueden habilitar registros de depuraci\u00f3n a nivel de componente para JWT.&#xa0;Los registros del filtro JWT indicar\u00e1n que se presenta una petici\u00f3n con un token JWT y un fallo de que falta el token JWT"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-303"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:1.17.0:*:*:*:*:*:*:*", "matchCriteriaId": "E426CE56-9EB3-4641-B9A0-2E418FD3478F"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/pull/15194", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4996-m8hf-hj27", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/ea39e3cba652bcc4b11bb0d5c62b017e584d2e5a"}}