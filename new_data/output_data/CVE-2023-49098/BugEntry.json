{"buggy_code": ["# frozen_string_literal: true\n\nclass DiscourseReactions::CustomReactionsController < ApplicationController\n  MAX_USERS_COUNT = 26\n\n  requires_plugin DiscourseReactions::PLUGIN_NAME\n\n  before_action :ensure_logged_in, except: [:post_reactions_users]\n\n  def toggle\n    post = fetch_post_from_params\n\n    unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n      return render_json_error(post)\n    end\n\n    begin\n      manager =\n        DiscourseReactions::ReactionManager.new(\n          reaction_value: params[:reaction],\n          user: current_user,\n          guardian: guardian,\n          post: post,\n        )\n      manager.toggle!\n    rescue ActiveRecord::RecordNotUnique\n      # If the user already performed this action, it's probably due to a different browser tab\n      # or non-debounced clicking. We can ignore.\n    end\n\n    post.publish_change_to_clients!(:acted)\n    publish_change_to_clients!(\n      post,\n      reaction: manager.reaction_value,\n      previous_reaction: manager.previous_reaction_value,\n    )\n\n    render_json_dump(post_serializer(post).as_json)\n  end\n\n  def reactions_given\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction, :post)\n        .joins(\"INNER JOIN topics t ON t.id = posts.topic_id AND t.deleted_at IS NULL\")\n        .joins(\"LEFT JOIN categories c ON c.id = t.category_id\")\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    reaction_users = secure_reaction_users!(reaction_users)\n\n    if params[:before_reaction_user_id]\n      reaction_users =\n        reaction_users.where(\n          \"discourse_reactions_reaction_users.id < ?\",\n          params[:before_reaction_user_id].to_i,\n        )\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20)\n\n    render_serialized(reaction_users.to_a, UserReactionSerializer)\n  end\n\n  def reactions_received\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    posts = Post.joins(:topic).where(user_id: user.id)\n    posts = guardian.filter_allowed_categories(posts)\n    post_ids = posts.select(:id)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    # Guarantee backwards compatibility if someone was calling this endpoint with the old param.\n    # TODO(roman): Remove after the 2.9 release.\n    before_reaction_id = params[:before_reaction_user_id]\n    if before_reaction_id.blank? && params[:before_post_id]\n      before_reaction_id = params[:before_post_id]\n    end\n\n    if before_reaction_id\n      reaction_users =\n        reaction_users.where(\"discourse_reactions_reaction_users.id < ?\", before_reaction_id.to_i)\n    end\n\n    if params[:acting_username]\n      reaction_users =\n        reaction_users.joins(:user).where(users: { username: params[:acting_username] })\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20).to_a\n\n    if params[:include_likes]\n      likes =\n        PostAction\n          .where(\n            post_id: post_ids,\n            deleted_at: nil,\n            post_action_type_id: PostActionType.types[:like],\n          )\n          .order(created_at: :desc)\n          .limit(20)\n\n      if params[:before_like_id]\n        likes = likes.where(\"post_actions.id < ?\", params[:before_like_id].to_i)\n      end\n\n      if params[:acting_username]\n        likes = likes.joins(:user).where(users: { username: params[:acting_username] })\n      end\n\n      reaction_users = reaction_users.concat(translate_to_reactions(likes))\n      reaction_users = reaction_users.sort { |a, b| b.created_at <=> a.created_at }\n    end\n\n    render_serialized reaction_users.first(20), UserReactionSerializer\n  end\n\n  def post_reactions_users\n    id = params.require(:id).to_i\n    reaction_value = params[:reaction_value]\n    post = fetch_post_from_params\n\n    raise Discourse::InvalidParameters if !post\n\n    reaction_users = []\n\n    likes =\n      post.post_actions.where(\n        \"deleted_at IS NULL AND post_action_type_id = ?\",\n        PostActionType.types[:like],\n      ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n    if likes.present?\n      main_reaction =\n        DiscourseReactions::Reaction.find_by(\n          reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n          post_id: post.id,\n        )\n      count = likes.length\n      users = format_likes_users(likes)\n\n      if main_reaction && main_reaction[:reaction_users_count]\n        (users << get_users(main_reaction)).flatten!\n        users.sort_by! { |user| user[:created_at] }\n        count += main_reaction.reaction_users_count.to_i\n      end\n\n      reaction_users << {\n        id: DiscourseReactions::Reaction.main_reaction_id,\n        count: count,\n        users: users.reverse.slice(0, MAX_USERS_COUNT + 1),\n      }\n    end\n\n    if !reaction_value\n      post\n        .reactions\n        .select do |reaction|\n          reaction[:reaction_users_count] &&\n            reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id\n        end\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n      post\n        .reactions\n        .where(reaction_value: reaction_value)\n        .select { |reaction| reaction[:reaction_users_count] }\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    end\n\n    render_json_dump(reaction_users: reaction_users)\n  end\n\n  private\n\n  def get_users(reaction)\n    reaction\n      .reaction_users\n      .includes(:user)\n      .order(\"discourse_reactions_reaction_users.created_at desc\")\n      .limit(MAX_USERS_COUNT + 1)\n      .map do |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s,\n        }\n      end\n  end\n\n  def post_serializer(post)\n    PostSerializer.new(post, scope: guardian, root: false)\n  end\n\n  def format_reaction_user(reaction)\n    {\n      id: reaction.reaction_value,\n      count: reaction.reaction_users_count.to_i,\n      users: get_users(reaction),\n    }\n  end\n\n  def format_like_user(like)\n    {\n      username: like.user.username,\n      name: like.user.name,\n      avatar_template: like.user.avatar_template,\n      can_undo: guardian.can_delete_post_action?(like),\n      created_at: like.created_at.to_s,\n    }\n  end\n\n  def format_likes_users(likes)\n    likes.includes([:user]).limit(MAX_USERS_COUNT + 1).map { |like| format_like_user(like) }\n  end\n\n  def fetch_post_from_params\n    post_id = params[:post_id] || params[:id]\n    post = Post.find(post_id)\n    guardian.ensure_can_see!(post)\n    post\n  end\n\n  def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil)\n    message = { post_id: post.id, reactions: [reaction, previous_reaction].compact.uniq }\n\n    opts = {}\n    secure_audience = post.topic.secure_audience_publish_messages\n    opts = secure_audience if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != []\n\n    MessageBus.publish(\"/topic/#{post.topic.id}/reactions\", message, opts)\n  end\n\n  def secure_reaction_users!(reaction_users)\n    builder = DB.build(\"/*where*/\")\n    UserAction.filter_private_messages(builder, current_user.id, guardian)\n    UserAction.filter_categories(builder, guardian)\n    reaction_users.where(builder.to_sql.delete_prefix(\"/*where*/\").delete_prefix(\"WHERE\"))\n  end\n\n  def translate_to_reactions(likes)\n    likes.map do |like|\n      DiscourseReactions::ReactionUser.new(\n        id: like.id,\n        post: like.post,\n        user: like.user,\n        created_at: like.created_at,\n        reaction:\n          DiscourseReactions::Reaction.new(\n            id: like.id,\n            reaction_type: \"emoji\",\n            post_id: like.post_id,\n            reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n            created_at: like.created_at,\n            reaction_users_count: 1,\n          ),\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2, recipient: admin) }\n  fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:reaction_4) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n  fab!(:like) do\n    Fabricate(\n      :post_action,\n      post: post_2,\n      user: user_5,\n      post_action_type_id: PostActionType.types[:like],\n    )\n  end\n  fab!(:reaction_user_1) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2)\n  end\n  fab!(:reaction_user_2) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2)\n  end\n  fab!(:reaction_user_3) do\n    Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2)\n  end\n  fab!(:reaction_user_4) do\n    Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2)\n  end\n  fab!(:reaction_user_5) do\n    Fabricate(:reaction_user, reaction: reaction_4, user: admin, post: private_post)\n  end\n\n  before do\n    SiteSetting.discourse_reactions_enabled = true\n    SiteSetting.discourse_reactions_like_icon = \"heart\"\n    SiteSetting.discourse_reactions_enabled_reactions =\n      \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  describe \"#toggle\" do\n    let(:payload_with_user) { [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }] }\n    let(:api_key) { Fabricate(:api_key, user: admin, created_by: admin) }\n\n    it \"toggles reaction\" do\n      sign_in(user_1)\n      expected_payload = [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to not_change { DiscourseReactions::Reaction.count }.and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq([])\n    end\n\n    it \"publishes MessageBus messages\" do\n      sign_in(user_1)\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i[acted])\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\")\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/angry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\", \"angry\")\n    end\n\n    it \"publishes MessageBus messages securely\" do\n      sign_in(user_1)\n      messages =\n        MessageBus.track_publish(\"/topic/#{private_post.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{private_post.id}/custom-reactions/cry/toggle.json\",\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n        end\n      user_1_messages = messages.find { |m| m.user_ids.include?(user_1.id) }\n      expect(messages.count).to eq(1)\n      expect(user_1_messages).to eq(nil)\n    end\n\n    it \"errors when reaction is invalid\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.not_to change { DiscourseReactions::Reaction.count }\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  describe \"#reactions_given\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2) }\n    fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n    fab!(:secure_group) { Fabricate(:group) }\n    fab!(:secure_category) { Fabricate(:private_category, group: secure_group) }\n    fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n    fab!(:secure_post) { Fabricate(:post, topic: secure_topic) }\n    fab!(:private_reaction) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n    fab!(:secure_reaction) { Fabricate(:reaction, post: secure_post, reaction_value: \"hugs\") }\n    fab!(:private_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: private_reaction, user: user_2, post: private_post)\n    end\n    fab!(:secure_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: secure_reaction, user: user_2, post: secure_post)\n    end\n\n    it \"returns reactions given by a user\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_2.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_1.id)\n    end\n\n    it \"does not return reactions for private messages\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        private_post.id,\n      )\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(\n        private_post.id,\n      )\n    end\n\n    it \"does not return reactions for secure categories\" do\n      secure_group.add(user_2)\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        secure_post.id,\n      )\n\n      secure_group.add(user_1)\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n    end\n\n    describe \"a post with one of your reactions has been deleted\" do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) do\n        Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_on_kept_post) do\n        Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_user_on_deleted_post) do\n        Fabricate(\n          :reaction_user,\n          reaction: reaction_on_deleted_post,\n          user: user,\n          post: deleted_post,\n        )\n      end\n      fab!(:reaction_user_on_kept_post) do\n        Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post)\n      end\n\n      it \"doesn\u2019t return the deleted post/reaction\" do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"post_id\"]).to eq(kept_post.id)\n      end\n    end\n\n    context \"when op containing reactions is destroyed\" do\n      fab!(:topic) { create_topic }\n      fab!(:op) { Fabricate(:post, topic: topic) }\n\n      it \"doesn\u2019t return the reactions from deleted topic\" do\n        deleted_topic_id = topic.id\n        sign_in(user_1)\n        put \"/discourse-reactions/posts/#{op.id}/custom-reactions/hugs/toggle.json\"\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        expect(response.parsed_body.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, op).destroy\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"topic_id\"]).to_not eq(deleted_topic_id)\n      end\n    end\n  end\n\n  describe \"#reactions_received\" do\n    it \"returns reactions received by a user\" do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_3.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_2.id)\n    end\n\n    it \"filters by acting username\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            acting_username: user_4.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_4.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_3.id)\n    end\n\n    it \"include likes\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"also filter likes by id when including likes\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_5,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n            before_like_id: latest_like.id,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"filters likes by username\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_4,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n  end\n\n  describe \"#post_reactions_users\" do\n    it \"return reaction_users of post when theres no parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_5.avatar_template,\n      )\n    end\n\n    it \"return reaction_users of reaction when there are parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_1.avatar_template,\n      )\n    end\n\n    it \"gives 404 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(404)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"merges identic custom reaction into likes\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = \"laughing\"\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n\n    it \"does not show reaction_users on PMs without permission\" do\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows reaction_users on PMs with permission\" do\n      sign_in(user_2)\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"positive notifications\" do\n    before { PostActionNotifier.enable }\n\n    it \"creates notification when first like\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1).and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1).and change { PostAction.count }.by(-1)\n    end\n  end\n\n  describe \"reaction notifications\" do\n    it \"calls ReactinNotification service\" do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it \"allows to delete reaction only in undo action window frame\" do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to not_change { DiscourseReactions::Reaction.count }.and not_change {\n            DiscourseReactions::ReactionUser.count\n          }\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass DiscourseReactions::CustomReactionsController < ApplicationController\n  MAX_USERS_COUNT = 26\n\n  requires_plugin DiscourseReactions::PLUGIN_NAME\n\n  before_action :ensure_logged_in, except: [:post_reactions_users]\n\n  def toggle\n    post = fetch_post_from_params\n\n    unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n      return render_json_error(post)\n    end\n\n    begin\n      manager =\n        DiscourseReactions::ReactionManager.new(\n          reaction_value: params[:reaction],\n          user: current_user,\n          guardian: guardian,\n          post: post,\n        )\n      manager.toggle!\n    rescue ActiveRecord::RecordNotUnique\n      # If the user already performed this action, it's probably due to a different browser tab\n      # or non-debounced clicking. We can ignore.\n    end\n\n    post.publish_change_to_clients!(:acted)\n    publish_change_to_clients!(\n      post,\n      reaction: manager.reaction_value,\n      previous_reaction: manager.previous_reaction_value,\n    )\n\n    render_json_dump(post_serializer(post).as_json)\n  end\n\n  def reactions_given\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::InvalidAccess unless guardian.can_see_notifications?(user)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction, :post)\n        .joins(\"INNER JOIN topics t ON t.id = posts.topic_id AND t.deleted_at IS NULL\")\n        .joins(\"LEFT JOIN categories c ON c.id = t.category_id\")\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    reaction_users = secure_reaction_users!(reaction_users)\n\n    if params[:before_reaction_user_id]\n      reaction_users =\n        reaction_users.where(\n          \"discourse_reactions_reaction_users.id < ?\",\n          params[:before_reaction_user_id].to_i,\n        )\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20)\n\n    render_serialized(reaction_users.to_a, UserReactionSerializer)\n  end\n\n  def reactions_received\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::InvalidAccess unless guardian.can_see_notifications?(user)\n\n    posts = Post.joins(:topic).where(user_id: user.id)\n    posts = guardian.filter_allowed_categories(posts)\n    post_ids = posts.select(:id)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    # Guarantee backwards compatibility if someone was calling this endpoint with the old param.\n    # TODO(roman): Remove after the 2.9 release.\n    before_reaction_id = params[:before_reaction_user_id]\n    if before_reaction_id.blank? && params[:before_post_id]\n      before_reaction_id = params[:before_post_id]\n    end\n\n    if before_reaction_id\n      reaction_users =\n        reaction_users.where(\"discourse_reactions_reaction_users.id < ?\", before_reaction_id.to_i)\n    end\n\n    if params[:acting_username]\n      reaction_users =\n        reaction_users.joins(:user).where(users: { username: params[:acting_username] })\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20).to_a\n\n    if params[:include_likes]\n      likes =\n        PostAction\n          .where(\n            post_id: post_ids,\n            deleted_at: nil,\n            post_action_type_id: PostActionType.types[:like],\n          )\n          .order(created_at: :desc)\n          .limit(20)\n\n      if params[:before_like_id]\n        likes = likes.where(\"post_actions.id < ?\", params[:before_like_id].to_i)\n      end\n\n      if params[:acting_username]\n        likes = likes.joins(:user).where(users: { username: params[:acting_username] })\n      end\n\n      reaction_users = reaction_users.concat(translate_to_reactions(likes))\n      reaction_users = reaction_users.sort { |a, b| b.created_at <=> a.created_at }\n    end\n\n    render_serialized reaction_users.first(20), UserReactionSerializer\n  end\n\n  def post_reactions_users\n    id = params.require(:id).to_i\n    reaction_value = params[:reaction_value]\n    post = fetch_post_from_params\n\n    raise Discourse::InvalidParameters if !post\n\n    reaction_users = []\n\n    likes =\n      post.post_actions.where(\n        \"deleted_at IS NULL AND post_action_type_id = ?\",\n        PostActionType.types[:like],\n      ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n    if likes.present?\n      main_reaction =\n        DiscourseReactions::Reaction.find_by(\n          reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n          post_id: post.id,\n        )\n      count = likes.length\n      users = format_likes_users(likes)\n\n      if main_reaction && main_reaction[:reaction_users_count]\n        (users << get_users(main_reaction)).flatten!\n        users.sort_by! { |user| user[:created_at] }\n        count += main_reaction.reaction_users_count.to_i\n      end\n\n      reaction_users << {\n        id: DiscourseReactions::Reaction.main_reaction_id,\n        count: count,\n        users: users.reverse.slice(0, MAX_USERS_COUNT + 1),\n      }\n    end\n\n    if !reaction_value\n      post\n        .reactions\n        .select do |reaction|\n          reaction[:reaction_users_count] &&\n            reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id\n        end\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n      post\n        .reactions\n        .where(reaction_value: reaction_value)\n        .select { |reaction| reaction[:reaction_users_count] }\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    end\n\n    render_json_dump(reaction_users: reaction_users)\n  end\n\n  private\n\n  def get_users(reaction)\n    reaction\n      .reaction_users\n      .includes(:user)\n      .order(\"discourse_reactions_reaction_users.created_at desc\")\n      .limit(MAX_USERS_COUNT + 1)\n      .map do |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s,\n        }\n      end\n  end\n\n  def post_serializer(post)\n    PostSerializer.new(post, scope: guardian, root: false)\n  end\n\n  def format_reaction_user(reaction)\n    {\n      id: reaction.reaction_value,\n      count: reaction.reaction_users_count.to_i,\n      users: get_users(reaction),\n    }\n  end\n\n  def format_like_user(like)\n    {\n      username: like.user.username,\n      name: like.user.name,\n      avatar_template: like.user.avatar_template,\n      can_undo: guardian.can_delete_post_action?(like),\n      created_at: like.created_at.to_s,\n    }\n  end\n\n  def format_likes_users(likes)\n    likes.includes([:user]).limit(MAX_USERS_COUNT + 1).map { |like| format_like_user(like) }\n  end\n\n  def fetch_post_from_params\n    post_id = params[:post_id] || params[:id]\n    post = Post.find(post_id)\n    guardian.ensure_can_see!(post)\n    post\n  end\n\n  def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil)\n    message = { post_id: post.id, reactions: [reaction, previous_reaction].compact.uniq }\n\n    opts = {}\n    secure_audience = post.topic.secure_audience_publish_messages\n    opts = secure_audience if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != []\n\n    MessageBus.publish(\"/topic/#{post.topic.id}/reactions\", message, opts)\n  end\n\n  def secure_reaction_users!(reaction_users)\n    builder = DB.build(\"/*where*/\")\n    UserAction.filter_private_messages(builder, current_user.id, guardian)\n    UserAction.filter_categories(builder, guardian)\n    reaction_users.where(builder.to_sql.delete_prefix(\"/*where*/\").delete_prefix(\"WHERE\"))\n  end\n\n  def translate_to_reactions(likes)\n    likes.map do |like|\n      DiscourseReactions::ReactionUser.new(\n        id: like.id,\n        post: like.post,\n        user: like.user,\n        created_at: like.created_at,\n        reaction:\n          DiscourseReactions::Reaction.new(\n            id: like.id,\n            reaction_type: \"emoji\",\n            post_id: like.post_id,\n            reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n            created_at: like.created_at,\n            reaction_users_count: 1,\n          ),\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2, recipient: admin) }\n  fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:reaction_4) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n  fab!(:like) do\n    Fabricate(\n      :post_action,\n      post: post_2,\n      user: user_5,\n      post_action_type_id: PostActionType.types[:like],\n    )\n  end\n  fab!(:reaction_user_1) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2)\n  end\n  fab!(:reaction_user_2) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2)\n  end\n  fab!(:reaction_user_3) do\n    Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2)\n  end\n  fab!(:reaction_user_4) do\n    Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2)\n  end\n  fab!(:reaction_user_5) do\n    Fabricate(:reaction_user, reaction: reaction_4, user: admin, post: private_post)\n  end\n\n  before do\n    SiteSetting.discourse_reactions_enabled = true\n    SiteSetting.discourse_reactions_like_icon = \"heart\"\n    SiteSetting.discourse_reactions_enabled_reactions =\n      \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  describe \"#toggle\" do\n    let(:payload_with_user) { [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }] }\n    let(:api_key) { Fabricate(:api_key, user: admin, created_by: admin) }\n\n    it \"toggles reaction\" do\n      sign_in(user_1)\n      expected_payload = [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to not_change { DiscourseReactions::Reaction.count }.and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq([])\n    end\n\n    it \"publishes MessageBus messages\" do\n      sign_in(user_1)\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i[acted])\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\")\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/angry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\", \"angry\")\n    end\n\n    it \"publishes MessageBus messages securely\" do\n      sign_in(user_1)\n      messages =\n        MessageBus.track_publish(\"/topic/#{private_post.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{private_post.id}/custom-reactions/cry/toggle.json\",\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n        end\n      user_1_messages = messages.find { |m| m.user_ids.include?(user_1.id) }\n      expect(messages.count).to eq(1)\n      expect(user_1_messages).to eq(nil)\n    end\n\n    it \"errors when reaction is invalid\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.not_to change { DiscourseReactions::Reaction.count }\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  describe \"#reactions_given\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2) }\n    fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n    fab!(:secure_group) { Fabricate(:group) }\n    fab!(:secure_category) { Fabricate(:private_category, group: secure_group) }\n    fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n    fab!(:secure_post) { Fabricate(:post, topic: secure_topic) }\n    fab!(:private_reaction) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n    fab!(:secure_reaction) { Fabricate(:reaction, post: secure_post, reaction_value: \"hugs\") }\n    fab!(:private_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: private_reaction, user: user_2, post: private_post)\n    end\n    fab!(:secure_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: secure_reaction, user: user_2, post: secure_post)\n    end\n\n    it \"returns reactions given by a user when current user is admin\" do\n      sign_in(admin)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      expect(response.status).to eq(200)\n\n      parsed = response.parsed_body\n      expect(parsed[2][\"user\"][\"id\"]).to eq(user_2.id)\n      expect(parsed[2][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[2][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[2][\"reaction\"][\"id\"]).to eq(reaction_1.id)\n    end\n\n    it \"does not return reactions for private messages of other users\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      expect(response.status).to eq(403)\n    end\n\n    it \"returns reactions for private messages of current user\" do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(\n        private_post.id,\n      )\n    end\n\n    it \"does not return reactions for secure categories\" do\n      secure_group.add(user_2)\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      expect(response.status).to eq(403)\n\n      secure_group.add(user_1)\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      expect(response.status).to eq(403)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n    end\n\n    describe \"a post with one of your reactions has been deleted\" do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) do\n        Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_on_kept_post) do\n        Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_user_on_deleted_post) do\n        Fabricate(\n          :reaction_user,\n          reaction: reaction_on_deleted_post,\n          user: user,\n          post: deleted_post,\n        )\n      end\n      fab!(:reaction_user_on_kept_post) do\n        Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post)\n      end\n\n      it \"doesn\u2019t return the deleted post/reaction\" do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"post_id\"]).to eq(kept_post.id)\n      end\n    end\n\n    context \"when op containing reactions is destroyed\" do\n      fab!(:topic) { create_topic }\n      fab!(:op) { Fabricate(:post, topic: topic) }\n\n      it \"doesn\u2019t return the reactions from deleted topic\" do\n        deleted_topic_id = topic.id\n        sign_in(user_1)\n        put \"/discourse-reactions/posts/#{op.id}/custom-reactions/hugs/toggle.json\"\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        expect(response.parsed_body.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, op).destroy\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"topic_id\"]).to_not eq(deleted_topic_id)\n      end\n    end\n  end\n\n  describe \"#reactions_received\" do\n    it \"returns reactions received by a user when current user is admin\" do\n      sign_in(admin)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_3.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_2.id)\n    end\n\n    it \"does not return reactions received by a user when current user is not an admin\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_2.username,\n          }\n\n      expect(response.status).to eq(403)\n    end\n\n    it \"filters by acting username\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            acting_username: user_4.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_4.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_3.id)\n    end\n\n    it \"include likes\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"also filter likes by id when including likes\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_5,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n            before_like_id: latest_like.id,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"filters likes by username\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_4,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n  end\n\n  describe \"#post_reactions_users\" do\n    it \"return reaction_users of post when theres no parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_5.avatar_template,\n      )\n    end\n\n    it \"return reaction_users of reaction when there are parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_1.avatar_template,\n      )\n    end\n\n    it \"gives 404 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(404)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"merges identic custom reaction into likes\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = \"laughing\"\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n\n    it \"does not show reaction_users on PMs without permission\" do\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows reaction_users on PMs with permission\" do\n      sign_in(user_2)\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"positive notifications\" do\n    before { PostActionNotifier.enable }\n\n    it \"creates notification when first like\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1).and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1).and change { PostAction.count }.by(-1)\n    end\n  end\n\n  describe \"reaction notifications\" do\n    it \"calls ReactinNotification service\" do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it \"allows to delete reaction only in undo action window frame\" do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to not_change { DiscourseReactions::Reaction.count }.and not_change {\n            DiscourseReactions::ReactionUser.count\n          }\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "filenames": ["app/controllers/discourse_reactions/custom_reactions_controller.rb", "spec/requests/custom_reactions_controller_spec.rb"], "buggy_code_start_loc": [48, 170], "buggy_code_end_loc": [82, 296], "fixing_code_start_loc": [48, 170], "fixing_code_end_loc": [82, 304], "type": "CWE-284", "message": "Discourse-reactions is a plugin that allows user to add their reactions to the post. Data about a user's reaction notifications could be exposed. This vulnerability was patched in commit 2c26939.", "other": {"cve": {"id": "CVE-2023-49098", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-12T21:15:09.540", "lastModified": "2024-01-25T15:44:43.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse-reactions is a plugin that allows user to add their reactions to the post. Data about a user's reaction notifications could be exposed. This vulnerability was patched in commit 2c26939."}, {"lang": "es", "value": "Discourse-reactions es un complemento que permite al usuario agregar sus reacciones a la publicaci\u00f3n. Los datos sobre las notificaciones de reacci\u00f3n de un usuario podr\u00edan quedar expuestos. Esta vulnerabilidad fue parcheada en el commit 2c26939."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_reactions:*:*:*:*:*:discourse:*:*", "versionEndIncluding": "0.4", "matchCriteriaId": "6D7031E2-271E-43D4-98C0-21804A0D5358"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-reactions/commit/2c26939395177730e492640d71aac68423be84fc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-reactions/security/advisories/GHSA-mq82-7v5x-rhv8", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-reactions/commit/2c26939395177730e492640d71aac68423be84fc"}}