{"buggy_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\Appointment\\CreateAppointmentCalendarRequest;\nuse App\\Http\\Requests\\Appointment\\UpdateAppointmentCalendarRequest;\nuse App\\Models\\Appointment;\nuse App\\Models\\User;\nuse App\\Models\\Client;\nuse Carbon\\Carbon;\nuse Illuminate\\Http\\Request;\nuse Ramsey\\Uuid\\Uuid;\n\nclass AppointmentsController extends Controller\n{\n    public function calendar()\n    {\n        return view('appointments.calendar');\n    }\n\n    public function appointmentsJson()\n    {\n        return Appointment::with(['user:id,name,external_id', 'user.department:name'])\n            ->whereBetween('start_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n            ->orWhereBetween('end_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n                ->get();\n    }\n\n    public function update(UpdateAppointmentCalendarRequest $request, Appointment $appointment)\n    {\n        $appointment->start_at = Carbon::parse($request->start)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->end_at = Carbon::parse($request->end)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->user()->associate(User::where('external_id', $request->group)->first());\n        $appointment->save();\n\n        return response($appointment);\n    }\n\n    public function store(CreateAppointmentCalendarRequest $request)\n    {\n \n        $client_id = null;\n        $user = User::where('external_id', $request->user)->first();\n\n        if ($request->client_external_id) {\n            $client_id = Client::where('external_id', $request->client_external_id)->first()->id;\n            if (!$client_id) {\n                return response(__(\"Client not found\"), 422);\n            }\n        }\n\n        $request_type = null;\n        $request_id = null;\n        if ($request->source_type && $request->source_external_id) {\n            $request_type = $request->source_type;\n\n            $entry = $request_type::whereExternalId($request->source_external_id);\n            $request_id = $entry->id;\n        }\n\n        if (!$user) {\n            return response(__(\"User not found\"), 422);\n        }\n\n        $startTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->start_time) . ':00';\n        $endTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->end_time) . ':00';\n\n     \n\n        $appointment = Appointment::create([\n            'external_id' => Uuid::uuid4()->toString(),\n            'source_type' => $request_type,\n            'source_id' => $request_id,\n            'client_id' => $client_id,\n            'title' => $request->title,\n            'start_at' => Carbon::parse($request->start_date . \" \" . $startTime),\n            'end_at' => Carbon::parse($request->end_date . \" \" . $endTime),\n            'user_id' => $user->id,\n            'color' => $request->color\n        ]);\n        $appointment->user_external_id = $user->external_id;\n        $appointment->start_at = $appointment->start_at;\n\n        return response($appointment);\n    }\n\n    public function destroy(Appointment $appointment)\n    {\n        if (!auth()->user()->can(\"appointment-create\")) {\n            return response(\"Access denied\", 403);\n        }\n\n        $deleted = $appointment->delete();\n        if ($deleted) {\n            return response(\"Success\");\n        }\n        return response(\"Error\", 503);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass StoreUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-create');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'required|min:5|confirmed',\n            'password_confirmation' => 'required|min:5',\n            'image_path' => '',\n            'roles' => 'required',\n            'departments' => 'required'\n        ];\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-update');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'sometimes',\n            'password_confirmation' => 'sometimes',\n            'image_path' => '',\n            'departments' => 'required'\n        ];\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\Appointment\\CreateAppointmentCalendarRequest;\nuse App\\Http\\Requests\\Appointment\\UpdateAppointmentCalendarRequest;\nuse App\\Models\\Appointment;\nuse App\\Models\\User;\nuse App\\Models\\Client;\nuse Carbon\\Carbon;\nuse Illuminate\\Http\\Request;\nuse Ramsey\\Uuid\\Uuid;\n\nclass AppointmentsController extends Controller\n{\n    public function calendar()\n    {\n        if (!auth()->user()->can(\"calendar-view\")) {\n            session()->flash('flash_message_warning', __('You do not have permission to view this page'));\n            return redirect()->back();\n        }\n        return view('appointments.calendar');\n    }\n\n    public function appointmentsJson()\n    {\n        return Appointment::with(['user:id,name,external_id', 'user.department:name'])\n            ->whereBetween('start_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n            ->orWhereBetween('end_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n                ->get();\n    }\n\n    public function update(UpdateAppointmentCalendarRequest $request, Appointment $appointment)\n    {\n        $appointment->start_at = Carbon::parse($request->start)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->end_at = Carbon::parse($request->end)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->user()->associate(User::where('external_id', $request->group)->first());\n        $appointment->save();\n\n        return response($appointment);\n    }\n\n    public function store(CreateAppointmentCalendarRequest $request)\n    {\n        $client_id = null;\n        $user = User::where('external_id', $request->user)->first();\n\n        if ($request->client_external_id) {\n            $client_id = Client::where('external_id', $request->client_external_id)->first()->id;\n            if (!$client_id) {\n                return response(__(\"Client not found\"), 422);\n            }\n        }\n\n        $request_type = null;\n        $request_id = null;\n        if ($request->source_type && $request->source_external_id) {\n            $request_type = $request->source_type;\n\n            $entry = $request_type::whereExternalId($request->source_external_id);\n            $request_id = $entry->id;\n        }\n\n        if (!$user) {\n            return response(__(\"User not found\"), 422);\n        }\n\n        $startTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->start_time) . ':00';\n        $endTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->end_time) . ':00';\n\n     \n\n        $appointment = Appointment::create([\n            'external_id' => Uuid::uuid4()->toString(),\n            'source_type' => $request_type,\n            'source_id' => $request_id,\n            'client_id' => $client_id,\n            'title' => $request->title,\n            'start_at' => Carbon::parse($request->start_date . \" \" . $startTime),\n            'end_at' => Carbon::parse($request->end_date . \" \" . $endTime),\n            'user_id' => $user->id,\n            'color' => $request->color\n        ]);\n        $appointment->user_external_id = $user->external_id;\n        $appointment->start_at = $appointment->start_at;\n\n        return response($appointment);\n    }\n\n    public function destroy(Appointment $appointment)\n    {\n        if (!auth()->user()->can(\"appointment-delete\")) {\n            return response(\"Access denied\", 403);\n        }\n\n        $deleted = $appointment->delete();\n        if ($deleted) {\n            return response(\"Success\");\n        }\n        return response(\"Error\", 503);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass StoreUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-create');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'required|min:6|confirmed',\n            'password_confirmation' => 'required|min:6',\n            'image_path' => '',\n            'roles' => 'required',\n            'departments' => 'required'\n        ];\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-update');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'sometimes|min:6|confirmed',\n            'password_confirmation' => 'sometimes|min:6',\n            'image_path' => '',\n            'departments' => 'required'\n        ];\n    }\n}\n"], "filenames": ["app/Http/Controllers/AppointmentsController.php", "app/Http/Requests/User/StoreUserRequest.php", "app/Http/Requests/User/UpdateUserRequest.php"], "buggy_code_start_loc": [17, 32, 32], "buggy_code_end_loc": [90, 34, 34], "fixing_code_start_loc": [18, 32, 32], "fixing_code_end_loc": [93, 34, 34], "type": "CWE-521", "message": "In Daybyday CRM, versions 1.1 through 2.2.0 enforce weak password requirements in the user update functionality. A user with privileges to update his password could change it to a weak password, such as those with a length of a single character. This may allow an attacker to brute-force users\u2019 passwords with minimal to no computational effort.", "other": {"cve": {"id": "CVE-2022-22110", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-01-05T15:15:07.923", "lastModified": "2022-01-21T14:24:35.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Daybyday CRM, versions 1.1 through 2.2.0 enforce weak password requirements in the user update functionality. A user with privileges to update his password could change it to a weak password, such as those with a length of a single character. This may allow an attacker to brute-force users\u2019 passwords with minimal to no computational effort."}, {"lang": "es", "value": "En Daybyday CRM, versiones 1.1 a 2.2.0, imponen requisitos de contrase\u00f1a d\u00e9biles en la funcionalidad user update. Un usuario con privilegios para actualizar su contrase\u00f1a podr\u00eda cambiarla por una contrase\u00f1a d\u00e9bil, como las que presentan una longitud de un solo car\u00e1cter. Esto podr\u00eda permitir a un atacante forzar las contrase\u00f1as de los usuarios con un esfuerzo computacional m\u00ednimo o nulo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-521"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-521"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:daybydaycrm:daybyday_crm:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndIncluding": "2.2.0", "matchCriteriaId": "7C4701D6-2257-487B-8037-51B4B3AA90B5"}]}]}], "references": [{"url": "https://github.com/Bottelet/DaybydayCRM/commit/a0392f4a4a14e1e3fedaf6817aefce69b6bd661b", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2022-22110", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Bottelet/DaybydayCRM/commit/a0392f4a4a14e1e3fedaf6817aefce69b6bd661b"}}