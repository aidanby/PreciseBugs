{"buggy_code": ["/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"RegisteredHeaders.h\"\n\n#include <ostream>\n#include <vector>\n\nnamespace Http\n{\n/* glue to code generated by gperf */\n#include \"http/RegisteredHeadersHash.cci\"\n\nHeaderTableRecord::HeaderTableRecord() :\n    name(\"\"), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),\n    list(false), request(false), reply(false), hopbyhop(false), denied304(false)\n{}\n\nHeaderTableRecord::HeaderTableRecord(const char *n) :\n    name(n), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),\n    list(false), request(false), reply(false), hopbyhop(false), denied304(false)\n{}\n\nHeaderTableRecord::HeaderTableRecord(const char *n, HdrType theId, HdrFieldType theType, int theKind) :\n    name(n), id(theId), type(theType),\n    list(theKind & HdrKind::ListHeader), request(theKind & HdrKind::RequestHeader),\n    reply(theKind & HdrKind::ReplyHeader), hopbyhop(theKind & HdrKind::HopByHopHeader),\n    denied304(theKind & HdrKind::Denied304Header)\n{}\n\nconst HeaderTableRecord&\nHeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {\n    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);\n    if (!r)\n        return BadHdr;\n    return *r;\n}\nconst HeaderTableRecord HeaderLookupTable_t::BadHdr {\"*INVALID*:\", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None};\n\nHeaderLookupTable_t::HeaderLookupTable_t()\n{\n    initCache();\n}\n\nvoid\nHeaderLookupTable_t::initCache()\n{\n    idCache.resize(TOTAL_KEYWORDS);\n    for (int j = MIN_HASH_VALUE; j <= MAX_HASH_VALUE; ++j) { //MAX_HASH_VALUE is exported by gperf\n        if (HttpHeaderDefinitionsTable[j].name[0] != '\\0') { //some slots are empty\n            idCache[static_cast<int>(HttpHeaderDefinitionsTable[j].id)] =\n                & HttpHeaderDefinitionsTable[j];\n        }\n    }\n    //check after the fact. The cache array must be full\n    for (auto e : idCache) {\n        assert(e->name);\n    }\n}\nconst HeaderLookupTable_t HeaderLookupTable;\n\n}; /* namespace Http */\n\nstd::ostream&\noperator<< (std::ostream &s, Http::HdrType id)\n{\n    if (Http::any_HdrType_enum_value(id))\n        s << Http::HeaderLookupTable.lookup(id).name << '[' << static_cast<int>(id) << ']';\n    else\n        s << \"Invalid-Header[\" << static_cast<int>(id) << ']';\n    return s;\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#include \"squid.h\"\n#include \"RegisteredHeaders.h\"\n\n#include <ostream>\n#include <vector>\n\nnamespace Http\n{\n/* glue to code generated by gperf */\n#include \"http/RegisteredHeadersHash.cci\"\n\nHeaderTableRecord::HeaderTableRecord() :\n    name(\"\"), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),\n    list(false), request(false), reply(false), hopbyhop(false), denied304(false)\n{}\n\nHeaderTableRecord::HeaderTableRecord(const char *n) :\n    name(n), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),\n    list(false), request(false), reply(false), hopbyhop(false), denied304(false)\n{}\n\nHeaderTableRecord::HeaderTableRecord(const char *n, HdrType theId, HdrFieldType theType, int theKind) :\n    name(n), id(theId), type(theType),\n    list(theKind & HdrKind::ListHeader), request(theKind & HdrKind::RequestHeader),\n    reply(theKind & HdrKind::ReplyHeader), hopbyhop(theKind & HdrKind::HopByHopHeader),\n    denied304(theKind & HdrKind::Denied304Header)\n{}\n\nconst HeaderTableRecord&\nHeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {\n    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);\n    if (!r || r->id == Http::HdrType::OTHER)\n        return BadHdr;\n    return *r;\n}\nconst HeaderTableRecord HeaderLookupTable_t::BadHdr {\"*INVALID*:\", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None};\n\nHeaderLookupTable_t::HeaderLookupTable_t()\n{\n    initCache();\n}\n\nvoid\nHeaderLookupTable_t::initCache()\n{\n    idCache.resize(TOTAL_KEYWORDS);\n    for (int j = MIN_HASH_VALUE; j <= MAX_HASH_VALUE; ++j) { //MAX_HASH_VALUE is exported by gperf\n        if (HttpHeaderDefinitionsTable[j].name[0] != '\\0') { //some slots are empty\n            idCache[static_cast<int>(HttpHeaderDefinitionsTable[j].id)] =\n                & HttpHeaderDefinitionsTable[j];\n        }\n    }\n    //check after the fact. The cache array must be full\n    for (auto e : idCache) {\n        assert(e->name);\n    }\n}\nconst HeaderLookupTable_t HeaderLookupTable;\n\n}; /* namespace Http */\n\nstd::ostream&\noperator<< (std::ostream &s, Http::HdrType id)\n{\n    if (Http::any_HdrType_enum_value(id))\n        s << Http::HeaderLookupTable.lookup(id).name << '[' << static_cast<int>(id) << ']';\n    else\n        s << \"Invalid-Header[\" << static_cast<int>(id) << ']';\n    return s;\n}\n\n"], "filenames": ["src/http/RegisteredHeaders.cc"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [41], "fixing_code_start_loc": [40], "fixing_code_end_loc": [41], "type": "CWE-116", "message": "An issue was discovered in Squid 4.x before 4.15 and 5.x before 5.0.6. If a remote server sends a certain response header over HTTP or HTTPS, there is a denial of service. This header can plausibly occur in benign network traffic.", "other": {"cve": {"id": "CVE-2021-28662", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-27T12:15:08.263", "lastModified": "2022-04-19T03:56:27.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Squid 4.x before 4.15 and 5.x before 5.0.6. If a remote server sends a certain response header over HTTP or HTTPS, there is a denial of service. This header can plausibly occur in benign network traffic."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Squid versiones 4.x anteriores a 4.15 y versiones 5.x anteriores a 5.0.6.&#xa0;Si un servidor remoto env\u00eda un determinado encabezado de respuesta por medio de HTTP o HTTPS, ocurre una denegaci\u00f3n de servicio.&#xa0;Este encabezado puede ocurrir plausiblemente en tr\u00e1fico de red benigno"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.1", "versionEndExcluding": "4.15", "matchCriteriaId": "B5A199CF-E7E1-44D4-8A5A-BEA6DFEB35ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.0.6", "matchCriteriaId": "68801A75-0B13-444A-B88F-8BDD4EE953D3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v6/changesets/squid-6-051824924c709bd6162a378f746fb859454c674e.patch", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/squid-cache/squid/commit/051824924c709bd6162a378f746fb859454c674e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-jjq6-mh2h-g39h", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSQ3U54ZCNXR44QRPW3AV2VCS6K3TKCF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T4EPIWUZDJAXADDHVOPKRBTQHPBR6H66/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4924", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/051824924c709bd6162a378f746fb859454c674e"}}