{"buggy_code": ["/* sternenblog\n * A small file based blog software\n * intended to run as a CGI script\n * written in C by Lukas Epple aka\n * sternenseemann */\n#define _POSIX_C_SOURCE 200809L\n#define _XOPEN_SOURCE 501\n#include <stdio.h>\n#include <stdlib.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <string.h>\n#include <errno.h>\n#include <time.h>\n#include \"template.h\"\n#include \"config.h\"\n\n/* returns a blogpost struct\n * for a path */\nstruct blogpost make_blogpost(char path[]);\n\n/* constructs a path from a dirent\n * and calls make_blogpost */\nstruct blogpost make_blogpost_from_dirent(struct dirent *file);\n\n/* generates the template\n * for the index page */\nvoid blog_index(void);\n\n/* generates the template for \n * a single view of a blog post*/\nvoid blog_post(char post_path[]);\n\n/* generates the rss feed */\nvoid blog_rss(void);\n/* checks if a file exists\n * returns 0 if not\n * returns 1 if\n * returns -1 if the file isn't accesible\n * for some other reason */\nint file_exists(char path[]);\n\n/* sends a CGI/HTTP header */\nvoid send_header(char key[], char val[]);\n\n/* terminates the header section of a\n * CGI/HTTP Response */\nvoid terminate_headers(void);\n\n/* function that filters out the .files\n * for scandir */\nint no_dotfiles(const struct dirent *file);\n\nint main(void) {\n\tchar *path_info = getenv(\"PATH_INFO\");\n\t\n\tif(path_info == NULL || path_info[0] == '\\0' || strcmp(path_info, \"/\") == 0) {\n\t\tblog_index();\n\t} else if(strcmp(path_info, \"/rss.xml\") == 0) {\n\t\tblog_rss();\n\t} else {\n\t\tunsigned long bufsize = strlen(BLOG_DIR) + strlen(path_info);\n\t\tchar post_path[bufsize];\n\t\tstrcpy(post_path, BLOG_DIR);\n\t\tstrcat(post_path, path_info);\n\n\t\tblog_post(post_path);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n/**************************\n * functions for dealing\n * with struct blogpost's\n *************************/\n\nstruct blogpost make_blogpost(char path[]) {\n\tstruct tm blog_tm;\n\tmemset(&blog_tm, 0, sizeof blog_tm);\n\n\tstruct blogpost struct_to_return;\n\n\n\t\n\t/* find the last '/' to\n\t * get 2014-12-12-12-12-lala\n\t * from /path/to/2014-12-12-12-12-lala */\n\n\tchar *last_slash_position = strrchr(path, '/');\n\tif(last_slash_position == NULL) {\n\t\tfprintf(stderr, \"There's something incredibly wrong with the path (%s) supplied to make_blogpost\\n\", path);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* this parses the filename that is linke\n\t * year-month-day-hour-minute-title */\n\n\t/* the string in the time part of the path */\n\tchar time_string[4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1];\n\tstrncpy(time_string, last_slash_position + 1, sizeof time_string - 1);\n\ttime_string[sizeof time_string - 1] = '\\0';\n\n\tstrptime(time_string, \"%Y-%m-%d-%H-%M\", &blog_tm);\n\n\tstruct_to_return.timestamp = mktime(&blog_tm);\n\tstruct_to_return.path = malloc(strlen(path) * sizeof(char));\n\tstrcpy(struct_to_return.path, path);\n\n\t/* let's build up the link */\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tint bufsize = strlen(script_name) +\n\t\tstrlen(last_slash_position) + 1;\n\tstruct_to_return.link = malloc(sizeof(char) * bufsize);\n\tstrcpy(struct_to_return.link, script_name);\n\tstrcat(struct_to_return.link, last_slash_position);\n\n\t/* that's all */\n\n\treturn struct_to_return;\n}\n\nstruct blogpost make_blogpost_from_dirent(struct dirent *post) {\n\tint bufsize = strlen(BLOG_DIR) + 1 + strlen(post->d_name) + 1;\n\tchar buf[bufsize];\n\n\tstrcpy(buf, BLOG_DIR);\n\tstrcat(buf, \"/\");\n\tstrcat(buf, post->d_name);\n\n\treturn make_blogpost(buf);\n}\n\nvoid free_blogpost(struct blogpost to_free) {\n\tfree(to_free.path);\n\tfree(to_free.link);\n\t/* the rest lies in stack mem */\n}\n\n/************************\n * wrapper functions for\n * template generation\n ***********************/\n\nvoid blog_index(void) {\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tstruct dirent **dirlist;\n\tint dircount;\n\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_header(\"Content-type\", \"text/html\");\n\tterminate_headers();\n\n\ttemplate_header();\n\n\tdircount = scandir(BLOG_DIR, &dirlist, no_dotfiles, alphasort);\t\n\n\tif(dircount < 0) {\n\t\tfprintf(stderr, \"An error occurred while scanning %s: %s\\n\", \n\t\t\t\tBLOG_DIR, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile(dircount--) {\n\t\tstruct blogpost post = make_blogpost_from_dirent(dirlist[dircount]);\n\n\t\t/* finally if the file exists call the\n\t\t * template function. Otherwise\n\t\t * we do nothing. (this case is also\n\t\t * FUCKING unlikely */\n\t\tif(file_exists(post.path) > 0) {\n\t\t\ttemplate_post_index_entry(post);\n\t\t}\n\t\t\n\t\tfree_blogpost(post);\n\t\tfree(dirlist[dircount]);\n\t}\n\tfree(dirlist);\n\n\ttemplate_footer();\n}\n\nvoid blog_post(char post_path[]) {\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\n\ttemplate_footer();\n}\n\nvoid blog_rss(void) {\n\tstruct dirent **dirlist;\n\tint dircount;\n\t\n\t/* construct the time,\n\t * the blogpost was\n\t * created */\n\ttime_t timestamp;\n\tstruct tm *timeinfo;\n\tchar strtime_now[512];\n\n\ttime(&timestamp);\n\ttimeinfo = localtime(&timestamp);\n\n\tstrftime(strtime_now, sizeof strtime_now, \"%a, %d %b %G %T %z\", timeinfo);\n\n\t\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* build the top part\n\t * of the rss-feed */\n\tsend_header(\"Content-type\", \"application/rss+xml\");\n\tterminate_headers();\n\n\tprintf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"\n\t       \"<rss version=\\\"2.0\\\">\\n\"\n\t       \"<channel>\\n\"\n\t       \"\\t<title>%s</title>\\n\"\n\t       \"\\t<description>%s</description>\\n\"\n\t       \"\\t<link>\" BLOG_SERVER_URL \"%s</link>\\n\"\n\t       \"\\t<lastBuildDate>%s</lastBuildDate>\\n\"\n\t       \"\\t<pubDate>%s</pubDate>\\n\"\n\t       \"\\t<ttl>%d</ttl>\\n\",\n\t       BLOG_TITLE, BLOG_DESCRIPTION, \n\t       script_name,\n\t       strtime_now, strtime_now,\n\t       BLOG_RSS_TTL);\n\n\tdircount = scandir(BLOG_DIR, &dirlist, no_dotfiles, alphasort);\n\n\tif(dircount < 0) {\n\t\tfprintf(stderr, \"An error occurred while scanning %s: %s\\n\",\n\t\t\t\tBLOG_DIR, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile(dircount--) {\n\t\tstruct blogpost post;\n\t\tpost = make_blogpost_from_dirent(dirlist[dircount]);\n\t\tchar *last_slash_position = strrchr(post.path, '/');\n\t\t\n\t\tif(last_slash_position == NULL) {\n\t\t\tfprintf(stderr, \"Malformed path %s in blog_rss\\n\", post.path);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tFILE *fp = fopen(post.path, \"r\");\n\t\tchar c;\n\t\tif(fp == NULL) {\n\t\t\tfprintf(stderr, \"Could not open file: %s: %s\\n\",\n\t\t\t\t\tpost.path, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tstruct tm *timeinfo = localtime(&post.timestamp);\n\t\tchar strtime_post[512];\n\t\tstrftime(strtime_post, sizeof strtime_post, \"%a, %d %b %G %T %z\", timeinfo);\n\t\t\n\t\tprintf(\"\\t<item>\\n\"\n\t\t       \"\\t\\t<title>%s</title>\\n\"\n\t\t       \"\\t\\t<description><![CDATA[\",\n\t\t       last_slash_position + 1);\n\n\t\twhile((c = getc(fp)) != EOF) {\n\t\t\tprintf(\"%c\", c);\n\t\t}\n\t\t\n\t\tfclose(fp);\n\n\t\tprintf(\"]]></description>\\n\"\n\t\t       \"\\t\\t<link>\" BLOG_SERVER_URL \"%s</link>\\n\"\n\t\t       \"\\t\\t<guid>\" BLOG_SERVER_URL \"%s</guid>\\n\"\n\t\t       \"\\t\\t<pubDate>%s</pubDate>\\n\"\n\t\t       \"\\t</item>\\n\",\n\t\t       post.link, post.link, strtime_post);\n\n\t\tfree_blogpost(post);\n\t\tfree(dirlist[dircount]);\n\t}\n\n\tfree(dirlist);\n\n\tprintf(\"</channel>\\n</rss>\\n\");\n}\n\nint file_exists(char path[]) {\n\tFILE *fp = fopen(path, \"r\");\n\n\tif(fp == NULL && errno == ENOENT) {\n\t\treturn 0;\n\t} else if(fp == NULL) {\n\t\t// some other error occured\n\t\treturn -1;\n\t} else {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n}\n\n/*********************\n * header utilities \n ********************/\nvoid send_header(char key[], char val[]) {\n\tprintf(\"%s: %s\\n\", key, val);\n}\n\nvoid terminate_headers(void) {\n\tprintf(\"\\n\");\n}\n\n/******************************\n * filter function\n * for scandir(3)\n *****************************/\n\nint no_dotfiles(const struct dirent *file) {\n\tif(file->d_name[0] == '.') {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n"], "fixing_code": ["/* sternenblog\n * A small file based blog software\n * intended to run as a CGI script\n * written in C by Lukas Epple aka\n * sternenseemann */\n#define _POSIX_C_SOURCE 200809L\n#define _XOPEN_SOURCE 501\n#include <stdio.h>\n#include <stdlib.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <string.h>\n#include <errno.h>\n#include <time.h>\n#include \"template.h\"\n#include \"config.h\"\n\n/* returns a blogpost struct\n * for a path */\nstruct blogpost make_blogpost(char path[]);\n\n/* constructs a path from a dirent\n * and calls make_blogpost */\nstruct blogpost make_blogpost_from_dirent(struct dirent *file);\n\n/* generates the template\n * for the index page */\nvoid blog_index(void);\n\n/* generates the template for \n * a single view of a blog post*/\nvoid blog_post(char post_path[]);\n\n/* generates the rss feed */\nvoid blog_rss(void);\n/* checks if a file exists\n * returns 0 if not\n * returns 1 if\n * returns -1 if the file isn't accesible\n * for some other reason */\nint file_exists(char path[]);\n\n/* sends a CGI/HTTP header */\nvoid send_header(char key[], char val[]);\n\n/* terminates the header section of a\n * CGI/HTTP Response */\nvoid terminate_headers(void);\n\n/* function that filters out the .files\n * for scandir */\nint no_dotfiles(const struct dirent *file);\n\nint main(void) {\n\tchar *path_info = getenv(\"PATH_INFO\");\n\t\n\tif(path_info == NULL || path_info[0] == '\\0' || strcmp(path_info, \"/\") == 0) {\n\t\tblog_index();\n\t} else if(strcmp(path_info, \"/rss.xml\") == 0) {\n\t\tblog_rss();\n\t} else {\n\t\tunsigned long bufsize = strlen(BLOG_DIR) + strlen(path_info);\n\t\tchar post_path[bufsize];\n\t\tstrcpy(post_path, BLOG_DIR);\n\t\tstrcat(post_path, path_info);\n\n\t\tblog_post(post_path);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n/**************************\n * functions for dealing\n * with struct blogpost's\n *************************/\n\nstruct blogpost make_blogpost(char path[]) {\n\tstruct tm blog_tm;\n\tmemset(&blog_tm, 0, sizeof blog_tm);\n\n\tstruct blogpost struct_to_return;\n\n\n\t\n\t/* find the last '/' to\n\t * get 2014-12-12-12-12-lala\n\t * from /path/to/2014-12-12-12-12-lala */\n\n\tchar *last_slash_position = strrchr(path, '/');\n\tif(last_slash_position == NULL) {\n\t\tfprintf(stderr, \"There's something incredibly wrong with the path (%s) supplied to make_blogpost\\n\", path);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* this parses the filename that is linke\n\t * year-month-day-hour-minute-title */\n\n\t/* the string in the time part of the path */\n\tchar time_string[4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1];\n\tstrncpy(time_string, last_slash_position + 1, sizeof time_string - 1);\n\ttime_string[sizeof time_string - 1] = '\\0';\n\n\tstrptime(time_string, \"%Y-%m-%d-%H-%M\", &blog_tm);\n\n\tstruct_to_return.timestamp = mktime(&blog_tm);\n\tstruct_to_return.path = malloc(strlen(path) * sizeof(char));\n\tstrcpy(struct_to_return.path, path);\n\n\t/* let's build up the link */\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tint bufsize = strlen(script_name) +\n\t\tstrlen(last_slash_position) + 1;\n\tstruct_to_return.link = malloc(sizeof(char) * bufsize);\n\tstrcpy(struct_to_return.link, script_name);\n\tstrcat(struct_to_return.link, last_slash_position);\n\n\t/* that's all */\n\n\treturn struct_to_return;\n}\n\nstruct blogpost make_blogpost_from_dirent(struct dirent *post) {\n\tint bufsize = strlen(BLOG_DIR) + 1 + strlen(post->d_name) + 1;\n\tchar buf[bufsize];\n\n\tstrcpy(buf, BLOG_DIR);\n\tstrcat(buf, \"/\");\n\tstrcat(buf, post->d_name);\n\n\treturn make_blogpost(buf);\n}\n\nvoid free_blogpost(struct blogpost to_free) {\n\tfree(to_free.path);\n\tfree(to_free.link);\n\t/* the rest lies in stack mem */\n}\n\n/************************\n * wrapper functions for\n * template generation\n ***********************/\n\nvoid blog_index(void) {\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tstruct dirent **dirlist;\n\tint dircount;\n\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsend_header(\"Content-type\", \"text/html\");\n\tterminate_headers();\n\n\ttemplate_header();\n\n\tdircount = scandir(BLOG_DIR, &dirlist, no_dotfiles, alphasort);\t\n\n\tif(dircount < 0) {\n\t\tfprintf(stderr, \"An error occurred while scanning %s: %s\\n\", \n\t\t\t\tBLOG_DIR, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile(dircount--) {\n\t\tstruct blogpost post = make_blogpost_from_dirent(dirlist[dircount]);\n\n\t\t/* finally if the file exists call the\n\t\t * template function. Otherwise\n\t\t * we do nothing. (this case is also\n\t\t * FUCKING unlikely */\n\t\tif(file_exists(post.path) > 0) {\n\t\t\ttemplate_post_index_entry(post);\n\t\t}\n\t\t\n\t\tfree_blogpost(post);\n\t\tfree(dirlist[dircount]);\n\t}\n\tfree(dirlist);\n\n\ttemplate_footer();\n}\n\nvoid blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\n\ttemplate_footer();\n}\n\nvoid blog_rss(void) {\n\tstruct dirent **dirlist;\n\tint dircount;\n\t\n\t/* construct the time,\n\t * the blogpost was\n\t * created */\n\ttime_t timestamp;\n\tstruct tm *timeinfo;\n\tchar strtime_now[512];\n\n\ttime(&timestamp);\n\ttimeinfo = localtime(&timestamp);\n\n\tstrftime(strtime_now, sizeof strtime_now, \"%a, %d %b %G %T %z\", timeinfo);\n\n\t\n\tchar *script_name = getenv(\"SCRIPT_NAME\");\n\tif(script_name == NULL) {\n\t\tfprintf(stderr, \"Died because of missing self-awareness\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* build the top part\n\t * of the rss-feed */\n\tsend_header(\"Content-type\", \"application/rss+xml\");\n\tterminate_headers();\n\n\tprintf(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"\n\t       \"<rss version=\\\"2.0\\\">\\n\"\n\t       \"<channel>\\n\"\n\t       \"\\t<title>%s</title>\\n\"\n\t       \"\\t<description>%s</description>\\n\"\n\t       \"\\t<link>\" BLOG_SERVER_URL \"%s</link>\\n\"\n\t       \"\\t<lastBuildDate>%s</lastBuildDate>\\n\"\n\t       \"\\t<pubDate>%s</pubDate>\\n\"\n\t       \"\\t<ttl>%d</ttl>\\n\",\n\t       BLOG_TITLE, BLOG_DESCRIPTION, \n\t       script_name,\n\t       strtime_now, strtime_now,\n\t       BLOG_RSS_TTL);\n\n\tdircount = scandir(BLOG_DIR, &dirlist, no_dotfiles, alphasort);\n\n\tif(dircount < 0) {\n\t\tfprintf(stderr, \"An error occurred while scanning %s: %s\\n\",\n\t\t\t\tBLOG_DIR, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile(dircount--) {\n\t\tstruct blogpost post;\n\t\tpost = make_blogpost_from_dirent(dirlist[dircount]);\n\t\tchar *last_slash_position = strrchr(post.path, '/');\n\t\t\n\t\tif(last_slash_position == NULL) {\n\t\t\tfprintf(stderr, \"Malformed path %s in blog_rss\\n\", post.path);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tFILE *fp = fopen(post.path, \"r\");\n\t\tchar c;\n\t\tif(fp == NULL) {\n\t\t\tfprintf(stderr, \"Could not open file: %s: %s\\n\",\n\t\t\t\t\tpost.path, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tstruct tm *timeinfo = localtime(&post.timestamp);\n\t\tchar strtime_post[512];\n\t\tstrftime(strtime_post, sizeof strtime_post, \"%a, %d %b %G %T %z\", timeinfo);\n\t\t\n\t\tprintf(\"\\t<item>\\n\"\n\t\t       \"\\t\\t<title>%s</title>\\n\"\n\t\t       \"\\t\\t<description><![CDATA[\",\n\t\t       last_slash_position + 1);\n\n\t\twhile((c = getc(fp)) != EOF) {\n\t\t\tprintf(\"%c\", c);\n\t\t}\n\t\t\n\t\tfclose(fp);\n\n\t\tprintf(\"]]></description>\\n\"\n\t\t       \"\\t\\t<link>\" BLOG_SERVER_URL \"%s</link>\\n\"\n\t\t       \"\\t\\t<guid>\" BLOG_SERVER_URL \"%s</guid>\\n\"\n\t\t       \"\\t\\t<pubDate>%s</pubDate>\\n\"\n\t\t       \"\\t</item>\\n\",\n\t\t       post.link, post.link, strtime_post);\n\n\t\tfree_blogpost(post);\n\t\tfree(dirlist[dircount]);\n\t}\n\n\tfree(dirlist);\n\n\tprintf(\"</channel>\\n</rss>\\n\");\n}\n\nint file_exists(char path[]) {\n\tFILE *fp = fopen(path, \"r\");\n\n\tif(fp == NULL && errno == ENOENT) {\n\t\treturn 0;\n\t} else if(fp == NULL) {\n\t\t// some other error occured\n\t\treturn -1;\n\t} else {\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n}\n\n/*********************\n * header utilities \n ********************/\nvoid send_header(char key[], char val[]) {\n\tprintf(\"%s: %s\\n\", key, val);\n}\n\nvoid terminate_headers(void) {\n\tprintf(\"\\n\");\n}\n\n/******************************\n * filter function\n * for scandir(3)\n *****************************/\n\nint no_dotfiles(const struct dirent *file) {\n\tif(file->d_name[0] == '.') {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n"], "filenames": ["main.c"], "buggy_code_start_loc": [190], "buggy_code_end_loc": [190], "fixing_code_start_loc": [191], "fixing_code_end_loc": [199], "type": "CWE-73", "message": "A vulnerability, which was classified as problematic, has been found in sternenseemann sternenblog. This issue affects the function blog_index of the file main.c. The manipulation of the argument post_path leads to file inclusion. The attack may be initiated remotely. Upgrading to version 0.1.0 is able to address this issue. The name of the patch is cf715d911d8ce17969a7926dea651e930c27e71a. It is recommended to upgrade the affected component. The identifier VDB-217613 was assigned to this vulnerability. NOTE: This case is rather theoretical and probably won't happen. Maybe only on obscure Web servers.", "other": {"cve": {"id": "CVE-2014-125059", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T13:15:09.040", "lastModified": "2023-01-12T20:10:02.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, has been found in sternenseemann sternenblog. This issue affects the function blog_index of the file main.c. The manipulation of the argument post_path leads to file inclusion. The attack may be initiated remotely. Upgrading to version 0.1.0 is able to address this issue. The name of the patch is cf715d911d8ce17969a7926dea651e930c27e71a. It is recommended to upgrade the affected component. The identifier VDB-217613 was assigned to this vulnerability. NOTE: This case is rather theoretical and probably won't happen. Maybe only on obscure Web servers."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-73"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sternenblog_project:sternenblog:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-08-15", "matchCriteriaId": "F7DBC948-DD6A-4E88-8827-4A3B20DD0714"}]}]}], "references": [{"url": "https://github.com/sternenseemann/sternenblog/commit/cf715d911d8ce17969a7926dea651e930c27e71a", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sternenseemann/sternenblog/releases/tag/0.1.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217613", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217613", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sternenseemann/sternenblog/commit/cf715d911d8ce17969a7926dea651e930c27e71a"}}