{"buggy_code": ["<?php\n\n/**\n * This file is part of playSMS.\n *\n * playSMS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * playSMS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with playSMS. If not, see <http://www.gnu.org/licenses/>.\n */\ndefined('_SECURE_') or die('Forbidden');\n\n/**\n * Validate username and password\n *\n * @param string $username\n *        Username\n * @param string $password\n *        Password\n * @return boolean TRUE when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_login($username, $password) {\n\n\t// fixme anton - sanitize username\n\tif (!($username && $username == core_sanitize_username($username))) {\n\t\t_log('invalid username u:' . $username . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\n\t\treturn FALSE;\n\t}\n\n\t$uid = user_username2uid($username);\n\t_log('login attempt u:' . $username . ' uid:' . $uid . ' p:' . md5($password) . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_login');\n\t\n\t// check blacklist\n\tif (blacklist_ifipexists($username, $_SERVER['REMOTE_ADDR'])) {\n\t\t_log('IP blacklisted u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\treturn FALSE;\n\t}\n\t\n\tif (user_banned_get($uid)) {\n\t\t_log('user banned u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\treturn FALSE;\n\t}\n\t$db_query = \"SELECT password FROM \" . _DB_PREF_ . \"_tblUser WHERE flag_deleted='0' AND username='$username'\";\n\t$db_result = dba_query($db_query);\n\t$db_row = dba_fetch_array($db_result);\n\t$res_password = trim($db_row['password']);\n\t$password = md5($password);\n\tif ($password && $res_password && ($password == $res_password)) {\n\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\t\n\t\t// remove IP on successful login\n\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\n\t\treturn true;\n\t} else {\n\t\t$ret = registry_search(1, 'auth', 'tmp_password', $username);\n\t\t$tmp_password = $ret['auth']['tmp_password'][$username];\n\t\tif ($password && $tmp_password && ($password == $tmp_password)) {\n\t\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'] . ' using temporary password', 2, 'auth_validate_login');\n\t\t\tif (!registry_remove(1, 'auth', 'tmp_password', $username)) {\n\t\t\t\t_log('WARNING: unable to remove temporary password after successful login', 3, 'login');\n\t\t\t}\n\t\t\t\n\t\t\t// remove IP on successful login\n\t\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t// check blacklist\n\tblacklist_checkip($username, $_SERVER['REMOTE_ADDR']);\n\t\n\t_log('invalid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\treturn false;\n}\n\n/**\n * Validate email and password\n *\n * @param string $email\n *        Username\n * @param string $password\n *        Password\n * @return boolean TRUE when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_email($email, $password) {\n\t$username = user_email2username($email);\n\t_log('login attempt email:' . $email . ' u:' . $username . ' p:' . md5($password) . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_email');\n\treturn auth_validate_login($username, $password);\n}\n\n/**\n * Validate token\n *\n * @param string $token\n *        Token\n * @return string User ID when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_token($token) {\n\t$token = trim($token);\n\tif (_APP_ == 'main' || _APP_ == 'menu') {\n\t\t_log('login attempt token:' . $token . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_token');\n\t}\n\t\n\tif ($token) {\n\t\t$db_query = \"SELECT uid,username,enable_webservices,webservices_ip FROM \" . _DB_PREF_ . \"_tblUser WHERE flag_deleted='0' AND token='$token'\";\n\t\t$db_result = dba_query($db_query);\n\t\t$db_row = dba_fetch_array($db_result);\n\t\t$username = trim($db_row['username']);\n\t\t\n\t\t// check blacklist\n\t\tif (blacklist_ifipexists($username, $_SERVER['REMOTE_ADDR'])) {\n\t\t\t_log('IP blacklisted u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\t\t\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tif (($uid = trim($db_row['uid'])) && $username && ($db_row['enable_webservices'])) {\n\t\t\t$ip = explode(',', $db_row['webservices_ip']);\n\t\t\tif (is_array($ip)) {\n\t\t\t\tforeach ($ip as $key => $net) {\n\t\t\t\t\tif (core_net_match($net, $_SERVER['REMOTE_ADDR'])) {\n\t\t\t\t\t\tif (user_banned_get($uid)) {\n\t\t\t\t\t\t\t_log('user banned u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (_APP_ == 'main' || _APP_ == 'menu') {\n\t\t\t\t\t\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove IP on successful login\n\t\t\t\t\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn $uid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// check blacklist\n\tblacklist_checkip($username, $_SERVER['REMOTE_ADDR']);\n\t\n\t_log('invalid login t:' . $token . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has been validated\n *\n * @return boolean TRUE if valid\n */\nfunction auth_isvalid() {\n\tif ($_SESSION['sid'] && $_SESSION['uid'] && $_SESSION['valid']) {\n\t\t$hash = user_session_get('', $_SESSION['sid']);\n\t\tif ($_SESSION['sid'] == $hash[key($hash)]['sid'] && $_SESSION['uid'] == $hash[key($hash)]['uid']) {\n\t\t\treturn acl_checkurl($_SERVER['QUERY_STRING'], $_SESSION['uid']);\n\t\t}\n\t}\n\t\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has admin access level\n *\n * @return boolean TRUE if valid and visitor has admin access level\n */\nfunction auth_isadmin() {\n\tif ($_SESSION['status'] == 2) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has user access level\n *\n * @return boolean TRUE if valid and visitor has user access level\n */\nfunction auth_isuser() {\n\tif ($_SESSION['status'] == 3) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has subuser access level\n *\n * @return boolean TRUE if valid and visitor has subuser access level\n */\nfunction auth_issubuser() {\n\tif ($_SESSION['status'] == 4) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has certain user status\n *\n * @param string $status\n *        Account status\n * @return boolean TRUE if valid and visitor has certain user status\n */\nfunction auth_isstatus($status) {\n\tif ($_SESSION['status'] == (int) $status) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has certain ACL\n *\n * @param string $acl\n *        Access Control List\n * @return boolean TRUE if valid and visitor has certain ACL\n */\nfunction auth_isacl($acl) {\n\tif (auth_isvalid()) {\n\t\tif (auth_isadmin()) {\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\t$user_acl_id = user_getfieldbyuid($_SESSION['uid'], 'acl_id');\n\t\t\t$user_acl_name = acl_getname($user_acl_id);\n\t\t\tif ($acl && $user_acl_name && strtoupper($acl) == strtoupper($user_acl_name)) {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Display page for blocked access\n */\nfunction auth_block() {\n\theader(\"Location: \" . _u('index.php?app=main&inc=core_auth&route=block&op=block'));\n\texit();\n}\n\n/**\n * Setup user session\n *\n * @param string $username\n *        Username\n */\nfunction auth_session_setup($uid) {\n\tglobal $core_config;\n\t\n\t$c_user = user_getdatabyuid($uid);\n\tif ($c_user['username']) {\n\t\t// set session\n\t\t$_SESSION['sid'] = session_id();\n\t\t$_SESSION['username'] = $c_user['username'];\n\t\t$_SESSION['uid'] = $c_user['uid'];\n\t\t$_SESSION['status'] = $c_user['status'];\n\t\t$_SESSION['valid'] = TRUE;\n\t\tif (!is_array($_SESSION['tmp']['login_as'])) {\n\t\t\t$_SESSION['tmp']['login_as'] = array();\n\t\t}\n\t\t\n\t\t// save session in registry\n\t\tif (!$core_config['daemon_process']) {\n\t\t\tuser_session_set($c_user['uid']);\n\t\t}\n\t}\n}\n\nfunction auth_login_as($uid) {\n\t\n\t// save current login\n\tarray_unshift($_SESSION['tmp']['login_as'], $_SESSION['uid']);\n\t\n\t// setup new session\n\tauth_session_setup($uid);\n}\n\nfunction auth_login_return() {\n\t\n\t// get previous login\n\t$previous_login = $_SESSION['tmp']['login_as'][0];\n\tarray_shift($_SESSION['tmp']['login_as']);\n\t\n\t// return to previous session\n\tauth_session_setup($previous_login);\n}\n\nfunction auth_login_as_check() {\n\tif (count($_SESSION['tmp']['login_as']) > 0) {\n\t\treturn TRUE;\n\t} else {\n\t\treturn FALSE;\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of playSMS.\n *\n * playSMS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * playSMS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with playSMS. If not, see <http://www.gnu.org/licenses/>.\n */\ndefined('_SECURE_') or die('Forbidden');\n\n/**\n * Validate username and password\n *\n * @param string $username\n *        Username\n * @param string $password\n *        Password\n * @return boolean TRUE when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_login($username, $password) {\n\n\t// fixme anton - sanitize username\n\tif (!($username && $username == core_sanitize_username($username))) {\n\t\t_log('invalid username u:' . $username . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\n\t\treturn FALSE;\n\t}\n\n\t$uid = user_username2uid($username);\n\t_log('login attempt u:' . $username . ' uid:' . $uid . ' p:' . md5($password) . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_login');\n\t\n\t// check blacklist\n\tif (blacklist_ifipexists($username, $_SERVER['REMOTE_ADDR'])) {\n\t\t_log('IP blacklisted u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\treturn FALSE;\n\t}\n\t\n\tif (user_banned_get($uid)) {\n\t\t_log('user banned u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\treturn FALSE;\n\t}\n\t$db_query = \"SELECT password FROM \" . _DB_PREF_ . \"_tblUser WHERE flag_deleted='0' AND username='$username'\";\n\t$db_result = dba_query($db_query);\n\t$db_row = dba_fetch_array($db_result);\n\t$res_password = trim($db_row['password']);\n\t$password = md5($password);\n\tif ($password && $res_password && ($password === $res_password)) {\n\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\t\n\t\t// remove IP on successful login\n\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\n\t\treturn true;\n\t} else {\n\t\t$ret = registry_search(1, 'auth', 'tmp_password', $username);\n\t\t$tmp_password = $ret['auth']['tmp_password'][$username];\n\t\tif ($password && $tmp_password && ($password === $tmp_password)) {\n\t\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'] . ' using temporary password', 2, 'auth_validate_login');\n\t\t\tif (!registry_remove(1, 'auth', 'tmp_password', $username)) {\n\t\t\t\t_log('WARNING: unable to remove temporary password after successful login', 3, 'login');\n\t\t\t}\n\t\t\t\n\t\t\t// remove IP on successful login\n\t\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t// check blacklist\n\tblacklist_checkip($username, $_SERVER['REMOTE_ADDR']);\n\t\n\t_log('invalid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\treturn false;\n}\n\n/**\n * Validate email and password\n *\n * @param string $email\n *        Username\n * @param string $password\n *        Password\n * @return boolean TRUE when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_email($email, $password) {\n\t$username = user_email2username($email);\n\t_log('login attempt email:' . $email . ' u:' . $username . ' p:' . md5($password) . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_email');\n\treturn auth_validate_login($username, $password);\n}\n\n/**\n * Validate token\n *\n * @param string $token\n *        Token\n * @return string User ID when validated or boolean FALSE when validation failed\n */\nfunction auth_validate_token($token) {\n\t$token = trim($token);\n\tif (_APP_ == 'main' || _APP_ == 'menu') {\n\t\t_log('login attempt token:' . $token . ' ip:' . $_SERVER['REMOTE_ADDR'], 3, 'auth_validate_token');\n\t}\n\t\n\tif ($token) {\n\t\t$db_query = \"SELECT uid,username,enable_webservices,webservices_ip FROM \" . _DB_PREF_ . \"_tblUser WHERE flag_deleted='0' AND token='$token'\";\n\t\t$db_result = dba_query($db_query);\n\t\t$db_row = dba_fetch_array($db_result);\n\t\t$username = trim($db_row['username']);\n\t\t\n\t\t// check blacklist\n\t\tif (blacklist_ifipexists($username, $_SERVER['REMOTE_ADDR'])) {\n\t\t\t_log('IP blacklisted u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_login');\n\t\t\t\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tif (($uid = trim($db_row['uid'])) && $username && ($db_row['enable_webservices'])) {\n\t\t\t$ip = explode(',', $db_row['webservices_ip']);\n\t\t\tif (is_array($ip)) {\n\t\t\t\tforeach ($ip as $key => $net) {\n\t\t\t\t\tif (core_net_match($net, $_SERVER['REMOTE_ADDR'])) {\n\t\t\t\t\t\tif (user_banned_get($uid)) {\n\t\t\t\t\t\t\t_log('user banned u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (_APP_ == 'main' || _APP_ == 'menu') {\n\t\t\t\t\t\t\t_log('valid login u:' . $username . ' uid:' . $uid . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove IP on successful login\n\t\t\t\t\t\tblacklist_clearip($username, $_SERVER['REMOTE_ADDR']);\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn $uid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// check blacklist\n\tblacklist_checkip($username, $_SERVER['REMOTE_ADDR']);\n\t\n\t_log('invalid login t:' . $token . ' ip:' . $_SERVER['REMOTE_ADDR'], 2, 'auth_validate_token');\n\t\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has been validated\n *\n * @return boolean TRUE if valid\n */\nfunction auth_isvalid() {\n\tif ($_SESSION['sid'] && $_SESSION['uid'] && $_SESSION['valid']) {\n\t\t$hash = user_session_get('', $_SESSION['sid']);\n\t\tif ($_SESSION['sid'] == $hash[key($hash)]['sid'] && $_SESSION['uid'] == $hash[key($hash)]['uid']) {\n\t\t\treturn acl_checkurl($_SERVER['QUERY_STRING'], $_SESSION['uid']);\n\t\t}\n\t}\n\t\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has admin access level\n *\n * @return boolean TRUE if valid and visitor has admin access level\n */\nfunction auth_isadmin() {\n\tif ($_SESSION['status'] == 2) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has user access level\n *\n * @return boolean TRUE if valid and visitor has user access level\n */\nfunction auth_isuser() {\n\tif ($_SESSION['status'] == 3) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has subuser access level\n *\n * @return boolean TRUE if valid and visitor has subuser access level\n */\nfunction auth_issubuser() {\n\tif ($_SESSION['status'] == 4) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has certain user status\n *\n * @param string $status\n *        Account status\n * @return boolean TRUE if valid and visitor has certain user status\n */\nfunction auth_isstatus($status) {\n\tif ($_SESSION['status'] == (int) $status) {\n\t\tif (auth_isvalid()) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Check if visitor has certain ACL\n *\n * @param string $acl\n *        Access Control List\n * @return boolean TRUE if valid and visitor has certain ACL\n */\nfunction auth_isacl($acl) {\n\tif (auth_isvalid()) {\n\t\tif (auth_isadmin()) {\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\t$user_acl_id = user_getfieldbyuid($_SESSION['uid'], 'acl_id');\n\t\t\t$user_acl_name = acl_getname($user_acl_id);\n\t\t\tif ($acl && $user_acl_name && strtoupper($acl) == strtoupper($user_acl_name)) {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/**\n * Display page for blocked access\n */\nfunction auth_block() {\n\theader(\"Location: \" . _u('index.php?app=main&inc=core_auth&route=block&op=block'));\n\texit();\n}\n\n/**\n * Setup user session\n *\n * @param string $username\n *        Username\n */\nfunction auth_session_setup($uid) {\n\tglobal $core_config;\n\t\n\t$c_user = user_getdatabyuid($uid);\n\tif ($c_user['username']) {\n\t\t// set session\n\t\t$_SESSION['sid'] = session_id();\n\t\t$_SESSION['username'] = $c_user['username'];\n\t\t$_SESSION['uid'] = $c_user['uid'];\n\t\t$_SESSION['status'] = $c_user['status'];\n\t\t$_SESSION['valid'] = TRUE;\n\t\tif (!is_array($_SESSION['tmp']['login_as'])) {\n\t\t\t$_SESSION['tmp']['login_as'] = array();\n\t\t}\n\t\t\n\t\t// save session in registry\n\t\tif (!$core_config['daemon_process']) {\n\t\t\tuser_session_set($c_user['uid']);\n\t\t}\n\t}\n}\n\nfunction auth_login_as($uid) {\n\t\n\t// save current login\n\tarray_unshift($_SESSION['tmp']['login_as'], $_SESSION['uid']);\n\t\n\t// setup new session\n\tauth_session_setup($uid);\n}\n\nfunction auth_login_return() {\n\t\n\t// get previous login\n\t$previous_login = $_SESSION['tmp']['login_as'][0];\n\tarray_shift($_SESSION['tmp']['login_as']);\n\t\n\t// return to previous session\n\tauth_session_setup($previous_login);\n}\n\nfunction auth_login_as_check() {\n\tif (count($_SESSION['tmp']['login_as']) > 0) {\n\t\treturn TRUE;\n\t} else {\n\t\treturn FALSE;\n\t}\n}\n"], "filenames": ["web/plugin/core/auth/fn.php"], "buggy_code_start_loc": [57], "buggy_code_end_loc": [68], "fixing_code_start_loc": [57], "fixing_code_end_loc": [68], "type": "CWE-697", "message": "A type juggling vulnerability in the component /auth/fn.php of PlaySMS v1.4.5 and earlier allows attackers to bypass authentication.", "other": {"cve": {"id": "CVE-2022-47034", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-13T22:15:13.317", "lastModified": "2023-02-22T20:14:11.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A type juggling vulnerability in the component /auth/fn.php of PlaySMS v1.4.5 and earlier allows attackers to bypass authentication."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:playsms:playsms:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.5", "matchCriteriaId": "C26E3E23-6519-417A-A5A0-741B44A333D3"}]}]}], "references": [{"url": "https://gist.github.com/tonino-25/d2316094cc751cc7a8e2c1ae6dbecfe9", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/playsms/playsms/commit/dd23673a00c052e113c6d44eb629dc355d3c0605", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/playsms/playsms/commit/dd23673a00c052e113c6d44eb629dc355d3c0605"}}