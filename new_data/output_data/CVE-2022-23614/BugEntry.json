{"buggy_code": ["# 2.14.11 (2022-XX-XX)\n\n* n/a\n\n# 2.14.10 (2022-01-03)\n\n* Allow more null arguments when Twig expects a string (for better 8.1 support)\n\n# 2.14.9 (2022-01-03)\n\n* Allow null when Twig expects a string (for better 8.1 support)\n* Add support for PHP 7.1 back\n* Make some performance optimizations\n* Allow Symfony translation contract v3+\n\n# 2.14.8 (2021-11-25)\n\n * Bump minimum supported Symfony component versions\n * Fix a deprecated message\n\n# 2.14.7 (2021-09-17)\n\n * Allow Symfony 6\n * Improve compatibility with PHP 8.1\n * Explicitly specify the encoding for mb_ord in JS escaper\n \n# 2.14.6 (2021-05-16)\n\n * Revert \"Throw a proper exception when a template name is an absolute path (as it has never been supported)\"\n\n# 2.14.5 (2021-05-12)\n\n * Fix PHP 8.1 compatibility\n * Throw a proper exception when a template name is an absolute path (as it has never been supported)\n\n# 2.14.4 (2021-03-10)\n\n * Add the slug filter\n\n# 2.14.3 (2021-01-05)\n\n * Fix extra bundle compat with older versions of Symfony\n\n# 2.14.2 (2021-01-05)\n\n * Fix \"odd\" not working for negative numbers\n\n# 2.14.1 (2020-10-27)\n\n* Fix \"include(template_from_string())\"\n\n# 2.14.0 (2020-10-21)\n\n * Fix sandbox support when using \"include(template_from_string())\"\n * Make round brackets optional for one argument tests like \"same as\" or \"divisible by\"\n * Add support for ES2015 style object initialisation shortcut { a } is the same as { 'a': a }\n * Drop PHP 7.1 support\n\n# 2.13.1 (2020-08-05)\n\n * Fix sandbox not disabled if syntax error occurs within {% sandbox %} tag\n * Fix a regression when not using a space before an operator\n * Restrict callables to closures in filters\n * Allow trailing commas in argument lists (in calls as well as definitions)\n\n# 2.13.0 (2020-07-05)\n\n * Fix options not taken into account when using \"Michelf\\MarkdownExtra\"\n * Fix \"Twig\\Extra\\Intl\\IntlExtension::getCountryName()\" to accept \"null\" as a first argument\n * Drop support for PHP 7.0\n * Throw exception in case non-Traversable data is passed to \"filter\"\n * Fix context optimization on PHP 7.4\n * Fix PHP 8 compatibility\n * Fix ambiguous syntax parsing\n\n# 2.12.5 (2020-02-11)\n\n * Add a check to ensure that iconv() is defined\n\n# 2.12.4 (2020-02-11)\n\n * Avoid exceptions when an intl resource is not found\n * Fix implementation of case-insensitivity for method names\n\n# 2.12.3 (2019-12-28)\n\n * fixed Symfony 5.0 support for the HTML extra extension\n * fixed number formatter in Intl extra extension when using a formatter prototype\n\n# 2.12.2 (2019-11-11)\n\n * added supported for exponential numbers\n\n# 2.12.1 (2019-10-17)\n\n * added the String extension in the \"extra\" repositories: \"u\" filter\n\n# 2.12.0 (2019-10-05)\n\n * added the spaceship operator (\"<=>\"), useful when using an arrow function in the \"sort\" filter\n * added support for an \"arrow\" function on the \"sort\" filter\n * added the CssInliner extension in the \"extra\" repositories: \"inline_css\"\n   filter\n * added the Inky extension in the \"extra\" repositories: \"inky_to_html\" filter\n * added Intl extension in the \"extra\" repositories: \"country_name\",\n   \"currency_name\", \"currency_symbol\", \"language_name\", \"locale_name\",\n   \"timezone_name\", \"format_currency\", \"format_number\",\n   \"format_*_number\", \"format_datetime\", \"format_date\", and \"format_time\"\n   filters, and the \"country_timezones\" function\n * added the Markdown extension in the \"extra\" repositories: \"markdown_to_html\",\n   and \"html_to_markdown\" filters\n * added the HtmlExtension extension in the \"extra\" repositories: \"date_uri\"\n   filter, and \"html_classes\" function\n * optimized \"block('foo') ?? 'bar'\"\n * fixed the empty test on Traversable instances\n * fixed array_key_exists() on objects\n * fixed cache when opcache is installed but disabled\n * fixed using macros in arrow functions\n * fixed split filter on edge case\n\n# 2.11.3 (2019-06-18)\n\n * display partial output (PHP buffer) when an error occurs in debug mode\n * fixed the filter filter (allow the result to be used several times)\n * fixed macro auto-import when a template contains only macros\n\n# 2.11.2 (2019-06-05)\n\n * fixed macro auto-import\n\n# 2.11.1 (2019-06-04)\n\n * added support for \"Twig\\Markup\" instances in the \"in\" test (again)\n * allowed string operators as variables names in assignments\n * fixed support for macros defined in parent templates\n\n# 2.11.0 (2019-05-31)\n\n * added the possibility to register classes/interfaces as being safe for the escaper (\"EscaperExtension::addSafeClass()\")\n * deprecated CoreExtension::setEscaper() and CoreExtension::getEscapers() in favor of the same methods on EscaperExtension\n * macros are now auto-imported in the template they are defined (under the ``_self`` variable)\n * added support for macros on \"is defined\" tests\n * fixed macros \"import\" when using the same name in the parent and child templates\n * fixed recursive macros\n * macros imported \"globally\" in a template are now available in macros without re-importing them\n * fixed the \"filter\" filter when the argument is \\Traversable but does not implement \\Iterator (\\SimpleXmlElement for instance)\n * fixed a PHP fatal error when calling a macro imported in a block in a nested block\n * fixed a PHP fatal error when calling a macro imported in the template in another macro\n * fixed wrong error message on \"import\" and \"from\"\n\n# 2.10.0 (2019-05-14)\n\n * deprecated \"if\" conditions on \"for\" tags\n * added \"filter\", \"map\", and \"reduce\" filters (and support for arrow functions)\n * fixed partial output leak when a PHP fatal error occurs\n * optimized context access on PHP 7.4\n\n# 2.9.0 (2019-04-28)\n\n * deprecated returning \"false\" to remove a Node from NodeVisitorInterface::leaveNode()\n * allowed Twig\\NodeVisitor\\NodeVisitorInterface::leaveNode() to return \"null\" instead of \"false\" (same meaning)\n * deprecated the \"filter\" tag (use the \"apply\" tag instead)\n * added the \"apply\" tag as a replacement for the \"filter\" tag\n * allowed Twig\\Loader\\FilesystemLoader::findTemplate() to return \"null\" instead of \"false\" (same meaning)\n * added support for \"Twig\\Markup\" instances in the \"in\" test\n * fixed \"import\" when macros are stored in a template string\n * fixed Lexer when using custom options containing the # char\n * added template line number to twig_get_attribute()\n\n# 2.8.1 (2019-04-16)\n\n * fixed EscaperNodeVisitor\n * deprecated passing a 3rd, 4th, and 5th arguments to the Sandbox exception classes\n * deprecated Node::setTemplateName() in favor of Node::setSourceContext()\n\n# 2.8.0 (2019-04-16)\n\n * added Traversable support for the length filter\n * fixed some wrong location in error messages\n * made exception creation faster\n * made escaping on ternary expressions (?: and ??) more fine-grained\n * added the possibility to give a nice name to string templates (template_from_string function)\n * fixed the \"with\" behavior to always include the globals (for consistency with the \"include\" and \"embed\" tags)\n * fixed \"include\" with \"ignore missing\" when an error loading occurs in the included template\n * added support for a new whitespace trimming option ({%~ ~%}, {{~ ~}}, {#~ ~#})\n * added the \"column\" filter\n\n# 2.7.4 (2019-03-23)\n\n * fixed variadic support\n * fixed CheckToStringNode implementation (broken when a function/filter is variadic)\n\n# 2.7.3 (2019-03-21)\n\n * fixed the spaceless filter so that it behaves like the spaceless tag\n * fixed BC break on Environment::resolveTemplate()\n * allowed Traversable objects to be used in the \"with\" tag\n * allowed Traversable objects to be used in the \"with\" tag\n * allowed Traversable objects to be used in the \"with\" argument of the \"include\" and \"embed\" tags\n\n# 2.7.2 (2019-03-12)\n\n * added TemplateWrapper::getTemplateName()\n\n# 2.7.1 (2019-03-12)\n\n * fixed class aliases\n\n# 2.7.0 (2019-03-12)\n\n * fixed sandbox security issue (under some circumstances, calling the\n   __toString() method on an object was possible even if not allowed by the\n   security policy)\n * fixed batch filter clobbers array keys when fill parameter is used\n * added preserveKeys support for the batch filter\n * fixed \"embed\" support when used from \"template_from_string\"\n * deprecated passing a Twig\\Template to Twig\\Environment::load()/Twig\\Environment::resolveTemplate()\n * added the possibility to pass a TemplateWrapper to Twig\\Environment::load()\n * marked Twig\\Environment::getTemplateClass() as internal (implementation detail)\n * improved the performance of the sandbox\n * deprecated the spaceless tag\n * added a spaceless filter\n * added max value to the \"random\" function\n * deprecated Twig\\Extension\\InitRuntimeInterface\n * deprecated Twig\\Loader\\ExistsLoaderInterface\n * deprecated PSR-0 classes in favor of namespaced ones\n * made namespace classes the default classes (PSR-0 ones are aliases now)\n * added Twig\\Loader\\ChainLoader::getLoaders()\n * removed duplicated directory separator in FilesystemLoader\n * deprecated the \"base_template_class\" option on Twig\\Environment\n * deprecated the Twig\\Environment::getBaseTemplateClass() and\n   Twig\\Environment::setBaseTemplateClass() methods\n * changed internal code to use the namespaced classes as much as possible\n * deprecated Twig_Parser::isReservedMacroName()\n\n# 2.6.2 (2019-01-14)\n\n * fixed regression (key exists check for non ArrayObject objects)\n\n# 2.6.1 (2019-01-14)\n\n * fixed ArrayObject access with a null value\n * fixed embedded templates starting with a BOM\n * fixed using a Twig_TemplateWrapper instance as an argument to extends\n * fixed error location when calling an undefined block\n * deprecated passing a string as a source on Twig_Error\n * switched generated code to use the PHP short array notation\n * fixed float representation in compiled templates\n * added a second argument to the join filter (last separator configuration)\n\n# 2.6.0 (2018-12-16)\n\n * made sure twig_include returns a string\n * fixed multi-byte UFT-8 in escape('html_attr')\n * added the \"deprecated\" tag\n * added support for dynamically named tests\n * fixed GlobalsInterface extended class\n * fixed filesystem loader throwing an exception instead of returning false\n\n# 2.5.0 (2018-07-13)\n\n * deprecated using the spaceless tag at the root level of a child template (noop anyway)\n * deprecated the possibility to define a block in a non-capturing block in a child template\n * added the Symfony ctype polyfill as a dependency\n * fixed reporting the proper location for errors compiled in templates\n * fixed the error handling for the optimized extension-based function calls\n * ensured that syntax errors are triggered with the right line\n * \"js\" filter now produces valid JSON\n\n# 2.4.8 (2018-04-02)\n\n * fixed a regression when using the \"default\" filter or the \"defined\" test on non-existing arrays\n\n# 2.4.7 (2018-03-20)\n\n * optimized runtime performance\n * optimized parser performance by inlining the constant values\n * fixed block names unicity\n * fixed counting children of SimpleXMLElement objects\n * added missing else clause to avoid infinite loops\n * fixed .. (range operator) in sandbox policy\n\n# 2.4.6 (2018-03-03)\n\n * fixed a regression in the way the profiler is registered in templates\n\n# 2.4.5 (2018-03-02)\n\n * optimized the performance of calling an extension method at runtime\n * optimized the performance of the dot operator for array and method calls\n * added an exception when using \"===\" instead of \"same as\"\n * fixed possible array to string conversion concealing actual error\n * made variable names deterministic in compiled templates\n * fixed length filter when passing an instance of IteratorAggregate\n * fixed Environment::resolveTemplate to accept instances of TemplateWrapper\n\n# 2.4.4 (2017-09-27)\n\n * added Twig_Profiler_Profile::reset()\n * fixed use TokenParser to return an empty Node\n * added RuntimeExtensionInterface\n * added circular reference detection when loading templates\n * added support for runtime loaders in IntegrationTestCase\n * fixed deprecation when using Twig_Profiler_Dumper_Html\n * removed @final from Twig_Profiler_Dumper_Text\n\n# 2.4.3 (2017-06-07)\n\n * fixed namespaces introduction\n\n# 2.4.2 (2017-06-05)\n\n * fixed namespaces introduction\n\n# 2.4.1 (2017-06-05)\n\n * fixed namespaces introduction\n\n# 2.4.0 (2017-06-05)\n\n * added support for PHPUnit 6 when testing extensions\n * fixed PHP 7.2 compatibility\n * fixed template name generation in Twig_Environment::createTemplate()\n * removed final tag on Twig_TokenParser_Include\n * dropped HHVM support\n * added namespaced aliases for all (non-deprecated) classes and interfaces\n * marked Twig_Filter, Twig_Function, Twig_Test, Twig_Node_Module and Twig_Profiler_Profile as final via the @final annotation\n\n# 2.3.2 (2017-04-20)\n\n * fixed edge case in the method cache for Twig attributes\n\n# 2.3.1 (2017-04-18)\n\n * fixed the empty() test\n\n# 2.3.0 (2017-03-22)\n\n * fixed a race condition handling when writing cache files\n * \"length\" filter now returns string length when applied to an object that does\n   not implement \\Countable but provides __toString()\n * \"empty\" test will now consider the return value of the __toString() method for\n   objects implement __toString() but not \\Countable\n * fixed JS escaping for unicode characters with higher code points\n * added error message when calling `parent()` in a block that doesn't exist in the parent template\n\n# 2.2.0 (2017-02-26)\n\n * added a PSR-11 compatible runtime loader\n * added `side` argument to `trim` to allow left or right trimming only.\n\n# 2.1.0 (2017-01-11)\n\n * fixed twig_get_attribute()\n * added Twig_NodeCaptureInterface for nodes that capture all output\n\n# 2.0.0 (2017-01-05)\n\n * removed the C extension\n * moved Twig_Environment::getAttribute() to twig_get_attribute()\n * removed Twig_Environment::getLexer(), Twig_Environment::getParser(), Twig_Environment::getCompiler()\n * removed Twig_Compiler::getFilename()\n * added hasser support in Twig_Template::getAttribute()\n * sped up the json_encode filter\n * removed reserved macro names; all names can be used as macro\n * removed Twig_Template::getEnvironment()\n * changed _self variable to return the current template name\n * made the loader a required argument of Twig_Environment constructor\n * removed Twig_Environment::clearTemplateCache()\n * removed Twig_Autoloader (use Composer instead)\n * removed `true` as an equivalent to `html` for the auto-escaping strategy\n * removed pre-1.8 autoescape tag syntax\n * dropped support for PHP 5.x\n * removed the ability to register a global variable after the runtime or the extensions have been initialized\n * improved the performance of the filesystem loader\n * removed features that were deprecated in 1.x\n", "<?php\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Twig\\Extension {\nuse Twig\\ExpressionParser;\nuse Twig\\Node\\Expression\\Binary\\AddBinary;\nuse Twig\\Node\\Expression\\Binary\\AndBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseAndBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseOrBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseXorBinary;\nuse Twig\\Node\\Expression\\Binary\\ConcatBinary;\nuse Twig\\Node\\Expression\\Binary\\DivBinary;\nuse Twig\\Node\\Expression\\Binary\\EndsWithBinary;\nuse Twig\\Node\\Expression\\Binary\\EqualBinary;\nuse Twig\\Node\\Expression\\Binary\\FloorDivBinary;\nuse Twig\\Node\\Expression\\Binary\\GreaterBinary;\nuse Twig\\Node\\Expression\\Binary\\GreaterEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\InBinary;\nuse Twig\\Node\\Expression\\Binary\\LessBinary;\nuse Twig\\Node\\Expression\\Binary\\LessEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\MatchesBinary;\nuse Twig\\Node\\Expression\\Binary\\ModBinary;\nuse Twig\\Node\\Expression\\Binary\\MulBinary;\nuse Twig\\Node\\Expression\\Binary\\NotEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\NotInBinary;\nuse Twig\\Node\\Expression\\Binary\\OrBinary;\nuse Twig\\Node\\Expression\\Binary\\PowerBinary;\nuse Twig\\Node\\Expression\\Binary\\RangeBinary;\nuse Twig\\Node\\Expression\\Binary\\SpaceshipBinary;\nuse Twig\\Node\\Expression\\Binary\\StartsWithBinary;\nuse Twig\\Node\\Expression\\Binary\\SubBinary;\nuse Twig\\Node\\Expression\\Filter\\DefaultFilter;\nuse Twig\\Node\\Expression\\NullCoalesceExpression;\nuse Twig\\Node\\Expression\\Test\\ConstantTest;\nuse Twig\\Node\\Expression\\Test\\DefinedTest;\nuse Twig\\Node\\Expression\\Test\\DivisiblebyTest;\nuse Twig\\Node\\Expression\\Test\\EvenTest;\nuse Twig\\Node\\Expression\\Test\\NullTest;\nuse Twig\\Node\\Expression\\Test\\OddTest;\nuse Twig\\Node\\Expression\\Test\\SameasTest;\nuse Twig\\Node\\Expression\\Unary\\NegUnary;\nuse Twig\\Node\\Expression\\Unary\\NotUnary;\nuse Twig\\Node\\Expression\\Unary\\PosUnary;\nuse Twig\\NodeVisitor\\MacroAutoImportNodeVisitor;\nuse Twig\\TokenParser\\ApplyTokenParser;\nuse Twig\\TokenParser\\BlockTokenParser;\nuse Twig\\TokenParser\\DeprecatedTokenParser;\nuse Twig\\TokenParser\\DoTokenParser;\nuse Twig\\TokenParser\\EmbedTokenParser;\nuse Twig\\TokenParser\\ExtendsTokenParser;\nuse Twig\\TokenParser\\FilterTokenParser;\nuse Twig\\TokenParser\\FlushTokenParser;\nuse Twig\\TokenParser\\ForTokenParser;\nuse Twig\\TokenParser\\FromTokenParser;\nuse Twig\\TokenParser\\IfTokenParser;\nuse Twig\\TokenParser\\ImportTokenParser;\nuse Twig\\TokenParser\\IncludeTokenParser;\nuse Twig\\TokenParser\\MacroTokenParser;\nuse Twig\\TokenParser\\SetTokenParser;\nuse Twig\\TokenParser\\SpacelessTokenParser;\nuse Twig\\TokenParser\\UseTokenParser;\nuse Twig\\TokenParser\\WithTokenParser;\nuse Twig\\TwigFilter;\nuse Twig\\TwigFunction;\nuse Twig\\TwigTest;\n\nfinal class CoreExtension extends AbstractExtension\n{\n    private $dateFormats = ['F j, Y H:i', '%d days'];\n    private $numberFormat = [0, '.', ','];\n    private $timezone = null;\n    private $escapers = [];\n\n    /**\n     * Defines a new escaper to be used via the escape filter.\n     *\n     * @param string   $strategy The strategy name that should be used as a strategy in the escape call\n     * @param callable $callable A valid PHP callable\n     *\n     * @deprecated since Twig 2.11, to be removed in 3.0; use the same method on EscaperExtension instead\n     */\n    public function setEscaper($strategy, callable $callable)\n    {\n        @trigger_error(sprintf('The \"%s\" method is deprecated since Twig 2.11; use \"%s::setEscaper\" instead.', __METHOD__, EscaperExtension::class), \\E_USER_DEPRECATED);\n\n        $this->escapers[$strategy] = $callable;\n    }\n\n    /**\n     * Gets all defined escapers.\n     *\n     * @return callable[] An array of escapers\n     *\n     * @deprecated since Twig 2.11, to be removed in 3.0; use the same method on EscaperExtension instead\n     */\n    public function getEscapers(/* $triggerDeprecation = true */)\n    {\n        if (0 === \\func_num_args() || \\func_get_arg(0)) {\n            @trigger_error(sprintf('The \"%s\" method is deprecated since Twig 2.11; use \"%s::getEscapers\" instead.', __METHOD__, EscaperExtension::class), \\E_USER_DEPRECATED);\n        }\n\n        return $this->escapers;\n    }\n\n    /**\n     * Sets the default format to be used by the date filter.\n     *\n     * @param string $format             The default date format string\n     * @param string $dateIntervalFormat The default date interval format string\n     */\n    public function setDateFormat($format = null, $dateIntervalFormat = null)\n    {\n        if (null !== $format) {\n            $this->dateFormats[0] = $format;\n        }\n\n        if (null !== $dateIntervalFormat) {\n            $this->dateFormats[1] = $dateIntervalFormat;\n        }\n    }\n\n    /**\n     * Gets the default format to be used by the date filter.\n     *\n     * @return array The default date format string and the default date interval format string\n     */\n    public function getDateFormat()\n    {\n        return $this->dateFormats;\n    }\n\n    /**\n     * Sets the default timezone to be used by the date filter.\n     *\n     * @param \\DateTimeZone|string $timezone The default timezone string or a \\DateTimeZone object\n     */\n    public function setTimezone($timezone)\n    {\n        $this->timezone = $timezone instanceof \\DateTimeZone ? $timezone : new \\DateTimeZone($timezone);\n    }\n\n    /**\n     * Gets the default timezone to be used by the date filter.\n     *\n     * @return \\DateTimeZone The default timezone currently in use\n     */\n    public function getTimezone()\n    {\n        if (null === $this->timezone) {\n            $this->timezone = new \\DateTimeZone(date_default_timezone_get());\n        }\n\n        return $this->timezone;\n    }\n\n    /**\n     * Sets the default format to be used by the number_format filter.\n     *\n     * @param int    $decimal      the number of decimal places to use\n     * @param string $decimalPoint the character(s) to use for the decimal point\n     * @param string $thousandSep  the character(s) to use for the thousands separator\n     */\n    public function setNumberFormat($decimal, $decimalPoint, $thousandSep)\n    {\n        $this->numberFormat = [$decimal, $decimalPoint, $thousandSep];\n    }\n\n    /**\n     * Get the default format used by the number_format filter.\n     *\n     * @return array The arguments for number_format()\n     */\n    public function getNumberFormat()\n    {\n        return $this->numberFormat;\n    }\n\n    public function getTokenParsers()\n    {\n        return [\n            new ApplyTokenParser(),\n            new ForTokenParser(),\n            new IfTokenParser(),\n            new ExtendsTokenParser(),\n            new IncludeTokenParser(),\n            new BlockTokenParser(),\n            new UseTokenParser(),\n            new FilterTokenParser(),\n            new MacroTokenParser(),\n            new ImportTokenParser(),\n            new FromTokenParser(),\n            new SetTokenParser(),\n            new SpacelessTokenParser(),\n            new FlushTokenParser(),\n            new DoTokenParser(),\n            new EmbedTokenParser(),\n            new WithTokenParser(),\n            new DeprecatedTokenParser(),\n        ];\n    }\n\n    public function getFilters()\n    {\n        return [\n            // formatting filters\n            new TwigFilter('date', 'twig_date_format_filter', ['needs_environment' => true]),\n            new TwigFilter('date_modify', 'twig_date_modify_filter', ['needs_environment' => true]),\n            new TwigFilter('format', 'twig_sprintf'),\n            new TwigFilter('replace', 'twig_replace_filter'),\n            new TwigFilter('number_format', 'twig_number_format_filter', ['needs_environment' => true]),\n            new TwigFilter('abs', 'abs'),\n            new TwigFilter('round', 'twig_round'),\n\n            // encoding\n            new TwigFilter('url_encode', 'twig_urlencode_filter'),\n            new TwigFilter('json_encode', 'json_encode'),\n            new TwigFilter('convert_encoding', 'twig_convert_encoding'),\n\n            // string filters\n            new TwigFilter('title', 'twig_title_string_filter', ['needs_environment' => true]),\n            new TwigFilter('capitalize', 'twig_capitalize_string_filter', ['needs_environment' => true]),\n            new TwigFilter('upper', 'twig_upper_filter', ['needs_environment' => true]),\n            new TwigFilter('lower', 'twig_lower_filter', ['needs_environment' => true]),\n            new TwigFilter('striptags', 'twig_striptags'),\n            new TwigFilter('trim', 'twig_trim_filter'),\n            new TwigFilter('nl2br', 'twig_nl2br', ['pre_escape' => 'html', 'is_safe' => ['html']]),\n            new TwigFilter('spaceless', 'twig_spaceless', ['is_safe' => ['html']]),\n\n            // array helpers\n            new TwigFilter('join', 'twig_join_filter'),\n            new TwigFilter('split', 'twig_split_filter', ['needs_environment' => true]),\n            new TwigFilter('sort', 'twig_sort_filter'),\n            new TwigFilter('merge', 'twig_array_merge'),\n            new TwigFilter('batch', 'twig_array_batch'),\n            new TwigFilter('column', 'twig_array_column'),\n            new TwigFilter('filter', 'twig_array_filter', ['needs_environment' => true]),\n            new TwigFilter('map', 'twig_array_map', ['needs_environment' => true]),\n            new TwigFilter('reduce', 'twig_array_reduce', ['needs_environment' => true]),\n\n            // string/array filters\n            new TwigFilter('reverse', 'twig_reverse_filter', ['needs_environment' => true]),\n            new TwigFilter('length', 'twig_length_filter', ['needs_environment' => true]),\n            new TwigFilter('slice', 'twig_slice', ['needs_environment' => true]),\n            new TwigFilter('first', 'twig_first', ['needs_environment' => true]),\n            new TwigFilter('last', 'twig_last', ['needs_environment' => true]),\n\n            // iteration and runtime\n            new TwigFilter('default', '_twig_default_filter', ['node_class' => DefaultFilter::class]),\n            new TwigFilter('keys', 'twig_get_array_keys_filter'),\n        ];\n    }\n\n    public function getFunctions()\n    {\n        return [\n            new TwigFunction('max', 'max'),\n            new TwigFunction('min', 'min'),\n            new TwigFunction('range', 'range'),\n            new TwigFunction('constant', 'twig_constant'),\n            new TwigFunction('cycle', 'twig_cycle'),\n            new TwigFunction('random', 'twig_random', ['needs_environment' => true]),\n            new TwigFunction('date', 'twig_date_converter', ['needs_environment' => true]),\n            new TwigFunction('include', 'twig_include', ['needs_environment' => true, 'needs_context' => true, 'is_safe' => ['all']]),\n            new TwigFunction('source', 'twig_source', ['needs_environment' => true, 'is_safe' => ['all']]),\n        ];\n    }\n\n    public function getTests()\n    {\n        return [\n            new TwigTest('even', null, ['node_class' => EvenTest::class]),\n            new TwigTest('odd', null, ['node_class' => OddTest::class]),\n            new TwigTest('defined', null, ['node_class' => DefinedTest::class]),\n            new TwigTest('same as', null, ['node_class' => SameasTest::class, 'one_mandatory_argument' => true]),\n            new TwigTest('none', null, ['node_class' => NullTest::class]),\n            new TwigTest('null', null, ['node_class' => NullTest::class]),\n            new TwigTest('divisible by', null, ['node_class' => DivisiblebyTest::class, 'one_mandatory_argument' => true]),\n            new TwigTest('constant', null, ['node_class' => ConstantTest::class]),\n            new TwigTest('empty', 'twig_test_empty'),\n            new TwigTest('iterable', 'twig_test_iterable'),\n        ];\n    }\n\n    public function getNodeVisitors()\n    {\n        return [new MacroAutoImportNodeVisitor()];\n    }\n\n    public function getOperators()\n    {\n        return [\n            [\n                'not' => ['precedence' => 50, 'class' => NotUnary::class],\n                '-' => ['precedence' => 500, 'class' => NegUnary::class],\n                '+' => ['precedence' => 500, 'class' => PosUnary::class],\n            ],\n            [\n                'or' => ['precedence' => 10, 'class' => OrBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'and' => ['precedence' => 15, 'class' => AndBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-or' => ['precedence' => 16, 'class' => BitwiseOrBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-xor' => ['precedence' => 17, 'class' => BitwiseXorBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-and' => ['precedence' => 18, 'class' => BitwiseAndBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '==' => ['precedence' => 20, 'class' => EqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '!=' => ['precedence' => 20, 'class' => NotEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<=>' => ['precedence' => 20, 'class' => SpaceshipBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<' => ['precedence' => 20, 'class' => LessBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '>' => ['precedence' => 20, 'class' => GreaterBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '>=' => ['precedence' => 20, 'class' => GreaterEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<=' => ['precedence' => 20, 'class' => LessEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'not in' => ['precedence' => 20, 'class' => NotInBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'in' => ['precedence' => 20, 'class' => InBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'matches' => ['precedence' => 20, 'class' => MatchesBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'starts with' => ['precedence' => 20, 'class' => StartsWithBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'ends with' => ['precedence' => 20, 'class' => EndsWithBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '..' => ['precedence' => 25, 'class' => RangeBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '+' => ['precedence' => 30, 'class' => AddBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '-' => ['precedence' => 30, 'class' => SubBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '~' => ['precedence' => 40, 'class' => ConcatBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '*' => ['precedence' => 60, 'class' => MulBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '/' => ['precedence' => 60, 'class' => DivBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '//' => ['precedence' => 60, 'class' => FloorDivBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '%' => ['precedence' => 60, 'class' => ModBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'is' => ['precedence' => 100, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'is not' => ['precedence' => 100, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '**' => ['precedence' => 200, 'class' => PowerBinary::class, 'associativity' => ExpressionParser::OPERATOR_RIGHT],\n                '??' => ['precedence' => 300, 'class' => NullCoalesceExpression::class, 'associativity' => ExpressionParser::OPERATOR_RIGHT],\n            ],\n        ];\n    }\n}\n\nclass_alias('Twig\\Extension\\CoreExtension', 'Twig_Extension_Core');\n}\n\nnamespace {\n    use Twig\\Environment;\n    use Twig\\Error\\LoaderError;\n    use Twig\\Error\\RuntimeError;\n    use Twig\\Extension\\CoreExtension;\n    use Twig\\Extension\\SandboxExtension;\n    use Twig\\Markup;\n    use Twig\\Source;\n    use Twig\\Template;\n    use Twig\\TemplateWrapper;\n\n/**\n * Cycles over a value.\n *\n * @param \\ArrayAccess|array $values\n * @param int                $position The cycle position\n *\n * @return string The next value in the cycle\n */\nfunction twig_cycle($values, $position)\n{\n    if (!\\is_array($values) && !$values instanceof \\ArrayAccess) {\n        return $values;\n    }\n\n    return $values[$position % \\count($values)];\n}\n\n/**\n * Returns a random value depending on the supplied parameter type:\n * - a random item from a \\Traversable or array\n * - a random character from a string\n * - a random integer between 0 and the integer parameter.\n *\n * @param \\Traversable|array|int|float|string $values The values to pick a random item from\n * @param int|null                            $max    Maximum value used when $values is an int\n *\n * @throws RuntimeError when $values is an empty array (does not apply to an empty string which is returned as is)\n *\n * @return mixed A random value from the given sequence\n */\nfunction twig_random(Environment $env, $values = null, $max = null)\n{\n    if (null === $values) {\n        return null === $max ? mt_rand() : mt_rand(0, (int) $max);\n    }\n\n    if (\\is_int($values) || \\is_float($values)) {\n        if (null === $max) {\n            if ($values < 0) {\n                $max = 0;\n                $min = $values;\n            } else {\n                $max = $values;\n                $min = 0;\n            }\n        } else {\n            $min = $values;\n            $max = $max;\n        }\n\n        return mt_rand((int) $min, (int) $max);\n    }\n\n    if (\\is_string($values)) {\n        if ('' === $values) {\n            return '';\n        }\n\n        $charset = $env->getCharset();\n\n        if ('UTF-8' !== $charset) {\n            $values = twig_convert_encoding($values, 'UTF-8', $charset);\n        }\n\n        // unicode version of str_split()\n        // split at all positions, but not after the start and not before the end\n        $values = preg_split('/(?<!^)(?!$)/u', $values);\n\n        if ('UTF-8' !== $charset) {\n            foreach ($values as $i => $value) {\n                $values[$i] = twig_convert_encoding($value, $charset, 'UTF-8');\n            }\n        }\n    }\n\n    if (!twig_test_iterable($values)) {\n        return $values;\n    }\n\n    $values = twig_to_array($values);\n\n    if (0 === \\count($values)) {\n        throw new RuntimeError('The random function cannot pick from an empty array.');\n    }\n\n    return $values[array_rand($values, 1)];\n}\n\n/**\n * Converts a date to the given format.\n *\n *   {{ post.published_at|date(\"m/d/Y\") }}\n *\n * @param \\DateTimeInterface|\\DateInterval|string $date     A date\n * @param string|null                             $format   The target format, null to use the default\n * @param \\DateTimeZone|string|false|null         $timezone The target timezone, null to use the default, false to leave unchanged\n *\n * @return string The formatted date\n */\nfunction twig_date_format_filter(Environment $env, $date, $format = null, $timezone = null)\n{\n    if (null === $format) {\n        $formats = $env->getExtension(CoreExtension::class)->getDateFormat();\n        $format = $date instanceof \\DateInterval ? $formats[1] : $formats[0];\n    }\n\n    if ($date instanceof \\DateInterval) {\n        return $date->format($format);\n    }\n\n    return twig_date_converter($env, $date, $timezone)->format($format);\n}\n\n/**\n * Returns a new date object modified.\n *\n *   {{ post.published_at|date_modify(\"-1day\")|date(\"m/d/Y\") }}\n *\n * @param \\DateTimeInterface|string $date     A date\n * @param string                    $modifier A modifier string\n *\n * @return \\DateTimeInterface\n */\nfunction twig_date_modify_filter(Environment $env, $date, $modifier)\n{\n    $date = twig_date_converter($env, $date, false);\n\n    return $date->modify($modifier);\n}\n\n/**\n * Returns a formatted string.\n *\n * @param string|null $format\n * @param ...$values\n *\n * @return string\n */\nfunction twig_sprintf($format, ...$values)\n{\n    return sprintf($format ?? '', ...$values);\n}\n\n/**\n * Converts an input to a \\DateTime instance.\n *\n *    {% if date(user.created_at) < date('+2days') %}\n *      {# do something #}\n *    {% endif %}\n *\n * @param \\DateTimeInterface|string|null  $date     A date or null to use the current time\n * @param \\DateTimeZone|string|false|null $timezone The target timezone, null to use the default, false to leave unchanged\n *\n * @return \\DateTimeInterface\n */\nfunction twig_date_converter(Environment $env, $date = null, $timezone = null)\n{\n    // determine the timezone\n    if (false !== $timezone) {\n        if (null === $timezone) {\n            $timezone = $env->getExtension(CoreExtension::class)->getTimezone();\n        } elseif (!$timezone instanceof \\DateTimeZone) {\n            $timezone = new \\DateTimeZone($timezone);\n        }\n    }\n\n    // immutable dates\n    if ($date instanceof \\DateTimeImmutable) {\n        return false !== $timezone ? $date->setTimezone($timezone) : $date;\n    }\n\n    if ($date instanceof \\DateTimeInterface) {\n        $date = clone $date;\n        if (false !== $timezone) {\n            $date->setTimezone($timezone);\n        }\n\n        return $date;\n    }\n\n    if (null === $date || 'now' === $date) {\n        if (null === $date) {\n            $date = 'now';\n        }\n\n        return new \\DateTime($date, false !== $timezone ? $timezone : $env->getExtension(CoreExtension::class)->getTimezone());\n    }\n\n    $asString = (string) $date;\n    if (ctype_digit($asString) || (!empty($asString) && '-' === $asString[0] && ctype_digit(substr($asString, 1)))) {\n        $date = new \\DateTime('@'.$date);\n    } else {\n        $date = new \\DateTime($date, $env->getExtension(CoreExtension::class)->getTimezone());\n    }\n\n    if (false !== $timezone) {\n        $date->setTimezone($timezone);\n    }\n\n    return $date;\n}\n\n/**\n * Replaces strings within a string.\n *\n * @param string|null        $str  String to replace in\n * @param array|\\Traversable $from Replace values\n *\n * @return string\n */\nfunction twig_replace_filter($str, $from)\n{\n    if (!twig_test_iterable($from)) {\n        throw new RuntimeError(sprintf('The \"replace\" filter expects an array or \"Traversable\" as replace values, got \"%s\".', \\is_object($from) ? \\get_class($from) : \\gettype($from)));\n    }\n\n    return strtr($str ?? '', twig_to_array($from));\n}\n\n/**\n * Rounds a number.\n *\n * @param int|float|string|null $value     The value to round\n * @param int|float             $precision The rounding precision\n * @param string                $method    The method to use for rounding\n *\n * @return int|float The rounded number\n */\nfunction twig_round($value, $precision = 0, $method = 'common')\n{\n    $value = (float) $value;\n\n    if ('common' === $method) {\n        return round($value, $precision);\n    }\n\n    if ('ceil' !== $method && 'floor' !== $method) {\n        throw new RuntimeError('The round filter only supports the \"common\", \"ceil\", and \"floor\" methods.');\n    }\n\n    return $method($value * 10 ** $precision) / 10 ** $precision;\n}\n\n/**\n * Number format filter.\n *\n * All of the formatting options can be left null, in that case the defaults will\n * be used. Supplying any of the parameters will override the defaults set in the\n * environment object.\n *\n * @param mixed  $number       A float/int/string of the number to format\n * @param int    $decimal      the number of decimal points to display\n * @param string $decimalPoint the character(s) to use for the decimal point\n * @param string $thousandSep  the character(s) to use for the thousands separator\n *\n * @return string The formatted number\n */\nfunction twig_number_format_filter(Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)\n{\n    $defaults = $env->getExtension(CoreExtension::class)->getNumberFormat();\n    if (null === $decimal) {\n        $decimal = $defaults[0];\n    }\n\n    if (null === $decimalPoint) {\n        $decimalPoint = $defaults[1];\n    }\n\n    if (null === $thousandSep) {\n        $thousandSep = $defaults[2];\n    }\n\n    return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);\n}\n\n/**\n * URL encodes (RFC 3986) a string as a path segment or an array as a query string.\n *\n * @param string|array|null $url A URL or an array of query parameters\n *\n * @return string The URL encoded value\n */\nfunction twig_urlencode_filter($url)\n{\n    if (\\is_array($url)) {\n        return http_build_query($url, '', '&', \\PHP_QUERY_RFC3986);\n    }\n\n    return rawurlencode($url ?? '');\n}\n\n/**\n * Merges an array with another one.\n *\n *  {% set items = { 'apple': 'fruit', 'orange': 'fruit' } %}\n *\n *  {% set items = items|merge({ 'peugeot': 'car' }) %}\n *\n *  {# items now contains { 'apple': 'fruit', 'orange': 'fruit', 'peugeot': 'car' } #}\n *\n * @param array|\\Traversable $arr1 An array\n * @param array|\\Traversable $arr2 An array\n *\n * @return array The merged array\n */\nfunction twig_array_merge($arr1, $arr2)\n{\n    if (!twig_test_iterable($arr1)) {\n        throw new RuntimeError(sprintf('The merge filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($arr1)));\n    }\n\n    if (!twig_test_iterable($arr2)) {\n        throw new RuntimeError(sprintf('The merge filter only works with arrays or \"Traversable\", got \"%s\" as second argument.', \\gettype($arr2)));\n    }\n\n    return array_merge(twig_to_array($arr1), twig_to_array($arr2));\n}\n\n/**\n * Slices a variable.\n *\n * @param mixed $item         A variable\n * @param int   $start        Start of the slice\n * @param int   $length       Size of the slice\n * @param bool  $preserveKeys Whether to preserve key or not (when the input is an array)\n *\n * @return mixed The sliced variable\n */\nfunction twig_slice(Environment $env, $item, $start, $length = null, $preserveKeys = false)\n{\n    if ($item instanceof \\Traversable) {\n        while ($item instanceof \\IteratorAggregate) {\n            $item = $item->getIterator();\n        }\n\n        if ($start >= 0 && $length >= 0 && $item instanceof \\Iterator) {\n            try {\n                return iterator_to_array(new \\LimitIterator($item, $start, null === $length ? -1 : $length), $preserveKeys);\n            } catch (\\OutOfBoundsException $e) {\n                return [];\n            }\n        }\n\n        $item = iterator_to_array($item, $preserveKeys);\n    }\n\n    if (\\is_array($item)) {\n        return \\array_slice($item, $start, $length, $preserveKeys);\n    }\n\n    return (string) mb_substr((string) $item, $start, $length, $env->getCharset());\n}\n\n/**\n * Returns the first element of the item.\n *\n * @param mixed $item A variable\n *\n * @return mixed The first element of the item\n */\nfunction twig_first(Environment $env, $item)\n{\n    $elements = twig_slice($env, $item, 0, 1, false);\n\n    return \\is_string($elements) ? $elements : current($elements);\n}\n\n/**\n * Returns the last element of the item.\n *\n * @param mixed $item A variable\n *\n * @return mixed The last element of the item\n */\nfunction twig_last(Environment $env, $item)\n{\n    $elements = twig_slice($env, $item, -1, 1, false);\n\n    return \\is_string($elements) ? $elements : current($elements);\n}\n\n/**\n * Joins the values to a string.\n *\n * The separators between elements are empty strings per default, you can define them with the optional parameters.\n *\n *  {{ [1, 2, 3]|join(', ', ' and ') }}\n *  {# returns 1, 2 and 3 #}\n *\n *  {{ [1, 2, 3]|join('|') }}\n *  {# returns 1|2|3 #}\n *\n *  {{ [1, 2, 3]|join }}\n *  {# returns 123 #}\n *\n * @param array       $value An array\n * @param string      $glue  The separator\n * @param string|null $and   The separator for the last pair\n *\n * @return string The concatenated string\n */\nfunction twig_join_filter($value, $glue = '', $and = null)\n{\n    if (!twig_test_iterable($value)) {\n        $value = (array) $value;\n    }\n\n    $value = twig_to_array($value, false);\n\n    if (0 === \\count($value)) {\n        return '';\n    }\n\n    if (null === $and || $and === $glue) {\n        return implode($glue, $value);\n    }\n\n    if (1 === \\count($value)) {\n        return $value[0];\n    }\n\n    return implode($glue, \\array_slice($value, 0, -1)).$and.$value[\\count($value) - 1];\n}\n\n/**\n * Splits the string into an array.\n *\n *  {{ \"one,two,three\"|split(',') }}\n *  {# returns [one, two, three] #}\n *\n *  {{ \"one,two,three,four,five\"|split(',', 3) }}\n *  {# returns [one, two, \"three,four,five\"] #}\n *\n *  {{ \"123\"|split('') }}\n *  {# returns [1, 2, 3] #}\n *\n *  {{ \"aabbcc\"|split('', 2) }}\n *  {# returns [aa, bb, cc] #}\n *\n * @param string|null $value     A string\n * @param string      $delimiter The delimiter\n * @param int         $limit     The limit\n *\n * @return array The split string as an array\n */\nfunction twig_split_filter(Environment $env, $value, $delimiter, $limit = null)\n{\n    $value = $value ?? '';\n\n    if (\\strlen($delimiter) > 0) {\n        return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);\n    }\n\n    if ($limit <= 1) {\n        return preg_split('/(?<!^)(?!$)/u', $value);\n    }\n\n    $length = mb_strlen($value, $env->getCharset());\n    if ($length < $limit) {\n        return [$value];\n    }\n\n    $r = [];\n    for ($i = 0; $i < $length; $i += $limit) {\n        $r[] = mb_substr($value, $i, $limit, $env->getCharset());\n    }\n\n    return $r;\n}\n\n// The '_default' filter is used internally to avoid using the ternary operator\n// which costs a lot for big contexts (before PHP 5.4). So, on average,\n// a function call is cheaper.\n/**\n * @internal\n */\nfunction _twig_default_filter($value, $default = '')\n{\n    if (twig_test_empty($value)) {\n        return $default;\n    }\n\n    return $value;\n}\n\n/**\n * Returns the keys for the given array.\n *\n * It is useful when you want to iterate over the keys of an array:\n *\n *  {% for key in array|keys %}\n *      {# ... #}\n *  {% endfor %}\n *\n * @param array $array An array\n *\n * @return array The keys\n */\nfunction twig_get_array_keys_filter($array)\n{\n    if ($array instanceof \\Traversable) {\n        while ($array instanceof \\IteratorAggregate) {\n            $array = $array->getIterator();\n        }\n\n        if ($array instanceof \\Iterator) {\n            $keys = [];\n            $array->rewind();\n            while ($array->valid()) {\n                $keys[] = $array->key();\n                $array->next();\n            }\n\n            return $keys;\n        }\n\n        $keys = [];\n        foreach ($array as $key => $item) {\n            $keys[] = $key;\n        }\n\n        return $keys;\n    }\n\n    if (!\\is_array($array)) {\n        return [];\n    }\n\n    return array_keys($array);\n}\n\n/**\n * Reverses a variable.\n *\n * @param array|\\Traversable|string|null $item         An array, a \\Traversable instance, or a string\n * @param bool                           $preserveKeys Whether to preserve key or not\n *\n * @return mixed The reversed input\n */\nfunction twig_reverse_filter(Environment $env, $item, $preserveKeys = false)\n{\n    if ($item instanceof \\Traversable) {\n        return array_reverse(iterator_to_array($item), $preserveKeys);\n    }\n\n    if (\\is_array($item)) {\n        return array_reverse($item, $preserveKeys);\n    }\n\n    $string = (string) $item;\n\n    $charset = $env->getCharset();\n\n    if ('UTF-8' !== $charset) {\n        $string = twig_convert_encoding($string, 'UTF-8', $charset);\n    }\n\n    preg_match_all('/./us', $string, $matches);\n\n    $string = implode('', array_reverse($matches[0]));\n\n    if ('UTF-8' !== $charset) {\n        $string = twig_convert_encoding($string, $charset, 'UTF-8');\n    }\n\n    return $string;\n}\n\n/**\n * Sorts an array.\n *\n * @param array|\\Traversable $array\n *\n * @return array\n */\nfunction twig_sort_filter($array, $arrow = null)\n{\n    if ($array instanceof \\Traversable) {\n        $array = iterator_to_array($array);\n    } elseif (!\\is_array($array)) {\n        throw new RuntimeError(sprintf('The sort filter only works with arrays or \"Traversable\", got \"%s\".', \\gettype($array)));\n    }\n\n    if (null !== $arrow) {\n        uasort($array, $arrow);\n    } else {\n        asort($array);\n    }\n\n    return $array;\n}\n\n/**\n * @internal\n */\nfunction twig_in_filter($value, $compare)\n{\n    if ($value instanceof Markup) {\n        $value = (string) $value;\n    }\n    if ($compare instanceof Markup) {\n        $compare = (string) $compare;\n    }\n\n    if (\\is_array($compare)) {\n        return \\in_array($value, $compare, \\is_object($value) || \\is_resource($value));\n    } elseif (\\is_string($compare) && (\\is_string($value) || \\is_int($value) || \\is_float($value))) {\n        return '' === $value || false !== strpos($compare, (string) $value);\n    } elseif ($compare instanceof \\Traversable) {\n        if (\\is_object($value) || \\is_resource($value)) {\n            foreach ($compare as $item) {\n                if ($item === $value) {\n                    return true;\n                }\n            }\n        } else {\n            foreach ($compare as $item) {\n                if ($item == $value) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    return false;\n}\n\n/**\n * Returns a trimmed string.\n *\n * @param string|null $string\n * @param string|null $characterMask\n * @param string      $side\n *\n * @return string\n *\n * @throws RuntimeError When an invalid trimming side is used (not a string or not 'left', 'right', or 'both')\n */\nfunction twig_trim_filter($string, $characterMask = null, $side = 'both')\n{\n    if (null === $characterMask) {\n        $characterMask = \" \\t\\n\\r\\0\\x0B\";\n    }\n\n    switch ($side) {\n        case 'both':\n            return trim($string ?? '', $characterMask);\n        case 'left':\n            return ltrim($string ?? '', $characterMask);\n        case 'right':\n            return rtrim($string ?? '', $characterMask);\n        default:\n            throw new RuntimeError('Trimming side must be \"left\", \"right\" or \"both\".');\n    }\n}\n\n/**\n * Inserts HTML line breaks before all newlines in a string.\n *\n * @param string|null $string\n *\n * @return string\n */\nfunction twig_nl2br($string)\n{\n    return nl2br($string ?? '');\n}\n\n/**\n * Removes whitespaces between HTML tags.\n *\n * @param string|null $string\n *\n * @return string\n */\nfunction twig_spaceless($content)\n{\n    return trim(preg_replace('/>\\s+</', '><', $content ?? ''));\n}\n\n/**\n * @param string|null $string\n * @param string      $to\n * @param string      $from\n *\n * @return string\n */\nfunction twig_convert_encoding($string, $to, $from)\n{\n    if (!\\function_exists('iconv')) {\n        throw new RuntimeError('Unable to convert encoding: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');\n    }\n\n    return iconv($from, $to, $string ?? '');\n}\n\n/**\n * Returns the length of a variable.\n *\n * @param mixed $thing A variable\n *\n * @return int The length of the value\n */\nfunction twig_length_filter(Environment $env, $thing)\n{\n    if (null === $thing) {\n        return 0;\n    }\n\n    if (is_scalar($thing)) {\n        return mb_strlen($thing, $env->getCharset());\n    }\n\n    if ($thing instanceof \\Countable || \\is_array($thing) || $thing instanceof \\SimpleXMLElement) {\n        return \\count($thing);\n    }\n\n    if ($thing instanceof \\Traversable) {\n        return iterator_count($thing);\n    }\n\n    if (method_exists($thing, '__toString') && !$thing instanceof \\Countable) {\n        return mb_strlen((string) $thing, $env->getCharset());\n    }\n\n    return 1;\n}\n\n/**\n * Converts a string to uppercase.\n *\n * @param string|null $string A string\n *\n * @return string The uppercased string\n */\nfunction twig_upper_filter(Environment $env, $string)\n{\n    return mb_strtoupper($string ?? '', $env->getCharset());\n}\n\n/**\n * Converts a string to lowercase.\n *\n * @param string|null $string A string\n *\n * @return string The lowercased string\n */\nfunction twig_lower_filter(Environment $env, $string)\n{\n    return mb_strtolower($string ?? '', $env->getCharset());\n}\n\n/**\n * Strips HTML and PHP tags from a string.\n *\n * @param string|null $string\n * @param string[]|string|null $string\n *\n * @return string\n */\nfunction twig_striptags($string, $allowable_tags = null)\n{\n    return strip_tags($string ?? '', $allowable_tags);\n}\n\n/**\n * Returns a titlecased string.\n *\n * @param string|null $string A string\n *\n * @return string The titlecased string\n */\nfunction twig_title_string_filter(Environment $env, $string)\n{\n    if (null !== $charset = $env->getCharset()) {\n        return mb_convert_case($string ?? '', \\MB_CASE_TITLE, $charset);\n    }\n\n    return ucwords(strtolower($string ?? ''));\n}\n\n/**\n * Returns a capitalized string.\n *\n * @param string|null $string A string\n *\n * @return string The capitalized string\n */\nfunction twig_capitalize_string_filter(Environment $env, $string)\n{\n    $charset = $env->getCharset();\n\n    return mb_strtoupper(mb_substr($string ?? '', 0, 1, $charset), $charset).mb_strtolower(mb_substr($string ?? '', 1, null, $charset), $charset);\n}\n\n/**\n * @internal\n */\nfunction twig_call_macro(Template $template, string $method, array $args, int $lineno, array $context, Source $source)\n{\n    if (!method_exists($template, $method)) {\n        $parent = $template;\n        while ($parent = $parent->getParent($context)) {\n            if (method_exists($parent, $method)) {\n                return $parent->$method(...$args);\n            }\n        }\n\n        throw new RuntimeError(sprintf('Macro \"%s\" is not defined in template \"%s\".', substr($method, \\strlen('macro_')), $template->getTemplateName()), $lineno, $source);\n    }\n\n    return $template->$method(...$args);\n}\n\n/**\n * @internal\n */\nfunction twig_ensure_traversable($seq)\n{\n    if ($seq instanceof \\Traversable || \\is_array($seq)) {\n        return $seq;\n    }\n\n    return [];\n}\n\n/**\n * @internal\n */\nfunction twig_to_array($seq, $preserveKeys = true)\n{\n    if ($seq instanceof \\Traversable) {\n        return iterator_to_array($seq, $preserveKeys);\n    }\n\n    if (!\\is_array($seq)) {\n        return $seq;\n    }\n\n    return $preserveKeys ? $seq : array_values($seq);\n}\n\n/**\n * Checks if a variable is empty.\n *\n *    {# evaluates to true if the foo variable is null, false, or the empty string #}\n *    {% if foo is empty %}\n *        {# ... #}\n *    {% endif %}\n *\n * @param mixed $value A variable\n *\n * @return bool true if the value is empty, false otherwise\n */\nfunction twig_test_empty($value)\n{\n    if ($value instanceof \\Countable) {\n        return 0 === \\count($value);\n    }\n\n    if ($value instanceof \\Traversable) {\n        return !iterator_count($value);\n    }\n\n    if (\\is_object($value) && method_exists($value, '__toString')) {\n        return '' === (string) $value;\n    }\n\n    return '' === $value || false === $value || null === $value || [] === $value;\n}\n\n/**\n * Checks if a variable is traversable.\n *\n *    {# evaluates to true if the foo variable is an array or a traversable object #}\n *    {% if foo is iterable %}\n *        {# ... #}\n *    {% endif %}\n *\n * @param mixed $value A variable\n *\n * @return bool true if the value is traversable\n */\nfunction twig_test_iterable($value)\n{\n    return $value instanceof \\Traversable || \\is_array($value);\n}\n\n/**\n * Renders a template.\n *\n * @param array        $context\n * @param string|array $template      The template to render or an array of templates to try consecutively\n * @param array        $variables     The variables to pass to the template\n * @param bool         $withContext\n * @param bool         $ignoreMissing Whether to ignore missing templates or not\n * @param bool         $sandboxed     Whether to sandbox the template or not\n *\n * @return string The rendered template\n */\nfunction twig_include(Environment $env, $context, $template, $variables = [], $withContext = true, $ignoreMissing = false, $sandboxed = false)\n{\n    $alreadySandboxed = false;\n    $sandbox = null;\n    if ($withContext) {\n        $variables = array_merge($context, $variables);\n    }\n\n    if ($isSandboxed = $sandboxed && $env->hasExtension(SandboxExtension::class)) {\n        $sandbox = $env->getExtension(SandboxExtension::class);\n        if (!$alreadySandboxed = $sandbox->isSandboxed()) {\n            $sandbox->enableSandbox();\n        }\n\n        foreach ((\\is_array($template) ? $template : [$template]) as $name) {\n            // if a Template instance is passed, it might have been instantiated outside of a sandbox, check security\n            if ($name instanceof TemplateWrapper || $name instanceof Template) {\n                $name->unwrap()->checkSecurity();\n            }\n        }\n    }\n\n    try {\n        $loaded = null;\n        try {\n            $loaded = $env->resolveTemplate($template);\n        } catch (LoaderError $e) {\n            if (!$ignoreMissing) {\n                throw $e;\n            }\n        }\n\n        return $loaded ? $loaded->render($variables) : '';\n    } finally {\n        if ($isSandboxed && !$alreadySandboxed) {\n            $sandbox->disableSandbox();\n        }\n    }\n}\n\n/**\n * Returns a template content without rendering it.\n *\n * @param string $name          The template name\n * @param bool   $ignoreMissing Whether to ignore missing templates or not\n *\n * @return string The template source\n */\nfunction twig_source(Environment $env, $name, $ignoreMissing = false)\n{\n    $loader = $env->getLoader();\n    try {\n        return $loader->getSourceContext($name)->getCode();\n    } catch (LoaderError $e) {\n        if (!$ignoreMissing) {\n            throw $e;\n        }\n    }\n}\n\n/**\n * Provides the ability to get constants from instances as well as class/global constants.\n *\n * @param string      $constant The name of the constant\n * @param object|null $object   The object to get the constant from\n *\n * @return string\n */\nfunction twig_constant($constant, $object = null)\n{\n    if (null !== $object) {\n        $constant = \\get_class($object).'::'.$constant;\n    }\n\n    return \\constant($constant);\n}\n\n/**\n * Checks if a constant exists.\n *\n * @param string      $constant The name of the constant\n * @param object|null $object   The object to get the constant from\n *\n * @return bool\n */\nfunction twig_constant_is_defined($constant, $object = null)\n{\n    if (null !== $object) {\n        $constant = \\get_class($object).'::'.$constant;\n    }\n\n    return \\defined($constant);\n}\n\n/**\n * Batches item.\n *\n * @param array $items An array of items\n * @param int   $size  The size of the batch\n * @param mixed $fill  A value used to fill missing items\n *\n * @return array\n */\nfunction twig_array_batch($items, $size, $fill = null, $preserveKeys = true)\n{\n    if (!twig_test_iterable($items)) {\n        throw new RuntimeError(sprintf('The \"batch\" filter expects an array or \"Traversable\", got \"%s\".', \\is_object($items) ? \\get_class($items) : \\gettype($items)));\n    }\n\n    $size = ceil($size);\n\n    $result = array_chunk(twig_to_array($items, $preserveKeys), $size, $preserveKeys);\n\n    if (null !== $fill && $result) {\n        $last = \\count($result) - 1;\n        if ($fillCount = $size - \\count($result[$last])) {\n            for ($i = 0; $i < $fillCount; ++$i) {\n                $result[$last][] = $fill;\n            }\n        }\n    }\n\n    return $result;\n}\n\n/**\n * Returns the attribute value for a given array/object.\n *\n * @param mixed  $object            The object or array from where to get the item\n * @param mixed  $item              The item to get from the array or object\n * @param array  $arguments         An array of arguments to pass if the item is an object method\n * @param string $type              The type of attribute (@see \\Twig\\Template constants)\n * @param bool   $isDefinedTest     Whether this is only a defined check\n * @param bool   $ignoreStrictCheck Whether to ignore the strict attribute check or not\n * @param int    $lineno            The template line where the attribute was called\n *\n * @return mixed The attribute value, or a Boolean when $isDefinedTest is true, or null when the attribute is not set and $ignoreStrictCheck is true\n *\n * @throws RuntimeError if the attribute does not exist and Twig is running in strict mode and $isDefinedTest is false\n *\n * @internal\n */\nfunction twig_get_attribute(Environment $env, Source $source, $object, $item, array $arguments = [], $type = /* Template::ANY_CALL */ 'any', $isDefinedTest = false, $ignoreStrictCheck = false, $sandboxed = false, int $lineno = -1)\n{\n    // array\n    if (/* Template::METHOD_CALL */ 'method' !== $type) {\n        $arrayItem = \\is_bool($item) || \\is_float($item) ? (int) $item : $item;\n\n        if (((\\is_array($object) || $object instanceof \\ArrayObject) && (isset($object[$arrayItem]) || \\array_key_exists($arrayItem, (array) $object)))\n            || ($object instanceof ArrayAccess && isset($object[$arrayItem]))\n        ) {\n            if ($isDefinedTest) {\n                return true;\n            }\n\n            return $object[$arrayItem];\n        }\n\n        if (/* Template::ARRAY_CALL */ 'array' === $type || !\\is_object($object)) {\n            if ($isDefinedTest) {\n                return false;\n            }\n\n            if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n                return;\n            }\n\n            if ($object instanceof ArrayAccess) {\n                $message = sprintf('Key \"%s\" in object with ArrayAccess of class \"%s\" does not exist.', $arrayItem, \\get_class($object));\n            } elseif (\\is_object($object)) {\n                $message = sprintf('Impossible to access a key \"%s\" on an object of class \"%s\" that does not implement ArrayAccess interface.', $item, \\get_class($object));\n            } elseif (\\is_array($object)) {\n                if (empty($object)) {\n                    $message = sprintf('Key \"%s\" does not exist as the array is empty.', $arrayItem);\n                } else {\n                    $message = sprintf('Key \"%s\" for array with keys \"%s\" does not exist.', $arrayItem, implode(', ', array_keys($object)));\n                }\n            } elseif (/* Template::ARRAY_CALL */ 'array' === $type) {\n                if (null === $object) {\n                    $message = sprintf('Impossible to access a key (\"%s\") on a null variable.', $item);\n                } else {\n                    $message = sprintf('Impossible to access a key (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n                }\n            } elseif (null === $object) {\n                $message = sprintf('Impossible to access an attribute (\"%s\") on a null variable.', $item);\n            } else {\n                $message = sprintf('Impossible to access an attribute (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n            }\n\n            throw new RuntimeError($message, $lineno, $source);\n        }\n    }\n\n    if (!\\is_object($object)) {\n        if ($isDefinedTest) {\n            return false;\n        }\n\n        if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n            return;\n        }\n\n        if (null === $object) {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on a null variable.', $item);\n        } elseif (\\is_array($object)) {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on an array.', $item);\n        } else {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n        }\n\n        throw new RuntimeError($message, $lineno, $source);\n    }\n\n    if ($object instanceof Template) {\n        throw new RuntimeError('Accessing \\Twig\\Template attributes is forbidden.', $lineno, $source);\n    }\n\n    // object property\n    if (/* Template::METHOD_CALL */ 'method' !== $type) {\n        if (isset($object->$item) || \\array_key_exists((string) $item, (array) $object)) {\n            if ($isDefinedTest) {\n                return true;\n            }\n\n            if ($sandboxed) {\n                $env->getExtension(SandboxExtension::class)->checkPropertyAllowed($object, $item, $lineno, $source);\n            }\n\n            return $object->$item;\n        }\n    }\n\n    static $cache = [];\n\n    $class = \\get_class($object);\n\n    // object method\n    // precedence: getXxx() > isXxx() > hasXxx()\n    if (!isset($cache[$class])) {\n        $methods = get_class_methods($object);\n        sort($methods);\n        $lcMethods = array_map(function ($value) { return strtr($value, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'); }, $methods);\n        $classCache = [];\n        foreach ($methods as $i => $method) {\n            $classCache[$method] = $method;\n            $classCache[$lcName = $lcMethods[$i]] = $method;\n\n            if ('g' === $lcName[0] && 0 === strpos($lcName, 'get')) {\n                $name = substr($method, 3);\n                $lcName = substr($lcName, 3);\n            } elseif ('i' === $lcName[0] && 0 === strpos($lcName, 'is')) {\n                $name = substr($method, 2);\n                $lcName = substr($lcName, 2);\n            } elseif ('h' === $lcName[0] && 0 === strpos($lcName, 'has')) {\n                $name = substr($method, 3);\n                $lcName = substr($lcName, 3);\n                if (\\in_array('is'.$lcName, $lcMethods)) {\n                    continue;\n                }\n            } else {\n                continue;\n            }\n\n            // skip get() and is() methods (in which case, $name is empty)\n            if ($name) {\n                if (!isset($classCache[$name])) {\n                    $classCache[$name] = $method;\n                }\n\n                if (!isset($classCache[$lcName])) {\n                    $classCache[$lcName] = $method;\n                }\n            }\n        }\n        $cache[$class] = $classCache;\n    }\n\n    $call = false;\n    if (isset($cache[$class][$item])) {\n        $method = $cache[$class][$item];\n    } elseif (isset($cache[$class][$lcItem = strtr($item, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')])) {\n        $method = $cache[$class][$lcItem];\n    } elseif (isset($cache[$class]['__call'])) {\n        $method = $item;\n        $call = true;\n    } else {\n        if ($isDefinedTest) {\n            return false;\n        }\n\n        if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n            return;\n        }\n\n        throw new RuntimeError(sprintf('Neither the property \"%1$s\" nor one of the methods \"%1$s()\", \"get%1$s()\"/\"is%1$s()\"/\"has%1$s()\" or \"__call()\" exist and have public access in class \"%2$s\".', $item, $class), $lineno, $source);\n    }\n\n    if ($isDefinedTest) {\n        return true;\n    }\n\n    if ($sandboxed) {\n        $env->getExtension(SandboxExtension::class)->checkMethodAllowed($object, $method, $lineno, $source);\n    }\n\n    // Some objects throw exceptions when they have __call, and the method we try\n    // to call is not supported. If ignoreStrictCheck is true, we should return null.\n    try {\n        $ret = $object->$method(...$arguments);\n    } catch (\\BadMethodCallException $e) {\n        if ($call && ($ignoreStrictCheck || !$env->isStrictVariables())) {\n            return;\n        }\n        throw $e;\n    }\n\n    return $ret;\n}\n\n/**\n * Returns the values from a single column in the input array.\n *\n * <pre>\n *  {% set items = [{ 'fruit' : 'apple'}, {'fruit' : 'orange' }] %}\n *\n *  {% set fruits = items|column('fruit') %}\n *\n *  {# fruits now contains ['apple', 'orange'] #}\n * </pre>\n *\n * @param array|Traversable $array An array\n * @param mixed             $name  The column name\n * @param mixed             $index The column to use as the index/keys for the returned array\n *\n * @return array The array of values\n */\nfunction twig_array_column($array, $name, $index = null): array\n{\n    if ($array instanceof Traversable) {\n        $array = iterator_to_array($array);\n    } elseif (!\\is_array($array)) {\n        throw new RuntimeError(sprintf('The column filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($array)));\n    }\n\n    return array_column($array, $name, $index);\n}\n\nfunction twig_array_filter(Environment $env, $array, $arrow)\n{\n    if (!twig_test_iterable($array)) {\n        throw new RuntimeError(sprintf('The \"filter\" filter expects an array or \"Traversable\", got \"%s\".', \\is_object($array) ? \\get_class($array) : \\gettype($array)));\n    }\n\n    if (!$arrow instanceof Closure && $env->hasExtension('\\Twig\\Extension\\SandboxExtension') && $env->getExtension('\\Twig\\Extension\\SandboxExtension')->isSandboxed()) {\n        throw new RuntimeError('The callable passed to \"filter\" filter must be a Closure in sandbox mode.');\n    }\n\n    if (\\is_array($array)) {\n        return array_filter($array, $arrow, \\ARRAY_FILTER_USE_BOTH);\n    }\n\n    // the IteratorIterator wrapping is needed as some internal PHP classes are \\Traversable but do not implement \\Iterator\n    return new \\CallbackFilterIterator(new \\IteratorIterator($array), $arrow);\n}\n\nfunction twig_array_map(Environment $env, $array, $arrow)\n{\n    if (!$arrow instanceof Closure && $env->hasExtension('\\Twig\\Extension\\SandboxExtension') && $env->getExtension('\\Twig\\Extension\\SandboxExtension')->isSandboxed()) {\n        throw new RuntimeError('The callable passed to the \"map\" filter must be a Closure in sandbox mode.');\n    }\n\n    $r = [];\n    foreach ($array as $k => $v) {\n        $r[$k] = $arrow($v, $k);\n    }\n\n    return $r;\n}\n\nfunction twig_array_reduce(Environment $env, $array, $arrow, $initial = null)\n{\n    if (!$arrow instanceof Closure && $env->hasExtension('\\Twig\\Extension\\SandboxExtension') && $env->getExtension('\\Twig\\Extension\\SandboxExtension')->isSandboxed()) {\n        throw new RuntimeError('The callable passed to the \"reduce\" filter must be a Closure in sandbox mode.');\n    }\n\n    if (!\\is_array($array)) {\n        if (!$array instanceof \\Traversable) {\n            throw new RuntimeError(sprintf('The \"reduce\" filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($array)));\n        }\n\n        $array = iterator_to_array($array);\n    }\n\n    return array_reduce($array, $arrow, $initial);\n}\n}\n", "<?php\n\nnamespace Twig\\Tests\\Extension;\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse PHPUnit\\Framework\\TestCase;\nuse Twig\\Environment;\nuse Twig\\Error\\SyntaxError;\nuse Twig\\Extension\\SandboxExtension;\nuse Twig\\Extension\\StringLoaderExtension;\nuse Twig\\Loader\\ArrayLoader;\nuse Twig\\Sandbox\\SecurityError;\nuse Twig\\Sandbox\\SecurityNotAllowedFilterError;\nuse Twig\\Sandbox\\SecurityNotAllowedFunctionError;\nuse Twig\\Sandbox\\SecurityNotAllowedMethodError;\nuse Twig\\Sandbox\\SecurityNotAllowedPropertyError;\nuse Twig\\Sandbox\\SecurityNotAllowedTagError;\nuse Twig\\Sandbox\\SecurityPolicy;\n\nclass SandboxTest extends TestCase\n{\n    protected static $params;\n    protected static $templates;\n\n    protected function setUp(): void\n    {\n        self::$params = [\n            'name' => 'Fabien',\n            'obj' => new FooObject(),\n            'arr' => ['obj' => new FooObject()],\n        ];\n\n        self::$templates = [\n            '1_basic1' => '{{ obj.foo }}',\n            '1_basic2' => '{{ name|upper }}',\n            '1_basic3' => '{% if name %}foo{% endif %}',\n            '1_basic4' => '{{ obj.bar }}',\n            '1_basic5' => '{{ obj }}',\n            '1_basic7' => '{{ cycle([\"foo\",\"bar\"], 1) }}',\n            '1_basic8' => '{{ obj.getfoobar }}{{ obj.getFooBar }}',\n            '1_basic9' => '{{ obj.foobar }}{{ obj.fooBar }}',\n            '1_basic' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n            '1_layout' => '{% block content %}{% endblock %}',\n            '1_child' => \"{% extends \\\"1_layout\\\" %}\\n{% block content %}\\n{{ \\\"a\\\"|json_encode }}\\n{% endblock %}\",\n            '1_include' => '{{ include(\"1_basic1\", sandboxed=true) }}',\n            '1_basic2_include_template_from_string_sandboxed' => '{{ include(template_from_string(\"{{ name|upper }}\"), sandboxed=true) }}',\n            '1_basic2_include_template_from_string' => '{{ include(template_from_string(\"{{ name|upper }}\")) }}',\n            '1_range_operator' => '{{ (1..2)[0] }}',\n            '1_syntax_error_wrapper' => '{% sandbox %}{% include \"1_syntax_error\" %}{% endsandbox %}',\n            '1_syntax_error' => '{% syntax error }}',\n        ];\n    }\n\n    public function testSandboxWithInheritance()\n    {\n        $this->expectException(SecurityError::class);\n        $this->expectExceptionMessage('Filter \"json_encode\" is not allowed in \"1_child\" at line 3.');\n\n        $twig = $this->getEnvironment(true, [], self::$templates, ['block']);\n        $twig->load('1_child')->render([]);\n    }\n\n    public function testSandboxGloballySet()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $this->assertEquals('FOO', $twig->load('1_basic')->render(self::$params), 'Sandbox does nothing if it is disabled globally');\n    }\n\n    public function testSandboxUnallowedMethodAccessor()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic1')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed method is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedMethodError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedMethodError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('foo', $e->getMethodName(), 'Exception should be raised on the \"foo\" method');\n        }\n    }\n\n    public function testIfSandBoxIsDisabledAfterSyntaxError()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        try {\n            $twig->load('1_syntax_error_wrapper')->render(self::$params);\n        } catch (SyntaxError $e) {\n            /** @var SandboxExtension $sandbox */\n            $sandbox = $twig->getExtension(SandboxExtension::class);\n            $this->assertFalse($sandbox->isSandboxed());\n        }\n    }\n\n    public function testSandboxGloballyFalseUnallowedFilterWithIncludeTemplateFromStringSandboxed()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string_sandboxed')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxGloballyTrueUnallowedFilterWithIncludeTemplateFromStringSandboxed()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['include', 'template_from_string']);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string_sandboxed')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxGloballyFalseUnallowedFilterWithIncludeTemplateFromStringNotSandboxed()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $twig->addExtension(new StringLoaderExtension());\n        $this->assertSame('FABIEN', $twig->load('1_basic2_include_template_from_string')->render(self::$params));\n    }\n\n    public function testSandboxGloballyTrueUnallowedFilterWithIncludeTemplateFromStringNotSandboxed()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['include', 'template_from_string']);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxUnallowedFilter()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic2')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFilterError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxUnallowedTag()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic3')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed tag is used in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedTagError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedTagError');\n            $this->assertEquals('if', $e->getTagName(), 'Exception should be raised on the \"if\" tag');\n        }\n    }\n\n    public function testSandboxUnallowedProperty()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic4')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed property is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedPropertyError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedPropertyError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('bar', $e->getPropertyName(), 'Exception should be raised on the \"bar\" property');\n        }\n    }\n\n    /**\n     * @dataProvider getSandboxUnallowedToStringTests\n     */\n    public function testSandboxUnallowedToString($template)\n    {\n        $twig = $this->getEnvironment(true, [], ['index' => $template], [], ['upper'], ['Twig\\Tests\\Extension\\FooObject' => 'getAnotherFooObject'], [], ['random']);\n        try {\n            $twig->load('index')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed method (__toString()) is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedMethodError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedMethodError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('__tostring', $e->getMethodName(), 'Exception should be raised on the \"__toString\" method');\n        }\n    }\n\n    public function getSandboxUnallowedToStringTests()\n    {\n        return [\n            'simple' => ['{{ obj }}'],\n            'object_from_array' => ['{{ arr.obj }}'],\n            'object_chain' => ['{{ obj.anotherFooObject }}'],\n            'filter' => ['{{ obj|upper }}'],\n            'filter_from_array' => ['{{ arr.obj|upper }}'],\n            'function' => ['{{ random(obj) }}'],\n            'function_from_array' => ['{{ random(arr.obj) }}'],\n            'function_and_filter' => ['{{ random(obj|upper) }}'],\n            'function_and_filter_from_array' => ['{{ random(arr.obj|upper) }}'],\n            'object_chain_and_filter' => ['{{ obj.anotherFooObject|upper }}'],\n            'object_chain_and_function' => ['{{ random(obj.anotherFooObject) }}'],\n            'concat' => ['{{ obj ~ \"\" }}'],\n            'concat_again' => ['{{ \"\" ~ obj }}'],\n        ];\n    }\n\n    /**\n     * @dataProvider getSandboxAllowedToStringTests\n     */\n    public function testSandboxAllowedToString($template, $output)\n    {\n        $twig = $this->getEnvironment(true, [], ['index' => $template], ['set'], [], ['Twig\\Tests\\Extension\\FooObject' => ['foo', 'getAnotherFooObject']]);\n        $this->assertEquals($output, $twig->load('index')->render(self::$params));\n    }\n\n    public function getSandboxAllowedToStringTests()\n    {\n        return [\n            'constant_test' => ['{{ obj is constant(\"PHP_INT_MAX\") }}', ''],\n            'set_object' => ['{% set a = obj.anotherFooObject %}{{ a.foo }}', 'foo'],\n            'is_defined' => ['{{ obj.anotherFooObject is defined }}', '1'],\n            'is_null' => ['{{ obj is null }}', ''],\n            'is_sameas' => ['{{ obj is same as(obj) }}', '1'],\n            'is_sameas_no_brackets' => ['{{ obj is same as obj }}', '1'],\n            'is_sameas_from_array' => ['{{ arr.obj is same as(arr.obj) }}', '1'],\n            'is_sameas_from_array_no_brackets' => ['{{ arr.obj is same as arr.obj }}', '1'],\n            'is_sameas_from_another_method' => ['{{ obj.anotherFooObject is same as(obj.anotherFooObject) }}', ''],\n            'is_sameas_from_another_method_no_brackets' => ['{{ obj.anotherFooObject is same as obj.anotherFooObject }}', ''],\n        ];\n    }\n\n    public function testSandboxAllowMethodToString()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => '__toString']);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic5')->render(self::$params), 'Sandbox allow some methods');\n        $this->assertEquals(1, FooObject::$called['__toString'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxAllowMethodToStringDisabled()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic5')->render(self::$params), 'Sandbox allows __toString when sandbox disabled');\n        $this->assertEquals(1, FooObject::$called['__toString'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxUnallowedFunction()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic7')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed function is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFunctionError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFunctionError');\n            $this->assertEquals('cycle', $e->getFunctionName(), 'Exception should be raised on the \"cycle\" function');\n        }\n    }\n\n    public function testSandboxUnallowedRangeOperator()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_range_operator')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if the unallowed range operator is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFunctionError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFunctionError');\n            $this->assertEquals('range', $e->getFunctionName(), 'Exception should be raised on the \"range\" function');\n        }\n    }\n\n    public function testSandboxAllowMethodFoo()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => 'foo']);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic1')->render(self::$params), 'Sandbox allow some methods');\n        $this->assertEquals(1, FooObject::$called['foo'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxAllowFilter()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], ['upper']);\n        $this->assertEquals('FABIEN', $twig->load('1_basic2')->render(self::$params), 'Sandbox allow some filters');\n    }\n\n    public function testSandboxAllowTag()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, ['if']);\n        $this->assertEquals('foo', $twig->load('1_basic3')->render(self::$params), 'Sandbox allow some tags');\n    }\n\n    public function testSandboxAllowProperty()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], ['Twig\\Tests\\Extension\\FooObject' => 'bar']);\n        $this->assertEquals('bar', $twig->load('1_basic4')->render(self::$params), 'Sandbox allow some properties');\n    }\n\n    public function testSandboxAllowFunction()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['cycle']);\n        $this->assertEquals('bar', $twig->load('1_basic7')->render(self::$params), 'Sandbox allow some functions');\n    }\n\n    public function testSandboxAllowRangeOperator()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['range']);\n        $this->assertEquals('1', $twig->load('1_range_operator')->render(self::$params), 'Sandbox allow the range operator');\n    }\n\n    public function testSandboxAllowFunctionsCaseInsensitive()\n    {\n        foreach (['getfoobar', 'getFoobar', 'getFooBar'] as $name) {\n            $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => $name]);\n            FooObject::reset();\n            $this->assertEquals('foobarfoobar', $twig->load('1_basic8')->render(self::$params), 'Sandbox allow methods in a case-insensitive way');\n            $this->assertEquals(2, FooObject::$called['getFooBar'], 'Sandbox only calls method once');\n\n            $this->assertEquals('foobarfoobar', $twig->load('1_basic9')->render(self::$params), 'Sandbox allow methods via shortcut names (ie. without get/set)');\n        }\n    }\n\n    public function testSandboxLocallySetForAnInclude()\n    {\n        self::$templates = [\n            '2_basic' => '{{ obj.foo }}{% include \"2_included\" %}{{ obj.foo }}',\n            '2_included' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n        ];\n\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $this->assertEquals('fooFOOfoo', $twig->load('2_basic')->render(self::$params), 'Sandbox does nothing if disabled globally and sandboxed not used for the include');\n\n        self::$templates = [\n            '3_basic' => '{{ obj.foo }}{% sandbox %}{% include \"3_included\" %}{% endsandbox %}{{ obj.foo }}',\n            '3_included' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n        ];\n\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('3_basic')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception when the included file is sandboxed');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedTagError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedTagError');\n            $this->assertEquals('sandbox', $e->getTagName());\n        }\n    }\n\n    public function testMacrosInASandbox()\n    {\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{%- import _self as macros %}\n\n{%- macro test(text) %}<p>{{ text }}</p>{% endmacro %}\n\n{{- macros.test('username') }}\nEOF\n        ], ['macro', 'import'], ['escape']);\n\n        $this->assertEquals('<p>username</p>', $twig->load('index')->render([]));\n    }\n\n    public function testSandboxDisabledAfterIncludeFunctionError()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n\n        $e = null;\n        try {\n            $twig->load('1_include')->render(self::$params);\n        } catch (\\Throwable $e) {\n        }\n        if (null === $e) {\n            $this->fail('An exception should be thrown for this test to be valid.');\n        }\n\n        $this->assertFalse($twig->getExtension(SandboxExtension::class)->isSandboxed(), 'Sandboxed include() function call should not leave Sandbox enabled when an error occurs.');\n    }\n\n    public function testSandboxWithNoClosureFilter()\n    {\n        $this->expectException('\\Twig\\Error\\RuntimeError');\n        $this->expectExceptionMessage('The callable passed to \"filter\" filter must be a Closure in sandbox mode in \"index\" at line 1.');\n\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{{ [\"foo\", \"bar\", \"\"]|filter(\"trim\")|join(\", \") }}\nEOF\n        ], [], ['escape', 'filter', 'join']);\n\n        $twig->load('index')->render([]);\n    }\n\n    public function testSandboxWithClosureFilter()\n    {\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{{ [\"foo\", \"bar\", \"\"]|filter(v => v != \"\")|join(\", \") }}\nEOF\n        ], [], ['escape', 'filter', 'join']);\n\n        $this->assertSame('foo, bar', $twig->load('index')->render([]));\n    }\n\n    protected function getEnvironment($sandboxed, $options, $templates, $tags = [], $filters = [], $methods = [], $properties = [], $functions = [])\n    {\n        $loader = new ArrayLoader($templates);\n        $twig = new Environment($loader, array_merge(['debug' => true, 'cache' => false, 'autoescape' => false], $options));\n        $policy = new SecurityPolicy($tags, $filters, $methods, $properties, $functions);\n        $twig->addExtension(new SandboxExtension($policy, $sandboxed));\n\n        return $twig;\n    }\n}\n\nclass FooObject\n{\n    public static $called = ['__toString' => 0, 'foo' => 0, 'getFooBar' => 0];\n\n    public $bar = 'bar';\n\n    public static function reset()\n    {\n        self::$called = ['__toString' => 0, 'foo' => 0, 'getFooBar' => 0];\n    }\n\n    public function __toString()\n    {\n        ++self::$called['__toString'];\n\n        return 'foo';\n    }\n\n    public function foo()\n    {\n        ++self::$called['foo'];\n\n        return 'foo';\n    }\n\n    public function getFooBar()\n    {\n        ++self::$called['getFooBar'];\n\n        return 'foobar';\n    }\n\n    public function getAnotherFooObject()\n    {\n        return new self();\n    }\n}\n"], "fixing_code": ["# 2.14.11 (2022-02-04)\n\n * Fix a security issue when in a sandbox: the `sort` filter must require a Closure for the `arrow` parameter\n\n# 2.14.10 (2022-01-03)\n\n * Allow more null arguments when Twig expects a string (for better 8.1 support)\n\n# 2.14.9 (2022-01-03)\n\n* Allow null when Twig expects a string (for better 8.1 support)\n* Add support for PHP 7.1 back\n* Make some performance optimizations\n* Allow Symfony translation contract v3+\n\n# 2.14.8 (2021-11-25)\n\n * Bump minimum supported Symfony component versions\n * Fix a deprecated message\n\n# 2.14.7 (2021-09-17)\n\n * Allow Symfony 6\n * Improve compatibility with PHP 8.1\n * Explicitly specify the encoding for mb_ord in JS escaper\n \n# 2.14.6 (2021-05-16)\n\n * Revert \"Throw a proper exception when a template name is an absolute path (as it has never been supported)\"\n\n# 2.14.5 (2021-05-12)\n\n * Fix PHP 8.1 compatibility\n * Throw a proper exception when a template name is an absolute path (as it has never been supported)\n\n# 2.14.4 (2021-03-10)\n\n * Add the slug filter\n\n# 2.14.3 (2021-01-05)\n\n * Fix extra bundle compat with older versions of Symfony\n\n# 2.14.2 (2021-01-05)\n\n * Fix \"odd\" not working for negative numbers\n\n# 2.14.1 (2020-10-27)\n\n* Fix \"include(template_from_string())\"\n\n# 2.14.0 (2020-10-21)\n\n * Fix sandbox support when using \"include(template_from_string())\"\n * Make round brackets optional for one argument tests like \"same as\" or \"divisible by\"\n * Add support for ES2015 style object initialisation shortcut { a } is the same as { 'a': a }\n * Drop PHP 7.1 support\n\n# 2.13.1 (2020-08-05)\n\n * Fix sandbox not disabled if syntax error occurs within {% sandbox %} tag\n * Fix a regression when not using a space before an operator\n * Restrict callables to closures in filters\n * Allow trailing commas in argument lists (in calls as well as definitions)\n\n# 2.13.0 (2020-07-05)\n\n * Fix options not taken into account when using \"Michelf\\MarkdownExtra\"\n * Fix \"Twig\\Extra\\Intl\\IntlExtension::getCountryName()\" to accept \"null\" as a first argument\n * Drop support for PHP 7.0\n * Throw exception in case non-Traversable data is passed to \"filter\"\n * Fix context optimization on PHP 7.4\n * Fix PHP 8 compatibility\n * Fix ambiguous syntax parsing\n\n# 2.12.5 (2020-02-11)\n\n * Add a check to ensure that iconv() is defined\n\n# 2.12.4 (2020-02-11)\n\n * Avoid exceptions when an intl resource is not found\n * Fix implementation of case-insensitivity for method names\n\n# 2.12.3 (2019-12-28)\n\n * fixed Symfony 5.0 support for the HTML extra extension\n * fixed number formatter in Intl extra extension when using a formatter prototype\n\n# 2.12.2 (2019-11-11)\n\n * added supported for exponential numbers\n\n# 2.12.1 (2019-10-17)\n\n * added the String extension in the \"extra\" repositories: \"u\" filter\n\n# 2.12.0 (2019-10-05)\n\n * added the spaceship operator (\"<=>\"), useful when using an arrow function in the \"sort\" filter\n * added support for an \"arrow\" function on the \"sort\" filter\n * added the CssInliner extension in the \"extra\" repositories: \"inline_css\"\n   filter\n * added the Inky extension in the \"extra\" repositories: \"inky_to_html\" filter\n * added Intl extension in the \"extra\" repositories: \"country_name\",\n   \"currency_name\", \"currency_symbol\", \"language_name\", \"locale_name\",\n   \"timezone_name\", \"format_currency\", \"format_number\",\n   \"format_*_number\", \"format_datetime\", \"format_date\", and \"format_time\"\n   filters, and the \"country_timezones\" function\n * added the Markdown extension in the \"extra\" repositories: \"markdown_to_html\",\n   and \"html_to_markdown\" filters\n * added the HtmlExtension extension in the \"extra\" repositories: \"date_uri\"\n   filter, and \"html_classes\" function\n * optimized \"block('foo') ?? 'bar'\"\n * fixed the empty test on Traversable instances\n * fixed array_key_exists() on objects\n * fixed cache when opcache is installed but disabled\n * fixed using macros in arrow functions\n * fixed split filter on edge case\n\n# 2.11.3 (2019-06-18)\n\n * display partial output (PHP buffer) when an error occurs in debug mode\n * fixed the filter filter (allow the result to be used several times)\n * fixed macro auto-import when a template contains only macros\n\n# 2.11.2 (2019-06-05)\n\n * fixed macro auto-import\n\n# 2.11.1 (2019-06-04)\n\n * added support for \"Twig\\Markup\" instances in the \"in\" test (again)\n * allowed string operators as variables names in assignments\n * fixed support for macros defined in parent templates\n\n# 2.11.0 (2019-05-31)\n\n * added the possibility to register classes/interfaces as being safe for the escaper (\"EscaperExtension::addSafeClass()\")\n * deprecated CoreExtension::setEscaper() and CoreExtension::getEscapers() in favor of the same methods on EscaperExtension\n * macros are now auto-imported in the template they are defined (under the ``_self`` variable)\n * added support for macros on \"is defined\" tests\n * fixed macros \"import\" when using the same name in the parent and child templates\n * fixed recursive macros\n * macros imported \"globally\" in a template are now available in macros without re-importing them\n * fixed the \"filter\" filter when the argument is \\Traversable but does not implement \\Iterator (\\SimpleXmlElement for instance)\n * fixed a PHP fatal error when calling a macro imported in a block in a nested block\n * fixed a PHP fatal error when calling a macro imported in the template in another macro\n * fixed wrong error message on \"import\" and \"from\"\n\n# 2.10.0 (2019-05-14)\n\n * deprecated \"if\" conditions on \"for\" tags\n * added \"filter\", \"map\", and \"reduce\" filters (and support for arrow functions)\n * fixed partial output leak when a PHP fatal error occurs\n * optimized context access on PHP 7.4\n\n# 2.9.0 (2019-04-28)\n\n * deprecated returning \"false\" to remove a Node from NodeVisitorInterface::leaveNode()\n * allowed Twig\\NodeVisitor\\NodeVisitorInterface::leaveNode() to return \"null\" instead of \"false\" (same meaning)\n * deprecated the \"filter\" tag (use the \"apply\" tag instead)\n * added the \"apply\" tag as a replacement for the \"filter\" tag\n * allowed Twig\\Loader\\FilesystemLoader::findTemplate() to return \"null\" instead of \"false\" (same meaning)\n * added support for \"Twig\\Markup\" instances in the \"in\" test\n * fixed \"import\" when macros are stored in a template string\n * fixed Lexer when using custom options containing the # char\n * added template line number to twig_get_attribute()\n\n# 2.8.1 (2019-04-16)\n\n * fixed EscaperNodeVisitor\n * deprecated passing a 3rd, 4th, and 5th arguments to the Sandbox exception classes\n * deprecated Node::setTemplateName() in favor of Node::setSourceContext()\n\n# 2.8.0 (2019-04-16)\n\n * added Traversable support for the length filter\n * fixed some wrong location in error messages\n * made exception creation faster\n * made escaping on ternary expressions (?: and ??) more fine-grained\n * added the possibility to give a nice name to string templates (template_from_string function)\n * fixed the \"with\" behavior to always include the globals (for consistency with the \"include\" and \"embed\" tags)\n * fixed \"include\" with \"ignore missing\" when an error loading occurs in the included template\n * added support for a new whitespace trimming option ({%~ ~%}, {{~ ~}}, {#~ ~#})\n * added the \"column\" filter\n\n# 2.7.4 (2019-03-23)\n\n * fixed variadic support\n * fixed CheckToStringNode implementation (broken when a function/filter is variadic)\n\n# 2.7.3 (2019-03-21)\n\n * fixed the spaceless filter so that it behaves like the spaceless tag\n * fixed BC break on Environment::resolveTemplate()\n * allowed Traversable objects to be used in the \"with\" tag\n * allowed Traversable objects to be used in the \"with\" tag\n * allowed Traversable objects to be used in the \"with\" argument of the \"include\" and \"embed\" tags\n\n# 2.7.2 (2019-03-12)\n\n * added TemplateWrapper::getTemplateName()\n\n# 2.7.1 (2019-03-12)\n\n * fixed class aliases\n\n# 2.7.0 (2019-03-12)\n\n * fixed sandbox security issue (under some circumstances, calling the\n   __toString() method on an object was possible even if not allowed by the\n   security policy)\n * fixed batch filter clobbers array keys when fill parameter is used\n * added preserveKeys support for the batch filter\n * fixed \"embed\" support when used from \"template_from_string\"\n * deprecated passing a Twig\\Template to Twig\\Environment::load()/Twig\\Environment::resolveTemplate()\n * added the possibility to pass a TemplateWrapper to Twig\\Environment::load()\n * marked Twig\\Environment::getTemplateClass() as internal (implementation detail)\n * improved the performance of the sandbox\n * deprecated the spaceless tag\n * added a spaceless filter\n * added max value to the \"random\" function\n * deprecated Twig\\Extension\\InitRuntimeInterface\n * deprecated Twig\\Loader\\ExistsLoaderInterface\n * deprecated PSR-0 classes in favor of namespaced ones\n * made namespace classes the default classes (PSR-0 ones are aliases now)\n * added Twig\\Loader\\ChainLoader::getLoaders()\n * removed duplicated directory separator in FilesystemLoader\n * deprecated the \"base_template_class\" option on Twig\\Environment\n * deprecated the Twig\\Environment::getBaseTemplateClass() and\n   Twig\\Environment::setBaseTemplateClass() methods\n * changed internal code to use the namespaced classes as much as possible\n * deprecated Twig_Parser::isReservedMacroName()\n\n# 2.6.2 (2019-01-14)\n\n * fixed regression (key exists check for non ArrayObject objects)\n\n# 2.6.1 (2019-01-14)\n\n * fixed ArrayObject access with a null value\n * fixed embedded templates starting with a BOM\n * fixed using a Twig_TemplateWrapper instance as an argument to extends\n * fixed error location when calling an undefined block\n * deprecated passing a string as a source on Twig_Error\n * switched generated code to use the PHP short array notation\n * fixed float representation in compiled templates\n * added a second argument to the join filter (last separator configuration)\n\n# 2.6.0 (2018-12-16)\n\n * made sure twig_include returns a string\n * fixed multi-byte UFT-8 in escape('html_attr')\n * added the \"deprecated\" tag\n * added support for dynamically named tests\n * fixed GlobalsInterface extended class\n * fixed filesystem loader throwing an exception instead of returning false\n\n# 2.5.0 (2018-07-13)\n\n * deprecated using the spaceless tag at the root level of a child template (noop anyway)\n * deprecated the possibility to define a block in a non-capturing block in a child template\n * added the Symfony ctype polyfill as a dependency\n * fixed reporting the proper location for errors compiled in templates\n * fixed the error handling for the optimized extension-based function calls\n * ensured that syntax errors are triggered with the right line\n * \"js\" filter now produces valid JSON\n\n# 2.4.8 (2018-04-02)\n\n * fixed a regression when using the \"default\" filter or the \"defined\" test on non-existing arrays\n\n# 2.4.7 (2018-03-20)\n\n * optimized runtime performance\n * optimized parser performance by inlining the constant values\n * fixed block names unicity\n * fixed counting children of SimpleXMLElement objects\n * added missing else clause to avoid infinite loops\n * fixed .. (range operator) in sandbox policy\n\n# 2.4.6 (2018-03-03)\n\n * fixed a regression in the way the profiler is registered in templates\n\n# 2.4.5 (2018-03-02)\n\n * optimized the performance of calling an extension method at runtime\n * optimized the performance of the dot operator for array and method calls\n * added an exception when using \"===\" instead of \"same as\"\n * fixed possible array to string conversion concealing actual error\n * made variable names deterministic in compiled templates\n * fixed length filter when passing an instance of IteratorAggregate\n * fixed Environment::resolveTemplate to accept instances of TemplateWrapper\n\n# 2.4.4 (2017-09-27)\n\n * added Twig_Profiler_Profile::reset()\n * fixed use TokenParser to return an empty Node\n * added RuntimeExtensionInterface\n * added circular reference detection when loading templates\n * added support for runtime loaders in IntegrationTestCase\n * fixed deprecation when using Twig_Profiler_Dumper_Html\n * removed @final from Twig_Profiler_Dumper_Text\n\n# 2.4.3 (2017-06-07)\n\n * fixed namespaces introduction\n\n# 2.4.2 (2017-06-05)\n\n * fixed namespaces introduction\n\n# 2.4.1 (2017-06-05)\n\n * fixed namespaces introduction\n\n# 2.4.0 (2017-06-05)\n\n * added support for PHPUnit 6 when testing extensions\n * fixed PHP 7.2 compatibility\n * fixed template name generation in Twig_Environment::createTemplate()\n * removed final tag on Twig_TokenParser_Include\n * dropped HHVM support\n * added namespaced aliases for all (non-deprecated) classes and interfaces\n * marked Twig_Filter, Twig_Function, Twig_Test, Twig_Node_Module and Twig_Profiler_Profile as final via the @final annotation\n\n# 2.3.2 (2017-04-20)\n\n * fixed edge case in the method cache for Twig attributes\n\n# 2.3.1 (2017-04-18)\n\n * fixed the empty() test\n\n# 2.3.0 (2017-03-22)\n\n * fixed a race condition handling when writing cache files\n * \"length\" filter now returns string length when applied to an object that does\n   not implement \\Countable but provides __toString()\n * \"empty\" test will now consider the return value of the __toString() method for\n   objects implement __toString() but not \\Countable\n * fixed JS escaping for unicode characters with higher code points\n * added error message when calling `parent()` in a block that doesn't exist in the parent template\n\n# 2.2.0 (2017-02-26)\n\n * added a PSR-11 compatible runtime loader\n * added `side` argument to `trim` to allow left or right trimming only.\n\n# 2.1.0 (2017-01-11)\n\n * fixed twig_get_attribute()\n * added Twig_NodeCaptureInterface for nodes that capture all output\n\n# 2.0.0 (2017-01-05)\n\n * removed the C extension\n * moved Twig_Environment::getAttribute() to twig_get_attribute()\n * removed Twig_Environment::getLexer(), Twig_Environment::getParser(), Twig_Environment::getCompiler()\n * removed Twig_Compiler::getFilename()\n * added hasser support in Twig_Template::getAttribute()\n * sped up the json_encode filter\n * removed reserved macro names; all names can be used as macro\n * removed Twig_Template::getEnvironment()\n * changed _self variable to return the current template name\n * made the loader a required argument of Twig_Environment constructor\n * removed Twig_Environment::clearTemplateCache()\n * removed Twig_Autoloader (use Composer instead)\n * removed `true` as an equivalent to `html` for the auto-escaping strategy\n * removed pre-1.8 autoescape tag syntax\n * dropped support for PHP 5.x\n * removed the ability to register a global variable after the runtime or the extensions have been initialized\n * improved the performance of the filesystem loader\n * removed features that were deprecated in 1.x\n", "<?php\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Twig\\Extension {\nuse Twig\\ExpressionParser;\nuse Twig\\Node\\Expression\\Binary\\AddBinary;\nuse Twig\\Node\\Expression\\Binary\\AndBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseAndBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseOrBinary;\nuse Twig\\Node\\Expression\\Binary\\BitwiseXorBinary;\nuse Twig\\Node\\Expression\\Binary\\ConcatBinary;\nuse Twig\\Node\\Expression\\Binary\\DivBinary;\nuse Twig\\Node\\Expression\\Binary\\EndsWithBinary;\nuse Twig\\Node\\Expression\\Binary\\EqualBinary;\nuse Twig\\Node\\Expression\\Binary\\FloorDivBinary;\nuse Twig\\Node\\Expression\\Binary\\GreaterBinary;\nuse Twig\\Node\\Expression\\Binary\\GreaterEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\InBinary;\nuse Twig\\Node\\Expression\\Binary\\LessBinary;\nuse Twig\\Node\\Expression\\Binary\\LessEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\MatchesBinary;\nuse Twig\\Node\\Expression\\Binary\\ModBinary;\nuse Twig\\Node\\Expression\\Binary\\MulBinary;\nuse Twig\\Node\\Expression\\Binary\\NotEqualBinary;\nuse Twig\\Node\\Expression\\Binary\\NotInBinary;\nuse Twig\\Node\\Expression\\Binary\\OrBinary;\nuse Twig\\Node\\Expression\\Binary\\PowerBinary;\nuse Twig\\Node\\Expression\\Binary\\RangeBinary;\nuse Twig\\Node\\Expression\\Binary\\SpaceshipBinary;\nuse Twig\\Node\\Expression\\Binary\\StartsWithBinary;\nuse Twig\\Node\\Expression\\Binary\\SubBinary;\nuse Twig\\Node\\Expression\\Filter\\DefaultFilter;\nuse Twig\\Node\\Expression\\NullCoalesceExpression;\nuse Twig\\Node\\Expression\\Test\\ConstantTest;\nuse Twig\\Node\\Expression\\Test\\DefinedTest;\nuse Twig\\Node\\Expression\\Test\\DivisiblebyTest;\nuse Twig\\Node\\Expression\\Test\\EvenTest;\nuse Twig\\Node\\Expression\\Test\\NullTest;\nuse Twig\\Node\\Expression\\Test\\OddTest;\nuse Twig\\Node\\Expression\\Test\\SameasTest;\nuse Twig\\Node\\Expression\\Unary\\NegUnary;\nuse Twig\\Node\\Expression\\Unary\\NotUnary;\nuse Twig\\Node\\Expression\\Unary\\PosUnary;\nuse Twig\\NodeVisitor\\MacroAutoImportNodeVisitor;\nuse Twig\\TokenParser\\ApplyTokenParser;\nuse Twig\\TokenParser\\BlockTokenParser;\nuse Twig\\TokenParser\\DeprecatedTokenParser;\nuse Twig\\TokenParser\\DoTokenParser;\nuse Twig\\TokenParser\\EmbedTokenParser;\nuse Twig\\TokenParser\\ExtendsTokenParser;\nuse Twig\\TokenParser\\FilterTokenParser;\nuse Twig\\TokenParser\\FlushTokenParser;\nuse Twig\\TokenParser\\ForTokenParser;\nuse Twig\\TokenParser\\FromTokenParser;\nuse Twig\\TokenParser\\IfTokenParser;\nuse Twig\\TokenParser\\ImportTokenParser;\nuse Twig\\TokenParser\\IncludeTokenParser;\nuse Twig\\TokenParser\\MacroTokenParser;\nuse Twig\\TokenParser\\SetTokenParser;\nuse Twig\\TokenParser\\SpacelessTokenParser;\nuse Twig\\TokenParser\\UseTokenParser;\nuse Twig\\TokenParser\\WithTokenParser;\nuse Twig\\TwigFilter;\nuse Twig\\TwigFunction;\nuse Twig\\TwigTest;\n\nfinal class CoreExtension extends AbstractExtension\n{\n    private $dateFormats = ['F j, Y H:i', '%d days'];\n    private $numberFormat = [0, '.', ','];\n    private $timezone = null;\n    private $escapers = [];\n\n    /**\n     * Defines a new escaper to be used via the escape filter.\n     *\n     * @param string   $strategy The strategy name that should be used as a strategy in the escape call\n     * @param callable $callable A valid PHP callable\n     *\n     * @deprecated since Twig 2.11, to be removed in 3.0; use the same method on EscaperExtension instead\n     */\n    public function setEscaper($strategy, callable $callable)\n    {\n        @trigger_error(sprintf('The \"%s\" method is deprecated since Twig 2.11; use \"%s::setEscaper\" instead.', __METHOD__, EscaperExtension::class), \\E_USER_DEPRECATED);\n\n        $this->escapers[$strategy] = $callable;\n    }\n\n    /**\n     * Gets all defined escapers.\n     *\n     * @return callable[] An array of escapers\n     *\n     * @deprecated since Twig 2.11, to be removed in 3.0; use the same method on EscaperExtension instead\n     */\n    public function getEscapers(/* $triggerDeprecation = true */)\n    {\n        if (0 === \\func_num_args() || \\func_get_arg(0)) {\n            @trigger_error(sprintf('The \"%s\" method is deprecated since Twig 2.11; use \"%s::getEscapers\" instead.', __METHOD__, EscaperExtension::class), \\E_USER_DEPRECATED);\n        }\n\n        return $this->escapers;\n    }\n\n    /**\n     * Sets the default format to be used by the date filter.\n     *\n     * @param string $format             The default date format string\n     * @param string $dateIntervalFormat The default date interval format string\n     */\n    public function setDateFormat($format = null, $dateIntervalFormat = null)\n    {\n        if (null !== $format) {\n            $this->dateFormats[0] = $format;\n        }\n\n        if (null !== $dateIntervalFormat) {\n            $this->dateFormats[1] = $dateIntervalFormat;\n        }\n    }\n\n    /**\n     * Gets the default format to be used by the date filter.\n     *\n     * @return array The default date format string and the default date interval format string\n     */\n    public function getDateFormat()\n    {\n        return $this->dateFormats;\n    }\n\n    /**\n     * Sets the default timezone to be used by the date filter.\n     *\n     * @param \\DateTimeZone|string $timezone The default timezone string or a \\DateTimeZone object\n     */\n    public function setTimezone($timezone)\n    {\n        $this->timezone = $timezone instanceof \\DateTimeZone ? $timezone : new \\DateTimeZone($timezone);\n    }\n\n    /**\n     * Gets the default timezone to be used by the date filter.\n     *\n     * @return \\DateTimeZone The default timezone currently in use\n     */\n    public function getTimezone()\n    {\n        if (null === $this->timezone) {\n            $this->timezone = new \\DateTimeZone(date_default_timezone_get());\n        }\n\n        return $this->timezone;\n    }\n\n    /**\n     * Sets the default format to be used by the number_format filter.\n     *\n     * @param int    $decimal      the number of decimal places to use\n     * @param string $decimalPoint the character(s) to use for the decimal point\n     * @param string $thousandSep  the character(s) to use for the thousands separator\n     */\n    public function setNumberFormat($decimal, $decimalPoint, $thousandSep)\n    {\n        $this->numberFormat = [$decimal, $decimalPoint, $thousandSep];\n    }\n\n    /**\n     * Get the default format used by the number_format filter.\n     *\n     * @return array The arguments for number_format()\n     */\n    public function getNumberFormat()\n    {\n        return $this->numberFormat;\n    }\n\n    public function getTokenParsers()\n    {\n        return [\n            new ApplyTokenParser(),\n            new ForTokenParser(),\n            new IfTokenParser(),\n            new ExtendsTokenParser(),\n            new IncludeTokenParser(),\n            new BlockTokenParser(),\n            new UseTokenParser(),\n            new FilterTokenParser(),\n            new MacroTokenParser(),\n            new ImportTokenParser(),\n            new FromTokenParser(),\n            new SetTokenParser(),\n            new SpacelessTokenParser(),\n            new FlushTokenParser(),\n            new DoTokenParser(),\n            new EmbedTokenParser(),\n            new WithTokenParser(),\n            new DeprecatedTokenParser(),\n        ];\n    }\n\n    public function getFilters()\n    {\n        return [\n            // formatting filters\n            new TwigFilter('date', 'twig_date_format_filter', ['needs_environment' => true]),\n            new TwigFilter('date_modify', 'twig_date_modify_filter', ['needs_environment' => true]),\n            new TwigFilter('format', 'twig_sprintf'),\n            new TwigFilter('replace', 'twig_replace_filter'),\n            new TwigFilter('number_format', 'twig_number_format_filter', ['needs_environment' => true]),\n            new TwigFilter('abs', 'abs'),\n            new TwigFilter('round', 'twig_round'),\n\n            // encoding\n            new TwigFilter('url_encode', 'twig_urlencode_filter'),\n            new TwigFilter('json_encode', 'json_encode'),\n            new TwigFilter('convert_encoding', 'twig_convert_encoding'),\n\n            // string filters\n            new TwigFilter('title', 'twig_title_string_filter', ['needs_environment' => true]),\n            new TwigFilter('capitalize', 'twig_capitalize_string_filter', ['needs_environment' => true]),\n            new TwigFilter('upper', 'twig_upper_filter', ['needs_environment' => true]),\n            new TwigFilter('lower', 'twig_lower_filter', ['needs_environment' => true]),\n            new TwigFilter('striptags', 'twig_striptags'),\n            new TwigFilter('trim', 'twig_trim_filter'),\n            new TwigFilter('nl2br', 'twig_nl2br', ['pre_escape' => 'html', 'is_safe' => ['html']]),\n            new TwigFilter('spaceless', 'twig_spaceless', ['is_safe' => ['html']]),\n\n            // array helpers\n            new TwigFilter('join', 'twig_join_filter'),\n            new TwigFilter('split', 'twig_split_filter', ['needs_environment' => true]),\n            new TwigFilter('sort', 'twig_sort_filter', ['needs_environment' => true]),\n            new TwigFilter('merge', 'twig_array_merge'),\n            new TwigFilter('batch', 'twig_array_batch'),\n            new TwigFilter('column', 'twig_array_column'),\n            new TwigFilter('filter', 'twig_array_filter', ['needs_environment' => true]),\n            new TwigFilter('map', 'twig_array_map', ['needs_environment' => true]),\n            new TwigFilter('reduce', 'twig_array_reduce', ['needs_environment' => true]),\n\n            // string/array filters\n            new TwigFilter('reverse', 'twig_reverse_filter', ['needs_environment' => true]),\n            new TwigFilter('length', 'twig_length_filter', ['needs_environment' => true]),\n            new TwigFilter('slice', 'twig_slice', ['needs_environment' => true]),\n            new TwigFilter('first', 'twig_first', ['needs_environment' => true]),\n            new TwigFilter('last', 'twig_last', ['needs_environment' => true]),\n\n            // iteration and runtime\n            new TwigFilter('default', '_twig_default_filter', ['node_class' => DefaultFilter::class]),\n            new TwigFilter('keys', 'twig_get_array_keys_filter'),\n        ];\n    }\n\n    public function getFunctions()\n    {\n        return [\n            new TwigFunction('max', 'max'),\n            new TwigFunction('min', 'min'),\n            new TwigFunction('range', 'range'),\n            new TwigFunction('constant', 'twig_constant'),\n            new TwigFunction('cycle', 'twig_cycle'),\n            new TwigFunction('random', 'twig_random', ['needs_environment' => true]),\n            new TwigFunction('date', 'twig_date_converter', ['needs_environment' => true]),\n            new TwigFunction('include', 'twig_include', ['needs_environment' => true, 'needs_context' => true, 'is_safe' => ['all']]),\n            new TwigFunction('source', 'twig_source', ['needs_environment' => true, 'is_safe' => ['all']]),\n        ];\n    }\n\n    public function getTests()\n    {\n        return [\n            new TwigTest('even', null, ['node_class' => EvenTest::class]),\n            new TwigTest('odd', null, ['node_class' => OddTest::class]),\n            new TwigTest('defined', null, ['node_class' => DefinedTest::class]),\n            new TwigTest('same as', null, ['node_class' => SameasTest::class, 'one_mandatory_argument' => true]),\n            new TwigTest('none', null, ['node_class' => NullTest::class]),\n            new TwigTest('null', null, ['node_class' => NullTest::class]),\n            new TwigTest('divisible by', null, ['node_class' => DivisiblebyTest::class, 'one_mandatory_argument' => true]),\n            new TwigTest('constant', null, ['node_class' => ConstantTest::class]),\n            new TwigTest('empty', 'twig_test_empty'),\n            new TwigTest('iterable', 'twig_test_iterable'),\n        ];\n    }\n\n    public function getNodeVisitors()\n    {\n        return [new MacroAutoImportNodeVisitor()];\n    }\n\n    public function getOperators()\n    {\n        return [\n            [\n                'not' => ['precedence' => 50, 'class' => NotUnary::class],\n                '-' => ['precedence' => 500, 'class' => NegUnary::class],\n                '+' => ['precedence' => 500, 'class' => PosUnary::class],\n            ],\n            [\n                'or' => ['precedence' => 10, 'class' => OrBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'and' => ['precedence' => 15, 'class' => AndBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-or' => ['precedence' => 16, 'class' => BitwiseOrBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-xor' => ['precedence' => 17, 'class' => BitwiseXorBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'b-and' => ['precedence' => 18, 'class' => BitwiseAndBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '==' => ['precedence' => 20, 'class' => EqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '!=' => ['precedence' => 20, 'class' => NotEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<=>' => ['precedence' => 20, 'class' => SpaceshipBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<' => ['precedence' => 20, 'class' => LessBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '>' => ['precedence' => 20, 'class' => GreaterBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '>=' => ['precedence' => 20, 'class' => GreaterEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '<=' => ['precedence' => 20, 'class' => LessEqualBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'not in' => ['precedence' => 20, 'class' => NotInBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'in' => ['precedence' => 20, 'class' => InBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'matches' => ['precedence' => 20, 'class' => MatchesBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'starts with' => ['precedence' => 20, 'class' => StartsWithBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'ends with' => ['precedence' => 20, 'class' => EndsWithBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '..' => ['precedence' => 25, 'class' => RangeBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '+' => ['precedence' => 30, 'class' => AddBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '-' => ['precedence' => 30, 'class' => SubBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '~' => ['precedence' => 40, 'class' => ConcatBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '*' => ['precedence' => 60, 'class' => MulBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '/' => ['precedence' => 60, 'class' => DivBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '//' => ['precedence' => 60, 'class' => FloorDivBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '%' => ['precedence' => 60, 'class' => ModBinary::class, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'is' => ['precedence' => 100, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                'is not' => ['precedence' => 100, 'associativity' => ExpressionParser::OPERATOR_LEFT],\n                '**' => ['precedence' => 200, 'class' => PowerBinary::class, 'associativity' => ExpressionParser::OPERATOR_RIGHT],\n                '??' => ['precedence' => 300, 'class' => NullCoalesceExpression::class, 'associativity' => ExpressionParser::OPERATOR_RIGHT],\n            ],\n        ];\n    }\n}\n\nclass_alias('Twig\\Extension\\CoreExtension', 'Twig_Extension_Core');\n}\n\nnamespace {\n    use Twig\\Environment;\n    use Twig\\Error\\LoaderError;\n    use Twig\\Error\\RuntimeError;\n    use Twig\\Extension\\CoreExtension;\n    use Twig\\Extension\\SandboxExtension;\n    use Twig\\Markup;\n    use Twig\\Source;\n    use Twig\\Template;\n    use Twig\\TemplateWrapper;\n\n/**\n * Cycles over a value.\n *\n * @param \\ArrayAccess|array $values\n * @param int                $position The cycle position\n *\n * @return string The next value in the cycle\n */\nfunction twig_cycle($values, $position)\n{\n    if (!\\is_array($values) && !$values instanceof \\ArrayAccess) {\n        return $values;\n    }\n\n    return $values[$position % \\count($values)];\n}\n\n/**\n * Returns a random value depending on the supplied parameter type:\n * - a random item from a \\Traversable or array\n * - a random character from a string\n * - a random integer between 0 and the integer parameter.\n *\n * @param \\Traversable|array|int|float|string $values The values to pick a random item from\n * @param int|null                            $max    Maximum value used when $values is an int\n *\n * @throws RuntimeError when $values is an empty array (does not apply to an empty string which is returned as is)\n *\n * @return mixed A random value from the given sequence\n */\nfunction twig_random(Environment $env, $values = null, $max = null)\n{\n    if (null === $values) {\n        return null === $max ? mt_rand() : mt_rand(0, (int) $max);\n    }\n\n    if (\\is_int($values) || \\is_float($values)) {\n        if (null === $max) {\n            if ($values < 0) {\n                $max = 0;\n                $min = $values;\n            } else {\n                $max = $values;\n                $min = 0;\n            }\n        } else {\n            $min = $values;\n            $max = $max;\n        }\n\n        return mt_rand((int) $min, (int) $max);\n    }\n\n    if (\\is_string($values)) {\n        if ('' === $values) {\n            return '';\n        }\n\n        $charset = $env->getCharset();\n\n        if ('UTF-8' !== $charset) {\n            $values = twig_convert_encoding($values, 'UTF-8', $charset);\n        }\n\n        // unicode version of str_split()\n        // split at all positions, but not after the start and not before the end\n        $values = preg_split('/(?<!^)(?!$)/u', $values);\n\n        if ('UTF-8' !== $charset) {\n            foreach ($values as $i => $value) {\n                $values[$i] = twig_convert_encoding($value, $charset, 'UTF-8');\n            }\n        }\n    }\n\n    if (!twig_test_iterable($values)) {\n        return $values;\n    }\n\n    $values = twig_to_array($values);\n\n    if (0 === \\count($values)) {\n        throw new RuntimeError('The random function cannot pick from an empty array.');\n    }\n\n    return $values[array_rand($values, 1)];\n}\n\n/**\n * Converts a date to the given format.\n *\n *   {{ post.published_at|date(\"m/d/Y\") }}\n *\n * @param \\DateTimeInterface|\\DateInterval|string $date     A date\n * @param string|null                             $format   The target format, null to use the default\n * @param \\DateTimeZone|string|false|null         $timezone The target timezone, null to use the default, false to leave unchanged\n *\n * @return string The formatted date\n */\nfunction twig_date_format_filter(Environment $env, $date, $format = null, $timezone = null)\n{\n    if (null === $format) {\n        $formats = $env->getExtension(CoreExtension::class)->getDateFormat();\n        $format = $date instanceof \\DateInterval ? $formats[1] : $formats[0];\n    }\n\n    if ($date instanceof \\DateInterval) {\n        return $date->format($format);\n    }\n\n    return twig_date_converter($env, $date, $timezone)->format($format);\n}\n\n/**\n * Returns a new date object modified.\n *\n *   {{ post.published_at|date_modify(\"-1day\")|date(\"m/d/Y\") }}\n *\n * @param \\DateTimeInterface|string $date     A date\n * @param string                    $modifier A modifier string\n *\n * @return \\DateTimeInterface\n */\nfunction twig_date_modify_filter(Environment $env, $date, $modifier)\n{\n    $date = twig_date_converter($env, $date, false);\n\n    return $date->modify($modifier);\n}\n\n/**\n * Returns a formatted string.\n *\n * @param string|null $format\n * @param ...$values\n *\n * @return string\n */\nfunction twig_sprintf($format, ...$values)\n{\n    return sprintf($format ?? '', ...$values);\n}\n\n/**\n * Converts an input to a \\DateTime instance.\n *\n *    {% if date(user.created_at) < date('+2days') %}\n *      {# do something #}\n *    {% endif %}\n *\n * @param \\DateTimeInterface|string|null  $date     A date or null to use the current time\n * @param \\DateTimeZone|string|false|null $timezone The target timezone, null to use the default, false to leave unchanged\n *\n * @return \\DateTimeInterface\n */\nfunction twig_date_converter(Environment $env, $date = null, $timezone = null)\n{\n    // determine the timezone\n    if (false !== $timezone) {\n        if (null === $timezone) {\n            $timezone = $env->getExtension(CoreExtension::class)->getTimezone();\n        } elseif (!$timezone instanceof \\DateTimeZone) {\n            $timezone = new \\DateTimeZone($timezone);\n        }\n    }\n\n    // immutable dates\n    if ($date instanceof \\DateTimeImmutable) {\n        return false !== $timezone ? $date->setTimezone($timezone) : $date;\n    }\n\n    if ($date instanceof \\DateTimeInterface) {\n        $date = clone $date;\n        if (false !== $timezone) {\n            $date->setTimezone($timezone);\n        }\n\n        return $date;\n    }\n\n    if (null === $date || 'now' === $date) {\n        if (null === $date) {\n            $date = 'now';\n        }\n\n        return new \\DateTime($date, false !== $timezone ? $timezone : $env->getExtension(CoreExtension::class)->getTimezone());\n    }\n\n    $asString = (string) $date;\n    if (ctype_digit($asString) || (!empty($asString) && '-' === $asString[0] && ctype_digit(substr($asString, 1)))) {\n        $date = new \\DateTime('@'.$date);\n    } else {\n        $date = new \\DateTime($date, $env->getExtension(CoreExtension::class)->getTimezone());\n    }\n\n    if (false !== $timezone) {\n        $date->setTimezone($timezone);\n    }\n\n    return $date;\n}\n\n/**\n * Replaces strings within a string.\n *\n * @param string|null        $str  String to replace in\n * @param array|\\Traversable $from Replace values\n *\n * @return string\n */\nfunction twig_replace_filter($str, $from)\n{\n    if (!twig_test_iterable($from)) {\n        throw new RuntimeError(sprintf('The \"replace\" filter expects an array or \"Traversable\" as replace values, got \"%s\".', \\is_object($from) ? \\get_class($from) : \\gettype($from)));\n    }\n\n    return strtr($str ?? '', twig_to_array($from));\n}\n\n/**\n * Rounds a number.\n *\n * @param int|float|string|null $value     The value to round\n * @param int|float             $precision The rounding precision\n * @param string                $method    The method to use for rounding\n *\n * @return int|float The rounded number\n */\nfunction twig_round($value, $precision = 0, $method = 'common')\n{\n    $value = (float) $value;\n\n    if ('common' === $method) {\n        return round($value, $precision);\n    }\n\n    if ('ceil' !== $method && 'floor' !== $method) {\n        throw new RuntimeError('The round filter only supports the \"common\", \"ceil\", and \"floor\" methods.');\n    }\n\n    return $method($value * 10 ** $precision) / 10 ** $precision;\n}\n\n/**\n * Number format filter.\n *\n * All of the formatting options can be left null, in that case the defaults will\n * be used. Supplying any of the parameters will override the defaults set in the\n * environment object.\n *\n * @param mixed  $number       A float/int/string of the number to format\n * @param int    $decimal      the number of decimal points to display\n * @param string $decimalPoint the character(s) to use for the decimal point\n * @param string $thousandSep  the character(s) to use for the thousands separator\n *\n * @return string The formatted number\n */\nfunction twig_number_format_filter(Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)\n{\n    $defaults = $env->getExtension(CoreExtension::class)->getNumberFormat();\n    if (null === $decimal) {\n        $decimal = $defaults[0];\n    }\n\n    if (null === $decimalPoint) {\n        $decimalPoint = $defaults[1];\n    }\n\n    if (null === $thousandSep) {\n        $thousandSep = $defaults[2];\n    }\n\n    return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);\n}\n\n/**\n * URL encodes (RFC 3986) a string as a path segment or an array as a query string.\n *\n * @param string|array|null $url A URL or an array of query parameters\n *\n * @return string The URL encoded value\n */\nfunction twig_urlencode_filter($url)\n{\n    if (\\is_array($url)) {\n        return http_build_query($url, '', '&', \\PHP_QUERY_RFC3986);\n    }\n\n    return rawurlencode($url ?? '');\n}\n\n/**\n * Merges an array with another one.\n *\n *  {% set items = { 'apple': 'fruit', 'orange': 'fruit' } %}\n *\n *  {% set items = items|merge({ 'peugeot': 'car' }) %}\n *\n *  {# items now contains { 'apple': 'fruit', 'orange': 'fruit', 'peugeot': 'car' } #}\n *\n * @param array|\\Traversable $arr1 An array\n * @param array|\\Traversable $arr2 An array\n *\n * @return array The merged array\n */\nfunction twig_array_merge($arr1, $arr2)\n{\n    if (!twig_test_iterable($arr1)) {\n        throw new RuntimeError(sprintf('The merge filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($arr1)));\n    }\n\n    if (!twig_test_iterable($arr2)) {\n        throw new RuntimeError(sprintf('The merge filter only works with arrays or \"Traversable\", got \"%s\" as second argument.', \\gettype($arr2)));\n    }\n\n    return array_merge(twig_to_array($arr1), twig_to_array($arr2));\n}\n\n/**\n * Slices a variable.\n *\n * @param mixed $item         A variable\n * @param int   $start        Start of the slice\n * @param int   $length       Size of the slice\n * @param bool  $preserveKeys Whether to preserve key or not (when the input is an array)\n *\n * @return mixed The sliced variable\n */\nfunction twig_slice(Environment $env, $item, $start, $length = null, $preserveKeys = false)\n{\n    if ($item instanceof \\Traversable) {\n        while ($item instanceof \\IteratorAggregate) {\n            $item = $item->getIterator();\n        }\n\n        if ($start >= 0 && $length >= 0 && $item instanceof \\Iterator) {\n            try {\n                return iterator_to_array(new \\LimitIterator($item, $start, null === $length ? -1 : $length), $preserveKeys);\n            } catch (\\OutOfBoundsException $e) {\n                return [];\n            }\n        }\n\n        $item = iterator_to_array($item, $preserveKeys);\n    }\n\n    if (\\is_array($item)) {\n        return \\array_slice($item, $start, $length, $preserveKeys);\n    }\n\n    return (string) mb_substr((string) $item, $start, $length, $env->getCharset());\n}\n\n/**\n * Returns the first element of the item.\n *\n * @param mixed $item A variable\n *\n * @return mixed The first element of the item\n */\nfunction twig_first(Environment $env, $item)\n{\n    $elements = twig_slice($env, $item, 0, 1, false);\n\n    return \\is_string($elements) ? $elements : current($elements);\n}\n\n/**\n * Returns the last element of the item.\n *\n * @param mixed $item A variable\n *\n * @return mixed The last element of the item\n */\nfunction twig_last(Environment $env, $item)\n{\n    $elements = twig_slice($env, $item, -1, 1, false);\n\n    return \\is_string($elements) ? $elements : current($elements);\n}\n\n/**\n * Joins the values to a string.\n *\n * The separators between elements are empty strings per default, you can define them with the optional parameters.\n *\n *  {{ [1, 2, 3]|join(', ', ' and ') }}\n *  {# returns 1, 2 and 3 #}\n *\n *  {{ [1, 2, 3]|join('|') }}\n *  {# returns 1|2|3 #}\n *\n *  {{ [1, 2, 3]|join }}\n *  {# returns 123 #}\n *\n * @param array       $value An array\n * @param string      $glue  The separator\n * @param string|null $and   The separator for the last pair\n *\n * @return string The concatenated string\n */\nfunction twig_join_filter($value, $glue = '', $and = null)\n{\n    if (!twig_test_iterable($value)) {\n        $value = (array) $value;\n    }\n\n    $value = twig_to_array($value, false);\n\n    if (0 === \\count($value)) {\n        return '';\n    }\n\n    if (null === $and || $and === $glue) {\n        return implode($glue, $value);\n    }\n\n    if (1 === \\count($value)) {\n        return $value[0];\n    }\n\n    return implode($glue, \\array_slice($value, 0, -1)).$and.$value[\\count($value) - 1];\n}\n\n/**\n * Splits the string into an array.\n *\n *  {{ \"one,two,three\"|split(',') }}\n *  {# returns [one, two, three] #}\n *\n *  {{ \"one,two,three,four,five\"|split(',', 3) }}\n *  {# returns [one, two, \"three,four,five\"] #}\n *\n *  {{ \"123\"|split('') }}\n *  {# returns [1, 2, 3] #}\n *\n *  {{ \"aabbcc\"|split('', 2) }}\n *  {# returns [aa, bb, cc] #}\n *\n * @param string|null $value     A string\n * @param string      $delimiter The delimiter\n * @param int         $limit     The limit\n *\n * @return array The split string as an array\n */\nfunction twig_split_filter(Environment $env, $value, $delimiter, $limit = null)\n{\n    $value = $value ?? '';\n\n    if (\\strlen($delimiter) > 0) {\n        return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);\n    }\n\n    if ($limit <= 1) {\n        return preg_split('/(?<!^)(?!$)/u', $value);\n    }\n\n    $length = mb_strlen($value, $env->getCharset());\n    if ($length < $limit) {\n        return [$value];\n    }\n\n    $r = [];\n    for ($i = 0; $i < $length; $i += $limit) {\n        $r[] = mb_substr($value, $i, $limit, $env->getCharset());\n    }\n\n    return $r;\n}\n\n// The '_default' filter is used internally to avoid using the ternary operator\n// which costs a lot for big contexts (before PHP 5.4). So, on average,\n// a function call is cheaper.\n/**\n * @internal\n */\nfunction _twig_default_filter($value, $default = '')\n{\n    if (twig_test_empty($value)) {\n        return $default;\n    }\n\n    return $value;\n}\n\n/**\n * Returns the keys for the given array.\n *\n * It is useful when you want to iterate over the keys of an array:\n *\n *  {% for key in array|keys %}\n *      {# ... #}\n *  {% endfor %}\n *\n * @param array $array An array\n *\n * @return array The keys\n */\nfunction twig_get_array_keys_filter($array)\n{\n    if ($array instanceof \\Traversable) {\n        while ($array instanceof \\IteratorAggregate) {\n            $array = $array->getIterator();\n        }\n\n        if ($array instanceof \\Iterator) {\n            $keys = [];\n            $array->rewind();\n            while ($array->valid()) {\n                $keys[] = $array->key();\n                $array->next();\n            }\n\n            return $keys;\n        }\n\n        $keys = [];\n        foreach ($array as $key => $item) {\n            $keys[] = $key;\n        }\n\n        return $keys;\n    }\n\n    if (!\\is_array($array)) {\n        return [];\n    }\n\n    return array_keys($array);\n}\n\n/**\n * Reverses a variable.\n *\n * @param array|\\Traversable|string|null $item         An array, a \\Traversable instance, or a string\n * @param bool                           $preserveKeys Whether to preserve key or not\n *\n * @return mixed The reversed input\n */\nfunction twig_reverse_filter(Environment $env, $item, $preserveKeys = false)\n{\n    if ($item instanceof \\Traversable) {\n        return array_reverse(iterator_to_array($item), $preserveKeys);\n    }\n\n    if (\\is_array($item)) {\n        return array_reverse($item, $preserveKeys);\n    }\n\n    $string = (string) $item;\n\n    $charset = $env->getCharset();\n\n    if ('UTF-8' !== $charset) {\n        $string = twig_convert_encoding($string, 'UTF-8', $charset);\n    }\n\n    preg_match_all('/./us', $string, $matches);\n\n    $string = implode('', array_reverse($matches[0]));\n\n    if ('UTF-8' !== $charset) {\n        $string = twig_convert_encoding($string, $charset, 'UTF-8');\n    }\n\n    return $string;\n}\n\n/**\n * Sorts an array.\n *\n * @param array|\\Traversable $array\n *\n * @return array\n */\nfunction twig_sort_filter(Environment $env, $array, $arrow = null)\n{\n    if ($array instanceof \\Traversable) {\n        $array = iterator_to_array($array);\n    } elseif (!\\is_array($array)) {\n        throw new RuntimeError(sprintf('The sort filter only works with arrays or \"Traversable\", got \"%s\".', \\gettype($array)));\n    }\n\n    if (null !== $arrow) {\n        twig_check_arrow_in_sandbox($env, $arrow, 'sort', 'filter');\n\n        uasort($array, $arrow);\n    } else {\n        asort($array);\n    }\n\n    return $array;\n}\n\n/**\n * @internal\n */\nfunction twig_in_filter($value, $compare)\n{\n    if ($value instanceof Markup) {\n        $value = (string) $value;\n    }\n    if ($compare instanceof Markup) {\n        $compare = (string) $compare;\n    }\n\n    if (\\is_array($compare)) {\n        return \\in_array($value, $compare, \\is_object($value) || \\is_resource($value));\n    } elseif (\\is_string($compare) && (\\is_string($value) || \\is_int($value) || \\is_float($value))) {\n        return '' === $value || false !== strpos($compare, (string) $value);\n    } elseif ($compare instanceof \\Traversable) {\n        if (\\is_object($value) || \\is_resource($value)) {\n            foreach ($compare as $item) {\n                if ($item === $value) {\n                    return true;\n                }\n            }\n        } else {\n            foreach ($compare as $item) {\n                if ($item == $value) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    return false;\n}\n\n/**\n * Returns a trimmed string.\n *\n * @param string|null $string\n * @param string|null $characterMask\n * @param string      $side\n *\n * @return string\n *\n * @throws RuntimeError When an invalid trimming side is used (not a string or not 'left', 'right', or 'both')\n */\nfunction twig_trim_filter($string, $characterMask = null, $side = 'both')\n{\n    if (null === $characterMask) {\n        $characterMask = \" \\t\\n\\r\\0\\x0B\";\n    }\n\n    switch ($side) {\n        case 'both':\n            return trim($string ?? '', $characterMask);\n        case 'left':\n            return ltrim($string ?? '', $characterMask);\n        case 'right':\n            return rtrim($string ?? '', $characterMask);\n        default:\n            throw new RuntimeError('Trimming side must be \"left\", \"right\" or \"both\".');\n    }\n}\n\n/**\n * Inserts HTML line breaks before all newlines in a string.\n *\n * @param string|null $string\n *\n * @return string\n */\nfunction twig_nl2br($string)\n{\n    return nl2br($string ?? '');\n}\n\n/**\n * Removes whitespaces between HTML tags.\n *\n * @param string|null $string\n *\n * @return string\n */\nfunction twig_spaceless($content)\n{\n    return trim(preg_replace('/>\\s+</', '><', $content ?? ''));\n}\n\n/**\n * @param string|null $string\n * @param string      $to\n * @param string      $from\n *\n * @return string\n */\nfunction twig_convert_encoding($string, $to, $from)\n{\n    if (!\\function_exists('iconv')) {\n        throw new RuntimeError('Unable to convert encoding: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');\n    }\n\n    return iconv($from, $to, $string ?? '');\n}\n\n/**\n * Returns the length of a variable.\n *\n * @param mixed $thing A variable\n *\n * @return int The length of the value\n */\nfunction twig_length_filter(Environment $env, $thing)\n{\n    if (null === $thing) {\n        return 0;\n    }\n\n    if (is_scalar($thing)) {\n        return mb_strlen($thing, $env->getCharset());\n    }\n\n    if ($thing instanceof \\Countable || \\is_array($thing) || $thing instanceof \\SimpleXMLElement) {\n        return \\count($thing);\n    }\n\n    if ($thing instanceof \\Traversable) {\n        return iterator_count($thing);\n    }\n\n    if (method_exists($thing, '__toString') && !$thing instanceof \\Countable) {\n        return mb_strlen((string) $thing, $env->getCharset());\n    }\n\n    return 1;\n}\n\n/**\n * Converts a string to uppercase.\n *\n * @param string|null $string A string\n *\n * @return string The uppercased string\n */\nfunction twig_upper_filter(Environment $env, $string)\n{\n    return mb_strtoupper($string ?? '', $env->getCharset());\n}\n\n/**\n * Converts a string to lowercase.\n *\n * @param string|null $string A string\n *\n * @return string The lowercased string\n */\nfunction twig_lower_filter(Environment $env, $string)\n{\n    return mb_strtolower($string ?? '', $env->getCharset());\n}\n\n/**\n * Strips HTML and PHP tags from a string.\n *\n * @param string|null $string\n * @param string[]|string|null $string\n *\n * @return string\n */\nfunction twig_striptags($string, $allowable_tags = null)\n{\n    return strip_tags($string ?? '', $allowable_tags);\n}\n\n/**\n * Returns a titlecased string.\n *\n * @param string|null $string A string\n *\n * @return string The titlecased string\n */\nfunction twig_title_string_filter(Environment $env, $string)\n{\n    if (null !== $charset = $env->getCharset()) {\n        return mb_convert_case($string ?? '', \\MB_CASE_TITLE, $charset);\n    }\n\n    return ucwords(strtolower($string ?? ''));\n}\n\n/**\n * Returns a capitalized string.\n *\n * @param string|null $string A string\n *\n * @return string The capitalized string\n */\nfunction twig_capitalize_string_filter(Environment $env, $string)\n{\n    $charset = $env->getCharset();\n\n    return mb_strtoupper(mb_substr($string ?? '', 0, 1, $charset), $charset).mb_strtolower(mb_substr($string ?? '', 1, null, $charset), $charset);\n}\n\n/**\n * @internal\n */\nfunction twig_call_macro(Template $template, string $method, array $args, int $lineno, array $context, Source $source)\n{\n    if (!method_exists($template, $method)) {\n        $parent = $template;\n        while ($parent = $parent->getParent($context)) {\n            if (method_exists($parent, $method)) {\n                return $parent->$method(...$args);\n            }\n        }\n\n        throw new RuntimeError(sprintf('Macro \"%s\" is not defined in template \"%s\".', substr($method, \\strlen('macro_')), $template->getTemplateName()), $lineno, $source);\n    }\n\n    return $template->$method(...$args);\n}\n\n/**\n * @internal\n */\nfunction twig_ensure_traversable($seq)\n{\n    if ($seq instanceof \\Traversable || \\is_array($seq)) {\n        return $seq;\n    }\n\n    return [];\n}\n\n/**\n * @internal\n */\nfunction twig_to_array($seq, $preserveKeys = true)\n{\n    if ($seq instanceof \\Traversable) {\n        return iterator_to_array($seq, $preserveKeys);\n    }\n\n    if (!\\is_array($seq)) {\n        return $seq;\n    }\n\n    return $preserveKeys ? $seq : array_values($seq);\n}\n\n/**\n * Checks if a variable is empty.\n *\n *    {# evaluates to true if the foo variable is null, false, or the empty string #}\n *    {% if foo is empty %}\n *        {# ... #}\n *    {% endif %}\n *\n * @param mixed $value A variable\n *\n * @return bool true if the value is empty, false otherwise\n */\nfunction twig_test_empty($value)\n{\n    if ($value instanceof \\Countable) {\n        return 0 === \\count($value);\n    }\n\n    if ($value instanceof \\Traversable) {\n        return !iterator_count($value);\n    }\n\n    if (\\is_object($value) && method_exists($value, '__toString')) {\n        return '' === (string) $value;\n    }\n\n    return '' === $value || false === $value || null === $value || [] === $value;\n}\n\n/**\n * Checks if a variable is traversable.\n *\n *    {# evaluates to true if the foo variable is an array or a traversable object #}\n *    {% if foo is iterable %}\n *        {# ... #}\n *    {% endif %}\n *\n * @param mixed $value A variable\n *\n * @return bool true if the value is traversable\n */\nfunction twig_test_iterable($value)\n{\n    return $value instanceof \\Traversable || \\is_array($value);\n}\n\n/**\n * Renders a template.\n *\n * @param array        $context\n * @param string|array $template      The template to render or an array of templates to try consecutively\n * @param array        $variables     The variables to pass to the template\n * @param bool         $withContext\n * @param bool         $ignoreMissing Whether to ignore missing templates or not\n * @param bool         $sandboxed     Whether to sandbox the template or not\n *\n * @return string The rendered template\n */\nfunction twig_include(Environment $env, $context, $template, $variables = [], $withContext = true, $ignoreMissing = false, $sandboxed = false)\n{\n    $alreadySandboxed = false;\n    $sandbox = null;\n    if ($withContext) {\n        $variables = array_merge($context, $variables);\n    }\n\n    if ($isSandboxed = $sandboxed && $env->hasExtension(SandboxExtension::class)) {\n        $sandbox = $env->getExtension(SandboxExtension::class);\n        if (!$alreadySandboxed = $sandbox->isSandboxed()) {\n            $sandbox->enableSandbox();\n        }\n\n        foreach ((\\is_array($template) ? $template : [$template]) as $name) {\n            // if a Template instance is passed, it might have been instantiated outside of a sandbox, check security\n            if ($name instanceof TemplateWrapper || $name instanceof Template) {\n                $name->unwrap()->checkSecurity();\n            }\n        }\n    }\n\n    try {\n        $loaded = null;\n        try {\n            $loaded = $env->resolveTemplate($template);\n        } catch (LoaderError $e) {\n            if (!$ignoreMissing) {\n                throw $e;\n            }\n        }\n\n        return $loaded ? $loaded->render($variables) : '';\n    } finally {\n        if ($isSandboxed && !$alreadySandboxed) {\n            $sandbox->disableSandbox();\n        }\n    }\n}\n\n/**\n * Returns a template content without rendering it.\n *\n * @param string $name          The template name\n * @param bool   $ignoreMissing Whether to ignore missing templates or not\n *\n * @return string The template source\n */\nfunction twig_source(Environment $env, $name, $ignoreMissing = false)\n{\n    $loader = $env->getLoader();\n    try {\n        return $loader->getSourceContext($name)->getCode();\n    } catch (LoaderError $e) {\n        if (!$ignoreMissing) {\n            throw $e;\n        }\n    }\n}\n\n/**\n * Provides the ability to get constants from instances as well as class/global constants.\n *\n * @param string      $constant The name of the constant\n * @param object|null $object   The object to get the constant from\n *\n * @return string\n */\nfunction twig_constant($constant, $object = null)\n{\n    if (null !== $object) {\n        $constant = \\get_class($object).'::'.$constant;\n    }\n\n    return \\constant($constant);\n}\n\n/**\n * Checks if a constant exists.\n *\n * @param string      $constant The name of the constant\n * @param object|null $object   The object to get the constant from\n *\n * @return bool\n */\nfunction twig_constant_is_defined($constant, $object = null)\n{\n    if (null !== $object) {\n        $constant = \\get_class($object).'::'.$constant;\n    }\n\n    return \\defined($constant);\n}\n\n/**\n * Batches item.\n *\n * @param array $items An array of items\n * @param int   $size  The size of the batch\n * @param mixed $fill  A value used to fill missing items\n *\n * @return array\n */\nfunction twig_array_batch($items, $size, $fill = null, $preserveKeys = true)\n{\n    if (!twig_test_iterable($items)) {\n        throw new RuntimeError(sprintf('The \"batch\" filter expects an array or \"Traversable\", got \"%s\".', \\is_object($items) ? \\get_class($items) : \\gettype($items)));\n    }\n\n    $size = ceil($size);\n\n    $result = array_chunk(twig_to_array($items, $preserveKeys), $size, $preserveKeys);\n\n    if (null !== $fill && $result) {\n        $last = \\count($result) - 1;\n        if ($fillCount = $size - \\count($result[$last])) {\n            for ($i = 0; $i < $fillCount; ++$i) {\n                $result[$last][] = $fill;\n            }\n        }\n    }\n\n    return $result;\n}\n\n/**\n * Returns the attribute value for a given array/object.\n *\n * @param mixed  $object            The object or array from where to get the item\n * @param mixed  $item              The item to get from the array or object\n * @param array  $arguments         An array of arguments to pass if the item is an object method\n * @param string $type              The type of attribute (@see \\Twig\\Template constants)\n * @param bool   $isDefinedTest     Whether this is only a defined check\n * @param bool   $ignoreStrictCheck Whether to ignore the strict attribute check or not\n * @param int    $lineno            The template line where the attribute was called\n *\n * @return mixed The attribute value, or a Boolean when $isDefinedTest is true, or null when the attribute is not set and $ignoreStrictCheck is true\n *\n * @throws RuntimeError if the attribute does not exist and Twig is running in strict mode and $isDefinedTest is false\n *\n * @internal\n */\nfunction twig_get_attribute(Environment $env, Source $source, $object, $item, array $arguments = [], $type = /* Template::ANY_CALL */ 'any', $isDefinedTest = false, $ignoreStrictCheck = false, $sandboxed = false, int $lineno = -1)\n{\n    // array\n    if (/* Template::METHOD_CALL */ 'method' !== $type) {\n        $arrayItem = \\is_bool($item) || \\is_float($item) ? (int) $item : $item;\n\n        if (((\\is_array($object) || $object instanceof \\ArrayObject) && (isset($object[$arrayItem]) || \\array_key_exists($arrayItem, (array) $object)))\n            || ($object instanceof ArrayAccess && isset($object[$arrayItem]))\n        ) {\n            if ($isDefinedTest) {\n                return true;\n            }\n\n            return $object[$arrayItem];\n        }\n\n        if (/* Template::ARRAY_CALL */ 'array' === $type || !\\is_object($object)) {\n            if ($isDefinedTest) {\n                return false;\n            }\n\n            if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n                return;\n            }\n\n            if ($object instanceof ArrayAccess) {\n                $message = sprintf('Key \"%s\" in object with ArrayAccess of class \"%s\" does not exist.', $arrayItem, \\get_class($object));\n            } elseif (\\is_object($object)) {\n                $message = sprintf('Impossible to access a key \"%s\" on an object of class \"%s\" that does not implement ArrayAccess interface.', $item, \\get_class($object));\n            } elseif (\\is_array($object)) {\n                if (empty($object)) {\n                    $message = sprintf('Key \"%s\" does not exist as the array is empty.', $arrayItem);\n                } else {\n                    $message = sprintf('Key \"%s\" for array with keys \"%s\" does not exist.', $arrayItem, implode(', ', array_keys($object)));\n                }\n            } elseif (/* Template::ARRAY_CALL */ 'array' === $type) {\n                if (null === $object) {\n                    $message = sprintf('Impossible to access a key (\"%s\") on a null variable.', $item);\n                } else {\n                    $message = sprintf('Impossible to access a key (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n                }\n            } elseif (null === $object) {\n                $message = sprintf('Impossible to access an attribute (\"%s\") on a null variable.', $item);\n            } else {\n                $message = sprintf('Impossible to access an attribute (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n            }\n\n            throw new RuntimeError($message, $lineno, $source);\n        }\n    }\n\n    if (!\\is_object($object)) {\n        if ($isDefinedTest) {\n            return false;\n        }\n\n        if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n            return;\n        }\n\n        if (null === $object) {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on a null variable.', $item);\n        } elseif (\\is_array($object)) {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on an array.', $item);\n        } else {\n            $message = sprintf('Impossible to invoke a method (\"%s\") on a %s variable (\"%s\").', $item, \\gettype($object), $object);\n        }\n\n        throw new RuntimeError($message, $lineno, $source);\n    }\n\n    if ($object instanceof Template) {\n        throw new RuntimeError('Accessing \\Twig\\Template attributes is forbidden.', $lineno, $source);\n    }\n\n    // object property\n    if (/* Template::METHOD_CALL */ 'method' !== $type) {\n        if (isset($object->$item) || \\array_key_exists((string) $item, (array) $object)) {\n            if ($isDefinedTest) {\n                return true;\n            }\n\n            if ($sandboxed) {\n                $env->getExtension(SandboxExtension::class)->checkPropertyAllowed($object, $item, $lineno, $source);\n            }\n\n            return $object->$item;\n        }\n    }\n\n    static $cache = [];\n\n    $class = \\get_class($object);\n\n    // object method\n    // precedence: getXxx() > isXxx() > hasXxx()\n    if (!isset($cache[$class])) {\n        $methods = get_class_methods($object);\n        sort($methods);\n        $lcMethods = array_map(function ($value) { return strtr($value, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'); }, $methods);\n        $classCache = [];\n        foreach ($methods as $i => $method) {\n            $classCache[$method] = $method;\n            $classCache[$lcName = $lcMethods[$i]] = $method;\n\n            if ('g' === $lcName[0] && 0 === strpos($lcName, 'get')) {\n                $name = substr($method, 3);\n                $lcName = substr($lcName, 3);\n            } elseif ('i' === $lcName[0] && 0 === strpos($lcName, 'is')) {\n                $name = substr($method, 2);\n                $lcName = substr($lcName, 2);\n            } elseif ('h' === $lcName[0] && 0 === strpos($lcName, 'has')) {\n                $name = substr($method, 3);\n                $lcName = substr($lcName, 3);\n                if (\\in_array('is'.$lcName, $lcMethods)) {\n                    continue;\n                }\n            } else {\n                continue;\n            }\n\n            // skip get() and is() methods (in which case, $name is empty)\n            if ($name) {\n                if (!isset($classCache[$name])) {\n                    $classCache[$name] = $method;\n                }\n\n                if (!isset($classCache[$lcName])) {\n                    $classCache[$lcName] = $method;\n                }\n            }\n        }\n        $cache[$class] = $classCache;\n    }\n\n    $call = false;\n    if (isset($cache[$class][$item])) {\n        $method = $cache[$class][$item];\n    } elseif (isset($cache[$class][$lcItem = strtr($item, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')])) {\n        $method = $cache[$class][$lcItem];\n    } elseif (isset($cache[$class]['__call'])) {\n        $method = $item;\n        $call = true;\n    } else {\n        if ($isDefinedTest) {\n            return false;\n        }\n\n        if ($ignoreStrictCheck || !$env->isStrictVariables()) {\n            return;\n        }\n\n        throw new RuntimeError(sprintf('Neither the property \"%1$s\" nor one of the methods \"%1$s()\", \"get%1$s()\"/\"is%1$s()\"/\"has%1$s()\" or \"__call()\" exist and have public access in class \"%2$s\".', $item, $class), $lineno, $source);\n    }\n\n    if ($isDefinedTest) {\n        return true;\n    }\n\n    if ($sandboxed) {\n        $env->getExtension(SandboxExtension::class)->checkMethodAllowed($object, $method, $lineno, $source);\n    }\n\n    // Some objects throw exceptions when they have __call, and the method we try\n    // to call is not supported. If ignoreStrictCheck is true, we should return null.\n    try {\n        $ret = $object->$method(...$arguments);\n    } catch (\\BadMethodCallException $e) {\n        if ($call && ($ignoreStrictCheck || !$env->isStrictVariables())) {\n            return;\n        }\n        throw $e;\n    }\n\n    return $ret;\n}\n\n/**\n * Returns the values from a single column in the input array.\n *\n * <pre>\n *  {% set items = [{ 'fruit' : 'apple'}, {'fruit' : 'orange' }] %}\n *\n *  {% set fruits = items|column('fruit') %}\n *\n *  {# fruits now contains ['apple', 'orange'] #}\n * </pre>\n *\n * @param array|Traversable $array An array\n * @param mixed             $name  The column name\n * @param mixed             $index The column to use as the index/keys for the returned array\n *\n * @return array The array of values\n */\nfunction twig_array_column($array, $name, $index = null): array\n{\n    if ($array instanceof Traversable) {\n        $array = iterator_to_array($array);\n    } elseif (!\\is_array($array)) {\n        throw new RuntimeError(sprintf('The column filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($array)));\n    }\n\n    return array_column($array, $name, $index);\n}\n\nfunction twig_array_filter(Environment $env, $array, $arrow)\n{\n    if (!twig_test_iterable($array)) {\n        throw new RuntimeError(sprintf('The \"filter\" filter expects an array or \"Traversable\", got \"%s\".', \\is_object($array) ? \\get_class($array) : \\gettype($array)));\n    }\n\n    twig_check_arrow_in_sandbox($env, $arrow, 'filter', 'filter');\n\n    if (\\is_array($array)) {\n        return array_filter($array, $arrow, \\ARRAY_FILTER_USE_BOTH);\n    }\n\n    // the IteratorIterator wrapping is needed as some internal PHP classes are \\Traversable but do not implement \\Iterator\n    return new \\CallbackFilterIterator(new \\IteratorIterator($array), $arrow);\n}\n\nfunction twig_array_map(Environment $env, $array, $arrow)\n{\n    twig_check_arrow_in_sandbox($env, $arrow, 'map', 'filter');\n\n    $r = [];\n    foreach ($array as $k => $v) {\n        $r[$k] = $arrow($v, $k);\n    }\n\n    return $r;\n}\n\nfunction twig_array_reduce(Environment $env, $array, $arrow, $initial = null)\n{\n    twig_check_arrow_in_sandbox($env, $arrow, 'reduce', 'filter');\n\n    if (!\\is_array($array)) {\n        if (!$array instanceof \\Traversable) {\n            throw new RuntimeError(sprintf('The \"reduce\" filter only works with arrays or \"Traversable\", got \"%s\" as first argument.', \\gettype($array)));\n        }\n\n        $array = iterator_to_array($array);\n    }\n\n    return array_reduce($array, $arrow, $initial);\n}\n\nfunction twig_check_arrow_in_sandbox(Environment $env, $arrow, $thing, $type)\n{\n    if (!$arrow instanceof Closure && $env->hasExtension('\\Twig\\Extension\\SandboxExtension') && $env->getExtension('\\Twig\\Extension\\SandboxExtension')->isSandboxed()) {\n        throw new RuntimeError(sprintf('The callable passed to the \"%s\" %s must be a Closure in sandbox mode.', $thing, $type));\n    }\n}\n}\n", "<?php\n\nnamespace Twig\\Tests\\Extension;\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse PHPUnit\\Framework\\TestCase;\nuse Twig\\Environment;\nuse Twig\\Error\\SyntaxError;\nuse Twig\\Extension\\SandboxExtension;\nuse Twig\\Extension\\StringLoaderExtension;\nuse Twig\\Loader\\ArrayLoader;\nuse Twig\\Sandbox\\SecurityError;\nuse Twig\\Sandbox\\SecurityNotAllowedFilterError;\nuse Twig\\Sandbox\\SecurityNotAllowedFunctionError;\nuse Twig\\Sandbox\\SecurityNotAllowedMethodError;\nuse Twig\\Sandbox\\SecurityNotAllowedPropertyError;\nuse Twig\\Sandbox\\SecurityNotAllowedTagError;\nuse Twig\\Sandbox\\SecurityPolicy;\n\nclass SandboxTest extends TestCase\n{\n    protected static $params;\n    protected static $templates;\n\n    protected function setUp(): void\n    {\n        self::$params = [\n            'name' => 'Fabien',\n            'obj' => new FooObject(),\n            'arr' => ['obj' => new FooObject()],\n        ];\n\n        self::$templates = [\n            '1_basic1' => '{{ obj.foo }}',\n            '1_basic2' => '{{ name|upper }}',\n            '1_basic3' => '{% if name %}foo{% endif %}',\n            '1_basic4' => '{{ obj.bar }}',\n            '1_basic5' => '{{ obj }}',\n            '1_basic7' => '{{ cycle([\"foo\",\"bar\"], 1) }}',\n            '1_basic8' => '{{ obj.getfoobar }}{{ obj.getFooBar }}',\n            '1_basic9' => '{{ obj.foobar }}{{ obj.fooBar }}',\n            '1_basic' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n            '1_layout' => '{% block content %}{% endblock %}',\n            '1_child' => \"{% extends \\\"1_layout\\\" %}\\n{% block content %}\\n{{ \\\"a\\\"|json_encode }}\\n{% endblock %}\",\n            '1_include' => '{{ include(\"1_basic1\", sandboxed=true) }}',\n            '1_basic2_include_template_from_string_sandboxed' => '{{ include(template_from_string(\"{{ name|upper }}\"), sandboxed=true) }}',\n            '1_basic2_include_template_from_string' => '{{ include(template_from_string(\"{{ name|upper }}\")) }}',\n            '1_range_operator' => '{{ (1..2)[0] }}',\n            '1_syntax_error_wrapper' => '{% sandbox %}{% include \"1_syntax_error\" %}{% endsandbox %}',\n            '1_syntax_error' => '{% syntax error }}',\n        ];\n    }\n\n    public function testSandboxWithInheritance()\n    {\n        $this->expectException(SecurityError::class);\n        $this->expectExceptionMessage('Filter \"json_encode\" is not allowed in \"1_child\" at line 3.');\n\n        $twig = $this->getEnvironment(true, [], self::$templates, ['block']);\n        $twig->load('1_child')->render([]);\n    }\n\n    public function testSandboxGloballySet()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $this->assertEquals('FOO', $twig->load('1_basic')->render(self::$params), 'Sandbox does nothing if it is disabled globally');\n    }\n\n    public function testSandboxUnallowedMethodAccessor()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic1')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed method is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedMethodError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedMethodError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('foo', $e->getMethodName(), 'Exception should be raised on the \"foo\" method');\n        }\n    }\n\n    public function testIfSandBoxIsDisabledAfterSyntaxError()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        try {\n            $twig->load('1_syntax_error_wrapper')->render(self::$params);\n        } catch (SyntaxError $e) {\n            /** @var SandboxExtension $sandbox */\n            $sandbox = $twig->getExtension(SandboxExtension::class);\n            $this->assertFalse($sandbox->isSandboxed());\n        }\n    }\n\n    public function testSandboxGloballyFalseUnallowedFilterWithIncludeTemplateFromStringSandboxed()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string_sandboxed')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxGloballyTrueUnallowedFilterWithIncludeTemplateFromStringSandboxed()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['include', 'template_from_string']);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string_sandboxed')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxGloballyFalseUnallowedFilterWithIncludeTemplateFromStringNotSandboxed()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $twig->addExtension(new StringLoaderExtension());\n        $this->assertSame('FABIEN', $twig->load('1_basic2_include_template_from_string')->render(self::$params));\n    }\n\n    public function testSandboxGloballyTrueUnallowedFilterWithIncludeTemplateFromStringNotSandboxed()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['include', 'template_from_string']);\n        $twig->addExtension(new StringLoaderExtension());\n        try {\n            $twig->load('1_basic2_include_template_from_string')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf('\\Twig\\Sandbox\\SecurityNotAllowedFilterError', $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxUnallowedFilter()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic2')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed filter is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFilterError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFilterError');\n            $this->assertEquals('upper', $e->getFilterName(), 'Exception should be raised on the \"upper\" filter');\n        }\n    }\n\n    public function testSandboxUnallowedTag()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic3')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed tag is used in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedTagError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedTagError');\n            $this->assertEquals('if', $e->getTagName(), 'Exception should be raised on the \"if\" tag');\n        }\n    }\n\n    public function testSandboxUnallowedProperty()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic4')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed property is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedPropertyError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedPropertyError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('bar', $e->getPropertyName(), 'Exception should be raised on the \"bar\" property');\n        }\n    }\n\n    /**\n     * @dataProvider getSandboxUnallowedToStringTests\n     */\n    public function testSandboxUnallowedToString($template)\n    {\n        $twig = $this->getEnvironment(true, [], ['index' => $template], [], ['upper'], ['Twig\\Tests\\Extension\\FooObject' => 'getAnotherFooObject'], [], ['random']);\n        try {\n            $twig->load('index')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed method (__toString()) is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedMethodError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedMethodError');\n            $this->assertEquals('Twig\\Tests\\Extension\\FooObject', $e->getClassName(), 'Exception should be raised on the \"Twig\\Tests\\Extension\\FooObject\" class');\n            $this->assertEquals('__tostring', $e->getMethodName(), 'Exception should be raised on the \"__toString\" method');\n        }\n    }\n\n    public function getSandboxUnallowedToStringTests()\n    {\n        return [\n            'simple' => ['{{ obj }}'],\n            'object_from_array' => ['{{ arr.obj }}'],\n            'object_chain' => ['{{ obj.anotherFooObject }}'],\n            'filter' => ['{{ obj|upper }}'],\n            'filter_from_array' => ['{{ arr.obj|upper }}'],\n            'function' => ['{{ random(obj) }}'],\n            'function_from_array' => ['{{ random(arr.obj) }}'],\n            'function_and_filter' => ['{{ random(obj|upper) }}'],\n            'function_and_filter_from_array' => ['{{ random(arr.obj|upper) }}'],\n            'object_chain_and_filter' => ['{{ obj.anotherFooObject|upper }}'],\n            'object_chain_and_function' => ['{{ random(obj.anotherFooObject) }}'],\n            'concat' => ['{{ obj ~ \"\" }}'],\n            'concat_again' => ['{{ \"\" ~ obj }}'],\n        ];\n    }\n\n    /**\n     * @dataProvider getSandboxAllowedToStringTests\n     */\n    public function testSandboxAllowedToString($template, $output)\n    {\n        $twig = $this->getEnvironment(true, [], ['index' => $template], ['set'], [], ['Twig\\Tests\\Extension\\FooObject' => ['foo', 'getAnotherFooObject']]);\n        $this->assertEquals($output, $twig->load('index')->render(self::$params));\n    }\n\n    public function getSandboxAllowedToStringTests()\n    {\n        return [\n            'constant_test' => ['{{ obj is constant(\"PHP_INT_MAX\") }}', ''],\n            'set_object' => ['{% set a = obj.anotherFooObject %}{{ a.foo }}', 'foo'],\n            'is_defined' => ['{{ obj.anotherFooObject is defined }}', '1'],\n            'is_null' => ['{{ obj is null }}', ''],\n            'is_sameas' => ['{{ obj is same as(obj) }}', '1'],\n            'is_sameas_no_brackets' => ['{{ obj is same as obj }}', '1'],\n            'is_sameas_from_array' => ['{{ arr.obj is same as(arr.obj) }}', '1'],\n            'is_sameas_from_array_no_brackets' => ['{{ arr.obj is same as arr.obj }}', '1'],\n            'is_sameas_from_another_method' => ['{{ obj.anotherFooObject is same as(obj.anotherFooObject) }}', ''],\n            'is_sameas_from_another_method_no_brackets' => ['{{ obj.anotherFooObject is same as obj.anotherFooObject }}', ''],\n        ];\n    }\n\n    public function testSandboxAllowMethodToString()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => '__toString']);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic5')->render(self::$params), 'Sandbox allow some methods');\n        $this->assertEquals(1, FooObject::$called['__toString'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxAllowMethodToStringDisabled()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic5')->render(self::$params), 'Sandbox allows __toString when sandbox disabled');\n        $this->assertEquals(1, FooObject::$called['__toString'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxUnallowedFunction()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_basic7')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if an unallowed function is called in the template');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFunctionError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFunctionError');\n            $this->assertEquals('cycle', $e->getFunctionName(), 'Exception should be raised on the \"cycle\" function');\n        }\n    }\n\n    public function testSandboxUnallowedRangeOperator()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('1_range_operator')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception if the unallowed range operator is called');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedFunctionError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedFunctionError');\n            $this->assertEquals('range', $e->getFunctionName(), 'Exception should be raised on the \"range\" function');\n        }\n    }\n\n    public function testSandboxAllowMethodFoo()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => 'foo']);\n        FooObject::reset();\n        $this->assertEquals('foo', $twig->load('1_basic1')->render(self::$params), 'Sandbox allow some methods');\n        $this->assertEquals(1, FooObject::$called['foo'], 'Sandbox only calls method once');\n    }\n\n    public function testSandboxAllowFilter()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], ['upper']);\n        $this->assertEquals('FABIEN', $twig->load('1_basic2')->render(self::$params), 'Sandbox allow some filters');\n    }\n\n    public function testSandboxAllowTag()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, ['if']);\n        $this->assertEquals('foo', $twig->load('1_basic3')->render(self::$params), 'Sandbox allow some tags');\n    }\n\n    public function testSandboxAllowProperty()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], ['Twig\\Tests\\Extension\\FooObject' => 'bar']);\n        $this->assertEquals('bar', $twig->load('1_basic4')->render(self::$params), 'Sandbox allow some properties');\n    }\n\n    public function testSandboxAllowFunction()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['cycle']);\n        $this->assertEquals('bar', $twig->load('1_basic7')->render(self::$params), 'Sandbox allow some functions');\n    }\n\n    public function testSandboxAllowRangeOperator()\n    {\n        $twig = $this->getEnvironment(true, [], self::$templates, [], [], [], [], ['range']);\n        $this->assertEquals('1', $twig->load('1_range_operator')->render(self::$params), 'Sandbox allow the range operator');\n    }\n\n    public function testSandboxAllowFunctionsCaseInsensitive()\n    {\n        foreach (['getfoobar', 'getFoobar', 'getFooBar'] as $name) {\n            $twig = $this->getEnvironment(true, [], self::$templates, [], [], ['Twig\\Tests\\Extension\\FooObject' => $name]);\n            FooObject::reset();\n            $this->assertEquals('foobarfoobar', $twig->load('1_basic8')->render(self::$params), 'Sandbox allow methods in a case-insensitive way');\n            $this->assertEquals(2, FooObject::$called['getFooBar'], 'Sandbox only calls method once');\n\n            $this->assertEquals('foobarfoobar', $twig->load('1_basic9')->render(self::$params), 'Sandbox allow methods via shortcut names (ie. without get/set)');\n        }\n    }\n\n    public function testSandboxLocallySetForAnInclude()\n    {\n        self::$templates = [\n            '2_basic' => '{{ obj.foo }}{% include \"2_included\" %}{{ obj.foo }}',\n            '2_included' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n        ];\n\n        $twig = $this->getEnvironment(false, [], self::$templates);\n        $this->assertEquals('fooFOOfoo', $twig->load('2_basic')->render(self::$params), 'Sandbox does nothing if disabled globally and sandboxed not used for the include');\n\n        self::$templates = [\n            '3_basic' => '{{ obj.foo }}{% sandbox %}{% include \"3_included\" %}{% endsandbox %}{{ obj.foo }}',\n            '3_included' => '{% if obj.foo %}{{ obj.foo|upper }}{% endif %}',\n        ];\n\n        $twig = $this->getEnvironment(true, [], self::$templates);\n        try {\n            $twig->load('3_basic')->render(self::$params);\n            $this->fail('Sandbox throws a SecurityError exception when the included file is sandboxed');\n        } catch (SecurityError $e) {\n            $this->assertInstanceOf(SecurityNotAllowedTagError::class, $e, 'Exception should be an instance of Twig_Sandbox_SecurityNotAllowedTagError');\n            $this->assertEquals('sandbox', $e->getTagName());\n        }\n    }\n\n    public function testMacrosInASandbox()\n    {\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{%- import _self as macros %}\n\n{%- macro test(text) %}<p>{{ text }}</p>{% endmacro %}\n\n{{- macros.test('username') }}\nEOF\n        ], ['macro', 'import'], ['escape']);\n\n        $this->assertEquals('<p>username</p>', $twig->load('index')->render([]));\n    }\n\n    public function testSandboxDisabledAfterIncludeFunctionError()\n    {\n        $twig = $this->getEnvironment(false, [], self::$templates);\n\n        $e = null;\n        try {\n            $twig->load('1_include')->render(self::$params);\n        } catch (\\Throwable $e) {\n        }\n        if (null === $e) {\n            $this->fail('An exception should be thrown for this test to be valid.');\n        }\n\n        $this->assertFalse($twig->getExtension(SandboxExtension::class)->isSandboxed(), 'Sandboxed include() function call should not leave Sandbox enabled when an error occurs.');\n    }\n\n    public function testSandboxWithNoClosureFilter()\n    {\n        $this->expectException('\\Twig\\Error\\RuntimeError');\n        $this->expectExceptionMessage('The callable passed to the \"filter\" filter must be a Closure in sandbox mode in \"index\" at line 1.');\n\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{{ [\"foo\", \"bar\", \"\"]|filter(\"trim\")|join(\", \") }}\nEOF\n        ], [], ['escape', 'filter', 'join']);\n\n        $twig->load('index')->render([]);\n    }\n\n    public function testSandboxWithClosureFilter()\n    {\n        $twig = $this->getEnvironment(true, ['autoescape' => 'html'], ['index' => <<<EOF\n{{ [\"foo\", \"bar\", \"\"]|filter(v => v != \"\")|join(\", \") }}\nEOF\n        ], [], ['escape', 'filter', 'join']);\n\n        $this->assertSame('foo, bar', $twig->load('index')->render([]));\n    }\n\n    protected function getEnvironment($sandboxed, $options, $templates, $tags = [], $filters = [], $methods = [], $properties = [], $functions = [])\n    {\n        $loader = new ArrayLoader($templates);\n        $twig = new Environment($loader, array_merge(['debug' => true, 'cache' => false, 'autoescape' => false], $options));\n        $policy = new SecurityPolicy($tags, $filters, $methods, $properties, $functions);\n        $twig->addExtension(new SandboxExtension($policy, $sandboxed));\n\n        return $twig;\n    }\n}\n\nclass FooObject\n{\n    public static $called = ['__toString' => 0, 'foo' => 0, 'getFooBar' => 0];\n\n    public $bar = 'bar';\n\n    public static function reset()\n    {\n        self::$called = ['__toString' => 0, 'foo' => 0, 'getFooBar' => 0];\n    }\n\n    public function __toString()\n    {\n        ++self::$called['__toString'];\n\n        return 'foo';\n    }\n\n    public function foo()\n    {\n        ++self::$called['foo'];\n\n        return 'foo';\n    }\n\n    public function getFooBar()\n    {\n        ++self::$called['getFooBar'];\n\n        return 'foobar';\n    }\n\n    public function getAnotherFooObject()\n    {\n        return new self();\n    }\n}\n"], "filenames": ["CHANGELOG", "src/Extension/CoreExtension.php", "tests/Extension/SandboxTest.php"], "buggy_code_start_loc": [1, 240, 393], "buggy_code_end_loc": [8, 1652, 394], "fixing_code_start_loc": [1, 240, 393], "fixing_code_end_loc": [8, 1655, 394], "type": "CWE-74", "message": "Twig is an open source template language for PHP. When in a sandbox mode, the `arrow` parameter of the `sort` filter must be a closure to avoid attackers being able to run arbitrary PHP functions. In affected versions this constraint was not properly enforced and could lead to code injection of arbitrary PHP code. Patched versions now disallow calling non Closure in the `sort` filter as is the case for some other filters. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2022-23614", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-04T23:15:15.727", "lastModified": "2022-04-18T19:34:45.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Twig is an open source template language for PHP. When in a sandbox mode, the `arrow` parameter of the `sort` filter must be a closure to avoid attackers being able to run arbitrary PHP functions. In affected versions this constraint was not properly enforced and could lead to code injection of arbitrary PHP code. Patched versions now disallow calling non Closure in the `sort` filter as is the case for some other filters. Users are advised to upgrade."}, {"lang": "es", "value": "Twig es un lenguaje de plantillas de c\u00f3digo abierto para PHP. Cuando est\u00e1 en modo sandbox, el par\u00e1metro \"arrow\" del filtro \"sort\" debe ser un cierre para evitar que atacantes puedan ejecutar funciones PHP arbitrarias. En las versiones afectadas, esta restricci\u00f3n no era aplicada correctamente y pod\u00eda conllevar a una inyecci\u00f3n de c\u00f3digo PHP arbitrario. Las versiones parcheadas ahora no permiten llamar a un no cierre en el filtro \"sort\" como es el caso de algunos otros filtros. Es recomendado a usuarios actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symfony:twig:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.14.11", "matchCriteriaId": "24C2FD11-E184-4113-A2EB-AAD71CE579C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:symfony:twig:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.3.8", "matchCriteriaId": "7373AE6D-CFDE-4E23-AF3D-90E85C84AF1E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/twigphp/Twig/commit/22b9dc3c03ee66d7e21d9ed2ca76052b134cb9e9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/twigphp/Twig/commit/2eb33080558611201b55079d07ac88f207b466d5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/twigphp/Twig/security/advisories/GHSA-5mv2-rx3q-4w2v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/I2PVV5DUTRUECTIHMTWRI5Z7DVNYQ2YO/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OTN4273U4RHVIXED64T7DSMJ3VYTPRE7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PECHIY2XLWUH2WLCNPDGNFMPHPRPCEDZ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SIGZCFSYLPP7UVJ4E4NLHSOQSKYNXSAD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5107", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/twigphp/Twig/commit/22b9dc3c03ee66d7e21d9ed2ca76052b134cb9e9"}}