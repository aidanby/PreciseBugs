{"buggy_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* jwt_authn: fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.\n* tcp_proxy: fix a crash that occurs when configured for :ref:`upstream tunneling <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection disconnects while the the upstream connection or http/2 stream is still being established.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "#include \"source/common/router/router.h\"\n\n#include <chrono>\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/event/timer.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/conn_pool.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n#include \"envoy/upstream/health_check_host_monitor.h\"\n#include \"envoy/upstream/upstream.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/cleanup.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/enum_to_int.h\"\n#include \"source/common/common/scope_tracker.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/config/utility.h\"\n#include \"source/common/grpc/common.h\"\n#include \"source/common/http/codes.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/headers.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/network/application_protocol.h\"\n#include \"source/common/network/socket_option_factory.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/network/upstream_server_name.h\"\n#include \"source/common/network/upstream_socket_options_filter_state.h\"\n#include \"source/common/network/upstream_subject_alt_names.h\"\n#include \"source/common/router/config_impl.h\"\n#include \"source/common/router/debug_config.h\"\n#include \"source/common/router/retry_state_impl.h\"\n#include \"source/common/router/upstream_request.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stream_info/uint32_accessor_impl.h\"\n#include \"source/common/tracing/http_tracer_impl.h\"\n\nnamespace Envoy {\nnamespace Router {\nnamespace {\nconstexpr char NumInternalRedirectsFilterStateName[] = \"num_internal_redirects\";\n\nuint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }\n\nbool schemeIsHttp(const Http::RequestHeaderMap& downstream_headers,\n                  const Network::Connection& connection) {\n  if (Http::Utility::getScheme(downstream_headers) == Http::Headers::get().SchemeValues.Http) {\n    return true;\n  }\n  if (!connection.ssl()) {\n    return true;\n  }\n  return false;\n}\n\nconstexpr uint64_t TimeoutPrecisionFactor = 100;\n\n} // namespace\n\n// Express percentage as [0, TimeoutPrecisionFactor] because stats do not accept floating point\n// values, and getting multiple significant figures on the histogram would be nice.\nuint64_t FilterUtility::percentageOfTimeout(const std::chrono::milliseconds response_time,\n                                            const std::chrono::milliseconds timeout) {\n  // Timeouts of 0 are considered infinite. Any portion of an infinite timeout used is still\n  // none of it.\n  if (timeout.count() == 0) {\n    return 0;\n  }\n\n  return static_cast<uint64_t>(response_time.count() * TimeoutPrecisionFactor / timeout.count());\n}\n\nvoid FilterUtility::setUpstreamScheme(Http::RequestHeaderMap& headers, bool downstream_secure) {\n  if (Http::HeaderUtility::schemeIsValid(headers.getSchemeValue())) {\n    return;\n  }\n  // After all the changes in https://github.com/envoyproxy/envoy/issues/14587\n  // this path should only occur if a buggy filter has removed the :scheme\n  // header. In that case best-effort set from X-Forwarded-Proto.\n  absl::string_view xfp = headers.getForwardedProtoValue();\n  if (Http::HeaderUtility::schemeIsValid(xfp)) {\n    headers.setScheme(xfp);\n    return;\n  }\n\n  if (downstream_secure) {\n    headers.setReferenceScheme(Http::Headers::get().SchemeValues.Https);\n  } else {\n    headers.setReferenceScheme(Http::Headers::get().SchemeValues.Http);\n  }\n}\n\nbool FilterUtility::shouldShadow(const ShadowPolicy& policy, Runtime::Loader& runtime,\n                                 uint64_t stable_random) {\n  if (policy.cluster().empty()) {\n    return false;\n  }\n\n  if (policy.defaultValue().numerator() > 0) {\n    return runtime.snapshot().featureEnabled(policy.runtimeKey(), policy.defaultValue(),\n                                             stable_random);\n  }\n\n  if (!policy.runtimeKey().empty() &&\n      !runtime.snapshot().featureEnabled(policy.runtimeKey(), 0, stable_random, 10000UL)) {\n    return false;\n  }\n\n  return true;\n}\n\nFilterUtility::TimeoutData\nFilterUtility::finalTimeout(const RouteEntry& route, Http::RequestHeaderMap& request_headers,\n                            bool insert_envoy_expected_request_timeout_ms, bool grpc_request,\n                            bool per_try_timeout_hedging_enabled,\n                            bool respect_expected_rq_timeout) {\n  // See if there is a user supplied timeout in a request header. If there is we take that.\n  // Otherwise if the request is gRPC and a maximum gRPC timeout is configured we use the timeout\n  // in the gRPC headers (or infinity when gRPC headers have no timeout), but cap that timeout to\n  // the configured maximum gRPC timeout (which may also be infinity, represented by a 0 value),\n  // or the default from the route config otherwise.\n  TimeoutData timeout;\n  if (!route.usingNewTimeouts()) {\n    if (grpc_request && route.maxGrpcTimeout()) {\n      const std::chrono::milliseconds max_grpc_timeout = route.maxGrpcTimeout().value();\n      auto header_timeout = Grpc::Common::getGrpcTimeout(request_headers);\n      std::chrono::milliseconds grpc_timeout =\n          header_timeout ? header_timeout.value() : std::chrono::milliseconds(0);\n      if (route.grpcTimeoutOffset()) {\n        // We only apply the offset if it won't result in grpc_timeout hitting 0 or below, as\n        // setting it to 0 means infinity and a negative timeout makes no sense.\n        const auto offset = *route.grpcTimeoutOffset();\n        if (offset < grpc_timeout) {\n          grpc_timeout -= offset;\n        }\n      }\n\n      // Cap gRPC timeout to the configured maximum considering that 0 means infinity.\n      if (max_grpc_timeout != std::chrono::milliseconds(0) &&\n          (grpc_timeout == std::chrono::milliseconds(0) || grpc_timeout > max_grpc_timeout)) {\n        grpc_timeout = max_grpc_timeout;\n      }\n      timeout.global_timeout_ = grpc_timeout;\n    } else {\n      timeout.global_timeout_ = route.timeout();\n    }\n  }\n  timeout.per_try_timeout_ = route.retryPolicy().perTryTimeout();\n  timeout.per_try_idle_timeout_ = route.retryPolicy().perTryIdleTimeout();\n\n  uint64_t header_timeout;\n\n  if (respect_expected_rq_timeout) {\n    // Check if there is timeout set by egress Envoy.\n    // If present, use that value as route timeout and don't override\n    // *x-envoy-expected-rq-timeout-ms* header. At this point *x-envoy-upstream-rq-timeout-ms*\n    // header should have been sanitized by egress Envoy.\n    const Http::HeaderEntry* header_expected_timeout_entry =\n        request_headers.EnvoyExpectedRequestTimeoutMs();\n    if (header_expected_timeout_entry) {\n      trySetGlobalTimeout(*header_expected_timeout_entry, timeout);\n    } else {\n      const Http::HeaderEntry* header_timeout_entry =\n          request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n      if (header_timeout_entry) {\n        trySetGlobalTimeout(*header_timeout_entry, timeout);\n        request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n      }\n    }\n  } else {\n    const Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n    if (header_timeout_entry) {\n      trySetGlobalTimeout(*header_timeout_entry, timeout);\n      request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n    }\n  }\n\n  // See if there is a per try/retry timeout. If it's >= global we just ignore it.\n  const absl::string_view per_try_timeout_entry =\n      request_headers.getEnvoyUpstreamRequestPerTryTimeoutMsValue();\n  if (!per_try_timeout_entry.empty()) {\n    if (absl::SimpleAtoi(per_try_timeout_entry, &header_timeout)) {\n      timeout.per_try_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    request_headers.removeEnvoyUpstreamRequestPerTryTimeoutMs();\n  }\n\n  if (timeout.per_try_timeout_ >= timeout.global_timeout_ && timeout.global_timeout_.count() != 0) {\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n  }\n\n  setTimeoutHeaders(0, timeout, route, request_headers, insert_envoy_expected_request_timeout_ms,\n                    grpc_request, per_try_timeout_hedging_enabled);\n\n  return timeout;\n}\n\nvoid FilterUtility::setTimeoutHeaders(uint64_t elapsed_time,\n                                      const FilterUtility::TimeoutData& timeout,\n                                      const RouteEntry& route,\n                                      Http::RequestHeaderMap& request_headers,\n                                      bool insert_envoy_expected_request_timeout_ms,\n                                      bool grpc_request, bool per_try_timeout_hedging_enabled) {\n\n  const uint64_t global_timeout = timeout.global_timeout_.count();\n\n  // See if there is any timeout to write in the expected timeout header.\n  uint64_t expected_timeout = timeout.per_try_timeout_.count();\n\n  // Use the global timeout if no per try timeout was specified or if we're\n  // doing hedging when there are per try timeouts. Either of these scenarios\n  // mean that the upstream server can use the full global timeout.\n  if (per_try_timeout_hedging_enabled || expected_timeout == 0) {\n    expected_timeout = global_timeout;\n  }\n\n  // If the expected timeout is 0 set no timeout, as Envoy treats 0 as infinite timeout.\n  if (expected_timeout > 0) {\n\n    if (global_timeout > 0) {\n      if (elapsed_time >= global_timeout) {\n        // We are out of time, but 0 would be an infinite timeout. So instead we send a 1ms timeout\n        // and assume the timers armed by onRequestComplete() will fire very soon.\n        expected_timeout = 1;\n      } else {\n        expected_timeout = std::min(expected_timeout, global_timeout - elapsed_time);\n      }\n    }\n\n    if (insert_envoy_expected_request_timeout_ms) {\n      request_headers.setEnvoyExpectedRequestTimeoutMs(expected_timeout);\n    }\n\n    // If we've configured max_grpc_timeout, override the grpc-timeout header with\n    // the expected timeout. This ensures that the optional per try timeout is reflected\n    // in grpc-timeout, ensuring that the upstream gRPC server is aware of the actual timeout.\n    if (grpc_request && !route.usingNewTimeouts() && route.maxGrpcTimeout()) {\n      Grpc::Common::toGrpcTimeout(std::chrono::milliseconds(expected_timeout), request_headers);\n    }\n  }\n}\n\nabsl::optional<std::chrono::milliseconds>\nFilterUtility::tryParseHeaderTimeout(const Http::HeaderEntry& header_timeout_entry) {\n  uint64_t header_timeout;\n  if (absl::SimpleAtoi(header_timeout_entry.value().getStringView(), &header_timeout)) {\n    return std::chrono::milliseconds(header_timeout);\n  }\n  return absl::nullopt;\n}\n\nvoid FilterUtility::trySetGlobalTimeout(const Http::HeaderEntry& header_timeout_entry,\n                                        TimeoutData& timeout) {\n  const auto timeout_ms = tryParseHeaderTimeout(header_timeout_entry);\n  if (timeout_ms.has_value()) {\n    timeout.global_timeout_ = timeout_ms.value();\n  }\n}\n\nFilterUtility::HedgingParams\nFilterUtility::finalHedgingParams(const RouteEntry& route,\n                                  Http::RequestHeaderMap& request_headers) {\n  HedgingParams hedging_params;\n  hedging_params.hedge_on_per_try_timeout_ = route.hedgePolicy().hedgeOnPerTryTimeout();\n\n  const Http::HeaderEntry* hedge_on_per_try_timeout_entry =\n      request_headers.EnvoyHedgeOnPerTryTimeout();\n  if (hedge_on_per_try_timeout_entry) {\n    if (hedge_on_per_try_timeout_entry->value() == \"true\") {\n      hedging_params.hedge_on_per_try_timeout_ = true;\n    }\n    if (hedge_on_per_try_timeout_entry->value() == \"false\") {\n      hedging_params.hedge_on_per_try_timeout_ = false;\n    }\n\n    request_headers.removeEnvoyHedgeOnPerTryTimeout();\n  }\n\n  return hedging_params;\n}\n\nFilter::~Filter() {\n  // Upstream resources should already have been cleaned.\n  ASSERT(upstream_requests_.empty());\n  ASSERT(!retry_state_);\n}\n\nconst FilterUtility::StrictHeaderChecker::HeaderCheckResult\nFilterUtility::StrictHeaderChecker::checkHeader(Http::RequestHeaderMap& headers,\n                                                const Http::LowerCaseString& target_header) {\n  if (target_header == Http::Headers::get().EnvoyUpstreamRequestTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyUpstreamRequestPerTryTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestPerTryTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyMaxRetries) {\n    return isInteger(headers.EnvoyMaxRetries());\n  } else if (target_header == Http::Headers::get().EnvoyRetryOn) {\n    return hasValidRetryFields(headers.EnvoyRetryOn(), &Router::RetryStateImpl::parseRetryOn);\n  } else if (target_header == Http::Headers::get().EnvoyRetryGrpcOn) {\n    return hasValidRetryFields(headers.EnvoyRetryGrpcOn(),\n                               &Router::RetryStateImpl::parseRetryGrpcOn);\n  }\n  // Should only validate headers for which we have implemented a validator.\n  PANIC(\"unexpectedly reached\");\n}\n\nStats::StatName Filter::upstreamZone(Upstream::HostDescriptionConstSharedPtr upstream_host) {\n  return upstream_host ? upstream_host->localityZoneStatName() : config_.empty_stat_name_;\n}\n\nvoid Filter::chargeUpstreamCode(uint64_t response_status_code,\n                                const Http::ResponseHeaderMap& response_headers,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  // Passing the response_status_code explicitly is an optimization to avoid\n  // multiple calls to slow Http::Utility::getResponseStatus.\n  ASSERT(response_status_code == Http::Utility::getResponseStatus(response_headers));\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck()) {\n    const Http::HeaderEntry* upstream_canary_header = response_headers.EnvoyUpstreamCanary();\n    const bool is_canary = (upstream_canary_header && upstream_canary_header->value() == \"true\") ||\n                           (upstream_host ? upstream_host->canary() : false);\n    const bool internal_request = Http::HeaderUtility::isEnvoyInternalRequest(*downstream_headers_);\n\n    Stats::StatName upstream_zone = upstreamZone(upstream_host);\n    Http::CodeStats::ResponseStatInfo info{config_.scope_,\n                                           cluster_->statsScope(),\n                                           config_.empty_stat_name_,\n                                           response_status_code,\n                                           internal_request,\n                                           route_entry_->virtualHost().statName(),\n                                           request_vcluster_ ? request_vcluster_->statName()\n                                                             : config_.empty_stat_name_,\n                                           config_.zone_name_,\n                                           upstream_zone,\n                                           is_canary};\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    code_stats.chargeResponseStat(info, exclude_http_code_stats_);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseStatInfo alt_info{config_.scope_,\n                                                 cluster_->statsScope(),\n                                                 alt_stat_prefix_->statName(),\n                                                 response_status_code,\n                                                 internal_request,\n                                                 config_.empty_stat_name_,\n                                                 config_.empty_stat_name_,\n                                                 config_.zone_name_,\n                                                 upstream_zone,\n                                                 is_canary};\n      code_stats.chargeResponseStat(alt_info, exclude_http_code_stats_);\n    }\n\n    if (dropped) {\n      cluster_->loadReportStats().upstream_rq_dropped_.inc();\n    }\n    if (upstream_host && Http::CodeUtility::is5xx(response_status_code)) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::chargeUpstreamCode(Http::Code code,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  const uint64_t response_status_code = enumToInt(code);\n  const auto fake_response_headers = Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(response_status_code)}});\n  chargeUpstreamCode(response_status_code, *fake_response_headers, upstream_host, dropped);\n}\n\nHttp::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n  downstream_headers_ = &headers;\n\n  // Extract debug configuration from filter state. This is used further along to determine whether\n  // we should append cluster and host headers to the response, and whether to forward the request\n  // upstream.\n  const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();\n  const DebugConfig* debug_config = filter_state->getDataReadOnly<DebugConfig>(DebugConfig::key());\n\n  // TODO: Maybe add a filter API for this.\n  grpc_request_ = Grpc::Common::isGrpcRequestHeaders(headers);\n  exclude_http_code_stats_ = grpc_request_ && config_.suppress_grpc_request_failure_code_stats_;\n\n  // Only increment rq total stat if we actually decode headers here. This does not count requests\n  // that get handled by earlier filters.\n  config_.stats_.rq_total_.inc();\n\n  // Initialize the `modify_headers` function as a no-op (so we don't have to remember to check it\n  // against nullptr before calling it), and feed it behavior later if/when we have cluster info\n  // headers to append.\n  std::function<void(Http::ResponseHeaderMap&)> modify_headers = [](Http::ResponseHeaderMap&) {};\n\n  // Determine if there is a route entry or a direct response for the request.\n  route_ = callbacks_->route();\n  if (!route_) {\n    config_.stats_.no_route_.inc();\n    ENVOY_STREAM_LOG(debug, \"no route match for URL '{}'\", *callbacks_, headers.getPathValue());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(Http::Code::NotFound, \"\", modify_headers, absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().RouteNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Determine if there is a direct response for the request.\n  const auto* direct_response = route_->directResponseEntry();\n  if (direct_response != nullptr) {\n    config_.stats_.rq_direct_response_.inc();\n    direct_response->rewritePathHeader(headers, !config_.suppress_envoy_headers_);\n    callbacks_->streamInfo().setRouteName(direct_response->routeName());\n    callbacks_->sendLocalReply(\n        direct_response->responseCode(), direct_response->responseBody(),\n        [this, direct_response,\n         &request_headers = headers](Http::ResponseHeaderMap& response_headers) -> void {\n          std::string new_path;\n          if (request_headers.Path()) {\n            new_path = direct_response->newPath(request_headers);\n          }\n          // See https://tools.ietf.org/html/rfc7231#section-7.1.2.\n          const auto add_location =\n              direct_response->responseCode() == Http::Code::Created ||\n              Http::CodeUtility::is3xx(enumToInt(direct_response->responseCode()));\n          if (!new_path.empty() && add_location) {\n            response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n          }\n          direct_response->finalizeResponseHeaders(response_headers, callbacks_->streamInfo());\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().DirectResponse);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // A route entry matches for the request.\n  route_entry_ = route_->routeEntry();\n  // If there's a route specific limit and it's smaller than general downstream\n  // limits, apply the new cap.\n  retry_shadow_buffer_limit_ =\n      std::min(retry_shadow_buffer_limit_, route_entry_->retryShadowBufferLimit());\n  callbacks_->streamInfo().setRouteName(route_entry_->routeName());\n  if (debug_config && debug_config->append_cluster_) {\n    // The cluster name will be appended to any local or upstream responses from this point.\n    modify_headers = [this, debug_config](Http::ResponseHeaderMap& headers) {\n      headers.addCopy(debug_config->cluster_header_.value_or(Http::Headers::get().EnvoyCluster),\n                      route_entry_->clusterName());\n    };\n  }\n  Upstream::ThreadLocalCluster* cluster =\n      config_.cm_.getThreadLocalCluster(route_entry_->clusterName());\n  if (!cluster) {\n    config_.stats_.no_cluster_.inc();\n    ENVOY_STREAM_LOG(debug, \"unknown cluster '{}'\", *callbacks_, route_entry_->clusterName());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);\n    callbacks_->sendLocalReply(route_entry_->clusterNotFoundResponseCode(), \"\", modify_headers,\n                               absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().ClusterNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  cluster_ = cluster->info();\n\n  // Set up stat prefixes, etc.\n  request_vcluster_ = route_entry_->virtualCluster(headers);\n  if (request_vcluster_ != nullptr) {\n    callbacks_->streamInfo().setVirtualClusterName(request_vcluster_->name());\n  }\n  ENVOY_STREAM_LOG(debug, \"cluster '{}' match for URL '{}'\", *callbacks_,\n                   route_entry_->clusterName(), headers.getPathValue());\n\n  if (config_.strict_check_headers_ != nullptr) {\n    for (const auto& header : *config_.strict_check_headers_) {\n      const auto res = FilterUtility::StrictHeaderChecker::checkHeader(headers, header);\n      if (!res.valid_) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::InvalidEnvoyRequestHeaders);\n        const std::string body = fmt::format(\"invalid header '{}' with value '{}'\",\n                                             std::string(res.entry_->key().getStringView()),\n                                             std::string(res.entry_->value().getStringView()));\n        const std::string details =\n            absl::StrCat(StreamInfo::ResponseCodeDetails::get().InvalidEnvoyRequestHeaders, \"{\",\n                         StringUtil::replaceAllEmptySpace(res.entry_->key().getStringView()), \"}\");\n        callbacks_->sendLocalReply(Http::Code::BadRequest, body, nullptr, absl::nullopt, details);\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n    }\n  }\n\n  const Http::HeaderEntry* request_alt_name = headers.EnvoyUpstreamAltStatName();\n  if (request_alt_name) {\n    alt_stat_prefix_ = std::make_unique<Stats::StatNameDynamicStorage>(\n        request_alt_name->value().getStringView(), config_.scope_.symbolTable());\n    headers.removeEnvoyUpstreamAltStatName();\n  }\n\n  // See if we are supposed to immediately kill some percentage of this cluster's traffic.\n  if (cluster_->maintenanceMode()) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, true);\n    callbacks_->sendLocalReply(\n        Http::Code::ServiceUnavailable, \"maintenance mode\",\n        [modify_headers, this](Http::ResponseHeaderMap& headers) {\n          if (!config_.suppress_envoy_headers_) {\n            headers.addReference(Http::Headers::get().EnvoyOverloaded,\n                                 Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          // Note: append_cluster_info does not respect suppress_envoy_headers.\n          modify_headers(headers);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().MaintenanceMode);\n    cluster_->stats().upstream_rq_maintenance_mode_.inc();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Fetch a connection pool for the upstream cluster.\n  const auto& upstream_http_protocol_options = cluster_->upstreamHttpProtocolOptions();\n\n  if (upstream_http_protocol_options.has_value() &&\n      (upstream_http_protocol_options.value().auto_sni() ||\n       upstream_http_protocol_options.value().auto_san_validation())) {\n    // Default the header to Host/Authority header.\n    absl::string_view header_value = headers.getHostValue();\n\n    // Check whether `override_auto_sni_header` is specified.\n    const auto override_auto_sni_header =\n        upstream_http_protocol_options.value().override_auto_sni_header();\n    if (!override_auto_sni_header.empty()) {\n      // Use the header value from `override_auto_sni_header` to set the SNI value.\n      const auto overridden_header_value = Http::HeaderUtility::getAllOfHeaderAsString(\n          headers, Http::LowerCaseString(override_auto_sni_header));\n      if (overridden_header_value.result().has_value() &&\n          !overridden_header_value.result().value().empty()) {\n        header_value = overridden_header_value.result().value();\n      }\n    }\n    const auto parsed_authority = Http::Utility::parseAuthority(header_value);\n    bool should_set_sni = !parsed_authority.is_ip_address_;\n    // `host_` returns a string_view so doing this should be safe.\n    absl::string_view sni_value = parsed_authority.host_;\n\n    if (should_set_sni && upstream_http_protocol_options.value().auto_sni()) {\n      callbacks_->streamInfo().filterState()->setData(\n          Network::UpstreamServerName::key(),\n          std::make_unique<Network::UpstreamServerName>(sni_value),\n          StreamInfo::FilterState::StateType::Mutable);\n    }\n\n    if (upstream_http_protocol_options.value().auto_san_validation()) {\n      callbacks_->streamInfo().filterState()->setData(\n          Network::UpstreamSubjectAltNames::key(),\n          std::make_unique<Network::UpstreamSubjectAltNames>(\n              std::vector<std::string>{std::string(sni_value)}),\n          StreamInfo::FilterState::StateType::Mutable);\n    }\n  }\n\n  transport_socket_options_ = Network::TransportSocketOptionsUtility::fromFilterState(\n      *callbacks_->streamInfo().filterState());\n\n  if (auto downstream_connection = downstreamConnection(); downstream_connection != nullptr) {\n    if (auto typed_state = downstream_connection->streamInfo()\n                               .filterState()\n                               .getDataReadOnly<Network::UpstreamSocketOptionsFilterState>(\n                                   Network::UpstreamSocketOptionsFilterState::key());\n        typed_state != nullptr) {\n      auto downstream_options = typed_state->value();\n      if (!upstream_options_) {\n        upstream_options_ = std::make_shared<Network::Socket::Options>();\n      }\n      Network::Socket::appendOptions(upstream_options_, downstream_options);\n    }\n  }\n\n  if (upstream_options_ && callbacks_->getUpstreamSocketOptions()) {\n    Network::Socket::appendOptions(upstream_options_, callbacks_->getUpstreamSocketOptions());\n  }\n\n  std::unique_ptr<GenericConnPool> generic_conn_pool = createConnPool(*cluster);\n\n  if (!generic_conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  Upstream::HostDescriptionConstSharedPtr host = generic_conn_pool->host();\n\n  if (debug_config && debug_config->append_upstream_host_) {\n    // The hostname and address will be appended to any local or upstream responses from this point,\n    // possibly in addition to the cluster name.\n    modify_headers = [modify_headers, debug_config, host](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->hostname_header_.value_or(Http::Headers::get().EnvoyUpstreamHostname),\n          host->hostname());\n      headers.addCopy(debug_config->host_address_header_.value_or(\n                          Http::Headers::get().EnvoyUpstreamHostAddress),\n                      host->address()->asString());\n    };\n  }\n\n  // If we've been instructed not to forward the request upstream, send an empty local response.\n  if (debug_config && debug_config->do_not_forward_) {\n    modify_headers = [modify_headers, debug_config](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->not_forwarded_header_.value_or(Http::Headers::get().EnvoyNotForwarded),\n          \"true\");\n    };\n    callbacks_->sendLocalReply(Http::Code::NoContent, \"\", modify_headers, absl::nullopt, \"\");\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  hedging_params_ = FilterUtility::finalHedgingParams(*route_entry_, headers);\n\n  timeout_ = FilterUtility::finalTimeout(*route_entry_, headers, !config_.suppress_envoy_headers_,\n                                         grpc_request_, hedging_params_.hedge_on_per_try_timeout_,\n                                         config_.respect_expected_rq_timeout_);\n\n  const Http::HeaderEntry* header_max_stream_duration_entry =\n      headers.EnvoyUpstreamStreamDurationMs();\n  if (header_max_stream_duration_entry) {\n    dynamic_max_stream_duration_ =\n        FilterUtility::tryParseHeaderTimeout(*header_max_stream_duration_entry);\n    headers.removeEnvoyUpstreamStreamDurationMs();\n  }\n\n  // If this header is set with any value, use an alternate response code on timeout\n  if (headers.EnvoyUpstreamRequestTimeoutAltResponse()) {\n    timeout_response_code_ = Http::Code::NoContent;\n    headers.removeEnvoyUpstreamRequestTimeoutAltResponse();\n  }\n\n  include_attempt_count_in_request_ = route_entry_->includeAttemptCountInRequest();\n  if (include_attempt_count_in_request_) {\n    headers.setEnvoyAttemptCount(attempt_count_);\n  }\n\n  // The router has reached a point where it is going to try to send a request upstream,\n  // so now modify_headers should attach x-envoy-attempt-count to the downstream response if the\n  // config flag is true.\n  if (route_entry_->includeAttemptCountInResponse()) {\n    modify_headers = [modify_headers, this](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n\n      // This header is added without checking for config_.suppress_envoy_headers_ to mirror what is\n      // done for upstream requests.\n      headers.setEnvoyAttemptCount(attempt_count_);\n    };\n  }\n  callbacks_->streamInfo().setAttemptCount(attempt_count_);\n\n  // Inject the active span's tracing context into the request headers.\n  callbacks_->activeSpan().injectContext(headers);\n\n  route_entry_->finalizeRequestHeaders(headers, callbacks_->streamInfo(),\n                                       !config_.suppress_envoy_headers_);\n  FilterUtility::setUpstreamScheme(\n      headers, callbacks_->streamInfo().downstreamAddressProvider().sslConnection() != nullptr);\n\n  // Ensure an http transport scheme is selected before continuing with decoding.\n  ASSERT(headers.Scheme());\n\n  retry_state_ = createRetryState(\n      route_entry_->retryPolicy(), headers, *cluster_, request_vcluster_, config_.runtime_,\n      config_.random_, callbacks_->dispatcher(), config_.timeSource(), route_entry_->priority());\n\n  // Determine which shadow policies to use. It's possible that we don't do any shadowing due to\n  // runtime keys.\n  for (const auto& shadow_policy : route_entry_->shadowPolicies()) {\n    const auto& policy_ref = *shadow_policy;\n    if (FilterUtility::shouldShadow(policy_ref, config_.runtime_, callbacks_->streamId())) {\n      active_shadow_policies_.push_back(std::cref(policy_ref));\n    }\n  }\n\n  ENVOY_STREAM_LOG(debug, \"router decoding headers:\\n{}\", *callbacks_, headers);\n\n  // Hang onto the modify_headers function for later use in handling upstream responses.\n  modify_headers_ = modify_headers;\n\n  conn_pool_new_stream_with_early_data_and_http3_ =\n      Runtime::runtimeFeatureEnabled(Runtime::conn_pool_new_stream_with_early_data_and_http3);\n  const bool can_send_early_data = conn_pool_new_stream_with_early_data_and_http3_ &&\n                                   Http::Utility::isSafeRequest(*downstream_headers_);\n\n  UpstreamRequestPtr upstream_request =\n      std::make_unique<UpstreamRequest>(*this, std::move(generic_conn_pool), can_send_early_data,\n                                        /*can_use_http3=*/true);\n  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(end_stream);\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nstd::unique_ptr<GenericConnPool>\nFilter::createConnPool(Upstream::ThreadLocalCluster& thread_local_cluster) {\n  GenericConnPoolFactory* factory = nullptr;\n  if (cluster_->upstreamConfig().has_value()) {\n    factory = Envoy::Config::Utility::getFactory<GenericConnPoolFactory>(\n        cluster_->upstreamConfig().value());\n    ENVOY_BUG(factory != nullptr,\n              fmt::format(\"invalid factory type '{}', failing over to default upstream\",\n                          cluster_->upstreamConfig().value().DebugString()));\n  }\n  if (!factory) {\n    factory = &config_.router_context_.genericConnPoolFactory();\n  }\n\n  bool should_tcp_proxy = false;\n\n  if (route_entry_->connectConfig().has_value()) {\n    auto method = downstream_headers_->getMethodValue();\n    should_tcp_proxy = (method == Http::Headers::get().MethodValues.Connect);\n\n    // Allow POST for proxying raw TCP if it is configured.\n    if (!should_tcp_proxy && route_entry_->connectConfig().value().allow_post()) {\n      should_tcp_proxy = (method == Http::Headers::get().MethodValues.Post);\n    }\n  }\n  return factory->createGenericConnPool(thread_local_cluster, should_tcp_proxy, *route_entry_,\n                                        callbacks_->streamInfo().protocol(), this);\n}\n\nvoid Filter::sendNoHealthyUpstreamResponse() {\n  callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);\n  chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, false);\n  callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, \"no healthy upstream\", modify_headers_,\n                             absl::nullopt,\n                             StreamInfo::ResponseCodeDetails::get().NoHealthyUpstream);\n}\n\nHttp::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n  // upstream_requests_.size() cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onRequestComplete(). It could be zero\n  // if the first request attempt has already failed and a retry is waiting for\n  // a backoff timer.\n  ASSERT(upstream_requests_.size() <= 1);\n\n  bool buffering = (retry_state_ && retry_state_->enabled()) || !active_shadow_policies_.empty() ||\n                   (route_entry_ && route_entry_->internalRedirectPolicy().enabled());\n  if (buffering &&\n      getLength(callbacks_->decodingBuffer()) + data.length() > retry_shadow_buffer_limit_) {\n    ENVOY_LOG(debug,\n              \"The request payload has at least {} bytes data which exceeds buffer limit {}. Give \"\n              \"up on the retry/shadow.\",\n              getLength(callbacks_->decodingBuffer()) + data.length(), retry_shadow_buffer_limit_);\n    cluster_->stats().retry_or_shadow_abandoned_.inc();\n    retry_state_.reset();\n    buffering = false;\n    active_shadow_policies_.clear();\n    request_buffer_overflowed_ = true;\n\n    // If we had to abandon buffering and there's no request in progress, abort the request and\n    // clean up. This happens if the initial upstream request failed, and we are currently waiting\n    // for a backoff timer before starting the next upstream attempt.\n    if (upstream_requests_.empty()) {\n      cleanup();\n      callbacks_->sendLocalReply(\n          Http::Code::InsufficientStorage, \"exceeded request buffer limit while retrying upstream\",\n          modify_headers_, absl::nullopt,\n          StreamInfo::ResponseCodeDetails::get().RequestPayloadExceededRetryBufferLimit);\n      return Http::FilterDataStatus::StopIterationNoBuffer;\n    }\n  }\n\n  // If we aren't buffering and there is no active request, an abort should have occurred\n  // already.\n  ASSERT(buffering || !upstream_requests_.empty());\n\n  if (buffering) {\n    // If we are going to buffer for retries or shadowing, we need to make a copy before encoding\n    // since it's all moves from here on.\n    if (!upstream_requests_.empty()) {\n      Buffer::OwnedImpl copy(data);\n      upstream_requests_.front()->encodeData(copy, end_stream);\n    }\n\n    // If we are potentially going to retry or shadow this request we need to buffer.\n    // This will not cause the connection manager to 413 because before we hit the\n    // buffer limit we give up on retries and buffering. We must buffer using addDecodedData()\n    // so that all buffered data is available by the time we do request complete processing and\n    // potentially shadow.\n    callbacks_->addDecodedData(data, true);\n  } else {\n    upstream_requests_.front()->encodeData(data, end_stream);\n  }\n\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterDataStatus::StopIterationNoBuffer;\n}\n\nHttp::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap& trailers) {\n  ENVOY_STREAM_LOG(debug, \"router decoding trailers:\\n{}\", *callbacks_, trailers);\n\n  // upstream_requests_.size() cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onRequestComplete(). It could be zero\n  // if the first request attempt has already failed and a retry is waiting for\n  // a backoff timer.\n  ASSERT(upstream_requests_.size() <= 1);\n  downstream_trailers_ = &trailers;\n  for (auto& upstream_request : upstream_requests_) {\n    upstream_request->encodeTrailers(trailers);\n  }\n  onRequestComplete();\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Filter::decodeMetadata(Http::MetadataMap& metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  if (!upstream_requests_.empty()) {\n    // TODO(soya3129): Save metadata for retry, redirect and shadowing case.\n    upstream_requests_.front()->encodeMetadata(std::move(metadata_map_ptr));\n  }\n  return Http::FilterMetadataStatus::Continue;\n}\n\nvoid Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n  callbacks_ = &callbacks;\n  // As the decoder filter only pushes back via watermarks once data has reached\n  // it, it can latch the current buffer limit and does not need to update the\n  // limit if another filter increases it.\n  //\n  // The default is \"do not limit\". If there are configured (non-zero) buffer\n  // limits, apply them here.\n  if (callbacks_->decoderBufferLimit() != 0) {\n    retry_shadow_buffer_limit_ = callbacks_->decoderBufferLimit();\n  }\n}\n\nvoid Filter::cleanup() {\n  // All callers of cleanup() should have cleaned out the upstream_requests_\n  // list as appropriate.\n  ASSERT(upstream_requests_.empty());\n\n  retry_state_.reset();\n  if (response_timeout_) {\n    response_timeout_->disableTimer();\n    response_timeout_.reset();\n  }\n}\n\nvoid Filter::maybeDoShadowing() {\n  for (const auto& shadow_policy_wrapper : active_shadow_policies_) {\n    const auto& shadow_policy = shadow_policy_wrapper.get();\n\n    ASSERT(!shadow_policy.cluster().empty());\n    Http::RequestMessagePtr request(new Http::RequestMessageImpl(\n        Http::createHeaderMap<Http::RequestHeaderMapImpl>(*downstream_headers_)));\n    if (callbacks_->decodingBuffer()) {\n      request->body().add(*callbacks_->decodingBuffer());\n    }\n    if (downstream_trailers_) {\n      request->trailers(Http::createHeaderMap<Http::RequestTrailerMapImpl>(*downstream_trailers_));\n    }\n\n    auto options = Http::AsyncClient::RequestOptions()\n                       .setTimeout(timeout_.global_timeout_)\n                       .setParentSpan(callbacks_->activeSpan())\n                       .setChildSpanName(\"mirror\")\n                       .setSampled(shadow_policy.traceSampled());\n    config_.shadowWriter().shadow(shadow_policy.cluster(), std::move(request), options);\n  }\n}\n\nvoid Filter::onRequestComplete() {\n  // This should be called exactly once, when the downstream request has been received in full.\n  ASSERT(!downstream_end_stream_);\n  downstream_end_stream_ = true;\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  downstream_request_complete_time_ = dispatcher.timeSource().monotonicTime();\n\n  // Possible that we got an immediate reset.\n  if (!upstream_requests_.empty()) {\n    // Even if we got an immediate reset, we could still shadow, but that is a riskier change and\n    // seems unnecessary right now.\n    maybeDoShadowing();\n\n    if (timeout_.global_timeout_.count() > 0) {\n      response_timeout_ = dispatcher.createTimer([this]() -> void { onResponseTimeout(); });\n      response_timeout_->enableTimer(timeout_.global_timeout_);\n    }\n\n    for (auto& upstream_request : upstream_requests_) {\n      if (upstream_request->createPerTryTimeoutOnRequestComplete()) {\n        upstream_request->setupPerTryTimeout();\n      }\n    }\n  }\n}\n\nvoid Filter::onDestroy() {\n  // Reset any in-flight upstream requests.\n  resetAll();\n  cleanup();\n}\n\nvoid Filter::onResponseTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream timeout\", *callbacks_);\n\n  // Reset any upstream requests that are still in flight.\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n\n    // Don't do work for upstream requests we've already seen headers for.\n    if (upstream_request->awaitingHeaders()) {\n      cluster_->stats().upstream_rq_timeout_.inc();\n      if (request_vcluster_) {\n        request_vcluster_->stats().upstream_rq_timeout_.inc();\n      }\n\n      if (cluster_->timeoutBudgetStats().has_value()) {\n        // Cancel firing per-try timeout information, because the per-try timeout did not come into\n        // play when the global timeout was hit.\n        upstream_request->recordTimeoutBudget(false);\n      }\n\n      if (upstream_request->upstreamHost()) {\n        upstream_request->upstreamHost()->stats().rq_timeout_.inc();\n      }\n\n      // If this upstream request already hit a \"soft\" timeout, then it\n      // already recorded a timeout into outlier detection. Don't do it again.\n      if (!upstream_request->outlierDetectionTimeoutRecorded()) {\n        updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, *upstream_request,\n                               absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n      }\n\n      chargeUpstreamAbort(timeout_response_code_, false, *upstream_request);\n    }\n    upstream_request->resetStream();\n  }\n\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamTimeout);\n}\n\n// Called when the per try timeout is hit but we didn't reset the request\n// (hedge_on_per_try_timeout enabled).\nvoid Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          // Without any knowledge about what's going on in the connection pool, retry the request\n          // with the safest settings which is no early data but keep using or not using alt-svc as\n          // before. In this way, QUIC won't be falsely marked as broken.\n          doRetry(/*can_send_early_data*/ false, can_use_http3);\n        });\n\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried(true);\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}\n\nvoid Filter::onPerTryIdleTimeout(UpstreamRequest& upstream_request) {\n  onPerTryTimeoutCommon(upstream_request, cluster_->stats().upstream_rq_per_try_idle_timeout_,\n                        StreamInfo::ResponseCodeDetails::get().UpstreamPerTryIdleTimeout);\n}\n\nvoid Filter::onPerTryTimeout(UpstreamRequest& upstream_request) {\n  onPerTryTimeoutCommon(upstream_request, cluster_->stats().upstream_rq_per_try_timeout_,\n                        StreamInfo::ResponseCodeDetails::get().UpstreamPerTryTimeout);\n}\n\nvoid Filter::onPerTryTimeoutCommon(UpstreamRequest& upstream_request, Stats::Counter& error_counter,\n                                   const std::string& response_code_details) {\n  if (hedging_params_.hedge_on_per_try_timeout_) {\n    onSoftPerTryTimeout(upstream_request);\n    return;\n  }\n\n  error_counter.inc();\n  if (upstream_request.upstreamHost()) {\n    upstream_request.upstreamHost()->stats().rq_timeout_.inc();\n  }\n\n  upstream_request.resetStream();\n\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  chargeUpstreamAbort(timeout_response_code_, false, upstream_request);\n\n  // Remove this upstream request from the list now that we're done with it.\n  upstream_request.removeFromList(upstream_requests_);\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout, response_code_details);\n}\n\nvoid Filter::onStreamMaxDurationReached(UpstreamRequest& upstream_request) {\n  upstream_request.resetStream();\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n\n  callbacks_->streamInfo().setResponseFlag(\n      StreamInfo::ResponseFlag::UpstreamMaxStreamDurationReached);\n  // sendLocalReply may instead reset the stream if downstream_response_started_ is true.\n  callbacks_->sendLocalReply(\n      Http::Code::RequestTimeout, \"upstream max stream duration reached\", modify_headers_,\n      absl::nullopt, StreamInfo::ResponseCodeDetails::get().UpstreamMaxStreamDurationReached);\n}\n\nvoid Filter::updateOutlierDetection(Upstream::Outlier::Result result,\n                                    UpstreamRequest& upstream_request,\n                                    absl::optional<uint64_t> code) {\n  if (upstream_request.upstreamHost()) {\n    upstream_request.upstreamHost()->outlierDetector().putResult(result, code);\n  }\n}\n\nvoid Filter::chargeUpstreamAbort(Http::Code code, bool dropped, UpstreamRequest& upstream_request) {\n  if (downstream_response_started_) {\n    if (upstream_request.grpcRqSuccessDeferred()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n      config_.stats_.rq_reset_after_downstream_response_started_.inc();\n    }\n  } else {\n    Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstreamHost();\n\n    chargeUpstreamCode(code, upstream_host, dropped);\n    // If we had non-5xx but still have been reset by backend or timeout before\n    // starting response, we treat this as an error. We only get non-5xx when\n    // timeout_response_code_ is used for code above, where this member can\n    // assume values such as 204 (NoContent).\n    if (upstream_host != nullptr && !Http::CodeUtility::is5xx(enumToInt(code))) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::onUpstreamTimeoutAbort(StreamInfo::ResponseFlag response_flags,\n                                    absl::string_view details) {\n  Upstream::ClusterTimeoutBudgetStatsOptRef tb_stats = cluster()->timeoutBudgetStats();\n  if (tb_stats.has_value()) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n        dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n    tb_stats->get().upstream_rq_timeout_budget_percent_used_.recordValue(\n        FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));\n  }\n\n  const absl::string_view body =\n      timeout_response_code_ == Http::Code::GatewayTimeout ? \"upstream request timeout\" : \"\";\n  onUpstreamAbort(timeout_response_code_, response_flags, body, false, details);\n}\n\nvoid Filter::onUpstreamAbort(Http::Code code, StreamInfo::ResponseFlag response_flags,\n                             absl::string_view body, bool dropped, absl::string_view details) {\n  // If we have not yet sent anything downstream, send a response with an appropriate status code.\n  // Otherwise just reset the ongoing response.\n  callbacks_->streamInfo().setResponseFlag(response_flags);\n  // This will destroy any created retry timers.\n  cleanup();\n  // sendLocalReply may instead reset the stream if downstream_response_started_ is true.\n  callbacks_->sendLocalReply(\n      code, body,\n      [dropped, this](Http::ResponseHeaderMap& headers) {\n        if (dropped && !config_.suppress_envoy_headers_) {\n          headers.addReference(Http::Headers::get().EnvoyOverloaded,\n                               Http::Headers::get().EnvoyOverloadedValues.True);\n        }\n        modify_headers_(headers);\n      },\n      absl::nullopt, details);\n}\n\nbool Filter::maybeRetryReset(Http::StreamResetReason reset_reason,\n                             UpstreamRequest& upstream_request) {\n  // We don't retry if we already started the response, don't have a retry policy defined,\n  // or if we've already retried this upstream request (currently only possible if a per\n  // try timeout occurred and hedge_on_per_try_timeout is enabled).\n  if (downstream_response_started_ || !retry_state_ || upstream_request.retried()) {\n    return false;\n  }\n  RetryState::Http3Used was_using_http3 = RetryState::Http3Used::Unknown;\n  if (conn_pool_new_stream_with_early_data_and_http3_ && upstream_request.hadUpstream()) {\n    was_using_http3 = (upstream_request.streamInfo().protocol().has_value() &&\n                       upstream_request.streamInfo().protocol().value() == Http::Protocol::Http3)\n                          ? RetryState::Http3Used::Yes\n                          : RetryState::Http3Used::No;\n  }\n  const RetryStatus retry_status = retry_state_->shouldRetryReset(\n      reset_reason, was_using_http3,\n      [this, can_send_early_data = upstream_request.upstreamStreamOptions().can_send_early_data_,\n       can_use_http3 =\n           upstream_request.upstreamStreamOptions().can_use_http3_](bool disable_http3) -> void {\n        // This retry might be because of ConnectionFailure of 0-RTT handshake. In this case, though\n        // the original request is retried with the same can_send_early_data setting, it will not be\n        // sent as early data by the underlying connection pool grid.\n        doRetry(can_send_early_data, disable_http3 ? false : can_use_http3);\n      });\n  if (retry_status == RetryStatus::Yes) {\n    runRetryOptionsPredicates(upstream_request);\n    pending_retries_++;\n\n    if (upstream_request.upstreamHost()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n\n    auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n    return true;\n  } else if (retry_status == RetryStatus::NoOverflow) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n  } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n  }\n\n  return false;\n}\n\nvoid Filter::onUpstreamReset(Http::StreamResetReason reset_reason,\n                             absl::string_view transport_failure_reason,\n                             UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"upstream reset: reset reason: {}, transport failure reason: {}\",\n                   *callbacks_, Http::Utility::resetReasonToString(reset_reason),\n                   transport_failure_reason);\n\n  // TODO: The reset may also come from upstream over the wire. In this case it should be\n  // treated as external origin error and distinguished from local origin error.\n  // This matters only when running OutlierDetection with split_external_local_origin_errors\n  // config param set to true.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginConnectFailed, upstream_request,\n                         absl::nullopt);\n\n  if (maybeRetryReset(reset_reason, upstream_request)) {\n    return;\n  }\n\n  const bool dropped = reset_reason == Http::StreamResetReason::Overflow;\n  const Http::Code error_code = (reset_reason == Http::StreamResetReason::ProtocolError)\n                                    ? Http::Code::BadGateway\n                                    : Http::Code::ServiceUnavailable;\n  chargeUpstreamAbort(error_code, dropped, upstream_request);\n  auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n    request_ptr->cleanUp();\n    callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n  }\n\n  // If there are other in-flight requests that might see an upstream response,\n  // don't return anything downstream.\n  if (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0) {\n    return;\n  }\n\n  const StreamInfo::ResponseFlag response_flags = streamResetReasonToResponseFlag(reset_reason);\n\n  const std::string body =\n      absl::StrCat(\"upstream connect error or disconnect/reset before headers. \",\n                   (is_retry_ ? \"retried and the latest \" : \"\"),\n                   \"reset reason: \", Http::Utility::resetReasonToString(reset_reason),\n                   !transport_failure_reason.empty() ? \", transport failure reason: \" : \"\",\n                   transport_failure_reason);\n  const std::string& basic_details =\n      downstream_response_started_ ? StreamInfo::ResponseCodeDetails::get().LateUpstreamReset\n                                   : StreamInfo::ResponseCodeDetails::get().EarlyUpstreamReset;\n  const std::string details = StringUtil::replaceAllEmptySpace(absl::StrCat(\n      basic_details, \"{\", Http::Utility::resetReasonToString(reset_reason),\n      transport_failure_reason.empty() ? \"\" : absl::StrCat(\",\", transport_failure_reason), \"}\"));\n  onUpstreamAbort(error_code, response_flags, body, dropped, details);\n}\n\nvoid Filter::onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {\n  if (retry_state_ && host) {\n    retry_state_->onHostAttempted(host);\n  }\n}\n\nStreamInfo::ResponseFlag\nFilter::streamResetReasonToResponseFlag(Http::StreamResetReason reset_reason) {\n  switch (reset_reason) {\n  case Http::StreamResetReason::ConnectionFailure:\n    return StreamInfo::ResponseFlag::UpstreamConnectionFailure;\n  case Http::StreamResetReason::ConnectionTermination:\n    return StreamInfo::ResponseFlag::UpstreamConnectionTermination;\n  case Http::StreamResetReason::LocalReset:\n  case Http::StreamResetReason::LocalRefusedStreamReset:\n    return StreamInfo::ResponseFlag::LocalReset;\n  case Http::StreamResetReason::Overflow:\n    return StreamInfo::ResponseFlag::UpstreamOverflow;\n  case Http::StreamResetReason::RemoteReset:\n  case Http::StreamResetReason::RemoteRefusedStreamReset:\n  case Http::StreamResetReason::ConnectError:\n    return StreamInfo::ResponseFlag::UpstreamRemoteReset;\n  case Http::StreamResetReason::ProtocolError:\n    return StreamInfo::ResponseFlag::UpstreamProtocolError;\n  case Http::StreamResetReason::OverloadManager:\n    return StreamInfo::ResponseFlag::OverloadManager;\n  }\n\n  PANIC_DUE_TO_CORRUPT_ENUM;\n}\n\nvoid Filter::handleNon5xxResponseHeaders(absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                         UpstreamRequest& upstream_request, bool end_stream,\n                                         uint64_t grpc_to_http_status) {\n  // We need to defer gRPC success until after we have processed grpc-status in\n  // the trailers.\n  if (grpc_request_) {\n    if (end_stream) {\n      if (grpc_status && !Http::CodeUtility::is5xx(grpc_to_http_status)) {\n        upstream_request.upstreamHost()->stats().rq_success_.inc();\n      } else {\n        upstream_request.upstreamHost()->stats().rq_error_.inc();\n      }\n    } else {\n      upstream_request.grpcRqSuccessDeferred(true);\n    }\n  } else {\n    upstream_request.upstreamHost()->stats().rq_success_.inc();\n  }\n}\n\nvoid Filter::onUpstream1xxHeaders(Http::ResponseHeaderMapPtr&& headers,\n                                  UpstreamRequest& upstream_request) {\n  const uint64_t response_code = Http::Utility::getResponseStatus(*headers);\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);\n  ENVOY_STREAM_LOG(debug, \"upstream 1xx ({}).\", *callbacks_, response_code);\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n\n  // Don't send retries after 100-Continue has been sent on. Arguably we could attempt to do a\n  // retry, assume the next upstream would also send an 100-Continue and swallow the second one\n  // but it's sketchy (as the subsequent upstream might not send a 100-Continue) and not worth\n  // the complexity until someone asks for it.\n  retry_state_.reset();\n\n  // We coalesce 1xx headers here, to prevent encoder filters and HCM from having to worry\n  // about this. This is done in the router filter, rather than UpstreamRequest, since we want to\n  // potentially coalesce across retries and multiple upstream requests in the future, even though\n  // we currently don't support retry after 1xx.\n  // It's plausible that this functionality might need to move to HCM in the future for internal\n  // redirects, but we would need to maintain the \"only call encode1xxHeaders() once\"\n  // invariant.\n  if (!downstream_1xx_headers_encoded_) {\n    downstream_1xx_headers_encoded_ = true;\n    callbacks_->encode1xxHeaders(std::move(headers));\n  }\n}\n\nvoid Filter::resetAll() {\n  while (!upstream_requests_.empty()) {\n    auto request_ptr = upstream_requests_.back()->removeFromList(upstream_requests_);\n    request_ptr->resetStream();\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n  }\n}\n\nvoid Filter::resetOtherUpstreams(UpstreamRequest& upstream_request) {\n  // Pop each upstream request on the list and reset it if it's not the one\n  // provided. At the end we'll move it back into the list.\n  UpstreamRequestPtr final_upstream_request;\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request_tmp =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n    if (upstream_request_tmp.get() != &upstream_request) {\n      upstream_request_tmp->resetStream();\n      // TODO: per-host stat for hedge abandoned.\n      // TODO: cluster stat for hedge abandoned.\n    } else {\n      final_upstream_request = std::move(upstream_request_tmp);\n    }\n  }\n\n  ASSERT(final_upstream_request);\n  // Now put the final request back on this list.\n  LinkedList::moveIntoList(std::move(final_upstream_request), upstream_requests_);\n}\n\nvoid Filter::onUpstreamHeaders(uint64_t response_code, Http::ResponseHeaderMapPtr&& headers,\n                               UpstreamRequest& upstream_request, bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"upstream headers complete: end_stream={}\", *callbacks_, end_stream);\n\n  modify_headers_(*headers);\n  // When grpc-status appears in response headers, convert grpc-status to HTTP status code\n  // for outlier detection. This does not currently change any stats or logging and does not\n  // handle the case when an error grpc-status is sent as a trailer.\n  absl::optional<Grpc::Status::GrpcStatus> grpc_status;\n  uint64_t grpc_to_http_status = 0;\n  if (grpc_request_) {\n    grpc_status = Grpc::Common::getGrpcStatus(*headers);\n    if (grpc_status.has_value()) {\n      grpc_to_http_status = Grpc::Utility::grpcToHttpStatus(grpc_status.value());\n    }\n  }\n\n  if (grpc_status.has_value()) {\n    upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(grpc_to_http_status);\n  } else {\n    upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(response_code);\n  }\n\n  if (headers->EnvoyImmediateHealthCheckFail() != nullptr) {\n    upstream_request.upstreamHost()->healthChecker().setUnhealthy(\n        Upstream::HealthCheckHostMonitor::UnhealthyType::ImmediateHealthCheckFail);\n  }\n\n  bool could_not_retry = false;\n\n  // Check if this upstream request was already retried, for instance after\n  // hitting a per try timeout. Don't retry it if we already have.\n  if (retry_state_) {\n    if (upstream_request.retried()) {\n      // We already retried this request (presumably for a per try timeout) so\n      // we definitely won't retry it again. Check if we would have retried it\n      // if we could.\n      bool retry_as_early_data; // Not going to be used as we are not retrying.\n      could_not_retry = retry_state_->wouldRetryFromHeaders(*headers, *downstream_headers_,\n                                                            retry_as_early_data) !=\n                        RetryState::RetryDecision::NoRetry;\n    } else {\n      const RetryStatus retry_status = retry_state_->shouldRetryHeaders(\n          *headers, *downstream_headers_,\n          [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_,\n           had_early_data = upstream_request.upstreamStreamOptions().can_send_early_data_](\n              bool disable_early_data) -> void {\n            doRetry((disable_early_data ? false : had_early_data), can_use_http3);\n          });\n      if (retry_status == RetryStatus::Yes) {\n        runRetryOptionsPredicates(upstream_request);\n        pending_retries_++;\n        upstream_request.upstreamHost()->stats().rq_error_.inc();\n        Http::CodeStats& code_stats = httpContext().codeStats();\n        code_stats.chargeBasicResponseStat(\n            cluster_->statsScope(), config_.stats_.stat_names_.retry_,\n            static_cast<Http::Code>(response_code), exclude_http_code_stats_);\n\n        if (!end_stream || !upstream_request.encodeComplete()) {\n          upstream_request.resetStream();\n        }\n        auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n        if (Runtime::runtimeFeatureEnabled(\n                \"envoy.reloadable_features.allow_upstream_inline_write\")) {\n          request_ptr->cleanUp();\n          callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n        }\n        return;\n      } else if (retry_status == RetryStatus::NoOverflow) {\n        callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n        could_not_retry = true;\n      } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n        could_not_retry = true;\n      }\n    }\n  }\n\n  if (route_entry_->internalRedirectPolicy().enabled() &&\n      route_entry_->internalRedirectPolicy().shouldRedirectForResponseCode(\n          static_cast<Http::Code>(response_code)) &&\n      setupRedirect(*headers)) {\n    return;\n    // If the redirect could not be handled, fail open and let it pass to the\n    // next downstream.\n  }\n\n  // Check if we got a \"bad\" response, but there are still upstream requests in\n  // flight awaiting headers or scheduled retries. If so, exit to give them a\n  // chance to return before returning a response downstream.\n  if (could_not_retry && (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0)) {\n    upstream_request.upstreamHost()->stats().rq_error_.inc();\n\n    // Reset the stream because there are other in-flight requests that we'll\n    // wait around for and we're not interested in consuming any body/trailers.\n    auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n    request_ptr->resetStream();\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n    return;\n  }\n\n  // Make sure any retry timers are destroyed since we may not call cleanup() if end_stream is\n  // false.\n  if (retry_state_) {\n    retry_state_.reset();\n  }\n\n  // Only send upstream service time if we received the complete request and this is not a\n  // premature response.\n  if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    MonotonicTime response_received_time = dispatcher.timeSource().monotonicTime();\n    std::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n        response_received_time - downstream_request_complete_time_);\n    if (!config_.suppress_envoy_headers_) {\n      headers->setEnvoyUpstreamServiceTime(ms.count());\n    }\n  }\n\n  upstream_request.upstreamCanary(\n      (headers->EnvoyUpstreamCanary() && headers->EnvoyUpstreamCanary()->value() == \"true\") ||\n      upstream_request.upstreamHost()->canary());\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);\n  if (!Http::CodeUtility::is5xx(response_code)) {\n    handleNon5xxResponseHeaders(grpc_status, upstream_request, end_stream, grpc_to_http_status);\n  }\n\n  // Append routing cookies\n  for (const auto& header_value : downstream_set_cookies_) {\n    headers->addReferenceKey(Http::Headers::get().SetCookie, header_value);\n  }\n\n  // TODO(zuercher): If access to response_headers_to_add (at any level) is ever needed outside\n  // Router::Filter we'll need to find a better location for this work. One possibility is to\n  // provide finalizeResponseHeaders functions on the Router::Config and VirtualHost interfaces.\n  route_entry_->finalizeResponseHeaders(*headers, callbacks_->streamInfo());\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  // Make sure that for request hedging, we end up with the correct final upstream info.\n  callbacks_->streamInfo().setUpstreamInfo(final_upstream_request_->streamInfo().upstreamInfo());\n  resetOtherUpstreams(upstream_request);\n  if (end_stream) {\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeHeaders(std::move(headers), end_stream,\n                            StreamInfo::ResponseCodeDetails::get().ViaUpstream);\n}\n\nvoid Filter::onUpstreamData(Buffer::Instance& data, UpstreamRequest& upstream_request,\n                            bool end_stream) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamData) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n  if (end_stream) {\n    // gRPC request termination without trailers is an error.\n    if (upstream_request.grpcRqSuccessDeferred()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeData(data, end_stream);\n}\n\nvoid Filter::onUpstreamTrailers(Http::ResponseTrailerMapPtr&& trailers,\n                                UpstreamRequest& upstream_request) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamTrailers) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n\n  if (upstream_request.grpcRqSuccessDeferred()) {\n    absl::optional<Grpc::Status::GrpcStatus> grpc_status = Grpc::Common::getGrpcStatus(*trailers);\n    if (grpc_status &&\n        !Http::CodeUtility::is5xx(Grpc::Utility::grpcToHttpStatus(grpc_status.value()))) {\n      upstream_request.upstreamHost()->stats().rq_success_.inc();\n    } else {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n  }\n\n  onUpstreamComplete(upstream_request);\n\n  callbacks_->encodeTrailers(std::move(trailers));\n}\n\nvoid Filter::onUpstreamMetadata(Http::MetadataMapPtr&& metadata_map) {\n  callbacks_->encodeMetadata(std::move(metadata_map));\n}\n\nvoid Filter::onUpstreamComplete(UpstreamRequest& upstream_request) {\n  if (!downstream_end_stream_) {\n    upstream_request.resetStream();\n  }\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n      dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n  Upstream::ClusterTimeoutBudgetStatsOptRef tb_stats = cluster()->timeoutBudgetStats();\n  if (tb_stats.has_value()) {\n    tb_stats->get().upstream_rq_timeout_budget_percent_used_.recordValue(\n        FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));\n  }\n\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck() &&\n      DateUtil::timePointValid(downstream_request_complete_time_)) {\n    upstream_request.upstreamHost()->outlierDetector().putResponseTime(response_time);\n    const bool internal_request = Http::HeaderUtility::isEnvoyInternalRequest(*downstream_headers_);\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                             cluster_->statsScope(),\n                                             config_.empty_stat_name_,\n                                             response_time,\n                                             upstream_request.upstreamCanary(),\n                                             internal_request,\n                                             route_entry_->virtualHost().statName(),\n                                             request_vcluster_ ? request_vcluster_->statName()\n                                                               : config_.empty_stat_name_,\n                                             config_.zone_name_,\n                                             upstreamZone(upstream_request.upstreamHost())};\n\n    code_stats.chargeResponseTiming(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                               cluster_->statsScope(),\n                                               alt_stat_prefix_->statName(),\n                                               response_time,\n                                               upstream_request.upstreamCanary(),\n                                               internal_request,\n                                               config_.empty_stat_name_,\n                                               config_.empty_stat_name_,\n                                               config_.zone_name_,\n                                               upstreamZone(upstream_request.upstreamHost())};\n\n      code_stats.chargeResponseTiming(info);\n    }\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n}\n\nbool Filter::setupRedirect(const Http::ResponseHeaderMap& headers) {\n  ENVOY_STREAM_LOG(debug, \"attempting internal redirect\", *callbacks_);\n  const Http::HeaderEntry* location = headers.Location();\n\n  const uint64_t status_code = Http::Utility::getResponseStatus(headers);\n\n  // Redirects are not supported for streaming requests yet.\n  if (downstream_end_stream_ && (!request_buffer_overflowed_ || !callbacks_->decodingBuffer()) &&\n      location != nullptr &&\n      convertRequestHeadersForInternalRedirect(*downstream_headers_, *location, status_code) &&\n      callbacks_->recreateStream(&headers)) {\n    ENVOY_STREAM_LOG(debug, \"Internal redirect succeeded\", *callbacks_);\n    cluster_->stats().upstream_internal_redirect_succeeded_total_.inc();\n    return true;\n  }\n  // convertRequestHeadersForInternalRedirect logs failure reasons but log\n  // details for other failure modes here.\n  if (!downstream_end_stream_) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: request incomplete\", *callbacks_);\n  } else if (request_buffer_overflowed_) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: request body overflow\", *callbacks_);\n  } else if (location == nullptr) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: missing location header\", *callbacks_);\n  }\n\n  cluster_->stats().upstream_internal_redirect_failed_total_.inc();\n  return false;\n}\n\nbool Filter::convertRequestHeadersForInternalRedirect(Http::RequestHeaderMap& downstream_headers,\n                                                      const Http::HeaderEntry& internal_redirect,\n                                                      uint64_t status_code) {\n  if (!downstream_headers.Path()) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: no path in downstream_headers\", *callbacks_);\n    return false;\n  }\n\n  absl::string_view redirect_url = internal_redirect.value().getStringView();\n  // Make sure the redirect response contains a URL to redirect to.\n  if (redirect_url.empty()) {\n    config_.stats_.passthrough_internal_redirect_bad_location_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: empty location\", *callbacks_);\n    return false;\n  }\n  Http::Utility::Url absolute_url;\n  if (!absolute_url.initialize(redirect_url, false)) {\n    config_.stats_.passthrough_internal_redirect_bad_location_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: invalid location {}\", *callbacks_,\n                     redirect_url);\n    return false;\n  }\n\n  const auto& policy = route_entry_->internalRedirectPolicy();\n  // Don't change the scheme from the original request\n  const bool scheme_is_http = schemeIsHttp(downstream_headers, *callbacks_->connection());\n  const bool target_is_http = absolute_url.scheme() == Http::Headers::get().SchemeValues.Http;\n  if (!policy.isCrossSchemeRedirectAllowed() && scheme_is_http != target_is_http) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: incorrect scheme for {}\", *callbacks_,\n                     redirect_url);\n    config_.stats_.passthrough_internal_redirect_unsafe_scheme_.inc();\n    return false;\n  }\n\n  const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();\n  // Make sure that performing the redirect won't result in exceeding the configured number of\n  // redirects allowed for this route.\n  StreamInfo::UInt32Accessor* num_internal_redirect{};\n\n  if (num_internal_redirect = filter_state->getDataMutable<StreamInfo::UInt32Accessor>(\n          NumInternalRedirectsFilterStateName);\n      num_internal_redirect == nullptr) {\n    auto state = std::make_shared<StreamInfo::UInt32AccessorImpl>(0);\n    num_internal_redirect = state.get();\n\n    filter_state->setData(NumInternalRedirectsFilterStateName, std::move(state),\n                          StreamInfo::FilterState::StateType::Mutable,\n                          StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (num_internal_redirect->value() >= policy.maxInternalRedirects()) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: redirect limits exceeded.\", *callbacks_);\n    config_.stats_.passthrough_internal_redirect_too_many_redirects_.inc();\n    return false;\n  }\n  // Copy the old values, so they can be restored if the redirect fails.\n  const std::string original_host(downstream_headers.getHostValue());\n  const std::string original_path(downstream_headers.getPathValue());\n  const bool scheme_is_set = (downstream_headers.Scheme() != nullptr);\n  Cleanup restore_original_headers(\n      [&downstream_headers, original_host, original_path, scheme_is_set, scheme_is_http]() {\n        downstream_headers.setHost(original_host);\n        downstream_headers.setPath(original_path);\n        if (scheme_is_set) {\n          downstream_headers.setScheme(scheme_is_http ? Http::Headers::get().SchemeValues.Http\n                                                      : Http::Headers::get().SchemeValues.Https);\n        }\n      });\n\n  // Replace the original host, scheme and path.\n  downstream_headers.setScheme(absolute_url.scheme());\n  downstream_headers.setHost(absolute_url.hostAndPort());\n\n  auto path_and_query = absolute_url.pathAndQueryParams();\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.http_reject_path_with_fragment\")) {\n    // Envoy treats internal redirect as a new request and will reject it if URI path\n    // contains #fragment. However the Location header is allowed to have #fragment in URI path. To\n    // prevent Envoy from rejecting internal redirect, strip the #fragment from Location URI if it\n    // is present.\n    auto fragment_pos = path_and_query.find('#');\n    path_and_query = path_and_query.substr(0, fragment_pos);\n  }\n  downstream_headers.setPath(path_and_query);\n\n  callbacks_->clearRouteCache();\n  const auto route = callbacks_->route();\n  // Don't allow a redirect to a non existing route.\n  if (!route) {\n    config_.stats_.passthrough_internal_redirect_no_route_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: no route found\", *callbacks_);\n    return false;\n  }\n\n  const auto& route_name = route->routeEntry()->routeName();\n  for (const auto& predicate : policy.predicates()) {\n    if (!predicate->acceptTargetRoute(*filter_state, route_name, !scheme_is_http,\n                                      !target_is_http)) {\n      config_.stats_.passthrough_internal_redirect_predicate_.inc();\n      ENVOY_STREAM_LOG(trace,\n                       \"Internal redirect failed: rejecting redirect targeting {}, by {} predicate\",\n                       *callbacks_, route_name, predicate->name());\n      return false;\n    }\n  }\n\n  // See https://tools.ietf.org/html/rfc7231#section-6.4.4.\n  if (status_code == enumToInt(Http::Code::SeeOther) &&\n      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Get &&\n      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Head) {\n    downstream_headers.setMethod(Http::Headers::get().MethodValues.Get);\n    downstream_headers.remove(Http::Headers::get().ContentLength);\n    callbacks_->modifyDecodingBuffer([](Buffer::Instance& data) { data.drain(data.length()); });\n  }\n\n  num_internal_redirect->increment();\n  restore_original_headers.cancel();\n  // Preserve the original request URL for the second pass.\n  downstream_headers.setEnvoyOriginalUrl(absl::StrCat(scheme_is_http\n                                                          ? Http::Headers::get().SchemeValues.Http\n                                                          : Http::Headers::get().SchemeValues.Https,\n                                                      \"://\", original_host, original_path));\n  return true;\n}\n\nvoid Filter::runRetryOptionsPredicates(UpstreamRequest& retriable_request) {\n  for (const auto& options_predicate : route_entry_->retryPolicy().retryOptionsPredicates()) {\n    const Upstream::RetryOptionsPredicate::UpdateOptionsParameters parameters{\n        retriable_request.streamInfo(), upstreamSocketOptions()};\n    auto ret = options_predicate->updateOptions(parameters);\n    if (ret.new_upstream_socket_options_.has_value()) {\n      upstream_options_ = ret.new_upstream_socket_options_.value();\n    }\n  }\n}\n\nvoid Filter::doRetry(bool can_send_early_data, bool can_use_http3) {\n  ENVOY_STREAM_LOG(debug, \"performing retry\", *callbacks_);\n\n  is_retry_ = true;\n  attempt_count_++;\n  callbacks_->streamInfo().setAttemptCount(attempt_count_);\n  ASSERT(pending_retries_ > 0);\n  pending_retries_--;\n\n  // Clusters can technically get removed by CDS during a retry. Make sure it still exists.\n  const auto cluster = config_.cm_.getThreadLocalCluster(route_entry_->clusterName());\n  std::unique_ptr<GenericConnPool> generic_conn_pool;\n  if (cluster != nullptr) {\n    cluster_ = cluster->info();\n    generic_conn_pool = createConnPool(*cluster);\n  }\n\n  if (!generic_conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    cleanup();\n    return;\n  }\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(\n      *this, std::move(generic_conn_pool), can_send_early_data, can_use_http3);\n\n  if (include_attempt_count_in_request_) {\n    downstream_headers_->setEnvoyAttemptCount(attempt_count_);\n  }\n\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.update_expected_rq_timeout_on_retry\")) {\n    // If not enabled, then it will re-use the previous headers (if any.)\n\n    // The request timeouts only account for time elapsed since the downstream request completed\n    // which might not have happened yet (in which case zero time has elapsed.)\n    std::chrono::milliseconds elapsed_time = std::chrono::milliseconds::zero();\n\n    if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n      Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n      elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n          dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n    }\n\n    FilterUtility::setTimeoutHeaders(elapsed_time.count(), timeout_, *route_entry_,\n                                     *downstream_headers_, !config_.suppress_envoy_headers_,\n                                     grpc_request_, hedging_params_.hedge_on_per_try_timeout_);\n  }\n\n  UpstreamRequest* upstream_request_tmp = upstream_request.get();\n  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(!callbacks_->decodingBuffer() &&\n                                            !downstream_trailers_ && downstream_end_stream_);\n  // It's possible we got immediately reset which means the upstream request we just\n  // added to the front of the list might have been removed, so we need to check to make\n  // sure we don't encodeData on the wrong request.\n  if (!upstream_requests_.empty() && (upstream_requests_.front().get() == upstream_request_tmp)) {\n    if (callbacks_->decodingBuffer()) {\n      // If we are doing a retry we need to make a copy.\n      Buffer::OwnedImpl copy(*callbacks_->decodingBuffer());\n      upstream_requests_.front()->encodeData(copy, !downstream_trailers_ && downstream_end_stream_);\n    }\n\n    if (downstream_trailers_) {\n      upstream_requests_.front()->encodeTrailers(*downstream_trailers_);\n    }\n  }\n}\n\nuint32_t Filter::numRequestsAwaitingHeaders() {\n  return std::count_if(upstream_requests_.begin(), upstream_requests_.end(),\n                       [](const auto& req) -> bool { return req->awaitingHeaders(); });\n}\n\nRetryStatePtr ProdFilter::createRetryState(const RetryPolicy& policy,\n                                           Http::RequestHeaderMap& request_headers,\n                                           const Upstream::ClusterInfo& cluster,\n                                           const VirtualCluster* vcluster, Runtime::Loader& runtime,\n                                           Random::RandomGenerator& random,\n                                           Event::Dispatcher& dispatcher, TimeSource& time_source,\n                                           Upstream::ResourcePriority priority) {\n  std::unique_ptr<RetryStateImpl> retry_state =\n      RetryStateImpl::create(policy, request_headers, cluster, vcluster, runtime, random,\n                             dispatcher, time_source, priority);\n  if (retry_state != nullptr && retry_state->isAutomaticallyConfiguredForHttp3()) {\n    // Since doing retry will make Envoy to buffer the request body, if upstream using HTTP/3 is the\n    // only reason for doing retry, set the retry shadow buffer limit to 0 so that we don't retry or\n    // buffer safe requests with body which is not common.\n    setRetryShadownBufferLimit(0);\n  }\n  return retry_state;\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#include <chrono>\n#include <cstdint>\n#include <functional>\n#include <string>\n\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/upstreams/http/generic/v3/generic_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/http/http/v3/http_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/http/tcp/v3/tcp_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/tcp/generic/v3/generic_connection_pool.pb.h\"\n#include \"envoy/type/v3/percent.pb.h\"\n\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/config/metadata.h\"\n#include \"source/common/config/well_known_names.h\"\n#include \"source/common/http/context_impl.h\"\n#include \"source/common/network/application_protocol.h\"\n#include \"source/common/network/socket_option_factory.h\"\n#include \"source/common/network/upstream_server_name.h\"\n#include \"source/common/network/upstream_socket_options_filter_state.h\"\n#include \"source/common/network/upstream_subject_alt_names.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/common/network/win32_redirect_records_option_impl.h\"\n#include \"source/common/router/config_impl.h\"\n#include \"source/common/router/debug_config.h\"\n#include \"source/common/router/router.h\"\n#include \"source/common/stream_info/uint32_accessor_impl.h\"\n#include \"source/common/stream_info/utility.h\"\n#include \"source/common/tracing/http_tracer_impl.h\"\n#include \"source/common/upstream/upstream_impl.h\"\n\n#include \"test/common/http/common.h\"\n#include \"test/common/router/router_test_base.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/router/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/tracing/mocks.h\"\n#include \"test/mocks/upstream/cluster_manager.h\"\n#include \"test/mocks/upstream/host.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/simulated_time_system.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::AtLeast;\nusing testing::Eq;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::MockFunction;\nusing testing::NiceMock;\nusing testing::Property;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Router {\n\n// Allows verifying the state of the upstream StreamInfo\nclass TestAccessLog : public AccessLog::Instance {\npublic:\n  explicit TestAccessLog(std::function<void(const StreamInfo::StreamInfo&)> func) : func_(func) {}\n\n  void log(const Http::RequestHeaderMap*, const Http::ResponseHeaderMap*,\n           const Http::ResponseTrailerMap*, const StreamInfo::StreamInfo& info) override {\n    func_(info);\n  }\n\nprivate:\n  std::function<void(const StreamInfo::StreamInfo&)> func_;\n};\n\nclass RouterTest : public RouterTestBase {\npublic:\n  RouterTest() : RouterTestBase(false, false, false, Protobuf::RepeatedPtrField<std::string>{}) {\n    EXPECT_CALL(callbacks_, activeSpan()).WillRepeatedly(ReturnRef(span_));\n  };\n\n  void testRequestResponseSize(bool with_trailers) {\n    NiceMock<Http::MockRequestEncoder> encoder;\n    Http::ResponseDecoder* response_decoder = nullptr;\n\n    EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n        .WillOnce(\n            Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                       const Http::ConnectionPool::Instance::StreamOptions& options)\n                       -> Http::ConnectionPool::Cancellable* {\n              EXPECT_FALSE(options.can_send_early_data_);\n              EXPECT_TRUE(options.can_use_http3_);\n              response_decoder = &decoder;\n              callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                    upstream_stream_info_, Http::Protocol::Http10);\n              return nullptr;\n            }));\n\n    cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n        absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n    envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n    cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n        .mutable_typed_config()\n        ->PackFrom(generic_config);\n    callbacks_.route_->route_entry_.connect_config_ =\n        absl::make_optional<RouteEntry::ConnectConfig>();\n\n    EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _));\n\n    Http::TestRequestHeaderMapImpl headers;\n    HttpTestUtility::addDefaultHeaders(headers);\n    headers.setMethod(\"POST\");\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_headers_size\"), 74ull));\n    router_.decodeHeaders(headers, false);\n\n    EXPECT_CALL(callbacks_.dispatcher_, createTimer_);\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_body_size\"), 5ull));\n    Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n    EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,\n              router_.decodeData(*body_data, !with_trailers));\n\n    if (with_trailers) {\n      Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n      router_.decodeTrailers(trailers);\n    }\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_headers_size\"), 10ull));\n    Http::ResponseHeaderMapPtr response_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n    // NOLINTNEXTLINE: Silence null pointer access warning\n    response_decoder->decodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_body_size\"), 7ull));\n    Buffer::OwnedImpl response_data(\"goodbye\");\n    // NOLINTNEXTLINE: Silence null pointer access warning\n    response_decoder->decodeData(response_data, !with_trailers);\n\n    if (with_trailers) {\n      Http::ResponseTrailerMapPtr response_trailers(\n          new Http::TestResponseTrailerMapImpl{{\"some-trailer\", \"13\"}});\n      // NOLINTNEXTLINE: Silence null pointer access warning\n      response_decoder->decodeTrailers(std::move(response_trailers));\n    }\n\n    router_.onDestroy();\n  }\n\n  void testAutoSniOptions(\n      absl::optional<envoy::config::core::v3::UpstreamHttpProtocolOptions> dummy_option,\n      Envoy::Http::TestRequestHeaderMapImpl headers, std::string server_name = \"host\",\n      bool should_validate_san = false, std::string alt_server_name = \"host\") {\n    NiceMock<StreamInfo::MockStreamInfo> stream_info;\n    ON_CALL(*cm_.thread_local_cluster_.cluster_.info_, upstreamHttpProtocolOptions())\n        .WillByDefault(ReturnRef(dummy_option));\n    ON_CALL(callbacks_.stream_info_, filterState())\n        .WillByDefault(ReturnRef(stream_info.filterState()));\n    EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n        .WillOnce(Return(&cancellable_));\n    stream_info.filterState()->setData(Network::UpstreamServerName::key(),\n                                       std::make_unique<Network::UpstreamServerName>(\"dummy\"),\n                                       StreamInfo::FilterState::StateType::Mutable);\n    expectResponseTimerCreate();\n\n    HttpTestUtility::addDefaultHeaders(headers);\n    router_.decodeHeaders(headers, true);\n    EXPECT_EQ(server_name,\n              stream_info.filterState()\n                  ->getDataReadOnly<Network::UpstreamServerName>(Network::UpstreamServerName::key())\n                  ->value());\n    if (should_validate_san) {\n      EXPECT_EQ(alt_server_name, stream_info.filterState()\n                                     ->getDataReadOnly<Network::UpstreamSubjectAltNames>(\n                                         Network::UpstreamSubjectAltNames::key())\n                                     ->value()[0]);\n    }\n    EXPECT_CALL(cancellable_, cancel(_));\n    router_.onDestroy();\n    EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n    EXPECT_EQ(0U,\n              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n    EXPECT_EQ(0U,\n              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  }\n};\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithoutHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithHostHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\":authority\");\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"foo.bar\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, server_name);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithEmptyValueHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", \"\"}};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithoutHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithHostHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\":authority\");\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"foo.bar\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, server_name, true, server_name);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithEmptyValueHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", \"\"}};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithIpHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"127.0.0.1\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, \"dummy\", true, server_name);\n}\n\nTEST_F(RouterTest, RouteNotFound) {\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(callbacks_, route()).WillOnce(Return(nullptr));\n\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.no_route\").value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"route_not_found\");\n}\n\nTEST_F(RouterTest, MissingRequiredHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.removeMethod();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, _))\n      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {\n        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);\n      }));\n  EXPECT_CALL(\n      callbacks_,\n      sendLocalReply(Http::Code::ServiceUnavailable,\n                     testing::Eq(\"missing required header: :method\"), _, _,\n                     \"filter_removed_required_request_headers{missing_required_header:_:method}\"))\n      .WillOnce(testing::InvokeWithoutArgs([] {}));\n  router_.decodeHeaders(headers, true);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, ClusterNotFound) {\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  ON_CALL(cm_, getThreadLocalCluster(_)).WillByDefault(Return(nullptr));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.no_cluster\").value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"cluster_not_found\");\n}\n\nTEST_F(RouterTest, PoolFailureWithPriority) {\n  ON_CALL(callbacks_.route_->route_entry_, priority())\n      .WillByDefault(Return(Upstream::ResourcePriority::High));\n  EXPECT_CALL(cm_.thread_local_cluster_,\n              httpConnPool(Upstream::ResourcePriority::High, _, &router_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                \"tls version mismatch\", cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"139\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure, so upstream request was not initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(),\n            \"upstream_reset_before_response_started{connection_failure,tls_version_mismatch}\");\n}\n\nTEST_F(RouterTest, PoolFailureDueToConnectTimeout) {\n  ON_CALL(callbacks_.route_->route_entry_, priority())\n      .WillByDefault(Return(Upstream::ResourcePriority::High));\n  EXPECT_CALL(cm_.thread_local_cluster_,\n              httpConnPool(Upstream::ResourcePriority::High, _, &router_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::Timeout, \"connect_timeout\",\n                                cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"134\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure, so upstream request was not initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(),\n            \"upstream_reset_before_response_started{connection_failure,connect_timeout}\");\n}\n\nTEST_F(RouterTest, Http1Upstream) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, absl::optional<Http::Protocol>(), _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(callbacks_.route_->route_entry_, finalizeRequestHeaders(_, _, true));\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, Http2Upstream) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, absl::optional<Http::Protocol>(), _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashPolicy) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Return(absl::optional<uint64_t>(10)));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashPolicyNoHash) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Return(absl::optional<uint64_t>()));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, &router_))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_FALSE(context->computeHashKey());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashKeyNoHashPolicy) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy()).WillByDefault(Return(nullptr));\n  EXPECT_FALSE(router_.computeHashKey().has_value());\n}\n\nTEST_F(RouterTest, AddCookie) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  std::string cookie_value;\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        cookie_value = add_cookie(\"foo\", \"\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        EXPECT_EQ(\n            std::string{headers.get(Http::Headers::get().SetCookie)[0]->value().getStringView()},\n            \"foo=\\\"\" + cookie_value + \"\\\"; Max-Age=1337; HttpOnly\");\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_EQ(callbacks_.details(), \"via_upstream\");\n  // When the router filter gets reset we should cancel the pool request.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, AddCookieNoDuplicate) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        // this should be ignored\n        add_cookie(\"foo\", \"\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        EXPECT_EQ(\n            std::string{headers.get(Http::Headers::get().SetCookie)[0]->value().getStringView()},\n            \"foo=baz\");\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"set-cookie\", \"foo=baz\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  // When the router filter gets reset we should cancel the pool request.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, AddMultipleCookies) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  std::string choco_c, foo_c;\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        choco_c = add_cookie(\"choco\", \"\", std::chrono::seconds(15));\n        foo_c = add_cookie(\"foo\", \"/path\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        MockFunction<void(const std::string&)> cb;\n        EXPECT_CALL(cb, Call(\"foo=\\\"\" + foo_c + \"\\\"; Max-Age=1337; Path=/path; HttpOnly\"));\n        EXPECT_CALL(cb, Call(\"choco=\\\"\" + choco_c + \"\\\"; Max-Age=15; HttpOnly\"));\n\n        headers.iterate([&cb](const Http::HeaderEntry& header) -> Http::HeaderMap::Iterate {\n          if (header.key() == Http::Headers::get().SetCookie.get()) {\n            cb.Call(std::string(header.value().getStringView()));\n          }\n          return Http::HeaderMap::Iterate::Continue;\n        });\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, MetadataNoOp) { EXPECT_EQ(nullptr, router_.metadataMatchCriteria()); }\n\nTEST_F(RouterTest, MetadataMatchCriteria) {\n  ON_CALL(callbacks_.route_->route_entry_, metadataMatchCriteria())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.metadata_matches_criteria_));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(context->metadataMatchCriteria(),\n                  &callbacks_.route_->route_entry_.metadata_matches_criteria_);\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, MetadataMatchCriteriaFromRequest) {\n  verifyMetadataMatchCriteriaFromRequest(true);\n}\n\nTEST_F(RouterTest, MetadataMatchCriteriaFromRequestNoRouteEntryMatch) {\n  verifyMetadataMatchCriteriaFromRequest(false);\n}\n\nTEST_F(RouterTest, NoMetadataMatchCriteria) {\n  ON_CALL(callbacks_.route_->route_entry_, metadataMatchCriteria()).WillByDefault(Return(nullptr));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(context->metadataMatchCriteria(), nullptr);\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, CancelBeforeBoundToPool) {\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, NoHost) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _)).WillOnce(Return(absl::nullopt));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"19\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_maintenance_mode\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"no_healthy_upstream\");\n}\n\nTEST_F(RouterTest, MaintenanceMode) {\n  EXPECT_CALL(*cm_.thread_local_cluster_.cluster_.info_, maintenanceMode()).WillOnce(Return(true));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"},\n                                                   {\"content-length\", \"16\"},\n                                                   {\"content-type\", \"text/plain\"},\n                                                   {\"x-envoy-overloaded\", \"true\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_maintenance_mode\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->load_report_stats_store_\n                    .counter(\"upstream_rq_dropped\")\n                    .value());\n  EXPECT_EQ(callbacks_.details(), \"maintenance_mode\");\n}\n\nTEST_F(RouterTest, ResponseCodeDetailsSetByUpstream) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate that x-envoy-upstream-service-time is added on a regular\n// request/response path.\nTEST_F(RouterTest, EnvoyUpstreamServiceTime) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, true))\n      .WillOnce(Invoke([](Http::HeaderMap& headers, bool) {\n        EXPECT_FALSE(headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty());\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate that x-envoy-attempt-count is added to request headers when the option is true.\nTEST_F(RouterTest, EnvoyAttemptCountInRequest) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ true,\n      /* preset_count*/ absl::nullopt,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is overwritten by the router on request headers, if the\n// header is sent from the downstream and the option is set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestOverwritten) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ true,\n      /* preset_count*/ 123,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is not overwritten by the router on request headers, if the\n// header is sent from the downstream and the option is set to false.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestNotOverwritten) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ false,\n      /* preset_count*/ 123,\n      /* expected_count */ 123);\n}\n\nclass MockRetryOptionsPredicate : public Upstream::RetryOptionsPredicate {\npublic:\n  MOCK_METHOD(UpdateOptionsReturn, updateOptions, (const UpdateOptionsParameters& parameters),\n              (const));\n};\n\n// Also verify retry options predicates work.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestUpdatedInRetries) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\n// Validate that x-envoy-attempt-count is added when option is true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponse) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ true,\n      /* preset_count */ absl::nullopt,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is overwritten by the router on response headers, if the\n// header is sent from the upstream and the option is set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseOverwritten) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ true,\n      /* preset_count */ 123,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is not overwritten by the router on response headers, if the\n// header is sent from the upstream and the option is not set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseNotOverwritten) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ false,\n      /* preset_count */ 123,\n      /* expected_count */ 123);\n}\n\n// Validate that x-envoy-attempt-count is present in local replies after an upstream attempt is\n// made.\nTEST_F(RouterTest, EnvoyAttemptCountInResponsePresentWithLocalReply) {\n  setIncludeAttemptCountInResponse(true);\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                absl::string_view(), cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"},\n                                                   {\"content-length\", \"91\"},\n                                                   {\"content-type\", \"text/plain\"},\n                                                   {\"x-envoy-attempt-count\", \"1\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  // Pool failure, so upstream request was never initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_EQ(callbacks_.details(), \"upstream_reset_before_response_started{connection_failure}\");\n  EXPECT_EQ(1U, callbacks_.stream_info_.attemptCount().value());\n}\n\n// Validate that the x-envoy-attempt-count header in the downstream response reflects the number of\n// of upstream requests that occurred when retries take place.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseWithRetries) {\n  setIncludeAttemptCountInResponse(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(1U, callbacks_.stream_info_.attemptCount().value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(2U, callbacks_.stream_info_.attemptCount().value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, true))\n      .WillOnce(Invoke([](Http::ResponseHeaderMap& headers, bool) {\n        // Because a retry happened the number of attempts in the response headers should be 2.\n        EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Append cluster with default header name.\nTEST_F(RouterTest, AppendCluster0) { testAppendCluster(absl::nullopt); }\n\n// Append cluster with custom header name.\nTEST_F(RouterTest, AppendCluster1) {\n  testAppendCluster(absl::make_optional(Http::LowerCaseString(\"x-custom-cluster\")));\n}\n\n// Append hostname and address with default header names.\nTEST_F(RouterTest, AppendUpstreamHost00) { testAppendUpstreamHost(absl::nullopt, absl::nullopt); }\n\n// Append hostname and address with custom host address header name.\nTEST_F(RouterTest, AppendUpstreamHost01) {\n  testAppendUpstreamHost(\n      absl::nullopt, absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-host-address\")));\n}\n\n// Append hostname and address with custom hostname header name.\nTEST_F(RouterTest, AppendUpstreamHost10) {\n  testAppendUpstreamHost(absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-hostname\")),\n                         absl::nullopt);\n}\n\n// Append hostname and address with custom header names.\nTEST_F(RouterTest, AppendUpstreamHost11) {\n  testAppendUpstreamHost(\n      absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-hostname\")),\n      absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-host-address\")));\n}\n\n// Do not forward, with default not-forwarded header name\nTEST_F(RouterTest, DoNotForward0) { testDoNotForward(absl::nullopt); }\n\n// Do not forward, with custom not-forwarded header name\nTEST_F(RouterTest, DoNotForward1) {\n  testDoNotForward(absl::make_optional(Http::LowerCaseString(\"x-custom-not-forwarded\")));\n}\n\n// Validate that all DebugConfig options play nicely with each other.\nTEST_F(RouterTest, AllDebugConfig) {\n  auto debug_config = std::make_unique<DebugConfig>(\n      /* append_cluster */ true,\n      /* cluster_header */ absl::nullopt,\n      /* append_upstream_host */ true,\n      /* hostname_header */ absl::nullopt,\n      /* host_address_header */ absl::nullopt,\n      /* do_not_forward */ true,\n      /* not_forwarded_header */ absl::nullopt);\n  callbacks_.streamInfo().filterState()->setData(DebugConfig::key(), std::move(debug_config),\n                                                 StreamInfo::FilterState::StateType::ReadOnly,\n                                                 StreamInfo::FilterState::LifeSpan::FilterChain);\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"204\"},\n      {\"x-envoy-cluster\", \"fake_cluster\"},\n      {\"x-envoy-upstream-hostname\", \"scooby.doo\"},\n      {\"x-envoy-upstream-host-address\", \"10.0.0.5:9211\"},\n      {\"x-envoy-not-forwarded\", \"true\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, NoRetriesOverflow) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // RetryOverflow kicks in.\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoOverflow));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\nTEST_F(RouterTest, ResetDuringEncodeHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(callbacks_, removeDownstreamWatermarkCallbacks(_));\n  EXPECT_CALL(callbacks_, addDownstreamWatermarkCallbacks(_));\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  // First connection is successful and reset happens later on.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, UpstreamTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_timeout_.value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verify the timeout budget histograms are filled out correctly when using a\n// global and per-try timeout in a successful request.\nTEST_F(RouterTest, TimeoutBudgetHistogramStat) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 20ull));\n  // Per-try budget used.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  40ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly when using a\n// global and per-try timeout in a failed request.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatFailure) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 20ull));\n  // Per-try budget used.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  40ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly when only using a global timeout.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatOnlyGlobal) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 40ull));\n  // Per-try budget used is zero out of an infinite timeout.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"), 0ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly across retries.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatDuringRetries) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"100\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget used on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  100ull));\n  // Global timeout histogram does not fire on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), _))\n      .Times(0);\n\n  // Per-try timeout.\n  test_time_.advanceTimeWait(std::chrono::milliseconds(100));\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"504\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(504));\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget exhausted on the second try.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  100ull));\n  // Global timeout percentage used across both tries.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 50ull));\n\n  // Trigger second request failure.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder2.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  test_time_.advanceTimeWait(std::chrono::milliseconds(100));\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Verify the timeout budget histograms are filled out correctly when the global timeout occurs\n// during a retry.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatDuringGlobalTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"320\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget used on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  50ull));\n  // Global timeout histogram does not fire on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), _))\n      .Times(0);\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  test_time_.advanceTimeWait(std::chrono::milliseconds(160));\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout was hit, fires 100.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 100ull));\n  // Per-try budget used on the second request won't fire because the global timeout was hit.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"), _))\n      .Times(0);\n\n  // Trigger global timeout.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder2.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  test_time_.advanceTimeWait(std::chrono::milliseconds(240));\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Validate gRPC OK response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcOkTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"0\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC AlreadyExists response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcAlreadyExistsTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"6\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(409));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC Unavailable response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcOutlierDetectionUnavailableStatusCode) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"14\"}});\n  // Outlier detector will use the gRPC response status code.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC Internal response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcInternalTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"13\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC response stats are sane when response is ended in a DATA\n// frame.\nTEST_F(RouterTest, GrpcDataEndStream) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  Buffer::OwnedImpl data;\n  response_decoder->decodeData(data, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC response stats are sane when response is reset after initial\n// response HEADERS.\nTEST_F(RouterTest, GrpcReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.rq_reset_after_downstream_response_started\").value());\n}\n\n// Validate gRPC OK response stats are sane when response is not trailers only.\nTEST_F(RouterTest, GrpcOk) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.dispatcher_, pushTrackedObject(_));\n  EXPECT_CALL(callbacks_.dispatcher_, popTrackedObject(_));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  EXPECT_CALL(callbacks_.dispatcher_, pushTrackedObject(_));\n  EXPECT_CALL(callbacks_.dispatcher_, popTrackedObject(_));\n  Http::ResponseTrailerMapPtr response_trailers(\n      new Http::TestResponseTrailerMapImpl{{\"grpc-status\", \"0\"}});\n  response_decoder->decodeTrailers(std::move(response_trailers));\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC Internal response stats are sane when response is not trailers only.\nTEST_F(RouterTest, GrpcInternal) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  Http::ResponseTrailerMapPtr response_trailers(\n      new Http::TestResponseTrailerMapImpl{{\"grpc-status\", \"13\"}});\n  response_decoder->decodeTrailers(std::move(response_trailers));\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, UpstreamTimeoutWithAltResponse) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-alt-response\", \"204\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"204\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(204)));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verify the upstream per try idle timeout.\nTEST_F(RouterTest, UpstreamPerTryIdleTimeout) {\n  InSequence s;\n\n  callbacks_.route_->route_entry_.retry_policy_.per_try_idle_timeout_ =\n      std::chrono::milliseconds(3000);\n\n  // This pattern helps ensure that we're actually invoking the callback.\n  bool filter_state_verified = false;\n  router_.config().upstream_logs_.push_back(\n      std::make_shared<TestAccessLog>([&](const auto& stream_info) {\n        filter_state_verified =\n            stream_info.hasResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout);\n      }));\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_idle_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  EXPECT_CALL(*per_try_idle_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_, setResponseCodeDetails(\"upstream_per_try_idle_timeout\"));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  per_try_idle_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_idle_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_TRUE(filter_state_verified);\n}\n\n// Verify the upstream per try idle timeout gets reset in the success case.\nTEST_F(RouterTest, UpstreamPerTryIdleTimeoutSuccess) {\n  InSequence s;\n\n  callbacks_.route_->route_entry_.retry_policy_.per_try_idle_timeout_ =\n      std::chrono::milliseconds(3000);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_idle_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  response_decoder->decodeData(data, false);\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_CALL(*per_try_idle_timeout_, disableTimer());\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  response_decoder->decodeData(data, true);\n}\n\n// Verifies that the per try timeout is initialized once the downstream request has been read.\nTEST_F(RouterTest, UpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  // We verify that both timeouts are started after decodeData(_, true) is called. This\n  // verifies that we are not starting the initial per try timeout on the first onPoolReady.\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verifies that the per try timeout starts when onPoolReady is called when it occurs\n// after the downstream request has been read.\nTEST_F(RouterTest, UpstreamPerTryTimeoutDelayedPoolReady) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  // Global timeout starts when decodeData(_, true) is called.\n  expectResponseTimerCreate();\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Per try timeout starts when onPoolReady is called.\n  expectPerTryTimerCreate();\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Ensures that the per try callback is not set until the stream becomes available.\nTEST_F(RouterTest, UpstreamPerTryTimeoutExcludesNewStream) {\n  InSequence s;\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_timeout_, enableTimer(_, _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  EXPECT_CALL(*per_try_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Tests that a retry is sent after the first request hits the per try timeout, but then\n// headers received in response to the first request are still used (and the 2nd request\n// canceled). Also verify retry options predicates work.\nTEST_F(RouterTest, HedgedPerTryTimeoutFirstRequestSucceeds) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_));\n  per_try_timeout_->invokeCallback();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // We should not have updated any stats yet because no requests have been\n  // canceled\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::NoRetry));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Tests that an upstream request is reset even if it can't be retried as long as there is\n// another in-flight request we're waiting on.\n// Sequence:\n// 1) first upstream request per try timeout\n// 2) second upstream request sent\n// 3) second upstream request gets 5xx, retries exhausted, assert it's reset\n// 4) first upstream request gets 2xx\nTEST_F(RouterTest, HedgedPerTryTimeoutResetsOnBadHeaders) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // We should not have updated any stats yet because no requests have been\n  // canceled\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now write a 5xx back on the 2nd request with no retries remaining. The 2nd request\n  // should be reset immediately.\n  Http::ResponseHeaderMapPtr bad_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoOverflow));\n  // Not end_stream, otherwise we wouldn't need to reset.\n  ASSERT(response_decoder2);\n  response_decoder2->decodeHeaders(std::move(bad_response_headers), false);\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  response_decoder1->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Three requests sent: 1) 5xx error, 2) per try timeout, 3) gets good response\n// headers.\nTEST_F(RouterTest, HedgedPerTryTimeoutThirdRequestSucceeds) {\n  enableHedgeOnPerTryTimeout();\n\n  // Verify cluster request/response sizes are accounted for all requests/responses.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_headers_size\"), 73ull))\n      .Times(3);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_body_size\"), 0ull))\n      .Times(3);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_headers_size\"), 10ull))\n      .Times(2);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_body_size\"), 0ull))\n      .Times(2);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(111);\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n  expectPerTryTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  // Local origin connect success happens for first and third try.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHeadersRetry();\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(222);\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a per try timeout on the 2nd request, expect a 3rd\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  NiceMock<Http::MockRequestEncoder> encoder3;\n  Http::ResponseDecoder* response_decoder3 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder3 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(333);\n            callbacks.onPoolReady(encoder3, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  per_try_timeout_->invokeCallback();\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(3U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(encoder3.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder3->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  EXPECT_EQ(333U, callbacks_.stream_info_.upstreamInfo()->upstreamConnectionId());\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// First request times out and is retried, and then a response is received.\n// Make sure we don't attempt to retry because we already retried for timeout.\nTEST_F(RouterTest, RetryOnlyOnceForSameUpstreamRequest) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n\n  // Now send a 5xx back and make sure we don't ask whether we should retry it.\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::RetryWithBackoff));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n\n  response_timeout_->invokeCallback();\n}\n\n// Sequence: upstream request hits soft per try timeout and is retried, and\n// then \"bad\" response headers come back before the retry has been scheduled.\n// Ensures that the \"bad\" headers are not sent downstream because there is\n// still an attempt pending.\nTEST_F(RouterTest, BadHeadersDroppedIfPreviousRetryScheduled) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  expectPerTryTimerCreate();\n\n  // Now send a 5xx back and make sure we don't ask whether we should retry it\n  // and also that we don't respond downstream with it.\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::RetryWithBackoff));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  // Now trigger the retry for the per try timeout earlier.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  router_.retry_state_->callback_();\n\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder2->decodeHeaders(std::move(response_headers2), true);\n}\n\n// Test retrying a request, when the first attempt fails before the client\n// has sent any of the body. Also verify retry options predicates work.\nTEST_F(RouterTest, RetryRequestBeforeBody) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body(\"body\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body), true));\n  Buffer::OwnedImpl buf(body);\n  router_.decodeData(buf, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body.\nTEST_F(RouterTest, RetryRequestDuringBody) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body2(\"body2\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body2), true));\n  Buffer::OwnedImpl buf2(body2);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf2, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with more data arriving in between upstream attempts\n// (which would normally happen during the backoff timer interval), but not end_stream.\nTEST_F(RouterTest, RetryRequestDuringBodyDataBetweenAttemptsNotEndStream) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(3).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  const std::string body2(\"body2\");\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, false);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1 + body2), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body3(\"body3\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body3), true));\n  Buffer::OwnedImpl buf3(body3);\n  router_.decodeData(buf3, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the rest of the request arriving in between upstream\n// request attempts.\nTEST_F(RouterTest, RetryRequestDuringBodyCompleteBetweenAttempts) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(2).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  const std::string body2(\"body2\");\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, true);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1 + body2), true));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the trailers arriving in between upstream\n// request attempts.\nTEST_F(RouterTest, RetryRequestDuringBodyTrailerBetweenAttempts) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1), false));\n  EXPECT_CALL(encoder2, encodeTrailers(HeaderMapEqualRef(&trailers)));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the rest of the request arriving in between upstream\n// request attempts, but exceeding the buffer limit causing a downstream request abort.\nTEST_F(RouterTest, RetryRequestDuringBodyBufferLimitExceeded) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n  EXPECT_CALL(callbacks_.route_->route_entry_, retryShadowBufferLimit()).WillOnce(Return(10));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(2).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  const std::string body2(50, 'a');\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, false);\n\n  EXPECT_EQ(callbacks_.details(), \"request_payload_exceeded_retry_buffer_limit\");\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"retry_or_shadow_abandoned\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Two requests are sent (slow request + hedged retry) and then global timeout\n// is hit. Verify everything gets cleaned up.\nTEST_F(RouterTest, HedgedPerTryTimeoutGlobalTimeout) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger global timeout, expect everything to be reset\n  EXPECT_CALL(encoder1.stream_, resetStream(_));\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"504\");\n      }));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n  EXPECT_EQ(2, cm_.thread_local_cluster_.conn_pool_.host_->stats_.rq_timeout_.value());\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Sequence: 1) per try timeout w/ hedge retry, 2) second request gets a 5xx\n// response, no retries remaining 3) first request gets a 5xx response.\nTEST_F(RouterTest, HedgingRetriesExhaustedBadResponse) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger a 503 in response to the second request.\n  Http::ResponseHeaderMapPtr bad_response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoRetryLimitExceeded));\n  ASSERT(response_decoder2);\n  response_decoder2->decodeHeaders(std::move(bad_response_headers1), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a 503 in response to the first request.\n  Http::ResponseHeaderMapPtr bad_response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n\n  // We should not call shouldRetryHeaders() because you never retry the same\n  // request twice.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"503\");\n      }));\n  response_decoder1->decodeHeaders(std::move(bad_response_headers2), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Sequence: 1) per try timeout w/ hedge retry, 2) first request gets reset by upstream,\n// 3) 2nd request gets a 200 which should be sent downstream.\nTEST_F(RouterTest, HedgingRetriesProceedAfterReset) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n\n  // First is reset\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger an upstream reset in response to the first request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We should not call shouldRetryReset() because you never retry the same\n  // request twice.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n\n  // Now trigger a 200 in response to the second request.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder2->decodeHeaders(std::move(response_headers), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Sequence: 1) request with data hits per try timeout w/ hedge retry, 2)\n// second request is immediately reset 3) 1st request gets a 200.\n// The goal of this test is to ensure that the router can properly detect that an immediate\n// reset happens and that we don't accidentally write data twice on the first request.\nTEST_F(RouterTest, HedgingRetryImmediatelyReset) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  router_.retry_425_response_ = true;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n  Buffer::OwnedImpl body(\"test body\");\n  EXPECT_CALL(encoder, encodeData(_, _));\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, true));\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  // Per-timeout retry wouldn't enable 0-RTT.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions& options)\n                           -> Http::ConnectionPool::Cancellable* {\n        EXPECT_FALSE(options.can_send_early_data_);\n        EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n        EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                    putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                absl::string_view(), cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n  EXPECT_CALL(*router_.retry_state_,\n              shouldRetryReset(_, /*http3_used=*/RetryState::Http3Used::Unknown, _))\n      .WillOnce(Return(RetryStatus::NoRetryLimitExceeded));\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  router_.retry_state_->callback_();\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a 200 in response to the first request.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  // The request was already retried when the per try timeout occurred so it\n  // should't even consult the retry state.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  // Pool failure for the first try, so only 1 upstream request was made.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryNoneHealthy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::LocalReset);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _)).WillOnce(Return(absl::nullopt));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"19\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream));\n  router_.retry_state_->callback_();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure for the first try, so only 1 upstream request was made.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _));\n  Buffer::OwnedImpl body(\"test body\");\n  router_.decodeData(body, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(Http::StreamResetReason::RemoteReset, _, _))\n      .WillOnce(Invoke([this](const Http::StreamResetReason, RetryState::Http3Used http3_used,\n                              RetryState::DoRetryResetCallback callback) {\n        EXPECT_EQ(RetryState::Http3Used::No, http3_used);\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_http3=*/false); };\n        return RetryStatus::Yes;\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_use_http3_);\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryHttp3UpstreamReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  router_.retry_425_response_ = true;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http3);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _));\n  Buffer::OwnedImpl body(\"test body\");\n  router_.decodeData(body, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(Http::StreamResetReason::RemoteReset, _, _))\n      .WillOnce(Invoke([this](const Http::StreamResetReason, RetryState::Http3Used http3_used,\n                              RetryState::DoRetryResetCallback callback) {\n        EXPECT_EQ(RetryState::Http3Used::Yes, http3_used);\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_http3=*/true); };\n        return RetryStatus::Yes;\n      }));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_send_early_data_);\n            EXPECT_FALSE(options.can_use_http3_);\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, NoRetryWithBodyLimit) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  // Set a per route body limit which disallows any buffering.\n  EXPECT_CALL(callbacks_.route_->route_entry_, retryShadowBufferLimit()).WillOnce(Return(0));\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  // Unlike RetryUpstreamReset above the data won't be buffered as the body exceeds the buffer limit\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _)).Times(0);\n  Buffer::OwnedImpl body(\"t\");\n  router_.decodeData(body, false);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\n// Verifies that when the request fails with an upstream reset (per try timeout in this case)\n// before an upstream host has been established, then the onHostAttempted function will not be\n// invoked. This ensures that we're not passing a null host to the retry plugins.\nTEST_F(RouterTest, RetryUpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  ASSERT(response_decoder);\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Asserts that onHostAttempted is *not* called when the upstream connection fails in such\n// a way that no host is present.\nTEST_F(RouterTest, RetryUpstreamConnectionFailure) {\n  Http::ConnectionPool::Callbacks* conn_pool_callbacks;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        conn_pool_callbacks = &callbacks;\n        return nullptr;\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(*router_.retry_state_, onHostAttempted(_)).Times(0);\n\n  router_.retry_state_->expectResetRetry();\n\n  conn_pool_callbacks->onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                     absl::string_view(), nullptr);\n  // Pool failure, so no upstream request was made.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseDecoder* response_decoder = nullptr;\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, DontResetStartedResponseOnUpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Since the response is already started we don't retry.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, false));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  Buffer::OwnedImpl body(\"test body\");\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  per_try_timeout_->invokeCallback();\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_decoder->decodeData(body, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamResetResponseStarted) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Since the response is already started we don't retry.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, false));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  // Normally, sendLocalReply will actually send the reply, but in this case the\n  // HCM will detect the headers have already been sent and not route through\n  // the encoder again.\n  EXPECT_CALL(callbacks_, sendLocalReply(_, _, _, _, _)).WillOnce(testing::InvokeWithoutArgs([] {\n  }));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  // For normal HTTP, once we have a 200 we consider this a success, even if a\n  // later reset occurs.\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// The router filter is responsible for not propagating 100-continue headers after the initial 100.\nTEST_F(RouterTest, Coalesce1xxHeaders) {\n  // Setup.\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Initial 100-continue, this is processed normally.\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_));\n  {\n    Http::ResponseHeaderMapPtr continue_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n    // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n    response_decoder->decode1xxHeaders(std::move(continue_headers));\n  }\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n\n  // No encode1xxHeaders() invocation for the second 100-continue (but we continue to track\n  // stats from upstream).\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_)).Times(0);\n  {\n    Http::ResponseHeaderMapPtr continue_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n    // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n    response_decoder->decode1xxHeaders(std::move(continue_headers));\n  }\n  EXPECT_EQ(\n      2U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n\n  // Reset stream and cleanup.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamReset1xxResponseStarted) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The 100-continue will result in resetting retry_state_, so when the stream\n  // is reset we won't even check shouldRetryReset() (or shouldRetryHeaders()).\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_));\n  Http::ResponseHeaderMapPtr continue_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decode1xxHeaders(std::move(continue_headers));\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstream5xx) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelay) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Fire timeout.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, MaxStreamDurationValidlyConfiguredWithoutRetryPolicy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationDisabledIfSetToZero) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(0);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  // not to be called timer creation.\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationCallbackNotCalled) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(5000);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(5000));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationWhenDownstreamAlreadyStartedWithoutRetryPolicy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationWithRetryPolicy) {\n  // First upstream request\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"reset\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectResetRetry();\n  max_stream_duration_timer_->invokeCallback();\n\n  // Second upstream request\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n  router_.retry_state_->callback_();\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelayWithUpstreamRequestNoHost) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  Envoy::ConnectionPool::MockCancellable cancellable;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks&,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        return &cancellable;\n      }));\n  router_.retry_state_->callback_();\n\n  // Fire timeout.\n  EXPECT_CALL(cancellable, cancel(_));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Timeout fired so no retry was done.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// Retry timeout during a retry delay leading to no upstream host, as well as an alt response code.\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelayWithUpstreamRequestNoHostAltResponseCode) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-alt-response\", \"204\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  Envoy::ConnectionPool::MockCancellable cancellable;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks&,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        return &cancellable;\n      }));\n  router_.retry_state_->callback_();\n\n  // Fire timeout.\n  EXPECT_CALL(cancellable, cancel(_));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"204\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // no retry was done.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstream5xxNotComplete) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->health_checker_,\n      setUnhealthy(Upstream::HealthCheckHostMonitor::UnhealthyType::ImmediateHealthCheckFail));\n  Http::ResponseHeaderMapPtr response_headers2(new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"200\"}, {\"x-envoy-immediate-health-check-fail\", \"true\"}});\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"retry.upstream_rq_503\")\n                .value());\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_200\").value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"zone.zone_name.to_az.upstream_rq_2xx\")\n                    .value());\n}\n\n// Validate gRPC Cancelled response stats are sane when retry is taking effect.\nTEST_F(RouterTest, RetryUpstreamGrpcCancelled) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-grpc-on\", \"cancelled\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // gRPC with status \"cancelled\" (1)\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"1\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(499));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the grpc-status to result in a retried request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"0\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Verifies that the initial host is select with max host count of one, but during retries\n// RetryPolicy will be consulted.\nTEST_F(RouterTest, RetryRespectsMaxHostSelectionCount) {\n  router_.reject_all_hosts_ = true;\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  ON_CALL(*router_.retry_state_, hostSelectionMaxAttempts()).WillByDefault(Return(3));\n  // The router should accept any host at this point, since we're not in a retry.\n  EXPECT_EQ(1, router_.hostSelectionRetryCount());\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Now that we're triggered a retry, we should see the configured number of host selections.\n  EXPECT_EQ(3, router_.hostSelectionRetryCount());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Verifies that the initial request accepts any host, but during retries\n// RetryPolicy will be consulted.\nTEST_F(RouterTest, RetryRespectsRetryHostPredicate) {\n  router_.reject_all_hosts_ = true;\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  NiceMock<Upstream::MockHost> host;\n  // The router should accept any host at this point, since we're not in a retry.\n  EXPECT_FALSE(router_.shouldSelectAnotherHost(host));\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Now that we're triggered a retry, we should see the router reject hosts.\n  EXPECT_TRUE(router_.shouldSelectAnotherHost(host));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWhenReachingMaxInternalRedirect) {\n  enableRedirects(3);\n  setNumPreviousRedirect(3);\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL,\n            stats_store_.counter(\"test.passthrough_internal_redirect_too_many_redirects\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithEmptyLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_bad_location\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithInvalidLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"h\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_bad_location\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithoutCompleteRequest) {\n  enableRedirects();\n  sendRequest(false);\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithoutLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->removeLocation();\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n}\n\nTEST_F(RouterTest, InternalRedirectAcceptedWithRequestBody) {\n  enableRedirects();\n  sendRequest(false);\n\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"random_fake_data\"));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, true));\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  Buffer::OwnedImpl response_data(\"1234567890\");\n  response_decoder_->decodeData(response_data, false);\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(1, callbacks_.streamInfo()\n                   .filterState()\n                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n                   ->value());\n}\n\nTEST_F(RouterTest, CrossSchemeRedirectRejectedByPolicy) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"https://www.foo.com\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_unsafe_scheme\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedByPredicate) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"http://www.foo.com/some/path\");\n\n  auto mock_predicate = std::make_shared<NiceMock<MockInternalRedirectPredicate>>();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_.route_->route_entry_.internal_redirect_policy_, predicates())\n      .WillOnce(Return(std::vector<InternalRedirectPredicateSharedPtr>({mock_predicate})));\n  EXPECT_CALL(*mock_predicate, acceptTargetRoute(_, _, _, _)).WillOnce(Return(false));\n  ON_CALL(*mock_predicate, name()).WillByDefault(Return(\"mock_predicate\"));\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_predicate\").value());\n\n  // Make sure the original host/path is preserved.\n  EXPECT_EQ(\"host\", default_request_headers_.getHostValue());\n  EXPECT_EQ(\"/\", default_request_headers_.getPathValue());\n  // Make sure x-envoy-original-url is not set for unsuccessful redirect.\n  EXPECT_EQ(nullptr, default_request_headers_.EnvoyOriginalUrl());\n}\n\nTEST_F(RouterTest, HttpInternalRedirectSucceeded) {\n  enableRedirects(3);\n  setNumPreviousRedirect(2);\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(3, callbacks_.streamInfo()\n                   .filterState()\n                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n                   ->value());\n}\n\nTEST_F(RouterTest, InternalRedirectStripsFragment) {\n  enableRedirects();\n  default_request_headers_.setForwardedProto(\"http\");\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  Http::ResponseHeaderMapPtr redirect_headers{new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"302\"}, {\"location\", \"http://www.foo.com/#fragment\"}}};\n  response_decoder_->decodeHeaders(std::move(redirect_headers), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(\"/\", default_request_headers_.getPathValue());\n}\n\nTEST_F(RouterTest, InternalRedirectKeepsFragmentWithOveride) {\n  TestScopedRuntime scoped_runtime;\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http_reject_path_with_fragment\", \"false\"}});\n  enableRedirects();\n  default_request_headers_.setForwardedProto(\"http\");\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  Http::ResponseHeaderMapPtr redirect_headers{new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"302\"}, {\"location\", \"http://www.foo.com/#fragment\"}}};\n  response_decoder_->decodeHeaders(std::move(redirect_headers), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(\"/#fragment\", default_request_headers_.getPathValue());\n}\n\nTEST_F(RouterTest, HttpsInternalRedirectSucceeded) {\n  auto ssl_connection = std::make_shared<Ssl::MockConnectionInfo>();\n  enableRedirects(3);\n  setNumPreviousRedirect(1);\n  default_request_headers_.setScheme(\"https\");\n\n  sendRequest();\n\n  redirect_headers_->setLocation(\"https://www.foo.com\");\n  EXPECT_CALL(connection_, ssl()).WillOnce(Return(ssl_connection));\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, CrossSchemeRedirectAllowedByPolicy) {\n  auto ssl_connection = std::make_shared<Ssl::MockConnectionInfo>();\n  enableRedirects();\n  default_request_headers_.setScheme(\"https\");\n\n  sendRequest();\n\n  redirect_headers_->setLocation(\"http://www.foo.com\");\n  EXPECT_CALL(connection_, ssl()).WillOnce(Return(ssl_connection));\n  EXPECT_CALL(callbacks_.route_->route_entry_.internal_redirect_policy_,\n              isCrossSchemeRedirectAllowed())\n      .WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, Shadow) {\n  ShadowPolicyPtr policy = std::make_unique<TestShadowPolicy>(\"foo\", \"bar\");\n  callbacks_.route_->route_entry_.shadow_policies_.push_back(std::move(policy));\n  policy = std::make_unique<TestShadowPolicy>(\"fizz\", \"buzz\", envoy::type::v3::FractionalPercent(),\n                                              false);\n  callbacks_.route_->route_entry_.shadow_policies_.push_back(std::move(policy));\n  ON_CALL(callbacks_, streamId()).WillByDefault(Return(43));\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"bar\", 0, 43, 10000)).WillOnce(Return(true));\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"buzz\", 0, 43, 10000)).WillOnce(Return(true));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  EXPECT_CALL(callbacks_, decodingBuffer())\n      .Times(AtLeast(2))\n      .WillRepeatedly(Return(body_data.get()));\n  EXPECT_CALL(*shadow_writer_, shadow_(\"foo\", _, _))\n      .WillOnce(Invoke([](const std::string&, Http::RequestMessagePtr& request,\n                          const Http::AsyncClient::RequestOptions& options) -> void {\n        EXPECT_NE(request->body().length(), 0);\n        EXPECT_NE(nullptr, request->trailers());\n        EXPECT_EQ(absl::optional<std::chrono::milliseconds>(10), options.timeout);\n        EXPECT_TRUE(options.sampled_.value());\n      }));\n  EXPECT_CALL(*shadow_writer_, shadow_(\"fizz\", _, _))\n      .WillOnce(Invoke([](const std::string&, Http::RequestMessagePtr& request,\n                          const Http::AsyncClient::RequestOptions& options) -> void {\n        EXPECT_NE(request->body().length(), 0);\n        EXPECT_NE(nullptr, request->trailers());\n        EXPECT_EQ(absl::optional<std::chrono::milliseconds>(10), options.timeout);\n        EXPECT_FALSE(options.sampled_.value());\n      }));\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, AltStatName) {\n  // Also test no upstream timeout here.\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"true\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(1U,\n            stats_store_.counter(\"vhost.fake_vhost.vcluster.fake_virtual_cluster.upstream_rq_200\")\n                .value());\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n  EXPECT_EQ(\n      1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"alt_stat.upstream_rq_200\")\n              .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"alt_stat.zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"alt_stat.zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n}\n\nTEST_F(RouterTest, Redirect) {\n  MockDirectResponseEntry direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"hello\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, rewritePathHeader(_, _));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::MovedPermanently));\n  EXPECT_CALL(direct_response, responseBody()).WillOnce(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(direct_response, finalizeResponseHeaders(_, _));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"301\"}, {\"location\", \"hello\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, RedirectFound) {\n  MockDirectResponseEntry direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"hello\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, rewritePathHeader(_, _));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::Found));\n  EXPECT_CALL(direct_response, responseBody()).WillOnce(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(direct_response, finalizeResponseHeaders(_, _));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"302\"}, {\"location\", \"hello\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, DirectResponse) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithBody) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  const std::string response_body(\"static response\");\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(response_body));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"200\"}, {\"content-length\", \"15\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithLocation) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"http://host/\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::Created));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"201\"},\n                                                   {\"location\", \"http://host/\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithoutLocation) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"http://host/\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\n// Verifies that we propagate the upstream connection filter state to the upstream and downstream\n// request filter state.\nTEST_F(RouterTest, PropagatesUpstreamFilterState) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n\n  // This pattern helps ensure that we're actually invoking the callback.\n  bool filter_state_verified = false;\n  router_.config().upstream_logs_.push_back(\n      std::make_shared<TestAccessLog>([&](const auto& stream_info) {\n        filter_state_verified =\n            stream_info.upstreamInfo()->upstreamFilterState()->hasDataWithName(\"upstream data\");\n      }));\n\n  upstream_stream_info_.filterState()->setData(\n      \"upstream data\", std::make_unique<StreamInfo::UInt32AccessorImpl>(123),\n      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Connection);\n  expectResponseTimerCreate();\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_TRUE(filter_state_verified);\n  EXPECT_TRUE(callbacks_.streamInfo().upstreamInfo()->upstreamFilterState()->hasDataWithName(\n      \"upstream data\"));\n}\n\nTEST_F(RouterTest, UpstreamSSLConnection) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n\n  std::string session_id = \"D62A523A65695219D46FE1FFE285A4C371425ACE421B110B5B8D11D3EB4D5F0B\";\n  auto connection_info = std::make_shared<NiceMock<Ssl::MockConnectionInfo>>();\n  ON_CALL(*connection_info, sessionId()).WillByDefault(ReturnRef(session_id));\n  upstream_stream_info_.downstream_connection_info_provider_->setSslConnection(connection_info);\n\n  expectResponseTimerCreate();\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  ASSERT_NE(nullptr, callbacks_.streamInfo().upstreamInfo()->upstreamSslConnection());\n  EXPECT_EQ(session_id,\n            callbacks_.streamInfo().upstreamInfo()->upstreamSslConnection()->sessionId());\n  EXPECT_FALSE(callbacks_.streamInfo().upstreamInfo()->upstreamConnectionId().has_value());\n  EXPECT_FALSE(callbacks_.streamInfo().upstreamInfo()->upstreamInterfaceName().has_value());\n}\n\n// Verify that upstream timing information is set into the StreamInfo after the upstream\n// request completes.\nTEST_F(RouterTest, UpstreamTimingSingleRequest) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_.timeSystem(), nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n  EXPECT_EQ(nullptr, stream_info.upstreamInfo());\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(32));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(43));\n\n  // Upstream timing data is now available live.\n  ASSERT_NE(nullptr, stream_info.upstreamInfo());\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  response_decoder->decodeData(data, true);\n\n  // Now all these should be set.\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  // Timings should match our sleep() calls.\n  EXPECT_EQ(upstream_timing.last_upstream_rx_byte_received_.value() -\n                upstream_timing.first_upstream_rx_byte_received_.value(),\n            std::chrono::milliseconds(43));\n  EXPECT_EQ(upstream_timing.last_upstream_tx_byte_sent_.value() -\n                upstream_timing.first_upstream_tx_byte_sent_.value(),\n            std::chrono::milliseconds(32));\n}\n\n// Verify that upstream timing information is set into the StreamInfo when a\n// retry occurs (and not before).\nTEST_F(RouterTest, UpstreamTimingRetry) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_, nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n\n  // Check that upstream timing is updated after the first request.\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectHeadersRetry();\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(32));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(43));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::ResponseHeaderMapPtr bad_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(bad_response_headers), true);\n\n  router_.retry_state_->callback_();\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  MonotonicTime retry_time = test_time_.monotonicTime();\n\n  Http::ResponseHeaderMapPtr good_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(good_response_headers), false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(153));\n\n  response_decoder->decodeData(data, true);\n\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  EXPECT_EQ(upstream_timing.last_upstream_rx_byte_received_.value() -\n                upstream_timing.first_upstream_rx_byte_received_.value(),\n            std::chrono::milliseconds(153));\n\n  // Time spent in upstream tx is 0 because we're using simulated time and\n  // don't have a good way to insert a \"sleep\" there, but values being present\n  // and equal to the time the retry was sent is good enough of a test.\n  StreamInfo::TimingUtility timing(stream_info);\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value() - timing.firstUpstreamTxByteSent().value(),\n            std::chrono::milliseconds(0));\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value() +\n                stream_info.startTimeMonotonic().time_since_epoch(),\n            retry_time.time_since_epoch());\n  EXPECT_EQ(timing.firstUpstreamTxByteSent().value() +\n                stream_info.startTimeMonotonic().time_since_epoch(),\n            retry_time.time_since_epoch());\n}\n\n// Verify that upstream timing information is set into the StreamInfo when a\n// global timeout occurs.\nTEST_F(RouterTest, UpstreamTimingTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_, nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n\n  expectResponseTimerCreate();\n  test_time_.advanceTimeWait(std::chrono::milliseconds(10));\n\n  // Check that upstream timing is updated after the first request.\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"50\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(13));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(33));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(99));\n  response_timeout_->invokeCallback();\n\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  // False because no end_stream was seen.\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n  StreamInfo::TimingUtility timing(stream_info);\n  EXPECT_EQ(timing.firstUpstreamTxByteSent().value(), std::chrono::milliseconds(10));\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value(), std::chrono::milliseconds(23));\n  EXPECT_EQ(timing.firstUpstreamRxByteReceived().value(), std::chrono::milliseconds(56));\n}\n\nTEST(RouterFilterUtilityTest, FinalHedgingParamsHedgeOnPerTryTimeout) {\n  Http::TestRequestHeaderMapImpl empty_headers;\n  { // route says true, header not present, expect true.\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams =\n        FilterUtility::finalHedgingParams(route, empty_headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header not present, expect false.\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams =\n        FilterUtility::finalHedgingParams(route, empty_headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header says true, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"true\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header says false, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"false\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header says false, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"false\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header says true, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"true\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header is invalid, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"bad\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header is invalid, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"bad\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n}\n\nTEST(RouterFilterUtilityTest, FinalTimeout) {\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"bad\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, true, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, true, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(7), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"7\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(10);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(0)));\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout()).WillRepeatedly(Return(absl::nullopt));\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1000), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"1000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(999), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"999m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"0m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(999), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"999m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    EXPECT_CALL(route, grpcTimeoutOffset())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"100m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(90), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    EXPECT_CALL(route, grpcTimeoutOffset())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"bad\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1000), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"1000\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"1000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"5m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(7), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"7\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"7m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"5m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10000)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"6666666666666H\"}};\n    FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(\"10000\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"10000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-expected-rq-timeout-ms\", \"8\"}};\n    // Make ingress envoy respect `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-expected-rq-timeout-ms\", \"8\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"4\"}};\n    // Make ingress envoy respect `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(4), timeout.per_try_timeout_);\n    EXPECT_EQ(\"4\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"8\"}};\n    // Test that ingress envoy populates `x-envoy-expected-rq-timeout-ms` header if it has not been\n    // set by egress envoy.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"8\"}};\n    // Make envoy override `x-envoy-expected-rq-timeout-ms` header.\n    // Test that ingress envoy sets `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = false;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, FinalTimeoutSupressEnvoyHeaders) {\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, SetUpstreamScheme) {\n  TestScopedRuntime scoped_runtime;\n\n  // With no scheme and x-forwarded-proto, set scheme based on encryption level\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::setUpstreamScheme(headers, false);\n    EXPECT_EQ(\"http\", headers.get_(\":scheme\"));\n  }\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n\n  // With invalid x-forwarded-proto, still use scheme.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setForwardedProto(\"foo\");\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n\n  // Use valid x-forwarded-proto.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setForwardedProto(Http::Headers::get().SchemeValues.Http);\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"http\", headers.get_(\":scheme\"));\n  }\n\n  // Trust scheme over x-forwarded-proto.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setScheme(Http::Headers::get().SchemeValues.Https);\n    headers.setForwardedProto(Http::Headers::get().SchemeValues.Http);\n    FilterUtility::setUpstreamScheme(headers, false);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, ShouldShadow) {\n  {\n    TestShadowPolicy policy;\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(_, _, _, _)).Times(0);\n    EXPECT_FALSE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(_, _, _, _)).Times(0);\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\", \"foo\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(\"foo\", 0, 5, 10000)).WillOnce(Return(false));\n    EXPECT_FALSE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\", \"foo\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(\"foo\", 0, 5, 10000)).WillOnce(Return(true));\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  // Use default value instead of runtime key.\n  {\n    envoy::type::v3::FractionalPercent fractional_percent;\n    fractional_percent.set_numerator(5);\n    fractional_percent.set_denominator(envoy::type::v3::FractionalPercent::TEN_THOUSAND);\n    TestShadowPolicy policy(\"cluster\", \"foo\", fractional_percent);\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(\n        runtime.snapshot_,\n        featureEnabled(\"foo\", testing::Matcher<const envoy::type::v3::FractionalPercent&>(_), 3))\n        .WillOnce(Return(true));\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 3));\n  }\n}\n\nTEST_F(RouterTest, CanaryStatusTrue) {\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  const absl::optional<std::string> virtual_cluster_name =\n      absl::optional<std::string>(\"fake_virtual_cluster\");\n  EXPECT_CALL(callbacks_.stream_info_, setVirtualClusterName(virtual_cluster_name));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"false\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  ON_CALL(*cm_.thread_local_cluster_.conn_pool_.host_, canary()).WillByDefault(Return(true));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n}\n\nTEST_F(RouterTest, CanaryStatusFalse) {\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  const absl::optional<std::string> virtual_cluster_name =\n      absl::optional<std::string>(\"fake_virtual_cluster\");\n  EXPECT_CALL(callbacks_.stream_info_, setVirtualClusterName(virtual_cluster_name));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"false\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(0U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n}\n\nTEST_F(RouterTest, AutoHostRewriteEnabled) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  std::string req_host{\"foo.bar.com\"};\n\n  Http::TestRequestHeaderMapImpl incoming_headers;\n  HttpTestUtility::addDefaultHeaders(incoming_headers);\n  incoming_headers.setHost(req_host);\n\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n  Http::TestRequestHeaderMapImpl outgoing_headers;\n  HttpTestUtility::addDefaultHeaders(outgoing_headers);\n  outgoing_headers.setHost(cm_.thread_local_cluster_.conn_pool_.host_->hostname_);\n  outgoing_headers.setForwardedHost(req_host);\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder_, Http::Protocol::Http10);\n\n  // :authority header in the outgoing request should match the DNS name of\n  // the selected upstream host\n  EXPECT_CALL(encoder, encodeHeaders(HeaderMapEqualRef(&outgoing_headers), true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, autoHostRewrite()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_.route_->route_entry_, appendXfh()).WillOnce(Return(true));\n  router_.decodeHeaders(incoming_headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, AutoHostRewriteDisabled) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  std::string req_host{\"foo.bar.com\"};\n\n  Http::TestRequestHeaderMapImpl incoming_headers;\n  HttpTestUtility::addDefaultHeaders(incoming_headers);\n  incoming_headers.setHost(req_host);\n\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder_, Http::Protocol::Http10);\n\n  // :authority header in the outgoing request should match the :authority header of\n  // the incoming request\n  EXPECT_CALL(encoder, encodeHeaders(HeaderMapEqualRef(&incoming_headers), true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, autoHostRewrite()).WillOnce(Return(false));\n  router_.decodeHeaders(incoming_headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, UpstreamSocketOptionsReturnedEmpty) {\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(options.get(), nullptr);\n}\n\nTEST_F(RouterTest, IpTransparentOptions) {\n  Network::Socket::OptionsSharedPtr expected_options =\n      Network::SocketOptionFactory::buildIpTransparentOptions();\n  EXPECT_CALL(callbacks_, getUpstreamSocketOptions())\n      .Times(1)\n      .WillRepeatedly(Return(expected_options));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  router_.decodeHeaders(headers, false);\n\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(expected_options->size(), options->size());\n\n  for (size_t i = 0; i < 2; i++) {\n    NiceMock<Network::MockConnectionSocket> dummy_socket;\n    auto state = envoy::config::core::v3::SocketOption::STATE_PREBIND;\n    auto expected_details = expected_options->at(i)->getOptionDetails(dummy_socket, state);\n    auto returned_details = options->at(i)->getOptionDetails(dummy_socket, state);\n    EXPECT_TRUE(expected_details == returned_details);\n  }\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, RedirectRecords) {\n  auto redirect_records = std::make_shared<Network::Win32RedirectRecords>();\n  memcpy(redirect_records->buf_, reinterpret_cast<void*>(redirect_records_data_.data()),\n         redirect_records_data_.size());\n  redirect_records->buf_size_ = redirect_records_data_.size();\n  router_.downstream_connection_.stream_info_.filterState()->setData(\n      Network::UpstreamSocketOptionsFilterState::key(),\n      std::make_unique<Network::UpstreamSocketOptionsFilterState>(),\n      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n  router_.downstream_connection_.stream_info_.filterState()\n      ->getDataMutable<Network::UpstreamSocketOptionsFilterState>(\n          Network::UpstreamSocketOptionsFilterState::key())\n      ->addOption(Network::SocketOptionFactory::buildWFPRedirectRecordsOptions(*redirect_records));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  router_.decodeHeaders(headers, false);\n\n  Network::Socket::OptionsSharedPtr expected_options =\n      Network::SocketOptionFactory::buildWFPRedirectRecordsOptions(*redirect_records);\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(1, options->size());\n\n  NiceMock<Network::MockConnectionSocket> dummy_socket;\n  auto state = envoy::config::core::v3::SocketOption::STATE_PREBIND;\n  auto expected_details = expected_options->at(0)->getOptionDetails(dummy_socket, state);\n  auto returned_details = options->at(0)->getOptionDetails(dummy_socket, state);\n  EXPECT_TRUE(expected_details == returned_details);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, ApplicationProtocols) {\n  callbacks_.streamInfo().filterState()->setData(\n      Network::ApplicationProtocols::key(),\n      std::make_unique<Network::ApplicationProtocols>(std::vector<std::string>{\"foo\", \"bar\"}),\n      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::FilterChain);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        Network::TransportSocketOptionsConstSharedPtr transport_socket_options =\n            context->upstreamTransportSocketOptions();\n        EXPECT_NE(transport_socket_options, nullptr);\n        EXPECT_FALSE(transport_socket_options->applicationProtocolListOverride().empty());\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride().size(), 2);\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride()[0], \"foo\");\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride()[1], \"bar\");\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// Verify that CONNECT payload is not sent upstream until :200 response headers\n// are received.\nTEST_F(RouterTest, ConnectPauseAndResume) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, false));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  // Make sure any early data does not go upstream.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Now send the response headers, and ensure the deferred payload is proxied.\n  EXPECT_CALL(encoder, encodeData(_, _));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\n// Invalid upstream will fail over to generic in opt mode, but crash in debug mode.\nTEST_F(RouterTest, InvalidUpstream) {\n  // Explicitly configure an HTTP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  // Configure a TCP upstream rather than an HTTP upstream.\n  envoy::extensions::upstreams::tcp::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  ON_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillByDefault(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  EXPECT_ENVOY_BUG(router_.decodeHeaders(headers, false), \"envoy bug failure: factory != nullptr.\");\n\n  router_.onDestroy();\n}\n\n// Verify that CONNECT payload is not sent upstream if non-200 response headers are received.\nTEST_F(RouterTest, ConnectPauseNoResume) {\n  // Explicitly configure an HTTP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::http::v3::HttpConnectionPoolProto http_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(http_config);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, false));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  // Make sure any early data does not go upstream.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Now send the response headers, and ensure the deferred payload is not proxied.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"400\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(RouterTest, ConnectExplicitTcpUpstream) {\n  // Explicitly configure a TCP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::tcp::v3::TcpConnectionPoolProto tcp_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(tcp_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n\n  // Make sure newConnection is called on the TCP pool, not newStream on the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_.tcp_conn_pool_, newConnection(_));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, PostExplicitTcpUpstream) {\n  // Explicitly configure a generic upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n  callbacks_.route_->route_entry_.connect_config_.value().set_allow_post(true);\n\n  // Make sure newConnection is called on the TCP pool, not newStream on the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_.tcp_conn_pool_, newConnection(_));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"POST\");\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, PostHttpUpstream) {\n  // Explicitly configure a generic upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n\n  // Make sure POST request result in the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"POST\");\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, SetDynamicMaxStreamDuration) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder_, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-stream-duration-ms\", \"500\"}};\n\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, NotSetDynamicMaxStreamDurationIfZero) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder_, Http::Protocol::Http10);\n\n  // The timer will not be created.\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-stream-duration-ms\", \"0\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\n// Test that request/response header/body sizes are properly recorded.\nTEST_F(RouterTest, RequestResponseSize) { testRequestResponseSize(false); }\n\n// Test that request/response header/body sizes are properly recorded\n// when there are trailers in both the request/response.\nTEST_F(RouterTest, RequestResponseSizeWithTrailers) { testRequestResponseSize(true); }\n\nTEST_F(RouterTest, ExpectedUpstreamTimeoutUpdatedDuringRetries) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(50));\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  // We already used 50ms of our 200ms timeout before the retry was triggered\n  EXPECT_EQ(150, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\nTEST_F(RouterTest, ExpectedUpstreamTimeoutNotUpdatedDuringRetriesWhenRuntimeGuardDisabled) {\n  TestScopedRuntime scoped_runtime;\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.update_expected_rq_timeout_on_retry\", \"false\"}});\n\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(50));\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  // We already used 50ms of our 200ms timeout before the retry was triggered,\n  // but with the guard disabled this should not change the header.\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\nTEST(RouterFilterUtilityTest, SetTimeoutHeaders) {\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"200\",\n              headers.get_(\n                  \"x-envoy-expected-rq-timeout-ms\")); // No per try configured, use global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"50\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"150\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Per try timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(25, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"150\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Per try timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"50\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(300, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"1\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Over time\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"200\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Global timeout as hedged\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(25, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"175\", headers.get_(\n                         \"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout as hedged\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"50\", headers.get_(\n                        \"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout as hedged\n  }\n}\n\nTEST_F(RouterTest, HasEarlyDataAndRetryUpon425) {\n  Http::TestRequestHeaderMapImpl headers;\n  // This is a GET request.\n  HttpTestUtility::addDefaultHeaders(headers);\n\n  router_.retry_425_response_ = true;\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_use_http3_);\n            EXPECT_TRUE(options.can_send_early_data_);\n            response_decoder1 = &decoder;\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n  EXPECT_CALL(encoder1, encodeHeaders(_, _));\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"425\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, HeaderMapEqualRef(&headers), _))\n      .WillOnce(Invoke([this](const Http::ResponseHeaderMap&, const Http::RequestHeaderMap&,\n                              RetryState::DoRetryHeaderCallback callback) {\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_early_data=*/true); };\n        return RetryStatus::Yes;\n      }));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Expect retry upon 425 response.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_FALSE(options.can_send_early_data_);\n            EXPECT_TRUE(options.can_use_http3_);\n            response_decoder2 = &decoder;\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderMapEqualRef(&headers), _));\n  router_.retry_state_->callback_();\n\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _));\n  response_decoder2->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test the case that request with upstream override host.\nTEST_F(RouterTest, RequestWithUpstreamOverrideHost) {\n  NiceMock<Http::MockRequestEncoder> encoder_for_first_reqeust;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder,\n                           Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        callbacks.onPoolReady(encoder_for_first_reqeust, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n        return nullptr;\n      }));\n  expectResponseTimerCreate();\n\n  // Simulate the load balancer to call the `overrideHostToSelect`. When `overrideHostToSelect` of\n  // `LoadBalancerContext` is called, `upstreamOverrideHost` of StreamDecoderFilterCallbacks will be\n  // called to get address of upstream host that should be selected first.\n  EXPECT_CALL(callbacks_, upstreamOverrideHost())\n      .WillOnce(Return(absl::make_optional<absl::string_view>(\"1.2.3.4\")));\n\n  auto override_host = router_.overrideHostToSelect();\n  EXPECT_EQ(\"1.2.3.4\", override_host->first);\n  EXPECT_EQ(~static_cast<uint32_t>(0), override_host->second);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n\n  // Simulate the normal first request.\n  router_.decodeHeaders(headers, true);\n\n  // Mock response with status 503.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers_503(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  ASSERT(response_decoder != nullptr);\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers_503), true);\n\n  // Kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder_for_retry_request;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder,\n                           Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        callbacks.onPoolReady(encoder_for_retry_request, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n        return nullptr;\n      }));\n  router_.retry_state_->callback_();\n\n  // Simulate the load balancer to call the `overrideHostToSelect` again. The upstream override host\n  // will be ignored when the request is retried.\n  EXPECT_CALL(callbacks_, upstreamOverrideHost()).Times(0);\n  EXPECT_EQ(absl::nullopt, router_.overrideHostToSelect());\n\n  // Normal response.\n  Http::ResponseHeaderMapPtr response_headers_200(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  ASSERT(response_decoder != nullptr);\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers_200), true);\n\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n\n  router_.onDestroy();\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"test/integration/http_protocol_integration.h\"\n\nnamespace Envoy {\n\nusing ::testing::HasSubstr;\n\nnamespace {\nconstexpr char HandleThreeHopLocationFormat[] =\n    \"http://handle.internal.redirect.max.three.hop/path{}\";\nconstexpr char kTestHeaderKey[] = \"test-header\";\n} // namespace\n\nclass RedirectIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void initialize() override {\n    setMaxRequestHeadersKb(60);\n    setMaxRequestHeadersCount(100);\n    envoy::config::route::v3::RetryPolicy retry_policy;\n\n    auto pass_through = config_helper_.createVirtualHost(\"pass.through.internal.redirect\");\n    config_helper_.addVirtualHost(pass_through);\n\n    auto handle = config_helper_.createVirtualHost(\"handle.internal.redirect\");\n    handle.mutable_routes(0)->set_name(\"redirect\");\n    handle.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    config_helper_.addVirtualHost(handle);\n\n    auto handle_max_3_hop =\n        config_helper_.createVirtualHost(\"handle.internal.redirect.max.three.hop\");\n    handle_max_3_hop.mutable_routes(0)->set_name(\"max_three_hop\");\n    handle_max_3_hop.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    handle_max_3_hop.mutable_routes(0)\n        ->mutable_route()\n        ->mutable_internal_redirect_policy()\n        ->mutable_max_internal_redirects()\n        ->set_value(3);\n    config_helper_.addVirtualHost(handle_max_3_hop);\n\n    HttpProtocolIntegrationTest::initialize();\n  }\n\nprotected:\n  // Returns the next stream that the fake upstream receives.\n  FakeStreamPtr waitForNextStream() {\n    FakeStreamPtr new_stream = nullptr;\n    auto wait_new_stream_fn = [this,\n                               &new_stream](FakeHttpConnectionPtr& connection) -> AssertionResult {\n      AssertionResult result =\n          connection->waitForNewStream(*dispatcher_, new_stream, std::chrono::milliseconds(50));\n      if (result) {\n        ASSERT(new_stream);\n      }\n      return result;\n    };\n\n    // Using a while loop to poll for new connections and new streams on all\n    // connections because connection reuse may or may not be triggered.\n    while (new_stream == nullptr) {\n      FakeHttpConnectionPtr new_connection = nullptr;\n      AssertionResult result = fake_upstreams_[0]->waitForHttpConnection(\n          *dispatcher_, new_connection, std::chrono::milliseconds(50));\n      if (result) {\n        ASSERT(new_connection);\n        upstream_connections_.push_back(std::move(new_connection));\n      }\n\n      for (auto& connection : upstream_connections_) {\n        result = wait_new_stream_fn(connection);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    AssertionResult result = new_stream->waitForEndStream(*dispatcher_);\n    ASSERT(result);\n    return new_stream;\n  }\n\n  Http::TestResponseHeaderMapImpl redirect_response_{{\":status\", \"302\"},\n                                                     {\"content-length\", \"0\"},\n                                                     {\"location\", \"http://authority2/new/url\"},\n                                                     // Test header added to confirm that response\n                                                     // headers are populated for internal redirects\n                                                     {kTestHeaderKey, \"test-header-value\"}};\n  Envoy::Http::LowerCaseString test_header_key_{kTestHeaderKey};\n  std::vector<FakeHttpConnectionPtr> upstream_connections_;\n};\n\n// By default if internal redirects are not configured, redirects are proxied.\nTEST_P(RedirectIntegrationTest, RedirectNotConfigured) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n\n  // Use base class initialize.\n  HttpProtocolIntegrationTest::initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\n// Verify that URI fragment in upstream server Location header is passed unmodified to the\n// downstream client.\nTEST_P(RedirectIntegrationTest, UpstreamRedirectPreservesURIFragmentInLocation) {\n  // Use base class initialize.\n  HttpProtocolIntegrationTest::initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  Http::TestResponseHeaderMapImpl redirect_response{\n      {\":status\", \"302\"},\n      {\"content-length\", \"0\"},\n      {\"location\", \"http://authority2/new/url?p1=v1&p2=v2#fragment\"}};\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response, 0);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\"http://authority2/new/url?p1=v1&p2=v2#fragment\",\n            response->headers().getLocationValue());\n}\n\n// Now test a route with redirects configured on in pass-through mode.\nTEST_P(RedirectIntegrationTest, InternalRedirectPassedThrough) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"pass.through.internal.redirect\");\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      0,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirect) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirectDownstreamBytesCount) {\n  if (upstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(0, 63, 0, 31),\n                                       BytesCountExpectation(0, 42, 0, 42),\n                                       BytesCountExpectation(0, 42, 0, 42), 0);\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(140, 63, 121, 31),\n                                       BytesCountExpectation(77, 42, 77, 42),\n                                       BytesCountExpectation(77, 42, 77, 42), 1);\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirectUpstreamBytesCount) {\n  if (downstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%UPSTREAM_WIRE_BYTES_SENT% %UPSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%UPSTREAM_HEADER_BYTES_SENT% %UPSTREAM_HEADER_BYTES_RECEIVED%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  expectUpstreamBytesSentAndReceived(BytesCountExpectation(195, 110, 164, 85),\n                                     BytesCountExpectation(137, 64, 137, 64),\n                                     BytesCountExpectation(137, 64, 137, 64), 0);\n  expectUpstreamBytesSentAndReceived(BytesCountExpectation(244, 38, 219, 18),\n                                     BytesCountExpectation(85, 10, 85, 10),\n                                     BytesCountExpectation(85, 10, 85, 10), 1);\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectStripsUriFragment) {\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n\n  // Redirect to URI with fragment\n  Http::TestResponseHeaderMapImpl redirect_response{\n      {\":status\", \"302\"},\n      {\"content-length\", \"0\"},\n      {\"location\", \"http://authority2/new/url?p1=v1&p2=v2#fragment\"}};\n\n  upstream_request_->encodeHeaders(redirect_response, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  // During internal redirect Envoy always strips fragment from Location URI\n  EXPECT_EQ(\"/new/url?p1=v1&p2=v2\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectWithRequestBody) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  const std::string& request_body = \"foobarbizbaz\";\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeRequestWithBody(default_request_headers_, request_body);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n\n  // Respond with a redirect.\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectHandlesHttp303) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        hcm.set_via(\"via_value\");\n\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_route()\n            ->mutable_internal_redirect_policy()\n            ->mutable_redirect_response_codes()\n            ->Add(303);\n      });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  const std::string& request_body = \"foobarbizbaz\";\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  default_request_headers_.setContentLength(request_body.length());\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeRequestWithBody(default_request_headers_, request_body);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n\n  // Respond with a redirect.\n  redirect_response_.setStatus(303);\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"\", upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n  EXPECT_EQ(\"GET\", upstream_request_->headers().getMethodValue());\n  EXPECT_EQ(\"\", upstream_request_->headers().getContentLengthValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"303 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectHttp303PreservesHeadMethod) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        hcm.set_via(\"via_value\");\n\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_route()\n            ->mutable_internal_redirect_policy()\n            ->mutable_redirect_response_codes()\n            ->Add(303);\n      });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"HEAD\");\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n\n  // Respond with a redirect.\n  redirect_response_.setStatus(303);\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"\", upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n  EXPECT_EQ(\"HEAD\", upstream_request_->headers().getMethodValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"303 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectCancelledDueToBufferOverflow) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_per_request_buffer_limit_bytes()->set_value(1024);\n      });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto& encoder = encoder_decoder.first;\n  auto& response = encoder_decoder.second;\n\n  // Send more data than what we can buffer.\n  std::string data(2048, 'a');\n  Buffer::OwnedImpl send1(data);\n  encoder.encodeData(send1, true);\n\n  // Wait for a redirect response.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(data, upstream_request_->body().toString());\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Ensure the redirect was returned to the client.\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectCancelledDueToEarlyResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto& response = encoder_decoder.second;\n\n  // Wait for the request headers to be received upstream.\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n\n  // Respond with a redirect before the request is complete.\n  upstream_request_->encodeHeaders(redirect_response_, true);\n  ASSERT_TRUE(response->waitForEndStream());\n\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  if (downstream_protocol_ == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n\n  // Ensure the redirect was returned to the client and not handled internally.\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectWithThreeHopLimit) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect.max.three.hop\");\n  default_request_headers_.setPath(\"/path0\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  std::vector<FakeStreamPtr> upstream_requests;\n  // Four requests to upstream: 1 original request + 3 following redirect\n  for (int i = 0; i < 4; i++) {\n    upstream_requests.push_back(waitForNextStream());\n\n    EXPECT_EQ(fmt::format(\"/path{}\", i), upstream_requests.back()->headers().getPathValue());\n    EXPECT_EQ(\"handle.internal.redirect.max.three.hop\",\n              upstream_requests.back()->headers().getHostValue());\n    EXPECT_EQ(\"via_value\", upstream_requests.back()->headers().getViaValue());\n\n    auto next_location = fmt::format(HandleThreeHopLocationFormat, i + 1);\n    redirect_response_.setLocation(next_location);\n    upstream_requests.back()->encodeHeaders(redirect_response_, true);\n  }\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      1,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(\n      1, test_server_->counter(\"http.config_test.passthrough_internal_redirect_too_many_redirects\")\n             ->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 2),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 3),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectToDestinationWithResponseBody) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  config_helper_.prependFilter(R\"EOF(\n  name: pause-filter\n  typed_config:\n    \"@type\": type.googleapis.com/google.protobuf.Empty\n  )EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  Http::TestResponseHeaderMapImpl response_with_big_body(\n      {{\":status\", \"200\"}, {\"content-length\", \"2000000\"}});\n  upstream_request_->encodeHeaders(response_with_big_body, false);\n  upstream_request_->encodeData(2000000, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InvalidRedirect) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  initialize();\n\n  redirect_response_.setLocation(\"invalid_url\");\n\n  // Send the same request as above, only send an invalid URL as the response.\n  // The request should not be redirected.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      1,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nINSTANTIATE_TEST_SUITE_P(Protocols, RedirectIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n} // namespace Envoy\n"], "fixing_code": ["1.22.0 (pending)\n================\n\nIncompatible Behavior Changes\n-----------------------------\n*Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\n* tls: set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using :ref:`tls_minimum_protocol_version <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.\n\nMinor Behavior Changes\n----------------------\n*Changes that may cause incompatibilities for some users, but should not for most*\n\n* dynamic_forward_proxy: if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local filters and failing to select an upstream host.\n* ext_authz: added requested server name in ext_authz network filter for auth review.\n* file: changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.\n* grpc: flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client created through getOrCreateRawAsyncClient will be cached by default.\n* http: avoiding delay-close for HTTP/1.0 responses framed by connection: close as well as HTTP/1.1 if the request is fully read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are are seen to be receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.\n* http: now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but also can be adjusted up, of course, it can not exceed the configured upper bounds. This fix is guarded by ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.\n* http: when writing custom filters, `injectEncodedDataToFilterChain` and `injectDecodedDataToFilterChain` now trigger sending of headers if they were not yet sent due to `StopIteration`. Previously, calling one of the inject functions in that state would trigger an assertion. See issue #19891 for more details.\n* perf: ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret update.\n\nBug Fixes\n---------\n*Changes expected to improve the state of the world and are unlikely to have negative effects*\n\n* access_log: fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush attempt after a failure.\n* data plane: fix crash when internal redirect selects a route configured with direct response or redirect actions.\n* data plane: fixing error handling where writing to a socket failed while under the stack of processing. This should genreally affect HTTP/3. This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.\n* eds: fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.\n* jwt_authn: fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.\n* tcp_proxy: fix a crash that occurs when configured for :ref:`upstream tunneling <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection disconnects while the the upstream connection or http/2 stream is still being established.\n* tls: fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and ``buzz.example.net``, respectively.\n* upstream: fix stack overflow when a cluster with large number of idle connections is removed.\n* xray: fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header ``x-amzn-trace-id``.\n\nRemoved Config or Runtime\n-------------------------\n*Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n\n* access_log: removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.\n* grpc_bridge_filter: removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.\n* http: removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.\n* udp: removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.\n* upstream: removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.\n* xds: removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.\n\n\nNew Features\n------------\n* access_log: make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* admin: :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at once.\n* config: added new file based xDS configuration via :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.\n  :ref:`watched_directory <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can\n  be used to setup an independent watch for when to reload the file path, for example when using\n  Kubernetes ConfigMaps to deliver configuration. See the linked documentation for more information.\n* cors: add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.\n* http: added random_value_specifier in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from configuration proto.\n* http: added support for :ref:`proxy_status_config <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>` for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response header fields.\n* http: make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations of local & remote addresses for upstream & downstream connections.\n* http3: downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here <arch_overview_http3>` for details.\n* http3: supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure`` policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured with TCP fallback. This feature is guarded by ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.\n* matching: the matching API can now express a match tree that will always match by omitting a matcher at the top level.\n* outlier_detection: :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to not break or change the behavior of existing deployments.\n\nDeprecated\n----------\n\n* config: deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of\n  :ref:`path_config_source <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`\n* http: removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.\n* re2: removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.\n", "#include \"source/common/router/router.h\"\n\n#include <chrono>\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/event/timer.h\"\n#include \"envoy/grpc/status.h\"\n#include \"envoy/http/conn_pool.h\"\n#include \"envoy/runtime/runtime.h\"\n#include \"envoy/upstream/cluster_manager.h\"\n#include \"envoy/upstream/health_check_host_monitor.h\"\n#include \"envoy/upstream/upstream.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/cleanup.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/enum_to_int.h\"\n#include \"source/common/common/scope_tracker.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/config/utility.h\"\n#include \"source/common/grpc/common.h\"\n#include \"source/common/http/codes.h\"\n#include \"source/common/http/header_map_impl.h\"\n#include \"source/common/http/headers.h\"\n#include \"source/common/http/message_impl.h\"\n#include \"source/common/http/utility.h\"\n#include \"source/common/network/application_protocol.h\"\n#include \"source/common/network/socket_option_factory.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/network/upstream_server_name.h\"\n#include \"source/common/network/upstream_socket_options_filter_state.h\"\n#include \"source/common/network/upstream_subject_alt_names.h\"\n#include \"source/common/router/config_impl.h\"\n#include \"source/common/router/debug_config.h\"\n#include \"source/common/router/retry_state_impl.h\"\n#include \"source/common/router/upstream_request.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stream_info/uint32_accessor_impl.h\"\n#include \"source/common/tracing/http_tracer_impl.h\"\n\nnamespace Envoy {\nnamespace Router {\nnamespace {\nconstexpr char NumInternalRedirectsFilterStateName[] = \"num_internal_redirects\";\n\nuint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }\n\nbool schemeIsHttp(const Http::RequestHeaderMap& downstream_headers,\n                  const Network::Connection& connection) {\n  if (Http::Utility::getScheme(downstream_headers) == Http::Headers::get().SchemeValues.Http) {\n    return true;\n  }\n  if (!connection.ssl()) {\n    return true;\n  }\n  return false;\n}\n\nconstexpr uint64_t TimeoutPrecisionFactor = 100;\n\n} // namespace\n\n// Express percentage as [0, TimeoutPrecisionFactor] because stats do not accept floating point\n// values, and getting multiple significant figures on the histogram would be nice.\nuint64_t FilterUtility::percentageOfTimeout(const std::chrono::milliseconds response_time,\n                                            const std::chrono::milliseconds timeout) {\n  // Timeouts of 0 are considered infinite. Any portion of an infinite timeout used is still\n  // none of it.\n  if (timeout.count() == 0) {\n    return 0;\n  }\n\n  return static_cast<uint64_t>(response_time.count() * TimeoutPrecisionFactor / timeout.count());\n}\n\nvoid FilterUtility::setUpstreamScheme(Http::RequestHeaderMap& headers, bool downstream_secure) {\n  if (Http::HeaderUtility::schemeIsValid(headers.getSchemeValue())) {\n    return;\n  }\n  // After all the changes in https://github.com/envoyproxy/envoy/issues/14587\n  // this path should only occur if a buggy filter has removed the :scheme\n  // header. In that case best-effort set from X-Forwarded-Proto.\n  absl::string_view xfp = headers.getForwardedProtoValue();\n  if (Http::HeaderUtility::schemeIsValid(xfp)) {\n    headers.setScheme(xfp);\n    return;\n  }\n\n  if (downstream_secure) {\n    headers.setReferenceScheme(Http::Headers::get().SchemeValues.Https);\n  } else {\n    headers.setReferenceScheme(Http::Headers::get().SchemeValues.Http);\n  }\n}\n\nbool FilterUtility::shouldShadow(const ShadowPolicy& policy, Runtime::Loader& runtime,\n                                 uint64_t stable_random) {\n  if (policy.cluster().empty()) {\n    return false;\n  }\n\n  if (policy.defaultValue().numerator() > 0) {\n    return runtime.snapshot().featureEnabled(policy.runtimeKey(), policy.defaultValue(),\n                                             stable_random);\n  }\n\n  if (!policy.runtimeKey().empty() &&\n      !runtime.snapshot().featureEnabled(policy.runtimeKey(), 0, stable_random, 10000UL)) {\n    return false;\n  }\n\n  return true;\n}\n\nFilterUtility::TimeoutData\nFilterUtility::finalTimeout(const RouteEntry& route, Http::RequestHeaderMap& request_headers,\n                            bool insert_envoy_expected_request_timeout_ms, bool grpc_request,\n                            bool per_try_timeout_hedging_enabled,\n                            bool respect_expected_rq_timeout) {\n  // See if there is a user supplied timeout in a request header. If there is we take that.\n  // Otherwise if the request is gRPC and a maximum gRPC timeout is configured we use the timeout\n  // in the gRPC headers (or infinity when gRPC headers have no timeout), but cap that timeout to\n  // the configured maximum gRPC timeout (which may also be infinity, represented by a 0 value),\n  // or the default from the route config otherwise.\n  TimeoutData timeout;\n  if (!route.usingNewTimeouts()) {\n    if (grpc_request && route.maxGrpcTimeout()) {\n      const std::chrono::milliseconds max_grpc_timeout = route.maxGrpcTimeout().value();\n      auto header_timeout = Grpc::Common::getGrpcTimeout(request_headers);\n      std::chrono::milliseconds grpc_timeout =\n          header_timeout ? header_timeout.value() : std::chrono::milliseconds(0);\n      if (route.grpcTimeoutOffset()) {\n        // We only apply the offset if it won't result in grpc_timeout hitting 0 or below, as\n        // setting it to 0 means infinity and a negative timeout makes no sense.\n        const auto offset = *route.grpcTimeoutOffset();\n        if (offset < grpc_timeout) {\n          grpc_timeout -= offset;\n        }\n      }\n\n      // Cap gRPC timeout to the configured maximum considering that 0 means infinity.\n      if (max_grpc_timeout != std::chrono::milliseconds(0) &&\n          (grpc_timeout == std::chrono::milliseconds(0) || grpc_timeout > max_grpc_timeout)) {\n        grpc_timeout = max_grpc_timeout;\n      }\n      timeout.global_timeout_ = grpc_timeout;\n    } else {\n      timeout.global_timeout_ = route.timeout();\n    }\n  }\n  timeout.per_try_timeout_ = route.retryPolicy().perTryTimeout();\n  timeout.per_try_idle_timeout_ = route.retryPolicy().perTryIdleTimeout();\n\n  uint64_t header_timeout;\n\n  if (respect_expected_rq_timeout) {\n    // Check if there is timeout set by egress Envoy.\n    // If present, use that value as route timeout and don't override\n    // *x-envoy-expected-rq-timeout-ms* header. At this point *x-envoy-upstream-rq-timeout-ms*\n    // header should have been sanitized by egress Envoy.\n    const Http::HeaderEntry* header_expected_timeout_entry =\n        request_headers.EnvoyExpectedRequestTimeoutMs();\n    if (header_expected_timeout_entry) {\n      trySetGlobalTimeout(*header_expected_timeout_entry, timeout);\n    } else {\n      const Http::HeaderEntry* header_timeout_entry =\n          request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n      if (header_timeout_entry) {\n        trySetGlobalTimeout(*header_timeout_entry, timeout);\n        request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n      }\n    }\n  } else {\n    const Http::HeaderEntry* header_timeout_entry = request_headers.EnvoyUpstreamRequestTimeoutMs();\n\n    if (header_timeout_entry) {\n      trySetGlobalTimeout(*header_timeout_entry, timeout);\n      request_headers.removeEnvoyUpstreamRequestTimeoutMs();\n    }\n  }\n\n  // See if there is a per try/retry timeout. If it's >= global we just ignore it.\n  const absl::string_view per_try_timeout_entry =\n      request_headers.getEnvoyUpstreamRequestPerTryTimeoutMsValue();\n  if (!per_try_timeout_entry.empty()) {\n    if (absl::SimpleAtoi(per_try_timeout_entry, &header_timeout)) {\n      timeout.per_try_timeout_ = std::chrono::milliseconds(header_timeout);\n    }\n    request_headers.removeEnvoyUpstreamRequestPerTryTimeoutMs();\n  }\n\n  if (timeout.per_try_timeout_ >= timeout.global_timeout_ && timeout.global_timeout_.count() != 0) {\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n  }\n\n  setTimeoutHeaders(0, timeout, route, request_headers, insert_envoy_expected_request_timeout_ms,\n                    grpc_request, per_try_timeout_hedging_enabled);\n\n  return timeout;\n}\n\nvoid FilterUtility::setTimeoutHeaders(uint64_t elapsed_time,\n                                      const FilterUtility::TimeoutData& timeout,\n                                      const RouteEntry& route,\n                                      Http::RequestHeaderMap& request_headers,\n                                      bool insert_envoy_expected_request_timeout_ms,\n                                      bool grpc_request, bool per_try_timeout_hedging_enabled) {\n\n  const uint64_t global_timeout = timeout.global_timeout_.count();\n\n  // See if there is any timeout to write in the expected timeout header.\n  uint64_t expected_timeout = timeout.per_try_timeout_.count();\n\n  // Use the global timeout if no per try timeout was specified or if we're\n  // doing hedging when there are per try timeouts. Either of these scenarios\n  // mean that the upstream server can use the full global timeout.\n  if (per_try_timeout_hedging_enabled || expected_timeout == 0) {\n    expected_timeout = global_timeout;\n  }\n\n  // If the expected timeout is 0 set no timeout, as Envoy treats 0 as infinite timeout.\n  if (expected_timeout > 0) {\n\n    if (global_timeout > 0) {\n      if (elapsed_time >= global_timeout) {\n        // We are out of time, but 0 would be an infinite timeout. So instead we send a 1ms timeout\n        // and assume the timers armed by onRequestComplete() will fire very soon.\n        expected_timeout = 1;\n      } else {\n        expected_timeout = std::min(expected_timeout, global_timeout - elapsed_time);\n      }\n    }\n\n    if (insert_envoy_expected_request_timeout_ms) {\n      request_headers.setEnvoyExpectedRequestTimeoutMs(expected_timeout);\n    }\n\n    // If we've configured max_grpc_timeout, override the grpc-timeout header with\n    // the expected timeout. This ensures that the optional per try timeout is reflected\n    // in grpc-timeout, ensuring that the upstream gRPC server is aware of the actual timeout.\n    if (grpc_request && !route.usingNewTimeouts() && route.maxGrpcTimeout()) {\n      Grpc::Common::toGrpcTimeout(std::chrono::milliseconds(expected_timeout), request_headers);\n    }\n  }\n}\n\nabsl::optional<std::chrono::milliseconds>\nFilterUtility::tryParseHeaderTimeout(const Http::HeaderEntry& header_timeout_entry) {\n  uint64_t header_timeout;\n  if (absl::SimpleAtoi(header_timeout_entry.value().getStringView(), &header_timeout)) {\n    return std::chrono::milliseconds(header_timeout);\n  }\n  return absl::nullopt;\n}\n\nvoid FilterUtility::trySetGlobalTimeout(const Http::HeaderEntry& header_timeout_entry,\n                                        TimeoutData& timeout) {\n  const auto timeout_ms = tryParseHeaderTimeout(header_timeout_entry);\n  if (timeout_ms.has_value()) {\n    timeout.global_timeout_ = timeout_ms.value();\n  }\n}\n\nFilterUtility::HedgingParams\nFilterUtility::finalHedgingParams(const RouteEntry& route,\n                                  Http::RequestHeaderMap& request_headers) {\n  HedgingParams hedging_params;\n  hedging_params.hedge_on_per_try_timeout_ = route.hedgePolicy().hedgeOnPerTryTimeout();\n\n  const Http::HeaderEntry* hedge_on_per_try_timeout_entry =\n      request_headers.EnvoyHedgeOnPerTryTimeout();\n  if (hedge_on_per_try_timeout_entry) {\n    if (hedge_on_per_try_timeout_entry->value() == \"true\") {\n      hedging_params.hedge_on_per_try_timeout_ = true;\n    }\n    if (hedge_on_per_try_timeout_entry->value() == \"false\") {\n      hedging_params.hedge_on_per_try_timeout_ = false;\n    }\n\n    request_headers.removeEnvoyHedgeOnPerTryTimeout();\n  }\n\n  return hedging_params;\n}\n\nFilter::~Filter() {\n  // Upstream resources should already have been cleaned.\n  ASSERT(upstream_requests_.empty());\n  ASSERT(!retry_state_);\n}\n\nconst FilterUtility::StrictHeaderChecker::HeaderCheckResult\nFilterUtility::StrictHeaderChecker::checkHeader(Http::RequestHeaderMap& headers,\n                                                const Http::LowerCaseString& target_header) {\n  if (target_header == Http::Headers::get().EnvoyUpstreamRequestTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyUpstreamRequestPerTryTimeoutMs) {\n    return isInteger(headers.EnvoyUpstreamRequestPerTryTimeoutMs());\n  } else if (target_header == Http::Headers::get().EnvoyMaxRetries) {\n    return isInteger(headers.EnvoyMaxRetries());\n  } else if (target_header == Http::Headers::get().EnvoyRetryOn) {\n    return hasValidRetryFields(headers.EnvoyRetryOn(), &Router::RetryStateImpl::parseRetryOn);\n  } else if (target_header == Http::Headers::get().EnvoyRetryGrpcOn) {\n    return hasValidRetryFields(headers.EnvoyRetryGrpcOn(),\n                               &Router::RetryStateImpl::parseRetryGrpcOn);\n  }\n  // Should only validate headers for which we have implemented a validator.\n  PANIC(\"unexpectedly reached\");\n}\n\nStats::StatName Filter::upstreamZone(Upstream::HostDescriptionConstSharedPtr upstream_host) {\n  return upstream_host ? upstream_host->localityZoneStatName() : config_.empty_stat_name_;\n}\n\nvoid Filter::chargeUpstreamCode(uint64_t response_status_code,\n                                const Http::ResponseHeaderMap& response_headers,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  // Passing the response_status_code explicitly is an optimization to avoid\n  // multiple calls to slow Http::Utility::getResponseStatus.\n  ASSERT(response_status_code == Http::Utility::getResponseStatus(response_headers));\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck()) {\n    const Http::HeaderEntry* upstream_canary_header = response_headers.EnvoyUpstreamCanary();\n    const bool is_canary = (upstream_canary_header && upstream_canary_header->value() == \"true\") ||\n                           (upstream_host ? upstream_host->canary() : false);\n    const bool internal_request = Http::HeaderUtility::isEnvoyInternalRequest(*downstream_headers_);\n\n    Stats::StatName upstream_zone = upstreamZone(upstream_host);\n    Http::CodeStats::ResponseStatInfo info{config_.scope_,\n                                           cluster_->statsScope(),\n                                           config_.empty_stat_name_,\n                                           response_status_code,\n                                           internal_request,\n                                           route_entry_->virtualHost().statName(),\n                                           request_vcluster_ ? request_vcluster_->statName()\n                                                             : config_.empty_stat_name_,\n                                           config_.zone_name_,\n                                           upstream_zone,\n                                           is_canary};\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    code_stats.chargeResponseStat(info, exclude_http_code_stats_);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseStatInfo alt_info{config_.scope_,\n                                                 cluster_->statsScope(),\n                                                 alt_stat_prefix_->statName(),\n                                                 response_status_code,\n                                                 internal_request,\n                                                 config_.empty_stat_name_,\n                                                 config_.empty_stat_name_,\n                                                 config_.zone_name_,\n                                                 upstream_zone,\n                                                 is_canary};\n      code_stats.chargeResponseStat(alt_info, exclude_http_code_stats_);\n    }\n\n    if (dropped) {\n      cluster_->loadReportStats().upstream_rq_dropped_.inc();\n    }\n    if (upstream_host && Http::CodeUtility::is5xx(response_status_code)) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::chargeUpstreamCode(Http::Code code,\n                                Upstream::HostDescriptionConstSharedPtr upstream_host,\n                                bool dropped) {\n  const uint64_t response_status_code = enumToInt(code);\n  const auto fake_response_headers = Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(response_status_code)}});\n  chargeUpstreamCode(response_status_code, *fake_response_headers, upstream_host, dropped);\n}\n\nHttp::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n  downstream_headers_ = &headers;\n\n  // Extract debug configuration from filter state. This is used further along to determine whether\n  // we should append cluster and host headers to the response, and whether to forward the request\n  // upstream.\n  const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();\n  const DebugConfig* debug_config = filter_state->getDataReadOnly<DebugConfig>(DebugConfig::key());\n\n  // TODO: Maybe add a filter API for this.\n  grpc_request_ = Grpc::Common::isGrpcRequestHeaders(headers);\n  exclude_http_code_stats_ = grpc_request_ && config_.suppress_grpc_request_failure_code_stats_;\n\n  // Only increment rq total stat if we actually decode headers here. This does not count requests\n  // that get handled by earlier filters.\n  config_.stats_.rq_total_.inc();\n\n  // Initialize the `modify_headers` function as a no-op (so we don't have to remember to check it\n  // against nullptr before calling it), and feed it behavior later if/when we have cluster info\n  // headers to append.\n  std::function<void(Http::ResponseHeaderMap&)> modify_headers = [](Http::ResponseHeaderMap&) {};\n\n  // Determine if there is a route entry or a direct response for the request.\n  route_ = callbacks_->route();\n  if (!route_) {\n    config_.stats_.no_route_.inc();\n    ENVOY_STREAM_LOG(debug, \"no route match for URL '{}'\", *callbacks_, headers.getPathValue());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    callbacks_->sendLocalReply(Http::Code::NotFound, \"\", modify_headers, absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().RouteNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Determine if there is a direct response for the request.\n  const auto* direct_response = route_->directResponseEntry();\n  if (direct_response != nullptr) {\n    config_.stats_.rq_direct_response_.inc();\n    direct_response->rewritePathHeader(headers, !config_.suppress_envoy_headers_);\n    callbacks_->streamInfo().setRouteName(direct_response->routeName());\n    callbacks_->sendLocalReply(\n        direct_response->responseCode(), direct_response->responseBody(),\n        [this, direct_response,\n         &request_headers = headers](Http::ResponseHeaderMap& response_headers) -> void {\n          std::string new_path;\n          if (request_headers.Path()) {\n            new_path = direct_response->newPath(request_headers);\n          }\n          // See https://tools.ietf.org/html/rfc7231#section-7.1.2.\n          const auto add_location =\n              direct_response->responseCode() == Http::Code::Created ||\n              Http::CodeUtility::is3xx(enumToInt(direct_response->responseCode()));\n          if (!new_path.empty() && add_location) {\n            response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n          }\n          direct_response->finalizeResponseHeaders(response_headers, callbacks_->streamInfo());\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().DirectResponse);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // A route entry matches for the request.\n  route_entry_ = route_->routeEntry();\n  // If there's a route specific limit and it's smaller than general downstream\n  // limits, apply the new cap.\n  retry_shadow_buffer_limit_ =\n      std::min(retry_shadow_buffer_limit_, route_entry_->retryShadowBufferLimit());\n  callbacks_->streamInfo().setRouteName(route_entry_->routeName());\n  if (debug_config && debug_config->append_cluster_) {\n    // The cluster name will be appended to any local or upstream responses from this point.\n    modify_headers = [this, debug_config](Http::ResponseHeaderMap& headers) {\n      headers.addCopy(debug_config->cluster_header_.value_or(Http::Headers::get().EnvoyCluster),\n                      route_entry_->clusterName());\n    };\n  }\n  Upstream::ThreadLocalCluster* cluster =\n      config_.cm_.getThreadLocalCluster(route_entry_->clusterName());\n  if (!cluster) {\n    config_.stats_.no_cluster_.inc();\n    ENVOY_STREAM_LOG(debug, \"unknown cluster '{}'\", *callbacks_, route_entry_->clusterName());\n\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);\n    callbacks_->sendLocalReply(route_entry_->clusterNotFoundResponseCode(), \"\", modify_headers,\n                               absl::nullopt,\n                               StreamInfo::ResponseCodeDetails::get().ClusterNotFound);\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  cluster_ = cluster->info();\n\n  // Set up stat prefixes, etc.\n  request_vcluster_ = route_entry_->virtualCluster(headers);\n  if (request_vcluster_ != nullptr) {\n    callbacks_->streamInfo().setVirtualClusterName(request_vcluster_->name());\n  }\n  ENVOY_STREAM_LOG(debug, \"cluster '{}' match for URL '{}'\", *callbacks_,\n                   route_entry_->clusterName(), headers.getPathValue());\n\n  if (config_.strict_check_headers_ != nullptr) {\n    for (const auto& header : *config_.strict_check_headers_) {\n      const auto res = FilterUtility::StrictHeaderChecker::checkHeader(headers, header);\n      if (!res.valid_) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::InvalidEnvoyRequestHeaders);\n        const std::string body = fmt::format(\"invalid header '{}' with value '{}'\",\n                                             std::string(res.entry_->key().getStringView()),\n                                             std::string(res.entry_->value().getStringView()));\n        const std::string details =\n            absl::StrCat(StreamInfo::ResponseCodeDetails::get().InvalidEnvoyRequestHeaders, \"{\",\n                         StringUtil::replaceAllEmptySpace(res.entry_->key().getStringView()), \"}\");\n        callbacks_->sendLocalReply(Http::Code::BadRequest, body, nullptr, absl::nullopt, details);\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n    }\n  }\n\n  const Http::HeaderEntry* request_alt_name = headers.EnvoyUpstreamAltStatName();\n  if (request_alt_name) {\n    alt_stat_prefix_ = std::make_unique<Stats::StatNameDynamicStorage>(\n        request_alt_name->value().getStringView(), config_.scope_.symbolTable());\n    headers.removeEnvoyUpstreamAltStatName();\n  }\n\n  // See if we are supposed to immediately kill some percentage of this cluster's traffic.\n  if (cluster_->maintenanceMode()) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, true);\n    callbacks_->sendLocalReply(\n        Http::Code::ServiceUnavailable, \"maintenance mode\",\n        [modify_headers, this](Http::ResponseHeaderMap& headers) {\n          if (!config_.suppress_envoy_headers_) {\n            headers.addReference(Http::Headers::get().EnvoyOverloaded,\n                                 Http::Headers::get().EnvoyOverloadedValues.True);\n          }\n          // Note: append_cluster_info does not respect suppress_envoy_headers.\n          modify_headers(headers);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().MaintenanceMode);\n    cluster_->stats().upstream_rq_maintenance_mode_.inc();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Fetch a connection pool for the upstream cluster.\n  const auto& upstream_http_protocol_options = cluster_->upstreamHttpProtocolOptions();\n\n  if (upstream_http_protocol_options.has_value() &&\n      (upstream_http_protocol_options.value().auto_sni() ||\n       upstream_http_protocol_options.value().auto_san_validation())) {\n    // Default the header to Host/Authority header.\n    absl::string_view header_value = headers.getHostValue();\n\n    // Check whether `override_auto_sni_header` is specified.\n    const auto override_auto_sni_header =\n        upstream_http_protocol_options.value().override_auto_sni_header();\n    if (!override_auto_sni_header.empty()) {\n      // Use the header value from `override_auto_sni_header` to set the SNI value.\n      const auto overridden_header_value = Http::HeaderUtility::getAllOfHeaderAsString(\n          headers, Http::LowerCaseString(override_auto_sni_header));\n      if (overridden_header_value.result().has_value() &&\n          !overridden_header_value.result().value().empty()) {\n        header_value = overridden_header_value.result().value();\n      }\n    }\n    const auto parsed_authority = Http::Utility::parseAuthority(header_value);\n    bool should_set_sni = !parsed_authority.is_ip_address_;\n    // `host_` returns a string_view so doing this should be safe.\n    absl::string_view sni_value = parsed_authority.host_;\n\n    if (should_set_sni && upstream_http_protocol_options.value().auto_sni()) {\n      callbacks_->streamInfo().filterState()->setData(\n          Network::UpstreamServerName::key(),\n          std::make_unique<Network::UpstreamServerName>(sni_value),\n          StreamInfo::FilterState::StateType::Mutable);\n    }\n\n    if (upstream_http_protocol_options.value().auto_san_validation()) {\n      callbacks_->streamInfo().filterState()->setData(\n          Network::UpstreamSubjectAltNames::key(),\n          std::make_unique<Network::UpstreamSubjectAltNames>(\n              std::vector<std::string>{std::string(sni_value)}),\n          StreamInfo::FilterState::StateType::Mutable);\n    }\n  }\n\n  transport_socket_options_ = Network::TransportSocketOptionsUtility::fromFilterState(\n      *callbacks_->streamInfo().filterState());\n\n  if (auto downstream_connection = downstreamConnection(); downstream_connection != nullptr) {\n    if (auto typed_state = downstream_connection->streamInfo()\n                               .filterState()\n                               .getDataReadOnly<Network::UpstreamSocketOptionsFilterState>(\n                                   Network::UpstreamSocketOptionsFilterState::key());\n        typed_state != nullptr) {\n      auto downstream_options = typed_state->value();\n      if (!upstream_options_) {\n        upstream_options_ = std::make_shared<Network::Socket::Options>();\n      }\n      Network::Socket::appendOptions(upstream_options_, downstream_options);\n    }\n  }\n\n  if (upstream_options_ && callbacks_->getUpstreamSocketOptions()) {\n    Network::Socket::appendOptions(upstream_options_, callbacks_->getUpstreamSocketOptions());\n  }\n\n  std::unique_ptr<GenericConnPool> generic_conn_pool = createConnPool(*cluster);\n\n  if (!generic_conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n  Upstream::HostDescriptionConstSharedPtr host = generic_conn_pool->host();\n\n  if (debug_config && debug_config->append_upstream_host_) {\n    // The hostname and address will be appended to any local or upstream responses from this point,\n    // possibly in addition to the cluster name.\n    modify_headers = [modify_headers, debug_config, host](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->hostname_header_.value_or(Http::Headers::get().EnvoyUpstreamHostname),\n          host->hostname());\n      headers.addCopy(debug_config->host_address_header_.value_or(\n                          Http::Headers::get().EnvoyUpstreamHostAddress),\n                      host->address()->asString());\n    };\n  }\n\n  // If we've been instructed not to forward the request upstream, send an empty local response.\n  if (debug_config && debug_config->do_not_forward_) {\n    modify_headers = [modify_headers, debug_config](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n      headers.addCopy(\n          debug_config->not_forwarded_header_.value_or(Http::Headers::get().EnvoyNotForwarded),\n          \"true\");\n    };\n    callbacks_->sendLocalReply(Http::Code::NoContent, \"\", modify_headers, absl::nullopt, \"\");\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  hedging_params_ = FilterUtility::finalHedgingParams(*route_entry_, headers);\n\n  timeout_ = FilterUtility::finalTimeout(*route_entry_, headers, !config_.suppress_envoy_headers_,\n                                         grpc_request_, hedging_params_.hedge_on_per_try_timeout_,\n                                         config_.respect_expected_rq_timeout_);\n\n  const Http::HeaderEntry* header_max_stream_duration_entry =\n      headers.EnvoyUpstreamStreamDurationMs();\n  if (header_max_stream_duration_entry) {\n    dynamic_max_stream_duration_ =\n        FilterUtility::tryParseHeaderTimeout(*header_max_stream_duration_entry);\n    headers.removeEnvoyUpstreamStreamDurationMs();\n  }\n\n  // If this header is set with any value, use an alternate response code on timeout\n  if (headers.EnvoyUpstreamRequestTimeoutAltResponse()) {\n    timeout_response_code_ = Http::Code::NoContent;\n    headers.removeEnvoyUpstreamRequestTimeoutAltResponse();\n  }\n\n  include_attempt_count_in_request_ = route_entry_->includeAttemptCountInRequest();\n  if (include_attempt_count_in_request_) {\n    headers.setEnvoyAttemptCount(attempt_count_);\n  }\n\n  // The router has reached a point where it is going to try to send a request upstream,\n  // so now modify_headers should attach x-envoy-attempt-count to the downstream response if the\n  // config flag is true.\n  if (route_entry_->includeAttemptCountInResponse()) {\n    modify_headers = [modify_headers, this](Http::ResponseHeaderMap& headers) {\n      modify_headers(headers);\n\n      // This header is added without checking for config_.suppress_envoy_headers_ to mirror what is\n      // done for upstream requests.\n      headers.setEnvoyAttemptCount(attempt_count_);\n    };\n  }\n  callbacks_->streamInfo().setAttemptCount(attempt_count_);\n\n  // Inject the active span's tracing context into the request headers.\n  callbacks_->activeSpan().injectContext(headers);\n\n  route_entry_->finalizeRequestHeaders(headers, callbacks_->streamInfo(),\n                                       !config_.suppress_envoy_headers_);\n  FilterUtility::setUpstreamScheme(\n      headers, callbacks_->streamInfo().downstreamAddressProvider().sslConnection() != nullptr);\n\n  // Ensure an http transport scheme is selected before continuing with decoding.\n  ASSERT(headers.Scheme());\n\n  retry_state_ = createRetryState(\n      route_entry_->retryPolicy(), headers, *cluster_, request_vcluster_, config_.runtime_,\n      config_.random_, callbacks_->dispatcher(), config_.timeSource(), route_entry_->priority());\n\n  // Determine which shadow policies to use. It's possible that we don't do any shadowing due to\n  // runtime keys.\n  for (const auto& shadow_policy : route_entry_->shadowPolicies()) {\n    const auto& policy_ref = *shadow_policy;\n    if (FilterUtility::shouldShadow(policy_ref, config_.runtime_, callbacks_->streamId())) {\n      active_shadow_policies_.push_back(std::cref(policy_ref));\n    }\n  }\n\n  ENVOY_STREAM_LOG(debug, \"router decoding headers:\\n{}\", *callbacks_, headers);\n\n  // Hang onto the modify_headers function for later use in handling upstream responses.\n  modify_headers_ = modify_headers;\n\n  conn_pool_new_stream_with_early_data_and_http3_ =\n      Runtime::runtimeFeatureEnabled(Runtime::conn_pool_new_stream_with_early_data_and_http3);\n  const bool can_send_early_data = conn_pool_new_stream_with_early_data_and_http3_ &&\n                                   Http::Utility::isSafeRequest(*downstream_headers_);\n\n  UpstreamRequestPtr upstream_request =\n      std::make_unique<UpstreamRequest>(*this, std::move(generic_conn_pool), can_send_early_data,\n                                        /*can_use_http3=*/true);\n  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(end_stream);\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterHeadersStatus::StopIteration;\n}\n\nstd::unique_ptr<GenericConnPool>\nFilter::createConnPool(Upstream::ThreadLocalCluster& thread_local_cluster) {\n  GenericConnPoolFactory* factory = nullptr;\n  if (cluster_->upstreamConfig().has_value()) {\n    factory = Envoy::Config::Utility::getFactory<GenericConnPoolFactory>(\n        cluster_->upstreamConfig().value());\n    ENVOY_BUG(factory != nullptr,\n              fmt::format(\"invalid factory type '{}', failing over to default upstream\",\n                          cluster_->upstreamConfig().value().DebugString()));\n  }\n  if (!factory) {\n    factory = &config_.router_context_.genericConnPoolFactory();\n  }\n\n  bool should_tcp_proxy = false;\n\n  if (route_entry_->connectConfig().has_value()) {\n    auto method = downstream_headers_->getMethodValue();\n    should_tcp_proxy = (method == Http::Headers::get().MethodValues.Connect);\n\n    // Allow POST for proxying raw TCP if it is configured.\n    if (!should_tcp_proxy && route_entry_->connectConfig().value().allow_post()) {\n      should_tcp_proxy = (method == Http::Headers::get().MethodValues.Post);\n    }\n  }\n  return factory->createGenericConnPool(thread_local_cluster, should_tcp_proxy, *route_entry_,\n                                        callbacks_->streamInfo().protocol(), this);\n}\n\nvoid Filter::sendNoHealthyUpstreamResponse() {\n  callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);\n  chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, false);\n  callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, \"no healthy upstream\", modify_headers_,\n                             absl::nullopt,\n                             StreamInfo::ResponseCodeDetails::get().NoHealthyUpstream);\n}\n\nHttp::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n  // upstream_requests_.size() cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onRequestComplete(). It could be zero\n  // if the first request attempt has already failed and a retry is waiting for\n  // a backoff timer.\n  ASSERT(upstream_requests_.size() <= 1);\n\n  bool buffering = (retry_state_ && retry_state_->enabled()) || !active_shadow_policies_.empty() ||\n                   (route_entry_ && route_entry_->internalRedirectPolicy().enabled());\n  if (buffering &&\n      getLength(callbacks_->decodingBuffer()) + data.length() > retry_shadow_buffer_limit_) {\n    ENVOY_LOG(debug,\n              \"The request payload has at least {} bytes data which exceeds buffer limit {}. Give \"\n              \"up on the retry/shadow.\",\n              getLength(callbacks_->decodingBuffer()) + data.length(), retry_shadow_buffer_limit_);\n    cluster_->stats().retry_or_shadow_abandoned_.inc();\n    retry_state_.reset();\n    buffering = false;\n    active_shadow_policies_.clear();\n    request_buffer_overflowed_ = true;\n\n    // If we had to abandon buffering and there's no request in progress, abort the request and\n    // clean up. This happens if the initial upstream request failed, and we are currently waiting\n    // for a backoff timer before starting the next upstream attempt.\n    if (upstream_requests_.empty()) {\n      cleanup();\n      callbacks_->sendLocalReply(\n          Http::Code::InsufficientStorage, \"exceeded request buffer limit while retrying upstream\",\n          modify_headers_, absl::nullopt,\n          StreamInfo::ResponseCodeDetails::get().RequestPayloadExceededRetryBufferLimit);\n      return Http::FilterDataStatus::StopIterationNoBuffer;\n    }\n  }\n\n  // If we aren't buffering and there is no active request, an abort should have occurred\n  // already.\n  ASSERT(buffering || !upstream_requests_.empty());\n\n  if (buffering) {\n    // If we are going to buffer for retries or shadowing, we need to make a copy before encoding\n    // since it's all moves from here on.\n    if (!upstream_requests_.empty()) {\n      Buffer::OwnedImpl copy(data);\n      upstream_requests_.front()->encodeData(copy, end_stream);\n    }\n\n    // If we are potentially going to retry or shadow this request we need to buffer.\n    // This will not cause the connection manager to 413 because before we hit the\n    // buffer limit we give up on retries and buffering. We must buffer using addDecodedData()\n    // so that all buffered data is available by the time we do request complete processing and\n    // potentially shadow.\n    callbacks_->addDecodedData(data, true);\n  } else {\n    upstream_requests_.front()->encodeData(data, end_stream);\n  }\n\n  if (end_stream) {\n    onRequestComplete();\n  }\n\n  return Http::FilterDataStatus::StopIterationNoBuffer;\n}\n\nHttp::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap& trailers) {\n  ENVOY_STREAM_LOG(debug, \"router decoding trailers:\\n{}\", *callbacks_, trailers);\n\n  // upstream_requests_.size() cannot be > 1 because that only happens when a per\n  // try timeout occurs with hedge_on_per_try_timeout enabled but the per\n  // try timeout timer is not started until onRequestComplete(). It could be zero\n  // if the first request attempt has already failed and a retry is waiting for\n  // a backoff timer.\n  ASSERT(upstream_requests_.size() <= 1);\n  downstream_trailers_ = &trailers;\n  for (auto& upstream_request : upstream_requests_) {\n    upstream_request->encodeTrailers(trailers);\n  }\n  onRequestComplete();\n  return Http::FilterTrailersStatus::StopIteration;\n}\n\nHttp::FilterMetadataStatus Filter::decodeMetadata(Http::MetadataMap& metadata_map) {\n  Http::MetadataMapPtr metadata_map_ptr = std::make_unique<Http::MetadataMap>(metadata_map);\n  if (!upstream_requests_.empty()) {\n    // TODO(soya3129): Save metadata for retry, redirect and shadowing case.\n    upstream_requests_.front()->encodeMetadata(std::move(metadata_map_ptr));\n  }\n  return Http::FilterMetadataStatus::Continue;\n}\n\nvoid Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n  callbacks_ = &callbacks;\n  // As the decoder filter only pushes back via watermarks once data has reached\n  // it, it can latch the current buffer limit and does not need to update the\n  // limit if another filter increases it.\n  //\n  // The default is \"do not limit\". If there are configured (non-zero) buffer\n  // limits, apply them here.\n  if (callbacks_->decoderBufferLimit() != 0) {\n    retry_shadow_buffer_limit_ = callbacks_->decoderBufferLimit();\n  }\n}\n\nvoid Filter::cleanup() {\n  // All callers of cleanup() should have cleaned out the upstream_requests_\n  // list as appropriate.\n  ASSERT(upstream_requests_.empty());\n\n  retry_state_.reset();\n  if (response_timeout_) {\n    response_timeout_->disableTimer();\n    response_timeout_.reset();\n  }\n}\n\nvoid Filter::maybeDoShadowing() {\n  for (const auto& shadow_policy_wrapper : active_shadow_policies_) {\n    const auto& shadow_policy = shadow_policy_wrapper.get();\n\n    ASSERT(!shadow_policy.cluster().empty());\n    Http::RequestMessagePtr request(new Http::RequestMessageImpl(\n        Http::createHeaderMap<Http::RequestHeaderMapImpl>(*downstream_headers_)));\n    if (callbacks_->decodingBuffer()) {\n      request->body().add(*callbacks_->decodingBuffer());\n    }\n    if (downstream_trailers_) {\n      request->trailers(Http::createHeaderMap<Http::RequestTrailerMapImpl>(*downstream_trailers_));\n    }\n\n    auto options = Http::AsyncClient::RequestOptions()\n                       .setTimeout(timeout_.global_timeout_)\n                       .setParentSpan(callbacks_->activeSpan())\n                       .setChildSpanName(\"mirror\")\n                       .setSampled(shadow_policy.traceSampled());\n    config_.shadowWriter().shadow(shadow_policy.cluster(), std::move(request), options);\n  }\n}\n\nvoid Filter::onRequestComplete() {\n  // This should be called exactly once, when the downstream request has been received in full.\n  ASSERT(!downstream_end_stream_);\n  downstream_end_stream_ = true;\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  downstream_request_complete_time_ = dispatcher.timeSource().monotonicTime();\n\n  // Possible that we got an immediate reset.\n  if (!upstream_requests_.empty()) {\n    // Even if we got an immediate reset, we could still shadow, but that is a riskier change and\n    // seems unnecessary right now.\n    maybeDoShadowing();\n\n    if (timeout_.global_timeout_.count() > 0) {\n      response_timeout_ = dispatcher.createTimer([this]() -> void { onResponseTimeout(); });\n      response_timeout_->enableTimer(timeout_.global_timeout_);\n    }\n\n    for (auto& upstream_request : upstream_requests_) {\n      if (upstream_request->createPerTryTimeoutOnRequestComplete()) {\n        upstream_request->setupPerTryTimeout();\n      }\n    }\n  }\n}\n\nvoid Filter::onDestroy() {\n  // Reset any in-flight upstream requests.\n  resetAll();\n  cleanup();\n}\n\nvoid Filter::onResponseTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream timeout\", *callbacks_);\n\n  // Reset any upstream requests that are still in flight.\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n\n    // Don't do work for upstream requests we've already seen headers for.\n    if (upstream_request->awaitingHeaders()) {\n      cluster_->stats().upstream_rq_timeout_.inc();\n      if (request_vcluster_) {\n        request_vcluster_->stats().upstream_rq_timeout_.inc();\n      }\n\n      if (cluster_->timeoutBudgetStats().has_value()) {\n        // Cancel firing per-try timeout information, because the per-try timeout did not come into\n        // play when the global timeout was hit.\n        upstream_request->recordTimeoutBudget(false);\n      }\n\n      if (upstream_request->upstreamHost()) {\n        upstream_request->upstreamHost()->stats().rq_timeout_.inc();\n      }\n\n      // If this upstream request already hit a \"soft\" timeout, then it\n      // already recorded a timeout into outlier detection. Don't do it again.\n      if (!upstream_request->outlierDetectionTimeoutRecorded()) {\n        updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, *upstream_request,\n                               absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n      }\n\n      chargeUpstreamAbort(timeout_response_code_, false, *upstream_request);\n    }\n    upstream_request->resetStream();\n  }\n\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout,\n                         StreamInfo::ResponseCodeDetails::get().UpstreamTimeout);\n}\n\n// Called when the per try timeout is hit but we didn't reset the request\n// (hedge_on_per_try_timeout enabled).\nvoid Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          // Without any knowledge about what's going on in the connection pool, retry the request\n          // with the safest settings which is no early data but keep using or not using alt-svc as\n          // before. In this way, QUIC won't be falsely marked as broken.\n          doRetry(/*can_send_early_data*/ false, can_use_http3);\n        });\n\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried(true);\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}\n\nvoid Filter::onPerTryIdleTimeout(UpstreamRequest& upstream_request) {\n  onPerTryTimeoutCommon(upstream_request, cluster_->stats().upstream_rq_per_try_idle_timeout_,\n                        StreamInfo::ResponseCodeDetails::get().UpstreamPerTryIdleTimeout);\n}\n\nvoid Filter::onPerTryTimeout(UpstreamRequest& upstream_request) {\n  onPerTryTimeoutCommon(upstream_request, cluster_->stats().upstream_rq_per_try_timeout_,\n                        StreamInfo::ResponseCodeDetails::get().UpstreamPerTryTimeout);\n}\n\nvoid Filter::onPerTryTimeoutCommon(UpstreamRequest& upstream_request, Stats::Counter& error_counter,\n                                   const std::string& response_code_details) {\n  if (hedging_params_.hedge_on_per_try_timeout_) {\n    onSoftPerTryTimeout(upstream_request);\n    return;\n  }\n\n  error_counter.inc();\n  if (upstream_request.upstreamHost()) {\n    upstream_request.upstreamHost()->stats().rq_timeout_.inc();\n  }\n\n  upstream_request.resetStream();\n\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  chargeUpstreamAbort(timeout_response_code_, false, upstream_request);\n\n  // Remove this upstream request from the list now that we're done with it.\n  upstream_request.removeFromList(upstream_requests_);\n  onUpstreamTimeoutAbort(StreamInfo::ResponseFlag::UpstreamRequestTimeout, response_code_details);\n}\n\nvoid Filter::onStreamMaxDurationReached(UpstreamRequest& upstream_request) {\n  upstream_request.resetStream();\n\n  if (maybeRetryReset(Http::StreamResetReason::LocalReset, upstream_request)) {\n    return;\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n\n  callbacks_->streamInfo().setResponseFlag(\n      StreamInfo::ResponseFlag::UpstreamMaxStreamDurationReached);\n  // sendLocalReply may instead reset the stream if downstream_response_started_ is true.\n  callbacks_->sendLocalReply(\n      Http::Code::RequestTimeout, \"upstream max stream duration reached\", modify_headers_,\n      absl::nullopt, StreamInfo::ResponseCodeDetails::get().UpstreamMaxStreamDurationReached);\n}\n\nvoid Filter::updateOutlierDetection(Upstream::Outlier::Result result,\n                                    UpstreamRequest& upstream_request,\n                                    absl::optional<uint64_t> code) {\n  if (upstream_request.upstreamHost()) {\n    upstream_request.upstreamHost()->outlierDetector().putResult(result, code);\n  }\n}\n\nvoid Filter::chargeUpstreamAbort(Http::Code code, bool dropped, UpstreamRequest& upstream_request) {\n  if (downstream_response_started_) {\n    if (upstream_request.grpcRqSuccessDeferred()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n      config_.stats_.rq_reset_after_downstream_response_started_.inc();\n    }\n  } else {\n    Upstream::HostDescriptionConstSharedPtr upstream_host = upstream_request.upstreamHost();\n\n    chargeUpstreamCode(code, upstream_host, dropped);\n    // If we had non-5xx but still have been reset by backend or timeout before\n    // starting response, we treat this as an error. We only get non-5xx when\n    // timeout_response_code_ is used for code above, where this member can\n    // assume values such as 204 (NoContent).\n    if (upstream_host != nullptr && !Http::CodeUtility::is5xx(enumToInt(code))) {\n      upstream_host->stats().rq_error_.inc();\n    }\n  }\n}\n\nvoid Filter::onUpstreamTimeoutAbort(StreamInfo::ResponseFlag response_flags,\n                                    absl::string_view details) {\n  Upstream::ClusterTimeoutBudgetStatsOptRef tb_stats = cluster()->timeoutBudgetStats();\n  if (tb_stats.has_value()) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n        dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n    tb_stats->get().upstream_rq_timeout_budget_percent_used_.recordValue(\n        FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));\n  }\n\n  const absl::string_view body =\n      timeout_response_code_ == Http::Code::GatewayTimeout ? \"upstream request timeout\" : \"\";\n  onUpstreamAbort(timeout_response_code_, response_flags, body, false, details);\n}\n\nvoid Filter::onUpstreamAbort(Http::Code code, StreamInfo::ResponseFlag response_flags,\n                             absl::string_view body, bool dropped, absl::string_view details) {\n  // If we have not yet sent anything downstream, send a response with an appropriate status code.\n  // Otherwise just reset the ongoing response.\n  callbacks_->streamInfo().setResponseFlag(response_flags);\n  // This will destroy any created retry timers.\n  cleanup();\n  // sendLocalReply may instead reset the stream if downstream_response_started_ is true.\n  callbacks_->sendLocalReply(\n      code, body,\n      [dropped, this](Http::ResponseHeaderMap& headers) {\n        if (dropped && !config_.suppress_envoy_headers_) {\n          headers.addReference(Http::Headers::get().EnvoyOverloaded,\n                               Http::Headers::get().EnvoyOverloadedValues.True);\n        }\n        modify_headers_(headers);\n      },\n      absl::nullopt, details);\n}\n\nbool Filter::maybeRetryReset(Http::StreamResetReason reset_reason,\n                             UpstreamRequest& upstream_request) {\n  // We don't retry if we already started the response, don't have a retry policy defined,\n  // or if we've already retried this upstream request (currently only possible if a per\n  // try timeout occurred and hedge_on_per_try_timeout is enabled).\n  if (downstream_response_started_ || !retry_state_ || upstream_request.retried()) {\n    return false;\n  }\n  RetryState::Http3Used was_using_http3 = RetryState::Http3Used::Unknown;\n  if (conn_pool_new_stream_with_early_data_and_http3_ && upstream_request.hadUpstream()) {\n    was_using_http3 = (upstream_request.streamInfo().protocol().has_value() &&\n                       upstream_request.streamInfo().protocol().value() == Http::Protocol::Http3)\n                          ? RetryState::Http3Used::Yes\n                          : RetryState::Http3Used::No;\n  }\n  const RetryStatus retry_status = retry_state_->shouldRetryReset(\n      reset_reason, was_using_http3,\n      [this, can_send_early_data = upstream_request.upstreamStreamOptions().can_send_early_data_,\n       can_use_http3 =\n           upstream_request.upstreamStreamOptions().can_use_http3_](bool disable_http3) -> void {\n        // This retry might be because of ConnectionFailure of 0-RTT handshake. In this case, though\n        // the original request is retried with the same can_send_early_data setting, it will not be\n        // sent as early data by the underlying connection pool grid.\n        doRetry(can_send_early_data, disable_http3 ? false : can_use_http3);\n      });\n  if (retry_status == RetryStatus::Yes) {\n    runRetryOptionsPredicates(upstream_request);\n    pending_retries_++;\n\n    if (upstream_request.upstreamHost()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n\n    auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n    return true;\n  } else if (retry_status == RetryStatus::NoOverflow) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n  } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n  }\n\n  return false;\n}\n\nvoid Filter::onUpstreamReset(Http::StreamResetReason reset_reason,\n                             absl::string_view transport_failure_reason,\n                             UpstreamRequest& upstream_request) {\n  ENVOY_STREAM_LOG(debug, \"upstream reset: reset reason: {}, transport failure reason: {}\",\n                   *callbacks_, Http::Utility::resetReasonToString(reset_reason),\n                   transport_failure_reason);\n\n  // TODO: The reset may also come from upstream over the wire. In this case it should be\n  // treated as external origin error and distinguished from local origin error.\n  // This matters only when running OutlierDetection with split_external_local_origin_errors\n  // config param set to true.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginConnectFailed, upstream_request,\n                         absl::nullopt);\n\n  if (maybeRetryReset(reset_reason, upstream_request)) {\n    return;\n  }\n\n  const bool dropped = reset_reason == Http::StreamResetReason::Overflow;\n  const Http::Code error_code = (reset_reason == Http::StreamResetReason::ProtocolError)\n                                    ? Http::Code::BadGateway\n                                    : Http::Code::ServiceUnavailable;\n  chargeUpstreamAbort(error_code, dropped, upstream_request);\n  auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n    request_ptr->cleanUp();\n    callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n  }\n\n  // If there are other in-flight requests that might see an upstream response,\n  // don't return anything downstream.\n  if (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0) {\n    return;\n  }\n\n  const StreamInfo::ResponseFlag response_flags = streamResetReasonToResponseFlag(reset_reason);\n\n  const std::string body =\n      absl::StrCat(\"upstream connect error or disconnect/reset before headers. \",\n                   (is_retry_ ? \"retried and the latest \" : \"\"),\n                   \"reset reason: \", Http::Utility::resetReasonToString(reset_reason),\n                   !transport_failure_reason.empty() ? \", transport failure reason: \" : \"\",\n                   transport_failure_reason);\n  const std::string& basic_details =\n      downstream_response_started_ ? StreamInfo::ResponseCodeDetails::get().LateUpstreamReset\n                                   : StreamInfo::ResponseCodeDetails::get().EarlyUpstreamReset;\n  const std::string details = StringUtil::replaceAllEmptySpace(absl::StrCat(\n      basic_details, \"{\", Http::Utility::resetReasonToString(reset_reason),\n      transport_failure_reason.empty() ? \"\" : absl::StrCat(\",\", transport_failure_reason), \"}\"));\n  onUpstreamAbort(error_code, response_flags, body, dropped, details);\n}\n\nvoid Filter::onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {\n  if (retry_state_ && host) {\n    retry_state_->onHostAttempted(host);\n  }\n}\n\nStreamInfo::ResponseFlag\nFilter::streamResetReasonToResponseFlag(Http::StreamResetReason reset_reason) {\n  switch (reset_reason) {\n  case Http::StreamResetReason::ConnectionFailure:\n    return StreamInfo::ResponseFlag::UpstreamConnectionFailure;\n  case Http::StreamResetReason::ConnectionTermination:\n    return StreamInfo::ResponseFlag::UpstreamConnectionTermination;\n  case Http::StreamResetReason::LocalReset:\n  case Http::StreamResetReason::LocalRefusedStreamReset:\n    return StreamInfo::ResponseFlag::LocalReset;\n  case Http::StreamResetReason::Overflow:\n    return StreamInfo::ResponseFlag::UpstreamOverflow;\n  case Http::StreamResetReason::RemoteReset:\n  case Http::StreamResetReason::RemoteRefusedStreamReset:\n  case Http::StreamResetReason::ConnectError:\n    return StreamInfo::ResponseFlag::UpstreamRemoteReset;\n  case Http::StreamResetReason::ProtocolError:\n    return StreamInfo::ResponseFlag::UpstreamProtocolError;\n  case Http::StreamResetReason::OverloadManager:\n    return StreamInfo::ResponseFlag::OverloadManager;\n  }\n\n  PANIC_DUE_TO_CORRUPT_ENUM;\n}\n\nvoid Filter::handleNon5xxResponseHeaders(absl::optional<Grpc::Status::GrpcStatus> grpc_status,\n                                         UpstreamRequest& upstream_request, bool end_stream,\n                                         uint64_t grpc_to_http_status) {\n  // We need to defer gRPC success until after we have processed grpc-status in\n  // the trailers.\n  if (grpc_request_) {\n    if (end_stream) {\n      if (grpc_status && !Http::CodeUtility::is5xx(grpc_to_http_status)) {\n        upstream_request.upstreamHost()->stats().rq_success_.inc();\n      } else {\n        upstream_request.upstreamHost()->stats().rq_error_.inc();\n      }\n    } else {\n      upstream_request.grpcRqSuccessDeferred(true);\n    }\n  } else {\n    upstream_request.upstreamHost()->stats().rq_success_.inc();\n  }\n}\n\nvoid Filter::onUpstream1xxHeaders(Http::ResponseHeaderMapPtr&& headers,\n                                  UpstreamRequest& upstream_request) {\n  const uint64_t response_code = Http::Utility::getResponseStatus(*headers);\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);\n  ENVOY_STREAM_LOG(debug, \"upstream 1xx ({}).\", *callbacks_, response_code);\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  resetOtherUpstreams(upstream_request);\n\n  // Don't send retries after 100-Continue has been sent on. Arguably we could attempt to do a\n  // retry, assume the next upstream would also send an 100-Continue and swallow the second one\n  // but it's sketchy (as the subsequent upstream might not send a 100-Continue) and not worth\n  // the complexity until someone asks for it.\n  retry_state_.reset();\n\n  // We coalesce 1xx headers here, to prevent encoder filters and HCM from having to worry\n  // about this. This is done in the router filter, rather than UpstreamRequest, since we want to\n  // potentially coalesce across retries and multiple upstream requests in the future, even though\n  // we currently don't support retry after 1xx.\n  // It's plausible that this functionality might need to move to HCM in the future for internal\n  // redirects, but we would need to maintain the \"only call encode1xxHeaders() once\"\n  // invariant.\n  if (!downstream_1xx_headers_encoded_) {\n    downstream_1xx_headers_encoded_ = true;\n    callbacks_->encode1xxHeaders(std::move(headers));\n  }\n}\n\nvoid Filter::resetAll() {\n  while (!upstream_requests_.empty()) {\n    auto request_ptr = upstream_requests_.back()->removeFromList(upstream_requests_);\n    request_ptr->resetStream();\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n  }\n}\n\nvoid Filter::resetOtherUpstreams(UpstreamRequest& upstream_request) {\n  // Pop each upstream request on the list and reset it if it's not the one\n  // provided. At the end we'll move it back into the list.\n  UpstreamRequestPtr final_upstream_request;\n  while (!upstream_requests_.empty()) {\n    UpstreamRequestPtr upstream_request_tmp =\n        upstream_requests_.back()->removeFromList(upstream_requests_);\n    if (upstream_request_tmp.get() != &upstream_request) {\n      upstream_request_tmp->resetStream();\n      // TODO: per-host stat for hedge abandoned.\n      // TODO: cluster stat for hedge abandoned.\n    } else {\n      final_upstream_request = std::move(upstream_request_tmp);\n    }\n  }\n\n  ASSERT(final_upstream_request);\n  // Now put the final request back on this list.\n  LinkedList::moveIntoList(std::move(final_upstream_request), upstream_requests_);\n}\n\nvoid Filter::onUpstreamHeaders(uint64_t response_code, Http::ResponseHeaderMapPtr&& headers,\n                               UpstreamRequest& upstream_request, bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"upstream headers complete: end_stream={}\", *callbacks_, end_stream);\n\n  modify_headers_(*headers);\n  // When grpc-status appears in response headers, convert grpc-status to HTTP status code\n  // for outlier detection. This does not currently change any stats or logging and does not\n  // handle the case when an error grpc-status is sent as a trailer.\n  absl::optional<Grpc::Status::GrpcStatus> grpc_status;\n  uint64_t grpc_to_http_status = 0;\n  if (grpc_request_) {\n    grpc_status = Grpc::Common::getGrpcStatus(*headers);\n    if (grpc_status.has_value()) {\n      grpc_to_http_status = Grpc::Utility::grpcToHttpStatus(grpc_status.value());\n    }\n  }\n\n  if (grpc_status.has_value()) {\n    upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(grpc_to_http_status);\n  } else {\n    upstream_request.upstreamHost()->outlierDetector().putHttpResponseCode(response_code);\n  }\n\n  if (headers->EnvoyImmediateHealthCheckFail() != nullptr) {\n    upstream_request.upstreamHost()->healthChecker().setUnhealthy(\n        Upstream::HealthCheckHostMonitor::UnhealthyType::ImmediateHealthCheckFail);\n  }\n\n  bool could_not_retry = false;\n\n  // Check if this upstream request was already retried, for instance after\n  // hitting a per try timeout. Don't retry it if we already have.\n  if (retry_state_) {\n    if (upstream_request.retried()) {\n      // We already retried this request (presumably for a per try timeout) so\n      // we definitely won't retry it again. Check if we would have retried it\n      // if we could.\n      bool retry_as_early_data; // Not going to be used as we are not retrying.\n      could_not_retry = retry_state_->wouldRetryFromHeaders(*headers, *downstream_headers_,\n                                                            retry_as_early_data) !=\n                        RetryState::RetryDecision::NoRetry;\n    } else {\n      const RetryStatus retry_status = retry_state_->shouldRetryHeaders(\n          *headers, *downstream_headers_,\n          [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_,\n           had_early_data = upstream_request.upstreamStreamOptions().can_send_early_data_](\n              bool disable_early_data) -> void {\n            doRetry((disable_early_data ? false : had_early_data), can_use_http3);\n          });\n      if (retry_status == RetryStatus::Yes) {\n        runRetryOptionsPredicates(upstream_request);\n        pending_retries_++;\n        upstream_request.upstreamHost()->stats().rq_error_.inc();\n        Http::CodeStats& code_stats = httpContext().codeStats();\n        code_stats.chargeBasicResponseStat(\n            cluster_->statsScope(), config_.stats_.stat_names_.retry_,\n            static_cast<Http::Code>(response_code), exclude_http_code_stats_);\n\n        if (!end_stream || !upstream_request.encodeComplete()) {\n          upstream_request.resetStream();\n        }\n        auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n        if (Runtime::runtimeFeatureEnabled(\n                \"envoy.reloadable_features.allow_upstream_inline_write\")) {\n          request_ptr->cleanUp();\n          callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n        }\n        return;\n      } else if (retry_status == RetryStatus::NoOverflow) {\n        callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);\n        could_not_retry = true;\n      } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n        callbacks_->streamInfo().setResponseFlag(\n            StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);\n        could_not_retry = true;\n      }\n    }\n  }\n\n  if (route_entry_->internalRedirectPolicy().enabled() &&\n      route_entry_->internalRedirectPolicy().shouldRedirectForResponseCode(\n          static_cast<Http::Code>(response_code)) &&\n      setupRedirect(*headers)) {\n    return;\n    // If the redirect could not be handled, fail open and let it pass to the\n    // next downstream.\n  }\n\n  // Check if we got a \"bad\" response, but there are still upstream requests in\n  // flight awaiting headers or scheduled retries. If so, exit to give them a\n  // chance to return before returning a response downstream.\n  if (could_not_retry && (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0)) {\n    upstream_request.upstreamHost()->stats().rq_error_.inc();\n\n    // Reset the stream because there are other in-flight requests that we'll\n    // wait around for and we're not interested in consuming any body/trailers.\n    auto request_ptr = upstream_request.removeFromList(upstream_requests_);\n    request_ptr->resetStream();\n    if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.allow_upstream_inline_write\")) {\n      request_ptr->cleanUp();\n      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));\n    }\n    return;\n  }\n\n  // Make sure any retry timers are destroyed since we may not call cleanup() if end_stream is\n  // false.\n  if (retry_state_) {\n    retry_state_.reset();\n  }\n\n  // Only send upstream service time if we received the complete request and this is not a\n  // premature response.\n  if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n    Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n    MonotonicTime response_received_time = dispatcher.timeSource().monotonicTime();\n    std::chrono::milliseconds ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n        response_received_time - downstream_request_complete_time_);\n    if (!config_.suppress_envoy_headers_) {\n      headers->setEnvoyUpstreamServiceTime(ms.count());\n    }\n  }\n\n  upstream_request.upstreamCanary(\n      (headers->EnvoyUpstreamCanary() && headers->EnvoyUpstreamCanary()->value() == \"true\") ||\n      upstream_request.upstreamHost()->canary());\n  chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);\n  if (!Http::CodeUtility::is5xx(response_code)) {\n    handleNon5xxResponseHeaders(grpc_status, upstream_request, end_stream, grpc_to_http_status);\n  }\n\n  // Append routing cookies\n  for (const auto& header_value : downstream_set_cookies_) {\n    headers->addReferenceKey(Http::Headers::get().SetCookie, header_value);\n  }\n\n  // TODO(zuercher): If access to response_headers_to_add (at any level) is ever needed outside\n  // Router::Filter we'll need to find a better location for this work. One possibility is to\n  // provide finalizeResponseHeaders functions on the Router::Config and VirtualHost interfaces.\n  route_entry_->finalizeResponseHeaders(*headers, callbacks_->streamInfo());\n\n  downstream_response_started_ = true;\n  final_upstream_request_ = &upstream_request;\n  // Make sure that for request hedging, we end up with the correct final upstream info.\n  callbacks_->streamInfo().setUpstreamInfo(final_upstream_request_->streamInfo().upstreamInfo());\n  resetOtherUpstreams(upstream_request);\n  if (end_stream) {\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeHeaders(std::move(headers), end_stream,\n                            StreamInfo::ResponseCodeDetails::get().ViaUpstream);\n}\n\nvoid Filter::onUpstreamData(Buffer::Instance& data, UpstreamRequest& upstream_request,\n                            bool end_stream) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamData) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n  if (end_stream) {\n    // gRPC request termination without trailers is an error.\n    if (upstream_request.grpcRqSuccessDeferred()) {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n    onUpstreamComplete(upstream_request);\n  }\n\n  callbacks_->encodeData(data, end_stream);\n}\n\nvoid Filter::onUpstreamTrailers(Http::ResponseTrailerMapPtr&& trailers,\n                                UpstreamRequest& upstream_request) {\n  // This should be true because when we saw headers we either reset the stream\n  // (hence wouldn't have made it to onUpstreamTrailers) or all other in-flight\n  // streams.\n  ASSERT(upstream_requests_.size() == 1);\n\n  if (upstream_request.grpcRqSuccessDeferred()) {\n    absl::optional<Grpc::Status::GrpcStatus> grpc_status = Grpc::Common::getGrpcStatus(*trailers);\n    if (grpc_status &&\n        !Http::CodeUtility::is5xx(Grpc::Utility::grpcToHttpStatus(grpc_status.value()))) {\n      upstream_request.upstreamHost()->stats().rq_success_.inc();\n    } else {\n      upstream_request.upstreamHost()->stats().rq_error_.inc();\n    }\n  }\n\n  onUpstreamComplete(upstream_request);\n\n  callbacks_->encodeTrailers(std::move(trailers));\n}\n\nvoid Filter::onUpstreamMetadata(Http::MetadataMapPtr&& metadata_map) {\n  callbacks_->encodeMetadata(std::move(metadata_map));\n}\n\nvoid Filter::onUpstreamComplete(UpstreamRequest& upstream_request) {\n  if (!downstream_end_stream_) {\n    upstream_request.resetStream();\n  }\n  Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n  std::chrono::milliseconds response_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n      dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n\n  Upstream::ClusterTimeoutBudgetStatsOptRef tb_stats = cluster()->timeoutBudgetStats();\n  if (tb_stats.has_value()) {\n    tb_stats->get().upstream_rq_timeout_budget_percent_used_.recordValue(\n        FilterUtility::percentageOfTimeout(response_time, timeout_.global_timeout_));\n  }\n\n  if (config_.emit_dynamic_stats_ && !callbacks_->streamInfo().healthCheck() &&\n      DateUtil::timePointValid(downstream_request_complete_time_)) {\n    upstream_request.upstreamHost()->outlierDetector().putResponseTime(response_time);\n    const bool internal_request = Http::HeaderUtility::isEnvoyInternalRequest(*downstream_headers_);\n\n    Http::CodeStats& code_stats = httpContext().codeStats();\n    Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                             cluster_->statsScope(),\n                                             config_.empty_stat_name_,\n                                             response_time,\n                                             upstream_request.upstreamCanary(),\n                                             internal_request,\n                                             route_entry_->virtualHost().statName(),\n                                             request_vcluster_ ? request_vcluster_->statName()\n                                                               : config_.empty_stat_name_,\n                                             config_.zone_name_,\n                                             upstreamZone(upstream_request.upstreamHost())};\n\n    code_stats.chargeResponseTiming(info);\n\n    if (alt_stat_prefix_ != nullptr) {\n      Http::CodeStats::ResponseTimingInfo info{config_.scope_,\n                                               cluster_->statsScope(),\n                                               alt_stat_prefix_->statName(),\n                                               response_time,\n                                               upstream_request.upstreamCanary(),\n                                               internal_request,\n                                               config_.empty_stat_name_,\n                                               config_.empty_stat_name_,\n                                               config_.zone_name_,\n                                               upstreamZone(upstream_request.upstreamHost())};\n\n      code_stats.chargeResponseTiming(info);\n    }\n  }\n\n  upstream_request.removeFromList(upstream_requests_);\n  cleanup();\n}\n\nbool Filter::setupRedirect(const Http::ResponseHeaderMap& headers) {\n  ENVOY_STREAM_LOG(debug, \"attempting internal redirect\", *callbacks_);\n  const Http::HeaderEntry* location = headers.Location();\n\n  const uint64_t status_code = Http::Utility::getResponseStatus(headers);\n\n  // Redirects are not supported for streaming requests yet.\n  if (downstream_end_stream_ && (!request_buffer_overflowed_ || !callbacks_->decodingBuffer()) &&\n      location != nullptr &&\n      convertRequestHeadersForInternalRedirect(*downstream_headers_, *location, status_code) &&\n      callbacks_->recreateStream(&headers)) {\n    ENVOY_STREAM_LOG(debug, \"Internal redirect succeeded\", *callbacks_);\n    cluster_->stats().upstream_internal_redirect_succeeded_total_.inc();\n    return true;\n  }\n  // convertRequestHeadersForInternalRedirect logs failure reasons but log\n  // details for other failure modes here.\n  if (!downstream_end_stream_) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: request incomplete\", *callbacks_);\n  } else if (request_buffer_overflowed_) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: request body overflow\", *callbacks_);\n  } else if (location == nullptr) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: missing location header\", *callbacks_);\n  }\n\n  cluster_->stats().upstream_internal_redirect_failed_total_.inc();\n  return false;\n}\n\nbool Filter::convertRequestHeadersForInternalRedirect(Http::RequestHeaderMap& downstream_headers,\n                                                      const Http::HeaderEntry& internal_redirect,\n                                                      uint64_t status_code) {\n  if (!downstream_headers.Path()) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: no path in downstream_headers\", *callbacks_);\n    return false;\n  }\n\n  absl::string_view redirect_url = internal_redirect.value().getStringView();\n  // Make sure the redirect response contains a URL to redirect to.\n  if (redirect_url.empty()) {\n    config_.stats_.passthrough_internal_redirect_bad_location_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: empty location\", *callbacks_);\n    return false;\n  }\n  Http::Utility::Url absolute_url;\n  if (!absolute_url.initialize(redirect_url, false)) {\n    config_.stats_.passthrough_internal_redirect_bad_location_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: invalid location {}\", *callbacks_,\n                     redirect_url);\n    return false;\n  }\n\n  const auto& policy = route_entry_->internalRedirectPolicy();\n  // Don't change the scheme from the original request\n  const bool scheme_is_http = schemeIsHttp(downstream_headers, *callbacks_->connection());\n  const bool target_is_http = absolute_url.scheme() == Http::Headers::get().SchemeValues.Http;\n  if (!policy.isCrossSchemeRedirectAllowed() && scheme_is_http != target_is_http) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: incorrect scheme for {}\", *callbacks_,\n                     redirect_url);\n    config_.stats_.passthrough_internal_redirect_unsafe_scheme_.inc();\n    return false;\n  }\n\n  const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();\n  // Make sure that performing the redirect won't result in exceeding the configured number of\n  // redirects allowed for this route.\n  StreamInfo::UInt32Accessor* num_internal_redirect{};\n\n  if (num_internal_redirect = filter_state->getDataMutable<StreamInfo::UInt32Accessor>(\n          NumInternalRedirectsFilterStateName);\n      num_internal_redirect == nullptr) {\n    auto state = std::make_shared<StreamInfo::UInt32AccessorImpl>(0);\n    num_internal_redirect = state.get();\n\n    filter_state->setData(NumInternalRedirectsFilterStateName, std::move(state),\n                          StreamInfo::FilterState::StateType::Mutable,\n                          StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (num_internal_redirect->value() >= policy.maxInternalRedirects()) {\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: redirect limits exceeded.\", *callbacks_);\n    config_.stats_.passthrough_internal_redirect_too_many_redirects_.inc();\n    return false;\n  }\n  // Copy the old values, so they can be restored if the redirect fails.\n  const std::string original_host(downstream_headers.getHostValue());\n  const std::string original_path(downstream_headers.getPathValue());\n  const bool scheme_is_set = (downstream_headers.Scheme() != nullptr);\n  Cleanup restore_original_headers(\n      [&downstream_headers, original_host, original_path, scheme_is_set, scheme_is_http]() {\n        downstream_headers.setHost(original_host);\n        downstream_headers.setPath(original_path);\n        if (scheme_is_set) {\n          downstream_headers.setScheme(scheme_is_http ? Http::Headers::get().SchemeValues.Http\n                                                      : Http::Headers::get().SchemeValues.Https);\n        }\n      });\n\n  // Replace the original host, scheme and path.\n  downstream_headers.setScheme(absolute_url.scheme());\n  downstream_headers.setHost(absolute_url.hostAndPort());\n\n  auto path_and_query = absolute_url.pathAndQueryParams();\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.http_reject_path_with_fragment\")) {\n    // Envoy treats internal redirect as a new request and will reject it if URI path\n    // contains #fragment. However the Location header is allowed to have #fragment in URI path. To\n    // prevent Envoy from rejecting internal redirect, strip the #fragment from Location URI if it\n    // is present.\n    auto fragment_pos = path_and_query.find('#');\n    path_and_query = path_and_query.substr(0, fragment_pos);\n  }\n  downstream_headers.setPath(path_and_query);\n\n  callbacks_->clearRouteCache();\n  const auto route = callbacks_->route();\n  // Don't allow a redirect to a non existing route.\n  if (!route) {\n    config_.stats_.passthrough_internal_redirect_no_route_.inc();\n    ENVOY_STREAM_LOG(trace, \"Internal redirect failed: no route found\", *callbacks_);\n    return false;\n  }\n\n  const auto& route_name = route->directResponseEntry() ? route->directResponseEntry()->routeName()\n                                                        : route->routeEntry()->routeName();\n  for (const auto& predicate : policy.predicates()) {\n    if (!predicate->acceptTargetRoute(*filter_state, route_name, !scheme_is_http,\n                                      !target_is_http)) {\n      config_.stats_.passthrough_internal_redirect_predicate_.inc();\n      ENVOY_STREAM_LOG(trace,\n                       \"Internal redirect failed: rejecting redirect targeting {}, by {} predicate\",\n                       *callbacks_, route_name, predicate->name());\n      return false;\n    }\n  }\n\n  // See https://tools.ietf.org/html/rfc7231#section-6.4.4.\n  if (status_code == enumToInt(Http::Code::SeeOther) &&\n      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Get &&\n      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Head) {\n    downstream_headers.setMethod(Http::Headers::get().MethodValues.Get);\n    downstream_headers.remove(Http::Headers::get().ContentLength);\n    callbacks_->modifyDecodingBuffer([](Buffer::Instance& data) { data.drain(data.length()); });\n  }\n\n  num_internal_redirect->increment();\n  restore_original_headers.cancel();\n  // Preserve the original request URL for the second pass.\n  downstream_headers.setEnvoyOriginalUrl(absl::StrCat(scheme_is_http\n                                                          ? Http::Headers::get().SchemeValues.Http\n                                                          : Http::Headers::get().SchemeValues.Https,\n                                                      \"://\", original_host, original_path));\n  return true;\n}\n\nvoid Filter::runRetryOptionsPredicates(UpstreamRequest& retriable_request) {\n  for (const auto& options_predicate : route_entry_->retryPolicy().retryOptionsPredicates()) {\n    const Upstream::RetryOptionsPredicate::UpdateOptionsParameters parameters{\n        retriable_request.streamInfo(), upstreamSocketOptions()};\n    auto ret = options_predicate->updateOptions(parameters);\n    if (ret.new_upstream_socket_options_.has_value()) {\n      upstream_options_ = ret.new_upstream_socket_options_.value();\n    }\n  }\n}\n\nvoid Filter::doRetry(bool can_send_early_data, bool can_use_http3) {\n  ENVOY_STREAM_LOG(debug, \"performing retry\", *callbacks_);\n\n  is_retry_ = true;\n  attempt_count_++;\n  callbacks_->streamInfo().setAttemptCount(attempt_count_);\n  ASSERT(pending_retries_ > 0);\n  pending_retries_--;\n\n  // Clusters can technically get removed by CDS during a retry. Make sure it still exists.\n  const auto cluster = config_.cm_.getThreadLocalCluster(route_entry_->clusterName());\n  std::unique_ptr<GenericConnPool> generic_conn_pool;\n  if (cluster != nullptr) {\n    cluster_ = cluster->info();\n    generic_conn_pool = createConnPool(*cluster);\n  }\n\n  if (!generic_conn_pool) {\n    sendNoHealthyUpstreamResponse();\n    cleanup();\n    return;\n  }\n  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(\n      *this, std::move(generic_conn_pool), can_send_early_data, can_use_http3);\n\n  if (include_attempt_count_in_request_) {\n    downstream_headers_->setEnvoyAttemptCount(attempt_count_);\n  }\n\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.update_expected_rq_timeout_on_retry\")) {\n    // If not enabled, then it will re-use the previous headers (if any.)\n\n    // The request timeouts only account for time elapsed since the downstream request completed\n    // which might not have happened yet (in which case zero time has elapsed.)\n    std::chrono::milliseconds elapsed_time = std::chrono::milliseconds::zero();\n\n    if (DateUtil::timePointValid(downstream_request_complete_time_)) {\n      Event::Dispatcher& dispatcher = callbacks_->dispatcher();\n      elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(\n          dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);\n    }\n\n    FilterUtility::setTimeoutHeaders(elapsed_time.count(), timeout_, *route_entry_,\n                                     *downstream_headers_, !config_.suppress_envoy_headers_,\n                                     grpc_request_, hedging_params_.hedge_on_per_try_timeout_);\n  }\n\n  UpstreamRequest* upstream_request_tmp = upstream_request.get();\n  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);\n  upstream_requests_.front()->encodeHeaders(!callbacks_->decodingBuffer() &&\n                                            !downstream_trailers_ && downstream_end_stream_);\n  // It's possible we got immediately reset which means the upstream request we just\n  // added to the front of the list might have been removed, so we need to check to make\n  // sure we don't encodeData on the wrong request.\n  if (!upstream_requests_.empty() && (upstream_requests_.front().get() == upstream_request_tmp)) {\n    if (callbacks_->decodingBuffer()) {\n      // If we are doing a retry we need to make a copy.\n      Buffer::OwnedImpl copy(*callbacks_->decodingBuffer());\n      upstream_requests_.front()->encodeData(copy, !downstream_trailers_ && downstream_end_stream_);\n    }\n\n    if (downstream_trailers_) {\n      upstream_requests_.front()->encodeTrailers(*downstream_trailers_);\n    }\n  }\n}\n\nuint32_t Filter::numRequestsAwaitingHeaders() {\n  return std::count_if(upstream_requests_.begin(), upstream_requests_.end(),\n                       [](const auto& req) -> bool { return req->awaitingHeaders(); });\n}\n\nRetryStatePtr ProdFilter::createRetryState(const RetryPolicy& policy,\n                                           Http::RequestHeaderMap& request_headers,\n                                           const Upstream::ClusterInfo& cluster,\n                                           const VirtualCluster* vcluster, Runtime::Loader& runtime,\n                                           Random::RandomGenerator& random,\n                                           Event::Dispatcher& dispatcher, TimeSource& time_source,\n                                           Upstream::ResourcePriority priority) {\n  std::unique_ptr<RetryStateImpl> retry_state =\n      RetryStateImpl::create(policy, request_headers, cluster, vcluster, runtime, random,\n                             dispatcher, time_source, priority);\n  if (retry_state != nullptr && retry_state->isAutomaticallyConfiguredForHttp3()) {\n    // Since doing retry will make Envoy to buffer the request body, if upstream using HTTP/3 is the\n    // only reason for doing retry, set the retry shadow buffer limit to 0 so that we don't retry or\n    // buffer safe requests with body which is not common.\n    setRetryShadownBufferLimit(0);\n  }\n  return retry_state;\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#include <chrono>\n#include <cstdint>\n#include <functional>\n#include <string>\n\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/upstreams/http/generic/v3/generic_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/http/http/v3/http_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/http/tcp/v3/tcp_connection_pool.pb.h\"\n#include \"envoy/extensions/upstreams/tcp/generic/v3/generic_connection_pool.pb.h\"\n#include \"envoy/type/v3/percent.pb.h\"\n\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/config/metadata.h\"\n#include \"source/common/config/well_known_names.h\"\n#include \"source/common/http/context_impl.h\"\n#include \"source/common/network/application_protocol.h\"\n#include \"source/common/network/socket_option_factory.h\"\n#include \"source/common/network/upstream_server_name.h\"\n#include \"source/common/network/upstream_socket_options_filter_state.h\"\n#include \"source/common/network/upstream_subject_alt_names.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/common/network/win32_redirect_records_option_impl.h\"\n#include \"source/common/router/config_impl.h\"\n#include \"source/common/router/debug_config.h\"\n#include \"source/common/router/router.h\"\n#include \"source/common/stream_info/uint32_accessor_impl.h\"\n#include \"source/common/stream_info/utility.h\"\n#include \"source/common/tracing/http_tracer_impl.h\"\n#include \"source/common/upstream/upstream_impl.h\"\n\n#include \"test/common/http/common.h\"\n#include \"test/common/router/router_test_base.h\"\n#include \"test/mocks/http/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/router/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/tracing/mocks.h\"\n#include \"test/mocks/upstream/cluster_manager.h\"\n#include \"test/mocks/upstream/host.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/simulated_time_system.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing testing::_;\nusing testing::AtLeast;\nusing testing::Eq;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::MockFunction;\nusing testing::NiceMock;\nusing testing::Property;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Router {\n\n// Allows verifying the state of the upstream StreamInfo\nclass TestAccessLog : public AccessLog::Instance {\npublic:\n  explicit TestAccessLog(std::function<void(const StreamInfo::StreamInfo&)> func) : func_(func) {}\n\n  void log(const Http::RequestHeaderMap*, const Http::ResponseHeaderMap*,\n           const Http::ResponseTrailerMap*, const StreamInfo::StreamInfo& info) override {\n    func_(info);\n  }\n\nprivate:\n  std::function<void(const StreamInfo::StreamInfo&)> func_;\n};\n\nclass RouterTest : public RouterTestBase {\npublic:\n  RouterTest() : RouterTestBase(false, false, false, Protobuf::RepeatedPtrField<std::string>{}) {\n    EXPECT_CALL(callbacks_, activeSpan()).WillRepeatedly(ReturnRef(span_));\n  };\n\n  void testRequestResponseSize(bool with_trailers) {\n    NiceMock<Http::MockRequestEncoder> encoder;\n    Http::ResponseDecoder* response_decoder = nullptr;\n\n    EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n        .WillOnce(\n            Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                       const Http::ConnectionPool::Instance::StreamOptions& options)\n                       -> Http::ConnectionPool::Cancellable* {\n              EXPECT_FALSE(options.can_send_early_data_);\n              EXPECT_TRUE(options.can_use_http3_);\n              response_decoder = &decoder;\n              callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                    upstream_stream_info_, Http::Protocol::Http10);\n              return nullptr;\n            }));\n\n    cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n        absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n    envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n    cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n        .mutable_typed_config()\n        ->PackFrom(generic_config);\n    callbacks_.route_->route_entry_.connect_config_ =\n        absl::make_optional<RouteEntry::ConnectConfig>();\n\n    EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _));\n\n    Http::TestRequestHeaderMapImpl headers;\n    HttpTestUtility::addDefaultHeaders(headers);\n    headers.setMethod(\"POST\");\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_headers_size\"), 74ull));\n    router_.decodeHeaders(headers, false);\n\n    EXPECT_CALL(callbacks_.dispatcher_, createTimer_);\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_body_size\"), 5ull));\n    Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n    EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,\n              router_.decodeData(*body_data, !with_trailers));\n\n    if (with_trailers) {\n      Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n      router_.decodeTrailers(trailers);\n    }\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_headers_size\"), 10ull));\n    Http::ResponseHeaderMapPtr response_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n    // NOLINTNEXTLINE: Silence null pointer access warning\n    response_decoder->decodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(\n        cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n        deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_body_size\"), 7ull));\n    Buffer::OwnedImpl response_data(\"goodbye\");\n    // NOLINTNEXTLINE: Silence null pointer access warning\n    response_decoder->decodeData(response_data, !with_trailers);\n\n    if (with_trailers) {\n      Http::ResponseTrailerMapPtr response_trailers(\n          new Http::TestResponseTrailerMapImpl{{\"some-trailer\", \"13\"}});\n      // NOLINTNEXTLINE: Silence null pointer access warning\n      response_decoder->decodeTrailers(std::move(response_trailers));\n    }\n\n    router_.onDestroy();\n  }\n\n  void testAutoSniOptions(\n      absl::optional<envoy::config::core::v3::UpstreamHttpProtocolOptions> dummy_option,\n      Envoy::Http::TestRequestHeaderMapImpl headers, std::string server_name = \"host\",\n      bool should_validate_san = false, std::string alt_server_name = \"host\") {\n    NiceMock<StreamInfo::MockStreamInfo> stream_info;\n    ON_CALL(*cm_.thread_local_cluster_.cluster_.info_, upstreamHttpProtocolOptions())\n        .WillByDefault(ReturnRef(dummy_option));\n    ON_CALL(callbacks_.stream_info_, filterState())\n        .WillByDefault(ReturnRef(stream_info.filterState()));\n    EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n        .WillOnce(Return(&cancellable_));\n    stream_info.filterState()->setData(Network::UpstreamServerName::key(),\n                                       std::make_unique<Network::UpstreamServerName>(\"dummy\"),\n                                       StreamInfo::FilterState::StateType::Mutable);\n    expectResponseTimerCreate();\n\n    HttpTestUtility::addDefaultHeaders(headers);\n    router_.decodeHeaders(headers, true);\n    EXPECT_EQ(server_name,\n              stream_info.filterState()\n                  ->getDataReadOnly<Network::UpstreamServerName>(Network::UpstreamServerName::key())\n                  ->value());\n    if (should_validate_san) {\n      EXPECT_EQ(alt_server_name, stream_info.filterState()\n                                     ->getDataReadOnly<Network::UpstreamSubjectAltNames>(\n                                         Network::UpstreamSubjectAltNames::key())\n                                     ->value()[0]);\n    }\n    EXPECT_CALL(cancellable_, cancel(_));\n    router_.onDestroy();\n    EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n    EXPECT_EQ(0U,\n              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n    EXPECT_EQ(0U,\n              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  }\n};\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithoutHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithHostHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\":authority\");\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"foo.bar\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, server_name);\n}\n\nTEST_F(RouterTest, UpdateServerNameFilterStateWithEmptyValueHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", \"\"}};\n  testAutoSniOptions(dummy_option, headers);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithoutHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithHostHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\":authority\");\n\n  Http::TestRequestHeaderMapImpl headers{};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"foo.bar\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, server_name, true, server_name);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithEmptyValueHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", \"\"}};\n  testAutoSniOptions(dummy_option, headers, \"host\", true);\n}\n\nTEST_F(RouterTest, UpdateSubjectAltNamesFilterStateWithIpHeaderOverride) {\n  auto dummy_option = absl::make_optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>();\n  dummy_option.value().set_auto_sni(true);\n  dummy_option.value().set_auto_san_validation(true);\n  dummy_option.value().set_override_auto_sni_header(\"x-host\");\n\n  const auto server_name = \"127.0.0.1\";\n  Http::TestRequestHeaderMapImpl headers{{\"x-host\", server_name}};\n  testAutoSniOptions(dummy_option, headers, \"dummy\", true, server_name);\n}\n\nTEST_F(RouterTest, RouteNotFound) {\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(callbacks_, route()).WillOnce(Return(nullptr));\n\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.no_route\").value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"route_not_found\");\n}\n\nTEST_F(RouterTest, MissingRequiredHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.removeMethod();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, _))\n      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {\n        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);\n      }));\n  EXPECT_CALL(\n      callbacks_,\n      sendLocalReply(Http::Code::ServiceUnavailable,\n                     testing::Eq(\"missing required header: :method\"), _, _,\n                     \"filter_removed_required_request_headers{missing_required_header:_:method}\"))\n      .WillOnce(InvokeWithoutArgs([] {}));\n  router_.decodeHeaders(headers, true);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, ClusterNotFound) {\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  ON_CALL(cm_, getThreadLocalCluster(_)).WillByDefault(Return(nullptr));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.no_cluster\").value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"cluster_not_found\");\n}\n\nTEST_F(RouterTest, PoolFailureWithPriority) {\n  ON_CALL(callbacks_.route_->route_entry_, priority())\n      .WillByDefault(Return(Upstream::ResourcePriority::High));\n  EXPECT_CALL(cm_.thread_local_cluster_,\n              httpConnPool(Upstream::ResourcePriority::High, _, &router_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                \"tls version mismatch\", cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"139\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure, so upstream request was not initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(),\n            \"upstream_reset_before_response_started{connection_failure,tls_version_mismatch}\");\n}\n\nTEST_F(RouterTest, PoolFailureDueToConnectTimeout) {\n  ON_CALL(callbacks_.route_->route_entry_, priority())\n      .WillByDefault(Return(Upstream::ResourcePriority::High));\n  EXPECT_CALL(cm_.thread_local_cluster_,\n              httpConnPool(Upstream::ResourcePriority::High, _, &router_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::Timeout, \"connect_timeout\",\n                                cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"134\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure, so upstream request was not initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(),\n            \"upstream_reset_before_response_started{connection_failure,connect_timeout}\");\n}\n\nTEST_F(RouterTest, Http1Upstream) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, absl::optional<Http::Protocol>(), _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(callbacks_.route_->route_entry_, finalizeRequestHeaders(_, _, true));\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, Http2Upstream) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, absl::optional<Http::Protocol>(), _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashPolicy) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Return(absl::optional<uint64_t>(10)));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashPolicyNoHash) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Return(absl::optional<uint64_t>()));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, &router_))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_FALSE(context->computeHashKey());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, HashKeyNoHashPolicy) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy()).WillByDefault(Return(nullptr));\n  EXPECT_FALSE(router_.computeHashKey().has_value());\n}\n\nTEST_F(RouterTest, AddCookie) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  std::string cookie_value;\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        cookie_value = add_cookie(\"foo\", \"\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        EXPECT_EQ(\n            std::string{headers.get(Http::Headers::get().SetCookie)[0]->value().getStringView()},\n            \"foo=\\\"\" + cookie_value + \"\\\"; Max-Age=1337; HttpOnly\");\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_EQ(callbacks_.details(), \"via_upstream\");\n  // When the router filter gets reset we should cancel the pool request.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, AddCookieNoDuplicate) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        // this should be ignored\n        add_cookie(\"foo\", \"\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        EXPECT_EQ(\n            std::string{headers.get(Http::Headers::get().SetCookie)[0]->value().getStringView()},\n            \"foo=baz\");\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"set-cookie\", \"foo=baz\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  // When the router filter gets reset we should cancel the pool request.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, AddMultipleCookies) {\n  ON_CALL(callbacks_.route_->route_entry_, hashPolicy())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.hash_policy_));\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(10UL, context->computeHashKey().value());\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n\n  std::string choco_c, foo_c;\n  EXPECT_CALL(callbacks_.route_->route_entry_.hash_policy_, generateHash(_, _, _, _))\n      .WillOnce(Invoke([&](const Network::Address::Instance*, const Http::HeaderMap&,\n                           const Http::HashPolicy::AddCookieCallback add_cookie,\n                           const StreamInfo::FilterStateSharedPtr) {\n        choco_c = add_cookie(\"choco\", \"\", std::chrono::seconds(15));\n        foo_c = add_cookie(\"foo\", \"/path\", std::chrono::seconds(1337));\n        return absl::optional<uint64_t>(10);\n      }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](const Http::HeaderMap& headers, const bool) -> void {\n        MockFunction<void(const std::string&)> cb;\n        EXPECT_CALL(cb, Call(\"foo=\\\"\" + foo_c + \"\\\"; Max-Age=1337; Path=/path; HttpOnly\"));\n        EXPECT_CALL(cb, Call(\"choco=\\\"\" + choco_c + \"\\\"; Max-Age=15; HttpOnly\"));\n\n        headers.iterate([&cb](const Http::HeaderEntry& header) -> Http::HeaderMap::Iterate {\n          if (header.key() == Http::Headers::get().SetCookie.get()) {\n            cb.Call(std::string(header.value().getStringView()));\n          }\n          return Http::HeaderMap::Iterate::Continue;\n        });\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, MetadataNoOp) { EXPECT_EQ(nullptr, router_.metadataMatchCriteria()); }\n\nTEST_F(RouterTest, MetadataMatchCriteria) {\n  ON_CALL(callbacks_.route_->route_entry_, metadataMatchCriteria())\n      .WillByDefault(Return(&callbacks_.route_->route_entry_.metadata_matches_criteria_));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(context->metadataMatchCriteria(),\n                  &callbacks_.route_->route_entry_.metadata_matches_criteria_);\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, MetadataMatchCriteriaFromRequest) {\n  verifyMetadataMatchCriteriaFromRequest(true);\n}\n\nTEST_F(RouterTest, MetadataMatchCriteriaFromRequestNoRouteEntryMatch) {\n  verifyMetadataMatchCriteriaFromRequest(false);\n}\n\nTEST_F(RouterTest, NoMetadataMatchCriteria) {\n  ON_CALL(callbacks_.route_->route_entry_, metadataMatchCriteria()).WillByDefault(Return(nullptr));\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        EXPECT_EQ(context->metadataMatchCriteria(), nullptr);\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, CancelBeforeBoundToPool) {\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, NoHost) {\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _)).WillOnce(Return(absl::nullopt));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"19\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_maintenance_mode\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(callbacks_.details(), \"no_healthy_upstream\");\n}\n\nTEST_F(RouterTest, MaintenanceMode) {\n  EXPECT_CALL(*cm_.thread_local_cluster_.cluster_.info_, maintenanceMode()).WillOnce(Return(true));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"},\n                                                   {\"content-length\", \"16\"},\n                                                   {\"content-type\", \"text/plain\"},\n                                                   {\"x-envoy-overloaded\", \"true\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_maintenance_mode\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->load_report_stats_store_\n                    .counter(\"upstream_rq_dropped\")\n                    .value());\n  EXPECT_EQ(callbacks_.details(), \"maintenance_mode\");\n}\n\nTEST_F(RouterTest, ResponseCodeDetailsSetByUpstream) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate that x-envoy-upstream-service-time is added on a regular\n// request/response path.\nTEST_F(RouterTest, EnvoyUpstreamServiceTime) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, true))\n      .WillOnce(Invoke([](Http::HeaderMap& headers, bool) {\n        EXPECT_FALSE(headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty());\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate that x-envoy-attempt-count is added to request headers when the option is true.\nTEST_F(RouterTest, EnvoyAttemptCountInRequest) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ true,\n      /* preset_count*/ absl::nullopt,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is overwritten by the router on request headers, if the\n// header is sent from the downstream and the option is set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestOverwritten) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ true,\n      /* preset_count*/ 123,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is not overwritten by the router on request headers, if the\n// header is sent from the downstream and the option is set to false.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestNotOverwritten) {\n  verifyAttemptCountInRequestBasic(\n      /* set_include_attempt_count_in_request */ false,\n      /* preset_count*/ 123,\n      /* expected_count */ 123);\n}\n\nclass MockRetryOptionsPredicate : public Upstream::RetryOptionsPredicate {\npublic:\n  MOCK_METHOD(UpdateOptionsReturn, updateOptions, (const UpdateOptionsParameters& parameters),\n              (const));\n};\n\n// Also verify retry options predicates work.\nTEST_F(RouterTest, EnvoyAttemptCountInRequestUpdatedInRetries) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\n// Validate that x-envoy-attempt-count is added when option is true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponse) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ true,\n      /* preset_count */ absl::nullopt,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is overwritten by the router on response headers, if the\n// header is sent from the upstream and the option is set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseOverwritten) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ true,\n      /* preset_count */ 123,\n      /* expected_count */ 1);\n}\n\n// Validate that x-envoy-attempt-count is not overwritten by the router on response headers, if the\n// header is sent from the upstream and the option is not set to true.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseNotOverwritten) {\n  verifyAttemptCountInResponseBasic(\n      /* set_include_attempt_count_in_response */ false,\n      /* preset_count */ 123,\n      /* expected_count */ 123);\n}\n\n// Validate that x-envoy-attempt-count is present in local replies after an upstream attempt is\n// made.\nTEST_F(RouterTest, EnvoyAttemptCountInResponsePresentWithLocalReply) {\n  setIncludeAttemptCountInResponse(true);\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                absl::string_view(), cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"},\n                                                   {\"content-length\", \"91\"},\n                                                   {\"content-type\", \"text/plain\"},\n                                                   {\"x-envoy-attempt-count\", \"1\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  // Pool failure, so upstream request was never initiated.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_EQ(callbacks_.details(), \"upstream_reset_before_response_started{connection_failure}\");\n  EXPECT_EQ(1U, callbacks_.stream_info_.attemptCount().value());\n}\n\n// Validate that the x-envoy-attempt-count header in the downstream response reflects the number of\n// of upstream requests that occurred when retries take place.\nTEST_F(RouterTest, EnvoyAttemptCountInResponseWithRetries) {\n  setIncludeAttemptCountInResponse(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(1U, callbacks_.stream_info_.attemptCount().value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_EQ(2U, callbacks_.stream_info_.attemptCount().value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, true))\n      .WillOnce(Invoke([](Http::ResponseHeaderMap& headers, bool) {\n        // Because a retry happened the number of attempts in the response headers should be 2.\n        EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Append cluster with default header name.\nTEST_F(RouterTest, AppendCluster0) { testAppendCluster(absl::nullopt); }\n\n// Append cluster with custom header name.\nTEST_F(RouterTest, AppendCluster1) {\n  testAppendCluster(absl::make_optional(Http::LowerCaseString(\"x-custom-cluster\")));\n}\n\n// Append hostname and address with default header names.\nTEST_F(RouterTest, AppendUpstreamHost00) { testAppendUpstreamHost(absl::nullopt, absl::nullopt); }\n\n// Append hostname and address with custom host address header name.\nTEST_F(RouterTest, AppendUpstreamHost01) {\n  testAppendUpstreamHost(\n      absl::nullopt, absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-host-address\")));\n}\n\n// Append hostname and address with custom hostname header name.\nTEST_F(RouterTest, AppendUpstreamHost10) {\n  testAppendUpstreamHost(absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-hostname\")),\n                         absl::nullopt);\n}\n\n// Append hostname and address with custom header names.\nTEST_F(RouterTest, AppendUpstreamHost11) {\n  testAppendUpstreamHost(\n      absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-hostname\")),\n      absl::make_optional(Http::LowerCaseString(\"x-custom-upstream-host-address\")));\n}\n\n// Do not forward, with default not-forwarded header name\nTEST_F(RouterTest, DoNotForward0) { testDoNotForward(absl::nullopt); }\n\n// Do not forward, with custom not-forwarded header name\nTEST_F(RouterTest, DoNotForward1) {\n  testDoNotForward(absl::make_optional(Http::LowerCaseString(\"x-custom-not-forwarded\")));\n}\n\n// Validate that all DebugConfig options play nicely with each other.\nTEST_F(RouterTest, AllDebugConfig) {\n  auto debug_config = std::make_unique<DebugConfig>(\n      /* append_cluster */ true,\n      /* cluster_header */ absl::nullopt,\n      /* append_upstream_host */ true,\n      /* hostname_header */ absl::nullopt,\n      /* host_address_header */ absl::nullopt,\n      /* do_not_forward */ true,\n      /* not_forwarded_header */ absl::nullopt);\n  callbacks_.streamInfo().filterState()->setData(DebugConfig::key(), std::move(debug_config),\n                                                 StreamInfo::FilterState::StateType::ReadOnly,\n                                                 StreamInfo::FilterState::LifeSpan::FilterChain);\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"204\"},\n      {\"x-envoy-cluster\", \"fake_cluster\"},\n      {\"x-envoy-upstream-hostname\", \"scooby.doo\"},\n      {\"x-envoy-upstream-host-address\", \"10.0.0.5:9211\"},\n      {\"x-envoy-not-forwarded\", \"true\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, NoRetriesOverflow) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // RetryOverflow kicks in.\n  EXPECT_CALL(callbacks_.stream_info_, setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoOverflow));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\nTEST_F(RouterTest, ResetDuringEncodeHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(callbacks_, removeDownstreamWatermarkCallbacks(_));\n  EXPECT_CALL(callbacks_, addDownstreamWatermarkCallbacks(_));\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  // First connection is successful and reset happens later on.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, UpstreamTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_timeout_.value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verify the timeout budget histograms are filled out correctly when using a\n// global and per-try timeout in a successful request.\nTEST_F(RouterTest, TimeoutBudgetHistogramStat) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 20ull));\n  // Per-try budget used.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  40ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly when using a\n// global and per-try timeout in a failed request.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatFailure) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 20ull));\n  // Per-try budget used.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  40ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly when only using a global timeout.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatOnlyGlobal) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout budget used.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 40ull));\n  // Per-try budget used is zero out of an infinite timeout.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"), 0ull));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(80));\n  response_decoder->decodeData(data, true);\n}\n\n// Verify the timeout budget histograms are filled out correctly across retries.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatDuringRetries) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"100\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget used on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  100ull));\n  // Global timeout histogram does not fire on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), _))\n      .Times(0);\n\n  // Per-try timeout.\n  test_time_.advanceTimeWait(std::chrono::milliseconds(100));\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"504\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(504));\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget exhausted on the second try.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  100ull));\n  // Global timeout percentage used across both tries.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 50ull));\n\n  // Trigger second request failure.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder2.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  test_time_.advanceTimeWait(std::chrono::milliseconds(100));\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Verify the timeout budget histograms are filled out correctly when the global timeout occurs\n// during a retry.\nTEST_F(RouterTest, TimeoutBudgetHistogramStatDuringGlobalTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"400\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"320\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Per-try budget used on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"),\n                  50ull));\n  // Global timeout histogram does not fire on the first request.\n  EXPECT_CALL(cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n              deliverHistogramToSinks(\n                  Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), _))\n      .Times(0);\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  test_time_.advanceTimeWait(std::chrono::milliseconds(160));\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Global timeout was hit, fires 100.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_percent_used\"), 100ull));\n  // Per-try budget used on the second request won't fire because the global timeout was hit.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->timeout_budget_stats_store_,\n      deliverHistogramToSinks(\n          Property(&Stats::Metric::name, \"upstream_rq_timeout_budget_per_try_percent_used\"), _))\n      .Times(0);\n\n  // Trigger global timeout.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder2.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  test_time_.advanceTimeWait(std::chrono::milliseconds(240));\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Validate gRPC OK response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcOkTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"0\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC AlreadyExists response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcAlreadyExistsTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"6\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(409));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC Unavailable response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcOutlierDetectionUnavailableStatusCode) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"14\"}});\n  // Outlier detector will use the gRPC response status code.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC Internal response stats are sane when response is trailers only.\nTEST_F(RouterTest, GrpcInternalTrailersOnly) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"13\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC response stats are sane when response is ended in a DATA\n// frame.\nTEST_F(RouterTest, GrpcDataEndStream) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  Buffer::OwnedImpl data;\n  response_decoder->decodeData(data, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Validate gRPC response stats are sane when response is reset after initial\n// response HEADERS.\nTEST_F(RouterTest, GrpcReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.rq_reset_after_downstream_response_started\").value());\n}\n\n// Validate gRPC OK response stats are sane when response is not trailers only.\nTEST_F(RouterTest, GrpcOk) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.dispatcher_, pushTrackedObject(_));\n  EXPECT_CALL(callbacks_.dispatcher_, popTrackedObject(_));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  EXPECT_CALL(callbacks_.dispatcher_, pushTrackedObject(_));\n  EXPECT_CALL(callbacks_.dispatcher_, popTrackedObject(_));\n  Http::ResponseTrailerMapPtr response_trailers(\n      new Http::TestResponseTrailerMapImpl{{\"grpc-status\", \"0\"}});\n  response_decoder->decodeTrailers(std::move(response_trailers));\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\n// Validate gRPC Internal response stats are sane when response is not trailers only.\nTEST_F(RouterTest, GrpcInternal) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  Http::ResponseTrailerMapPtr response_trailers(\n      new Http::TestResponseTrailerMapImpl{{\"grpc-status\", \"13\"}});\n  response_decoder->decodeTrailers(std::move(response_trailers));\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, UpstreamTimeoutWithAltResponse) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-alt-response\", \"204\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"204\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(204)));\n  response_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_timeout\")\n                .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verify the upstream per try idle timeout.\nTEST_F(RouterTest, UpstreamPerTryIdleTimeout) {\n  InSequence s;\n\n  callbacks_.route_->route_entry_.retry_policy_.per_try_idle_timeout_ =\n      std::chrono::milliseconds(3000);\n\n  // This pattern helps ensure that we're actually invoking the callback.\n  bool filter_state_verified = false;\n  router_.config().upstream_logs_.push_back(\n      std::make_shared<TestAccessLog>([&](const auto& stream_info) {\n        filter_state_verified =\n            stream_info.hasResponseFlag(StreamInfo::ResponseFlag::StreamIdleTimeout);\n      }));\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_idle_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  EXPECT_CALL(*per_try_idle_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_, setResponseCodeDetails(\"upstream_per_try_idle_timeout\"));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  per_try_idle_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_idle_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  EXPECT_TRUE(filter_state_verified);\n}\n\n// Verify the upstream per try idle timeout gets reset in the success case.\nTEST_F(RouterTest, UpstreamPerTryIdleTimeoutSuccess) {\n  InSequence s;\n\n  callbacks_.route_->route_entry_.retry_policy_.per_try_idle_timeout_ =\n      std::chrono::milliseconds(3000);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_idle_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  response_decoder->decodeData(data, false);\n\n  EXPECT_CALL(*per_try_idle_timeout_, enableTimer(std::chrono::milliseconds(3000), _));\n  EXPECT_CALL(*per_try_idle_timeout_, disableTimer());\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  response_decoder->decodeData(data, true);\n}\n\n// Verifies that the per try timeout is initialized once the downstream request has been read.\nTEST_F(RouterTest, UpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  // We verify that both timeouts are started after decodeData(_, true) is called. This\n  // verifies that we are not starting the initial per try timeout on the first onPoolReady.\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Verifies that the per try timeout starts when onPoolReady is called when it occurs\n// after the downstream request has been read.\nTEST_F(RouterTest, UpstreamPerTryTimeoutDelayedPoolReady) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  // Global timeout starts when decodeData(_, true) is called.\n  expectResponseTimerCreate();\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Per try timeout starts when onPoolReady is called.\n  expectPerTryTimerCreate();\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Ensures that the per try callback is not set until the stream becomes available.\nTEST_F(RouterTest, UpstreamPerTryTimeoutExcludesNewStream) {\n  InSequence s;\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  Http::ConnectionPool::Callbacks* pool_callbacks;\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            pool_callbacks = &callbacks;\n            return nullptr;\n          }));\n\n  response_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*response_timeout_, enableTimer(_, _));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  per_try_timeout_ = new Event::MockTimer(&callbacks_.dispatcher_);\n  EXPECT_CALL(*per_try_timeout_, enableTimer(_, _));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  // The per try timeout timer should not be started yet.\n  pool_callbacks->onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  EXPECT_CALL(*per_try_timeout_, disableTimer());\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n  EXPECT_CALL(*response_timeout_, disableTimer());\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1UL, cm_.thread_local_cluster_.conn_pool_.host_->stats().rq_timeout_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Tests that a retry is sent after the first request hits the per try timeout, but then\n// headers received in response to the first request are still used (and the 2nd request\n// canceled). Also verify retry options predicates work.\nTEST_F(RouterTest, HedgedPerTryTimeoutFirstRequestSucceeds) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_));\n  per_try_timeout_->invokeCallback();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // We should not have updated any stats yet because no requests have been\n  // canceled\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::NoRetry));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Tests that an upstream request is reset even if it can't be retried as long as there is\n// another in-flight request we're waiting on.\n// Sequence:\n// 1) first upstream request per try timeout\n// 2) second upstream request sent\n// 3) second upstream request gets 5xx, retries exhausted, assert it's reset\n// 4) first upstream request gets 2xx\nTEST_F(RouterTest, HedgedPerTryTimeoutResetsOnBadHeaders) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // We should not have updated any stats yet because no requests have been\n  // canceled\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now write a 5xx back on the 2nd request with no retries remaining. The 2nd request\n  // should be reset immediately.\n  Http::ResponseHeaderMapPtr bad_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoOverflow));\n  // Not end_stream, otherwise we wouldn't need to reset.\n  ASSERT(response_decoder2);\n  response_decoder2->decodeHeaders(std::move(bad_response_headers), false);\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  response_decoder1->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Three requests sent: 1) 5xx error, 2) per try timeout, 3) gets good response\n// headers.\nTEST_F(RouterTest, HedgedPerTryTimeoutThirdRequestSucceeds) {\n  enableHedgeOnPerTryTimeout();\n\n  // Verify cluster request/response sizes are accounted for all requests/responses.\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_headers_size\"), 73ull))\n      .Times(3);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rq_body_size\"), 0ull))\n      .Times(3);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_headers_size\"), 10ull))\n      .Times(2);\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.cluster_.info_->request_response_size_stats_store_,\n      deliverHistogramToSinks(Property(&Stats::Metric::name, \"upstream_rs_body_size\"), 0ull))\n      .Times(2);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(111);\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n  expectPerTryTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  // Local origin connect success happens for first and third try.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHeadersRetry();\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(222);\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a per try timeout on the 2nd request, expect a 3rd\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  NiceMock<Http::MockRequestEncoder> encoder3;\n  Http::ResponseDecoder* response_decoder3 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder3 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            upstream_stream_info_.downstream_connection_info_provider_->setConnectionID(333);\n            callbacks.onPoolReady(encoder3, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  per_try_timeout_->invokeCallback();\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(3U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now write a 200 back. We expect the 2nd stream to be reset and stats to be\n  // incremented properly.\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(encoder3.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder3->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  EXPECT_EQ(333U, callbacks_.stream_info_.upstreamInfo()->upstreamConnectionId());\n\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// First request times out and is retried, and then a response is received.\n// Make sure we don't attempt to retry because we already retried for timeout.\nTEST_F(RouterTest, RetryOnlyOnceForSameUpstreamRequest) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n\n  // Now send a 5xx back and make sure we don't ask whether we should retry it.\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::RetryWithBackoff));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n\n  response_timeout_->invokeCallback();\n}\n\n// Sequence: upstream request hits soft per try timeout and is retried, and\n// then \"bad\" response headers come back before the retry has been scheduled.\n// Ensures that the \"bad\" headers are not sent downstream because there is\n// still an attempt pending.\nTEST_F(RouterTest, BadHeadersDroppedIfPreviousRetryScheduled) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  expectPerTryTimerCreate();\n\n  // Now send a 5xx back and make sure we don't ask whether we should retry it\n  // and also that we don't respond downstream with it.\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"500\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(500));\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, wouldRetryFromHeaders(_, _, _))\n      .WillOnce(Return(RetryState::RetryDecision::RetryWithBackoff));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n\n  // Now trigger the retry for the per try timeout earlier.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  router_.retry_state_->callback_();\n\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool end_stream) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n        EXPECT_TRUE(end_stream);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder2->decodeHeaders(std::move(response_headers2), true);\n}\n\n// Test retrying a request, when the first attempt fails before the client\n// has sent any of the body. Also verify retry options predicates work.\nTEST_F(RouterTest, RetryRequestBeforeBody) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body(\"body\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body), true));\n  Buffer::OwnedImpl buf(body);\n  router_.decodeData(buf, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body.\nTEST_F(RouterTest, RetryRequestDuringBody) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body2(\"body2\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body2), true));\n  Buffer::OwnedImpl buf2(body2);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf2, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with more data arriving in between upstream attempts\n// (which would normally happen during the backoff timer interval), but not end_stream.\nTEST_F(RouterTest, RetryRequestDuringBodyDataBetweenAttemptsNotEndStream) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(3).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  const std::string body2(\"body2\");\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, false);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1 + body2), false));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Complete request. Ensure original headers are present.\n  const std::string body3(\"body3\");\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body3), true));\n  Buffer::OwnedImpl buf3(body3);\n  router_.decodeData(buf3, true);\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the rest of the request arriving in between upstream\n// request attempts.\nTEST_F(RouterTest, RetryRequestDuringBodyCompleteBetweenAttempts) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(2).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  const std::string body2(\"body2\");\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, true);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1 + body2), true));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the trailers arriving in between upstream\n// request attempts.\nTEST_F(RouterTest, RetryRequestDuringBodyTrailerBetweenAttempts) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderHasValueRef(\"myheader\", \"present\"), false));\n  EXPECT_CALL(encoder2, encodeData(BufferStringEqual(body1), false));\n  EXPECT_CALL(encoder2, encodeTrailers(HeaderMapEqualRef(&trailers)));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Send successful response, verify success.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl({{\":status\", \"200\"}}));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test retrying a request, when the first attempt fails while the client\n// is sending the body, with the rest of the request arriving in between upstream\n// request attempts, but exceeding the buffer limit causing a downstream request abort.\nTEST_F(RouterTest, RetryRequestDuringBodyBufferLimitExceeded) {\n  Buffer::OwnedImpl decoding_buffer;\n  EXPECT_CALL(callbacks_, decodingBuffer()).WillRepeatedly(Return(&decoding_buffer));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) { decoding_buffer.move(data); }));\n  EXPECT_CALL(callbacks_.route_->route_entry_, retryShadowBufferLimit()).WillOnce(Return(10));\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{\n      {\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}, {\"myheader\", \"present\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  const std::string body1(\"body1\");\n  Buffer::OwnedImpl buf1(body1);\n  EXPECT_CALL(*router_.retry_state_, enabled()).Times(2).WillRepeatedly(Return(true));\n  router_.decodeData(buf1, false);\n\n  router_.retry_state_->expectResetRetry();\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // Complete request while there is no upstream request.\n  const std::string body2(50, 'a');\n  Buffer::OwnedImpl buf2(body2);\n  router_.decodeData(buf2, false);\n\n  EXPECT_EQ(callbacks_.details(), \"request_payload_exceeded_retry_buffer_limit\");\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"retry_or_shadow_abandoned\")\n                    .value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\n// Two requests are sent (slow request + hedged retry) and then global timeout\n// is hit. Verify everything gets cleaned up.\nTEST_F(RouterTest, HedgedPerTryTimeoutGlobalTimeout) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger global timeout, expect everything to be reset\n  EXPECT_CALL(encoder1.stream_, resetStream(_));\n  EXPECT_CALL(encoder2.stream_, resetStream(_));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"504\");\n      }));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n  EXPECT_EQ(2, cm_.thread_local_cluster_.conn_pool_.host_->stats_.rq_timeout_.value());\n  // TODO: Verify hedge stats here once they are implemented.\n}\n\n// Sequence: 1) per try timeout w/ hedge retry, 2) second request gets a 5xx\n// response, no retries remaining 3) first request gets a 5xx response.\nTEST_F(RouterTest, HedgingRetriesExhaustedBadResponse) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder1 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder2 = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger a 503 in response to the second request.\n  Http::ResponseHeaderMapPtr bad_response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _))\n      .WillOnce(Return(RetryStatus::NoRetryLimitExceeded));\n  ASSERT(response_decoder2);\n  response_decoder2->decodeHeaders(std::move(bad_response_headers1), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a 503 in response to the first request.\n  Http::ResponseHeaderMapPtr bad_response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n\n  // We should not call shouldRetryHeaders() because you never retry the same\n  // request twice.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"503\");\n      }));\n  response_decoder1->decodeHeaders(std::move(bad_response_headers2), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 2));\n}\n\n// Sequence: 1) per try timeout w/ hedge retry, 2) first request gets reset by upstream,\n// 3) 2nd request gets a 200 which should be sent downstream.\nTEST_F(RouterTest, HedgingRetriesProceedAfterReset) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder1, Http::Protocol::Http10);\n\n  // First is reset\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)))\n      .Times(2);\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder2, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n\n  // Now trigger an upstream reset in response to the first request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We should not call shouldRetryReset() because you never retry the same\n  // request twice.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n\n  // Now trigger a 200 in response to the second request.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder2->decodeHeaders(std::move(response_headers), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Sequence: 1) request with data hits per try timeout w/ hedge retry, 2)\n// second request is immediately reset 3) 1st request gets a 200.\n// The goal of this test is to ensure that the router can properly detect that an immediate\n// reset happens and that we don't accidentally write data twice on the first request.\nTEST_F(RouterTest, HedgingRetryImmediatelyReset) {\n  enableHedgeOnPerTryTimeout();\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  router_.retry_425_response_ = true;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                        absl::optional<uint64_t>(absl::nullopt)));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n  Buffer::OwnedImpl body(\"test body\");\n  EXPECT_CALL(encoder, encodeData(_, _));\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  router_.retry_state_->expectHedgedPerTryTimeoutRetry();\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, true));\n\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n      putResult(Upstream::Outlier::Result::LocalOriginTimeout, absl::optional<uint64_t>(504)));\n  EXPECT_CALL(encoder.stream_, resetStream(_)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _)).Times(0);\n  per_try_timeout_->invokeCallback();\n\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  // Per-timeout retry wouldn't enable 0-RTT.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions& options)\n                           -> Http::ConnectionPool::Cancellable* {\n        EXPECT_FALSE(options.can_send_early_data_);\n        EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n        EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                    putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n        callbacks.onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                absl::string_view(), cm_.thread_local_cluster_.conn_pool_.host_);\n        return nullptr;\n      }));\n  EXPECT_CALL(*router_.retry_state_,\n              shouldRetryReset(_, /*http3_used=*/RetryState::Http3Used::Unknown, _))\n      .WillOnce(Return(RetryStatus::NoRetryLimitExceeded));\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  router_.retry_state_->callback_();\n\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Now trigger a 200 in response to the first request.\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  // The request was already retried when the per try timeout occurred so it\n  // should't even consult the retry state.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _))\n      .WillOnce(Invoke([&](Http::ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(headers.Status()->value(), \"200\");\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  // Pool failure for the first try, so only 1 upstream request was made.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryNoneHealthy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::LocalReset);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _)).WillOnce(Return(absl::nullopt));\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"503\"}, {\"content-length\", \"19\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream));\n  router_.retry_state_->callback_();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Pool failure for the first try, so only 1 upstream request was made.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _));\n  Buffer::OwnedImpl body(\"test body\");\n  router_.decodeData(body, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(Http::StreamResetReason::RemoteReset, _, _))\n      .WillOnce(Invoke([this](const Http::StreamResetReason, RetryState::Http3Used http3_used,\n                              RetryState::DoRetryResetCallback callback) {\n        EXPECT_EQ(RetryState::Http3Used::No, http3_used);\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_http3=*/false); };\n        return RetryStatus::Yes;\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_use_http3_);\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryHttp3UpstreamReset) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  router_.retry_425_response_ = true;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http3);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _));\n  Buffer::OwnedImpl body(\"test body\");\n  router_.decodeData(body, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(Http::StreamResetReason::RemoteReset, _, _))\n      .WillOnce(Invoke([this](const Http::StreamResetReason, RetryState::Http3Used http3_used,\n                              RetryState::DoRetryResetCallback callback) {\n        EXPECT_EQ(RetryState::Http3Used::Yes, http3_used);\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_http3=*/true); };\n        return RetryStatus::Yes;\n      }));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_send_early_data_);\n            EXPECT_FALSE(options.can_use_http3_);\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, NoRetryWithBodyLimit) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  // Set a per route body limit which disallows any buffering.\n  EXPECT_CALL(callbacks_.route_->route_entry_, retryShadowBufferLimit()).WillOnce(Return(0));\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  // Unlike RetryUpstreamReset above the data won't be buffered as the body exceeds the buffer limit\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, _)).Times(0);\n  Buffer::OwnedImpl body(\"t\");\n  router_.decodeData(body, false);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\n// Verifies that when the request fails with an upstream reset (per try timeout in this case)\n// before an upstream host has been established, then the onHostAttempted function will not be\n// invoked. This ensures that we're not passing a null host to the retry plugins.\nTEST_F(RouterTest, RetryUpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  router_.retry_state_->expectResetRetry();\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginTimeout, _));\n  per_try_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n                        putResult(Upstream::Outlier::Result::LocalOriginConnectSuccess,\n                                  absl::optional<uint64_t>(absl::nullopt)));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  expectPerTryTimerCreate();\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  ASSERT(response_decoder);\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Asserts that onHostAttempted is *not* called when the upstream connection fails in such\n// a way that no host is present.\nTEST_F(RouterTest, RetryUpstreamConnectionFailure) {\n  Http::ConnectionPool::Callbacks* conn_pool_callbacks;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::StreamDecoder&, Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        conn_pool_callbacks = &callbacks;\n        return nullptr;\n      }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  EXPECT_CALL(*router_.retry_state_, onHostAttempted(_)).Times(0);\n\n  router_.retry_state_->expectResetRetry();\n\n  conn_pool_callbacks->onPoolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure,\n                                     absl::string_view(), nullptr);\n  // Pool failure, so no upstream request was made.\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseDecoder* response_decoder = nullptr;\n  // We expect this reset to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            EXPECT_CALL(*router_.retry_state_, onHostAttempted(_));\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, DontResetStartedResponseOnUpstreamPerTryTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectPerTryTimerCreate();\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Since the response is already started we don't retry.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, false));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  Buffer::OwnedImpl body(\"test body\");\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  per_try_timeout_->invokeCallback();\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_decoder->decodeData(body, true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_rq_per_try_timeout\")\n                    .value());\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamResetResponseStarted) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Since the response is already started we don't retry.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, false));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  // Normally, sendLocalReply will actually send the reply, but in this case the\n  // HCM will detect the headers have already been sent and not route through\n  // the encoder again.\n  EXPECT_CALL(callbacks_, sendLocalReply(_, _, _, _, _)).WillOnce(InvokeWithoutArgs([] {}));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  // For normal HTTP, once we have a 200 we consider this a success, even if a\n  // later reset occurs.\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// The router filter is responsible for not propagating 100-continue headers after the initial 100.\nTEST_F(RouterTest, Coalesce1xxHeaders) {\n  // Setup.\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Initial 100-continue, this is processed normally.\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_));\n  {\n    Http::ResponseHeaderMapPtr continue_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n    // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n    response_decoder->decode1xxHeaders(std::move(continue_headers));\n  }\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n\n  // No encode1xxHeaders() invocation for the second 100-continue (but we continue to track\n  // stats from upstream).\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_)).Times(0);\n  {\n    Http::ResponseHeaderMapPtr continue_headers(\n        new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n    // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n    response_decoder->decode1xxHeaders(std::move(continue_headers));\n  }\n  EXPECT_EQ(\n      2U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n\n  // Reset stream and cleanup.\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstreamReset1xxResponseStarted) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The 100-continue will result in resetting retry_state_, so when the stream\n  // is reset we won't even check shouldRetryReset() (or shouldRetryHeaders()).\n  EXPECT_CALL(*router_.retry_state_, shouldRetryReset(_, _, _)).Times(0);\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).Times(0);\n  EXPECT_CALL(callbacks_, encode1xxHeaders_(_));\n  Http::ResponseHeaderMapPtr continue_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"100\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decode1xxHeaders(std::move(continue_headers));\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_100\").value());\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putResult(Upstream::Outlier::Result::LocalOriginConnectFailed, _));\n  encoder1.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstream5xx) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelay) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Fire timeout.\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n}\n\nTEST_F(RouterTest, MaxStreamDurationValidlyConfiguredWithoutRetryPolicy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationDisabledIfSetToZero) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(0);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  // not to be called timer creation.\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationCallbackNotCalled) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(5000);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(5000));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationWhenDownstreamAlreadyStartedWithoutRetryPolicy) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, MaxStreamDurationWithRetryPolicy) {\n  // First upstream request\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"reset\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectResetRetry();\n  max_stream_duration_timer_->invokeCallback();\n\n  // Second upstream request\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  setUpstreamMaxStreamDuration(500);\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n  router_.retry_state_->callback_();\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelayWithUpstreamRequestNoHost) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  Envoy::ConnectionPool::MockCancellable cancellable;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks&,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        return &cancellable;\n      }));\n  router_.retry_state_->callback_();\n\n  // Fire timeout.\n  EXPECT_CALL(cancellable, cancel(_));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"504\"}, {\"content-length\", \"24\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // Timeout fired so no retry was done.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// Retry timeout during a retry delay leading to no upstream host, as well as an alt response code.\nTEST_F(RouterTest, RetryTimeoutDuringRetryDelayWithUpstreamRequestNoHostAltResponseCode) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-alt-response\", \"204\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  Envoy::ConnectionPool::MockCancellable cancellable;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks&,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        return &cancellable;\n      }));\n  router_.retry_state_->callback_();\n\n  // Fire timeout.\n  EXPECT_CALL(cancellable, cancel(_));\n  EXPECT_CALL(callbacks_.stream_info_,\n              setResponseFlag(StreamInfo::ResponseFlag::UpstreamRequestTimeout));\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_))\n      .Times(0);\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"204\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  response_timeout_->invokeCallback();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n  // no retry was done.\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, RetryUpstream5xxNotComplete) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_));\n  EXPECT_CALL(\n      cm_.thread_local_cluster_.conn_pool_.host_->health_checker_,\n      setUnhealthy(Upstream::HealthCheckHostMonitor::UnhealthyType::ImmediateHealthCheckFail));\n  Http::ResponseHeaderMapPtr response_headers2(new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"200\"}, {\"x-envoy-immediate-health-check-fail\", \"true\"}});\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"retry.upstream_rq_503\")\n                .value());\n  EXPECT_EQ(\n      1U,\n      cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"upstream_rq_200\").value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"zone.zone_name.to_az.upstream_rq_2xx\")\n                    .value());\n}\n\n// Validate gRPC Cancelled response stats are sane when retry is taking effect.\nTEST_F(RouterTest, RetryUpstreamGrpcCancelled) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-grpc-on\", \"cancelled\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"content-type\", \"application/grpc\"},\n                                         {\"grpc-timeout\", \"20S\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // gRPC with status \"cancelled\" (1)\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"1\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(499));\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the grpc-status to result in a retried request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}, {\"grpc-status\", \"0\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Verifies that the initial host is select with max host count of one, but during retries\n// RetryPolicy will be consulted.\nTEST_F(RouterTest, RetryRespectsMaxHostSelectionCount) {\n  router_.reject_all_hosts_ = true;\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  ON_CALL(*router_.retry_state_, hostSelectionMaxAttempts()).WillByDefault(Return(3));\n  // The router should accept any host at this point, since we're not in a retry.\n  EXPECT_EQ(1, router_.hostSelectionRetryCount());\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Now that we're triggered a retry, we should see the configured number of host selections.\n  EXPECT_EQ(3, router_.hostSelectionRetryCount());\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Verifies that the initial request accepts any host, but during retries\n// RetryPolicy will be consulted.\nTEST_F(RouterTest, RetryRespectsRetryHostPredicate) {\n  router_.reject_all_hosts_ = true;\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  NiceMock<Upstream::MockHost> host;\n  // The router should accept any host at this point, since we're not in a retry.\n  EXPECT_FALSE(router_.shouldSelectAnotherHost(host));\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(*router_.retry_state_, enabled()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(encoder1.stream_, resetStream(Http::StreamResetReason::LocalReset));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  response_decoder->decodeHeaders(std::move(response_headers1), false);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // We expect the 5xx response to kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  ON_CALL(callbacks_, decodingBuffer()).WillByDefault(Return(body_data.get()));\n  EXPECT_CALL(encoder2, encodeHeaders(_, false));\n  EXPECT_CALL(encoder2, encodeData(_, false));\n  EXPECT_CALL(encoder2, encodeTrailers(_));\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // Now that we're triggered a retry, we should see the router reject hosts.\n  EXPECT_TRUE(router_.shouldSelectAnotherHost(host));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWhenReachingMaxInternalRedirect) {\n  enableRedirects(3);\n  setNumPreviousRedirect(3);\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL,\n            stats_store_.counter(\"test.passthrough_internal_redirect_too_many_redirects\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithEmptyLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_bad_location\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithInvalidLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"h\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_bad_location\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithoutCompleteRequest) {\n  enableRedirects();\n  sendRequest(false);\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedWithoutLocation) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->removeLocation();\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  Buffer::OwnedImpl data(\"1234567890\");\n  response_decoder_->decodeData(data, true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n}\n\nTEST_F(RouterTest, InternalRedirectAcceptedWithRequestBody) {\n  enableRedirects();\n  sendRequest(false);\n\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"random_fake_data\"));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, true));\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  Buffer::OwnedImpl response_data(\"1234567890\");\n  response_decoder_->decodeData(response_data, false);\n  EXPECT_EQ(0U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(1, callbacks_.streamInfo()\n                   .filterState()\n                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n                   ->value());\n}\n\nTEST_F(RouterTest, CrossSchemeRedirectRejectedByPolicy) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"https://www.foo.com\");\n\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_unsafe_scheme\").value());\n}\n\nTEST_F(RouterTest, InternalRedirectRejectedByPredicate) {\n  enableRedirects();\n  sendRequest();\n\n  redirect_headers_->setLocation(\"http://www.foo.com/some/path\");\n\n  auto mock_predicate = std::make_shared<NiceMock<MockInternalRedirectPredicate>>();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_.route_->route_entry_.internal_redirect_policy_, predicates())\n      .WillOnce(Return(std::vector<InternalRedirectPredicateSharedPtr>({mock_predicate})));\n  EXPECT_CALL(*mock_predicate, acceptTargetRoute(_, _, _, _)).WillOnce(Return(false));\n  ON_CALL(*mock_predicate, name()).WillByDefault(Return(\"mock_predicate\"));\n  EXPECT_CALL(callbacks_, recreateStream(_)).Times(0);\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), true);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_failed_total\")\n                    .value());\n  EXPECT_EQ(1UL, stats_store_.counter(\"test.passthrough_internal_redirect_predicate\").value());\n\n  // Make sure the original host/path is preserved.\n  EXPECT_EQ(\"host\", default_request_headers_.getHostValue());\n  EXPECT_EQ(\"/\", default_request_headers_.getPathValue());\n  // Make sure x-envoy-original-url is not set for unsuccessful redirect.\n  EXPECT_EQ(nullptr, default_request_headers_.EnvoyOriginalUrl());\n}\n\nTEST_F(RouterTest, HttpInternalRedirectSucceeded) {\n  enableRedirects(3);\n  setNumPreviousRedirect(2);\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(3, callbacks_.streamInfo()\n                   .filterState()\n                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n                   ->value());\n}\n\nTEST_F(RouterTest, HttpInternalRedirectMatchedToDirectResponseSucceeded) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n\n  enableRedirects();\n  sendRequest();\n  EXPECT_CALL(callbacks_, clearRouteCache()).WillOnce(InvokeWithoutArgs([&]() -> void {\n    // Direct message route should be matched after internal redirect\n    EXPECT_CALL(*callbacks_.route_, routeEntry()).WillRepeatedly(Return(nullptr));\n    EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  }));\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(1, callbacks_.streamInfo()\n                   .filterState()\n                   ->getDataMutable<StreamInfo::UInt32Accessor>(\"num_internal_redirects\")\n                   ->value());\n}\n\nTEST_F(RouterTest, InternalRedirectStripsFragment) {\n  enableRedirects();\n  default_request_headers_.setForwardedProto(\"http\");\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  Http::ResponseHeaderMapPtr redirect_headers{new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"302\"}, {\"location\", \"http://www.foo.com/#fragment\"}}};\n  response_decoder_->decodeHeaders(std::move(redirect_headers), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(\"/\", default_request_headers_.getPathValue());\n}\n\nTEST_F(RouterTest, InternalRedirectKeepsFragmentWithOveride) {\n  TestScopedRuntime scoped_runtime;\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.http_reject_path_with_fragment\", \"false\"}});\n  enableRedirects();\n  default_request_headers_.setForwardedProto(\"http\");\n  sendRequest();\n\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  Http::ResponseHeaderMapPtr redirect_headers{new Http::TestResponseHeaderMapImpl{\n      {\":status\", \"302\"}, {\"location\", \"http://www.foo.com/#fragment\"}}};\n  response_decoder_->decodeHeaders(std::move(redirect_headers), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n  EXPECT_EQ(\"/#fragment\", default_request_headers_.getPathValue());\n}\n\nTEST_F(RouterTest, HttpsInternalRedirectSucceeded) {\n  auto ssl_connection = std::make_shared<Ssl::MockConnectionInfo>();\n  enableRedirects(3);\n  setNumPreviousRedirect(1);\n  default_request_headers_.setScheme(\"https\");\n\n  sendRequest();\n\n  redirect_headers_->setLocation(\"https://www.foo.com\");\n  EXPECT_CALL(connection_, ssl()).WillOnce(Return(ssl_connection));\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, CrossSchemeRedirectAllowedByPolicy) {\n  auto ssl_connection = std::make_shared<Ssl::MockConnectionInfo>();\n  enableRedirects();\n  default_request_headers_.setScheme(\"https\");\n\n  sendRequest();\n\n  redirect_headers_->setLocation(\"http://www.foo.com\");\n  EXPECT_CALL(connection_, ssl()).WillOnce(Return(ssl_connection));\n  EXPECT_CALL(callbacks_.route_->route_entry_.internal_redirect_policy_,\n              isCrossSchemeRedirectAllowed())\n      .WillOnce(Return(true));\n  EXPECT_CALL(callbacks_, clearRouteCache());\n  EXPECT_CALL(callbacks_, recreateStream(_)).WillOnce(Return(true));\n  response_decoder_->decodeHeaders(std::move(redirect_headers_), false);\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"upstream_internal_redirect_succeeded_total\")\n                    .value());\n\n  // In production, the HCM recreateStream would have called this.\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, Shadow) {\n  ShadowPolicyPtr policy = std::make_unique<TestShadowPolicy>(\"foo\", \"bar\");\n  callbacks_.route_->route_entry_.shadow_policies_.push_back(std::move(policy));\n  policy = std::make_unique<TestShadowPolicy>(\"fizz\", \"buzz\", envoy::type::v3::FractionalPercent(),\n                                              false);\n  callbacks_.route_->route_entry_.shadow_policies_.push_back(std::move(policy));\n  ON_CALL(callbacks_, streamId()).WillByDefault(Return(43));\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"bar\", 0, 43, 10000)).WillOnce(Return(true));\n  EXPECT_CALL(runtime_.snapshot_, featureEnabled(\"buzz\", 0, 43, 10000)).WillOnce(Return(true));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  Buffer::InstancePtr body_data(new Buffer::OwnedImpl(\"hello\"));\n  EXPECT_CALL(callbacks_, addDecodedData(_, true));\n  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, router_.decodeData(*body_data, false));\n\n  Http::TestRequestTrailerMapImpl trailers{{\"some\", \"trailer\"}};\n  EXPECT_CALL(callbacks_, decodingBuffer())\n      .Times(AtLeast(2))\n      .WillRepeatedly(Return(body_data.get()));\n  EXPECT_CALL(*shadow_writer_, shadow_(\"foo\", _, _))\n      .WillOnce(Invoke([](const std::string&, Http::RequestMessagePtr& request,\n                          const Http::AsyncClient::RequestOptions& options) -> void {\n        EXPECT_NE(request->body().length(), 0);\n        EXPECT_NE(nullptr, request->trailers());\n        EXPECT_EQ(absl::optional<std::chrono::milliseconds>(10), options.timeout);\n        EXPECT_TRUE(options.sampled_.value());\n      }));\n  EXPECT_CALL(*shadow_writer_, shadow_(\"fizz\", _, _))\n      .WillOnce(Invoke([](const std::string&, Http::RequestMessagePtr& request,\n                          const Http::AsyncClient::RequestOptions& options) -> void {\n        EXPECT_NE(request->body().length(), 0);\n        EXPECT_NE(nullptr, request->trailers());\n        EXPECT_EQ(absl::optional<std::chrono::milliseconds>(10), options.timeout);\n        EXPECT_FALSE(options.sampled_.value());\n      }));\n  router_.decodeTrailers(trailers);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n}\n\nTEST_F(RouterTest, AltStatName) {\n  // Also test no upstream timeout here.\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_, putResponseTime(_));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"true\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(1U,\n            stats_store_.counter(\"vhost.fake_vhost.vcluster.fake_virtual_cluster.upstream_rq_200\")\n                .value());\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n  EXPECT_EQ(\n      1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"alt_stat.upstream_rq_200\")\n              .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"alt_stat.zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n  EXPECT_EQ(1U, cm_.thread_local_cluster_.cluster_.info_->stats_store_\n                    .counter(\"alt_stat.zone.zone_name.to_az.upstream_rq_200\")\n                    .value());\n}\n\nTEST_F(RouterTest, Redirect) {\n  MockDirectResponseEntry direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"hello\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, rewritePathHeader(_, _));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::MovedPermanently));\n  EXPECT_CALL(direct_response, responseBody()).WillOnce(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(direct_response, finalizeResponseHeaders(_, _));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"301\"}, {\"location\", \"hello\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, RedirectFound) {\n  MockDirectResponseEntry direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"hello\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, rewritePathHeader(_, _));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::Found));\n  EXPECT_CALL(direct_response, responseBody()).WillOnce(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(direct_response, finalizeResponseHeaders(_, _));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"302\"}, {\"location\", \"hello\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, DirectResponse) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithBody) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  const std::string response_body(\"static response\");\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(response_body));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{\n      {\":status\", \"200\"}, {\"content-length\", \"15\"}, {\"content-type\", \"text/plain\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), false));\n  EXPECT_CALL(callbacks_, encodeData(_, true));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithLocation) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"http://host/\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::Created));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"201\"},\n                                                   {\"location\", \"http://host/\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\nTEST_F(RouterTest, DirectResponseWithoutLocation) {\n  NiceMock<MockDirectResponseEntry> direct_response;\n  std::string route_name(\"route-test-name\");\n  EXPECT_CALL(direct_response, newPath(_)).WillOnce(Return(\"http://host/\"));\n  EXPECT_CALL(direct_response, routeName()).WillOnce(ReturnRef(route_name));\n  EXPECT_CALL(direct_response, responseCode()).WillRepeatedly(Return(Http::Code::OK));\n  EXPECT_CALL(direct_response, responseBody()).WillRepeatedly(ReturnRef(EMPTY_STRING));\n  EXPECT_CALL(*callbacks_.route_, directResponseEntry()).WillRepeatedly(Return(&direct_response));\n  absl::string_view route_name_view(route_name);\n  EXPECT_CALL(callbacks_.stream_info_, setRouteName(route_name_view));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  EXPECT_CALL(callbacks_, encodeHeaders_(HeaderMapEqualRef(&response_headers), true));\n  EXPECT_CALL(span_, injectContext(_)).Times(0);\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n  EXPECT_FALSE(callbacks_.stream_info_.attemptCount().has_value());\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(1UL, config_.stats_.rq_direct_response_.value());\n}\n\n// Verifies that we propagate the upstream connection filter state to the upstream and downstream\n// request filter state.\nTEST_F(RouterTest, PropagatesUpstreamFilterState) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n\n  // This pattern helps ensure that we're actually invoking the callback.\n  bool filter_state_verified = false;\n  router_.config().upstream_logs_.push_back(\n      std::make_shared<TestAccessLog>([&](const auto& stream_info) {\n        filter_state_verified =\n            stream_info.upstreamInfo()->upstreamFilterState()->hasDataWithName(\"upstream data\");\n      }));\n\n  upstream_stream_info_.filterState()->setData(\n      \"upstream data\", std::make_unique<StreamInfo::UInt32AccessorImpl>(123),\n      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Connection);\n  expectResponseTimerCreate();\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_TRUE(filter_state_verified);\n  EXPECT_TRUE(callbacks_.streamInfo().upstreamInfo()->upstreamFilterState()->hasDataWithName(\n      \"upstream data\"));\n}\n\nTEST_F(RouterTest, UpstreamSSLConnection) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n\n  std::string session_id = \"D62A523A65695219D46FE1FFE285A4C371425ACE421B110B5B8D11D3EB4D5F0B\";\n  auto connection_info = std::make_shared<NiceMock<Ssl::MockConnectionInfo>>();\n  ON_CALL(*connection_info, sessionId()).WillByDefault(ReturnRef(session_id));\n  upstream_stream_info_.downstream_connection_info_provider_->setSslConnection(connection_info);\n\n  expectResponseTimerCreate();\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  ASSERT_NE(nullptr, callbacks_.streamInfo().upstreamInfo()->upstreamSslConnection());\n  EXPECT_EQ(session_id,\n            callbacks_.streamInfo().upstreamInfo()->upstreamSslConnection()->sessionId());\n  EXPECT_FALSE(callbacks_.streamInfo().upstreamInfo()->upstreamConnectionId().has_value());\n  EXPECT_FALSE(callbacks_.streamInfo().upstreamInfo()->upstreamInterfaceName().has_value());\n}\n\n// Verify that upstream timing information is set into the StreamInfo after the upstream\n// request completes.\nTEST_F(RouterTest, UpstreamTimingSingleRequest) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n  expectResponseTimerCreate();\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_.timeSystem(), nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n  EXPECT_EQ(nullptr, stream_info.upstreamInfo());\n\n  Http::TestRequestHeaderMapImpl headers{};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(32));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n  test_time_.advanceTimeWait(std::chrono::milliseconds(43));\n\n  // Upstream timing data is now available live.\n  ASSERT_NE(nullptr, stream_info.upstreamInfo());\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  response_decoder->decodeData(data, true);\n\n  // Now all these should be set.\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  // Timings should match our sleep() calls.\n  EXPECT_EQ(upstream_timing.last_upstream_rx_byte_received_.value() -\n                upstream_timing.first_upstream_rx_byte_received_.value(),\n            std::chrono::milliseconds(43));\n  EXPECT_EQ(upstream_timing.last_upstream_tx_byte_sent_.value() -\n                upstream_timing.first_upstream_tx_byte_sent_.value(),\n            std::chrono::milliseconds(32));\n}\n\n// Verify that upstream timing information is set into the StreamInfo when a\n// retry occurs (and not before).\nTEST_F(RouterTest, UpstreamTimingRetry) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_, nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n\n  // Check that upstream timing is updated after the first request.\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.retry_state_->expectHeadersRetry();\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(32));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(43));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::ResponseHeaderMapPtr bad_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(bad_response_headers), true);\n\n  router_.retry_state_->callback_();\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  MonotonicTime retry_time = test_time_.monotonicTime();\n\n  Http::ResponseHeaderMapPtr good_response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(good_response_headers), false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(153));\n\n  response_decoder->decodeData(data, true);\n\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  EXPECT_EQ(upstream_timing.last_upstream_rx_byte_received_.value() -\n                upstream_timing.first_upstream_rx_byte_received_.value(),\n            std::chrono::milliseconds(153));\n\n  // Time spent in upstream tx is 0 because we're using simulated time and\n  // don't have a good way to insert a \"sleep\" there, but values being present\n  // and equal to the time the retry was sent is good enough of a test.\n  StreamInfo::TimingUtility timing(stream_info);\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value() - timing.firstUpstreamTxByteSent().value(),\n            std::chrono::milliseconds(0));\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value() +\n                stream_info.startTimeMonotonic().time_since_epoch(),\n            retry_time.time_since_epoch());\n  EXPECT_EQ(timing.firstUpstreamTxByteSent().value() +\n                stream_info.startTimeMonotonic().time_since_epoch(),\n            retry_time.time_since_epoch());\n}\n\n// Verify that upstream timing information is set into the StreamInfo when a\n// global timeout occurs.\nTEST_F(RouterTest, UpstreamTimingTimeout) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  StreamInfo::StreamInfoImpl stream_info(test_time_, nullptr);\n  ON_CALL(callbacks_, streamInfo()).WillByDefault(ReturnRef(stream_info));\n\n  expectResponseTimerCreate();\n  test_time_.advanceTimeWait(std::chrono::milliseconds(10));\n\n  // Check that upstream timing is updated after the first request.\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"50\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  auto& upstream_timing = stream_info.upstreamInfo()->upstreamTiming();\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(13));\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(33));\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers), false);\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(99));\n  response_timeout_->invokeCallback();\n\n  EXPECT_TRUE(upstream_timing.first_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.last_upstream_tx_byte_sent_.has_value());\n  EXPECT_TRUE(upstream_timing.first_upstream_rx_byte_received_.has_value());\n  // False because no end_stream was seen.\n  EXPECT_FALSE(upstream_timing.last_upstream_rx_byte_received_.has_value());\n  StreamInfo::TimingUtility timing(stream_info);\n  EXPECT_EQ(timing.firstUpstreamTxByteSent().value(), std::chrono::milliseconds(10));\n  EXPECT_EQ(timing.lastUpstreamTxByteSent().value(), std::chrono::milliseconds(23));\n  EXPECT_EQ(timing.firstUpstreamRxByteReceived().value(), std::chrono::milliseconds(56));\n}\n\nTEST(RouterFilterUtilityTest, FinalHedgingParamsHedgeOnPerTryTimeout) {\n  Http::TestRequestHeaderMapImpl empty_headers;\n  { // route says true, header not present, expect true.\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams =\n        FilterUtility::finalHedgingParams(route, empty_headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header not present, expect false.\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams =\n        FilterUtility::finalHedgingParams(route, empty_headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header says true, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"true\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header says false, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"false\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header says false, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"false\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header says true, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"true\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says true, header is invalid, expect true.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"bad\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = true;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_TRUE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n  { // route says false, header is invalid, expect false.\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-hedge-on-per-try-timeout\", \"bad\"}};\n    NiceMock<MockRouteEntry> route;\n    route.hedge_policy_.hedge_on_per_try_timeout_ = false;\n    EXPECT_CALL(route, hedgePolicy).WillRepeatedly(ReturnRef(route.hedge_policy_));\n    FilterUtility::HedgingParams hedgingParams = FilterUtility::finalHedgingParams(route, headers);\n    EXPECT_FALSE(hedgingParams.hedge_on_per_try_timeout_);\n  }\n}\n\nTEST(RouterFilterUtilityTest, FinalTimeout) {\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"bad\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, true, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, true, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(7), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"7\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(10);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(0)));\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"10\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout()).WillRepeatedly(Return(absl::nullopt));\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(10), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1000), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"1000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(999), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"999m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"0m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(999), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"999m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    EXPECT_CALL(route, grpcTimeoutOffset())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"100m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(90), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(999)));\n    EXPECT_CALL(route, grpcTimeoutOffset())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1m\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"bad\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(1000), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_EQ(\"1000\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"1000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"15\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"15m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"5m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(7), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"7\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"7m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(0)));\n    route.retry_policy_.per_try_timeout_ = std::chrono::milliseconds(7);\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"1000m\"},\n                                           {\"x-envoy-upstream-rq-timeout-ms\", \"15\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"5\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(5), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"5\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"5m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, maxGrpcTimeout())\n        .WillRepeatedly(Return(absl::optional<std::chrono::milliseconds>(10000)));\n    Http::TestRequestHeaderMapImpl headers{{\"content-type\", \"application/grpc\"},\n                                           {\"grpc-timeout\", \"6666666666666H\"}};\n    FilterUtility::finalTimeout(route, headers, true, true, false, false);\n    EXPECT_EQ(\"10000\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_EQ(\"10000m\", headers.get_(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-expected-rq-timeout-ms\", \"8\"}};\n    // Make ingress envoy respect `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-expected-rq-timeout-ms\", \"8\"},\n                                           {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"4\"}};\n    // Make ingress envoy respect `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(4), timeout.per_try_timeout_);\n    EXPECT_EQ(\"4\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"8\"}};\n    // Test that ingress envoy populates `x-envoy-expected-rq-timeout-ms` header if it has not been\n    // set by egress envoy.\n    bool respect_expected_rq_timeout = true;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"8\"}};\n    // Make envoy override `x-envoy-expected-rq-timeout-ms` header.\n    // Test that ingress envoy sets `x-envoy-expected-rq-timeout-ms` header.\n    bool respect_expected_rq_timeout = false;\n    FilterUtility::TimeoutData timeout = FilterUtility::finalTimeout(\n        route, headers, true, false, false, respect_expected_rq_timeout);\n    EXPECT_EQ(std::chrono::milliseconds(8), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-per-try-timeout-ms\"));\n    EXPECT_EQ(\"8\", headers.get_(\"x-envoy-expected-rq-timeout-ms\"));\n    EXPECT_FALSE(headers.has(\"grpc-timeout\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, FinalTimeoutSupressEnvoyHeaders) {\n  {\n    NiceMock<MockRouteEntry> route;\n    EXPECT_CALL(route, timeout()).WillOnce(Return(std::chrono::milliseconds(10)));\n    Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-rq-timeout-ms\", \"15\"}};\n    FilterUtility::TimeoutData timeout =\n        FilterUtility::finalTimeout(route, headers, true, false, false, false);\n    EXPECT_EQ(std::chrono::milliseconds(15), timeout.global_timeout_);\n    EXPECT_EQ(std::chrono::milliseconds(0), timeout.per_try_timeout_);\n    EXPECT_FALSE(headers.has(\"x-envoy-upstream-rq-timeout-ms\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, SetUpstreamScheme) {\n  TestScopedRuntime scoped_runtime;\n\n  // With no scheme and x-forwarded-proto, set scheme based on encryption level\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::setUpstreamScheme(headers, false);\n    EXPECT_EQ(\"http\", headers.get_(\":scheme\"));\n  }\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n\n  // With invalid x-forwarded-proto, still use scheme.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setForwardedProto(\"foo\");\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n\n  // Use valid x-forwarded-proto.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setForwardedProto(Http::Headers::get().SchemeValues.Http);\n    FilterUtility::setUpstreamScheme(headers, true);\n    EXPECT_EQ(\"http\", headers.get_(\":scheme\"));\n  }\n\n  // Trust scheme over x-forwarded-proto.\n  {\n    Http::TestRequestHeaderMapImpl headers;\n    headers.setScheme(Http::Headers::get().SchemeValues.Https);\n    headers.setForwardedProto(Http::Headers::get().SchemeValues.Http);\n    FilterUtility::setUpstreamScheme(headers, false);\n    EXPECT_EQ(\"https\", headers.get_(\":scheme\"));\n  }\n}\n\nTEST(RouterFilterUtilityTest, ShouldShadow) {\n  {\n    TestShadowPolicy policy;\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(_, _, _, _)).Times(0);\n    EXPECT_FALSE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(_, _, _, _)).Times(0);\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\", \"foo\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(\"foo\", 0, 5, 10000)).WillOnce(Return(false));\n    EXPECT_FALSE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  {\n    TestShadowPolicy policy(\"cluster\", \"foo\");\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(runtime.snapshot_, featureEnabled(\"foo\", 0, 5, 10000)).WillOnce(Return(true));\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 5));\n  }\n  // Use default value instead of runtime key.\n  {\n    envoy::type::v3::FractionalPercent fractional_percent;\n    fractional_percent.set_numerator(5);\n    fractional_percent.set_denominator(envoy::type::v3::FractionalPercent::TEN_THOUSAND);\n    TestShadowPolicy policy(\"cluster\", \"foo\", fractional_percent);\n    NiceMock<Runtime::MockLoader> runtime;\n    EXPECT_CALL(\n        runtime.snapshot_,\n        featureEnabled(\"foo\", testing::Matcher<const envoy::type::v3::FractionalPercent&>(_), 3))\n        .WillOnce(Return(true));\n    EXPECT_TRUE(FilterUtility::shouldShadow(policy, runtime, 3));\n  }\n}\n\nTEST_F(RouterTest, CanaryStatusTrue) {\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  const absl::optional<std::string> virtual_cluster_name =\n      absl::optional<std::string>(\"fake_virtual_cluster\");\n  EXPECT_CALL(callbacks_.stream_info_, setVirtualClusterName(virtual_cluster_name));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"false\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  ON_CALL(*cm_.thread_local_cluster_.conn_pool_.host_, canary()).WillByDefault(Return(true));\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(1U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n}\n\nTEST_F(RouterTest, CanaryStatusFalse) {\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_(_)).Times(0);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-alt-stat-name\", \"alt_stat\"},\n                                         {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  const absl::optional<std::string> virtual_cluster_name =\n      absl::optional<std::string>(\"fake_virtual_cluster\");\n  EXPECT_CALL(callbacks_.stream_info_, setVirtualClusterName(virtual_cluster_name));\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"},\n                                          {\"x-envoy-upstream-canary\", \"false\"},\n                                          {\"x-envoy-virtual-cluster\", \"hello\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 0));\n\n  EXPECT_EQ(0U,\n            cm_.thread_local_cluster_.cluster_.info_->stats_store_.counter(\"canary.upstream_rq_200\")\n                .value());\n}\n\nTEST_F(RouterTest, AutoHostRewriteEnabled) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  std::string req_host{\"foo.bar.com\"};\n\n  Http::TestRequestHeaderMapImpl incoming_headers;\n  HttpTestUtility::addDefaultHeaders(incoming_headers);\n  incoming_headers.setHost(req_host);\n\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n  Http::TestRequestHeaderMapImpl outgoing_headers;\n  HttpTestUtility::addDefaultHeaders(outgoing_headers);\n  outgoing_headers.setHost(cm_.thread_local_cluster_.conn_pool_.host_->hostname_);\n  outgoing_headers.setForwardedHost(req_host);\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder_, Http::Protocol::Http10);\n\n  // :authority header in the outgoing request should match the DNS name of\n  // the selected upstream host\n  EXPECT_CALL(encoder, encodeHeaders(HeaderMapEqualRef(&outgoing_headers), true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, autoHostRewrite()).WillOnce(Return(true));\n  EXPECT_CALL(callbacks_.route_->route_entry_, appendXfh()).WillOnce(Return(true));\n  router_.decodeHeaders(incoming_headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, AutoHostRewriteDisabled) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  std::string req_host{\"foo.bar.com\"};\n\n  Http::TestRequestHeaderMapImpl incoming_headers;\n  HttpTestUtility::addDefaultHeaders(incoming_headers);\n  incoming_headers.setHost(req_host);\n\n  cm_.thread_local_cluster_.conn_pool_.host_->hostname_ = \"scooby.doo\";\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, timeout())\n      .WillOnce(Return(std::chrono::milliseconds(0)));\n\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder_, Http::Protocol::Http10);\n\n  // :authority header in the outgoing request should match the :authority header of\n  // the incoming request\n  EXPECT_CALL(encoder, encodeHeaders(HeaderMapEqualRef(&incoming_headers), true))\n      .WillOnce(Invoke([&](const Http::HeaderMap&, bool) -> Http::Status {\n        encoder.stream_.resetStream(Http::StreamResetReason::RemoteReset);\n        return Http::okStatus();\n      }));\n\n  EXPECT_CALL(callbacks_.route_->route_entry_, autoHostRewrite()).WillOnce(Return(false));\n  router_.decodeHeaders(incoming_headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\nTEST_F(RouterTest, UpstreamSocketOptionsReturnedEmpty) {\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(options.get(), nullptr);\n}\n\nTEST_F(RouterTest, IpTransparentOptions) {\n  Network::Socket::OptionsSharedPtr expected_options =\n      Network::SocketOptionFactory::buildIpTransparentOptions();\n  EXPECT_CALL(callbacks_, getUpstreamSocketOptions())\n      .Times(1)\n      .WillRepeatedly(Return(expected_options));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  router_.decodeHeaders(headers, false);\n\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(expected_options->size(), options->size());\n\n  for (size_t i = 0; i < 2; i++) {\n    NiceMock<Network::MockConnectionSocket> dummy_socket;\n    auto state = envoy::config::core::v3::SocketOption::STATE_PREBIND;\n    auto expected_details = expected_options->at(i)->getOptionDetails(dummy_socket, state);\n    auto returned_details = options->at(i)->getOptionDetails(dummy_socket, state);\n    EXPECT_TRUE(expected_details == returned_details);\n  }\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, RedirectRecords) {\n  auto redirect_records = std::make_shared<Network::Win32RedirectRecords>();\n  memcpy(redirect_records->buf_, reinterpret_cast<void*>(redirect_records_data_.data()),\n         redirect_records_data_.size());\n  redirect_records->buf_size_ = redirect_records_data_.size();\n  router_.downstream_connection_.stream_info_.filterState()->setData(\n      Network::UpstreamSocketOptionsFilterState::key(),\n      std::make_unique<Network::UpstreamSocketOptionsFilterState>(),\n      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n  router_.downstream_connection_.stream_info_.filterState()\n      ->getDataMutable<Network::UpstreamSocketOptionsFilterState>(\n          Network::UpstreamSocketOptionsFilterState::key())\n      ->addOption(Network::SocketOptionFactory::buildWFPRedirectRecordsOptions(*redirect_records));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  router_.decodeHeaders(headers, false);\n\n  Network::Socket::OptionsSharedPtr expected_options =\n      Network::SocketOptionFactory::buildWFPRedirectRecordsOptions(*redirect_records);\n  auto options = router_.upstreamSocketOptions();\n  EXPECT_EQ(1, options->size());\n\n  NiceMock<Network::MockConnectionSocket> dummy_socket;\n  auto state = envoy::config::core::v3::SocketOption::STATE_PREBIND;\n  auto expected_details = expected_options->at(0)->getOptionDetails(dummy_socket, state);\n  auto returned_details = options->at(0)->getOptionDetails(dummy_socket, state);\n  EXPECT_TRUE(expected_details == returned_details);\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, ApplicationProtocols) {\n  callbacks_.streamInfo().filterState()->setData(\n      Network::ApplicationProtocols::key(),\n      std::make_unique<Network::ApplicationProtocols>(std::vector<std::string>{\"foo\", \"bar\"}),\n      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::FilterChain);\n\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _))\n      .WillOnce(Invoke([&](Upstream::ResourcePriority, absl::optional<Http::Protocol>,\n                           Upstream::LoadBalancerContext* context) {\n        Network::TransportSocketOptionsConstSharedPtr transport_socket_options =\n            context->upstreamTransportSocketOptions();\n        EXPECT_NE(transport_socket_options, nullptr);\n        EXPECT_FALSE(transport_socket_options->applicationProtocolListOverride().empty());\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride().size(), 2);\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride()[0], \"foo\");\n        EXPECT_EQ(transport_socket_options->applicationProtocolListOverride()[1], \"bar\");\n        return Upstream::HttpPoolData([]() {}, &cm_.thread_local_cluster_.conn_pool_);\n      }));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Return(&cancellable_));\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  EXPECT_CALL(span_, injectContext(_));\n  router_.decodeHeaders(headers, true);\n\n  // When the router filter gets reset we should cancel the pool request.\n  EXPECT_CALL(cancellable_, cancel(_));\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n  EXPECT_EQ(0U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n}\n\n// Verify that CONNECT payload is not sent upstream until :200 response headers\n// are received.\nTEST_F(RouterTest, ConnectPauseAndResume) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, false));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  // Make sure any early data does not go upstream.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Now send the response headers, and ensure the deferred payload is proxied.\n  EXPECT_CALL(encoder, encodeData(_, _));\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\n// Invalid upstream will fail over to generic in opt mode, but crash in debug mode.\nTEST_F(RouterTest, InvalidUpstream) {\n  // Explicitly configure an HTTP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  // Configure a TCP upstream rather than an HTTP upstream.\n  envoy::extensions::upstreams::tcp::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  ON_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillByDefault(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions&)\n                     -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  EXPECT_ENVOY_BUG(router_.decodeHeaders(headers, false), \"envoy bug failure: factory != nullptr.\");\n\n  router_.onDestroy();\n}\n\n// Verify that CONNECT payload is not sent upstream if non-200 response headers are received.\nTEST_F(RouterTest, ConnectPauseNoResume) {\n  // Explicitly configure an HTTP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::http::v3::HttpConnectionPoolProto http_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(http_config);\n\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, false));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  // Make sure any early data does not go upstream.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Buffer::OwnedImpl data;\n  router_.decodeData(data, true);\n\n  // Now send the response headers, and ensure the deferred payload is not proxied.\n  EXPECT_CALL(encoder, encodeData(_, _)).Times(0);\n  Http::ResponseHeaderMapPtr response_headers(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"400\"}});\n  response_decoder->decodeHeaders(std::move(response_headers), true);\n}\n\nTEST_F(RouterTest, ConnectExplicitTcpUpstream) {\n  // Explicitly configure a TCP upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::tcp::v3::TcpConnectionPoolProto tcp_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(tcp_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n\n  // Make sure newConnection is called on the TCP pool, not newStream on the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_.tcp_conn_pool_, newConnection(_));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"CONNECT\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, PostExplicitTcpUpstream) {\n  // Explicitly configure a generic upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n  callbacks_.route_->route_entry_.connect_config_.value().set_allow_post(true);\n\n  // Make sure newConnection is called on the TCP pool, not newStream on the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_.tcp_conn_pool_, newConnection(_));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"POST\");\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, PostHttpUpstream) {\n  // Explicitly configure a generic upstream, to test factory creation.\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::generic::v3::GenericConnectionPoolProto generic_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(generic_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n\n  // Make sure POST request result in the HTTP pool.\n  EXPECT_CALL(cm_.thread_local_cluster_, httpConnPool(_, _, _));\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"POST\");\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}\n\nTEST_F(RouterTest, SetDynamicMaxStreamDuration) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder_, Http::Protocol::Http10);\n\n  expectMaxStreamDurationTimerCreate(std::chrono::milliseconds(500));\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-stream-duration-ms\", \"500\"}};\n\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n  max_stream_duration_timer_->invokeCallback();\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\nTEST_F(RouterTest, NotSetDynamicMaxStreamDurationIfZero) {\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder_, Http::Protocol::Http10);\n\n  // The timer will not be created.\n  EXPECT_CALL(callbacks_.dispatcher_, createTimer_).Times(0);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-upstream-stream-duration-ms\", \"0\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 0));\n}\n\n// Test that request/response header/body sizes are properly recorded.\nTEST_F(RouterTest, RequestResponseSize) { testRequestResponseSize(false); }\n\n// Test that request/response header/body sizes are properly recorded\n// when there are trailers in both the request/response.\nTEST_F(RouterTest, RequestResponseSizeWithTrailers) { testRequestResponseSize(true); }\n\nTEST_F(RouterTest, ExpectedUpstreamTimeoutUpdatedDuringRetries) {\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(50));\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  // We already used 50ms of our 200ms timeout before the retry was triggered\n  EXPECT_EQ(150, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\nTEST_F(RouterTest, ExpectedUpstreamTimeoutNotUpdatedDuringRetriesWhenRuntimeGuardDisabled) {\n  TestScopedRuntime scoped_runtime;\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"envoy.reloadable_features.update_expected_rq_timeout_on_retry\", \"false\"}});\n\n  auto retry_options_predicate = std::make_shared<MockRetryOptionsPredicate>();\n  callbacks_.route_->route_entry_.retry_policy_.retry_options_predicates_.emplace_back(\n      retry_options_predicate);\n\n  setIncludeAttemptCountInRequest(true);\n\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  expectNewStreamWithImmediateEncoder(encoder1, &response_decoder, Http::Protocol::Http10);\n\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"},\n                                         {\"x-envoy-internal\", \"true\"},\n                                         {\"x-envoy-upstream-rq-timeout-ms\", \"200\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n  router_.decodeHeaders(headers, true);\n  EXPECT_EQ(1U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  test_time_.advanceTimeWait(std::chrono::milliseconds(50));\n\n  // Initial request has 1 attempt.\n  EXPECT_EQ(1, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // 5xx response.\n  router_.retry_state_->expectHeadersRetry();\n  Upstream::RetryOptionsPredicate::UpdateOptionsReturn update_options_return{\n      std::make_shared<Network::Socket::Options>()};\n  EXPECT_CALL(*retry_options_predicate, updateOptions(_)).WillOnce(Return(update_options_return));\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(503));\n  // NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)\n  response_decoder->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Verify retry options predicate return values have been updated.\n  EXPECT_EQ(update_options_return.new_upstream_socket_options_.value(),\n            router_.upstreamSocketOptions());\n\n  // We expect the 5xx response to kick off a new request.\n  EXPECT_CALL(encoder1.stream_, resetStream(_)).Times(0);\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  expectNewStreamWithImmediateEncoder(encoder2, &response_decoder, Http::Protocol::Http10);\n\n  router_.retry_state_->callback_();\n  EXPECT_EQ(2U,\n            callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());\n\n  // The retry should cause the header to increase to 2.\n  EXPECT_EQ(2, atoi(std::string(headers.getEnvoyAttemptCountValue()).c_str()));\n  // We already used 50ms of our 200ms timeout before the retry was triggered,\n  // but with the guard disabled this should not change the header.\n  EXPECT_EQ(200, atoi(std::string(headers.getEnvoyExpectedRequestTimeoutMsValue()).c_str()));\n\n  // Normal response.\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->health_checker_, setUnhealthy(_))\n      .Times(0);\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_.host_->outlier_detector_,\n              putHttpResponseCode(200));\n  response_decoder->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n}\n\nTEST(RouterFilterUtilityTest, SetTimeoutHeaders) {\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"200\",\n              headers.get_(\n                  \"x-envoy-expected-rq-timeout-ms\")); // No per try configured, use global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"50\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"150\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Per try timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(25, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"150\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Per try timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"50\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(0);\n\n    FilterUtility::setTimeoutHeaders(300, timeout, route, headers, true, false, false);\n    EXPECT_EQ(\"1\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Over time\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(0, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"200\", headers.get_(\"x-envoy-expected-rq-timeout-ms\")); // Global timeout as hedged\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(25, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"175\", headers.get_(\n                         \"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout as hedged\n  }\n  {\n    NiceMock<MockRouteEntry> route;\n    Http::TestRequestHeaderMapImpl headers;\n    FilterUtility::TimeoutData timeout;\n    timeout.global_timeout_ = std::chrono::milliseconds(200);\n    timeout.per_try_timeout_ = std::chrono::milliseconds(150);\n\n    FilterUtility::setTimeoutHeaders(150, timeout, route, headers, true, false, true);\n    EXPECT_EQ(\"50\", headers.get_(\n                        \"x-envoy-expected-rq-timeout-ms\")); // Remains of global timeout as hedged\n  }\n}\n\nTEST_F(RouterTest, HasEarlyDataAndRetryUpon425) {\n  Http::TestRequestHeaderMapImpl headers;\n  // This is a GET request.\n  HttpTestUtility::addDefaultHeaders(headers);\n\n  router_.retry_425_response_ = true;\n  NiceMock<Http::MockRequestEncoder> encoder1;\n  Http::ResponseDecoder* response_decoder1 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_TRUE(options.can_use_http3_);\n            EXPECT_TRUE(options.can_send_early_data_);\n            response_decoder1 = &decoder;\n            callbacks.onPoolReady(encoder1, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n  EXPECT_CALL(encoder1, encodeHeaders(_, _));\n  router_.decodeHeaders(headers, true);\n\n  Http::ResponseHeaderMapPtr response_headers1(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"425\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, HeaderMapEqualRef(&headers), _))\n      .WillOnce(Invoke([this](const Http::ResponseHeaderMap&, const Http::RequestHeaderMap&,\n                              RetryState::DoRetryHeaderCallback callback) {\n        router_.retry_state_->callback_ = [callback]() { callback(/*disable_early_data=*/true); };\n        return RetryStatus::Yes;\n      }));\n  ASSERT(response_decoder1);\n  response_decoder1->decodeHeaders(std::move(response_headers1), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(0, 1));\n\n  // Expect retry upon 425 response.\n  NiceMock<Http::MockRequestEncoder> encoder2;\n  Http::ResponseDecoder* response_decoder2 = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(\n          Invoke([&](Http::ResponseDecoder& decoder, Http::ConnectionPool::Callbacks& callbacks,\n                     const Http::ConnectionPool::Instance::StreamOptions& options)\n                     -> Http::ConnectionPool::Cancellable* {\n            EXPECT_FALSE(options.can_send_early_data_);\n            EXPECT_TRUE(options.can_use_http3_);\n            response_decoder2 = &decoder;\n            callbacks.onPoolReady(encoder2, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  EXPECT_CALL(encoder2, encodeHeaders(HeaderMapEqualRef(&headers), _));\n  router_.retry_state_->callback_();\n\n  Http::ResponseHeaderMapPtr response_headers2(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  EXPECT_CALL(callbacks_, encodeHeaders_(_, _));\n  response_decoder2->decodeHeaders(std::move(response_headers2), true);\n  EXPECT_TRUE(verifyHostUpstreamStats(1, 1));\n}\n\n// Test the case that request with upstream override host.\nTEST_F(RouterTest, RequestWithUpstreamOverrideHost) {\n  NiceMock<Http::MockRequestEncoder> encoder_for_first_reqeust;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder,\n                           Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        callbacks.onPoolReady(encoder_for_first_reqeust, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n        return nullptr;\n      }));\n  expectResponseTimerCreate();\n\n  // Simulate the load balancer to call the `overrideHostToSelect`. When `overrideHostToSelect` of\n  // `LoadBalancerContext` is called, `upstreamOverrideHost` of StreamDecoderFilterCallbacks will be\n  // called to get address of upstream host that should be selected first.\n  EXPECT_CALL(callbacks_, upstreamOverrideHost())\n      .WillOnce(Return(absl::make_optional<absl::string_view>(\"1.2.3.4\")));\n\n  auto override_host = router_.overrideHostToSelect();\n  EXPECT_EQ(\"1.2.3.4\", override_host->first);\n  EXPECT_EQ(~static_cast<uint32_t>(0), override_host->second);\n\n  Http::TestRequestHeaderMapImpl headers{{\"x-envoy-retry-on\", \"5xx\"}, {\"x-envoy-internal\", \"true\"}};\n  HttpTestUtility::addDefaultHeaders(headers);\n\n  // Simulate the normal first request.\n  router_.decodeHeaders(headers, true);\n\n  // Mock response with status 503.\n  router_.retry_state_->expectHeadersRetry();\n  Http::ResponseHeaderMapPtr response_headers_503(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"503\"}});\n  ASSERT(response_decoder != nullptr);\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers_503), true);\n\n  // Kick off a new request.\n  NiceMock<Http::MockRequestEncoder> encoder_for_retry_request;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))\n      .WillOnce(Invoke([&](Http::ResponseDecoder& decoder,\n                           Http::ConnectionPool::Callbacks& callbacks,\n                           const Http::ConnectionPool::Instance::StreamOptions&)\n                           -> Http::ConnectionPool::Cancellable* {\n        response_decoder = &decoder;\n        callbacks.onPoolReady(encoder_for_retry_request, cm_.thread_local_cluster_.conn_pool_.host_,\n                              upstream_stream_info_, Http::Protocol::Http10);\n        return nullptr;\n      }));\n  router_.retry_state_->callback_();\n\n  // Simulate the load balancer to call the `overrideHostToSelect` again. The upstream override host\n  // will be ignored when the request is retried.\n  EXPECT_CALL(callbacks_, upstreamOverrideHost()).Times(0);\n  EXPECT_EQ(absl::nullopt, router_.overrideHostToSelect());\n\n  // Normal response.\n  Http::ResponseHeaderMapPtr response_headers_200(\n      new Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}});\n\n  EXPECT_CALL(*router_.retry_state_, shouldRetryHeaders(_, _, _)).WillOnce(Return(RetryStatus::No));\n  ASSERT(response_decoder != nullptr);\n  // NOLINTNEXTLINE: Silence null pointer access warning\n  response_decoder->decodeHeaders(std::move(response_headers_200), true);\n\n  EXPECT_EQ(2, callbacks_.stream_info_.attemptCount().value());\n\n  router_.onDestroy();\n}\n\n} // namespace Router\n} // namespace Envoy\n", "#include \"envoy/config/route/v3/route_components.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"test/integration/http_protocol_integration.h\"\n\nnamespace Envoy {\n\nusing ::testing::HasSubstr;\n\nnamespace {\nconstexpr char HandleThreeHopLocationFormat[] =\n    \"http://handle.internal.redirect.max.three.hop/path{}\";\nconstexpr char kTestHeaderKey[] = \"test-header\";\n} // namespace\n\nclass RedirectIntegrationTest : public HttpProtocolIntegrationTest {\npublic:\n  void initialize() override {\n    setMaxRequestHeadersKb(60);\n    setMaxRequestHeadersCount(100);\n    envoy::config::route::v3::RetryPolicy retry_policy;\n\n    auto pass_through = config_helper_.createVirtualHost(\"pass.through.internal.redirect\");\n    config_helper_.addVirtualHost(pass_through);\n\n    auto handle = config_helper_.createVirtualHost(\"handle.internal.redirect\");\n    handle.mutable_routes(0)->set_name(\"redirect\");\n    handle.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    config_helper_.addVirtualHost(handle);\n\n    auto handle_max_3_hop =\n        config_helper_.createVirtualHost(\"handle.internal.redirect.max.three.hop\");\n    handle_max_3_hop.mutable_routes(0)->set_name(\"max_three_hop\");\n    handle_max_3_hop.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    handle_max_3_hop.mutable_routes(0)\n        ->mutable_route()\n        ->mutable_internal_redirect_policy()\n        ->mutable_max_internal_redirects()\n        ->set_value(3);\n    config_helper_.addVirtualHost(handle_max_3_hop);\n\n    auto handle_by_direct_response = config_helper_.createVirtualHost(\"handle.direct.response\");\n    handle_by_direct_response.mutable_routes(0)->set_name(\"direct_response\");\n    handle_by_direct_response.mutable_routes(0)->mutable_direct_response()->set_status(204);\n    handle_by_direct_response.mutable_routes(0)\n        ->mutable_direct_response()\n        ->mutable_body()\n        ->set_inline_string(EMPTY_STRING);\n    config_helper_.addVirtualHost(handle_by_direct_response);\n\n    HttpProtocolIntegrationTest::initialize();\n  }\n\nprotected:\n  // Returns the next stream that the fake upstream receives.\n  FakeStreamPtr waitForNextStream() {\n    FakeStreamPtr new_stream = nullptr;\n    auto wait_new_stream_fn = [this,\n                               &new_stream](FakeHttpConnectionPtr& connection) -> AssertionResult {\n      AssertionResult result =\n          connection->waitForNewStream(*dispatcher_, new_stream, std::chrono::milliseconds(50));\n      if (result) {\n        ASSERT(new_stream);\n      }\n      return result;\n    };\n\n    // Using a while loop to poll for new connections and new streams on all\n    // connections because connection reuse may or may not be triggered.\n    while (new_stream == nullptr) {\n      FakeHttpConnectionPtr new_connection = nullptr;\n      AssertionResult result = fake_upstreams_[0]->waitForHttpConnection(\n          *dispatcher_, new_connection, std::chrono::milliseconds(50));\n      if (result) {\n        ASSERT(new_connection);\n        upstream_connections_.push_back(std::move(new_connection));\n      }\n\n      for (auto& connection : upstream_connections_) {\n        result = wait_new_stream_fn(connection);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    AssertionResult result = new_stream->waitForEndStream(*dispatcher_);\n    ASSERT(result);\n    return new_stream;\n  }\n\n  Http::TestResponseHeaderMapImpl redirect_response_{{\":status\", \"302\"},\n                                                     {\"content-length\", \"0\"},\n                                                     {\"location\", \"http://authority2/new/url\"},\n                                                     // Test header added to confirm that response\n                                                     // headers are populated for internal redirects\n                                                     {kTestHeaderKey, \"test-header-value\"}};\n  Envoy::Http::LowerCaseString test_header_key_{kTestHeaderKey};\n  std::vector<FakeHttpConnectionPtr> upstream_connections_;\n};\n\n// By default if internal redirects are not configured, redirects are proxied.\nTEST_P(RedirectIntegrationTest, RedirectNotConfigured) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n\n  // Use base class initialize.\n  HttpProtocolIntegrationTest::initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\n// Verify that URI fragment in upstream server Location header is passed unmodified to the\n// downstream client.\nTEST_P(RedirectIntegrationTest, UpstreamRedirectPreservesURIFragmentInLocation) {\n  // Use base class initialize.\n  HttpProtocolIntegrationTest::initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  Http::TestResponseHeaderMapImpl redirect_response{\n      {\":status\", \"302\"},\n      {\"content-length\", \"0\"},\n      {\"location\", \"http://authority2/new/url?p1=v1&p2=v2#fragment\"}};\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response, 0);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\"http://authority2/new/url?p1=v1&p2=v2#fragment\",\n            response->headers().getLocationValue());\n}\n\n// Now test a route with redirects configured on in pass-through mode.\nTEST_P(RedirectIntegrationTest, InternalRedirectPassedThrough) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"pass.through.internal.redirect\");\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      0,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirect) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirectDownstreamBytesCount) {\n  if (upstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(0, 63, 0, 31),\n                                       BytesCountExpectation(0, 42, 0, 42),\n                                       BytesCountExpectation(0, 42, 0, 42), 0);\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(140, 63, 121, 31),\n                                       BytesCountExpectation(77, 42, 77, 42),\n                                       BytesCountExpectation(77, 42, 77, 42), 1);\n}\n\nTEST_P(RedirectIntegrationTest, BasicInternalRedirectUpstreamBytesCount) {\n  if (downstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%UPSTREAM_WIRE_BYTES_SENT% %UPSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%UPSTREAM_HEADER_BYTES_SENT% %UPSTREAM_HEADER_BYTES_RECEIVED%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  expectUpstreamBytesSentAndReceived(BytesCountExpectation(195, 110, 164, 85),\n                                     BytesCountExpectation(137, 64, 137, 64),\n                                     BytesCountExpectation(137, 64, 137, 64), 0);\n  expectUpstreamBytesSentAndReceived(BytesCountExpectation(244, 38, 219, 18),\n                                     BytesCountExpectation(85, 10, 85, 10),\n                                     BytesCountExpectation(85, 10, 85, 10), 1);\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectStripsUriFragment) {\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n\n  // Redirect to URI with fragment\n  Http::TestResponseHeaderMapImpl redirect_response{\n      {\":status\", \"302\"},\n      {\"content-length\", \"0\"},\n      {\"location\", \"http://authority2/new/url?p1=v1&p2=v2#fragment\"}};\n\n  upstream_request_->encodeHeaders(redirect_response, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  // During internal redirect Envoy always strips fragment from Location URI\n  EXPECT_EQ(\"/new/url?p1=v1&p2=v2\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectWithRequestBody) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  const std::string& request_body = \"foobarbizbaz\";\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeRequestWithBody(default_request_headers_, request_body);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n\n  // Respond with a redirect.\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectHandlesHttp303) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        hcm.set_via(\"via_value\");\n\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_route()\n            ->mutable_internal_redirect_policy()\n            ->mutable_redirect_response_codes()\n            ->Add(303);\n      });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  const std::string& request_body = \"foobarbizbaz\";\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  default_request_headers_.setContentLength(request_body.length());\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeRequestWithBody(default_request_headers_, request_body);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(request_body, upstream_request_->body().toString());\n\n  // Respond with a redirect.\n  redirect_response_.setStatus(303);\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"\", upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n  EXPECT_EQ(\"GET\", upstream_request_->headers().getMethodValue());\n  EXPECT_EQ(\"\", upstream_request_->headers().getContentLengthValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"303 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectHttp303PreservesHeadMethod) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        hcm.set_via(\"via_value\");\n\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_route()\n            ->mutable_internal_redirect_policy()\n            ->mutable_redirect_response_codes()\n            ->Add(303);\n      });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"HEAD\");\n\n  // First request to original upstream.\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n\n  // Respond with a redirect.\n  redirect_response_.setStatus(303);\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Second request to redirected upstream.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"\", upstream_request_->body().toString());\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n  EXPECT_EQ(\"HEAD\", upstream_request_->headers().getMethodValue());\n\n  // Return the response from the redirect upstream.\n  upstream_request_->encodeHeaders(default_response_headers_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"303 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectCancelledDueToBufferOverflow) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) {\n        auto* route = hcm.mutable_route_config()->mutable_virtual_hosts(2)->mutable_routes(0);\n        route->mutable_per_request_buffer_limit_bytes()->set_value(1024);\n      });\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto& encoder = encoder_decoder.first;\n  auto& response = encoder_decoder.second;\n\n  // Send more data than what we can buffer.\n  std::string data(2048, 'a');\n  Buffer::OwnedImpl send1(data);\n  encoder.encodeData(send1, true);\n\n  // Wait for a redirect response.\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(data, upstream_request_->body().toString());\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  // Ensure the redirect was returned to the client.\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectCancelledDueToEarlyResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  default_request_headers_.setMethod(\"POST\");\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  auto& response = encoder_decoder.second;\n\n  // Wait for the request headers to be received upstream.\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n\n  // Respond with a redirect before the request is complete.\n  upstream_request_->encodeHeaders(redirect_response_, true);\n  ASSERT_TRUE(response->waitForEndStream());\n\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  } else {\n    ASSERT_TRUE(upstream_request_->waitForReset());\n    ASSERT_TRUE(fake_upstream_connection_->close());\n    ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n  }\n\n  if (downstream_protocol_ == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  } else {\n    codec_client_->close();\n  }\n\n  EXPECT_FALSE(upstream_request_->complete());\n\n  // Ensure the redirect was returned to the client and not handled internally.\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectWithThreeHopLimit) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect.max.three.hop\");\n  default_request_headers_.setPath(\"/path0\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  std::vector<FakeStreamPtr> upstream_requests;\n  // Four requests to upstream: 1 original request + 3 following redirect\n  for (int i = 0; i < 4; i++) {\n    upstream_requests.push_back(waitForNextStream());\n\n    EXPECT_EQ(fmt::format(\"/path{}\", i), upstream_requests.back()->headers().getPathValue());\n    EXPECT_EQ(\"handle.internal.redirect.max.three.hop\",\n              upstream_requests.back()->headers().getHostValue());\n    EXPECT_EQ(\"via_value\", upstream_requests.back()->headers().getViaValue());\n\n    auto next_location = fmt::format(HandleThreeHopLocationFormat, i + 1);\n    redirect_response_.setLocation(next_location);\n    upstream_requests.back()->encodeHeaders(redirect_response_, true);\n  }\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      1,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(\n      1, test_server_->counter(\"http.config_test.passthrough_internal_redirect_too_many_redirects\")\n             ->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 2),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 3),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectToDestinationWithResponseBody) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  config_helper_.prependFilter(R\"EOF(\n  name: pause-filter\n  typed_config:\n    \"@type\": type.googleapis.com/google.protobuf.Empty\n  )EOF\");\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  waitForNextUpstreamRequest();\n  ASSERT(upstream_request_->headers().EnvoyOriginalUrl() != nullptr);\n  EXPECT_EQ(\"http://handle.internal.redirect/test/long/url\",\n            upstream_request_->headers().getEnvoyOriginalUrlValue());\n  EXPECT_EQ(\"/new/url\", upstream_request_->headers().getPathValue());\n  EXPECT_EQ(\"authority2\", upstream_request_->headers().getHostValue());\n  EXPECT_EQ(\"via_value\", upstream_request_->headers().getViaValue());\n\n  Http::TestResponseHeaderMapImpl response_with_big_body(\n      {{\":status\", \"200\"}, {\"content-length\", \"2000000\"}});\n  upstream_request_->encodeHeaders(response_with_big_body, false);\n  upstream_request_->encodeData(2000000, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"200 via_upstream -\\n\"));\n}\n\nTEST_P(RedirectIntegrationTest, InvalidRedirect) {\n  useAccessLog(\"%RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  initialize();\n\n  redirect_response_.setLocation(\"invalid_url\");\n\n  // Send the same request as above, only send an invalid URL as the response.\n  // The request should not be redirected.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  auto response = sendRequestAndWaitForResponse(default_request_headers_, 0, redirect_response_, 0);\n  EXPECT_EQ(\"302\", response->headers().getStatusValue());\n  EXPECT_EQ(\n      1,\n      test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_failed_total\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              HasSubstr(\"302 via_upstream test-header-value\\n\"));\n  EXPECT_EQ(\"test-header-value\",\n            response->headers().get(test_header_key_)[0]->value().getStringView());\n}\n\nTEST_P(RedirectIntegrationTest, InternalRedirectHandledByDirectResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  // Validate that header sanitization is only called once.\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n\n  waitForNextUpstreamRequest();\n\n  redirect_response_.setLocation(\"http://handle.direct.response/\");\n  upstream_request_->encodeHeaders(redirect_response_, true);\n\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"204\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  // 302 was never returned downstream\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  // No test header\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"204 direct_response -\\n\"));\n}\n\nINSTANTIATE_TEST_SUITE_P(Protocols, RedirectIntegrationTest,\n                         testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),\n                         HttpProtocolIntegrationTest::protocolTestParamsToString);\n\n} // namespace Envoy\n"], "filenames": ["docs/root/version_history/current.rst", "source/common/router/router.cc", "test/common/router/router_test.cc", "test/integration/redirect_integration_test.cc"], "buggy_code_start_loc": [27, 1695, 58, 40], "buggy_code_end_loc": [27, 1696, 4204, 667], "fixing_code_start_loc": [28, 1695, 59, 41], "fixing_code_end_loc": [29, 1697, 4232, 710], "type": "CWE-670", "message": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The envoy common router will segfault if an internal redirect selects a route configured with direct response or redirect actions. This will result in a denial of service. As a workaround turn off internal redirects if direct response entries are configured on the same listener.", "other": {"cve": {"id": "CVE-2022-21655", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T23:15:11.163", "lastModified": "2022-03-02T14:27:36.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The envoy common router will segfault if an internal redirect selects a route configured with direct response or redirect actions. This will result in a denial of service. As a workaround turn off internal redirects if direct response entries are configured on the same listener."}, {"lang": "es", "value": "Envoy es un proxy de borde y servicio de c\u00f3digo abierto, dise\u00f1ado para aplicaciones nativas de la nube. El enrutador com\u00fan de Envoy fallar\u00e1 si una redirecci\u00f3n interna selecciona una ruta configurada con acciones de respuesta directa o redirecci\u00f3n. Esto resultar\u00e1 en una denegaci\u00f3n de servicio. Como medida de mitigaci\u00f3n, deshabilite las redirecciones internas si las entradas de respuesta directa est\u00e1n configuradas en el mismo receptor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.18.6", "matchCriteriaId": "0EFC93D0-C206-417C-81D0-F18145E3D768"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.19.0", "versionEndExcluding": "1.19.3", "matchCriteriaId": "2812AC62-44B5-4077-862D-A221CD88981D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.20.0", "versionEndExcluding": "1.20.2", "matchCriteriaId": "F5441B2D-F807-4ED9-AFB9-ED4DE07CE5F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.21.0", "versionEndExcluding": "1.21.1", "matchCriteriaId": "83895D03-DAD1-4893-8A1C-F9143DEEC172"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/177d608155ba8b11598b9bbf8240e90d8c350682", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-7r5p-7fmh-jxpg", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/177d608155ba8b11598b9bbf8240e90d8c350682"}}