{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rfkill.h>\n#include <linux/nfc.h>\n\n#include <net/genetlink.h>\n\n#include \"nfc.h\"\n\n#define VERSION \"0.1\"\n\n#define NFC_CHECK_PRES_FREQ_MS\t2000\n\nint nfc_devlist_generation;\nDEFINE_MUTEX(nfc_devlist_mutex);\n\n/* NFC device ID bitmap */\nstatic DEFINE_IDA(nfc_index_ida);\n\nint nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_fw_download_done - inform that a firmware download was completed\n *\n * @dev: The nfc device to which firmware was downloaded\n * @firmware_name: The firmware filename\n * @result: The positive value of a standard errno value\n */\nint nfc_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t u32 result)\n{\n\tdev->fw_download_in_progress = false;\n\n\treturn nfc_genl_fw_download_done(dev, firmware_name, result);\n}\nEXPORT_SYMBOL(nfc_fw_download_done);\n\n/**\n * nfc_dev_up - turn on the NFC device\n *\n * @dev: The nfc device to be turned on\n *\n * The device remains up until the nfc_dev_down function is called.\n */\nint nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\n\tif (!rc)\n\t\tdev->dev_up = true;\n\n\t/* We have to enable the device before discovering SEs */\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_dev_down - turn off the NFC device\n *\n * @dev: The nfc device to be turned off\n */\nint nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\n\tdev->dev_up = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstatic int nfc_rfkill_set_block(void *data, bool blocked)\n{\n\tstruct nfc_dev *dev = data;\n\n\tpr_debug(\"%s blocked %d\", dev_name(&dev->dev), blocked);\n\n\tif (!blocked)\n\t\treturn 0;\n\n\tnfc_dev_down(dev);\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops nfc_rfkill_ops = {\n\t.set_block = nfc_rfkill_set_block,\n};\n\n/**\n * nfc_start_poll - start polling for nfc targets\n *\n * @dev: The nfc device that must start polling\n * @im_protocols: bitset of nfc initiator protocols to be used for polling\n * @tm_protocols: bitset of nfc transport protocols to be used for polling\n *\n * The device remains polling for targets until a target is found or\n * the nfc_stop_poll function is called.\n */\nint nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_stop_poll - stop polling for nfc targets\n *\n * @dev: The nfc device that must stop polling\n */\nint nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstatic struct nfc_target *nfc_find_target(struct nfc_dev *dev, u32 target_idx)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->n_targets; i++) {\n\t\tif (dev->targets[i].idx == target_idx)\n\t\t\treturn &dev->targets[i];\n\t}\n\n\treturn NULL;\n}\n\nint nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\n\treturn rc;\n}\n\nint nfc_dep_link_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tdev->dep_link_up = true;\n\n\tif (!dev->active_target && rf_mode == NFC_RF_INITIATOR) {\n\t\tstruct nfc_target *target;\n\n\t\ttarget = nfc_find_target(dev, target_idx);\n\t\tif (target == NULL)\n\t\t\treturn -ENOTCONN;\n\n\t\tdev->active_target = target;\n\t}\n\n\tdev->polling = false;\n\tdev->rf_mode = rf_mode;\n\n\tnfc_llcp_mac_is_up(dev, target_idx, comm_mode, rf_mode);\n\n\treturn nfc_genl_dep_link_up_event(dev, target_idx, comm_mode, rf_mode);\n}\nEXPORT_SYMBOL(nfc_dep_link_is_up);\n\n/**\n * nfc_activate_target - prepare the target for data exchange\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be activated\n * @protocol: nfc protocol that will be used for data exchange\n */\nint nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_deactivate_target - deactivate a nfc target\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be deactivated\n * @mode: idle or sleep?\n */\nint nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_data_exchange - transceive data\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target\n * @skb: data to be sent\n * @cb: callback called when the response is received\n * @cb_context: parameter for the callback function\n *\n * The user must wait for the callback before calling this function again.\n */\nint nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstruct nfc_se *nfc_find_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\n\tlist_for_each_entry(se, &dev->secure_elements, list)\n\t\tif (se->idx == se_idx)\n\t\t\treturn se;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nfc_find_se);\n\nint nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_set_remote_general_bytes(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tpr_debug(\"dev_name=%s gb_len=%d\\n\", dev_name(&dev->dev), gb_len);\n\n\treturn nfc_llcp_set_remote_gb(dev, gb, gb_len);\n}\nEXPORT_SYMBOL(nfc_set_remote_general_bytes);\n\nu8 *nfc_get_local_general_bytes(struct nfc_dev *dev, size_t *gb_len)\n{\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\treturn nfc_llcp_general_bytes(dev, gb_len);\n}\nEXPORT_SYMBOL(nfc_get_local_general_bytes);\n\nint nfc_tm_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\t/* Only LLCP target mode for now */\n\tif (dev->dep_link_up == false) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOLINK;\n\t}\n\n\treturn nfc_llcp_data_received(dev, skb);\n}\nEXPORT_SYMBOL(nfc_tm_data_received);\n\nint nfc_tm_activated(struct nfc_dev *dev, u32 protocol, u8 comm_mode,\n\t\t     const u8 *gb, size_t gb_len)\n{\n\tint rc;\n\n\tdevice_lock(&dev->dev);\n\n\tdev->polling = false;\n\n\tif (gb != NULL) {\n\t\trc = nfc_set_remote_general_bytes(dev, gb, gb_len);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\tdev->rf_mode = NFC_RF_TARGET;\n\n\tif (protocol == NFC_PROTO_NFC_DEP_MASK)\n\t\tnfc_dep_link_is_up(dev, 0, comm_mode, NFC_RF_TARGET);\n\n\trc = nfc_genl_tm_activated(dev, protocol);\n\nout:\n\tdevice_unlock(&dev->dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_tm_activated);\n\nint nfc_tm_deactivated(struct nfc_dev *dev)\n{\n\tdev->dep_link_up = false;\n\tdev->rf_mode = NFC_RF_NONE;\n\n\treturn nfc_genl_tm_deactivated(dev);\n}\nEXPORT_SYMBOL(nfc_tm_deactivated);\n\n/**\n * nfc_alloc_send_skb - allocate a skb for data exchange responses\n *\n * @dev: device sending the response\n * @sk: socket sending the response\n * @flags: MSG_DONTWAIT flag\n * @size: size to allocate\n * @err: pointer to memory to store the error code\n */\nstruct sk_buff *nfc_alloc_send_skb(struct nfc_dev *dev, struct sock *sk,\n\t\t\t\t   unsigned int flags, unsigned int size,\n\t\t\t\t   unsigned int *err)\n{\n\tstruct sk_buff *skb;\n\tunsigned int total_size;\n\n\ttotal_size = size +\n\t\tdev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = sock_alloc_send_skb(sk, total_size, flags & MSG_DONTWAIT, err);\n\tif (skb)\n\t\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\treturn skb;\n}\n\n/**\n * nfc_alloc_recv_skb - allocate a skb for data exchange responses\n *\n * @size: size to allocate\n * @gfp: gfp flags\n */\nstruct sk_buff *nfc_alloc_recv_skb(unsigned int size, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tunsigned int total_size;\n\n\ttotal_size = size + 1;\n\tskb = alloc_skb(total_size, gfp);\n\n\tif (skb)\n\t\tskb_reserve(skb, 1);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(nfc_alloc_recv_skb);\n\n/**\n * nfc_targets_found - inform that targets were found\n *\n * @dev: The nfc device that found the targets\n * @targets: array of nfc targets found\n * @n_targets: targets array size\n *\n * The device driver must call this function when one or many nfc targets\n * are found. After calling this function, the device driver must stop\n * polling for targets.\n * NOTE: This function can be called with targets=NULL and n_targets=0 to\n * notify a driver error, meaning that the polling operation cannot complete.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_targets_found(struct nfc_dev *dev,\n\t\t      struct nfc_target *targets, int n_targets)\n{\n\tint i;\n\n\tpr_debug(\"dev_name=%s n_targets=%d\\n\", dev_name(&dev->dev), n_targets);\n\n\tfor (i = 0; i < n_targets; i++)\n\t\ttargets[i].idx = dev->target_next_idx++;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->polling == false) {\n\t\tdevice_unlock(&dev->dev);\n\t\treturn 0;\n\t}\n\n\tdev->polling = false;\n\n\tdev->targets_generation++;\n\n\tkfree(dev->targets);\n\tdev->targets = NULL;\n\n\tif (targets) {\n\t\tdev->targets = kmemdup(targets,\n\t\t\t\t       n_targets * sizeof(struct nfc_target),\n\t\t\t\t       GFP_ATOMIC);\n\n\t\tif (!dev->targets) {\n\t\t\tdev->n_targets = 0;\n\t\t\tdevice_unlock(&dev->dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tdev->n_targets = n_targets;\n\tdevice_unlock(&dev->dev);\n\n\tnfc_genl_targets_found(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_targets_found);\n\n/**\n * nfc_target_lost - inform that an activated target went out of field\n *\n * @dev: The nfc device that had the activated target in field\n * @target_idx: the nfc index of the target\n *\n * The device driver must call this function when the activated target\n * goes out of the field.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tconst struct nfc_target *tg;\n\tint i;\n\n\tpr_debug(\"dev_name %s n_target %d\\n\", dev_name(&dev->dev), target_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tfor (i = 0; i < dev->n_targets; i++) {\n\t\ttg = &dev->targets[i];\n\t\tif (tg->idx == target_idx)\n\t\t\tbreak;\n\t}\n\n\tif (i == dev->n_targets) {\n\t\tdevice_unlock(&dev->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->targets_generation++;\n\tdev->n_targets--;\n\tdev->active_target = NULL;\n\n\tif (dev->n_targets) {\n\t\tmemcpy(&dev->targets[i], &dev->targets[i + 1],\n\t\t       (dev->n_targets - i) * sizeof(struct nfc_target));\n\t} else {\n\t\tkfree(dev->targets);\n\t\tdev->targets = NULL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tnfc_genl_target_lost(dev, target_idx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_target_lost);\n\ninline void nfc_driver_failure(struct nfc_dev *dev, int err)\n{\n\tnfc_targets_found(dev, NULL, 0);\n}\nEXPORT_SYMBOL(nfc_driver_failure);\n\nint nfc_add_se(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (se)\n\t\treturn -EALREADY;\n\n\tse = kzalloc(sizeof(struct nfc_se), GFP_KERNEL);\n\tif (!se)\n\t\treturn -ENOMEM;\n\n\tse->idx = se_idx;\n\tse->type = type;\n\tse->state = NFC_SE_DISABLED;\n\tINIT_LIST_HEAD(&se->list);\n\n\tlist_add(&se->list, &dev->secure_elements);\n\n\trc = nfc_genl_se_added(dev, se_idx, type);\n\tif (rc < 0) {\n\t\tlist_del(&se->list);\n\t\tkfree(se);\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_add_se);\n\nint nfc_remove_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se, *n;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list)\n\t\tif (se->idx == se_idx) {\n\t\t\trc = nfc_genl_se_removed(dev, se_idx);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tlist_del(&se->list);\n\t\t\tkfree(se);\n\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(nfc_remove_se);\n\nint nfc_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t       struct nfc_evt_transaction *evt_transaction)\n{\n\tint rc;\n\n\tpr_debug(\"transaction: %x\\n\", se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!evt_transaction) {\n\t\trc = -EPROTO;\n\t\tgoto out;\n\t}\n\n\trc = nfc_genl_se_transaction(dev, se_idx, evt_transaction);\nout:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_se_transaction);\n\nint nfc_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tint rc;\n\n\tpr_debug(\"connectivity: %x\\n\", se_idx);\n\n\tdevice_lock(&dev->dev);\n\trc = nfc_genl_se_connectivity(dev, se_idx);\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_se_connectivity);\n\nstatic void nfc_release(struct device *d)\n{\n\tstruct nfc_dev *dev = to_nfc_dev(d);\n\tstruct nfc_se *se, *n;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tnfc_genl_data_exit(&dev->genl_data);\n\tkfree(dev->targets);\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\t\tnfc_genl_se_removed(dev, se->idx);\n\t\t\tlist_del(&se->list);\n\t\t\tkfree(se);\n\t}\n\n\tida_simple_remove(&nfc_index_ida, dev->idx);\n\n\tkfree(dev);\n}\n\nstatic void nfc_check_pres_work(struct work_struct *work)\n{\n\tstruct nfc_dev *dev = container_of(work, struct nfc_dev,\n\t\t\t\t\t   check_pres_work);\n\tint rc;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->active_target && timer_pending(&dev->check_pres_timer) == 0) {\n\t\trc = dev->ops->check_presence(dev, dev->active_target);\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\tgoto exit;\n\t\tif (rc) {\n\t\t\tu32 active_target_idx = dev->active_target->idx;\n\t\t\tdevice_unlock(&dev->dev);\n\t\t\tnfc_target_lost(dev, active_target_idx);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\n\nexit:\n\tdevice_unlock(&dev->dev);\n}\n\nstatic void nfc_check_pres_timeout(struct timer_list *t)\n{\n\tstruct nfc_dev *dev = from_timer(dev, t, check_pres_timer);\n\n\tschedule_work(&dev->check_pres_work);\n}\n\nstruct class nfc_class = {\n\t.name = \"nfc\",\n\t.dev_release = nfc_release,\n};\nEXPORT_SYMBOL(nfc_class);\n\nstatic int match_idx(struct device *d, const void *data)\n{\n\tstruct nfc_dev *dev = to_nfc_dev(d);\n\tconst unsigned int *idx = data;\n\n\treturn dev->idx == *idx;\n}\n\nstruct nfc_dev *nfc_get_device(unsigned int idx)\n{\n\tstruct device *d;\n\n\td = class_find_device(&nfc_class, NULL, &idx, match_idx);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn to_nfc_dev(d);\n}\n\n/**\n * nfc_allocate_device - allocate a new nfc device\n *\n * @ops: device operations\n * @supported_protocols: NFC protocols supported by the device\n * @tx_headroom: reserved space at beginning of skb\n * @tx_tailroom: reserved space at end of skb\n */\nstruct nfc_dev *nfc_allocate_device(const struct nfc_ops *ops,\n\t\t\t\t    u32 supported_protocols,\n\t\t\t\t    int tx_headroom, int tx_tailroom)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\n\tif (!ops->start_poll || !ops->stop_poll || !ops->activate_target ||\n\t    !ops->deactivate_target || !ops->im_transceive)\n\t\treturn NULL;\n\n\tif (!supported_protocols)\n\t\treturn NULL;\n\n\tdev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\trc = ida_simple_get(&nfc_index_ida, 0, 0, GFP_KERNEL);\n\tif (rc < 0)\n\t\tgoto err_free_dev;\n\tdev->idx = rc;\n\n\tdev->dev.class = &nfc_class;\n\tdev_set_name(&dev->dev, \"nfc%d\", dev->idx);\n\tdevice_initialize(&dev->dev);\n\n\tdev->ops = ops;\n\tdev->supported_protocols = supported_protocols;\n\tdev->tx_headroom = tx_headroom;\n\tdev->tx_tailroom = tx_tailroom;\n\tINIT_LIST_HEAD(&dev->secure_elements);\n\n\tnfc_genl_data_init(&dev->genl_data);\n\n\tdev->rf_mode = NFC_RF_NONE;\n\n\t/* first generation must not be 0 */\n\tdev->targets_generation = 1;\n\n\tif (ops->check_presence) {\n\t\ttimer_setup(&dev->check_pres_timer, nfc_check_pres_timeout, 0);\n\t\tINIT_WORK(&dev->check_pres_work, nfc_check_pres_work);\n\t}\n\n\treturn dev;\n\nerr_free_dev:\n\tkfree(dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nfc_allocate_device);\n\n/**\n * nfc_register_device - register a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to register\n */\nint nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdevice_unlock(&dev->dev);\n\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_register_device);\n\n/**\n * nfc_unregister_device - unregister a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to unregister\n */\nvoid nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdevice_unlock(&dev->dev);\n\n\tif (dev->ops->check_presence) {\n\t\tdevice_lock(&dev->dev);\n\t\tdev->shutting_down = true;\n\t\tdevice_unlock(&dev->dev);\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\n\tnfc_llcp_unregister_device(dev);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}\nEXPORT_SYMBOL(nfc_unregister_device);\n\nstatic int __init nfc_init(void)\n{\n\tint rc;\n\n\tpr_info(\"NFC Core ver %s\\n\", VERSION);\n\n\trc = class_register(&nfc_class);\n\tif (rc)\n\t\treturn rc;\n\n\trc = nfc_genl_init();\n\tif (rc)\n\t\tgoto err_genl;\n\n\t/* the first generation must not be 0 */\n\tnfc_devlist_generation = 1;\n\n\trc = rawsock_init();\n\tif (rc)\n\t\tgoto err_rawsock;\n\n\trc = nfc_llcp_init();\n\tif (rc)\n\t\tgoto err_llcp_sock;\n\n\trc = af_nfc_init();\n\tif (rc)\n\t\tgoto err_af_nfc;\n\n\treturn 0;\n\nerr_af_nfc:\n\tnfc_llcp_exit();\nerr_llcp_sock:\n\trawsock_exit();\nerr_rawsock:\n\tnfc_genl_exit();\nerr_genl:\n\tclass_unregister(&nfc_class);\n\treturn rc;\n}\n\nstatic void __exit nfc_exit(void)\n{\n\taf_nfc_exit();\n\tnfc_llcp_exit();\n\trawsock_exit();\n\tnfc_genl_exit();\n\tclass_unregister(&nfc_class);\n}\n\nsubsys_initcall(nfc_init);\nmodule_exit(nfc_exit);\n\nMODULE_AUTHOR(\"Lauro Ramos Venancio <lauro.venancio@openbossa.org>\");\nMODULE_DESCRIPTION(\"NFC Core ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_NFC);\nMODULE_ALIAS_GENL_FAMILY(NFC_GENL_NAME);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rfkill.h>\n#include <linux/nfc.h>\n\n#include <net/genetlink.h>\n\n#include \"nfc.h\"\n\n#define VERSION \"0.1\"\n\n#define NFC_CHECK_PRES_FREQ_MS\t2000\n\nint nfc_devlist_generation;\nDEFINE_MUTEX(nfc_devlist_mutex);\n\n/* NFC device ID bitmap */\nstatic DEFINE_IDA(nfc_index_ida);\n\nint nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_fw_download_done - inform that a firmware download was completed\n *\n * @dev: The nfc device to which firmware was downloaded\n * @firmware_name: The firmware filename\n * @result: The positive value of a standard errno value\n */\nint nfc_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t u32 result)\n{\n\tdev->fw_download_in_progress = false;\n\n\treturn nfc_genl_fw_download_done(dev, firmware_name, result);\n}\nEXPORT_SYMBOL(nfc_fw_download_done);\n\n/**\n * nfc_dev_up - turn on the NFC device\n *\n * @dev: The nfc device to be turned on\n *\n * The device remains up until the nfc_dev_down function is called.\n */\nint nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\n\tif (!rc)\n\t\tdev->dev_up = true;\n\n\t/* We have to enable the device before discovering SEs */\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_dev_down - turn off the NFC device\n *\n * @dev: The nfc device to be turned off\n */\nint nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\n\tdev->dev_up = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstatic int nfc_rfkill_set_block(void *data, bool blocked)\n{\n\tstruct nfc_dev *dev = data;\n\n\tpr_debug(\"%s blocked %d\", dev_name(&dev->dev), blocked);\n\n\tif (!blocked)\n\t\treturn 0;\n\n\tnfc_dev_down(dev);\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops nfc_rfkill_ops = {\n\t.set_block = nfc_rfkill_set_block,\n};\n\n/**\n * nfc_start_poll - start polling for nfc targets\n *\n * @dev: The nfc device that must start polling\n * @im_protocols: bitset of nfc initiator protocols to be used for polling\n * @tm_protocols: bitset of nfc transport protocols to be used for polling\n *\n * The device remains polling for targets until a target is found or\n * the nfc_stop_poll function is called.\n */\nint nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_stop_poll - stop polling for nfc targets\n *\n * @dev: The nfc device that must stop polling\n */\nint nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstatic struct nfc_target *nfc_find_target(struct nfc_dev *dev, u32 target_idx)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->n_targets; i++) {\n\t\tif (dev->targets[i].idx == target_idx)\n\t\t\treturn &dev->targets[i];\n\t}\n\n\treturn NULL;\n}\n\nint nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\n\treturn rc;\n}\n\nint nfc_dep_link_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tdev->dep_link_up = true;\n\n\tif (!dev->active_target && rf_mode == NFC_RF_INITIATOR) {\n\t\tstruct nfc_target *target;\n\n\t\ttarget = nfc_find_target(dev, target_idx);\n\t\tif (target == NULL)\n\t\t\treturn -ENOTCONN;\n\n\t\tdev->active_target = target;\n\t}\n\n\tdev->polling = false;\n\tdev->rf_mode = rf_mode;\n\n\tnfc_llcp_mac_is_up(dev, target_idx, comm_mode, rf_mode);\n\n\treturn nfc_genl_dep_link_up_event(dev, target_idx, comm_mode, rf_mode);\n}\nEXPORT_SYMBOL(nfc_dep_link_is_up);\n\n/**\n * nfc_activate_target - prepare the target for data exchange\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be activated\n * @protocol: nfc protocol that will be used for data exchange\n */\nint nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_deactivate_target - deactivate a nfc target\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be deactivated\n * @mode: idle or sleep?\n */\nint nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\n/**\n * nfc_data_exchange - transceive data\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target\n * @skb: data to be sent\n * @cb: callback called when the response is received\n * @cb_context: parameter for the callback function\n *\n * The user must wait for the callback before calling this function again.\n */\nint nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstruct nfc_se *nfc_find_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\n\tlist_for_each_entry(se, &dev->secure_elements, list)\n\t\tif (se->idx == se_idx)\n\t\t\treturn se;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nfc_find_se);\n\nint nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nint nfc_set_remote_general_bytes(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tpr_debug(\"dev_name=%s gb_len=%d\\n\", dev_name(&dev->dev), gb_len);\n\n\treturn nfc_llcp_set_remote_gb(dev, gb, gb_len);\n}\nEXPORT_SYMBOL(nfc_set_remote_general_bytes);\n\nu8 *nfc_get_local_general_bytes(struct nfc_dev *dev, size_t *gb_len)\n{\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\treturn nfc_llcp_general_bytes(dev, gb_len);\n}\nEXPORT_SYMBOL(nfc_get_local_general_bytes);\n\nint nfc_tm_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\t/* Only LLCP target mode for now */\n\tif (dev->dep_link_up == false) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOLINK;\n\t}\n\n\treturn nfc_llcp_data_received(dev, skb);\n}\nEXPORT_SYMBOL(nfc_tm_data_received);\n\nint nfc_tm_activated(struct nfc_dev *dev, u32 protocol, u8 comm_mode,\n\t\t     const u8 *gb, size_t gb_len)\n{\n\tint rc;\n\n\tdevice_lock(&dev->dev);\n\n\tdev->polling = false;\n\n\tif (gb != NULL) {\n\t\trc = nfc_set_remote_general_bytes(dev, gb, gb_len);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\tdev->rf_mode = NFC_RF_TARGET;\n\n\tif (protocol == NFC_PROTO_NFC_DEP_MASK)\n\t\tnfc_dep_link_is_up(dev, 0, comm_mode, NFC_RF_TARGET);\n\n\trc = nfc_genl_tm_activated(dev, protocol);\n\nout:\n\tdevice_unlock(&dev->dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_tm_activated);\n\nint nfc_tm_deactivated(struct nfc_dev *dev)\n{\n\tdev->dep_link_up = false;\n\tdev->rf_mode = NFC_RF_NONE;\n\n\treturn nfc_genl_tm_deactivated(dev);\n}\nEXPORT_SYMBOL(nfc_tm_deactivated);\n\n/**\n * nfc_alloc_send_skb - allocate a skb for data exchange responses\n *\n * @dev: device sending the response\n * @sk: socket sending the response\n * @flags: MSG_DONTWAIT flag\n * @size: size to allocate\n * @err: pointer to memory to store the error code\n */\nstruct sk_buff *nfc_alloc_send_skb(struct nfc_dev *dev, struct sock *sk,\n\t\t\t\t   unsigned int flags, unsigned int size,\n\t\t\t\t   unsigned int *err)\n{\n\tstruct sk_buff *skb;\n\tunsigned int total_size;\n\n\ttotal_size = size +\n\t\tdev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = sock_alloc_send_skb(sk, total_size, flags & MSG_DONTWAIT, err);\n\tif (skb)\n\t\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\treturn skb;\n}\n\n/**\n * nfc_alloc_recv_skb - allocate a skb for data exchange responses\n *\n * @size: size to allocate\n * @gfp: gfp flags\n */\nstruct sk_buff *nfc_alloc_recv_skb(unsigned int size, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tunsigned int total_size;\n\n\ttotal_size = size + 1;\n\tskb = alloc_skb(total_size, gfp);\n\n\tif (skb)\n\t\tskb_reserve(skb, 1);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(nfc_alloc_recv_skb);\n\n/**\n * nfc_targets_found - inform that targets were found\n *\n * @dev: The nfc device that found the targets\n * @targets: array of nfc targets found\n * @n_targets: targets array size\n *\n * The device driver must call this function when one or many nfc targets\n * are found. After calling this function, the device driver must stop\n * polling for targets.\n * NOTE: This function can be called with targets=NULL and n_targets=0 to\n * notify a driver error, meaning that the polling operation cannot complete.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_targets_found(struct nfc_dev *dev,\n\t\t      struct nfc_target *targets, int n_targets)\n{\n\tint i;\n\n\tpr_debug(\"dev_name=%s n_targets=%d\\n\", dev_name(&dev->dev), n_targets);\n\n\tfor (i = 0; i < n_targets; i++)\n\t\ttargets[i].idx = dev->target_next_idx++;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->polling == false) {\n\t\tdevice_unlock(&dev->dev);\n\t\treturn 0;\n\t}\n\n\tdev->polling = false;\n\n\tdev->targets_generation++;\n\n\tkfree(dev->targets);\n\tdev->targets = NULL;\n\n\tif (targets) {\n\t\tdev->targets = kmemdup(targets,\n\t\t\t\t       n_targets * sizeof(struct nfc_target),\n\t\t\t\t       GFP_ATOMIC);\n\n\t\tif (!dev->targets) {\n\t\t\tdev->n_targets = 0;\n\t\t\tdevice_unlock(&dev->dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tdev->n_targets = n_targets;\n\tdevice_unlock(&dev->dev);\n\n\tnfc_genl_targets_found(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_targets_found);\n\n/**\n * nfc_target_lost - inform that an activated target went out of field\n *\n * @dev: The nfc device that had the activated target in field\n * @target_idx: the nfc index of the target\n *\n * The device driver must call this function when the activated target\n * goes out of the field.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tconst struct nfc_target *tg;\n\tint i;\n\n\tpr_debug(\"dev_name %s n_target %d\\n\", dev_name(&dev->dev), target_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tfor (i = 0; i < dev->n_targets; i++) {\n\t\ttg = &dev->targets[i];\n\t\tif (tg->idx == target_idx)\n\t\t\tbreak;\n\t}\n\n\tif (i == dev->n_targets) {\n\t\tdevice_unlock(&dev->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->targets_generation++;\n\tdev->n_targets--;\n\tdev->active_target = NULL;\n\n\tif (dev->n_targets) {\n\t\tmemcpy(&dev->targets[i], &dev->targets[i + 1],\n\t\t       (dev->n_targets - i) * sizeof(struct nfc_target));\n\t} else {\n\t\tkfree(dev->targets);\n\t\tdev->targets = NULL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tnfc_genl_target_lost(dev, target_idx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_target_lost);\n\ninline void nfc_driver_failure(struct nfc_dev *dev, int err)\n{\n\tnfc_targets_found(dev, NULL, 0);\n}\nEXPORT_SYMBOL(nfc_driver_failure);\n\nint nfc_add_se(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (se)\n\t\treturn -EALREADY;\n\n\tse = kzalloc(sizeof(struct nfc_se), GFP_KERNEL);\n\tif (!se)\n\t\treturn -ENOMEM;\n\n\tse->idx = se_idx;\n\tse->type = type;\n\tse->state = NFC_SE_DISABLED;\n\tINIT_LIST_HEAD(&se->list);\n\n\tlist_add(&se->list, &dev->secure_elements);\n\n\trc = nfc_genl_se_added(dev, se_idx, type);\n\tif (rc < 0) {\n\t\tlist_del(&se->list);\n\t\tkfree(se);\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_add_se);\n\nint nfc_remove_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se, *n;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list)\n\t\tif (se->idx == se_idx) {\n\t\t\trc = nfc_genl_se_removed(dev, se_idx);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tlist_del(&se->list);\n\t\t\tkfree(se);\n\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(nfc_remove_se);\n\nint nfc_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t       struct nfc_evt_transaction *evt_transaction)\n{\n\tint rc;\n\n\tpr_debug(\"transaction: %x\\n\", se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!evt_transaction) {\n\t\trc = -EPROTO;\n\t\tgoto out;\n\t}\n\n\trc = nfc_genl_se_transaction(dev, se_idx, evt_transaction);\nout:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_se_transaction);\n\nint nfc_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tint rc;\n\n\tpr_debug(\"connectivity: %x\\n\", se_idx);\n\n\tdevice_lock(&dev->dev);\n\trc = nfc_genl_se_connectivity(dev, se_idx);\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(nfc_se_connectivity);\n\nstatic void nfc_release(struct device *d)\n{\n\tstruct nfc_dev *dev = to_nfc_dev(d);\n\tstruct nfc_se *se, *n;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tnfc_genl_data_exit(&dev->genl_data);\n\tkfree(dev->targets);\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\t\tnfc_genl_se_removed(dev, se->idx);\n\t\t\tlist_del(&se->list);\n\t\t\tkfree(se);\n\t}\n\n\tida_simple_remove(&nfc_index_ida, dev->idx);\n\n\tkfree(dev);\n}\n\nstatic void nfc_check_pres_work(struct work_struct *work)\n{\n\tstruct nfc_dev *dev = container_of(work, struct nfc_dev,\n\t\t\t\t\t   check_pres_work);\n\tint rc;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->active_target && timer_pending(&dev->check_pres_timer) == 0) {\n\t\trc = dev->ops->check_presence(dev, dev->active_target);\n\t\tif (rc == -EOPNOTSUPP)\n\t\t\tgoto exit;\n\t\tif (rc) {\n\t\t\tu32 active_target_idx = dev->active_target->idx;\n\t\t\tdevice_unlock(&dev->dev);\n\t\t\tnfc_target_lost(dev, active_target_idx);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\n\nexit:\n\tdevice_unlock(&dev->dev);\n}\n\nstatic void nfc_check_pres_timeout(struct timer_list *t)\n{\n\tstruct nfc_dev *dev = from_timer(dev, t, check_pres_timer);\n\n\tschedule_work(&dev->check_pres_work);\n}\n\nstruct class nfc_class = {\n\t.name = \"nfc\",\n\t.dev_release = nfc_release,\n};\nEXPORT_SYMBOL(nfc_class);\n\nstatic int match_idx(struct device *d, const void *data)\n{\n\tstruct nfc_dev *dev = to_nfc_dev(d);\n\tconst unsigned int *idx = data;\n\n\treturn dev->idx == *idx;\n}\n\nstruct nfc_dev *nfc_get_device(unsigned int idx)\n{\n\tstruct device *d;\n\n\td = class_find_device(&nfc_class, NULL, &idx, match_idx);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn to_nfc_dev(d);\n}\n\n/**\n * nfc_allocate_device - allocate a new nfc device\n *\n * @ops: device operations\n * @supported_protocols: NFC protocols supported by the device\n * @tx_headroom: reserved space at beginning of skb\n * @tx_tailroom: reserved space at end of skb\n */\nstruct nfc_dev *nfc_allocate_device(const struct nfc_ops *ops,\n\t\t\t\t    u32 supported_protocols,\n\t\t\t\t    int tx_headroom, int tx_tailroom)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\n\tif (!ops->start_poll || !ops->stop_poll || !ops->activate_target ||\n\t    !ops->deactivate_target || !ops->im_transceive)\n\t\treturn NULL;\n\n\tif (!supported_protocols)\n\t\treturn NULL;\n\n\tdev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\trc = ida_simple_get(&nfc_index_ida, 0, 0, GFP_KERNEL);\n\tif (rc < 0)\n\t\tgoto err_free_dev;\n\tdev->idx = rc;\n\n\tdev->dev.class = &nfc_class;\n\tdev_set_name(&dev->dev, \"nfc%d\", dev->idx);\n\tdevice_initialize(&dev->dev);\n\n\tdev->ops = ops;\n\tdev->supported_protocols = supported_protocols;\n\tdev->tx_headroom = tx_headroom;\n\tdev->tx_tailroom = tx_tailroom;\n\tINIT_LIST_HEAD(&dev->secure_elements);\n\n\tnfc_genl_data_init(&dev->genl_data);\n\n\tdev->rf_mode = NFC_RF_NONE;\n\n\t/* first generation must not be 0 */\n\tdev->targets_generation = 1;\n\n\tif (ops->check_presence) {\n\t\ttimer_setup(&dev->check_pres_timer, nfc_check_pres_timeout, 0);\n\t\tINIT_WORK(&dev->check_pres_work, nfc_check_pres_work);\n\t}\n\n\treturn dev;\n\nerr_free_dev:\n\tkfree(dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nfc_allocate_device);\n\n/**\n * nfc_register_device - register a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to register\n */\nint nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdev->shutting_down = false;\n\tdevice_unlock(&dev->dev);\n\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_register_device);\n\n/**\n * nfc_unregister_device - unregister a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to unregister\n */\nvoid nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdev->shutting_down = true;\n\tdevice_unlock(&dev->dev);\n\n\tif (dev->ops->check_presence) {\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\n\tnfc_llcp_unregister_device(dev);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}\nEXPORT_SYMBOL(nfc_unregister_device);\n\nstatic int __init nfc_init(void)\n{\n\tint rc;\n\n\tpr_info(\"NFC Core ver %s\\n\", VERSION);\n\n\trc = class_register(&nfc_class);\n\tif (rc)\n\t\treturn rc;\n\n\trc = nfc_genl_init();\n\tif (rc)\n\t\tgoto err_genl;\n\n\t/* the first generation must not be 0 */\n\tnfc_devlist_generation = 1;\n\n\trc = rawsock_init();\n\tif (rc)\n\t\tgoto err_rawsock;\n\n\trc = nfc_llcp_init();\n\tif (rc)\n\t\tgoto err_llcp_sock;\n\n\trc = af_nfc_init();\n\tif (rc)\n\t\tgoto err_af_nfc;\n\n\treturn 0;\n\nerr_af_nfc:\n\tnfc_llcp_exit();\nerr_llcp_sock:\n\trawsock_exit();\nerr_rawsock:\n\tnfc_genl_exit();\nerr_genl:\n\tclass_unregister(&nfc_class);\n\treturn rc;\n}\n\nstatic void __exit nfc_exit(void)\n{\n\taf_nfc_exit();\n\tnfc_llcp_exit();\n\trawsock_exit();\n\tnfc_genl_exit();\n\tclass_unregister(&nfc_class);\n}\n\nsubsys_initcall(nfc_init);\nmodule_exit(nfc_exit);\n\nMODULE_AUTHOR(\"Lauro Ramos Venancio <lauro.venancio@openbossa.org>\");\nMODULE_DESCRIPTION(\"NFC Core ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_NFC);\nMODULE_ALIAS_GENL_FAMILY(NFC_GENL_NAME);\n"], "filenames": ["net/nfc/core.c"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [1175], "fixing_code_start_loc": [41], "fixing_code_end_loc": [1173], "type": "CWE-416", "message": "A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.", "other": {"cve": {"id": "CVE-2022-1974", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-31T16:15:10.007", "lastModified": "2022-09-07T15:54:56.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information."}, {"lang": "es", "value": "Se ha encontrado un fallo de uso de memoria previamente liberada en la funcionalidad del n\u00facleo NFC del kernel de Linux debido a una condici\u00f3n de carrera entre la creaci\u00f3n y el borrado de kobject. Esta vulnerabilidad permite a un atacante local con privilegios CAP_NET_ADMIN filtrar informaci\u00f3n del kernel"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc6:*:*:*:*:*:*", "matchCriteriaId": "EE723F14-047B-4FCF-B109-E0542EDFB063"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd"}}