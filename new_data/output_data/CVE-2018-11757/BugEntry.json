{"buggy_code": ["\"\"\"Executable Python script for a proxy service to dockerSkeleton.\n\nProvides a proxy service (using Flask, a Python web microframework)\nthat implements the required /init and /run routes to interact with\nthe OpenWhisk invoker service.\n\nThe implementation of these routes is encapsulated in a class named\nActionRunner which provides a basic framework for receiving code\nfrom an invoker, preparing it for execution, and then running the\ncode when required.\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"\"\"\n\nimport sys\nimport os\nimport json\nimport subprocess\nimport codecs\nimport flask\nfrom gevent.wsgi import WSGIServer\nimport zipfile\nimport io\nimport base64\n\n\nclass ActionRunner:\n    \"\"\"ActionRunner.\"\"\"\n    LOG_SENTINEL = 'XXX_THE_END_OF_A_WHISK_ACTIVATION_XXX'\n\n    # initializes the runner\n    # @param source the path where the source code will be located (if any)\n    # @param binary the path where the binary will be located (may be the\n    # same as source code path)\n    def __init__(self, source=None, binary=None, zipdest=None):\n        defaultBinary = '/action/exec'\n        self.source = source if source else defaultBinary\n        self.binary = binary if binary else defaultBinary\n        self.zipdest = zipdest if zipdest else os.path.dirname(self.source)\n\n    def preinit(self):\n        return\n\n    # extracts from the JSON object message a 'code' property and\n    # writes it to the <source> path. The source code may have an\n    # an optional <epilogue>. The source code is subsequently built\n    # to produce the <binary> that is executed during <run>.\n    # @param message is a JSON object, should contain 'code'\n    # @return True iff binary exists and is executable\n    def init(self, message):\n        def prep():\n            self.preinit()\n            if 'code' in message and message['code'] is not None:\n                binary = message['binary'] if 'binary' in message else False\n                if not binary:\n                    return self.initCodeFromString(message)\n                else:\n                    return self.initCodeFromZip(message)\n            else:\n                return False\n\n        if prep():\n            try:\n                # write source epilogue if any\n                # the message is passed along as it may contain other\n                # fields relevant to a specific container.\n                if self.epilogue(message) is False:\n                    return False\n                # build the source\n                if self.build(message) is False:\n                    return False\n            except Exception:\n                return False\n        # verify the binary exists and is executable\n        return self.verify()\n\n    # optionally appends source to the loaded code during <init>\n    def epilogue(self, init_arguments):\n        return\n\n    # optionally builds the source code loaded during <init> into an executable\n    def build(self, init_arguments):\n        return\n\n    # @return True iff binary exists and is executable, False otherwise\n    def verify(self):\n        return (os.path.isfile(self.binary) and\n                os.access(self.binary, os.X_OK))\n\n    # constructs an environment for the action to run in\n    # @param message is a JSON object received from invoker (should\n    # contain 'value' and 'api_key' and other metadata)\n    # @return an environment dictionary for the action process\n    def env(self, message):\n        # make sure to include all the env vars passed in by the invoker\n        env = os.environ\n        for p in ['api_key', 'namespace', 'action_name', 'activation_id', 'deadline']:\n            if p in message:\n                env['__OW_%s' % p.upper()] = message[p]\n        return env\n\n    # runs the action, called iff self.verify() is True.\n    # @param args is a JSON object representing the input to the action\n    # @param env is the environment for the action to run in (defined edge\n    # host, auth key)\n    # return JSON object result of running the action or an error dictionary\n    # if action failed\n    def run(self, args, env):\n        def error(msg):\n            # fall through (exception and else case are handled the same way)\n            sys.stdout.write('%s\\n' % msg)\n            return (502, {'error': 'The action did not return a dictionary.'})\n\n        try:\n            input = json.dumps(args)\n            if len(input) > 131071:             # MAX_ARG_STRLEN (131071) linux/binfmts.h\n                # pass argument via stdin\n                p = subprocess.Popen(\n                    [self.binary],\n                    stdin=subprocess.PIPE,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    env=env)\n            else:\n                # pass argument via stdin and command parameter\n                p = subprocess.Popen(\n                    [self.binary, input],\n                    stdin=subprocess.PIPE,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    env=env)\n            # run the process and wait until it completes.\n            # stdout/stderr will always be set because we passed PIPEs to Popen\n            (o, e) = p.communicate(input=input.encode())\n\n        except Exception as e:\n            return error(e)\n\n        # stdout/stderr may be either text or bytes, depending on Python\n        # version, so if bytes, decode to text. Note that in Python 2\n        # a string will match both types; so also skip decoding in that case\n        if isinstance(o, bytes) and not isinstance(o, str):\n            o = o.decode('utf-8')\n        if isinstance(e, bytes) and not isinstance(e, str):\n            e = e.decode('utf-8')\n\n        # get the last line of stdout, even if empty\n        lastNewLine = o.rfind('\\n', 0, len(o)-1)\n        if lastNewLine != -1:\n            # this is the result string to JSON parse\n            lastLine = o[lastNewLine+1:].strip()\n            # emit the rest as logs to stdout (including last new line)\n            sys.stdout.write(o[:lastNewLine+1])\n        else:\n            # either o is empty or it is the result string\n            lastLine = o.strip()\n\n        if e:\n            sys.stderr.write(e)\n\n        try:\n            json_output = json.loads(lastLine)\n            if isinstance(json_output, dict):\n                return (200, json_output)\n            else:\n                return error(lastLine)\n        except Exception:\n            return error(lastLine)\n\n    # initialize code from inlined string\n    def initCodeFromString(self, message):\n        with codecs.open(self.source, 'w', 'utf-8') as fp:\n            fp.write(message['code'])\n        return True\n\n    # initialize code from base64 encoded archive\n    def initCodeFromZip(self, message):\n        try:\n            bytes = base64.b64decode(message['code'])\n            bytes = io.BytesIO(bytes)\n            archive = zipfile.ZipFile(bytes)\n            archive.extractall(self.zipdest)\n            archive.close()\n            return True\n        except Exception as e:\n            print('err', str(e))\n            return False\n\nproxy = flask.Flask(__name__)\nproxy.debug = False\nrunner = None\n\n\ndef setRunner(r):\n    global runner\n    runner = r\n\n\n@proxy.route('/init', methods=['POST'])\ndef init():\n    message = flask.request.get_json(force=True, silent=True)\n    if message and not isinstance(message, dict):\n        flask.abort(404)\n    else:\n        value = message.get('value', {}) if message else {}\n\n    if not isinstance(value, dict):\n        flask.abort(404)\n\n    try:\n        status = runner.init(value)\n    except Exception as e:\n        status = False\n\n    if status is True:\n        return ('OK', 200)\n    else:\n        response = flask.jsonify({'error': 'The action failed to generate or locate a binary. See logs for details.'})\n        response.status_code = 502\n        return complete(response)\n\n\n@proxy.route('/run', methods=['POST'])\ndef run():\n    def error():\n        response = flask.jsonify({'error': 'The action did not receive a dictionary as an argument.'})\n        response.status_code = 404\n        return complete(response)\n\n    message = flask.request.get_json(force=True, silent=True)\n    if message and not isinstance(message, dict):\n        return error()\n    else:\n        args = message.get('value', {}) if message else {}\n        if not isinstance(args, dict):\n            return error()\n\n    if runner.verify():\n        try:\n            code, result = runner.run(args, runner.env(message or {}))\n            response = flask.jsonify(result)\n            response.status_code = code\n        except Exception as e:\n            response = flask.jsonify({'error': 'Internal error. {}'.format(e)})\n            response.status_code = 500\n    else:\n        response = flask.jsonify({'error': 'The action failed to locate a binary. See logs for details.'})\n        response.status_code = 502\n    return complete(response)\n\n\ndef complete(response):\n    # Add sentinel to stdout/stderr\n    sys.stdout.write('%s\\n' % ActionRunner.LOG_SENTINEL)\n    sys.stdout.flush()\n    sys.stderr.write('%s\\n' % ActionRunner.LOG_SENTINEL)\n    sys.stderr.flush()\n    return response\n\n\ndef main():\n    port = int(os.getenv('FLASK_PROXY_PORT', 8080))\n    server = WSGIServer(('0.0.0.0', port), proxy, log=None)\n    server.serve_forever()\n\nif __name__ == '__main__':\n    setRunner(ActionRunner())\n    main()\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage runtime.actionContainers\n\nimport java.io.File\nimport java.util.Base64\n\nimport org.apache.commons.io.FileUtils\nimport org.junit.runner.RunWith\nimport org.scalatest.junit.JUnitRunner\n\nimport actionContainers.{ActionContainer, BasicActionRunnerTests}\nimport actionContainers.ActionContainer.withContainer\nimport common.TestUtils\nimport common.WskActorSystem\nimport spray.json._\n\n@RunWith(classOf[JUnitRunner])\nclass ActionProxyContainerTests extends BasicActionRunnerTests with WskActorSystem {\n\n  override def withActionContainer(env: Map[String, String] = Map.empty)(code: ActionContainer => Unit) = {\n    withContainer(\"dockerskeleton\", env)(code)\n  }\n\n  val codeNotReturningJson = \"\"\"\n                               |#!/bin/sh\n                               |echo not a json object\n                             \"\"\".stripMargin.trim\n\n  /** Standard code samples, should print 'hello' to stdout and echo the input args. */\n  val stdCodeSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |echo 'hello stdout'\n                 |echo 'hello stderr' 1>&2\n                 |if [[ -z $1 || $1 == '{}' ]]; then\n                 |   echo '{ \"msg\": \"Hello from bash script!\" }'\n                 |else\n                 |   echo $1 # echo the arguments back as the result\n                 |fi\n               \"\"\".stripMargin.trim\n\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |from __future__ import print_function\n                   |import sys\n                   |print('hello stdout')\n                   |print('hello stderr', file=sys.stderr)\n                   |print(sys.argv[1])\n                 \"\"\".stripMargin.trim\n\n    val perl = \"\"\"\n                 |#!/usr/bin/env perl\n                 |print STDOUT \"hello stdout\\n\";\n                 |print STDERR \"hello stderr\\n\";\n                 |print $ARGV[0];\n               \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  val stdUnicodeSamples = {\n    // python 3 in base image\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |import json, sys\n                   |j = json.loads(sys.argv[1])\n                   |sep = j[\"delimiter\"]\n                   |s = sep + \" \u2603 \" + sep\n                   |print(s)\n                   |print(json.dumps({\"winter\": s}))\n                 \"\"\".stripMargin.trim\n\n    Seq((\"python\", python))\n  }\n\n  /** Standard code samples, should print 'hello' to stdout and echo the input args. */\n  val stdEnvSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |echo \"{ \\\n                 |\\\"api_host\\\": \\\"$__OW_API_HOST\\\", \\\"api_key\\\": \\\"$__OW_API_KEY\\\", \\\n                 |\\\"namespace\\\": \\\"$__OW_NAMESPACE\\\", \\\"action_name\\\": \\\"$__OW_ACTION_NAME\\\", \\\n                 |\\\"activation_id\\\": \\\"$__OW_ACTIVATION_ID\\\", \\\"deadline\\\": \\\"$__OW_DEADLINE\\\" }\"\n               \"\"\".stripMargin.trim\n\n    val python =\n      \"\"\"\n        |#!/usr/bin/env python\n        |import os\n        |\n        |print('{ \"api_host\": \"%s\", \"api_key\": \"%s\", \"namespace\": \"%s\", \"action_name\" : \"%s\", \"activation_id\": \"%s\", \"deadline\": \"%s\" }' % (\n        |  os.environ['__OW_API_HOST'], os.environ['__OW_API_KEY'],\n        |  os.environ['__OW_NAMESPACE'], os.environ['__OW_ACTION_NAME'],\n        |  os.environ['__OW_ACTIVATION_ID'], os.environ['__OW_DEADLINE']))\n      \"\"\".stripMargin.trim\n\n    val perl =\n      \"\"\"\n        |#!/usr/bin/env perl\n        |$a = $ENV{'__OW_API_HOST'};\n        |$b = $ENV{'__OW_API_KEY'};\n        |$c = $ENV{'__OW_NAMESPACE'};\n        |$d = $ENV{'__OW_ACTION_NAME'};\n        |$e = $ENV{'__OW_ACTIVATION_ID'};\n        |$f = $ENV{'__OW_DEADLINE'};\n        |print \"{ \\\"api_host\\\": \\\"$a\\\", \\\"api_key\\\": \\\"$b\\\", \\\"namespace\\\": \\\"$c\\\", \\\"action_name\\\": \\\"$d\\\", \\\"activation_id\\\": \\\"$e\\\", \\\"deadline\\\": \\\"$f\\\" }\";\n      \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  /** Large param samples, echo the input args with input larger than 128K and using STDIN */\n  val stdLargeInputSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |  read inputstring\n                 |  echo $inputstring\n               \"\"\".stripMargin.trim\n\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |import sys, json\n                   |params = sys.stdin.readline()\n                   |j = json.loads(params)\n                   |print(json.dumps(j))\n                 \"\"\".stripMargin.trim\n\n    val perl = \"\"\"\n                 |#!/usr/bin/env perl\n                 |$params=<STDIN>;\n                 |print $params;\n               \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  behavior of \"openwhisk/dockerskeleton\"\n\n  it should \"run sample without init\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"run sample with 'null' init\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(initPayload(null))\n      initCode should be(200)\n\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"run sample with init that does nothing\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(JsObject())\n      initCode should be(200)\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"respond with 404 for bad run argument\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (runCode, out) = c.run(runPayload(JsString(\"A\")))\n      runCode should be(404)\n    }\n\n    checkStreams(out, err, {\n      case (o, e) =>\n        o shouldBe empty\n        e shouldBe empty\n    })\n  }\n\n  it should \"fail to run a bad script\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(initPayload(\"\"))\n      initCode should be(200)\n      val (runCode, out) = c.run(JsNull)\n      runCode should be(502)\n      out should be(Some(JsObject(\"error\" -> JsString(\"The action did not return a dictionary.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"error\")\n    })\n  }\n\n  it should \"extract and run a compatible zip exec\" in {\n    val zip = FileUtils.readFileToByteArray(new File(TestUtils.getTestActionFilename(\"blackbox.zip\")))\n    val contents = Base64.getEncoder.encodeToString(zip)\n\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, err) =\n        c.init(JsObject(\"value\" -> JsObject(\"code\" -> JsString(contents), \"binary\" -> JsBoolean(true))))\n      initCode should be(200)\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out.get should be(JsObject(\"msg\" -> JsString(\"hello zip\")))\n    }\n\n    checkStreams(out, err, {\n      case (o, e) =>\n        o shouldBe \"This is an example zip used with the docker skeleton action.\"\n        e shouldBe empty\n    })\n  }\n\n  testNotReturningJson(codeNotReturningJson, checkResultInLogs = true)\n  testEcho(stdCodeSamples)\n  testUnicode(stdUnicodeSamples)\n  testEnv(stdEnvSamples)\n  testLargeInput(stdLargeInputSamples)\n}\n"], "fixing_code": ["\"\"\"Executable Python script for a proxy service to dockerSkeleton.\n\nProvides a proxy service (using Flask, a Python web microframework)\nthat implements the required /init and /run routes to interact with\nthe OpenWhisk invoker service.\n\nThe implementation of these routes is encapsulated in a class named\nActionRunner which provides a basic framework for receiving code\nfrom an invoker, preparing it for execution, and then running the\ncode when required.\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"\"\"\n\nimport sys\nimport os\nimport json\nimport subprocess\nimport codecs\nimport flask\nfrom gevent.wsgi import WSGIServer\nimport zipfile\nimport io\nimport base64\n\n\nclass ActionRunner:\n    \"\"\"ActionRunner.\"\"\"\n    LOG_SENTINEL = 'XXX_THE_END_OF_A_WHISK_ACTIVATION_XXX'\n\n    # initializes the runner\n    # @param source the path where the source code will be located (if any)\n    # @param binary the path where the binary will be located (may be the\n    # same as source code path)\n    def __init__(self, source=None, binary=None, zipdest=None):\n        defaultBinary = '/action/exec'\n        self.source = source if source else defaultBinary\n        self.binary = binary if binary else defaultBinary\n        self.zipdest = zipdest if zipdest else os.path.dirname(self.source)\n\n    def preinit(self):\n        return\n\n    # extracts from the JSON object message a 'code' property and\n    # writes it to the <source> path. The source code may have an\n    # an optional <epilogue>. The source code is subsequently built\n    # to produce the <binary> that is executed during <run>.\n    # @param message is a JSON object, should contain 'code'\n    # @return True iff binary exists and is executable\n    def init(self, message):\n        def prep():\n            self.preinit()\n            if 'code' in message and message['code'] is not None:\n                binary = message['binary'] if 'binary' in message else False\n                if not binary:\n                    return self.initCodeFromString(message)\n                else:\n                    return self.initCodeFromZip(message)\n            else:\n                return False\n\n        if prep():\n            try:\n                # write source epilogue if any\n                # the message is passed along as it may contain other\n                # fields relevant to a specific container.\n                if self.epilogue(message) is False:\n                    return False\n                # build the source\n                if self.build(message) is False:\n                    return False\n            except Exception:\n                return False\n        # verify the binary exists and is executable\n        return self.verify()\n\n    # optionally appends source to the loaded code during <init>\n    def epilogue(self, init_arguments):\n        return\n\n    # optionally builds the source code loaded during <init> into an executable\n    def build(self, init_arguments):\n        return\n\n    # @return True iff binary exists and is executable, False otherwise\n    def verify(self):\n        return (os.path.isfile(self.binary) and\n                os.access(self.binary, os.X_OK))\n\n    # constructs an environment for the action to run in\n    # @param message is a JSON object received from invoker (should\n    # contain 'value' and 'api_key' and other metadata)\n    # @return an environment dictionary for the action process\n    def env(self, message):\n        # make sure to include all the env vars passed in by the invoker\n        env = os.environ\n        for p in ['api_key', 'namespace', 'action_name', 'activation_id', 'deadline']:\n            if p in message:\n                env['__OW_%s' % p.upper()] = message[p]\n        return env\n\n    # runs the action, called iff self.verify() is True.\n    # @param args is a JSON object representing the input to the action\n    # @param env is the environment for the action to run in (defined edge\n    # host, auth key)\n    # return JSON object result of running the action or an error dictionary\n    # if action failed\n    def run(self, args, env):\n        def error(msg):\n            # fall through (exception and else case are handled the same way)\n            sys.stdout.write('%s\\n' % msg)\n            return (502, {'error': 'The action did not return a dictionary.'})\n\n        try:\n            input = json.dumps(args)\n            if len(input) > 131071:             # MAX_ARG_STRLEN (131071) linux/binfmts.h\n                # pass argument via stdin\n                p = subprocess.Popen(\n                    [self.binary],\n                    stdin=subprocess.PIPE,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    env=env)\n            else:\n                # pass argument via stdin and command parameter\n                p = subprocess.Popen(\n                    [self.binary, input],\n                    stdin=subprocess.PIPE,\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    env=env)\n            # run the process and wait until it completes.\n            # stdout/stderr will always be set because we passed PIPEs to Popen\n            (o, e) = p.communicate(input=input.encode())\n\n        except Exception as e:\n            return error(e)\n\n        # stdout/stderr may be either text or bytes, depending on Python\n        # version, so if bytes, decode to text. Note that in Python 2\n        # a string will match both types; so also skip decoding in that case\n        if isinstance(o, bytes) and not isinstance(o, str):\n            o = o.decode('utf-8')\n        if isinstance(e, bytes) and not isinstance(e, str):\n            e = e.decode('utf-8')\n\n        # get the last line of stdout, even if empty\n        lastNewLine = o.rfind('\\n', 0, len(o)-1)\n        if lastNewLine != -1:\n            # this is the result string to JSON parse\n            lastLine = o[lastNewLine+1:].strip()\n            # emit the rest as logs to stdout (including last new line)\n            sys.stdout.write(o[:lastNewLine+1])\n        else:\n            # either o is empty or it is the result string\n            lastLine = o.strip()\n\n        if e:\n            sys.stderr.write(e)\n\n        try:\n            json_output = json.loads(lastLine)\n            if isinstance(json_output, dict):\n                return (200, json_output)\n            else:\n                return error(lastLine)\n        except Exception:\n            return error(lastLine)\n\n    # initialize code from inlined string\n    def initCodeFromString(self, message):\n        with codecs.open(self.source, 'w', 'utf-8') as fp:\n            fp.write(message['code'])\n        return True\n\n    # initialize code from base64 encoded archive\n    def initCodeFromZip(self, message):\n        try:\n            bytes = base64.b64decode(message['code'])\n            bytes = io.BytesIO(bytes)\n            archive = zipfile.ZipFile(bytes)\n            archive.extractall(self.zipdest)\n            archive.close()\n            return True\n        except Exception as e:\n            print('err', str(e))\n            return False\n\nproxy = flask.Flask(__name__)\nproxy.debug = False\n# disable re-initialization of the executable unless explicitly allowed via an environment\n# variable PROXY_ALLOW_REINIT == \"1\" (this is generally useful for local testing and development)\nproxy.rejectReinit = 'PROXY_ALLOW_REINIT' not in os.environ or os.environ['PROXY_ALLOW_REINIT'] != \"1\"\nproxy.initialized = False\nrunner = None\n\ndef setRunner(r):\n    global runner\n    runner = r\n\n\n@proxy.route('/init', methods=['POST'])\ndef init():\n    if proxy.rejectReinit is True and proxy.initialized is True:\n        msg = 'Cannot initialize the action more than once.'\n        sys.stderr.write(msg + '\\n')\n        response = flask.jsonify({'error': msg})\n        response.status_code = 403\n        return complete(response)\n\n    message = flask.request.get_json(force=True, silent=True)\n    if message and not isinstance(message, dict):\n        flask.abort(404)\n    else:\n        value = message.get('value', {}) if message else {}\n\n    if not isinstance(value, dict):\n        flask.abort(404)\n\n    try:\n        status = runner.init(value)\n    except Exception as e:\n        status = False\n\n    if status is True:\n        proxy.initialized = True\n        return ('OK', 200)\n    else:\n        response = flask.jsonify({'error': 'The action failed to generate or locate a binary. See logs for details.'})\n        response.status_code = 502\n        return complete(response)\n\n\n@proxy.route('/run', methods=['POST'])\ndef run():\n    def error():\n        response = flask.jsonify({'error': 'The action did not receive a dictionary as an argument.'})\n        response.status_code = 404\n        return complete(response)\n\n    message = flask.request.get_json(force=True, silent=True)\n    if message and not isinstance(message, dict):\n        return error()\n    else:\n        args = message.get('value', {}) if message else {}\n        if not isinstance(args, dict):\n            return error()\n\n    if runner.verify():\n        try:\n            code, result = runner.run(args, runner.env(message or {}))\n            response = flask.jsonify(result)\n            response.status_code = code\n        except Exception as e:\n            response = flask.jsonify({'error': 'Internal error. {}'.format(e)})\n            response.status_code = 500\n    else:\n        response = flask.jsonify({'error': 'The action failed to locate a binary. See logs for details.'})\n        response.status_code = 502\n    return complete(response)\n\n\ndef complete(response):\n    # Add sentinel to stdout/stderr\n    sys.stdout.write('%s\\n' % ActionRunner.LOG_SENTINEL)\n    sys.stdout.flush()\n    sys.stderr.write('%s\\n' % ActionRunner.LOG_SENTINEL)\n    sys.stderr.flush()\n    return response\n\n\ndef main():\n    port = int(os.getenv('FLASK_PROXY_PORT', 8080))\n    server = WSGIServer(('0.0.0.0', port), proxy, log=None)\n    server.serve_forever()\n\nif __name__ == '__main__':\n    setRunner(ActionRunner())\n    main()\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage runtime.actionContainers\n\nimport java.io.File\nimport java.util.Base64\n\nimport org.apache.commons.io.FileUtils\nimport org.junit.runner.RunWith\nimport org.scalatest.junit.JUnitRunner\n\nimport actionContainers.{ActionContainer, BasicActionRunnerTests}\nimport actionContainers.ActionContainer.withContainer\nimport common.TestUtils\nimport common.WskActorSystem\nimport spray.json._\n\n@RunWith(classOf[JUnitRunner])\nclass ActionProxyContainerTests extends BasicActionRunnerTests with WskActorSystem {\n\n  override def withActionContainer(env: Map[String, String] = Map.empty)(code: ActionContainer => Unit) = {\n    withContainer(\"dockerskeleton\", env)(code)\n  }\n\n  val codeNotReturningJson = \"\"\"\n                               |#!/bin/sh\n                               |echo not a json object\n                             \"\"\".stripMargin.trim\n\n  /** Standard code samples, should print 'hello' to stdout and echo the input args. */\n  val stdCodeSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |echo 'hello stdout'\n                 |echo 'hello stderr' 1>&2\n                 |if [[ -z $1 || $1 == '{}' ]]; then\n                 |   echo '{ \"msg\": \"Hello from bash script!\" }'\n                 |else\n                 |   echo $1 # echo the arguments back as the result\n                 |fi\n               \"\"\".stripMargin.trim\n\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |from __future__ import print_function\n                   |import sys\n                   |print('hello stdout')\n                   |print('hello stderr', file=sys.stderr)\n                   |print(sys.argv[1])\n                 \"\"\".stripMargin.trim\n\n    val perl = \"\"\"\n                 |#!/usr/bin/env perl\n                 |print STDOUT \"hello stdout\\n\";\n                 |print STDERR \"hello stderr\\n\";\n                 |print $ARGV[0];\n               \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  val stdUnicodeSamples = {\n    // python 3 in base image\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |import json, sys\n                   |j = json.loads(sys.argv[1])\n                   |sep = j[\"delimiter\"]\n                   |s = sep + \" \u2603 \" + sep\n                   |print(s)\n                   |print(json.dumps({\"winter\": s}))\n                 \"\"\".stripMargin.trim\n\n    Seq((\"python\", python))\n  }\n\n  /** Standard code samples, should print 'hello' to stdout and echo the input args. */\n  val stdEnvSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |echo \"{ \\\n                 |\\\"api_host\\\": \\\"$__OW_API_HOST\\\", \\\"api_key\\\": \\\"$__OW_API_KEY\\\", \\\n                 |\\\"namespace\\\": \\\"$__OW_NAMESPACE\\\", \\\"action_name\\\": \\\"$__OW_ACTION_NAME\\\", \\\n                 |\\\"activation_id\\\": \\\"$__OW_ACTIVATION_ID\\\", \\\"deadline\\\": \\\"$__OW_DEADLINE\\\" }\"\n               \"\"\".stripMargin.trim\n\n    val python =\n      \"\"\"\n        |#!/usr/bin/env python\n        |import os\n        |\n        |print('{ \"api_host\": \"%s\", \"api_key\": \"%s\", \"namespace\": \"%s\", \"action_name\" : \"%s\", \"activation_id\": \"%s\", \"deadline\": \"%s\" }' % (\n        |  os.environ['__OW_API_HOST'], os.environ['__OW_API_KEY'],\n        |  os.environ['__OW_NAMESPACE'], os.environ['__OW_ACTION_NAME'],\n        |  os.environ['__OW_ACTIVATION_ID'], os.environ['__OW_DEADLINE']))\n      \"\"\".stripMargin.trim\n\n    val perl =\n      \"\"\"\n        |#!/usr/bin/env perl\n        |$a = $ENV{'__OW_API_HOST'};\n        |$b = $ENV{'__OW_API_KEY'};\n        |$c = $ENV{'__OW_NAMESPACE'};\n        |$d = $ENV{'__OW_ACTION_NAME'};\n        |$e = $ENV{'__OW_ACTIVATION_ID'};\n        |$f = $ENV{'__OW_DEADLINE'};\n        |print \"{ \\\"api_host\\\": \\\"$a\\\", \\\"api_key\\\": \\\"$b\\\", \\\"namespace\\\": \\\"$c\\\", \\\"action_name\\\": \\\"$d\\\", \\\"activation_id\\\": \\\"$e\\\", \\\"deadline\\\": \\\"$f\\\" }\";\n      \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  /** Large param samples, echo the input args with input larger than 128K and using STDIN */\n  val stdLargeInputSamples = {\n    val bash = \"\"\"\n                 |#!/bin/bash\n                 |  read inputstring\n                 |  echo $inputstring\n               \"\"\".stripMargin.trim\n\n    val python = \"\"\"\n                   |#!/usr/bin/env python\n                   |import sys, json\n                   |params = sys.stdin.readline()\n                   |j = json.loads(params)\n                   |print(json.dumps(j))\n                 \"\"\".stripMargin.trim\n\n    val perl = \"\"\"\n                 |#!/usr/bin/env perl\n                 |$params=<STDIN>;\n                 |print $params;\n               \"\"\".stripMargin.trim\n\n    Seq((\"bash\", bash), (\"python\", python), (\"perl\", perl))\n  }\n\n  behavior of \"openwhisk/dockerskeleton\"\n\n  it should \"run sample without init\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"run sample with 'null' init\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(initPayload(null))\n      initCode should be(200)\n\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"run sample with init that does nothing\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(JsObject())\n      initCode should be(200)\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out should be(Some(JsObject(\"error\" -> JsString(\"This is a stub action. Replace it with custom logic.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"This is a stub action\")\n    })\n  }\n\n  it should \"respond with 404 for bad run argument\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (runCode, out) = c.run(runPayload(JsString(\"A\")))\n      runCode should be(404)\n    }\n\n    checkStreams(out, err, {\n      case (o, e) =>\n        o shouldBe empty\n        e shouldBe empty\n    })\n  }\n\n  it should \"fail to run a bad script\" in {\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, _) = c.init(initPayload(\"\"))\n      initCode should be(200)\n      val (runCode, out) = c.run(JsNull)\n      runCode should be(502)\n      out should be(Some(JsObject(\"error\" -> JsString(\"The action did not return a dictionary.\"))))\n    }\n\n    checkStreams(out, err, {\n      case (o, _) => o should include(\"error\")\n    })\n  }\n\n  it should \"extract and run a compatible zip exec\" in {\n    val zip = FileUtils.readFileToByteArray(new File(TestUtils.getTestActionFilename(\"blackbox.zip\")))\n    val contents = Base64.getEncoder.encodeToString(zip)\n\n    val (out, err) = withActionContainer() { c =>\n      val (initCode, err) =\n        c.init(JsObject(\"value\" -> JsObject(\"code\" -> JsString(contents), \"binary\" -> JsBoolean(true))))\n      initCode should be(200)\n      val (runCode, out) = c.run(JsObject())\n      runCode should be(200)\n      out.get should be(JsObject(\"msg\" -> JsString(\"hello zip\")))\n    }\n\n    checkStreams(out, err, {\n      case (o, e) =>\n        o shouldBe \"This is an example zip used with the docker skeleton action.\"\n        e shouldBe empty\n    })\n  }\n\n  testNotReturningJson(codeNotReturningJson, checkResultInLogs = true)\n  testEcho(stdCodeSamples)\n  testUnicode(stdUnicodeSamples)\n  testEnv(stdEnvSamples)\n  testLargeInput(stdLargeInputSamples)\n  testInitCannotBeCalledMoreThanOnce(codeNotReturningJson) // any code sample will do\n}\n"], "filenames": ["core/actionProxy/actionproxy.py", "tests/src/test/scala/runtime/actionContainers/ActionProxyContainerTests.scala"], "buggy_code_start_loc": [205, 247], "buggy_code_end_loc": [230, 247], "fixing_code_start_loc": [206, 248], "fixing_code_end_loc": [242, 249], "type": "NVD-CWE-noinfo", "message": "In Docker Skeleton Runtime for Apache OpenWhisk, a Docker action inheriting the Docker tag openwhisk/dockerskeleton:1.3.0 (or earlier) may allow an attacker to replace the user function inside the container if the user code is vulnerable to code exploitation.", "other": {"cve": {"id": "CVE-2018-11757", "sourceIdentifier": "security@apache.org", "published": "2018-07-23T17:29:00.307", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Docker Skeleton Runtime for Apache OpenWhisk, a Docker action inheriting the Docker tag openwhisk/dockerskeleton:1.3.0 (or earlier) may allow an attacker to replace the user function inside the container if the user code is vulnerable to code exploitation."}, {"lang": "es", "value": "En Docker Skeleton Runtime para Apache OpenWhisk, una acci\u00f3n Docker que hereda la etiqueta Docker openwhisk/dockerskeleton:1.3.0 (o anteriores) podr\u00eda permitir que un atacante reemplace la funci\u00f3n de usuario en el contenedor si el c\u00f3digo de usuario es vulnerable a la explotaci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:openwhisk:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.0", "matchCriteriaId": "1E71A7E0-15F0-4E12-8094-A5CE9EB4A38E"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104913", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/apache/incubator-openwhisk-runtime-docker/commit/891896f25c39bc336ef6dda53f80f466ac4ca3c8", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/0b6d8a677f1c063ed32eb3638ef4d1a47dfba8907de4b222ddd24b05@%3Cdev.openwhisk.apache.org%3E", "source": "security@apache.org", "tags": ["Mitigation", "Mailing List", "Vendor Advisory"]}, {"url": "https://www.puresec.io/hubfs/Apache%20OpenWhisk%20PureSec%20Security%20Advisory.pdf", "source": "nvd@nist.gov", "tags": ["Mitigation", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apache/incubator-openwhisk-runtime-docker/commit/891896f25c39bc336ef6dda53f80f466ac4ca3c8"}}