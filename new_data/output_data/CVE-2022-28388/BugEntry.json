{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * CAN driver for \"8 devices\" USB2CAN converter\n *\n * Copyright (C) 2012 Bernd Krumboeck (krumboeck@universalnet.at)\n *\n * This driver is inspired by the 3.2.0 version of drivers/net/can/usb/ems_usb.c\n * and drivers/net/can/usb/esd_usb2.c\n *\n * Many thanks to Gerhard Bertelsmann (info@gerhard-bertelsmann.de)\n * for testing and fixing this driver. Also many thanks to \"8 devices\",\n * who were very cooperative and answered my questions.\n */\n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/led.h>\n\n/* driver constants */\n#define MAX_RX_URBS\t\t\t20\n#define MAX_TX_URBS\t\t\t20\n#define RX_BUFFER_SIZE\t\t\t64\n\n/* vendor and product id */\n#define USB_8DEV_VENDOR_ID\t\t0x0483\n#define USB_8DEV_PRODUCT_ID\t\t0x1234\n\n/* endpoints */\nenum usb_8dev_endpoint {\n\tUSB_8DEV_ENDP_DATA_RX = 1,\n\tUSB_8DEV_ENDP_DATA_TX,\n\tUSB_8DEV_ENDP_CMD_RX,\n\tUSB_8DEV_ENDP_CMD_TX\n};\n\n/* device CAN clock */\n#define USB_8DEV_ABP_CLOCK\t\t32000000\n\n/* setup flags */\n#define USB_8DEV_SILENT\t\t\t0x01\n#define USB_8DEV_LOOPBACK\t\t0x02\n#define USB_8DEV_DISABLE_AUTO_RESTRANS\t0x04\n#define USB_8DEV_STATUS_FRAME\t\t0x08\n\n/* commands */\nenum usb_8dev_cmd {\n\tUSB_8DEV_RESET = 1,\n\tUSB_8DEV_OPEN,\n\tUSB_8DEV_CLOSE,\n\tUSB_8DEV_SET_SPEED,\n\tUSB_8DEV_SET_MASK_FILTER,\n\tUSB_8DEV_GET_STATUS,\n\tUSB_8DEV_GET_STATISTICS,\n\tUSB_8DEV_GET_SERIAL,\n\tUSB_8DEV_GET_SOFTW_VER,\n\tUSB_8DEV_GET_HARDW_VER,\n\tUSB_8DEV_RESET_TIMESTAMP,\n\tUSB_8DEV_GET_SOFTW_HARDW_VER\n};\n\n/* command options */\n#define USB_8DEV_BAUD_MANUAL\t\t0x09\n#define USB_8DEV_CMD_START\t\t0x11\n#define USB_8DEV_CMD_END\t\t0x22\n\n#define USB_8DEV_CMD_SUCCESS\t\t0\n#define USB_8DEV_CMD_ERROR\t\t255\n\n#define USB_8DEV_CMD_TIMEOUT\t\t1000\n\n/* frames */\n#define USB_8DEV_DATA_START\t\t0x55\n#define USB_8DEV_DATA_END\t\t0xAA\n\n#define USB_8DEV_TYPE_CAN_FRAME\t\t0\n#define USB_8DEV_TYPE_ERROR_FRAME\t3\n\n#define USB_8DEV_EXTID\t\t\t0x01\n#define USB_8DEV_RTR\t\t\t0x02\n#define USB_8DEV_ERR_FLAG\t\t0x04\n\n/* status */\n#define USB_8DEV_STATUSMSG_OK\t\t0x00  /* Normal condition. */\n#define USB_8DEV_STATUSMSG_OVERRUN\t0x01  /* Overrun occurred when sending */\n#define USB_8DEV_STATUSMSG_BUSLIGHT\t0x02  /* Error counter has reached 96 */\n#define USB_8DEV_STATUSMSG_BUSHEAVY\t0x03  /* Error count. has reached 128 */\n#define USB_8DEV_STATUSMSG_BUSOFF\t0x04  /* Device is in BUSOFF */\n#define USB_8DEV_STATUSMSG_STUFF\t0x20  /* Stuff Error */\n#define USB_8DEV_STATUSMSG_FORM\t\t0x21  /* Form Error */\n#define USB_8DEV_STATUSMSG_ACK\t\t0x23  /* Ack Error */\n#define USB_8DEV_STATUSMSG_BIT0\t\t0x24  /* Bit1 Error */\n#define USB_8DEV_STATUSMSG_BIT1\t\t0x25  /* Bit0 Error */\n#define USB_8DEV_STATUSMSG_CRC\t\t0x27  /* CRC Error */\n\n#define USB_8DEV_RP_MASK\t\t0x7F  /* Mask for Receive Error Bit */\n\n\n/* table of devices that work with this driver */\nstatic const struct usb_device_id usb_8dev_table[] = {\n\t{ USB_DEVICE(USB_8DEV_VENDOR_ID, USB_8DEV_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, usb_8dev_table);\n\nstruct usb_8dev_tx_urb_context {\n\tstruct usb_8dev_priv *priv;\n\n\tu32 echo_index;\n};\n\n/* Structure to hold all of our device specific stuff */\nstruct usb_8dev_priv {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\tatomic_t active_tx_urbs;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_8dev_tx_urb_context tx_contexts[MAX_TX_URBS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tstruct can_berr_counter bec;\n\n\tu8 *cmd_msg_buffer;\n\n\tstruct mutex usb_8dev_cmd_lock;\n\tvoid *rxbuf[MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MAX_RX_URBS];\n};\n\n/* tx frame */\nstruct __packed usb_8dev_tx_msg {\n\tu8 begin;\n\tu8 flags;\t/* RTR and EXT_ID flag */\n\t__be32 id;\t/* upper 3 bits not used */\n\tu8 dlc;\t\t/* data length code 0-8 bytes */\n\tu8 data[8];\t/* 64-bit data */\n\tu8 end;\n};\n\n/* rx frame */\nstruct __packed usb_8dev_rx_msg {\n\tu8 begin;\n\tu8 type;\t\t/* frame type */\n\tu8 flags;\t\t/* RTR and EXT_ID flag */\n\t__be32 id;\t\t/* upper 3 bits not used */\n\tu8 dlc;\t\t\t/* data length code 0-8 bytes */\n\tu8 data[8];\t\t/* 64-bit data */\n\t__be32 timestamp;\t/* 32-bit timestamp */\n\tu8 end;\n};\n\n/* command frame */\nstruct __packed usb_8dev_cmd_msg {\n\tu8 begin;\n\tu8 channel;\t/* unknown - always 0 */\n\tu8 command;\t/* command to execute */\n\tu8 opt1;\t/* optional parameter / return value */\n\tu8 opt2;\t/* optional parameter 2 */\n\tu8 data[10];\t/* optional parameter and data */\n\tu8 end;\n};\n\nstatic int usb_8dev_send_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size)\n{\n\tint actual_length;\n\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_TX),\n\t\t\t    msg, size, &actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\nstatic int usb_8dev_wait_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size,\n\t\t\t\tint *actual_length)\n{\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_RX),\n\t\t\t    msg, size, actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\n/* Send command to device and receive result.\n * Command was successful when opt1 = 0.\n */\nstatic int usb_8dev_send_cmd(struct usb_8dev_priv *priv,\n\t\t\t     struct usb_8dev_cmd_msg *out,\n\t\t\t     struct usb_8dev_cmd_msg *in)\n{\n\tint err;\n\tint num_bytes_read;\n\tstruct net_device *netdev;\n\n\tnetdev = priv->netdev;\n\n\tout->begin = USB_8DEV_CMD_START;\n\tout->end = USB_8DEV_CMD_END;\n\n\tmutex_lock(&priv->usb_8dev_cmd_lock);\n\n\tmemcpy(priv->cmd_msg_buffer, out,\n\t\tsizeof(struct usb_8dev_cmd_msg));\n\n\terr = usb_8dev_send_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg));\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"sending command message failed\\n\");\n\t\tgoto failed;\n\t}\n\n\terr = usb_8dev_wait_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t    &num_bytes_read);\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"no command message answer\\n\");\n\t\tgoto failed;\n\t}\n\n\tmemcpy(in, priv->cmd_msg_buffer, sizeof(struct usb_8dev_cmd_msg));\n\n\tif (in->begin != USB_8DEV_CMD_START || in->end != USB_8DEV_CMD_END ||\n\t\t\tnum_bytes_read != 16 || in->opt1 != 0)\n\t\terr = -EPROTO;\n\nfailed:\n\tmutex_unlock(&priv->usb_8dev_cmd_lock);\n\treturn err;\n}\n\n/* Send open command to device */\nstatic int usb_8dev_cmd_open(struct usb_8dev_priv *priv)\n{\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct usb_8dev_cmd_msg outmsg;\n\tstruct usb_8dev_cmd_msg inmsg;\n\tu32 ctrlmode = priv->can.ctrlmode;\n\tu32 flags = USB_8DEV_STATUS_FRAME;\n\t__be32 beflags;\n\t__be16 bebrp;\n\n\tmemset(&outmsg, 0, sizeof(outmsg));\n\toutmsg.command = USB_8DEV_OPEN;\n\toutmsg.opt1 = USB_8DEV_BAUD_MANUAL;\n\toutmsg.data[0] = bt->prop_seg + bt->phase_seg1;\n\toutmsg.data[1] = bt->phase_seg2;\n\toutmsg.data[2] = bt->sjw;\n\n\t/* BRP */\n\tbebrp = cpu_to_be16((u16)bt->brp);\n\tmemcpy(&outmsg.data[3], &bebrp, sizeof(bebrp));\n\n\t/* flags */\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tflags |= USB_8DEV_LOOPBACK;\n\tif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tflags |= USB_8DEV_SILENT;\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tflags |= USB_8DEV_DISABLE_AUTO_RESTRANS;\n\n\tbeflags = cpu_to_be32(flags);\n\tmemcpy(&outmsg.data[5], &beflags, sizeof(beflags));\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n/* Send close command to device */\nstatic int usb_8dev_cmd_close(struct usb_8dev_priv *priv)\n{\n\tstruct usb_8dev_cmd_msg inmsg;\n\tstruct usb_8dev_cmd_msg outmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_CLOSE,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n/* Get firmware and hardware version */\nstatic int usb_8dev_cmd_version(struct usb_8dev_priv *priv, u32 *res)\n{\n\tstruct usb_8dev_cmd_msg\tinmsg;\n\tstruct usb_8dev_cmd_msg\toutmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_GET_SOFTW_HARDW_VER,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\tint err = usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n\tif (err)\n\t\treturn err;\n\n\t*res = be32_to_cpup((__be32 *)inmsg.data);\n\n\treturn err;\n}\n\n/* Set network device mode\n *\n * Maybe we should leave this function empty, because the device\n * set mode variable with open command.\n */\nstatic int usb_8dev_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = usb_8dev_cmd_open(priv);\n\t\tif (err)\n\t\t\tnetdev_warn(netdev, \"couldn't start device\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n/* Read error/status frames */\nstatic void usb_8dev_rx_err_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t/* Error message:\n\t * byte 0: Status\n\t * byte 1: bit   7: Receive Passive\n\t * byte 1: bit 0-6: Receive Error Counter\n\t * byte 2: Transmit Error Counter\n\t * byte 3: Always 0 (maybe reserved for future use)\n\t */\n\n\tu8 state = msg->data[0];\n\tu8 rxerr = msg->data[1] & USB_8DEV_RP_MASK;\n\tu8 txerr = msg->data[2];\n\tint rx_errors = 0;\n\tint tx_errors = 0;\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tcf->data[2] = CAN_ERR_PROT_ACTIVE;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(priv->netdev);\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tbreak;\n\tdefault:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_ACK:\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_CRC:\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT0:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT1:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_FORM:\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_STUFF:\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tpriv->can.can_stats.error_warning++;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\tpriv->can.can_stats.error_passive++;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unknown status/error message (%d)\\n\", state);\n\t\tbreak;\n\t}\n\n\tif (tx_errors) {\n\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\tstats->tx_errors++;\n\t}\n\n\tif (rx_errors)\n\t\tstats->rx_errors++;\n\n\tcf->data[6] = txerr;\n\tcf->data[7] = rxerr;\n\n\tpriv->bec.txerr = txerr;\n\tpriv->bec.rxerr = rxerr;\n\n\tnetif_rx(skb);\n}\n\n/* Read data and status frames */\nstatic void usb_8dev_rx_can_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\tif (msg->type == USB_8DEV_TYPE_ERROR_FRAME &&\n\t\t   msg->flags == USB_8DEV_ERR_FLAG) {\n\t\tusb_8dev_rx_err_msg(priv, msg);\n\t} else if (msg->type == USB_8DEV_TYPE_CAN_FRAME) {\n\t\tskb = alloc_can_skb(priv->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = be32_to_cpu(msg->id);\n\t\tcan_frame_set_cc_len(cf, msg->dlc & 0xF, priv->can.ctrlmode);\n\n\t\tif (msg->flags & USB_8DEV_EXTID)\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\t\tif (msg->flags & USB_8DEV_RTR) {\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\t} else {\n\t\t\tmemcpy(cf->data, msg->data, cf->len);\n\t\t\tstats->rx_bytes += cf->len;\n\t\t}\n\t\tstats->rx_packets++;\n\n\t\tnetif_rx(skb);\n\n\t\tcan_led_event(priv->netdev, CAN_LED_EVENT_RX);\n\t} else {\n\t\tnetdev_warn(priv->netdev, \"frame type %d unknown\",\n\t\t\t msg->type);\n\t}\n\n}\n\n/* Callback for reading data from device\n *\n * Check urb status, call read function and resubmit urb read operation.\n */\nstatic void usb_8dev_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct usb_8dev_rx_msg *msg;\n\n\t\tif (pos + sizeof(struct usb_8dev_rx_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct usb_8dev_rx_msg *)(urb->transfer_buffer + pos);\n\t\tusb_8dev_rx_can_msg(priv, msg);\n\n\t\tpos += sizeof(struct usb_8dev_rx_msg);\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_RX),\n\t\t\t  urb->transfer_buffer, RX_BUFFER_SIZE,\n\t\t\t  usb_8dev_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev,\n\t\t\t\"failed resubmitting read bulk urb: %d\\n\", retval);\n}\n\n/* Callback handler for write operations\n *\n * Free allocated buffers, check transmit status and\n * calculate statistic.\n */\nstatic void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\tcan_led_event(netdev, CAN_LED_EVENT_TX);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}\n\n/* Send data to device */\nstatic netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\telse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nfailed:\n\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse\n\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int usb_8dev_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\n/* Start USB device */\nstatic int usb_8dev_start(struct usb_8dev_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tfor (i = 0; i < MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev,\n\t\t\t\t\t\t  USB_8DEV_ENDP_DATA_RX),\n\t\t\t\t  buf, RX_BUFFER_SIZE,\n\t\t\t\t  usb_8dev_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\terr = usb_8dev_cmd_open(priv);\n\tif (err)\n\t\tgoto failed;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nfailed:\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\treturn err;\n}\n\n/* Open USB device */\nstatic int usb_8dev_open(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\tcan_led_event(netdev, CAN_LED_EVENT_OPEN);\n\n\t/* finally start device */\n\terr = usb_8dev_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\",\n\t\t\t err);\n\n\t\tclose_candev(netdev);\n\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void unlink_all_urbs(struct usb_8dev_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n}\n\n/* Close USB device */\nstatic int usb_8dev_close(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\t/* Send CLOSE command to CAN controller */\n\terr = usb_8dev_cmd_close(priv);\n\tif (err)\n\t\tnetdev_warn(netdev, \"couldn't stop device\");\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tunlink_all_urbs(priv);\n\n\tclose_candev(netdev);\n\n\tcan_led_event(netdev, CAN_LED_EVENT_STOP);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops usb_8dev_netdev_ops = {\n\t.ndo_open = usb_8dev_open,\n\t.ndo_stop = usb_8dev_close,\n\t.ndo_start_xmit = usb_8dev_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct can_bittiming_const usb_8dev_bittiming_const = {\n\t.name = \"usb_8dev\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n/* Probe USB device\n *\n * Check device and firmware.\n * Set supported modes and bittiming constants.\n * Allocate some memory.\n */\nstatic int usb_8dev_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct usb_8dev_priv *priv;\n\tint i, err = -ENOMEM;\n\tu32 version;\n\tchar buf[18];\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\t/* product id looks strange, better we also check iProduct string */\n\tif (usb_string(usbdev, usbdev->descriptor.iProduct, buf,\n\t\t       sizeof(buf)) > 0 && strcmp(buf, \"USB2CAN converter\")) {\n\t\tdev_info(&usbdev->dev, \"ignoring: not an USB2CAN converter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev = alloc_candev(sizeof(struct usb_8dev_priv), MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.clock.freq = USB_8DEV_ABP_CLOCK;\n\tpriv->can.bittiming_const = &usb_8dev_bittiming_const;\n\tpriv->can.do_set_mode = usb_8dev_set_mode;\n\tpriv->can.do_get_berr_counter = usb_8dev_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t      CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t      CAN_CTRLMODE_ONE_SHOT |\n\t\t\t\t      CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tnetdev->netdev_ops = &usb_8dev_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n\n\tpriv->cmd_msg_buffer = devm_kzalloc(&intf->dev, sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!priv->cmd_msg_buffer)\n\t\tgoto cleanup_candev;\n\n\tusb_set_intfdata(intf, priv);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tmutex_init(&priv->usb_8dev_cmd_lock);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t\"couldn't register CAN device: %d\\n\", err);\n\t\tgoto cleanup_candev;\n\t}\n\n\terr = usb_8dev_cmd_version(priv, &version);\n\tif (err) {\n\t\tnetdev_err(netdev, \"can't get firmware version\\n\");\n\t\tgoto cleanup_unregister_candev;\n\t} else {\n\t\tnetdev_info(netdev,\n\t\t\t \"firmware: %d.%d, hardware: %d.%d\\n\",\n\t\t\t (version>>24) & 0xff, (version>>16) & 0xff,\n\t\t\t (version>>8) & 0xff, version & 0xff);\n\t}\n\n\tdevm_can_led_init(netdev);\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_netdev(priv->netdev);\n\ncleanup_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n\n}\n\n/* Called by the usb core when driver is unloaded or device is removed */\nstatic void usb_8dev_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_8dev_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (priv) {\n\t\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\t\tunregister_netdev(priv->netdev);\n\t\tunlink_all_urbs(priv);\n\t\tfree_candev(priv->netdev);\n\t}\n\n}\n\nstatic struct usb_driver usb_8dev_driver = {\n\t.name =\t\t\"usb_8dev\",\n\t.probe =\tusb_8dev_probe,\n\t.disconnect =\tusb_8dev_disconnect,\n\t.id_table =\tusb_8dev_table,\n};\n\nmodule_usb_driver(usb_8dev_driver);\n\nMODULE_AUTHOR(\"Bernd Krumboeck <krumboeck@universalnet.at>\");\nMODULE_DESCRIPTION(\"CAN driver for 8 devices USB2CAN interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * CAN driver for \"8 devices\" USB2CAN converter\n *\n * Copyright (C) 2012 Bernd Krumboeck (krumboeck@universalnet.at)\n *\n * This driver is inspired by the 3.2.0 version of drivers/net/can/usb/ems_usb.c\n * and drivers/net/can/usb/esd_usb2.c\n *\n * Many thanks to Gerhard Bertelsmann (info@gerhard-bertelsmann.de)\n * for testing and fixing this driver. Also many thanks to \"8 devices\",\n * who were very cooperative and answered my questions.\n */\n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/led.h>\n\n/* driver constants */\n#define MAX_RX_URBS\t\t\t20\n#define MAX_TX_URBS\t\t\t20\n#define RX_BUFFER_SIZE\t\t\t64\n\n/* vendor and product id */\n#define USB_8DEV_VENDOR_ID\t\t0x0483\n#define USB_8DEV_PRODUCT_ID\t\t0x1234\n\n/* endpoints */\nenum usb_8dev_endpoint {\n\tUSB_8DEV_ENDP_DATA_RX = 1,\n\tUSB_8DEV_ENDP_DATA_TX,\n\tUSB_8DEV_ENDP_CMD_RX,\n\tUSB_8DEV_ENDP_CMD_TX\n};\n\n/* device CAN clock */\n#define USB_8DEV_ABP_CLOCK\t\t32000000\n\n/* setup flags */\n#define USB_8DEV_SILENT\t\t\t0x01\n#define USB_8DEV_LOOPBACK\t\t0x02\n#define USB_8DEV_DISABLE_AUTO_RESTRANS\t0x04\n#define USB_8DEV_STATUS_FRAME\t\t0x08\n\n/* commands */\nenum usb_8dev_cmd {\n\tUSB_8DEV_RESET = 1,\n\tUSB_8DEV_OPEN,\n\tUSB_8DEV_CLOSE,\n\tUSB_8DEV_SET_SPEED,\n\tUSB_8DEV_SET_MASK_FILTER,\n\tUSB_8DEV_GET_STATUS,\n\tUSB_8DEV_GET_STATISTICS,\n\tUSB_8DEV_GET_SERIAL,\n\tUSB_8DEV_GET_SOFTW_VER,\n\tUSB_8DEV_GET_HARDW_VER,\n\tUSB_8DEV_RESET_TIMESTAMP,\n\tUSB_8DEV_GET_SOFTW_HARDW_VER\n};\n\n/* command options */\n#define USB_8DEV_BAUD_MANUAL\t\t0x09\n#define USB_8DEV_CMD_START\t\t0x11\n#define USB_8DEV_CMD_END\t\t0x22\n\n#define USB_8DEV_CMD_SUCCESS\t\t0\n#define USB_8DEV_CMD_ERROR\t\t255\n\n#define USB_8DEV_CMD_TIMEOUT\t\t1000\n\n/* frames */\n#define USB_8DEV_DATA_START\t\t0x55\n#define USB_8DEV_DATA_END\t\t0xAA\n\n#define USB_8DEV_TYPE_CAN_FRAME\t\t0\n#define USB_8DEV_TYPE_ERROR_FRAME\t3\n\n#define USB_8DEV_EXTID\t\t\t0x01\n#define USB_8DEV_RTR\t\t\t0x02\n#define USB_8DEV_ERR_FLAG\t\t0x04\n\n/* status */\n#define USB_8DEV_STATUSMSG_OK\t\t0x00  /* Normal condition. */\n#define USB_8DEV_STATUSMSG_OVERRUN\t0x01  /* Overrun occurred when sending */\n#define USB_8DEV_STATUSMSG_BUSLIGHT\t0x02  /* Error counter has reached 96 */\n#define USB_8DEV_STATUSMSG_BUSHEAVY\t0x03  /* Error count. has reached 128 */\n#define USB_8DEV_STATUSMSG_BUSOFF\t0x04  /* Device is in BUSOFF */\n#define USB_8DEV_STATUSMSG_STUFF\t0x20  /* Stuff Error */\n#define USB_8DEV_STATUSMSG_FORM\t\t0x21  /* Form Error */\n#define USB_8DEV_STATUSMSG_ACK\t\t0x23  /* Ack Error */\n#define USB_8DEV_STATUSMSG_BIT0\t\t0x24  /* Bit1 Error */\n#define USB_8DEV_STATUSMSG_BIT1\t\t0x25  /* Bit0 Error */\n#define USB_8DEV_STATUSMSG_CRC\t\t0x27  /* CRC Error */\n\n#define USB_8DEV_RP_MASK\t\t0x7F  /* Mask for Receive Error Bit */\n\n\n/* table of devices that work with this driver */\nstatic const struct usb_device_id usb_8dev_table[] = {\n\t{ USB_DEVICE(USB_8DEV_VENDOR_ID, USB_8DEV_PRODUCT_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, usb_8dev_table);\n\nstruct usb_8dev_tx_urb_context {\n\tstruct usb_8dev_priv *priv;\n\n\tu32 echo_index;\n};\n\n/* Structure to hold all of our device specific stuff */\nstruct usb_8dev_priv {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\tatomic_t active_tx_urbs;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_8dev_tx_urb_context tx_contexts[MAX_TX_URBS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tstruct can_berr_counter bec;\n\n\tu8 *cmd_msg_buffer;\n\n\tstruct mutex usb_8dev_cmd_lock;\n\tvoid *rxbuf[MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MAX_RX_URBS];\n};\n\n/* tx frame */\nstruct __packed usb_8dev_tx_msg {\n\tu8 begin;\n\tu8 flags;\t/* RTR and EXT_ID flag */\n\t__be32 id;\t/* upper 3 bits not used */\n\tu8 dlc;\t\t/* data length code 0-8 bytes */\n\tu8 data[8];\t/* 64-bit data */\n\tu8 end;\n};\n\n/* rx frame */\nstruct __packed usb_8dev_rx_msg {\n\tu8 begin;\n\tu8 type;\t\t/* frame type */\n\tu8 flags;\t\t/* RTR and EXT_ID flag */\n\t__be32 id;\t\t/* upper 3 bits not used */\n\tu8 dlc;\t\t\t/* data length code 0-8 bytes */\n\tu8 data[8];\t\t/* 64-bit data */\n\t__be32 timestamp;\t/* 32-bit timestamp */\n\tu8 end;\n};\n\n/* command frame */\nstruct __packed usb_8dev_cmd_msg {\n\tu8 begin;\n\tu8 channel;\t/* unknown - always 0 */\n\tu8 command;\t/* command to execute */\n\tu8 opt1;\t/* optional parameter / return value */\n\tu8 opt2;\t/* optional parameter 2 */\n\tu8 data[10];\t/* optional parameter and data */\n\tu8 end;\n};\n\nstatic int usb_8dev_send_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size)\n{\n\tint actual_length;\n\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_TX),\n\t\t\t    msg, size, &actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\nstatic int usb_8dev_wait_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size,\n\t\t\t\tint *actual_length)\n{\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_RX),\n\t\t\t    msg, size, actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\n/* Send command to device and receive result.\n * Command was successful when opt1 = 0.\n */\nstatic int usb_8dev_send_cmd(struct usb_8dev_priv *priv,\n\t\t\t     struct usb_8dev_cmd_msg *out,\n\t\t\t     struct usb_8dev_cmd_msg *in)\n{\n\tint err;\n\tint num_bytes_read;\n\tstruct net_device *netdev;\n\n\tnetdev = priv->netdev;\n\n\tout->begin = USB_8DEV_CMD_START;\n\tout->end = USB_8DEV_CMD_END;\n\n\tmutex_lock(&priv->usb_8dev_cmd_lock);\n\n\tmemcpy(priv->cmd_msg_buffer, out,\n\t\tsizeof(struct usb_8dev_cmd_msg));\n\n\terr = usb_8dev_send_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg));\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"sending command message failed\\n\");\n\t\tgoto failed;\n\t}\n\n\terr = usb_8dev_wait_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t    &num_bytes_read);\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"no command message answer\\n\");\n\t\tgoto failed;\n\t}\n\n\tmemcpy(in, priv->cmd_msg_buffer, sizeof(struct usb_8dev_cmd_msg));\n\n\tif (in->begin != USB_8DEV_CMD_START || in->end != USB_8DEV_CMD_END ||\n\t\t\tnum_bytes_read != 16 || in->opt1 != 0)\n\t\terr = -EPROTO;\n\nfailed:\n\tmutex_unlock(&priv->usb_8dev_cmd_lock);\n\treturn err;\n}\n\n/* Send open command to device */\nstatic int usb_8dev_cmd_open(struct usb_8dev_priv *priv)\n{\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct usb_8dev_cmd_msg outmsg;\n\tstruct usb_8dev_cmd_msg inmsg;\n\tu32 ctrlmode = priv->can.ctrlmode;\n\tu32 flags = USB_8DEV_STATUS_FRAME;\n\t__be32 beflags;\n\t__be16 bebrp;\n\n\tmemset(&outmsg, 0, sizeof(outmsg));\n\toutmsg.command = USB_8DEV_OPEN;\n\toutmsg.opt1 = USB_8DEV_BAUD_MANUAL;\n\toutmsg.data[0] = bt->prop_seg + bt->phase_seg1;\n\toutmsg.data[1] = bt->phase_seg2;\n\toutmsg.data[2] = bt->sjw;\n\n\t/* BRP */\n\tbebrp = cpu_to_be16((u16)bt->brp);\n\tmemcpy(&outmsg.data[3], &bebrp, sizeof(bebrp));\n\n\t/* flags */\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tflags |= USB_8DEV_LOOPBACK;\n\tif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tflags |= USB_8DEV_SILENT;\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tflags |= USB_8DEV_DISABLE_AUTO_RESTRANS;\n\n\tbeflags = cpu_to_be32(flags);\n\tmemcpy(&outmsg.data[5], &beflags, sizeof(beflags));\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n/* Send close command to device */\nstatic int usb_8dev_cmd_close(struct usb_8dev_priv *priv)\n{\n\tstruct usb_8dev_cmd_msg inmsg;\n\tstruct usb_8dev_cmd_msg outmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_CLOSE,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n/* Get firmware and hardware version */\nstatic int usb_8dev_cmd_version(struct usb_8dev_priv *priv, u32 *res)\n{\n\tstruct usb_8dev_cmd_msg\tinmsg;\n\tstruct usb_8dev_cmd_msg\toutmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_GET_SOFTW_HARDW_VER,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\tint err = usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n\tif (err)\n\t\treturn err;\n\n\t*res = be32_to_cpup((__be32 *)inmsg.data);\n\n\treturn err;\n}\n\n/* Set network device mode\n *\n * Maybe we should leave this function empty, because the device\n * set mode variable with open command.\n */\nstatic int usb_8dev_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = usb_8dev_cmd_open(priv);\n\t\tif (err)\n\t\t\tnetdev_warn(netdev, \"couldn't start device\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n/* Read error/status frames */\nstatic void usb_8dev_rx_err_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t/* Error message:\n\t * byte 0: Status\n\t * byte 1: bit   7: Receive Passive\n\t * byte 1: bit 0-6: Receive Error Counter\n\t * byte 2: Transmit Error Counter\n\t * byte 3: Always 0 (maybe reserved for future use)\n\t */\n\n\tu8 state = msg->data[0];\n\tu8 rxerr = msg->data[1] & USB_8DEV_RP_MASK;\n\tu8 txerr = msg->data[2];\n\tint rx_errors = 0;\n\tint tx_errors = 0;\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tcf->data[2] = CAN_ERR_PROT_ACTIVE;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(priv->netdev);\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tbreak;\n\tdefault:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_ACK:\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_CRC:\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT0:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT1:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_FORM:\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_STUFF:\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tpriv->can.can_stats.error_warning++;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\tpriv->can.can_stats.error_passive++;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unknown status/error message (%d)\\n\", state);\n\t\tbreak;\n\t}\n\n\tif (tx_errors) {\n\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\tstats->tx_errors++;\n\t}\n\n\tif (rx_errors)\n\t\tstats->rx_errors++;\n\n\tcf->data[6] = txerr;\n\tcf->data[7] = rxerr;\n\n\tpriv->bec.txerr = txerr;\n\tpriv->bec.rxerr = rxerr;\n\n\tnetif_rx(skb);\n}\n\n/* Read data and status frames */\nstatic void usb_8dev_rx_can_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\tif (msg->type == USB_8DEV_TYPE_ERROR_FRAME &&\n\t\t   msg->flags == USB_8DEV_ERR_FLAG) {\n\t\tusb_8dev_rx_err_msg(priv, msg);\n\t} else if (msg->type == USB_8DEV_TYPE_CAN_FRAME) {\n\t\tskb = alloc_can_skb(priv->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = be32_to_cpu(msg->id);\n\t\tcan_frame_set_cc_len(cf, msg->dlc & 0xF, priv->can.ctrlmode);\n\n\t\tif (msg->flags & USB_8DEV_EXTID)\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\t\tif (msg->flags & USB_8DEV_RTR) {\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\t} else {\n\t\t\tmemcpy(cf->data, msg->data, cf->len);\n\t\t\tstats->rx_bytes += cf->len;\n\t\t}\n\t\tstats->rx_packets++;\n\n\t\tnetif_rx(skb);\n\n\t\tcan_led_event(priv->netdev, CAN_LED_EVENT_RX);\n\t} else {\n\t\tnetdev_warn(priv->netdev, \"frame type %d unknown\",\n\t\t\t msg->type);\n\t}\n\n}\n\n/* Callback for reading data from device\n *\n * Check urb status, call read function and resubmit urb read operation.\n */\nstatic void usb_8dev_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct usb_8dev_rx_msg *msg;\n\n\t\tif (pos + sizeof(struct usb_8dev_rx_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct usb_8dev_rx_msg *)(urb->transfer_buffer + pos);\n\t\tusb_8dev_rx_can_msg(priv, msg);\n\n\t\tpos += sizeof(struct usb_8dev_rx_msg);\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_RX),\n\t\t\t  urb->transfer_buffer, RX_BUFFER_SIZE,\n\t\t\t  usb_8dev_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev,\n\t\t\t\"failed resubmitting read bulk urb: %d\\n\", retval);\n}\n\n/* Callback handler for write operations\n *\n * Free allocated buffers, check transmit status and\n * calculate statistic.\n */\nstatic void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\tcan_led_event(netdev, CAN_LED_EVENT_TX);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}\n\n/* Send data to device */\nstatic netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&priv->active_tx_urbs);\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\t\tstats->tx_dropped++;\n\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int usb_8dev_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\n/* Start USB device */\nstatic int usb_8dev_start(struct usb_8dev_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tfor (i = 0; i < MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev,\n\t\t\t\t\t\t  USB_8DEV_ENDP_DATA_RX),\n\t\t\t\t  buf, RX_BUFFER_SIZE,\n\t\t\t\t  usb_8dev_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\terr = usb_8dev_cmd_open(priv);\n\tif (err)\n\t\tgoto failed;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nfailed:\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\treturn err;\n}\n\n/* Open USB device */\nstatic int usb_8dev_open(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\tcan_led_event(netdev, CAN_LED_EVENT_OPEN);\n\n\t/* finally start device */\n\terr = usb_8dev_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\",\n\t\t\t err);\n\n\t\tclose_candev(netdev);\n\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void unlink_all_urbs(struct usb_8dev_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n}\n\n/* Close USB device */\nstatic int usb_8dev_close(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\t/* Send CLOSE command to CAN controller */\n\terr = usb_8dev_cmd_close(priv);\n\tif (err)\n\t\tnetdev_warn(netdev, \"couldn't stop device\");\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tunlink_all_urbs(priv);\n\n\tclose_candev(netdev);\n\n\tcan_led_event(netdev, CAN_LED_EVENT_STOP);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops usb_8dev_netdev_ops = {\n\t.ndo_open = usb_8dev_open,\n\t.ndo_stop = usb_8dev_close,\n\t.ndo_start_xmit = usb_8dev_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct can_bittiming_const usb_8dev_bittiming_const = {\n\t.name = \"usb_8dev\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n/* Probe USB device\n *\n * Check device and firmware.\n * Set supported modes and bittiming constants.\n * Allocate some memory.\n */\nstatic int usb_8dev_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct usb_8dev_priv *priv;\n\tint i, err = -ENOMEM;\n\tu32 version;\n\tchar buf[18];\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\t/* product id looks strange, better we also check iProduct string */\n\tif (usb_string(usbdev, usbdev->descriptor.iProduct, buf,\n\t\t       sizeof(buf)) > 0 && strcmp(buf, \"USB2CAN converter\")) {\n\t\tdev_info(&usbdev->dev, \"ignoring: not an USB2CAN converter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev = alloc_candev(sizeof(struct usb_8dev_priv), MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.clock.freq = USB_8DEV_ABP_CLOCK;\n\tpriv->can.bittiming_const = &usb_8dev_bittiming_const;\n\tpriv->can.do_set_mode = usb_8dev_set_mode;\n\tpriv->can.do_get_berr_counter = usb_8dev_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t      CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t      CAN_CTRLMODE_ONE_SHOT |\n\t\t\t\t      CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tnetdev->netdev_ops = &usb_8dev_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n\n\tpriv->cmd_msg_buffer = devm_kzalloc(&intf->dev, sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!priv->cmd_msg_buffer)\n\t\tgoto cleanup_candev;\n\n\tusb_set_intfdata(intf, priv);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tmutex_init(&priv->usb_8dev_cmd_lock);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t\"couldn't register CAN device: %d\\n\", err);\n\t\tgoto cleanup_candev;\n\t}\n\n\terr = usb_8dev_cmd_version(priv, &version);\n\tif (err) {\n\t\tnetdev_err(netdev, \"can't get firmware version\\n\");\n\t\tgoto cleanup_unregister_candev;\n\t} else {\n\t\tnetdev_info(netdev,\n\t\t\t \"firmware: %d.%d, hardware: %d.%d\\n\",\n\t\t\t (version>>24) & 0xff, (version>>16) & 0xff,\n\t\t\t (version>>8) & 0xff, version & 0xff);\n\t}\n\n\tdevm_can_led_init(netdev);\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_netdev(priv->netdev);\n\ncleanup_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n\n}\n\n/* Called by the usb core when driver is unloaded or device is removed */\nstatic void usb_8dev_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_8dev_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (priv) {\n\t\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\t\tunregister_netdev(priv->netdev);\n\t\tunlink_all_urbs(priv);\n\t\tfree_candev(priv->netdev);\n\t}\n\n}\n\nstatic struct usb_driver usb_8dev_driver = {\n\t.name =\t\t\"usb_8dev\",\n\t.probe =\tusb_8dev_probe,\n\t.disconnect =\tusb_8dev_disconnect,\n\t.id_table =\tusb_8dev_table,\n};\n\nmodule_usb_driver(usb_8dev_driver);\n\nMODULE_AUTHOR(\"Bernd Krumboeck <krumboeck@universalnet.at>\");\nMODULE_DESCRIPTION(\"CAN driver for 8 devices USB2CAN interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/net/can/usb/usb_8dev.c"], "buggy_code_start_loc": [666], "buggy_code_end_loc": [699], "fixing_code_start_loc": [666], "fixing_code_end_loc": [696], "type": "CWE-415", "message": "usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.", "other": {"cve": {"id": "CVE-2022-28388", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-03T21:15:08.070", "lastModified": "2023-01-03T15:11:22.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free."}, {"lang": "es", "value": "La funci\u00f3n usb_8dev_start_xmit en el archivo drivers/net/can/usb/usb_8dev.c en el kernel de Linux versiones hasta 5.17.1, presenta una doble liberaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.17.1", "matchCriteriaId": "63CEA1F5-F935-4664-88B3-3433F56FFB8B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/3d3925ff6433f98992685a9679613a2cc97f3ce2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220513-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3d3925ff6433f98992685a9679613a2cc97f3ce2"}}