{"buggy_code": ["'use strict'\n// external modules\nconst Sequelize = require('sequelize')\nconst scrypt = require('scrypt-kdf')\n\n// core\nconst logger = require('../logger')\nconst { generateAvatarURL } = require('../letter-avatars')\n\nmodule.exports = function (sequelize, DataTypes) {\n  const User = sequelize.define('User', {\n    id: {\n      type: DataTypes.UUID,\n      primaryKey: true,\n      defaultValue: Sequelize.UUIDV4\n    },\n    profileid: {\n      type: DataTypes.STRING,\n      unique: true\n    },\n    profile: {\n      type: DataTypes.TEXT\n    },\n    history: {\n      type: DataTypes.TEXT\n    },\n    accessToken: {\n      type: DataTypes.TEXT\n    },\n    refreshToken: {\n      type: DataTypes.TEXT\n    },\n    deleteToken: {\n      type: DataTypes.UUID,\n      defaultValue: Sequelize.UUIDV4\n    },\n    email: {\n      type: Sequelize.TEXT,\n      validate: {\n        isEmail: true\n      }\n    },\n    password: {\n      type: Sequelize.TEXT\n    }\n  })\n\n  User.prototype.verifyPassword = function (attempt) {\n    return scrypt.verify(Buffer.from(this.password, 'hex'), attempt)\n  }\n\n  User.associate = function (models) {\n    User.hasMany(models.Note, {\n      foreignKey: 'ownerId',\n      constraints: false\n    })\n    User.hasMany(models.Note, {\n      foreignKey: 'lastchangeuserId',\n      constraints: false\n    })\n  }\n  User.getProfile = function (user) {\n    if (!user) {\n      return null\n    }\n    return user.profile ? User.parseProfile(user.profile) : (user.email ? User.parseProfileByEmail(user.email) : null)\n  }\n  User.parseProfile = function (profile) {\n    try {\n      profile = JSON.parse(profile)\n    } catch (err) {\n      logger.error(err)\n      profile = null\n    }\n    if (profile) {\n      profile = {\n        name: profile.displayName || profile.username,\n        photo: User.parsePhotoByProfile(profile),\n        biggerphoto: User.parsePhotoByProfile(profile, true)\n      }\n    }\n    return profile\n  }\n  User.parsePhotoByProfile = function (profile, bigger) {\n    let photo = null\n    switch (profile.provider) {\n      case 'facebook':\n        photo = 'https://graph.facebook.com/' + profile.id + '/picture'\n        if (bigger) photo += '?width=400'\n        else photo += '?width=96'\n        break\n      case 'twitter':\n        photo = 'https://twitter.com/' + profile.username + '/profile_image'\n        if (bigger) photo += '?size=original'\n        else photo += '?size=bigger'\n        break\n      case 'github':\n        photo = 'https://avatars.githubusercontent.com/u/' + profile.id\n        if (bigger) photo += '?s=400'\n        else photo += '?s=96'\n        break\n      case 'gitlab':\n        photo = profile.avatarUrl\n        if (photo) {\n          if (bigger) photo = photo.replace(/(\\?s=)\\d*$/i, '$1400')\n          else photo = photo.replace(/(\\?s=)\\d*$/i, '$196')\n        } else {\n          photo = generateAvatarURL(profile.username)\n        }\n        break\n      case 'mattermost':\n        photo = profile.avatarUrl\n        if (photo) {\n          if (bigger) photo = photo.replace(/(\\?s=)\\d*$/i, '$1400')\n          else photo = photo.replace(/(\\?s=)\\d*$/i, '$196')\n        } else {\n          photo = generateAvatarURL(profile.username)\n        }\n        break\n      case 'dropbox':\n        photo = generateAvatarURL('', profile.emails[0].value, bigger)\n        break\n      case 'google':\n        photo = profile.photos[0].value\n        if (bigger) photo = photo.replace(/(\\?sz=)\\d*$/i, '$1400')\n        else photo = photo.replace(/(\\?sz=)\\d*$/i, '$196')\n        break\n      case 'ldap':\n        photo = generateAvatarURL(profile.username, profile.emails[0], bigger)\n        break\n      case 'saml':\n        photo = generateAvatarURL(profile.username, profile.emails[0], bigger)\n        break\n      default:\n        photo = generateAvatarURL(profile.username)\n        break\n    }\n    return photo\n  }\n  User.parseProfileByEmail = function (email) {\n    return {\n      name: email.substring(0, email.lastIndexOf('@')),\n      photo: generateAvatarURL('', email, false),\n      biggerphoto: generateAvatarURL('', email, true)\n    }\n  }\n\n  function updatePasswordHashHook (user, options) {\n    // suggested way to hash passwords to be able to do this asynchronously:\n    // @see https://github.com/sequelize/sequelize/issues/1821#issuecomment-44265819\n\n    if (!user.changed('password')) {\n      return Promise.resolve()\n    }\n\n    return scrypt.kdf(user.getDataValue('password'), { logN: 15 }).then(keyBuf => {\n      user.setDataValue('password', keyBuf.toString('hex'))\n    })\n  }\n\n  User.beforeCreate(updatePasswordHashHook)\n  User.beforeUpdate(updatePasswordHashHook)\n\n  return User\n}\n", "<meta charset=\"utf-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n<meta name=\"mobile-web-app-capable\" content=\"yes\">\n<%- include('../includes/favicon') %>\n<% for (var og in opengraph) { %>\n<% if (opengraph.hasOwnProperty(og) && opengraph[og].trim() !== '') { %>\n<meta property=\"og:<%- og %>\" content=\"<%- opengraph[og] %>\">\n<% }} if (!opengraph.hasOwnProperty('image')) { %>\n<meta property=\"og:image\" content=\"<%- serverURL %>/icons/android-chrome-512x512.png\">\n<meta property=\"og:image:alt\" content=\"HedgeDoc logo\">\n<meta property=\"og:image:type\" content=\"image/png\">\n<% } %>\n<base href=\"<%- serverURL %>/\">\n<title><%= title %></title>\n<% if(useCDN) { %>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.0/css/bootstrap.min.css\" integrity=\"sha256-H0KfTigpUV+0/5tn2HXC0CPwhhDhWgSawJdnFd0CGCo=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/fork-awesome/1.1.3/css/fork-awesome.min.css\" integrity=\"sha256-ZhApazu+kejqTYhMF+1DzNKjIzP7KXu6AzyXcC1gMus=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bootstrap-social/4.9.0/bootstrap-social.min.css\" integrity=\"sha256-02JtFTurpwBjQJ6q13iJe82/NF0RbZlJroDegK5g87Y=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css\" integrity=\"sha256-3iu9jgsy9TpTwXKb7bNQzqWekRX7pPK+2OLj3R922fo=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/emojify.js/1.1.0/css/basic/emojify.min.css\" integrity=\"sha256-UOrvMOsSDSrW6szVLe8ZDZezBxh5IoIfgTwdNDgTjiU=\" crossorigin=\"anonymous\" />\n<%- include('../build/index-header') %>\n<%- include('../shared/polyfill') %>\n<% } else { %>\n<link rel=\"stylesheet\" href='<%- serverURL %>/build/emojify.js/dist/css/basic/emojify.min.css'>\n<%- include('../build/index-pack-header') %>\n<% } %>\n"], "fixing_code": ["'use strict'\n// external modules\nconst Sequelize = require('sequelize')\nconst scrypt = require('scrypt-kdf')\nconst filterXSS = require('xss')\n\n// core\nconst logger = require('../logger')\nconst { generateAvatarURL } = require('../letter-avatars')\n\nmodule.exports = function (sequelize, DataTypes) {\n  const User = sequelize.define('User', {\n    id: {\n      type: DataTypes.UUID,\n      primaryKey: true,\n      defaultValue: Sequelize.UUIDV4\n    },\n    profileid: {\n      type: DataTypes.STRING,\n      unique: true\n    },\n    profile: {\n      type: DataTypes.TEXT\n    },\n    history: {\n      type: DataTypes.TEXT\n    },\n    accessToken: {\n      type: DataTypes.TEXT\n    },\n    refreshToken: {\n      type: DataTypes.TEXT\n    },\n    deleteToken: {\n      type: DataTypes.UUID,\n      defaultValue: Sequelize.UUIDV4\n    },\n    email: {\n      type: Sequelize.TEXT,\n      validate: {\n        isEmail: true\n      }\n    },\n    password: {\n      type: Sequelize.TEXT\n    }\n  })\n\n  User.prototype.verifyPassword = function (attempt) {\n    return scrypt.verify(Buffer.from(this.password, 'hex'), attempt)\n  }\n\n  User.associate = function (models) {\n    User.hasMany(models.Note, {\n      foreignKey: 'ownerId',\n      constraints: false\n    })\n    User.hasMany(models.Note, {\n      foreignKey: 'lastchangeuserId',\n      constraints: false\n    })\n  }\n  User.getProfile = function (user) {\n    if (!user) {\n      return null\n    }\n    return user.profile ? User.parseProfile(user.profile) : (user.email ? User.parseProfileByEmail(user.email) : null)\n  }\n  User.parseProfile = function (profile) {\n    try {\n      profile = JSON.parse(profile)\n    } catch (err) {\n      logger.error(err)\n      profile = null\n    }\n    if (profile) {\n      profile = {\n        name: filterXSS(profile.displayName || profile.username),\n        photo: User.parsePhotoByProfile(profile),\n        biggerphoto: User.parsePhotoByProfile(profile, true)\n      }\n    }\n    return profile\n  }\n  User.parsePhotoByProfile = function (profile, bigger) {\n    let photo = null\n    switch (profile.provider) {\n      case 'facebook':\n        photo = 'https://graph.facebook.com/' + profile.id + '/picture'\n        if (bigger) photo += '?width=400'\n        else photo += '?width=96'\n        break\n      case 'twitter':\n        photo = 'https://twitter.com/' + profile.username + '/profile_image'\n        if (bigger) photo += '?size=original'\n        else photo += '?size=bigger'\n        break\n      case 'github':\n        photo = 'https://avatars.githubusercontent.com/u/' + profile.id\n        if (bigger) photo += '?s=400'\n        else photo += '?s=96'\n        break\n      case 'gitlab':\n        photo = profile.avatarUrl\n        if (photo) {\n          if (bigger) photo = photo.replace(/(\\?s=)\\d*$/i, '$1400')\n          else photo = photo.replace(/(\\?s=)\\d*$/i, '$196')\n        } else {\n          photo = generateAvatarURL(profile.username)\n        }\n        break\n      case 'mattermost':\n        photo = profile.avatarUrl\n        if (photo) {\n          if (bigger) photo = photo.replace(/(\\?s=)\\d*$/i, '$1400')\n          else photo = photo.replace(/(\\?s=)\\d*$/i, '$196')\n        } else {\n          photo = generateAvatarURL(profile.username)\n        }\n        break\n      case 'dropbox':\n        photo = generateAvatarURL('', profile.emails[0].value, bigger)\n        break\n      case 'google':\n        photo = profile.photos[0].value\n        if (bigger) photo = photo.replace(/(\\?sz=)\\d*$/i, '$1400')\n        else photo = photo.replace(/(\\?sz=)\\d*$/i, '$196')\n        break\n      case 'ldap':\n        photo = generateAvatarURL(profile.username, profile.emails[0], bigger)\n        break\n      case 'saml':\n        photo = generateAvatarURL(profile.username, profile.emails[0], bigger)\n        break\n      default:\n        photo = generateAvatarURL(profile.username)\n        break\n    }\n    return filterXSS(photo)\n  }\n  User.parseProfileByEmail = function (email) {\n    return {\n      name: email.substring(0, email.lastIndexOf('@')),\n      photo: generateAvatarURL('', email, false),\n      biggerphoto: generateAvatarURL('', email, true)\n    }\n  }\n\n  function updatePasswordHashHook (user, options) {\n    // suggested way to hash passwords to be able to do this asynchronously:\n    // @see https://github.com/sequelize/sequelize/issues/1821#issuecomment-44265819\n\n    if (!user.changed('password')) {\n      return Promise.resolve()\n    }\n\n    return scrypt.kdf(user.getDataValue('password'), { logN: 15 }).then(keyBuf => {\n      user.setDataValue('password', keyBuf.toString('hex'))\n    })\n  }\n\n  User.beforeCreate(updatePasswordHashHook)\n  User.beforeUpdate(updatePasswordHashHook)\n\n  return User\n}\n", "<meta charset=\"utf-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n<meta name=\"mobile-web-app-capable\" content=\"yes\">\n<%- include('../includes/favicon') %>\n<% for (var og in opengraph) { %>\n<% if (opengraph.hasOwnProperty(og) && opengraph[og].trim() !== '') { %>\n<meta property=\"og:<%= og %>\" content=\"<%= opengraph[og] %>\">\n<% }} if (!opengraph.hasOwnProperty('image')) { %>\n<meta property=\"og:image\" content=\"<%- serverURL %>/icons/android-chrome-512x512.png\">\n<meta property=\"og:image:alt\" content=\"HedgeDoc logo\">\n<meta property=\"og:image:type\" content=\"image/png\">\n<% } %>\n<base href=\"<%- serverURL %>/\">\n<title><%= title %></title>\n<% if(useCDN) { %>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.0/css/bootstrap.min.css\" integrity=\"sha256-H0KfTigpUV+0/5tn2HXC0CPwhhDhWgSawJdnFd0CGCo=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/fork-awesome/1.1.3/css/fork-awesome.min.css\" integrity=\"sha256-ZhApazu+kejqTYhMF+1DzNKjIzP7KXu6AzyXcC1gMus=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bootstrap-social/4.9.0/bootstrap-social.min.css\" integrity=\"sha256-02JtFTurpwBjQJ6q13iJe82/NF0RbZlJroDegK5g87Y=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css\" integrity=\"sha256-3iu9jgsy9TpTwXKb7bNQzqWekRX7pPK+2OLj3R922fo=\" crossorigin=\"anonymous\" />\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/emojify.js/1.1.0/css/basic/emojify.min.css\" integrity=\"sha256-UOrvMOsSDSrW6szVLe8ZDZezBxh5IoIfgTwdNDgTjiU=\" crossorigin=\"anonymous\" />\n<%- include('../build/index-header') %>\n<%- include('../shared/polyfill') %>\n<% } else { %>\n<link rel=\"stylesheet\" href='<%- serverURL %>/build/emojify.js/dist/css/basic/emojify.min.css'>\n<%- include('../build/index-pack-header') %>\n<% } %>\n"], "filenames": ["lib/models/user.js", "public/views/hedgedoc/head.ejs"], "buggy_code_start_loc": [4, 10], "buggy_code_end_loc": [139, 11], "fixing_code_start_loc": [5, 10], "fixing_code_end_loc": [140, 11], "type": "CWE-79", "message": "HedgeDoc is a platform to write and share markdown. HedgeDoc before version 1.8.2 is vulnerable to a cross-site scripting attack using the YAML-metadata of a note. An attacker with write access to a note can embed HTML tags in the Open Graph metadata section of the note, resulting in the frontend rendering the script tag as part of the `<head>` section. Unless your instance prevents guests from editing notes, this vulnerability allows unauthenticated attackers to inject JavaScript into notes that allow guest edits. If your instance prevents guests from editing notes, this vulnerability allows authenticated attackers to inject JavaScript into any note pages they have write-access to. This vulnerability is patched in version 1.8.2. As a workaround, one can disable guest edits until the next update.", "other": {"cve": {"id": "CVE-2021-29503", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-19T20:15:07.440", "lastModified": "2022-04-25T20:09:54.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HedgeDoc is a platform to write and share markdown. HedgeDoc before version 1.8.2 is vulnerable to a cross-site scripting attack using the YAML-metadata of a note. An attacker with write access to a note can embed HTML tags in the Open Graph metadata section of the note, resulting in the frontend rendering the script tag as part of the `<head>` section. Unless your instance prevents guests from editing notes, this vulnerability allows unauthenticated attackers to inject JavaScript into notes that allow guest edits. If your instance prevents guests from editing notes, this vulnerability allows authenticated attackers to inject JavaScript into any note pages they have write-access to. This vulnerability is patched in version 1.8.2. As a workaround, one can disable guest edits until the next update."}, {"lang": "es", "value": "HedgeDoc es una plataforma para escribir y compartir markdown.&#xa0;HedgeDoc versiones anteriores a 1.8.2, es vulnerable a un ataque de tipo cross-site scripting usando los metadatos YAML de una nota.&#xa0;Un atacante con acceso de escritura a una nota puede insertar etiquetas HTML en la secci\u00f3n de metadatos de Open Graph de la nota, resultando en que el frontend renderiza la etiqueta script como parte de la secci\u00f3n \"(head)\". A menos que su instancia impida a unos invitados editar unas notas, esta vulnerabilidad permite que atacantes no autentificados inyectan JavaScript en unas notas que permiten la edici\u00f3n de los invitados. Si su instancia impide a unos invitados editar unas notas, esta vulnerabilidad permite a atacantes autentificados inyectar JavaScript en cualquier p\u00e1gina de notas a la que tengan acceso de escritura. Esta vulnerabilidad est\u00e1 parcheada en versi\u00f3n 1.8.2. Como soluci\u00f3n, uno puede deshabilitar una edici\u00f3n de invitados hasta la pr\u00f3xima actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-80"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hedgedoc:hedgedoc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "A017245C-AAAB-4762-B7B3-A70FCB3A1C7A"}]}]}], "references": [{"url": "https://github.com/hedgedoc/hedgedoc/commit/01dad5821ee28377ebe640c6c72c3e0bb0d51ea7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hedgedoc/hedgedoc/releases/tag/1.8.2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/hedgedoc/hedgedoc/security/advisories/GHSA-gjg7-4j2h-94fq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hedgedoc/hedgedoc/commit/01dad5821ee28377ebe640c6c72c3e0bb0d51ea7"}}