{"buggy_code": ["/*\n * Copyright (c) 2009-2020, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2020, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"util.h\"\n#include \"sha1.h\"   /* SHA1 is used for DEBUG DIGEST */\n#include \"crc64.h\"\n#include \"bio.h\"\n#include \"quicklist.h\"\n\n#include <arpa/inet.h>\n#include <signal.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#ifdef HAVE_BACKTRACE\n#include <execinfo.h>\n#ifndef __OpenBSD__\n#include <ucontext.h>\n#else\ntypedef ucontext_t sigcontext_t;\n#endif\n#endif /* HAVE_BACKTRACE */\n\n#ifdef __CYGWIN__\n#ifndef SA_ONSTACK\n#define SA_ONSTACK 0x08000000\n#endif\n#endif\n\n#if defined(__APPLE__) && defined(__arm64__)\n#include <mach/mach.h>\n#endif\n\n/* Globals */\nstatic int bug_report_start = 0; /* True if bug report header was already logged. */\nstatic pthread_mutex_t bug_report_start_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n/* Forward declarations */\nvoid bugReportStart(void);\nvoid printCrashReport(void);\nvoid bugReportEnd(int killViaSignal, int sig);\nvoid logStackTrace(void *eip, int uplevel);\n\n/* ================================= Debugging ============================== */\n\n/* Compute the sha1 of string at 's' with 'len' bytes long.\n * The SHA1 is then xored against the string pointed by digest.\n * Since xor is commutative, this operation is used in order to\n * \"add\" digests relative to unordered elements.\n *\n * So digest(a,b,c,d) will be the same of digest(b,a,c,d) */\nvoid xorDigest(unsigned char *digest, const void *ptr, size_t len) {\n    SHA1_CTX ctx;\n    unsigned char hash[20];\n    int j;\n\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,ptr,len);\n    SHA1Final(hash,&ctx);\n\n    for (j = 0; j < 20; j++)\n        digest[j] ^= hash[j];\n}\n\nvoid xorStringObjectDigest(unsigned char *digest, robj *o) {\n    o = getDecodedObject(o);\n    xorDigest(digest,o->ptr,sdslen(o->ptr));\n    decrRefCount(o);\n}\n\n/* This function instead of just computing the SHA1 and xoring it\n * against digest, also perform the digest of \"digest\" itself and\n * replace the old value with the new one.\n *\n * So the final digest will be:\n *\n * digest = SHA1(digest xor SHA1(data))\n *\n * This function is used every time we want to preserve the order so\n * that digest(a,b,c,d) will be different than digest(b,c,d,a)\n *\n * Also note that mixdigest(\"foo\") followed by mixdigest(\"bar\")\n * will lead to a different digest compared to \"fo\", \"obar\".\n */\nvoid mixDigest(unsigned char *digest, const void *ptr, size_t len) {\n    SHA1_CTX ctx;\n\n    xorDigest(digest,ptr,len);\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,digest,20);\n    SHA1Final(digest,&ctx);\n}\n\nvoid mixStringObjectDigest(unsigned char *digest, robj *o) {\n    o = getDecodedObject(o);\n    mixDigest(digest,o->ptr,sdslen(o->ptr));\n    decrRefCount(o);\n}\n\n/* This function computes the digest of a data structure stored in the\n * object 'o'. It is the core of the DEBUG DIGEST command: when taking the\n * digest of a whole dataset, we take the digest of the key and the value\n * pair, and xor all those together.\n *\n * Note that this function does not reset the initial 'digest' passed, it\n * will continue mixing this object digest to anything that was already\n * present. */\nvoid xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {\n    uint32_t aux = htonl(o->type);\n    mixDigest(digest,&aux,sizeof(aux));\n    long long expiretime = getExpire(db,keyobj);\n    char buf[128];\n\n    /* Save the key and associated value */\n    if (o->type == OBJ_STRING) {\n        mixStringObjectDigest(digest,o);\n    } else if (o->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            robj *eleobj = listTypeGet(&entry);\n            mixStringObjectDigest(digest,eleobj);\n            decrRefCount(eleobj);\n        }\n        listTypeReleaseIterator(li);\n    } else if (o->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(o);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            xorDigest(digest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (o->type == OBJ_ZSET) {\n        unsigned char eledigest[20];\n\n        if (o->encoding == OBJ_ENCODING_LISTPACK) {\n            unsigned char *zl = o->ptr;\n            unsigned char *eptr, *sptr;\n            unsigned char *vstr;\n            unsigned int vlen;\n            long long vll;\n            double score;\n\n            eptr = lpSeek(zl,0);\n            serverAssert(eptr != NULL);\n            sptr = lpNext(zl,eptr);\n            serverAssert(sptr != NULL);\n\n            while (eptr != NULL) {\n                vstr = lpGetValue(eptr,&vlen,&vll);\n                score = zzlGetScore(sptr);\n\n                memset(eledigest,0,20);\n                if (vstr != NULL) {\n                    mixDigest(eledigest,vstr,vlen);\n                } else {\n                    ll2string(buf,sizeof(buf),vll);\n                    mixDigest(eledigest,buf,strlen(buf));\n                }\n\n                snprintf(buf,sizeof(buf),\"%.17g\",score);\n                mixDigest(eledigest,buf,strlen(buf));\n                xorDigest(digest,eledigest,20);\n                zzlNext(zl,&eptr,&sptr);\n            }\n        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = o->ptr;\n            dictIterator *di = dictGetIterator(zs->dict);\n            dictEntry *de;\n\n            while((de = dictNext(di)) != NULL) {\n                sds sdsele = dictGetKey(de);\n                double *score = dictGetVal(de);\n\n                snprintf(buf,sizeof(buf),\"%.17g\",*score);\n                memset(eledigest,0,20);\n                mixDigest(eledigest,sdsele,sdslen(sdsele));\n                mixDigest(eledigest,buf,strlen(buf));\n                xorDigest(digest,eledigest,20);\n            }\n            dictReleaseIterator(di);\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else if (o->type == OBJ_HASH) {\n        hashTypeIterator *hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            unsigned char eledigest[20];\n            sds sdsele;\n\n            memset(eledigest,0,20);\n            sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            mixDigest(eledigest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n            sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            mixDigest(eledigest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n            xorDigest(digest,eledigest,20);\n        }\n        hashTypeReleaseIterator(hi);\n    } else if (o->type == OBJ_STREAM) {\n        streamIterator si;\n        streamIteratorStart(&si,o->ptr,NULL,NULL,0);\n        streamID id;\n        int64_t numfields;\n\n        while(streamIteratorGetID(&si,&id,&numfields)) {\n            sds itemid = sdscatfmt(sdsempty(),\"%U.%U\",id.ms,id.seq);\n            mixDigest(digest,itemid,sdslen(itemid));\n            sdsfree(itemid);\n\n            while(numfields--) {\n                unsigned char *field, *value;\n                int64_t field_len, value_len;\n                streamIteratorGetField(&si,&field,&value,\n                                           &field_len,&value_len);\n                mixDigest(digest,field,field_len);\n                mixDigest(digest,value,value_len);\n            }\n        }\n        streamIteratorStop(&si);\n    } else if (o->type == OBJ_MODULE) {\n        RedisModuleDigest md = {{0},{0},keyobj,db->id};\n        moduleValue *mv = o->ptr;\n        moduleType *mt = mv->type;\n        moduleInitDigestContext(md);\n        if (mt->digest) {\n            mt->digest(&md,mv->value);\n            xorDigest(digest,md.x,sizeof(md.x));\n        }\n    } else {\n        serverPanic(\"Unknown object type\");\n    }\n    /* If the key has an expire, add it to the mix */\n    if (expiretime != -1) xorDigest(digest,\"!!expire!!\",10);\n}\n\n/* Compute the dataset digest. Since keys, sets elements, hashes elements\n * are not ordered, we use a trick: every aggregate digest is the xor\n * of the digests of their elements. This way the order will not change\n * the result. For list instead we use a feedback entering the output digest\n * as input in order to ensure that a different ordered list will result in\n * a different digest. */\nvoid computeDatasetDigest(unsigned char *final) {\n    unsigned char digest[20];\n    dictIterator *di = NULL;\n    dictEntry *de;\n    int j;\n    uint32_t aux;\n\n    memset(final,0,20); /* Start with a clean result */\n\n    for (j = 0; j < server.dbnum; j++) {\n        redisDb *db = server.db+j;\n\n        if (dictSize(db->dict) == 0) continue;\n        di = dictGetSafeIterator(db->dict);\n\n        /* hash the DB id, so the same dataset moved in a different\n         * DB will lead to a different digest */\n        aux = htonl(j);\n        mixDigest(final,&aux,sizeof(aux));\n\n        /* Iterate this DB writing every entry */\n        while((de = dictNext(di)) != NULL) {\n            sds key;\n            robj *keyobj, *o;\n\n            memset(digest,0,20); /* This key-val digest */\n            key = dictGetKey(de);\n            keyobj = createStringObject(key,sdslen(key));\n\n            mixDigest(digest,key,sdslen(key));\n\n            o = dictGetVal(de);\n            xorObjectDigest(db,keyobj,digest,o);\n\n            /* We can finally xor the key-val digest to the final digest */\n            xorDigest(final,digest,20);\n            decrRefCount(keyobj);\n        }\n        dictReleaseIterator(di);\n    }\n}\n\n#ifdef USE_JEMALLOC\nvoid mallctl_int(client *c, robj **argv, int argc) {\n    int ret;\n    /* start with the biggest size (int64), and if that fails, try smaller sizes (int32, bool) */\n    int64_t old = 0, val;\n    if (argc > 1) {\n        long long ll;\n        if (getLongLongFromObjectOrReply(c, argv[1], &ll, NULL) != C_OK)\n            return;\n        val = ll;\n    }\n    size_t sz = sizeof(old);\n    while (sz > 0) {\n        if ((ret=je_mallctl(argv[0]->ptr, &old, &sz, argc > 1? &val: NULL, argc > 1?sz: 0))) {\n            if (ret == EPERM && argc > 1) {\n                /* if this option is write only, try just writing to it. */\n                if (!(ret=je_mallctl(argv[0]->ptr, NULL, 0, &val, sz))) {\n                    addReply(c, shared.ok);\n                    return;\n                }\n            }\n            if (ret==EINVAL) {\n                /* size might be wrong, try a smaller one */\n                sz /= 2;\n#if BYTE_ORDER == BIG_ENDIAN\n                val <<= 8*sz;\n#endif\n                continue;\n            }\n            addReplyErrorFormat(c,\"%s\", strerror(ret));\n            return;\n        } else {\n#if BYTE_ORDER == BIG_ENDIAN\n            old >>= 64 - 8*sz;\n#endif\n            addReplyLongLong(c, old);\n            return;\n        }\n    }\n    addReplyErrorFormat(c,\"%s\", strerror(EINVAL));\n}\n\nvoid mallctl_string(client *c, robj **argv, int argc) {\n    int rret, wret;\n    char *old;\n    size_t sz = sizeof(old);\n    /* for strings, it seems we need to first get the old value, before overriding it. */\n    if ((rret=je_mallctl(argv[0]->ptr, &old, &sz, NULL, 0))) {\n        /* return error unless this option is write only. */\n        if (!(rret == EPERM && argc > 1)) {\n            addReplyErrorFormat(c,\"%s\", strerror(rret));\n            return;\n        }\n    }\n    if(argc > 1) {\n        char *val = argv[1]->ptr;\n        char **valref = &val;\n        if ((!strcmp(val,\"VOID\")))\n            valref = NULL, sz = 0;\n        wret = je_mallctl(argv[0]->ptr, NULL, 0, valref, sz);\n    }\n    if (!rret)\n        addReplyBulkCString(c, old);\n    else if (wret)\n        addReplyErrorFormat(c,\"%s\", strerror(wret));\n    else\n        addReply(c, shared.ok);\n}\n#endif\n\nvoid debugCommand(client *c) {\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"AOF-FLUSH-SLEEP <microsec>\",\n\"    Server will sleep before flushing the AOF, this is used for testing.\",\n\"ASSERT\",\n\"    Crash by assertion failed.\",\n\"CHANGE-REPL-ID\",\n\"    Change the replication IDs of the instance.\",\n\"    Dangerous: should be used only for testing the replication subsystem.\",\n\"CONFIG-REWRITE-FORCE-ALL\",\n\"    Like CONFIG REWRITE but writes all configuration options, including\",\n\"    keywords not listed in original configuration file or default values.\",\n\"CRASH-AND-RECOVER [<milliseconds>]\",\n\"    Hard crash and restart after a <milliseconds> delay (default 0).\",\n\"DIGEST\",\n\"    Output a hex signature representing the current DB content.\",\n\"DIGEST-VALUE <key> [<key> ...]\",\n\"    Output a hex signature of the values of all the specified keys.\",\n\"ERROR <string>\",\n\"    Return a Redis protocol error with <string> as message. Useful for clients\",\n\"    unit tests to simulate Redis errors.\",\n\"LEAK <string>\",\n\"    Create a memory leak of the input string.\",\n\"LOG <message>\",\n\"    Write <message> to the server log.\",\n\"HTSTATS <dbid>\",\n\"    Return hash table statistics of the specified Redis database.\",\n\"HTSTATS-KEY <key>\",\n\"    Like HTSTATS but for the hash table stored at <key>'s value.\",\n\"LOADAOF\",\n\"    Flush the AOF buffers on disk and reload the AOF in memory.\",\n\"REPLICATE <string>\",\n\"    Replicates the provided string to replicas, allowing data divergence.\",\n#ifdef USE_JEMALLOC\n\"MALLCTL <key> [<val>]\",\n\"    Get or set a malloc tuning integer.\",\n\"MALLCTL-STR <key> [<val>]\",\n\"    Get or set a malloc tuning string.\",\n#endif\n\"OBJECT <key>\",\n\"    Show low level info about `key` and associated value.\",\n\"DROP-CLUSTER-PACKET-FILTER <packet-type>\",\n\"    Drop all packets that match the filtered type. Set to -1 allow all packets.\",\n\"OOM\",\n\"    Crash the server simulating an out-of-memory error.\",\n\"PANIC\",\n\"    Crash the server simulating a panic.\",\n\"POPULATE <count> [<prefix>] [<size>]\",\n\"    Create <count> string keys named key:<num>. If <prefix> is specified then\",\n\"    it is used instead of the 'key' prefix. These are not propagated to\",\n\"    replicas. Cluster slots are not respected so keys not belonging to the\",\n\"    current node can be created in cluster mode.\",\n\"PROTOCOL <type>\",\n\"    Reply with a test value of the specified type. <type> can be: string,\",\n\"    integer, double, bignum, null, array, set, map, attrib, push, verbatim,\",\n\"    true, false.\",\n\"RELOAD [option ...]\",\n\"    Save the RDB on disk and reload it back to memory. Valid <option> values:\",\n\"    * MERGE: conflicting keys will be loaded from RDB.\",\n\"    * NOFLUSH: the existing database will not be removed before load, but\",\n\"      conflicting keys will generate an exception and kill the server.\",\n\"    * NOSAVE: the database will be loaded from an existing RDB file.\",\n\"    Examples:\",\n\"    * DEBUG RELOAD: verify that the server is able to persist, flush and reload\",\n\"      the database.\",\n\"    * DEBUG RELOAD NOSAVE: replace the current database with the contents of an\",\n\"      existing RDB file.\",\n\"    * DEBUG RELOAD NOSAVE NOFLUSH MERGE: add the contents of an existing RDB\",\n\"      file to the database.\",\n\"RESTART [<milliseconds>]\",\n\"    Graceful restart: save config, db, restart after a <milliseconds> delay (default 0).\",\n\"SDSLEN <key>\",\n\"    Show low level SDS string info representing `key` and value.\",\n\"SEGFAULT\",\n\"    Crash the server with sigsegv.\",\n\"SET-ACTIVE-EXPIRE <0|1>\",\n\"    Setting it to 0 disables expiring keys in background when they are not\",\n\"    accessed (otherwise the Redis behavior). Setting it to 1 reenables back the\",\n\"    default.\",\n\"QUICKLIST-PACKED-THRESHOLD <size>\",\n\"    Sets the threshold for elements to be inserted as plain vs packed nodes\",\n\"    Default value is 1GB, allows values up to 4GB. Setting to 0 restores to default.\",\n\"SET-SKIP-CHECKSUM-VALIDATION <0|1>\",\n\"    Enables or disables checksum checks for RDB files and RESTORE's payload.\",\n\"SLEEP <seconds>\",\n\"    Stop the server for <seconds>. Decimals allowed.\",\n\"STRINGMATCH-TEST\",\n\"    Run a fuzz tester against the stringmatchlen() function.\",\n\"STRUCTSIZE\",\n\"    Return the size of different Redis core C structures.\",\n\"LISTPACK <key>\",\n\"    Show low level info about the listpack encoding of <key>.\",\n\"QUICKLIST <key> [<0|1>]\",\n\"    Show low level info about the quicklist encoding of <key>.\",\n\"    The optional argument (0 by default) sets the level of detail\",\n\"CLIENT-EVICTION\",\n\"    Show low level client eviction pools info (maxmemory-clients).\",\n\"PAUSE-CRON <0|1>\",\n\"    Stop periodic cron job processing.\",\n\"REPLYBUFFER PEAK-RESET-TIME <NEVER||RESET|time>\",\n\"    Sets the time (in milliseconds) to wait between client reply buffer peak resets.\",\n\"    In case NEVER is provided the last observed peak will never be reset\",\n\"    In case RESET is provided the peak reset time will be restored to the default value\",\n\"REPLYBUFFER RESIZING <0|1>\",\n\"    Enable or disable the reply buffer resize cron job\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"segfault\")) {\n        /* Compiler gives warnings about writing to a random address\n         * e.g \"*((char*)-1) = 'x';\". As a workaround, we map a read-only area\n         * and try to write there to trigger segmentation fault. */\n        char* p = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);\n        *p = 'x';\n    } else if (!strcasecmp(c->argv[1]->ptr,\"panic\")) {\n        serverPanic(\"DEBUG PANIC called at Unix time %lld\", (long long)time(NULL));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"restart\") ||\n               !strcasecmp(c->argv[1]->ptr,\"crash-and-recover\"))\n    {\n        long long delay = 0;\n        if (c->argc >= 3) {\n            if (getLongLongFromObjectOrReply(c, c->argv[2], &delay, NULL)\n                != C_OK) return;\n            if (delay < 0) delay = 0;\n        }\n        int flags = !strcasecmp(c->argv[1]->ptr,\"restart\") ?\n            (RESTART_SERVER_GRACEFULLY|RESTART_SERVER_CONFIG_REWRITE) :\n             RESTART_SERVER_NONE;\n        restartServer(flags,delay);\n        addReplyError(c,\"failed to restart the server. Check server logs.\");\n    } else if (!strcasecmp(c->argv[1]->ptr,\"oom\")) {\n        void *ptr = zmalloc(ULONG_MAX); /* Should trigger an out of memory. */\n        zfree(ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"assert\")) {\n        serverAssertWithInfo(c,c->argv[0],1 == 2);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"log\") && c->argc == 3) {\n        serverLog(LL_WARNING, \"DEBUG LOG: %s\", (char*)c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"leak\") && c->argc == 3) {\n        sdsdup(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"reload\")) {\n        int flush = 1, save = 1;\n        int flags = RDBFLAGS_NONE;\n\n        /* Parse the additional options that modify the RELOAD\n         * behavior. */\n        for (int j = 2; j < c->argc; j++) {\n            char *opt = c->argv[j]->ptr;\n            if (!strcasecmp(opt,\"MERGE\")) {\n                flags |= RDBFLAGS_ALLOW_DUP;\n            } else if (!strcasecmp(opt,\"NOFLUSH\")) {\n                flush = 0;\n            } else if (!strcasecmp(opt,\"NOSAVE\")) {\n                save = 0;\n            } else {\n                addReplyError(c,\"DEBUG RELOAD only supports the \"\n                                \"MERGE, NOFLUSH and NOSAVE options.\");\n                return;\n            }\n        }\n\n        /* The default behavior is to save the RDB file before loading\n         * it back. */\n        if (save) {\n            rdbSaveInfo rsi, *rsiptr;\n            rsiptr = rdbPopulateSaveInfo(&rsi);\n            if (rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr) != C_OK) {\n                addReplyErrorObject(c,shared.err);\n                return;\n            }\n        }\n\n        /* The default behavior is to remove the current dataset from\n         * memory before loading the RDB file, however when MERGE is\n         * used together with NOFLUSH, we are able to merge two datasets. */\n        if (flush) emptyData(-1,EMPTYDB_NO_FLAGS,NULL);\n\n        protectClient(c);\n        int ret = rdbLoad(server.rdb_filename,NULL,flags);\n        unprotectClient(c);\n        if (ret != RDB_OK) {\n            addReplyError(c,\"Error trying to load the RDB dump, check server logs.\");\n            return;\n        }\n        serverLog(LL_WARNING,\"DB reloaded by DEBUG RELOAD\");\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"loadaof\")) {\n        if (server.aof_state != AOF_OFF) flushAppendOnlyFile(1);\n        emptyData(-1,EMPTYDB_NO_FLAGS,NULL);\n        protectClient(c);\n        if (server.aof_manifest) aofManifestFree(server.aof_manifest);\n        aofLoadManifestFromDisk();\n        aofDelHistoryFiles();\n        int ret = loadAppendOnlyFiles(server.aof_manifest);\n        if (ret != AOF_OK && ret != AOF_EMPTY)\n            exit(1);\n        unprotectClient(c);\n        server.dirty = 0; /* Prevent AOF / replication */\n        serverLog(LL_WARNING,\"Append Only File loaded by DEBUG LOADAOF\");\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"drop-cluster-packet-filter\") && c->argc == 3) {\n        long packet_type;\n        if (getLongFromObjectOrReply(c, c->argv[2], &packet_type, NULL) != C_OK)\n            return;\n        server.cluster_drop_packet_filter = packet_type;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"object\") && c->argc == 3) {\n        dictEntry *de;\n        robj *val;\n        char *strenc;\n\n        if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {\n            addReplyErrorObject(c,shared.nokeyerr);\n            return;\n        }\n        val = dictGetVal(de);\n        strenc = strEncoding(val->encoding);\n\n        char extra[138] = {0};\n        if (val->encoding == OBJ_ENCODING_QUICKLIST) {\n            char *nextra = extra;\n            int remaining = sizeof(extra);\n            quicklist *ql = val->ptr;\n            /* Add number of quicklist nodes */\n            int used = snprintf(nextra, remaining, \" ql_nodes:%lu\", ql->len);\n            nextra += used;\n            remaining -= used;\n            /* Add average quicklist fill factor */\n            double avg = (double)ql->count/ql->len;\n            used = snprintf(nextra, remaining, \" ql_avg_node:%.2f\", avg);\n            nextra += used;\n            remaining -= used;\n            /* Add quicklist fill level / max listpack size */\n            used = snprintf(nextra, remaining, \" ql_listpack_max:%d\", ql->fill);\n            nextra += used;\n            remaining -= used;\n            /* Add isCompressed? */\n            int compressed = ql->compress != 0;\n            used = snprintf(nextra, remaining, \" ql_compressed:%d\", compressed);\n            nextra += used;\n            remaining -= used;\n            /* Add total uncompressed size */\n            unsigned long sz = 0;\n            for (quicklistNode *node = ql->head; node; node = node->next) {\n                sz += node->sz;\n            }\n            used = snprintf(nextra, remaining, \" ql_uncompressed_size:%lu\", sz);\n            nextra += used;\n            remaining -= used;\n        }\n\n        addReplyStatusFormat(c,\n            \"Value at:%p refcount:%d \"\n            \"encoding:%s serializedlength:%zu \"\n            \"lru:%d lru_seconds_idle:%llu%s\",\n            (void*)val, val->refcount,\n            strenc, rdbSavedObjectLen(val, c->argv[2], c->db->id),\n            val->lru, estimateObjectIdleTime(val)/1000, extra);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"sdslen\") && c->argc == 3) {\n        dictEntry *de;\n        robj *val;\n        sds key;\n\n        if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {\n            addReplyErrorObject(c,shared.nokeyerr);\n            return;\n        }\n        val = dictGetVal(de);\n        key = dictGetKey(de);\n\n        if (val->type != OBJ_STRING || !sdsEncodedObject(val)) {\n            addReplyError(c,\"Not an sds encoded string.\");\n        } else {\n            addReplyStatusFormat(c,\n                \"key_sds_len:%lld, key_sds_avail:%lld, key_zmalloc: %lld, \"\n                \"val_sds_len:%lld, val_sds_avail:%lld, val_zmalloc: %lld\",\n                (long long) sdslen(key),\n                (long long) sdsavail(key),\n                (long long) sdsZmallocSize(key),\n                (long long) sdslen(val->ptr),\n                (long long) sdsavail(val->ptr),\n                (long long) getStringObjectSdsUsedMemory(val));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"listpack\") && c->argc == 3) {\n        robj *o;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n                == NULL) return;\n\n        if (o->encoding != OBJ_ENCODING_LISTPACK) {\n            addReplyError(c,\"Not a listpack encoded object.\");\n        } else {\n            lpRepr(o->ptr);\n            addReplyStatus(c,\"Listpack structure printed on stdout\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"quicklist\") && (c->argc == 3 || c->argc == 4)) {\n        robj *o;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n            == NULL) return;\n\n        int full = 0;\n        if (c->argc == 4)\n            full = atoi(c->argv[3]->ptr);\n        if (o->encoding != OBJ_ENCODING_QUICKLIST) {\n            addReplyError(c,\"Not a quicklist encoded object.\");\n        } else {\n            quicklistRepr(o->ptr, full);\n            addReplyStatus(c,\"Quicklist structure printed on stdout\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"populate\") &&\n               c->argc >= 3 && c->argc <= 5) {\n        long keys, j;\n        robj *key, *val;\n        char buf[128];\n\n        if (getPositiveLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)\n            return;\n\n        dictExpand(c->db->dict,keys);\n        long valsize = 0;\n        if ( c->argc == 5 && getPositiveLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK ) \n            return;\n\n        for (j = 0; j < keys; j++) {\n            snprintf(buf,sizeof(buf),\"%s:%lu\",\n                (c->argc == 3) ? \"key\" : (char*)c->argv[3]->ptr, j);\n            key = createStringObject(buf,strlen(buf));\n            if (lookupKeyWrite(c->db,key) != NULL) {\n                decrRefCount(key);\n                continue;\n            }\n            snprintf(buf,sizeof(buf),\"value:%lu\",j);\n            if (valsize==0)\n                val = createStringObject(buf,strlen(buf));\n            else {\n                int buflen = strlen(buf);\n                val = createStringObject(NULL,valsize);\n                memcpy(val->ptr, buf, valsize<=buflen? valsize: buflen);\n            }\n            dbAdd(c->db,key,val);\n            signalModifiedKey(c,c->db,key);\n            decrRefCount(key);\n        }\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"digest\") && c->argc == 2) {\n        /* DEBUG DIGEST (form without keys specified) */\n        unsigned char digest[20];\n        sds d = sdsempty();\n\n        computeDatasetDigest(digest);\n        for (int i = 0; i < 20; i++) d = sdscatprintf(d, \"%02x\",digest[i]);\n        addReplyStatus(c,d);\n        sdsfree(d);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"digest-value\") && c->argc >= 2) {\n        /* DEBUG DIGEST-VALUE key key key ... key. */\n        addReplyArrayLen(c,c->argc-2);\n        for (int j = 2; j < c->argc; j++) {\n            unsigned char digest[20];\n            memset(digest,0,20); /* Start with a clean result */\n\n            /* We don't use lookupKey because a debug command should\n             * work on logically expired keys */\n            dictEntry *de;\n            robj *o = ((de = dictFind(c->db->dict,c->argv[j]->ptr)) == NULL) ? NULL : dictGetVal(de);\n            if (o) xorObjectDigest(c->db,c->argv[j],digest,o);\n\n            sds d = sdsempty();\n            for (int i = 0; i < 20; i++) d = sdscatprintf(d, \"%02x\",digest[i]);\n            addReplyStatus(c,d);\n            sdsfree(d);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"protocol\") && c->argc == 3) {\n        /* DEBUG PROTOCOL [string|integer|double|bignum|null|array|set|map|\n         *                 attrib|push|verbatim|true|false] */\n        char *name = c->argv[2]->ptr;\n        if (!strcasecmp(name,\"string\")) {\n            addReplyBulkCString(c,\"Hello World\");\n        } else if (!strcasecmp(name,\"integer\")) {\n            addReplyLongLong(c,12345);\n        } else if (!strcasecmp(name,\"double\")) {\n            addReplyDouble(c,3.141);\n        } else if (!strcasecmp(name,\"bignum\")) {\n            addReplyBigNum(c,\"1234567999999999999999999999999999999\",37);\n        } else if (!strcasecmp(name,\"null\")) {\n            addReplyNull(c);\n        } else if (!strcasecmp(name,\"array\")) {\n            addReplyArrayLen(c,3);\n            for (int j = 0; j < 3; j++) addReplyLongLong(c,j);\n        } else if (!strcasecmp(name,\"set\")) {\n            addReplySetLen(c,3);\n            for (int j = 0; j < 3; j++) addReplyLongLong(c,j);\n        } else if (!strcasecmp(name,\"map\")) {\n            addReplyMapLen(c,3);\n            for (int j = 0; j < 3; j++) {\n                addReplyLongLong(c,j);\n                addReplyBool(c, j == 1);\n            }\n        } else if (!strcasecmp(name,\"attrib\")) {\n            if (c->resp >= 3) {\n                addReplyAttributeLen(c,1);\n                addReplyBulkCString(c,\"key-popularity\");\n                addReplyArrayLen(c,2);\n                addReplyBulkCString(c,\"key:123\");\n                addReplyLongLong(c,90);\n            }\n            /* Attributes are not real replies, so a well formed reply should\n             * also have a normal reply type after the attribute. */\n            addReplyBulkCString(c,\"Some real reply following the attribute\");\n        } else if (!strcasecmp(name,\"push\")) {\n            if (c->resp < 3) {\n                addReplyError(c,\"RESP2 is not supported by this command\");\n                return;\n\t    }\n            addReplyPushLen(c,2);\n            addReplyBulkCString(c,\"server-cpu-usage\");\n            addReplyLongLong(c,42);\n            /* Push replies are not synchronous replies, so we emit also a\n             * normal reply in order for blocking clients just discarding the\n             * push reply, to actually consume the reply and continue. */\n            addReplyBulkCString(c,\"Some real reply following the push reply\");\n        } else if (!strcasecmp(name,\"true\")) {\n            addReplyBool(c,1);\n        } else if (!strcasecmp(name,\"false\")) {\n            addReplyBool(c,0);\n        } else if (!strcasecmp(name,\"verbatim\")) {\n            addReplyVerbatim(c,\"This is a verbatim\\nstring\",25,\"txt\");\n        } else {\n            addReplyError(c,\"Wrong protocol type name. Please use one of the following: string|integer|double|bignum|null|array|set|map|attrib|push|verbatim|true|false\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"sleep\") && c->argc == 3) {\n        double dtime = strtod(c->argv[2]->ptr,NULL);\n        long long utime = dtime*1000000;\n        struct timespec tv;\n\n        tv.tv_sec = utime / 1000000;\n        tv.tv_nsec = (utime % 1000000) * 1000;\n        nanosleep(&tv, NULL);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-active-expire\") &&\n               c->argc == 3)\n    {\n        server.active_expire_enabled = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"quicklist-packed-threshold\") &&\n               c->argc == 3)\n    {\n        int memerr;\n        unsigned long long sz = memtoull((const char *)c->argv[2]->ptr, &memerr);\n        if (memerr || !quicklistisSetPackedThreshold(sz)) {\n            addReplyError(c, \"argument must be a memory value bigger than 1 and smaller than 4gb\");\n        } else {\n            addReply(c,shared.ok);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-skip-checksum-validation\") &&\n               c->argc == 3)\n    {\n        server.skip_checksum_validation = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"aof-flush-sleep\") &&\n               c->argc == 3)\n    {\n        server.aof_flush_sleep = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"replicate\") && c->argc >= 3) {\n        replicationFeedSlaves(server.slaves, -1,\n                c->argv + 2, c->argc - 2);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"error\") && c->argc == 3) {\n        sds errstr = sdsnewlen(\"-\",1);\n\n        errstr = sdscatsds(errstr,c->argv[2]->ptr);\n        errstr = sdsmapchars(errstr,\"\\n\\r\",\"  \",2); /* no newlines in errors. */\n        errstr = sdscatlen(errstr,\"\\r\\n\",2);\n        addReplySds(c,errstr);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"structsize\") && c->argc == 2) {\n        sds sizes = sdsempty();\n        sizes = sdscatprintf(sizes,\"bits:%d \",(sizeof(void*) == 8)?64:32);\n        sizes = sdscatprintf(sizes,\"robj:%d \",(int)sizeof(robj));\n        sizes = sdscatprintf(sizes,\"dictentry:%d \",(int)sizeof(dictEntry));\n        sizes = sdscatprintf(sizes,\"sdshdr5:%d \",(int)sizeof(struct sdshdr5));\n        sizes = sdscatprintf(sizes,\"sdshdr8:%d \",(int)sizeof(struct sdshdr8));\n        sizes = sdscatprintf(sizes,\"sdshdr16:%d \",(int)sizeof(struct sdshdr16));\n        sizes = sdscatprintf(sizes,\"sdshdr32:%d \",(int)sizeof(struct sdshdr32));\n        sizes = sdscatprintf(sizes,\"sdshdr64:%d \",(int)sizeof(struct sdshdr64));\n        addReplyBulkSds(c,sizes);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"htstats\") && c->argc == 3) {\n        long dbid;\n        sds stats = sdsempty();\n        char buf[4096];\n\n        if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK) {\n            sdsfree(stats);\n            return;\n        }\n        if (dbid < 0 || dbid >= server.dbnum) {\n            sdsfree(stats);\n            addReplyError(c,\"Out of range database\");\n            return;\n        }\n\n        stats = sdscatprintf(stats,\"[Dictionary HT]\\n\");\n        dictGetStats(buf,sizeof(buf),server.db[dbid].dict);\n        stats = sdscat(stats,buf);\n\n        stats = sdscatprintf(stats,\"[Expires HT]\\n\");\n        dictGetStats(buf,sizeof(buf),server.db[dbid].expires);\n        stats = sdscat(stats,buf);\n\n        addReplyVerbatim(c,stats,sdslen(stats),\"txt\");\n        sdsfree(stats);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"htstats-key\") && c->argc == 3) {\n        robj *o;\n        dict *ht = NULL;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n                == NULL) return;\n\n        /* Get the hash table reference from the object, if possible. */\n        switch (o->encoding) {\n        case OBJ_ENCODING_SKIPLIST:\n            {\n                zset *zs = o->ptr;\n                ht = zs->dict;\n            }\n            break;\n        case OBJ_ENCODING_HT:\n            ht = o->ptr;\n            break;\n        }\n\n        if (ht == NULL) {\n            addReplyError(c,\"The value stored at the specified key is not \"\n                            \"represented using an hash table\");\n        } else {\n            char buf[4096];\n            dictGetStats(buf,sizeof(buf),ht);\n            addReplyVerbatim(c,buf,strlen(buf),\"txt\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"change-repl-id\") && c->argc == 2) {\n        serverLog(LL_WARNING,\"Changing replication IDs after receiving DEBUG change-repl-id\");\n        changeReplicationId();\n        clearReplicationId2();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"stringmatch-test\") && c->argc == 2)\n    {\n        stringmatchlen_fuzz_test();\n        addReplyStatus(c,\"Apparently Redis did not crash: test passed\");\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-disable-deny-scripts\") && c->argc == 3)\n    {\n        server.script_disable_deny_script = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"config-rewrite-force-all\") && c->argc == 2)\n    {\n        if (rewriteConfig(server.configfile, 1) == -1)\n            addReplyErrorFormat(c, \"CONFIG-REWRITE-FORCE-ALL failed: %s\", strerror(errno));\n        else\n            addReply(c, shared.ok);\n    } else if(!strcasecmp(c->argv[1]->ptr,\"client-eviction\") && c->argc == 2) {\n        sds bucket_info = sdsempty();\n        for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++) {\n            if (j == 0)\n                bucket_info = sdscatprintf(bucket_info, \"bucket          0\");\n            else\n                bucket_info = sdscatprintf(bucket_info, \"bucket %10zu\", (size_t)1<<(j-1+CLIENT_MEM_USAGE_BUCKET_MIN_LOG));\n            if (j == CLIENT_MEM_USAGE_BUCKETS-1)\n                bucket_info = sdscatprintf(bucket_info, \"+            : \");\n            else\n                bucket_info = sdscatprintf(bucket_info, \" - %10zu: \", ((size_t)1<<(j+CLIENT_MEM_USAGE_BUCKET_MIN_LOG))-1);\n            bucket_info = sdscatprintf(bucket_info, \"tot-mem: %10zu, clients: %lu\\n\",\n                server.client_mem_usage_buckets[j].mem_usage_sum,\n                server.client_mem_usage_buckets[j].clients->len);\n        }\n        addReplyVerbatim(c,bucket_info,sdslen(bucket_info),\"txt\");\n        sdsfree(bucket_info);\n#ifdef USE_JEMALLOC\n    } else if(!strcasecmp(c->argv[1]->ptr,\"mallctl\") && c->argc >= 3) {\n        mallctl_int(c, c->argv+2, c->argc-2);\n        return;\n    } else if(!strcasecmp(c->argv[1]->ptr,\"mallctl-str\") && c->argc >= 3) {\n        mallctl_string(c, c->argv+2, c->argc-2);\n        return;\n#endif\n    } else if (!strcasecmp(c->argv[1]->ptr,\"pause-cron\") && c->argc == 3)\n    {\n        server.pause_cron = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"replybuffer\") && c->argc == 4 ) {\n        if(!strcasecmp(c->argv[2]->ptr, \"peak-reset-time\")) {\n            if (!strcasecmp(c->argv[3]->ptr, \"never\")) {\n                server.reply_buffer_peak_reset_time = -1;\n            } else if(!strcasecmp(c->argv[3]->ptr, \"reset\")) {\n                server.reply_buffer_peak_reset_time = REPLY_BUFFER_DEFAULT_PEAK_RESET_TIME;\n            } else {\n                if (getLongFromObjectOrReply(c, c->argv[3], &server.reply_buffer_peak_reset_time, NULL) != C_OK)\n                    return;\n            }\n        } else if(!strcasecmp(c->argv[2]->ptr,\"resizing\")) {\n            server.reply_buffer_resizing_enabled = atoi(c->argv[3]->ptr);\n        } else {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n        addReply(c, shared.ok);\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n\n/* =========================== Crash handling  ============================== */\n\nvoid _serverAssert(const char *estr, const char *file, int line) {\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED ===\");\n    serverLog(LL_WARNING,\"==> %s:%d '%s' is not true\",file,line,estr);\n\n    if (server.crashlog_enabled) {\n#ifdef HAVE_BACKTRACE\n        logStackTrace(NULL, 1);\n#endif\n        printCrashReport();\n    }\n\n    // remove the signal handler so on abort() we will output the crash report.\n    removeSignalHandlers();\n    bugReportEnd(0, 0);\n}\n\nvoid _serverAssertPrintClientInfo(const client *c) {\n    int j;\n    char conninfo[CONN_INFO_LEN];\n\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED CLIENT CONTEXT ===\");\n    serverLog(LL_WARNING,\"client->flags = %llu\", (unsigned long long) c->flags);\n    serverLog(LL_WARNING,\"client->conn = %s\", connGetInfo(c->conn, conninfo, sizeof(conninfo)));\n    serverLog(LL_WARNING,\"client->argc = %d\", c->argc);\n    for (j=0; j < c->argc; j++) {\n        char buf[128];\n        char *arg;\n\n        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {\n            arg = (char*) c->argv[j]->ptr;\n        } else {\n            snprintf(buf,sizeof(buf),\"Object type: %u, encoding: %u\",\n                c->argv[j]->type, c->argv[j]->encoding);\n            arg = buf;\n        }\n        serverLog(LL_WARNING,\"client->argv[%d] = \\\"%s\\\" (refcount: %d)\",\n            j, arg, c->argv[j]->refcount);\n    }\n}\n\nvoid serverLogObjectDebugInfo(const robj *o) {\n    serverLog(LL_WARNING,\"Object type: %u\", o->type);\n    serverLog(LL_WARNING,\"Object encoding: %u\", o->encoding);\n    serverLog(LL_WARNING,\"Object refcount: %d\", o->refcount);\n#if UNSAFE_CRASH_REPORT\n    /* This code is now disabled. o->ptr may be unreliable to print. in some\n     * cases a ziplist could have already been freed by realloc, but not yet\n     * updated to o->ptr. in other cases the call to ziplistLen may need to\n     * iterate on all the items in the list (and possibly crash again).\n     * For some cases it may be ok to crash here again, but these could cause\n     * invalid memory access which will bother valgrind and also possibly cause\n     * random memory portion to be \"leaked\" into the logfile. */\n    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {\n        serverLog(LL_WARNING,\"Object raw string len: %zu\", sdslen(o->ptr));\n        if (sdslen(o->ptr) < 4096) {\n            sds repr = sdscatrepr(sdsempty(),o->ptr,sdslen(o->ptr));\n            serverLog(LL_WARNING,\"Object raw string content: %s\", repr);\n            sdsfree(repr);\n        }\n    } else if (o->type == OBJ_LIST) {\n        serverLog(LL_WARNING,\"List length: %d\", (int) listTypeLength(o));\n    } else if (o->type == OBJ_SET) {\n        serverLog(LL_WARNING,\"Set size: %d\", (int) setTypeSize(o));\n    } else if (o->type == OBJ_HASH) {\n        serverLog(LL_WARNING,\"Hash size: %d\", (int) hashTypeLength(o));\n    } else if (o->type == OBJ_ZSET) {\n        serverLog(LL_WARNING,\"Sorted set size: %d\", (int) zsetLength(o));\n        if (o->encoding == OBJ_ENCODING_SKIPLIST)\n            serverLog(LL_WARNING,\"Skiplist level: %d\", (int) ((const zset*)o->ptr)->zsl->level);\n    } else if (o->type == OBJ_STREAM) {\n        serverLog(LL_WARNING,\"Stream size: %d\", (int) streamLength(o));\n    }\n#endif\n}\n\nvoid _serverAssertPrintObject(const robj *o) {\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED OBJECT CONTEXT ===\");\n    serverLogObjectDebugInfo(o);\n}\n\nvoid _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {\n    if (c) _serverAssertPrintClientInfo(c);\n    if (o) _serverAssertPrintObject(o);\n    _serverAssert(estr,file,line);\n}\n\nvoid _serverPanic(const char *file, int line, const char *msg, ...) {\n    va_list ap;\n    va_start(ap,msg);\n    char fmtmsg[256];\n    vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);\n    va_end(ap);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\"------------------------------------------------\");\n    serverLog(LL_WARNING,\"!!! Software Failure. Press left mouse button to continue\");\n    serverLog(LL_WARNING,\"Guru Meditation: %s #%s:%d\",fmtmsg,file,line);\n\n    if (server.crashlog_enabled) {\n#ifdef HAVE_BACKTRACE\n        logStackTrace(NULL, 1);\n#endif\n        printCrashReport();\n    }\n\n    // remove the signal handler so on abort() we will output the crash report.\n    removeSignalHandlers();\n    bugReportEnd(0, 0);\n}\n\nvoid bugReportStart(void) {\n    pthread_mutex_lock(&bug_report_start_mutex);\n    if (bug_report_start == 0) {\n        serverLogRaw(LL_WARNING|LL_RAW,\n        \"\\n\\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\\n\");\n        bug_report_start = 1;\n    }\n    pthread_mutex_unlock(&bug_report_start_mutex);\n}\n\n#ifdef HAVE_BACKTRACE\nstatic void *getMcontextEip(ucontext_t *uc) {\n#define NOT_SUPPORTED() do {\\\n    UNUSED(uc);\\\n    return NULL;\\\n} while(0)\n#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)\n    /* OSX < 10.6 */\n    #if defined(__x86_64__)\n    return (void*) uc->uc_mcontext->__ss.__rip;\n    #elif defined(__i386__)\n    return (void*) uc->uc_mcontext->__ss.__eip;\n    #else\n    return (void*) uc->uc_mcontext->__ss.__srr0;\n    #endif\n#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n    /* OSX >= 10.6 */\n    #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    return (void*) uc->uc_mcontext->__ss.__rip;\n    #elif defined(__i386__)\n    return (void*) uc->uc_mcontext->__ss.__eip;\n    #else\n    /* OSX ARM64 */\n    return (void*) arm_thread_state64_get_pc(uc->uc_mcontext->__ss);\n    #endif\n#elif defined(__linux__)\n    /* Linux */\n    #if defined(__i386__) || ((defined(__X86_64__) || defined(__x86_64__)) && defined(__ILP32__))\n    return (void*) uc->uc_mcontext.gregs[14]; /* Linux 32 */\n    #elif defined(__X86_64__) || defined(__x86_64__)\n    return (void*) uc->uc_mcontext.gregs[16]; /* Linux 64 */\n    #elif defined(__ia64__) /* Linux IA64 */\n    return (void*) uc->uc_mcontext.sc_ip;\n    #elif defined(__arm__) /* Linux ARM */\n    return (void*) uc->uc_mcontext.arm_pc;\n    #elif defined(__aarch64__) /* Linux AArch64 */\n    return (void*) uc->uc_mcontext.pc;\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__FreeBSD__)\n    /* FreeBSD */\n    #if defined(__i386__)\n    return (void*) uc->uc_mcontext.mc_eip;\n    #elif defined(__x86_64__)\n    return (void*) uc->uc_mcontext.mc_rip;\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__OpenBSD__)\n    /* OpenBSD */\n    #if defined(__i386__)\n    return (void*) uc->sc_eip;\n    #elif defined(__x86_64__)\n    return (void*) uc->sc_rip;\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__NetBSD__)\n    #if defined(__i386__)\n    return (void*) uc->uc_mcontext.__gregs[_REG_EIP];\n    #elif defined(__x86_64__)\n    return (void*) uc->uc_mcontext.__gregs[_REG_RIP];\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__DragonFly__)\n    return (void*) uc->uc_mcontext.mc_rip;\n#else\n    NOT_SUPPORTED();\n#endif\n#undef NOT_SUPPORTED\n}\n\nREDIS_NO_SANITIZE(\"address\")\nvoid logStackContent(void **sp) {\n    int i;\n    for (i = 15; i >= 0; i--) {\n        unsigned long addr = (unsigned long) sp+i;\n        unsigned long val = (unsigned long) sp[i];\n\n        if (sizeof(long) == 4)\n            serverLog(LL_WARNING, \"(%08lx) -> %08lx\", addr, val);\n        else\n            serverLog(LL_WARNING, \"(%016lx) -> %016lx\", addr, val);\n    }\n}\n\n/* Log dump of processor registers */\nvoid logRegisters(ucontext_t *uc) {\n    serverLog(LL_WARNING|LL_RAW, \"\\n------ REGISTERS ------\\n\");\n#define NOT_SUPPORTED() do {\\\n    UNUSED(uc);\\\n    serverLog(LL_WARNING,\\\n              \"  Dumping of registers not supported for this OS/arch\");\\\n} while(0)\n\n/* OSX */\n#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n  /* OSX AMD64 */\n    #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCS :%016lx FS:%016lx  GS:%016lx\",\n        (unsigned long) uc->uc_mcontext->__ss.__rax,\n        (unsigned long) uc->uc_mcontext->__ss.__rbx,\n        (unsigned long) uc->uc_mcontext->__ss.__rcx,\n        (unsigned long) uc->uc_mcontext->__ss.__rdx,\n        (unsigned long) uc->uc_mcontext->__ss.__rdi,\n        (unsigned long) uc->uc_mcontext->__ss.__rsi,\n        (unsigned long) uc->uc_mcontext->__ss.__rbp,\n        (unsigned long) uc->uc_mcontext->__ss.__rsp,\n        (unsigned long) uc->uc_mcontext->__ss.__r8,\n        (unsigned long) uc->uc_mcontext->__ss.__r9,\n        (unsigned long) uc->uc_mcontext->__ss.__r10,\n        (unsigned long) uc->uc_mcontext->__ss.__r11,\n        (unsigned long) uc->uc_mcontext->__ss.__r12,\n        (unsigned long) uc->uc_mcontext->__ss.__r13,\n        (unsigned long) uc->uc_mcontext->__ss.__r14,\n        (unsigned long) uc->uc_mcontext->__ss.__r15,\n        (unsigned long) uc->uc_mcontext->__ss.__rip,\n        (unsigned long) uc->uc_mcontext->__ss.__rflags,\n        (unsigned long) uc->uc_mcontext->__ss.__cs,\n        (unsigned long) uc->uc_mcontext->__ss.__fs,\n        (unsigned long) uc->uc_mcontext->__ss.__gs\n    );\n    logStackContent((void**)uc->uc_mcontext->__ss.__rsp);\n    #elif defined(__i386__)\n    /* OSX x86 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\\n\"\n    \"DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx\",\n        (unsigned long) uc->uc_mcontext->__ss.__eax,\n        (unsigned long) uc->uc_mcontext->__ss.__ebx,\n        (unsigned long) uc->uc_mcontext->__ss.__ecx,\n        (unsigned long) uc->uc_mcontext->__ss.__edx,\n        (unsigned long) uc->uc_mcontext->__ss.__edi,\n        (unsigned long) uc->uc_mcontext->__ss.__esi,\n        (unsigned long) uc->uc_mcontext->__ss.__ebp,\n        (unsigned long) uc->uc_mcontext->__ss.__esp,\n        (unsigned long) uc->uc_mcontext->__ss.__ss,\n        (unsigned long) uc->uc_mcontext->__ss.__eflags,\n        (unsigned long) uc->uc_mcontext->__ss.__eip,\n        (unsigned long) uc->uc_mcontext->__ss.__cs,\n        (unsigned long) uc->uc_mcontext->__ss.__ds,\n        (unsigned long) uc->uc_mcontext->__ss.__es,\n        (unsigned long) uc->uc_mcontext->__ss.__fs,\n        (unsigned long) uc->uc_mcontext->__ss.__gs\n    );\n    logStackContent((void**)uc->uc_mcontext->__ss.__esp);\n    #else\n    /* OSX ARM64 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"x0:%016lx x1:%016lx x2:%016lx x3:%016lx\\n\"\n    \"x4:%016lx x5:%016lx x6:%016lx x7:%016lx\\n\"\n    \"x8:%016lx x9:%016lx x10:%016lx x11:%016lx\\n\"\n    \"x12:%016lx x13:%016lx x14:%016lx x15:%016lx\\n\"\n    \"x16:%016lx x17:%016lx x18:%016lx x19:%016lx\\n\"\n    \"x20:%016lx x21:%016lx x22:%016lx x23:%016lx\\n\"\n    \"x24:%016lx x25:%016lx x26:%016lx x27:%016lx\\n\"\n    \"x28:%016lx fp:%016lx lr:%016lx\\n\"\n    \"sp:%016lx pc:%016lx cpsr:%08lx\\n\",\n        (unsigned long) uc->uc_mcontext->__ss.__x[0],\n        (unsigned long) uc->uc_mcontext->__ss.__x[1],\n        (unsigned long) uc->uc_mcontext->__ss.__x[2],\n        (unsigned long) uc->uc_mcontext->__ss.__x[3],\n        (unsigned long) uc->uc_mcontext->__ss.__x[4],\n        (unsigned long) uc->uc_mcontext->__ss.__x[5],\n        (unsigned long) uc->uc_mcontext->__ss.__x[6],\n        (unsigned long) uc->uc_mcontext->__ss.__x[7],\n        (unsigned long) uc->uc_mcontext->__ss.__x[8],\n        (unsigned long) uc->uc_mcontext->__ss.__x[9],\n        (unsigned long) uc->uc_mcontext->__ss.__x[10],\n        (unsigned long) uc->uc_mcontext->__ss.__x[11],\n        (unsigned long) uc->uc_mcontext->__ss.__x[12],\n        (unsigned long) uc->uc_mcontext->__ss.__x[13],\n        (unsigned long) uc->uc_mcontext->__ss.__x[14],\n        (unsigned long) uc->uc_mcontext->__ss.__x[15],\n        (unsigned long) uc->uc_mcontext->__ss.__x[16],\n        (unsigned long) uc->uc_mcontext->__ss.__x[17],\n        (unsigned long) uc->uc_mcontext->__ss.__x[18],\n        (unsigned long) uc->uc_mcontext->__ss.__x[19],\n        (unsigned long) uc->uc_mcontext->__ss.__x[20],\n        (unsigned long) uc->uc_mcontext->__ss.__x[21],\n        (unsigned long) uc->uc_mcontext->__ss.__x[22],\n        (unsigned long) uc->uc_mcontext->__ss.__x[23],\n        (unsigned long) uc->uc_mcontext->__ss.__x[24],\n        (unsigned long) uc->uc_mcontext->__ss.__x[25],\n        (unsigned long) uc->uc_mcontext->__ss.__x[26],\n        (unsigned long) uc->uc_mcontext->__ss.__x[27],\n        (unsigned long) uc->uc_mcontext->__ss.__x[28],\n        (unsigned long) arm_thread_state64_get_fp(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_lr(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_sp(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_pc(uc->uc_mcontext->__ss),\n        (unsigned long) uc->uc_mcontext->__ss.__cpsr\n    );\n    logStackContent((void**) arm_thread_state64_get_sp(uc->uc_mcontext->__ss));\n    #endif\n/* Linux */\n#elif defined(__linux__)\n    /* Linux x86 */\n    #if defined(__i386__) || ((defined(__X86_64__) || defined(__x86_64__)) && defined(__ILP32__))\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.gregs[11],\n        (unsigned long) uc->uc_mcontext.gregs[8],\n        (unsigned long) uc->uc_mcontext.gregs[10],\n        (unsigned long) uc->uc_mcontext.gregs[9],\n        (unsigned long) uc->uc_mcontext.gregs[4],\n        (unsigned long) uc->uc_mcontext.gregs[5],\n        (unsigned long) uc->uc_mcontext.gregs[6],\n        (unsigned long) uc->uc_mcontext.gregs[7],\n        (unsigned long) uc->uc_mcontext.gregs[18],\n        (unsigned long) uc->uc_mcontext.gregs[17],\n        (unsigned long) uc->uc_mcontext.gregs[14],\n        (unsigned long) uc->uc_mcontext.gregs[15],\n        (unsigned long) uc->uc_mcontext.gregs[3],\n        (unsigned long) uc->uc_mcontext.gregs[2],\n        (unsigned long) uc->uc_mcontext.gregs[1],\n        (unsigned long) uc->uc_mcontext.gregs[0]\n    );\n    logStackContent((void**)uc->uc_mcontext.gregs[7]);\n    #elif defined(__X86_64__) || defined(__x86_64__)\n    /* Linux AMD64 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.gregs[13],\n        (unsigned long) uc->uc_mcontext.gregs[11],\n        (unsigned long) uc->uc_mcontext.gregs[14],\n        (unsigned long) uc->uc_mcontext.gregs[12],\n        (unsigned long) uc->uc_mcontext.gregs[8],\n        (unsigned long) uc->uc_mcontext.gregs[9],\n        (unsigned long) uc->uc_mcontext.gregs[10],\n        (unsigned long) uc->uc_mcontext.gregs[15],\n        (unsigned long) uc->uc_mcontext.gregs[0],\n        (unsigned long) uc->uc_mcontext.gregs[1],\n        (unsigned long) uc->uc_mcontext.gregs[2],\n        (unsigned long) uc->uc_mcontext.gregs[3],\n        (unsigned long) uc->uc_mcontext.gregs[4],\n        (unsigned long) uc->uc_mcontext.gregs[5],\n        (unsigned long) uc->uc_mcontext.gregs[6],\n        (unsigned long) uc->uc_mcontext.gregs[7],\n        (unsigned long) uc->uc_mcontext.gregs[16],\n        (unsigned long) uc->uc_mcontext.gregs[17],\n        (unsigned long) uc->uc_mcontext.gregs[18]\n    );\n    logStackContent((void**)uc->uc_mcontext.gregs[15]);\n    #elif defined(__aarch64__) /* Linux AArch64 */\n    serverLog(LL_WARNING,\n\t      \"\\n\"\n\t      \"X18:%016lx X19:%016lx\\nX20:%016lx X21:%016lx\\n\"\n\t      \"X22:%016lx X23:%016lx\\nX24:%016lx X25:%016lx\\n\"\n\t      \"X26:%016lx X27:%016lx\\nX28:%016lx X29:%016lx\\n\"\n\t      \"X30:%016lx\\n\"\n\t      \"pc:%016lx sp:%016lx\\npstate:%016lx fault_address:%016lx\\n\",\n\t      (unsigned long) uc->uc_mcontext.regs[18],\n\t      (unsigned long) uc->uc_mcontext.regs[19],\n\t      (unsigned long) uc->uc_mcontext.regs[20],\n\t      (unsigned long) uc->uc_mcontext.regs[21],\n\t      (unsigned long) uc->uc_mcontext.regs[22],\n\t      (unsigned long) uc->uc_mcontext.regs[23],\n\t      (unsigned long) uc->uc_mcontext.regs[24],\n\t      (unsigned long) uc->uc_mcontext.regs[25],\n\t      (unsigned long) uc->uc_mcontext.regs[26],\n\t      (unsigned long) uc->uc_mcontext.regs[27],\n\t      (unsigned long) uc->uc_mcontext.regs[28],\n\t      (unsigned long) uc->uc_mcontext.regs[29],\n\t      (unsigned long) uc->uc_mcontext.regs[30],\n\t      (unsigned long) uc->uc_mcontext.pc,\n\t      (unsigned long) uc->uc_mcontext.sp,\n\t      (unsigned long) uc->uc_mcontext.pstate,\n\t      (unsigned long) uc->uc_mcontext.fault_address\n\t\t      );\n\t      logStackContent((void**)uc->uc_mcontext.sp);\n    #elif defined(__arm__) /* Linux ARM */\n    serverLog(LL_WARNING,\n\t      \"\\n\"\n\t      \"R10:%016lx R9 :%016lx\\nR8 :%016lx R7 :%016lx\\n\"\n\t      \"R6 :%016lx R5 :%016lx\\nR4 :%016lx R3 :%016lx\\n\"\n\t      \"R2 :%016lx R1 :%016lx\\nR0 :%016lx EC :%016lx\\n\"\n\t      \"fp: %016lx ip:%016lx\\n\"\n\t      \"pc:%016lx sp:%016lx\\ncpsr:%016lx fault_address:%016lx\\n\",\n\t      (unsigned long) uc->uc_mcontext.arm_r10,\n\t      (unsigned long) uc->uc_mcontext.arm_r9,\n\t      (unsigned long) uc->uc_mcontext.arm_r8,\n\t      (unsigned long) uc->uc_mcontext.arm_r7,\n\t      (unsigned long) uc->uc_mcontext.arm_r6,\n\t      (unsigned long) uc->uc_mcontext.arm_r5,\n\t      (unsigned long) uc->uc_mcontext.arm_r4,\n\t      (unsigned long) uc->uc_mcontext.arm_r3,\n\t      (unsigned long) uc->uc_mcontext.arm_r2,\n\t      (unsigned long) uc->uc_mcontext.arm_r1,\n\t      (unsigned long) uc->uc_mcontext.arm_r0,\n\t      (unsigned long) uc->uc_mcontext.error_code,\n\t      (unsigned long) uc->uc_mcontext.arm_fp,\n\t      (unsigned long) uc->uc_mcontext.arm_ip,\n\t      (unsigned long) uc->uc_mcontext.arm_pc,\n\t      (unsigned long) uc->uc_mcontext.arm_sp,\n\t      (unsigned long) uc->uc_mcontext.arm_cpsr,\n\t      (unsigned long) uc->uc_mcontext.fault_address\n\t\t      );\n\t      logStackContent((void**)uc->uc_mcontext.arm_sp);\n    #else\n\tNOT_SUPPORTED();\n    #endif\n#elif defined(__FreeBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.mc_rax,\n        (unsigned long) uc->uc_mcontext.mc_rbx,\n        (unsigned long) uc->uc_mcontext.mc_rcx,\n        (unsigned long) uc->uc_mcontext.mc_rdx,\n        (unsigned long) uc->uc_mcontext.mc_rdi,\n        (unsigned long) uc->uc_mcontext.mc_rsi,\n        (unsigned long) uc->uc_mcontext.mc_rbp,\n        (unsigned long) uc->uc_mcontext.mc_rsp,\n        (unsigned long) uc->uc_mcontext.mc_r8,\n        (unsigned long) uc->uc_mcontext.mc_r9,\n        (unsigned long) uc->uc_mcontext.mc_r10,\n        (unsigned long) uc->uc_mcontext.mc_r11,\n        (unsigned long) uc->uc_mcontext.mc_r12,\n        (unsigned long) uc->uc_mcontext.mc_r13,\n        (unsigned long) uc->uc_mcontext.mc_r14,\n        (unsigned long) uc->uc_mcontext.mc_r15,\n        (unsigned long) uc->uc_mcontext.mc_rip,\n        (unsigned long) uc->uc_mcontext.mc_rflags,\n        (unsigned long) uc->uc_mcontext.mc_cs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_rsp);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.mc_eax,\n        (unsigned long) uc->uc_mcontext.mc_ebx,\n        (unsigned long) uc->uc_mcontext.mc_ebx,\n        (unsigned long) uc->uc_mcontext.mc_edx,\n        (unsigned long) uc->uc_mcontext.mc_edi,\n        (unsigned long) uc->uc_mcontext.mc_esi,\n        (unsigned long) uc->uc_mcontext.mc_ebp,\n        (unsigned long) uc->uc_mcontext.mc_esp,\n        (unsigned long) uc->uc_mcontext.mc_ss,\n        (unsigned long) uc->uc_mcontext.mc_eflags,\n        (unsigned long) uc->uc_mcontext.mc_eip,\n        (unsigned long) uc->uc_mcontext.mc_cs,\n        (unsigned long) uc->uc_mcontext.mc_es,\n        (unsigned long) uc->uc_mcontext.mc_fs,\n        (unsigned long) uc->uc_mcontext.mc_gs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_esp);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__OpenBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->sc_rax,\n        (unsigned long) uc->sc_rbx,\n        (unsigned long) uc->sc_rcx,\n        (unsigned long) uc->sc_rdx,\n        (unsigned long) uc->sc_rdi,\n        (unsigned long) uc->sc_rsi,\n        (unsigned long) uc->sc_rbp,\n        (unsigned long) uc->sc_rsp,\n        (unsigned long) uc->sc_r8,\n        (unsigned long) uc->sc_r9,\n        (unsigned long) uc->sc_r10,\n        (unsigned long) uc->sc_r11,\n        (unsigned long) uc->sc_r12,\n        (unsigned long) uc->sc_r13,\n        (unsigned long) uc->sc_r14,\n        (unsigned long) uc->sc_r15,\n        (unsigned long) uc->sc_rip,\n        (unsigned long) uc->sc_rflags,\n        (unsigned long) uc->sc_cs\n    );\n    logStackContent((void**)uc->sc_rsp);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->sc_eax,\n        (unsigned long) uc->sc_ebx,\n        (unsigned long) uc->sc_ebx,\n        (unsigned long) uc->sc_edx,\n        (unsigned long) uc->sc_edi,\n        (unsigned long) uc->sc_esi,\n        (unsigned long) uc->sc_ebp,\n        (unsigned long) uc->sc_esp,\n        (unsigned long) uc->sc_ss,\n        (unsigned long) uc->sc_eflags,\n        (unsigned long) uc->sc_eip,\n        (unsigned long) uc->sc_cs,\n        (unsigned long) uc->sc_es,\n        (unsigned long) uc->sc_fs,\n        (unsigned long) uc->sc_gs\n    );\n    logStackContent((void**)uc->sc_esp);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__NetBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RAX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RBX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RCX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RDX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RDI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RSI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RBP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RSP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R8],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R9],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R10],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R11],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R12],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R13],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R14],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R15],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RIP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RFLAGS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_CS]\n    );\n    logStackContent((void**)uc->uc_mcontext.__gregs[_REG_RSP]);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EAX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EBX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EDX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EDI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ESI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EBP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ESP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_SS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EFLAGS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EIP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_CS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ES],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_FS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_GS]\n    );\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__DragonFly__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.mc_rax,\n        (unsigned long) uc->uc_mcontext.mc_rbx,\n        (unsigned long) uc->uc_mcontext.mc_rcx,\n        (unsigned long) uc->uc_mcontext.mc_rdx,\n        (unsigned long) uc->uc_mcontext.mc_rdi,\n        (unsigned long) uc->uc_mcontext.mc_rsi,\n        (unsigned long) uc->uc_mcontext.mc_rbp,\n        (unsigned long) uc->uc_mcontext.mc_rsp,\n        (unsigned long) uc->uc_mcontext.mc_r8,\n        (unsigned long) uc->uc_mcontext.mc_r9,\n        (unsigned long) uc->uc_mcontext.mc_r10,\n        (unsigned long) uc->uc_mcontext.mc_r11,\n        (unsigned long) uc->uc_mcontext.mc_r12,\n        (unsigned long) uc->uc_mcontext.mc_r13,\n        (unsigned long) uc->uc_mcontext.mc_r14,\n        (unsigned long) uc->uc_mcontext.mc_r15,\n        (unsigned long) uc->uc_mcontext.mc_rip,\n        (unsigned long) uc->uc_mcontext.mc_rflags,\n        (unsigned long) uc->uc_mcontext.mc_cs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_rsp);\n#else\n    NOT_SUPPORTED();\n#endif\n#undef NOT_SUPPORTED\n}\n\n#endif /* HAVE_BACKTRACE */\n\n/* Return a file descriptor to write directly to the Redis log with the\n * write(2) syscall, that can be used in critical sections of the code\n * where the rest of Redis can't be trusted (for example during the memory\n * test) or when an API call requires a raw fd.\n *\n * Close it with closeDirectLogFiledes(). */\nint openDirectLogFiledes(void) {\n    int log_to_stdout = server.logfile[0] == '\\0';\n    int fd = log_to_stdout ?\n        STDOUT_FILENO :\n        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    return fd;\n}\n\n/* Used to close what closeDirectLogFiledes() returns. */\nvoid closeDirectLogFiledes(int fd) {\n    int log_to_stdout = server.logfile[0] == '\\0';\n    if (!log_to_stdout) close(fd);\n}\n\n#ifdef HAVE_BACKTRACE\n\n/* Logs the stack trace using the backtrace() call. This function is designed\n * to be called from signal handlers safely.\n * The eip argument is optional (can take NULL).\n * The uplevel argument indicates how many of the calling functions to skip.\n */\nvoid logStackTrace(void *eip, int uplevel) {\n    void *trace[100];\n    int trace_size = 0, fd = openDirectLogFiledes();\n    char *msg;\n    uplevel++; /* skip this function */\n\n    if (fd == -1) return; /* If we can't log there is anything to do. */\n\n    /* Get the stack trace first! */\n    trace_size = backtrace(trace, 100);\n\n    msg = \"\\n------ STACK TRACE ------\\n\";\n    if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n\n    if (eip) {\n        /* Write EIP to the log file*/\n        msg = \"EIP:\\n\";\n        if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n        backtrace_symbols_fd(&eip, 1, fd);\n    }\n\n    /* Write symbols to log file */\n    msg = \"\\nBacktrace:\\n\";\n    if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n    backtrace_symbols_fd(trace+uplevel, trace_size-uplevel, fd);\n\n    /* Cleanup */\n    closeDirectLogFiledes(fd);\n}\n\n#endif /* HAVE_BACKTRACE */\n\n/* Log global server info */\nvoid logServerInfo(void) {\n    sds infostring, clients;\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ INFO OUTPUT ------\\n\");\n    int all = 0, everything = 0;\n    robj *argv[1];\n    argv[0] = createStringObject(\"all\", strlen(\"all\"));\n    dict *section_dict = genInfoSectionDict(argv, 1, NULL, &all, &everything);\n    infostring = genRedisInfoString(section_dict, all, everything);\n    serverLogRaw(LL_WARNING|LL_RAW, infostring);\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CLIENT LIST OUTPUT ------\\n\");\n    clients = getAllClientsInfoString(-1);\n    serverLogRaw(LL_WARNING|LL_RAW, clients);\n    sdsfree(infostring);\n    sdsfree(clients);\n    releaseInfoSectionDict(section_dict);\n    decrRefCount(argv[0]);\n}\n\n/* Log certain config values, which can be used for debuggin */\nvoid logConfigDebugInfo(void) {\n    sds configstring;\n    configstring = getConfigDebugInfo();\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CONFIG DEBUG OUTPUT ------\\n\");\n    serverLogRaw(LL_WARNING|LL_RAW, configstring);\n    sdsfree(configstring);\n}\n\n/* Log modules info. Something we wanna do last since we fear it may crash. */\nvoid logModulesInfo(void) {\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ MODULES INFO OUTPUT ------\\n\");\n    sds infostring = modulesCollectInfo(sdsempty(), NULL, 1, 0);\n    serverLogRaw(LL_WARNING|LL_RAW, infostring);\n    sdsfree(infostring);\n}\n\n/* Log information about the \"current\" client, that is, the client that is\n * currently being served by Redis. May be NULL if Redis is not serving a\n * client right now. */\nvoid logCurrentClient(void) {\n    if (server.current_client == NULL) return;\n\n    client *cc = server.current_client;\n    sds client;\n    int j;\n\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CURRENT CLIENT INFO ------\\n\");\n    client = catClientInfoString(sdsempty(),cc);\n    serverLog(LL_WARNING|LL_RAW,\"%s\\n\", client);\n    sdsfree(client);\n    for (j = 0; j < cc->argc; j++) {\n        robj *decoded;\n        decoded = getDecodedObject(cc->argv[j]);\n        sds repr = sdscatrepr(sdsempty(),decoded->ptr, min(sdslen(decoded->ptr), 128));\n        serverLog(LL_WARNING|LL_RAW,\"argv[%d]: '%s'\\n\", j, (char*)repr);\n        sdsfree(repr);\n        decrRefCount(decoded);\n    }\n    /* Check if the first argument, usually a key, is found inside the\n     * selected DB, and if so print info about the associated object. */\n    if (cc->argc > 1) {\n        robj *val, *key;\n        dictEntry *de;\n\n        key = getDecodedObject(cc->argv[1]);\n        de = dictFind(cc->db->dict, key->ptr);\n        if (de) {\n            val = dictGetVal(de);\n            serverLog(LL_WARNING,\"key '%s' found in DB containing the following object:\", (char*)key->ptr);\n            serverLogObjectDebugInfo(val);\n        }\n        decrRefCount(key);\n    }\n}\n\n#if defined(HAVE_PROC_MAPS)\n\n#define MEMTEST_MAX_REGIONS 128\n\n/* A non destructive memory test executed during segfault. */\nint memtest_test_linux_anonymous_maps(void) {\n    FILE *fp;\n    char line[1024];\n    char logbuf[1024];\n    size_t start_addr, end_addr, size;\n    size_t start_vect[MEMTEST_MAX_REGIONS];\n    size_t size_vect[MEMTEST_MAX_REGIONS];\n    int regions = 0, j;\n\n    int fd = openDirectLogFiledes();\n    if (!fd) return 0;\n\n    fp = fopen(\"/proc/self/maps\",\"r\");\n    if (!fp) {\n        closeDirectLogFiledes(fd);\n        return 0;\n    }\n    while(fgets(line,sizeof(line),fp) != NULL) {\n        char *start, *end, *p = line;\n\n        start = p;\n        p = strchr(p,'-');\n        if (!p) continue;\n        *p++ = '\\0';\n        end = p;\n        p = strchr(p,' ');\n        if (!p) continue;\n        *p++ = '\\0';\n        if (strstr(p,\"stack\") ||\n            strstr(p,\"vdso\") ||\n            strstr(p,\"vsyscall\")) continue;\n        if (!strstr(p,\"00:00\")) continue;\n        if (!strstr(p,\"rw\")) continue;\n\n        start_addr = strtoul(start,NULL,16);\n        end_addr = strtoul(end,NULL,16);\n        size = end_addr-start_addr;\n\n        start_vect[regions] = start_addr;\n        size_vect[regions] = size;\n        snprintf(logbuf,sizeof(logbuf),\n            \"*** Preparing to test memory region %lx (%lu bytes)\\n\",\n                (unsigned long) start_vect[regions],\n                (unsigned long) size_vect[regions]);\n        if (write(fd,logbuf,strlen(logbuf)) == -1) { /* Nothing to do. */ }\n        regions++;\n    }\n\n    int errors = 0;\n    for (j = 0; j < regions; j++) {\n        if (write(fd,\".\",1) == -1) { /* Nothing to do. */ }\n        errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);\n        if (write(fd, errors ? \"E\" : \"O\",1) == -1) { /* Nothing to do. */ }\n    }\n    if (write(fd,\"\\n\",1) == -1) { /* Nothing to do. */ }\n\n    /* NOTE: It is very important to close the file descriptor only now\n     * because closing it before may result into unmapping of some memory\n     * region that we are testing. */\n    fclose(fp);\n    closeDirectLogFiledes(fd);\n    return errors;\n}\n#endif /* HAVE_PROC_MAPS */\n\nstatic void killMainThread(void) {\n    int err;\n    if (pthread_self() != server.main_thread_id && pthread_cancel(server.main_thread_id) == 0) {\n        if ((err = pthread_join(server.main_thread_id,NULL)) != 0) {\n            serverLog(LL_WARNING, \"main thread can not be joined: %s\", strerror(err));\n        } else {\n            serverLog(LL_WARNING, \"main thread terminated\");\n        }\n    }\n}\n\n/* Kill the running threads (other than current) in an unclean way. This function\n * should be used only when it's critical to stop the threads for some reason.\n * Currently Redis does this only on crash (for instance on SIGSEGV) in order\n * to perform a fast memory check without other threads messing with memory. */\nvoid killThreads(void) {\n    killMainThread();\n    bioKillThreads();\n    killIOThreads();\n}\n\nvoid doFastMemoryTest(void) {\n#if defined(HAVE_PROC_MAPS)\n    if (server.memcheck_enabled) {\n        /* Test memory */\n        serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ FAST MEMORY TEST ------\\n\");\n        killThreads();\n        if (memtest_test_linux_anonymous_maps()) {\n            serverLogRaw(LL_WARNING|LL_RAW,\n                \"!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\\n\");\n        } else {\n            serverLogRaw(LL_WARNING|LL_RAW,\n                \"Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\\n\");\n        }\n    }\n#endif /* HAVE_PROC_MAPS */\n}\n\n/* Scans the (assumed) x86 code starting at addr, for a max of `len`\n * bytes, searching for E8 (callq) opcodes, and dumping the symbols\n * and the call offset if they appear to be valid. */\nvoid dumpX86Calls(void *addr, size_t len) {\n    size_t j;\n    unsigned char *p = addr;\n    Dl_info info;\n    /* Hash table to best-effort avoid printing the same symbol\n     * multiple times. */\n    unsigned long ht[256] = {0};\n\n    if (len < 5) return;\n    for (j = 0; j < len-4; j++) {\n        if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */\n        unsigned long target = (unsigned long)addr+j+5;\n        uint32_t tmp;\n        memcpy(&tmp, p+j+1, sizeof(tmp));\n        target += tmp;\n        if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {\n            if (ht[target&0xff] != target) {\n                printf(\"Function at 0x%lx is %s\\n\",target,info.dli_sname);\n                ht[target&0xff] = target;\n            }\n            j += 4; /* Skip the 32 bit immediate. */\n        }\n    }\n}\n\nvoid dumpCodeAroundEIP(void *eip) {\n    Dl_info info;\n    if (dladdr(eip, &info) != 0) {\n        serverLog(LL_WARNING|LL_RAW,\n            \"\\n------ DUMPING CODE AROUND EIP ------\\n\"\n            \"Symbol: %s (base: %p)\\n\"\n            \"Module: %s (base %p)\\n\"\n            \"$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\\n\"\n            \"$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\\n\"\n            \"------\\n\",\n            info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,\n            info.dli_saddr);\n        size_t len = (long)eip - (long)info.dli_saddr;\n        unsigned long sz = sysconf(_SC_PAGESIZE);\n        if (len < 1<<13) { /* we don't have functions over 8k (verified) */\n            /* Find the address of the next page, which is our \"safety\"\n             * limit when dumping. Then try to dump just 128 bytes more\n             * than EIP if there is room, or stop sooner. */\n            void *base = (void *)info.dli_saddr;\n            unsigned long next = ((unsigned long)eip + sz) & ~(sz-1);\n            unsigned long end = (unsigned long)eip + 128;\n            if (end > next) end = next;\n            len = end - (unsigned long)base;\n            serverLogHexDump(LL_WARNING, \"dump of function\",\n                base, len);\n            dumpX86Calls(base, len);\n        }\n    }\n}\n\nvoid sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    logStackTrace(getMcontextEip(uc), 1);\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}\n\nvoid printCrashReport(void) {\n    /* Log INFO and CLIENT LIST */\n    logServerInfo();\n\n    /* Log the current client */\n    logCurrentClient();\n\n    /* Log modules info. Something we wanna do last since we fear it may crash. */\n    logModulesInfo();\n\n    /* Log debug config information, which are some values\n     * which may be useful for debugging crashes. */\n    logConfigDebugInfo();\n\n    /* Run memory test in case the crash was triggered by memory corruption. */\n    doFastMemoryTest();\n}\n\nvoid bugReportEnd(int killViaSignal, int sig) {\n    struct sigaction act;\n\n    serverLogRaw(LL_WARNING|LL_RAW,\n\"\\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\\n\\n\"\n\"       Please report the crash by opening an issue on github:\\n\\n\"\n\"           http://github.com/redis/redis/issues\\n\\n\"\n\"  If a Redis module was involved, please open in the module's repo instead.\\n\\n\"\n\"  Suspect RAM error? Use redis-server --test-memory to verify it.\\n\\n\"\n\"  Some other issues could be detected by redis-server --check-system\\n\"\n);\n\n    /* free(messages); Don't call free() with possibly corrupted memory. */\n    if (server.daemonize && server.supervised == 0 && server.pidfile) unlink(server.pidfile);\n\n    if (!killViaSignal) {\n        /* To avoid issues with valgrind, we may wanna exit rahter than generate a signal */\n        if (server.use_exit_on_panic) {\n             /* Using _exit to bypass false leak reports by gcc ASAN */\n             fflush(stdout);\n            _exit(1);\n        }\n        abort();\n    }\n\n    /* Make sure we exit with the right signal at the end. So for instance\n     * the core will be dumped if enabled. */\n    sigemptyset (&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction (sig, &act, NULL);\n    kill(getpid(),sig);\n}\n\n/* ==================== Logging functions for debugging ===================== */\n\nvoid serverLogHexDump(int level, char *descr, void *value, size_t len) {\n    char buf[65], *b;\n    unsigned char *v = value;\n    char charset[] = \"0123456789abcdef\";\n\n    serverLog(level,\"%s (hexdump of %zu bytes):\", descr, len);\n    b = buf;\n    while(len) {\n        b[0] = charset[(*v)>>4];\n        b[1] = charset[(*v)&0xf];\n        b[2] = '\\0';\n        b += 2;\n        len--;\n        v++;\n        if (b-buf == 64 || len == 0) {\n            serverLogRaw(level|LL_RAW,buf);\n            b = buf;\n        }\n    }\n    serverLogRaw(level|LL_RAW,\"\\n\");\n}\n\n/* =========================== Software Watchdog ============================ */\n#include <sys/time.h>\n\nvoid watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}\n\n/* Schedule a SIGALRM delivery after the specified period in milliseconds.\n * If a timer is already scheduled, this function will re-schedule it to the\n * specified time. If period is 0 the current timer is disabled. */\nvoid watchdogScheduleSignal(int period) {\n    struct itimerval it;\n\n    /* Will stop the timer if period is 0. */\n    it.it_value.tv_sec = period/1000;\n    it.it_value.tv_usec = (period%1000)*1000;\n    /* Don't automatically restart. */\n    it.it_interval.tv_sec = 0;\n    it.it_interval.tv_usec = 0;\n    setitimer(ITIMER_REAL, &it, NULL);\n}\nvoid applyWatchdogPeriod() {\n    struct sigaction act;\n\n    /* Disable watchdog when period is 0 */\n    if (server.watchdog_period == 0) {\n        watchdogScheduleSignal(0); /* Stop the current timer. */\n\n        /* Set the signal handler to SIG_IGN, this will also remove pending\n         * signals from the queue. */\n        sigemptyset(&act.sa_mask);\n        act.sa_flags = 0;\n        act.sa_handler = SIG_IGN;\n        sigaction(SIGALRM, &act, NULL);\n    } else {\n        /* Setup the signal handler. */\n        sigemptyset(&act.sa_mask);\n        act.sa_flags = SA_SIGINFO;\n        act.sa_sigaction = watchdogSignalHandler;\n        sigaction(SIGALRM, &act, NULL);\n\n        /* If the configured period is smaller than twice the timer period, it is\n         * too short for the software watchdog to work reliably. Fix it now\n         * if needed. */\n        int min_period = (1000/server.hz)*2;\n        if (server.watchdog_period < min_period) server.watchdog_period = min_period;\n        watchdogScheduleSignal(server.watchdog_period); /* Adjust the current timer. */\n    }\n}\n\n/* Positive input is sleep time in microseconds. Negative input is fractions\n * of microseconds, i.e. -10 means 100 nanoseconds. */\nvoid debugDelay(int usec) {\n    /* Since even the shortest sleep results in context switch and system call,\n     * the way we achieve short sleeps is by statistically sleeping less often. */\n    if (usec < 0) usec = (rand() % -usec) == 0 ? 1: 0;\n    if (usec) usleep(usec);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2020, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2020, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"util.h\"\n#include \"sha1.h\"   /* SHA1 is used for DEBUG DIGEST */\n#include \"crc64.h\"\n#include \"bio.h\"\n#include \"quicklist.h\"\n\n#include <arpa/inet.h>\n#include <signal.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#ifdef HAVE_BACKTRACE\n#include <execinfo.h>\n#ifndef __OpenBSD__\n#include <ucontext.h>\n#else\ntypedef ucontext_t sigcontext_t;\n#endif\n#endif /* HAVE_BACKTRACE */\n\n#ifdef __CYGWIN__\n#ifndef SA_ONSTACK\n#define SA_ONSTACK 0x08000000\n#endif\n#endif\n\n#if defined(__APPLE__) && defined(__arm64__)\n#include <mach/mach.h>\n#endif\n\n/* Globals */\nstatic int bug_report_start = 0; /* True if bug report header was already logged. */\nstatic pthread_mutex_t bug_report_start_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n/* Forward declarations */\nvoid bugReportStart(void);\nvoid printCrashReport(void);\nvoid bugReportEnd(int killViaSignal, int sig);\nvoid logStackTrace(void *eip, int uplevel);\n\n/* ================================= Debugging ============================== */\n\n/* Compute the sha1 of string at 's' with 'len' bytes long.\n * The SHA1 is then xored against the string pointed by digest.\n * Since xor is commutative, this operation is used in order to\n * \"add\" digests relative to unordered elements.\n *\n * So digest(a,b,c,d) will be the same of digest(b,a,c,d) */\nvoid xorDigest(unsigned char *digest, const void *ptr, size_t len) {\n    SHA1_CTX ctx;\n    unsigned char hash[20];\n    int j;\n\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,ptr,len);\n    SHA1Final(hash,&ctx);\n\n    for (j = 0; j < 20; j++)\n        digest[j] ^= hash[j];\n}\n\nvoid xorStringObjectDigest(unsigned char *digest, robj *o) {\n    o = getDecodedObject(o);\n    xorDigest(digest,o->ptr,sdslen(o->ptr));\n    decrRefCount(o);\n}\n\n/* This function instead of just computing the SHA1 and xoring it\n * against digest, also perform the digest of \"digest\" itself and\n * replace the old value with the new one.\n *\n * So the final digest will be:\n *\n * digest = SHA1(digest xor SHA1(data))\n *\n * This function is used every time we want to preserve the order so\n * that digest(a,b,c,d) will be different than digest(b,c,d,a)\n *\n * Also note that mixdigest(\"foo\") followed by mixdigest(\"bar\")\n * will lead to a different digest compared to \"fo\", \"obar\".\n */\nvoid mixDigest(unsigned char *digest, const void *ptr, size_t len) {\n    SHA1_CTX ctx;\n\n    xorDigest(digest,ptr,len);\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,digest,20);\n    SHA1Final(digest,&ctx);\n}\n\nvoid mixStringObjectDigest(unsigned char *digest, robj *o) {\n    o = getDecodedObject(o);\n    mixDigest(digest,o->ptr,sdslen(o->ptr));\n    decrRefCount(o);\n}\n\n/* This function computes the digest of a data structure stored in the\n * object 'o'. It is the core of the DEBUG DIGEST command: when taking the\n * digest of a whole dataset, we take the digest of the key and the value\n * pair, and xor all those together.\n *\n * Note that this function does not reset the initial 'digest' passed, it\n * will continue mixing this object digest to anything that was already\n * present. */\nvoid xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {\n    uint32_t aux = htonl(o->type);\n    mixDigest(digest,&aux,sizeof(aux));\n    long long expiretime = getExpire(db,keyobj);\n    char buf[128];\n\n    /* Save the key and associated value */\n    if (o->type == OBJ_STRING) {\n        mixStringObjectDigest(digest,o);\n    } else if (o->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            robj *eleobj = listTypeGet(&entry);\n            mixStringObjectDigest(digest,eleobj);\n            decrRefCount(eleobj);\n        }\n        listTypeReleaseIterator(li);\n    } else if (o->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(o);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            xorDigest(digest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n        }\n        setTypeReleaseIterator(si);\n    } else if (o->type == OBJ_ZSET) {\n        unsigned char eledigest[20];\n\n        if (o->encoding == OBJ_ENCODING_LISTPACK) {\n            unsigned char *zl = o->ptr;\n            unsigned char *eptr, *sptr;\n            unsigned char *vstr;\n            unsigned int vlen;\n            long long vll;\n            double score;\n\n            eptr = lpSeek(zl,0);\n            serverAssert(eptr != NULL);\n            sptr = lpNext(zl,eptr);\n            serverAssert(sptr != NULL);\n\n            while (eptr != NULL) {\n                vstr = lpGetValue(eptr,&vlen,&vll);\n                score = zzlGetScore(sptr);\n\n                memset(eledigest,0,20);\n                if (vstr != NULL) {\n                    mixDigest(eledigest,vstr,vlen);\n                } else {\n                    ll2string(buf,sizeof(buf),vll);\n                    mixDigest(eledigest,buf,strlen(buf));\n                }\n\n                snprintf(buf,sizeof(buf),\"%.17g\",score);\n                mixDigest(eledigest,buf,strlen(buf));\n                xorDigest(digest,eledigest,20);\n                zzlNext(zl,&eptr,&sptr);\n            }\n        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {\n            zset *zs = o->ptr;\n            dictIterator *di = dictGetIterator(zs->dict);\n            dictEntry *de;\n\n            while((de = dictNext(di)) != NULL) {\n                sds sdsele = dictGetKey(de);\n                double *score = dictGetVal(de);\n\n                snprintf(buf,sizeof(buf),\"%.17g\",*score);\n                memset(eledigest,0,20);\n                mixDigest(eledigest,sdsele,sdslen(sdsele));\n                mixDigest(eledigest,buf,strlen(buf));\n                xorDigest(digest,eledigest,20);\n            }\n            dictReleaseIterator(di);\n        } else {\n            serverPanic(\"Unknown sorted set encoding\");\n        }\n    } else if (o->type == OBJ_HASH) {\n        hashTypeIterator *hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            unsigned char eledigest[20];\n            sds sdsele;\n\n            memset(eledigest,0,20);\n            sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            mixDigest(eledigest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n            sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            mixDigest(eledigest,sdsele,sdslen(sdsele));\n            sdsfree(sdsele);\n            xorDigest(digest,eledigest,20);\n        }\n        hashTypeReleaseIterator(hi);\n    } else if (o->type == OBJ_STREAM) {\n        streamIterator si;\n        streamIteratorStart(&si,o->ptr,NULL,NULL,0);\n        streamID id;\n        int64_t numfields;\n\n        while(streamIteratorGetID(&si,&id,&numfields)) {\n            sds itemid = sdscatfmt(sdsempty(),\"%U.%U\",id.ms,id.seq);\n            mixDigest(digest,itemid,sdslen(itemid));\n            sdsfree(itemid);\n\n            while(numfields--) {\n                unsigned char *field, *value;\n                int64_t field_len, value_len;\n                streamIteratorGetField(&si,&field,&value,\n                                           &field_len,&value_len);\n                mixDigest(digest,field,field_len);\n                mixDigest(digest,value,value_len);\n            }\n        }\n        streamIteratorStop(&si);\n    } else if (o->type == OBJ_MODULE) {\n        RedisModuleDigest md = {{0},{0},keyobj,db->id};\n        moduleValue *mv = o->ptr;\n        moduleType *mt = mv->type;\n        moduleInitDigestContext(md);\n        if (mt->digest) {\n            mt->digest(&md,mv->value);\n            xorDigest(digest,md.x,sizeof(md.x));\n        }\n    } else {\n        serverPanic(\"Unknown object type\");\n    }\n    /* If the key has an expire, add it to the mix */\n    if (expiretime != -1) xorDigest(digest,\"!!expire!!\",10);\n}\n\n/* Compute the dataset digest. Since keys, sets elements, hashes elements\n * are not ordered, we use a trick: every aggregate digest is the xor\n * of the digests of their elements. This way the order will not change\n * the result. For list instead we use a feedback entering the output digest\n * as input in order to ensure that a different ordered list will result in\n * a different digest. */\nvoid computeDatasetDigest(unsigned char *final) {\n    unsigned char digest[20];\n    dictIterator *di = NULL;\n    dictEntry *de;\n    int j;\n    uint32_t aux;\n\n    memset(final,0,20); /* Start with a clean result */\n\n    for (j = 0; j < server.dbnum; j++) {\n        redisDb *db = server.db+j;\n\n        if (dictSize(db->dict) == 0) continue;\n        di = dictGetSafeIterator(db->dict);\n\n        /* hash the DB id, so the same dataset moved in a different\n         * DB will lead to a different digest */\n        aux = htonl(j);\n        mixDigest(final,&aux,sizeof(aux));\n\n        /* Iterate this DB writing every entry */\n        while((de = dictNext(di)) != NULL) {\n            sds key;\n            robj *keyobj, *o;\n\n            memset(digest,0,20); /* This key-val digest */\n            key = dictGetKey(de);\n            keyobj = createStringObject(key,sdslen(key));\n\n            mixDigest(digest,key,sdslen(key));\n\n            o = dictGetVal(de);\n            xorObjectDigest(db,keyobj,digest,o);\n\n            /* We can finally xor the key-val digest to the final digest */\n            xorDigest(final,digest,20);\n            decrRefCount(keyobj);\n        }\n        dictReleaseIterator(di);\n    }\n}\n\n#ifdef USE_JEMALLOC\nvoid mallctl_int(client *c, robj **argv, int argc) {\n    int ret;\n    /* start with the biggest size (int64), and if that fails, try smaller sizes (int32, bool) */\n    int64_t old = 0, val;\n    if (argc > 1) {\n        long long ll;\n        if (getLongLongFromObjectOrReply(c, argv[1], &ll, NULL) != C_OK)\n            return;\n        val = ll;\n    }\n    size_t sz = sizeof(old);\n    while (sz > 0) {\n        if ((ret=je_mallctl(argv[0]->ptr, &old, &sz, argc > 1? &val: NULL, argc > 1?sz: 0))) {\n            if (ret == EPERM && argc > 1) {\n                /* if this option is write only, try just writing to it. */\n                if (!(ret=je_mallctl(argv[0]->ptr, NULL, 0, &val, sz))) {\n                    addReply(c, shared.ok);\n                    return;\n                }\n            }\n            if (ret==EINVAL) {\n                /* size might be wrong, try a smaller one */\n                sz /= 2;\n#if BYTE_ORDER == BIG_ENDIAN\n                val <<= 8*sz;\n#endif\n                continue;\n            }\n            addReplyErrorFormat(c,\"%s\", strerror(ret));\n            return;\n        } else {\n#if BYTE_ORDER == BIG_ENDIAN\n            old >>= 64 - 8*sz;\n#endif\n            addReplyLongLong(c, old);\n            return;\n        }\n    }\n    addReplyErrorFormat(c,\"%s\", strerror(EINVAL));\n}\n\nvoid mallctl_string(client *c, robj **argv, int argc) {\n    int rret, wret;\n    char *old;\n    size_t sz = sizeof(old);\n    /* for strings, it seems we need to first get the old value, before overriding it. */\n    if ((rret=je_mallctl(argv[0]->ptr, &old, &sz, NULL, 0))) {\n        /* return error unless this option is write only. */\n        if (!(rret == EPERM && argc > 1)) {\n            addReplyErrorFormat(c,\"%s\", strerror(rret));\n            return;\n        }\n    }\n    if(argc > 1) {\n        char *val = argv[1]->ptr;\n        char **valref = &val;\n        if ((!strcmp(val,\"VOID\")))\n            valref = NULL, sz = 0;\n        wret = je_mallctl(argv[0]->ptr, NULL, 0, valref, sz);\n    }\n    if (!rret)\n        addReplyBulkCString(c, old);\n    else if (wret)\n        addReplyErrorFormat(c,\"%s\", strerror(wret));\n    else\n        addReply(c, shared.ok);\n}\n#endif\n\nvoid debugCommand(client *c) {\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"AOF-FLUSH-SLEEP <microsec>\",\n\"    Server will sleep before flushing the AOF, this is used for testing.\",\n\"ASSERT\",\n\"    Crash by assertion failed.\",\n\"CHANGE-REPL-ID\",\n\"    Change the replication IDs of the instance.\",\n\"    Dangerous: should be used only for testing the replication subsystem.\",\n\"CONFIG-REWRITE-FORCE-ALL\",\n\"    Like CONFIG REWRITE but writes all configuration options, including\",\n\"    keywords not listed in original configuration file or default values.\",\n\"CRASH-AND-RECOVER [<milliseconds>]\",\n\"    Hard crash and restart after a <milliseconds> delay (default 0).\",\n\"DIGEST\",\n\"    Output a hex signature representing the current DB content.\",\n\"DIGEST-VALUE <key> [<key> ...]\",\n\"    Output a hex signature of the values of all the specified keys.\",\n\"ERROR <string>\",\n\"    Return a Redis protocol error with <string> as message. Useful for clients\",\n\"    unit tests to simulate Redis errors.\",\n\"LEAK <string>\",\n\"    Create a memory leak of the input string.\",\n\"LOG <message>\",\n\"    Write <message> to the server log.\",\n\"HTSTATS <dbid>\",\n\"    Return hash table statistics of the specified Redis database.\",\n\"HTSTATS-KEY <key>\",\n\"    Like HTSTATS but for the hash table stored at <key>'s value.\",\n\"LOADAOF\",\n\"    Flush the AOF buffers on disk and reload the AOF in memory.\",\n\"REPLICATE <string>\",\n\"    Replicates the provided string to replicas, allowing data divergence.\",\n#ifdef USE_JEMALLOC\n\"MALLCTL <key> [<val>]\",\n\"    Get or set a malloc tuning integer.\",\n\"MALLCTL-STR <key> [<val>]\",\n\"    Get or set a malloc tuning string.\",\n#endif\n\"OBJECT <key>\",\n\"    Show low level info about `key` and associated value.\",\n\"DROP-CLUSTER-PACKET-FILTER <packet-type>\",\n\"    Drop all packets that match the filtered type. Set to -1 allow all packets.\",\n\"OOM\",\n\"    Crash the server simulating an out-of-memory error.\",\n\"PANIC\",\n\"    Crash the server simulating a panic.\",\n\"POPULATE <count> [<prefix>] [<size>]\",\n\"    Create <count> string keys named key:<num>. If <prefix> is specified then\",\n\"    it is used instead of the 'key' prefix. These are not propagated to\",\n\"    replicas. Cluster slots are not respected so keys not belonging to the\",\n\"    current node can be created in cluster mode.\",\n\"PROTOCOL <type>\",\n\"    Reply with a test value of the specified type. <type> can be: string,\",\n\"    integer, double, bignum, null, array, set, map, attrib, push, verbatim,\",\n\"    true, false.\",\n\"RELOAD [option ...]\",\n\"    Save the RDB on disk and reload it back to memory. Valid <option> values:\",\n\"    * MERGE: conflicting keys will be loaded from RDB.\",\n\"    * NOFLUSH: the existing database will not be removed before load, but\",\n\"      conflicting keys will generate an exception and kill the server.\",\n\"    * NOSAVE: the database will be loaded from an existing RDB file.\",\n\"    Examples:\",\n\"    * DEBUG RELOAD: verify that the server is able to persist, flush and reload\",\n\"      the database.\",\n\"    * DEBUG RELOAD NOSAVE: replace the current database with the contents of an\",\n\"      existing RDB file.\",\n\"    * DEBUG RELOAD NOSAVE NOFLUSH MERGE: add the contents of an existing RDB\",\n\"      file to the database.\",\n\"RESTART [<milliseconds>]\",\n\"    Graceful restart: save config, db, restart after a <milliseconds> delay (default 0).\",\n\"SDSLEN <key>\",\n\"    Show low level SDS string info representing `key` and value.\",\n\"SEGFAULT\",\n\"    Crash the server with sigsegv.\",\n\"SET-ACTIVE-EXPIRE <0|1>\",\n\"    Setting it to 0 disables expiring keys in background when they are not\",\n\"    accessed (otherwise the Redis behavior). Setting it to 1 reenables back the\",\n\"    default.\",\n\"QUICKLIST-PACKED-THRESHOLD <size>\",\n\"    Sets the threshold for elements to be inserted as plain vs packed nodes\",\n\"    Default value is 1GB, allows values up to 4GB. Setting to 0 restores to default.\",\n\"SET-SKIP-CHECKSUM-VALIDATION <0|1>\",\n\"    Enables or disables checksum checks for RDB files and RESTORE's payload.\",\n\"SLEEP <seconds>\",\n\"    Stop the server for <seconds>. Decimals allowed.\",\n\"STRINGMATCH-TEST\",\n\"    Run a fuzz tester against the stringmatchlen() function.\",\n\"STRUCTSIZE\",\n\"    Return the size of different Redis core C structures.\",\n\"LISTPACK <key>\",\n\"    Show low level info about the listpack encoding of <key>.\",\n\"QUICKLIST <key> [<0|1>]\",\n\"    Show low level info about the quicklist encoding of <key>.\",\n\"    The optional argument (0 by default) sets the level of detail\",\n\"CLIENT-EVICTION\",\n\"    Show low level client eviction pools info (maxmemory-clients).\",\n\"PAUSE-CRON <0|1>\",\n\"    Stop periodic cron job processing.\",\n\"REPLYBUFFER PEAK-RESET-TIME <NEVER||RESET|time>\",\n\"    Sets the time (in milliseconds) to wait between client reply buffer peak resets.\",\n\"    In case NEVER is provided the last observed peak will never be reset\",\n\"    In case RESET is provided the peak reset time will be restored to the default value\",\n\"REPLYBUFFER RESIZING <0|1>\",\n\"    Enable or disable the reply buffer resize cron job\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"segfault\")) {\n        /* Compiler gives warnings about writing to a random address\n         * e.g \"*((char*)-1) = 'x';\". As a workaround, we map a read-only area\n         * and try to write there to trigger segmentation fault. */\n        char* p = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);\n        *p = 'x';\n    } else if (!strcasecmp(c->argv[1]->ptr,\"panic\")) {\n        serverPanic(\"DEBUG PANIC called at Unix time %lld\", (long long)time(NULL));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"restart\") ||\n               !strcasecmp(c->argv[1]->ptr,\"crash-and-recover\"))\n    {\n        long long delay = 0;\n        if (c->argc >= 3) {\n            if (getLongLongFromObjectOrReply(c, c->argv[2], &delay, NULL)\n                != C_OK) return;\n            if (delay < 0) delay = 0;\n        }\n        int flags = !strcasecmp(c->argv[1]->ptr,\"restart\") ?\n            (RESTART_SERVER_GRACEFULLY|RESTART_SERVER_CONFIG_REWRITE) :\n             RESTART_SERVER_NONE;\n        restartServer(flags,delay);\n        addReplyError(c,\"failed to restart the server. Check server logs.\");\n    } else if (!strcasecmp(c->argv[1]->ptr,\"oom\")) {\n        void *ptr = zmalloc(ULONG_MAX); /* Should trigger an out of memory. */\n        zfree(ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"assert\")) {\n        serverAssertWithInfo(c,c->argv[0],1 == 2);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"log\") && c->argc == 3) {\n        serverLog(LL_WARNING, \"DEBUG LOG: %s\", (char*)c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"leak\") && c->argc == 3) {\n        sdsdup(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"reload\")) {\n        int flush = 1, save = 1;\n        int flags = RDBFLAGS_NONE;\n\n        /* Parse the additional options that modify the RELOAD\n         * behavior. */\n        for (int j = 2; j < c->argc; j++) {\n            char *opt = c->argv[j]->ptr;\n            if (!strcasecmp(opt,\"MERGE\")) {\n                flags |= RDBFLAGS_ALLOW_DUP;\n            } else if (!strcasecmp(opt,\"NOFLUSH\")) {\n                flush = 0;\n            } else if (!strcasecmp(opt,\"NOSAVE\")) {\n                save = 0;\n            } else {\n                addReplyError(c,\"DEBUG RELOAD only supports the \"\n                                \"MERGE, NOFLUSH and NOSAVE options.\");\n                return;\n            }\n        }\n\n        /* The default behavior is to save the RDB file before loading\n         * it back. */\n        if (save) {\n            rdbSaveInfo rsi, *rsiptr;\n            rsiptr = rdbPopulateSaveInfo(&rsi);\n            if (rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr) != C_OK) {\n                addReplyErrorObject(c,shared.err);\n                return;\n            }\n        }\n\n        /* The default behavior is to remove the current dataset from\n         * memory before loading the RDB file, however when MERGE is\n         * used together with NOFLUSH, we are able to merge two datasets. */\n        if (flush) emptyData(-1,EMPTYDB_NO_FLAGS,NULL);\n\n        protectClient(c);\n        int ret = rdbLoad(server.rdb_filename,NULL,flags);\n        unprotectClient(c);\n        if (ret != RDB_OK) {\n            addReplyError(c,\"Error trying to load the RDB dump, check server logs.\");\n            return;\n        }\n        serverLog(LL_WARNING,\"DB reloaded by DEBUG RELOAD\");\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"loadaof\")) {\n        if (server.aof_state != AOF_OFF) flushAppendOnlyFile(1);\n        emptyData(-1,EMPTYDB_NO_FLAGS,NULL);\n        protectClient(c);\n        if (server.aof_manifest) aofManifestFree(server.aof_manifest);\n        aofLoadManifestFromDisk();\n        aofDelHistoryFiles();\n        int ret = loadAppendOnlyFiles(server.aof_manifest);\n        if (ret != AOF_OK && ret != AOF_EMPTY)\n            exit(1);\n        unprotectClient(c);\n        server.dirty = 0; /* Prevent AOF / replication */\n        serverLog(LL_WARNING,\"Append Only File loaded by DEBUG LOADAOF\");\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"drop-cluster-packet-filter\") && c->argc == 3) {\n        long packet_type;\n        if (getLongFromObjectOrReply(c, c->argv[2], &packet_type, NULL) != C_OK)\n            return;\n        server.cluster_drop_packet_filter = packet_type;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"object\") && c->argc == 3) {\n        dictEntry *de;\n        robj *val;\n        char *strenc;\n\n        if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {\n            addReplyErrorObject(c,shared.nokeyerr);\n            return;\n        }\n        val = dictGetVal(de);\n        strenc = strEncoding(val->encoding);\n\n        char extra[138] = {0};\n        if (val->encoding == OBJ_ENCODING_QUICKLIST) {\n            char *nextra = extra;\n            int remaining = sizeof(extra);\n            quicklist *ql = val->ptr;\n            /* Add number of quicklist nodes */\n            int used = snprintf(nextra, remaining, \" ql_nodes:%lu\", ql->len);\n            nextra += used;\n            remaining -= used;\n            /* Add average quicklist fill factor */\n            double avg = (double)ql->count/ql->len;\n            used = snprintf(nextra, remaining, \" ql_avg_node:%.2f\", avg);\n            nextra += used;\n            remaining -= used;\n            /* Add quicklist fill level / max listpack size */\n            used = snprintf(nextra, remaining, \" ql_listpack_max:%d\", ql->fill);\n            nextra += used;\n            remaining -= used;\n            /* Add isCompressed? */\n            int compressed = ql->compress != 0;\n            used = snprintf(nextra, remaining, \" ql_compressed:%d\", compressed);\n            nextra += used;\n            remaining -= used;\n            /* Add total uncompressed size */\n            unsigned long sz = 0;\n            for (quicklistNode *node = ql->head; node; node = node->next) {\n                sz += node->sz;\n            }\n            used = snprintf(nextra, remaining, \" ql_uncompressed_size:%lu\", sz);\n            nextra += used;\n            remaining -= used;\n        }\n\n        addReplyStatusFormat(c,\n            \"Value at:%p refcount:%d \"\n            \"encoding:%s serializedlength:%zu \"\n            \"lru:%d lru_seconds_idle:%llu%s\",\n            (void*)val, val->refcount,\n            strenc, rdbSavedObjectLen(val, c->argv[2], c->db->id),\n            val->lru, estimateObjectIdleTime(val)/1000, extra);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"sdslen\") && c->argc == 3) {\n        dictEntry *de;\n        robj *val;\n        sds key;\n\n        if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {\n            addReplyErrorObject(c,shared.nokeyerr);\n            return;\n        }\n        val = dictGetVal(de);\n        key = dictGetKey(de);\n\n        if (val->type != OBJ_STRING || !sdsEncodedObject(val)) {\n            addReplyError(c,\"Not an sds encoded string.\");\n        } else {\n            addReplyStatusFormat(c,\n                \"key_sds_len:%lld, key_sds_avail:%lld, key_zmalloc: %lld, \"\n                \"val_sds_len:%lld, val_sds_avail:%lld, val_zmalloc: %lld\",\n                (long long) sdslen(key),\n                (long long) sdsavail(key),\n                (long long) sdsZmallocSize(key),\n                (long long) sdslen(val->ptr),\n                (long long) sdsavail(val->ptr),\n                (long long) getStringObjectSdsUsedMemory(val));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"listpack\") && c->argc == 3) {\n        robj *o;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n                == NULL) return;\n\n        if (o->encoding != OBJ_ENCODING_LISTPACK) {\n            addReplyError(c,\"Not a listpack encoded object.\");\n        } else {\n            lpRepr(o->ptr);\n            addReplyStatus(c,\"Listpack structure printed on stdout\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"quicklist\") && (c->argc == 3 || c->argc == 4)) {\n        robj *o;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n            == NULL) return;\n\n        int full = 0;\n        if (c->argc == 4)\n            full = atoi(c->argv[3]->ptr);\n        if (o->encoding != OBJ_ENCODING_QUICKLIST) {\n            addReplyError(c,\"Not a quicklist encoded object.\");\n        } else {\n            quicklistRepr(o->ptr, full);\n            addReplyStatus(c,\"Quicklist structure printed on stdout\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"populate\") &&\n               c->argc >= 3 && c->argc <= 5) {\n        long keys, j;\n        robj *key, *val;\n        char buf[128];\n\n        if (getPositiveLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)\n            return;\n\n        dictExpand(c->db->dict,keys);\n        long valsize = 0;\n        if ( c->argc == 5 && getPositiveLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK ) \n            return;\n\n        for (j = 0; j < keys; j++) {\n            snprintf(buf,sizeof(buf),\"%s:%lu\",\n                (c->argc == 3) ? \"key\" : (char*)c->argv[3]->ptr, j);\n            key = createStringObject(buf,strlen(buf));\n            if (lookupKeyWrite(c->db,key) != NULL) {\n                decrRefCount(key);\n                continue;\n            }\n            snprintf(buf,sizeof(buf),\"value:%lu\",j);\n            if (valsize==0)\n                val = createStringObject(buf,strlen(buf));\n            else {\n                int buflen = strlen(buf);\n                val = createStringObject(NULL,valsize);\n                memcpy(val->ptr, buf, valsize<=buflen? valsize: buflen);\n            }\n            dbAdd(c->db,key,val);\n            signalModifiedKey(c,c->db,key);\n            decrRefCount(key);\n        }\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"digest\") && c->argc == 2) {\n        /* DEBUG DIGEST (form without keys specified) */\n        unsigned char digest[20];\n        sds d = sdsempty();\n\n        computeDatasetDigest(digest);\n        for (int i = 0; i < 20; i++) d = sdscatprintf(d, \"%02x\",digest[i]);\n        addReplyStatus(c,d);\n        sdsfree(d);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"digest-value\") && c->argc >= 2) {\n        /* DEBUG DIGEST-VALUE key key key ... key. */\n        addReplyArrayLen(c,c->argc-2);\n        for (int j = 2; j < c->argc; j++) {\n            unsigned char digest[20];\n            memset(digest,0,20); /* Start with a clean result */\n\n            /* We don't use lookupKey because a debug command should\n             * work on logically expired keys */\n            dictEntry *de;\n            robj *o = ((de = dictFind(c->db->dict,c->argv[j]->ptr)) == NULL) ? NULL : dictGetVal(de);\n            if (o) xorObjectDigest(c->db,c->argv[j],digest,o);\n\n            sds d = sdsempty();\n            for (int i = 0; i < 20; i++) d = sdscatprintf(d, \"%02x\",digest[i]);\n            addReplyStatus(c,d);\n            sdsfree(d);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"protocol\") && c->argc == 3) {\n        /* DEBUG PROTOCOL [string|integer|double|bignum|null|array|set|map|\n         *                 attrib|push|verbatim|true|false] */\n        char *name = c->argv[2]->ptr;\n        if (!strcasecmp(name,\"string\")) {\n            addReplyBulkCString(c,\"Hello World\");\n        } else if (!strcasecmp(name,\"integer\")) {\n            addReplyLongLong(c,12345);\n        } else if (!strcasecmp(name,\"double\")) {\n            addReplyDouble(c,3.141);\n        } else if (!strcasecmp(name,\"bignum\")) {\n            addReplyBigNum(c,\"1234567999999999999999999999999999999\",37);\n        } else if (!strcasecmp(name,\"null\")) {\n            addReplyNull(c);\n        } else if (!strcasecmp(name,\"array\")) {\n            addReplyArrayLen(c,3);\n            for (int j = 0; j < 3; j++) addReplyLongLong(c,j);\n        } else if (!strcasecmp(name,\"set\")) {\n            addReplySetLen(c,3);\n            for (int j = 0; j < 3; j++) addReplyLongLong(c,j);\n        } else if (!strcasecmp(name,\"map\")) {\n            addReplyMapLen(c,3);\n            for (int j = 0; j < 3; j++) {\n                addReplyLongLong(c,j);\n                addReplyBool(c, j == 1);\n            }\n        } else if (!strcasecmp(name,\"attrib\")) {\n            if (c->resp >= 3) {\n                addReplyAttributeLen(c,1);\n                addReplyBulkCString(c,\"key-popularity\");\n                addReplyArrayLen(c,2);\n                addReplyBulkCString(c,\"key:123\");\n                addReplyLongLong(c,90);\n            }\n            /* Attributes are not real replies, so a well formed reply should\n             * also have a normal reply type after the attribute. */\n            addReplyBulkCString(c,\"Some real reply following the attribute\");\n        } else if (!strcasecmp(name,\"push\")) {\n            if (c->resp < 3) {\n                addReplyError(c,\"RESP2 is not supported by this command\");\n                return;\n\t    }\n            addReplyPushLen(c,2);\n            addReplyBulkCString(c,\"server-cpu-usage\");\n            addReplyLongLong(c,42);\n            /* Push replies are not synchronous replies, so we emit also a\n             * normal reply in order for blocking clients just discarding the\n             * push reply, to actually consume the reply and continue. */\n            addReplyBulkCString(c,\"Some real reply following the push reply\");\n        } else if (!strcasecmp(name,\"true\")) {\n            addReplyBool(c,1);\n        } else if (!strcasecmp(name,\"false\")) {\n            addReplyBool(c,0);\n        } else if (!strcasecmp(name,\"verbatim\")) {\n            addReplyVerbatim(c,\"This is a verbatim\\nstring\",25,\"txt\");\n        } else {\n            addReplyError(c,\"Wrong protocol type name. Please use one of the following: string|integer|double|bignum|null|array|set|map|attrib|push|verbatim|true|false\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"sleep\") && c->argc == 3) {\n        double dtime = strtod(c->argv[2]->ptr,NULL);\n        long long utime = dtime*1000000;\n        struct timespec tv;\n\n        tv.tv_sec = utime / 1000000;\n        tv.tv_nsec = (utime % 1000000) * 1000;\n        nanosleep(&tv, NULL);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-active-expire\") &&\n               c->argc == 3)\n    {\n        server.active_expire_enabled = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"quicklist-packed-threshold\") &&\n               c->argc == 3)\n    {\n        int memerr;\n        unsigned long long sz = memtoull((const char *)c->argv[2]->ptr, &memerr);\n        if (memerr || !quicklistisSetPackedThreshold(sz)) {\n            addReplyError(c, \"argument must be a memory value bigger than 1 and smaller than 4gb\");\n        } else {\n            addReply(c,shared.ok);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-skip-checksum-validation\") &&\n               c->argc == 3)\n    {\n        server.skip_checksum_validation = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"aof-flush-sleep\") &&\n               c->argc == 3)\n    {\n        server.aof_flush_sleep = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"replicate\") && c->argc >= 3) {\n        replicationFeedSlaves(server.slaves, -1,\n                c->argv + 2, c->argc - 2);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"error\") && c->argc == 3) {\n        sds errstr = sdsnewlen(\"-\",1);\n\n        errstr = sdscatsds(errstr,c->argv[2]->ptr);\n        errstr = sdsmapchars(errstr,\"\\n\\r\",\"  \",2); /* no newlines in errors. */\n        errstr = sdscatlen(errstr,\"\\r\\n\",2);\n        addReplySds(c,errstr);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"structsize\") && c->argc == 2) {\n        sds sizes = sdsempty();\n        sizes = sdscatprintf(sizes,\"bits:%d \",(sizeof(void*) == 8)?64:32);\n        sizes = sdscatprintf(sizes,\"robj:%d \",(int)sizeof(robj));\n        sizes = sdscatprintf(sizes,\"dictentry:%d \",(int)sizeof(dictEntry));\n        sizes = sdscatprintf(sizes,\"sdshdr5:%d \",(int)sizeof(struct sdshdr5));\n        sizes = sdscatprintf(sizes,\"sdshdr8:%d \",(int)sizeof(struct sdshdr8));\n        sizes = sdscatprintf(sizes,\"sdshdr16:%d \",(int)sizeof(struct sdshdr16));\n        sizes = sdscatprintf(sizes,\"sdshdr32:%d \",(int)sizeof(struct sdshdr32));\n        sizes = sdscatprintf(sizes,\"sdshdr64:%d \",(int)sizeof(struct sdshdr64));\n        addReplyBulkSds(c,sizes);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"htstats\") && c->argc == 3) {\n        long dbid;\n        sds stats = sdsempty();\n        char buf[4096];\n\n        if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK) {\n            sdsfree(stats);\n            return;\n        }\n        if (dbid < 0 || dbid >= server.dbnum) {\n            sdsfree(stats);\n            addReplyError(c,\"Out of range database\");\n            return;\n        }\n\n        stats = sdscatprintf(stats,\"[Dictionary HT]\\n\");\n        dictGetStats(buf,sizeof(buf),server.db[dbid].dict);\n        stats = sdscat(stats,buf);\n\n        stats = sdscatprintf(stats,\"[Expires HT]\\n\");\n        dictGetStats(buf,sizeof(buf),server.db[dbid].expires);\n        stats = sdscat(stats,buf);\n\n        addReplyVerbatim(c,stats,sdslen(stats),\"txt\");\n        sdsfree(stats);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"htstats-key\") && c->argc == 3) {\n        robj *o;\n        dict *ht = NULL;\n\n        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))\n                == NULL) return;\n\n        /* Get the hash table reference from the object, if possible. */\n        switch (o->encoding) {\n        case OBJ_ENCODING_SKIPLIST:\n            {\n                zset *zs = o->ptr;\n                ht = zs->dict;\n            }\n            break;\n        case OBJ_ENCODING_HT:\n            ht = o->ptr;\n            break;\n        }\n\n        if (ht == NULL) {\n            addReplyError(c,\"The value stored at the specified key is not \"\n                            \"represented using an hash table\");\n        } else {\n            char buf[4096];\n            dictGetStats(buf,sizeof(buf),ht);\n            addReplyVerbatim(c,buf,strlen(buf),\"txt\");\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"change-repl-id\") && c->argc == 2) {\n        serverLog(LL_WARNING,\"Changing replication IDs after receiving DEBUG change-repl-id\");\n        changeReplicationId();\n        clearReplicationId2();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"stringmatch-test\") && c->argc == 2)\n    {\n        stringmatchlen_fuzz_test();\n        addReplyStatus(c,\"Apparently Redis did not crash: test passed\");\n    } else if (!strcasecmp(c->argv[1]->ptr,\"set-disable-deny-scripts\") && c->argc == 3)\n    {\n        server.script_disable_deny_script = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"config-rewrite-force-all\") && c->argc == 2)\n    {\n        if (rewriteConfig(server.configfile, 1) == -1)\n            addReplyErrorFormat(c, \"CONFIG-REWRITE-FORCE-ALL failed: %s\", strerror(errno));\n        else\n            addReply(c, shared.ok);\n    } else if(!strcasecmp(c->argv[1]->ptr,\"client-eviction\") && c->argc == 2) {\n        sds bucket_info = sdsempty();\n        for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++) {\n            if (j == 0)\n                bucket_info = sdscatprintf(bucket_info, \"bucket          0\");\n            else\n                bucket_info = sdscatprintf(bucket_info, \"bucket %10zu\", (size_t)1<<(j-1+CLIENT_MEM_USAGE_BUCKET_MIN_LOG));\n            if (j == CLIENT_MEM_USAGE_BUCKETS-1)\n                bucket_info = sdscatprintf(bucket_info, \"+            : \");\n            else\n                bucket_info = sdscatprintf(bucket_info, \" - %10zu: \", ((size_t)1<<(j+CLIENT_MEM_USAGE_BUCKET_MIN_LOG))-1);\n            bucket_info = sdscatprintf(bucket_info, \"tot-mem: %10zu, clients: %lu\\n\",\n                server.client_mem_usage_buckets[j].mem_usage_sum,\n                server.client_mem_usage_buckets[j].clients->len);\n        }\n        addReplyVerbatim(c,bucket_info,sdslen(bucket_info),\"txt\");\n        sdsfree(bucket_info);\n#ifdef USE_JEMALLOC\n    } else if(!strcasecmp(c->argv[1]->ptr,\"mallctl\") && c->argc >= 3) {\n        mallctl_int(c, c->argv+2, c->argc-2);\n        return;\n    } else if(!strcasecmp(c->argv[1]->ptr,\"mallctl-str\") && c->argc >= 3) {\n        mallctl_string(c, c->argv+2, c->argc-2);\n        return;\n#endif\n    } else if (!strcasecmp(c->argv[1]->ptr,\"pause-cron\") && c->argc == 3)\n    {\n        server.pause_cron = atoi(c->argv[2]->ptr);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"replybuffer\") && c->argc == 4 ) {\n        if(!strcasecmp(c->argv[2]->ptr, \"peak-reset-time\")) {\n            if (!strcasecmp(c->argv[3]->ptr, \"never\")) {\n                server.reply_buffer_peak_reset_time = -1;\n            } else if(!strcasecmp(c->argv[3]->ptr, \"reset\")) {\n                server.reply_buffer_peak_reset_time = REPLY_BUFFER_DEFAULT_PEAK_RESET_TIME;\n            } else {\n                if (getLongFromObjectOrReply(c, c->argv[3], &server.reply_buffer_peak_reset_time, NULL) != C_OK)\n                    return;\n            }\n        } else if(!strcasecmp(c->argv[2]->ptr,\"resizing\")) {\n            server.reply_buffer_resizing_enabled = atoi(c->argv[3]->ptr);\n        } else {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n        addReply(c, shared.ok);\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n\n/* =========================== Crash handling  ============================== */\n\nvoid _serverAssert(const char *estr, const char *file, int line) {\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED ===\");\n    serverLog(LL_WARNING,\"==> %s:%d '%s' is not true\",file,line,estr);\n\n    if (server.crashlog_enabled) {\n#ifdef HAVE_BACKTRACE\n        logStackTrace(NULL, 1);\n#endif\n        printCrashReport();\n    }\n\n    // remove the signal handler so on abort() we will output the crash report.\n    removeSignalHandlers();\n    bugReportEnd(0, 0);\n}\n\nvoid _serverAssertPrintClientInfo(const client *c) {\n    int j;\n    char conninfo[CONN_INFO_LEN];\n\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED CLIENT CONTEXT ===\");\n    serverLog(LL_WARNING,\"client->flags = %llu\", (unsigned long long) c->flags);\n    serverLog(LL_WARNING,\"client->conn = %s\", connGetInfo(c->conn, conninfo, sizeof(conninfo)));\n    serverLog(LL_WARNING,\"client->argc = %d\", c->argc);\n    for (j=0; j < c->argc; j++) {\n        char buf[128];\n        char *arg;\n\n        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {\n            arg = (char*) c->argv[j]->ptr;\n        } else {\n            snprintf(buf,sizeof(buf),\"Object type: %u, encoding: %u\",\n                c->argv[j]->type, c->argv[j]->encoding);\n            arg = buf;\n        }\n        serverLog(LL_WARNING,\"client->argv[%d] = \\\"%s\\\" (refcount: %d)\",\n            j, arg, c->argv[j]->refcount);\n    }\n}\n\nvoid serverLogObjectDebugInfo(const robj *o) {\n    serverLog(LL_WARNING,\"Object type: %u\", o->type);\n    serverLog(LL_WARNING,\"Object encoding: %u\", o->encoding);\n    serverLog(LL_WARNING,\"Object refcount: %d\", o->refcount);\n#if UNSAFE_CRASH_REPORT\n    /* This code is now disabled. o->ptr may be unreliable to print. in some\n     * cases a ziplist could have already been freed by realloc, but not yet\n     * updated to o->ptr. in other cases the call to ziplistLen may need to\n     * iterate on all the items in the list (and possibly crash again).\n     * For some cases it may be ok to crash here again, but these could cause\n     * invalid memory access which will bother valgrind and also possibly cause\n     * random memory portion to be \"leaked\" into the logfile. */\n    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {\n        serverLog(LL_WARNING,\"Object raw string len: %zu\", sdslen(o->ptr));\n        if (sdslen(o->ptr) < 4096) {\n            sds repr = sdscatrepr(sdsempty(),o->ptr,sdslen(o->ptr));\n            serverLog(LL_WARNING,\"Object raw string content: %s\", repr);\n            sdsfree(repr);\n        }\n    } else if (o->type == OBJ_LIST) {\n        serverLog(LL_WARNING,\"List length: %d\", (int) listTypeLength(o));\n    } else if (o->type == OBJ_SET) {\n        serverLog(LL_WARNING,\"Set size: %d\", (int) setTypeSize(o));\n    } else if (o->type == OBJ_HASH) {\n        serverLog(LL_WARNING,\"Hash size: %d\", (int) hashTypeLength(o));\n    } else if (o->type == OBJ_ZSET) {\n        serverLog(LL_WARNING,\"Sorted set size: %d\", (int) zsetLength(o));\n        if (o->encoding == OBJ_ENCODING_SKIPLIST)\n            serverLog(LL_WARNING,\"Skiplist level: %d\", (int) ((const zset*)o->ptr)->zsl->level);\n    } else if (o->type == OBJ_STREAM) {\n        serverLog(LL_WARNING,\"Stream size: %d\", (int) streamLength(o));\n    }\n#endif\n}\n\nvoid _serverAssertPrintObject(const robj *o) {\n    bugReportStart();\n    serverLog(LL_WARNING,\"=== ASSERTION FAILED OBJECT CONTEXT ===\");\n    serverLogObjectDebugInfo(o);\n}\n\nvoid _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {\n    if (c) _serverAssertPrintClientInfo(c);\n    if (o) _serverAssertPrintObject(o);\n    _serverAssert(estr,file,line);\n}\n\nvoid _serverPanic(const char *file, int line, const char *msg, ...) {\n    va_list ap;\n    va_start(ap,msg);\n    char fmtmsg[256];\n    vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);\n    va_end(ap);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\"------------------------------------------------\");\n    serverLog(LL_WARNING,\"!!! Software Failure. Press left mouse button to continue\");\n    serverLog(LL_WARNING,\"Guru Meditation: %s #%s:%d\",fmtmsg,file,line);\n\n    if (server.crashlog_enabled) {\n#ifdef HAVE_BACKTRACE\n        logStackTrace(NULL, 1);\n#endif\n        printCrashReport();\n    }\n\n    // remove the signal handler so on abort() we will output the crash report.\n    removeSignalHandlers();\n    bugReportEnd(0, 0);\n}\n\nvoid bugReportStart(void) {\n    pthread_mutex_lock(&bug_report_start_mutex);\n    if (bug_report_start == 0) {\n        serverLogRaw(LL_WARNING|LL_RAW,\n        \"\\n\\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\\n\");\n        bug_report_start = 1;\n    }\n    pthread_mutex_unlock(&bug_report_start_mutex);\n}\n\n#ifdef HAVE_BACKTRACE\n\n/* Returns the current eip and set it to the given new value (if its not NULL) */\nstatic void* getAndSetMcontextEip(ucontext_t *uc, void *eip) {\n#define NOT_SUPPORTED() do {\\\n    UNUSED(uc);\\\n    UNUSED(eip);\\\n    return NULL;\\\n} while(0)\n#define GET_SET_RETURN(target_var, new_val) do {\\\n    void *old_val = (void*)target_var; \\\n    if (new_val) { \\\n        void **temp = (void**)&target_var; \\\n        *temp = new_val; \\\n    } \\\n    return old_val; \\\n} while(0)\n#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)\n    /* OSX < 10.6 */\n    #if defined(__x86_64__)\n    GET_SET_RETURN(uc->uc_mcontext->__ss.__rip, eip);\n    #elif defined(__i386__)\n    GET_SET_RETURN(uc->uc_mcontext->__ss.__eip, eip);\n    #else\n    GET_SET_RETURN(uc->uc_mcontext->__ss.__srr0, eip);\n    #endif\n#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n    /* OSX >= 10.6 */\n    #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    GET_SET_RETURN(uc->uc_mcontext->__ss.__rip, eip);\n    #elif defined(__i386__)\n    GET_SET_RETURN(uc->uc_mcontext->__ss.__eip, eip);\n    #else\n    /* OSX ARM64 */\n    void *old_val = (void*)arm_thread_state64_get_pc(uc->uc_mcontext->__ss);\n    if (eip) {\n        arm_thread_state64_set_pc_fptr(uc->uc_mcontext->__ss, eip);\n    }\n    return old_val;\n    #endif\n#elif defined(__linux__)\n    /* Linux */\n    #if defined(__i386__) || ((defined(__X86_64__) || defined(__x86_64__)) && defined(__ILP32__))\n    GET_SET_RETURN(uc->uc_mcontext.gregs[14], eip);\n    #elif defined(__X86_64__) || defined(__x86_64__)\n    GET_SET_RETURN(uc->uc_mcontext.gregs[16], eip);\n    #elif defined(__ia64__) /* Linux IA64 */\n    GET_SET_RETURN(uc->uc_mcontext.sc_ip, eip);\n    #elif defined(__arm__) /* Linux ARM */\n    GET_SET_RETURN(uc->uc_mcontext.arm_pc, eip);\n    #elif defined(__aarch64__) /* Linux AArch64 */\n    GET_SET_RETURN(uc->uc_mcontext.pc, eip);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__FreeBSD__)\n    /* FreeBSD */\n    #if defined(__i386__)\n    GET_SET_RETURN(uc->uc_mcontext.mc_eip, eip);\n    #elif defined(__x86_64__)\n    GET_SET_RETURN(uc->uc_mcontext.mc_rip, eip);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__OpenBSD__)\n    /* OpenBSD */\n    #if defined(__i386__)\n    GET_SET_RETURN(uc->sc_eip, eip);\n    #elif defined(__x86_64__)\n    GET_SET_RETURN(uc->sc_rip, eip);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__NetBSD__)\n    #if defined(__i386__)\n    GET_SET_RETURN(uc->uc_mcontext.__gregs[_REG_EIP], eip);\n    #elif defined(__x86_64__)\n    GET_SET_RETURN(uc->uc_mcontext.__gregs[_REG_RIP], eip);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__DragonFly__)\n    GET_SET_RETURN(uc->uc_mcontext.mc_rip, eip);\n#else\n    NOT_SUPPORTED();\n#endif\n#undef NOT_SUPPORTED\n}\n\nREDIS_NO_SANITIZE(\"address\")\nvoid logStackContent(void **sp) {\n    int i;\n    for (i = 15; i >= 0; i--) {\n        unsigned long addr = (unsigned long) sp+i;\n        unsigned long val = (unsigned long) sp[i];\n\n        if (sizeof(long) == 4)\n            serverLog(LL_WARNING, \"(%08lx) -> %08lx\", addr, val);\n        else\n            serverLog(LL_WARNING, \"(%016lx) -> %016lx\", addr, val);\n    }\n}\n\n/* Log dump of processor registers */\nvoid logRegisters(ucontext_t *uc) {\n    serverLog(LL_WARNING|LL_RAW, \"\\n------ REGISTERS ------\\n\");\n#define NOT_SUPPORTED() do {\\\n    UNUSED(uc);\\\n    serverLog(LL_WARNING,\\\n              \"  Dumping of registers not supported for this OS/arch\");\\\n} while(0)\n\n/* OSX */\n#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n  /* OSX AMD64 */\n    #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCS :%016lx FS:%016lx  GS:%016lx\",\n        (unsigned long) uc->uc_mcontext->__ss.__rax,\n        (unsigned long) uc->uc_mcontext->__ss.__rbx,\n        (unsigned long) uc->uc_mcontext->__ss.__rcx,\n        (unsigned long) uc->uc_mcontext->__ss.__rdx,\n        (unsigned long) uc->uc_mcontext->__ss.__rdi,\n        (unsigned long) uc->uc_mcontext->__ss.__rsi,\n        (unsigned long) uc->uc_mcontext->__ss.__rbp,\n        (unsigned long) uc->uc_mcontext->__ss.__rsp,\n        (unsigned long) uc->uc_mcontext->__ss.__r8,\n        (unsigned long) uc->uc_mcontext->__ss.__r9,\n        (unsigned long) uc->uc_mcontext->__ss.__r10,\n        (unsigned long) uc->uc_mcontext->__ss.__r11,\n        (unsigned long) uc->uc_mcontext->__ss.__r12,\n        (unsigned long) uc->uc_mcontext->__ss.__r13,\n        (unsigned long) uc->uc_mcontext->__ss.__r14,\n        (unsigned long) uc->uc_mcontext->__ss.__r15,\n        (unsigned long) uc->uc_mcontext->__ss.__rip,\n        (unsigned long) uc->uc_mcontext->__ss.__rflags,\n        (unsigned long) uc->uc_mcontext->__ss.__cs,\n        (unsigned long) uc->uc_mcontext->__ss.__fs,\n        (unsigned long) uc->uc_mcontext->__ss.__gs\n    );\n    logStackContent((void**)uc->uc_mcontext->__ss.__rsp);\n    #elif defined(__i386__)\n    /* OSX x86 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\\n\"\n    \"DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx\",\n        (unsigned long) uc->uc_mcontext->__ss.__eax,\n        (unsigned long) uc->uc_mcontext->__ss.__ebx,\n        (unsigned long) uc->uc_mcontext->__ss.__ecx,\n        (unsigned long) uc->uc_mcontext->__ss.__edx,\n        (unsigned long) uc->uc_mcontext->__ss.__edi,\n        (unsigned long) uc->uc_mcontext->__ss.__esi,\n        (unsigned long) uc->uc_mcontext->__ss.__ebp,\n        (unsigned long) uc->uc_mcontext->__ss.__esp,\n        (unsigned long) uc->uc_mcontext->__ss.__ss,\n        (unsigned long) uc->uc_mcontext->__ss.__eflags,\n        (unsigned long) uc->uc_mcontext->__ss.__eip,\n        (unsigned long) uc->uc_mcontext->__ss.__cs,\n        (unsigned long) uc->uc_mcontext->__ss.__ds,\n        (unsigned long) uc->uc_mcontext->__ss.__es,\n        (unsigned long) uc->uc_mcontext->__ss.__fs,\n        (unsigned long) uc->uc_mcontext->__ss.__gs\n    );\n    logStackContent((void**)uc->uc_mcontext->__ss.__esp);\n    #else\n    /* OSX ARM64 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"x0:%016lx x1:%016lx x2:%016lx x3:%016lx\\n\"\n    \"x4:%016lx x5:%016lx x6:%016lx x7:%016lx\\n\"\n    \"x8:%016lx x9:%016lx x10:%016lx x11:%016lx\\n\"\n    \"x12:%016lx x13:%016lx x14:%016lx x15:%016lx\\n\"\n    \"x16:%016lx x17:%016lx x18:%016lx x19:%016lx\\n\"\n    \"x20:%016lx x21:%016lx x22:%016lx x23:%016lx\\n\"\n    \"x24:%016lx x25:%016lx x26:%016lx x27:%016lx\\n\"\n    \"x28:%016lx fp:%016lx lr:%016lx\\n\"\n    \"sp:%016lx pc:%016lx cpsr:%08lx\\n\",\n        (unsigned long) uc->uc_mcontext->__ss.__x[0],\n        (unsigned long) uc->uc_mcontext->__ss.__x[1],\n        (unsigned long) uc->uc_mcontext->__ss.__x[2],\n        (unsigned long) uc->uc_mcontext->__ss.__x[3],\n        (unsigned long) uc->uc_mcontext->__ss.__x[4],\n        (unsigned long) uc->uc_mcontext->__ss.__x[5],\n        (unsigned long) uc->uc_mcontext->__ss.__x[6],\n        (unsigned long) uc->uc_mcontext->__ss.__x[7],\n        (unsigned long) uc->uc_mcontext->__ss.__x[8],\n        (unsigned long) uc->uc_mcontext->__ss.__x[9],\n        (unsigned long) uc->uc_mcontext->__ss.__x[10],\n        (unsigned long) uc->uc_mcontext->__ss.__x[11],\n        (unsigned long) uc->uc_mcontext->__ss.__x[12],\n        (unsigned long) uc->uc_mcontext->__ss.__x[13],\n        (unsigned long) uc->uc_mcontext->__ss.__x[14],\n        (unsigned long) uc->uc_mcontext->__ss.__x[15],\n        (unsigned long) uc->uc_mcontext->__ss.__x[16],\n        (unsigned long) uc->uc_mcontext->__ss.__x[17],\n        (unsigned long) uc->uc_mcontext->__ss.__x[18],\n        (unsigned long) uc->uc_mcontext->__ss.__x[19],\n        (unsigned long) uc->uc_mcontext->__ss.__x[20],\n        (unsigned long) uc->uc_mcontext->__ss.__x[21],\n        (unsigned long) uc->uc_mcontext->__ss.__x[22],\n        (unsigned long) uc->uc_mcontext->__ss.__x[23],\n        (unsigned long) uc->uc_mcontext->__ss.__x[24],\n        (unsigned long) uc->uc_mcontext->__ss.__x[25],\n        (unsigned long) uc->uc_mcontext->__ss.__x[26],\n        (unsigned long) uc->uc_mcontext->__ss.__x[27],\n        (unsigned long) uc->uc_mcontext->__ss.__x[28],\n        (unsigned long) arm_thread_state64_get_fp(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_lr(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_sp(uc->uc_mcontext->__ss),\n        (unsigned long) arm_thread_state64_get_pc(uc->uc_mcontext->__ss),\n        (unsigned long) uc->uc_mcontext->__ss.__cpsr\n    );\n    logStackContent((void**) arm_thread_state64_get_sp(uc->uc_mcontext->__ss));\n    #endif\n/* Linux */\n#elif defined(__linux__)\n    /* Linux x86 */\n    #if defined(__i386__) || ((defined(__X86_64__) || defined(__x86_64__)) && defined(__ILP32__))\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.gregs[11],\n        (unsigned long) uc->uc_mcontext.gregs[8],\n        (unsigned long) uc->uc_mcontext.gregs[10],\n        (unsigned long) uc->uc_mcontext.gregs[9],\n        (unsigned long) uc->uc_mcontext.gregs[4],\n        (unsigned long) uc->uc_mcontext.gregs[5],\n        (unsigned long) uc->uc_mcontext.gregs[6],\n        (unsigned long) uc->uc_mcontext.gregs[7],\n        (unsigned long) uc->uc_mcontext.gregs[18],\n        (unsigned long) uc->uc_mcontext.gregs[17],\n        (unsigned long) uc->uc_mcontext.gregs[14],\n        (unsigned long) uc->uc_mcontext.gregs[15],\n        (unsigned long) uc->uc_mcontext.gregs[3],\n        (unsigned long) uc->uc_mcontext.gregs[2],\n        (unsigned long) uc->uc_mcontext.gregs[1],\n        (unsigned long) uc->uc_mcontext.gregs[0]\n    );\n    logStackContent((void**)uc->uc_mcontext.gregs[7]);\n    #elif defined(__X86_64__) || defined(__x86_64__)\n    /* Linux AMD64 */\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.gregs[13],\n        (unsigned long) uc->uc_mcontext.gregs[11],\n        (unsigned long) uc->uc_mcontext.gregs[14],\n        (unsigned long) uc->uc_mcontext.gregs[12],\n        (unsigned long) uc->uc_mcontext.gregs[8],\n        (unsigned long) uc->uc_mcontext.gregs[9],\n        (unsigned long) uc->uc_mcontext.gregs[10],\n        (unsigned long) uc->uc_mcontext.gregs[15],\n        (unsigned long) uc->uc_mcontext.gregs[0],\n        (unsigned long) uc->uc_mcontext.gregs[1],\n        (unsigned long) uc->uc_mcontext.gregs[2],\n        (unsigned long) uc->uc_mcontext.gregs[3],\n        (unsigned long) uc->uc_mcontext.gregs[4],\n        (unsigned long) uc->uc_mcontext.gregs[5],\n        (unsigned long) uc->uc_mcontext.gregs[6],\n        (unsigned long) uc->uc_mcontext.gregs[7],\n        (unsigned long) uc->uc_mcontext.gregs[16],\n        (unsigned long) uc->uc_mcontext.gregs[17],\n        (unsigned long) uc->uc_mcontext.gregs[18]\n    );\n    logStackContent((void**)uc->uc_mcontext.gregs[15]);\n    #elif defined(__aarch64__) /* Linux AArch64 */\n    serverLog(LL_WARNING,\n\t      \"\\n\"\n\t      \"X18:%016lx X19:%016lx\\nX20:%016lx X21:%016lx\\n\"\n\t      \"X22:%016lx X23:%016lx\\nX24:%016lx X25:%016lx\\n\"\n\t      \"X26:%016lx X27:%016lx\\nX28:%016lx X29:%016lx\\n\"\n\t      \"X30:%016lx\\n\"\n\t      \"pc:%016lx sp:%016lx\\npstate:%016lx fault_address:%016lx\\n\",\n\t      (unsigned long) uc->uc_mcontext.regs[18],\n\t      (unsigned long) uc->uc_mcontext.regs[19],\n\t      (unsigned long) uc->uc_mcontext.regs[20],\n\t      (unsigned long) uc->uc_mcontext.regs[21],\n\t      (unsigned long) uc->uc_mcontext.regs[22],\n\t      (unsigned long) uc->uc_mcontext.regs[23],\n\t      (unsigned long) uc->uc_mcontext.regs[24],\n\t      (unsigned long) uc->uc_mcontext.regs[25],\n\t      (unsigned long) uc->uc_mcontext.regs[26],\n\t      (unsigned long) uc->uc_mcontext.regs[27],\n\t      (unsigned long) uc->uc_mcontext.regs[28],\n\t      (unsigned long) uc->uc_mcontext.regs[29],\n\t      (unsigned long) uc->uc_mcontext.regs[30],\n\t      (unsigned long) uc->uc_mcontext.pc,\n\t      (unsigned long) uc->uc_mcontext.sp,\n\t      (unsigned long) uc->uc_mcontext.pstate,\n\t      (unsigned long) uc->uc_mcontext.fault_address\n\t\t      );\n\t      logStackContent((void**)uc->uc_mcontext.sp);\n    #elif defined(__arm__) /* Linux ARM */\n    serverLog(LL_WARNING,\n\t      \"\\n\"\n\t      \"R10:%016lx R9 :%016lx\\nR8 :%016lx R7 :%016lx\\n\"\n\t      \"R6 :%016lx R5 :%016lx\\nR4 :%016lx R3 :%016lx\\n\"\n\t      \"R2 :%016lx R1 :%016lx\\nR0 :%016lx EC :%016lx\\n\"\n\t      \"fp: %016lx ip:%016lx\\n\"\n\t      \"pc:%016lx sp:%016lx\\ncpsr:%016lx fault_address:%016lx\\n\",\n\t      (unsigned long) uc->uc_mcontext.arm_r10,\n\t      (unsigned long) uc->uc_mcontext.arm_r9,\n\t      (unsigned long) uc->uc_mcontext.arm_r8,\n\t      (unsigned long) uc->uc_mcontext.arm_r7,\n\t      (unsigned long) uc->uc_mcontext.arm_r6,\n\t      (unsigned long) uc->uc_mcontext.arm_r5,\n\t      (unsigned long) uc->uc_mcontext.arm_r4,\n\t      (unsigned long) uc->uc_mcontext.arm_r3,\n\t      (unsigned long) uc->uc_mcontext.arm_r2,\n\t      (unsigned long) uc->uc_mcontext.arm_r1,\n\t      (unsigned long) uc->uc_mcontext.arm_r0,\n\t      (unsigned long) uc->uc_mcontext.error_code,\n\t      (unsigned long) uc->uc_mcontext.arm_fp,\n\t      (unsigned long) uc->uc_mcontext.arm_ip,\n\t      (unsigned long) uc->uc_mcontext.arm_pc,\n\t      (unsigned long) uc->uc_mcontext.arm_sp,\n\t      (unsigned long) uc->uc_mcontext.arm_cpsr,\n\t      (unsigned long) uc->uc_mcontext.fault_address\n\t\t      );\n\t      logStackContent((void**)uc->uc_mcontext.arm_sp);\n    #else\n\tNOT_SUPPORTED();\n    #endif\n#elif defined(__FreeBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.mc_rax,\n        (unsigned long) uc->uc_mcontext.mc_rbx,\n        (unsigned long) uc->uc_mcontext.mc_rcx,\n        (unsigned long) uc->uc_mcontext.mc_rdx,\n        (unsigned long) uc->uc_mcontext.mc_rdi,\n        (unsigned long) uc->uc_mcontext.mc_rsi,\n        (unsigned long) uc->uc_mcontext.mc_rbp,\n        (unsigned long) uc->uc_mcontext.mc_rsp,\n        (unsigned long) uc->uc_mcontext.mc_r8,\n        (unsigned long) uc->uc_mcontext.mc_r9,\n        (unsigned long) uc->uc_mcontext.mc_r10,\n        (unsigned long) uc->uc_mcontext.mc_r11,\n        (unsigned long) uc->uc_mcontext.mc_r12,\n        (unsigned long) uc->uc_mcontext.mc_r13,\n        (unsigned long) uc->uc_mcontext.mc_r14,\n        (unsigned long) uc->uc_mcontext.mc_r15,\n        (unsigned long) uc->uc_mcontext.mc_rip,\n        (unsigned long) uc->uc_mcontext.mc_rflags,\n        (unsigned long) uc->uc_mcontext.mc_cs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_rsp);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.mc_eax,\n        (unsigned long) uc->uc_mcontext.mc_ebx,\n        (unsigned long) uc->uc_mcontext.mc_ebx,\n        (unsigned long) uc->uc_mcontext.mc_edx,\n        (unsigned long) uc->uc_mcontext.mc_edi,\n        (unsigned long) uc->uc_mcontext.mc_esi,\n        (unsigned long) uc->uc_mcontext.mc_ebp,\n        (unsigned long) uc->uc_mcontext.mc_esp,\n        (unsigned long) uc->uc_mcontext.mc_ss,\n        (unsigned long) uc->uc_mcontext.mc_eflags,\n        (unsigned long) uc->uc_mcontext.mc_eip,\n        (unsigned long) uc->uc_mcontext.mc_cs,\n        (unsigned long) uc->uc_mcontext.mc_es,\n        (unsigned long) uc->uc_mcontext.mc_fs,\n        (unsigned long) uc->uc_mcontext.mc_gs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_esp);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__OpenBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->sc_rax,\n        (unsigned long) uc->sc_rbx,\n        (unsigned long) uc->sc_rcx,\n        (unsigned long) uc->sc_rdx,\n        (unsigned long) uc->sc_rdi,\n        (unsigned long) uc->sc_rsi,\n        (unsigned long) uc->sc_rbp,\n        (unsigned long) uc->sc_rsp,\n        (unsigned long) uc->sc_r8,\n        (unsigned long) uc->sc_r9,\n        (unsigned long) uc->sc_r10,\n        (unsigned long) uc->sc_r11,\n        (unsigned long) uc->sc_r12,\n        (unsigned long) uc->sc_r13,\n        (unsigned long) uc->sc_r14,\n        (unsigned long) uc->sc_r15,\n        (unsigned long) uc->sc_rip,\n        (unsigned long) uc->sc_rflags,\n        (unsigned long) uc->sc_cs\n    );\n    logStackContent((void**)uc->sc_rsp);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->sc_eax,\n        (unsigned long) uc->sc_ebx,\n        (unsigned long) uc->sc_ebx,\n        (unsigned long) uc->sc_edx,\n        (unsigned long) uc->sc_edi,\n        (unsigned long) uc->sc_esi,\n        (unsigned long) uc->sc_ebp,\n        (unsigned long) uc->sc_esp,\n        (unsigned long) uc->sc_ss,\n        (unsigned long) uc->sc_eflags,\n        (unsigned long) uc->sc_eip,\n        (unsigned long) uc->sc_cs,\n        (unsigned long) uc->sc_es,\n        (unsigned long) uc->sc_fs,\n        (unsigned long) uc->sc_gs\n    );\n    logStackContent((void**)uc->sc_esp);\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__NetBSD__)\n    #if defined(__x86_64__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RAX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RBX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RCX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RDX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RDI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RSI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RBP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RSP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R8],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R9],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R10],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R11],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R12],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R13],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R14],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_R15],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RIP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_RFLAGS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_CS]\n    );\n    logStackContent((void**)uc->uc_mcontext.__gregs[_REG_RSP]);\n    #elif defined(__i386__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\\n\"\n    \"EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\\n\"\n    \"SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\\n\"\n    \"DS :%08lx ES :%08lx FS :%08lx GS:%08lx\",\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EAX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EBX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EDX],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EDI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ESI],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EBP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ESP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_SS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EFLAGS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_EIP],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_CS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_ES],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_FS],\n        (unsigned long) uc->uc_mcontext.__gregs[_REG_GS]\n    );\n    #else\n    NOT_SUPPORTED();\n    #endif\n#elif defined(__DragonFly__)\n    serverLog(LL_WARNING,\n    \"\\n\"\n    \"RAX:%016lx RBX:%016lx\\nRCX:%016lx RDX:%016lx\\n\"\n    \"RDI:%016lx RSI:%016lx\\nRBP:%016lx RSP:%016lx\\n\"\n    \"R8 :%016lx R9 :%016lx\\nR10:%016lx R11:%016lx\\n\"\n    \"R12:%016lx R13:%016lx\\nR14:%016lx R15:%016lx\\n\"\n    \"RIP:%016lx EFL:%016lx\\nCSGSFS:%016lx\",\n        (unsigned long) uc->uc_mcontext.mc_rax,\n        (unsigned long) uc->uc_mcontext.mc_rbx,\n        (unsigned long) uc->uc_mcontext.mc_rcx,\n        (unsigned long) uc->uc_mcontext.mc_rdx,\n        (unsigned long) uc->uc_mcontext.mc_rdi,\n        (unsigned long) uc->uc_mcontext.mc_rsi,\n        (unsigned long) uc->uc_mcontext.mc_rbp,\n        (unsigned long) uc->uc_mcontext.mc_rsp,\n        (unsigned long) uc->uc_mcontext.mc_r8,\n        (unsigned long) uc->uc_mcontext.mc_r9,\n        (unsigned long) uc->uc_mcontext.mc_r10,\n        (unsigned long) uc->uc_mcontext.mc_r11,\n        (unsigned long) uc->uc_mcontext.mc_r12,\n        (unsigned long) uc->uc_mcontext.mc_r13,\n        (unsigned long) uc->uc_mcontext.mc_r14,\n        (unsigned long) uc->uc_mcontext.mc_r15,\n        (unsigned long) uc->uc_mcontext.mc_rip,\n        (unsigned long) uc->uc_mcontext.mc_rflags,\n        (unsigned long) uc->uc_mcontext.mc_cs\n    );\n    logStackContent((void**)uc->uc_mcontext.mc_rsp);\n#else\n    NOT_SUPPORTED();\n#endif\n#undef NOT_SUPPORTED\n}\n\n#endif /* HAVE_BACKTRACE */\n\n/* Return a file descriptor to write directly to the Redis log with the\n * write(2) syscall, that can be used in critical sections of the code\n * where the rest of Redis can't be trusted (for example during the memory\n * test) or when an API call requires a raw fd.\n *\n * Close it with closeDirectLogFiledes(). */\nint openDirectLogFiledes(void) {\n    int log_to_stdout = server.logfile[0] == '\\0';\n    int fd = log_to_stdout ?\n        STDOUT_FILENO :\n        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    return fd;\n}\n\n/* Used to close what closeDirectLogFiledes() returns. */\nvoid closeDirectLogFiledes(int fd) {\n    int log_to_stdout = server.logfile[0] == '\\0';\n    if (!log_to_stdout) close(fd);\n}\n\n#ifdef HAVE_BACKTRACE\n\n/* Logs the stack trace using the backtrace() call. This function is designed\n * to be called from signal handlers safely.\n * The eip argument is optional (can take NULL).\n * The uplevel argument indicates how many of the calling functions to skip.\n */\nvoid logStackTrace(void *eip, int uplevel) {\n    void *trace[100];\n    int trace_size = 0, fd = openDirectLogFiledes();\n    char *msg;\n    uplevel++; /* skip this function */\n\n    if (fd == -1) return; /* If we can't log there is anything to do. */\n\n    /* Get the stack trace first! */\n    trace_size = backtrace(trace, 100);\n\n    msg = \"\\n------ STACK TRACE ------\\n\";\n    if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n\n    if (eip) {\n        /* Write EIP to the log file*/\n        msg = \"EIP:\\n\";\n        if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n        backtrace_symbols_fd(&eip, 1, fd);\n    }\n\n    /* Write symbols to log file */\n    msg = \"\\nBacktrace:\\n\";\n    if (write(fd,msg,strlen(msg)) == -1) {/* Avoid warning. */};\n    backtrace_symbols_fd(trace+uplevel, trace_size-uplevel, fd);\n\n    /* Cleanup */\n    closeDirectLogFiledes(fd);\n}\n\n#endif /* HAVE_BACKTRACE */\n\n/* Log global server info */\nvoid logServerInfo(void) {\n    sds infostring, clients;\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ INFO OUTPUT ------\\n\");\n    int all = 0, everything = 0;\n    robj *argv[1];\n    argv[0] = createStringObject(\"all\", strlen(\"all\"));\n    dict *section_dict = genInfoSectionDict(argv, 1, NULL, &all, &everything);\n    infostring = genRedisInfoString(section_dict, all, everything);\n    serverLogRaw(LL_WARNING|LL_RAW, infostring);\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CLIENT LIST OUTPUT ------\\n\");\n    clients = getAllClientsInfoString(-1);\n    serverLogRaw(LL_WARNING|LL_RAW, clients);\n    sdsfree(infostring);\n    sdsfree(clients);\n    releaseInfoSectionDict(section_dict);\n    decrRefCount(argv[0]);\n}\n\n/* Log certain config values, which can be used for debuggin */\nvoid logConfigDebugInfo(void) {\n    sds configstring;\n    configstring = getConfigDebugInfo();\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CONFIG DEBUG OUTPUT ------\\n\");\n    serverLogRaw(LL_WARNING|LL_RAW, configstring);\n    sdsfree(configstring);\n}\n\n/* Log modules info. Something we wanna do last since we fear it may crash. */\nvoid logModulesInfo(void) {\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ MODULES INFO OUTPUT ------\\n\");\n    sds infostring = modulesCollectInfo(sdsempty(), NULL, 1, 0);\n    serverLogRaw(LL_WARNING|LL_RAW, infostring);\n    sdsfree(infostring);\n}\n\n/* Log information about the \"current\" client, that is, the client that is\n * currently being served by Redis. May be NULL if Redis is not serving a\n * client right now. */\nvoid logCurrentClient(void) {\n    if (server.current_client == NULL) return;\n\n    client *cc = server.current_client;\n    sds client;\n    int j;\n\n    serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ CURRENT CLIENT INFO ------\\n\");\n    client = catClientInfoString(sdsempty(),cc);\n    serverLog(LL_WARNING|LL_RAW,\"%s\\n\", client);\n    sdsfree(client);\n    for (j = 0; j < cc->argc; j++) {\n        robj *decoded;\n        decoded = getDecodedObject(cc->argv[j]);\n        sds repr = sdscatrepr(sdsempty(),decoded->ptr, min(sdslen(decoded->ptr), 128));\n        serverLog(LL_WARNING|LL_RAW,\"argv[%d]: '%s'\\n\", j, (char*)repr);\n        sdsfree(repr);\n        decrRefCount(decoded);\n    }\n    /* Check if the first argument, usually a key, is found inside the\n     * selected DB, and if so print info about the associated object. */\n    if (cc->argc > 1) {\n        robj *val, *key;\n        dictEntry *de;\n\n        key = getDecodedObject(cc->argv[1]);\n        de = dictFind(cc->db->dict, key->ptr);\n        if (de) {\n            val = dictGetVal(de);\n            serverLog(LL_WARNING,\"key '%s' found in DB containing the following object:\", (char*)key->ptr);\n            serverLogObjectDebugInfo(val);\n        }\n        decrRefCount(key);\n    }\n}\n\n#if defined(HAVE_PROC_MAPS)\n\n#define MEMTEST_MAX_REGIONS 128\n\n/* A non destructive memory test executed during segfault. */\nint memtest_test_linux_anonymous_maps(void) {\n    FILE *fp;\n    char line[1024];\n    char logbuf[1024];\n    size_t start_addr, end_addr, size;\n    size_t start_vect[MEMTEST_MAX_REGIONS];\n    size_t size_vect[MEMTEST_MAX_REGIONS];\n    int regions = 0, j;\n\n    int fd = openDirectLogFiledes();\n    if (!fd) return 0;\n\n    fp = fopen(\"/proc/self/maps\",\"r\");\n    if (!fp) {\n        closeDirectLogFiledes(fd);\n        return 0;\n    }\n    while(fgets(line,sizeof(line),fp) != NULL) {\n        char *start, *end, *p = line;\n\n        start = p;\n        p = strchr(p,'-');\n        if (!p) continue;\n        *p++ = '\\0';\n        end = p;\n        p = strchr(p,' ');\n        if (!p) continue;\n        *p++ = '\\0';\n        if (strstr(p,\"stack\") ||\n            strstr(p,\"vdso\") ||\n            strstr(p,\"vsyscall\")) continue;\n        if (!strstr(p,\"00:00\")) continue;\n        if (!strstr(p,\"rw\")) continue;\n\n        start_addr = strtoul(start,NULL,16);\n        end_addr = strtoul(end,NULL,16);\n        size = end_addr-start_addr;\n\n        start_vect[regions] = start_addr;\n        size_vect[regions] = size;\n        snprintf(logbuf,sizeof(logbuf),\n            \"*** Preparing to test memory region %lx (%lu bytes)\\n\",\n                (unsigned long) start_vect[regions],\n                (unsigned long) size_vect[regions]);\n        if (write(fd,logbuf,strlen(logbuf)) == -1) { /* Nothing to do. */ }\n        regions++;\n    }\n\n    int errors = 0;\n    for (j = 0; j < regions; j++) {\n        if (write(fd,\".\",1) == -1) { /* Nothing to do. */ }\n        errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);\n        if (write(fd, errors ? \"E\" : \"O\",1) == -1) { /* Nothing to do. */ }\n    }\n    if (write(fd,\"\\n\",1) == -1) { /* Nothing to do. */ }\n\n    /* NOTE: It is very important to close the file descriptor only now\n     * because closing it before may result into unmapping of some memory\n     * region that we are testing. */\n    fclose(fp);\n    closeDirectLogFiledes(fd);\n    return errors;\n}\n#endif /* HAVE_PROC_MAPS */\n\nstatic void killMainThread(void) {\n    int err;\n    if (pthread_self() != server.main_thread_id && pthread_cancel(server.main_thread_id) == 0) {\n        if ((err = pthread_join(server.main_thread_id,NULL)) != 0) {\n            serverLog(LL_WARNING, \"main thread can not be joined: %s\", strerror(err));\n        } else {\n            serverLog(LL_WARNING, \"main thread terminated\");\n        }\n    }\n}\n\n/* Kill the running threads (other than current) in an unclean way. This function\n * should be used only when it's critical to stop the threads for some reason.\n * Currently Redis does this only on crash (for instance on SIGSEGV) in order\n * to perform a fast memory check without other threads messing with memory. */\nvoid killThreads(void) {\n    killMainThread();\n    bioKillThreads();\n    killIOThreads();\n}\n\nvoid doFastMemoryTest(void) {\n#if defined(HAVE_PROC_MAPS)\n    if (server.memcheck_enabled) {\n        /* Test memory */\n        serverLogRaw(LL_WARNING|LL_RAW, \"\\n------ FAST MEMORY TEST ------\\n\");\n        killThreads();\n        if (memtest_test_linux_anonymous_maps()) {\n            serverLogRaw(LL_WARNING|LL_RAW,\n                \"!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\\n\");\n        } else {\n            serverLogRaw(LL_WARNING|LL_RAW,\n                \"Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\\n\");\n        }\n    }\n#endif /* HAVE_PROC_MAPS */\n}\n\n/* Scans the (assumed) x86 code starting at addr, for a max of `len`\n * bytes, searching for E8 (callq) opcodes, and dumping the symbols\n * and the call offset if they appear to be valid. */\nvoid dumpX86Calls(void *addr, size_t len) {\n    size_t j;\n    unsigned char *p = addr;\n    Dl_info info;\n    /* Hash table to best-effort avoid printing the same symbol\n     * multiple times. */\n    unsigned long ht[256] = {0};\n\n    if (len < 5) return;\n    for (j = 0; j < len-4; j++) {\n        if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */\n        unsigned long target = (unsigned long)addr+j+5;\n        uint32_t tmp;\n        memcpy(&tmp, p+j+1, sizeof(tmp));\n        target += tmp;\n        if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {\n            if (ht[target&0xff] != target) {\n                printf(\"Function at 0x%lx is %s\\n\",target,info.dli_sname);\n                ht[target&0xff] = target;\n            }\n            j += 4; /* Skip the 32 bit immediate. */\n        }\n    }\n}\n\nvoid dumpCodeAroundEIP(void *eip) {\n    Dl_info info;\n    if (dladdr(eip, &info) != 0) {\n        serverLog(LL_WARNING|LL_RAW,\n            \"\\n------ DUMPING CODE AROUND EIP ------\\n\"\n            \"Symbol: %s (base: %p)\\n\"\n            \"Module: %s (base %p)\\n\"\n            \"$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\\n\"\n            \"$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\\n\"\n            \"------\\n\",\n            info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,\n            info.dli_saddr);\n        size_t len = (long)eip - (long)info.dli_saddr;\n        unsigned long sz = sysconf(_SC_PAGESIZE);\n        if (len < 1<<13) { /* we don't have functions over 8k (verified) */\n            /* Find the address of the next page, which is our \"safety\"\n             * limit when dumping. Then try to dump just 128 bytes more\n             * than EIP if there is room, or stop sooner. */\n            void *base = (void *)info.dli_saddr;\n            unsigned long next = ((unsigned long)eip + sz) & ~(sz-1);\n            unsigned long end = (unsigned long)eip + 128;\n            if (end > next) end = next;\n            len = end - (unsigned long)base;\n            serverLogHexDump(LL_WARNING, \"dump of function\",\n                base, len);\n            dumpX86Calls(base, len);\n        }\n    }\n}\n\nvoid invalidFunctionWasCalled() {}\n\ntypedef void (*invalidFunctionWasCalledType)();\n\nvoid sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getAndSetMcontextEip(uc, NULL);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    if (eip == info->si_addr) {\n        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n\n        /* This trick allow to avoid compiler warning */\n        void *ptr;\n        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n        *ptr_ptr = invalidFunctionWasCalled;\n        getAndSetMcontextEip(uc, ptr);\n    }\n\n    logStackTrace(eip, 1);\n\n    if (eip == info->si_addr) {\n        /* Restore old eip */\n        getAndSetMcontextEip(uc, eip);\n    }\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}\n\nvoid printCrashReport(void) {\n    /* Log INFO and CLIENT LIST */\n    logServerInfo();\n\n    /* Log the current client */\n    logCurrentClient();\n\n    /* Log modules info. Something we wanna do last since we fear it may crash. */\n    logModulesInfo();\n\n    /* Log debug config information, which are some values\n     * which may be useful for debugging crashes. */\n    logConfigDebugInfo();\n\n    /* Run memory test in case the crash was triggered by memory corruption. */\n    doFastMemoryTest();\n}\n\nvoid bugReportEnd(int killViaSignal, int sig) {\n    struct sigaction act;\n\n    serverLogRaw(LL_WARNING|LL_RAW,\n\"\\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\\n\\n\"\n\"       Please report the crash by opening an issue on github:\\n\\n\"\n\"           http://github.com/redis/redis/issues\\n\\n\"\n\"  If a Redis module was involved, please open in the module's repo instead.\\n\\n\"\n\"  Suspect RAM error? Use redis-server --test-memory to verify it.\\n\\n\"\n\"  Some other issues could be detected by redis-server --check-system\\n\"\n);\n\n    /* free(messages); Don't call free() with possibly corrupted memory. */\n    if (server.daemonize && server.supervised == 0 && server.pidfile) unlink(server.pidfile);\n\n    if (!killViaSignal) {\n        /* To avoid issues with valgrind, we may wanna exit rahter than generate a signal */\n        if (server.use_exit_on_panic) {\n             /* Using _exit to bypass false leak reports by gcc ASAN */\n             fflush(stdout);\n            _exit(1);\n        }\n        abort();\n    }\n\n    /* Make sure we exit with the right signal at the end. So for instance\n     * the core will be dumped if enabled. */\n    sigemptyset (&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction (sig, &act, NULL);\n    kill(getpid(),sig);\n}\n\n/* ==================== Logging functions for debugging ===================== */\n\nvoid serverLogHexDump(int level, char *descr, void *value, size_t len) {\n    char buf[65], *b;\n    unsigned char *v = value;\n    char charset[] = \"0123456789abcdef\";\n\n    serverLog(level,\"%s (hexdump of %zu bytes):\", descr, len);\n    b = buf;\n    while(len) {\n        b[0] = charset[(*v)>>4];\n        b[1] = charset[(*v)&0xf];\n        b[2] = '\\0';\n        b += 2;\n        len--;\n        v++;\n        if (b-buf == 64 || len == 0) {\n            serverLogRaw(level|LL_RAW,buf);\n            b = buf;\n        }\n    }\n    serverLogRaw(level|LL_RAW,\"\\n\");\n}\n\n/* =========================== Software Watchdog ============================ */\n#include <sys/time.h>\n\nvoid watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}\n\n/* Schedule a SIGALRM delivery after the specified period in milliseconds.\n * If a timer is already scheduled, this function will re-schedule it to the\n * specified time. If period is 0 the current timer is disabled. */\nvoid watchdogScheduleSignal(int period) {\n    struct itimerval it;\n\n    /* Will stop the timer if period is 0. */\n    it.it_value.tv_sec = period/1000;\n    it.it_value.tv_usec = (period%1000)*1000;\n    /* Don't automatically restart. */\n    it.it_interval.tv_sec = 0;\n    it.it_interval.tv_usec = 0;\n    setitimer(ITIMER_REAL, &it, NULL);\n}\nvoid applyWatchdogPeriod() {\n    struct sigaction act;\n\n    /* Disable watchdog when period is 0 */\n    if (server.watchdog_period == 0) {\n        watchdogScheduleSignal(0); /* Stop the current timer. */\n\n        /* Set the signal handler to SIG_IGN, this will also remove pending\n         * signals from the queue. */\n        sigemptyset(&act.sa_mask);\n        act.sa_flags = 0;\n        act.sa_handler = SIG_IGN;\n        sigaction(SIGALRM, &act, NULL);\n    } else {\n        /* Setup the signal handler. */\n        sigemptyset(&act.sa_mask);\n        act.sa_flags = SA_SIGINFO;\n        act.sa_sigaction = watchdogSignalHandler;\n        sigaction(SIGALRM, &act, NULL);\n\n        /* If the configured period is smaller than twice the timer period, it is\n         * too short for the software watchdog to work reliably. Fix it now\n         * if needed. */\n        int min_period = (1000/server.hz)*2;\n        if (server.watchdog_period < min_period) server.watchdog_period = min_period;\n        watchdogScheduleSignal(server.watchdog_period); /* Adjust the current timer. */\n    }\n}\n\n/* Positive input is sleep time in microseconds. Negative input is fractions\n * of microseconds, i.e. -10 means 100 nanoseconds. */\nvoid debugDelay(int usec) {\n    /* Since even the shortest sleep results in context switch and system call,\n     * the way we achieve short sleeps is by statistically sleeping less often. */\n    if (usec < 0) usec = (rand() % -usec) == 0 ? 1: 0;\n    if (usec) usleep(usec);\n}\n"], "filenames": ["src/debug.c"], "buggy_code_start_loc": [1126], "buggy_code_end_loc": [2083], "fixing_code_start_loc": [1126], "fixing_code_end_loc": [2119], "type": "CWE-404", "message": "** DISPUTED ** A vulnerability, which was classified as problematic, was found in Redis. Affected is the function sigsegvHandler of the file debug.c of the component Crash Report. The manipulation leads to denial of service. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this vulnerability. NOTE: The vendor claims that this is not a DoS because it applies to the crash logging mechanism which is triggered after a crash has occurred.", "other": {"cve": {"id": "CVE-2022-3647", "sourceIdentifier": "cna@vuldb.com", "published": "2022-10-21T18:15:10.183", "lastModified": "2022-11-29T16:22:24.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A vulnerability, which was classified as problematic, was found in Redis. Affected is the function sigsegvHandler of the file debug.c of the component Crash Report. The manipulation leads to denial of service. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this vulnerability. NOTE: The vendor claims that this is not a DoS because it applies to the crash logging mechanism which is triggered after a crash has occurred."}, {"lang": "es", "value": "** EN DISPUTA ** Se ha encontrado una vulnerabilidad, clasificada como problem\u00e1tica, en Redis. La funci\u00f3n afectada es sigsegvHandler del archivo debug.c del componente Crash Report. La manipulaci\u00f3n conlleva a una denegaci\u00f3n de servicio. El nombre del parche es 0bf90d944313919eb8e63d3588bf63a367f020a3. Es recomendado aplicar un parche para corregir este problema. VDB-211962 es el identificador asignado a esta vulnerabilidad. NOTA: El proveedor afirma que esto no es un DoS porque se aplica al mecanismo de registro de fallos que se activa despu\u00e9s de que se haya producido un fallo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-09-29", "matchCriteriaId": "1A9E9EB4-7E92-4672-B9C7-35C22F5D6B50"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.211962", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3"}}