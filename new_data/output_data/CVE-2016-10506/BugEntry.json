{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param   p_cp        the coding parameters to modify\n * @param   p_tileno    the tile index being concerned.\n * @param   p_tx0       X0 parameter for the tile\n * @param   p_tx1       X1 parameter for the tile\n * @param   p_ty0       Y0 parameter for the tile\n * @param   p_ty1       Y1 parameter for the tile\n * @param   p_max_prec  the maximum precision for all the bands of the tile\n * @param   p_max_res   the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param   p_cp        the coding parameters to modify\n * @param   p_num_comps     the number of components\n * @param   p_tileno    the tile index being concerned.\n * @param   p_tx0       X0 parameter for the tile\n * @param   p_tx1       X1 parameter for the tile\n * @param   p_ty0       Y0 parameter for the tile\n * @param   p_ty1       Y1 parameter for the tile\n * @param   p_max_prec  the maximum precision for all the bands of the tile\n * @param   p_max_res   the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc(opj_cp_t *p_cp,\n        OPJ_UINT32 p_num_comps,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n *\n * @param   p_image         the image being encoded.\n * @param   p_cp            the coding parameters.\n * @param   tileno          the tile index of the tile being encoded.\n * @param   p_tx0           pointer that will hold the X0 parameter for the tile\n * @param   p_tx1           pointer that will hold the X1 parameter for the tile\n * @param   p_ty0           pointer that will hold the Y0 parameter for the tile\n * @param   p_ty1           pointer that will hold the Y1 parameter for the tile\n * @param   p_max_prec      pointer that will hold the maximum precision for all the bands of the tile\n * @param   p_max_res       pointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min            pointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min            pointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res);\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param   p_image         the image being encoded.\n * @param   p_cp            the coding parameters.\n * @param   tileno          the tile index of the tile being encoded.\n * @param   p_tx0           pointer that will hold the X0 parameter for the tile\n * @param   p_tx1           pointer that will hold the X1 parameter for the tile\n * @param   p_ty0           pointer that will hold the Y0 parameter for the tile\n * @param   p_ty1           pointer that will hold the Y1 parameter for the tile\n * @param   p_max_prec      pointer that will hold the maximum precision for all the bands of the tile\n * @param   p_max_res       pointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        pointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        pointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n * @param   p_resolutions   pointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno,\n        OPJ_INT32 * p_tx0,\n        OPJ_INT32 * p_tx1,\n        OPJ_INT32 * p_ty0,\n        OPJ_INT32 * p_ty1,\n        OPJ_UINT32 * p_dx_min,\n        OPJ_UINT32 * p_dy_min,\n        OPJ_UINT32 * p_max_prec,\n        OPJ_UINT32 * p_max_res,\n        OPJ_UINT32 ** p_resolutions);\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n *\n * @param   p_image     the image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param   p_cp        the coding parameters.\n * @param   tileno  the index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc(opj_pi_iterator_t * p_pi,\n        opj_tcp_t * p_tcp,\n        OPJ_UINT32 p_max_precision,\n        OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc(opj_pi_iterator_t * p_pi,\n                                     opj_tcp_t * p_tcp,\n                                     OPJ_UINT32 p_max_precision,\n                                     OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nstatic OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos,\n                                        opj_cp_t *cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_UINT32 pino,\n                                        const OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        OPJ_UINT32 compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                OPJ_UINT32 dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32  trx1, try1;\n                    OPJ_UINT32  rpx, rpy;\n                    OPJ_INT32  prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        OPJ_UINT32 compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                OPJ_UINT32 dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32 trx1, try1;\n                    OPJ_UINT32 rpx, rpy;\n                    OPJ_INT32 prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        OPJ_UINT32 resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            OPJ_UINT32 dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32 trx1, try1;\n                    OPJ_UINT32 rpx, rpy;\n                    OPJ_INT32 prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}\n\n\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno,\n        OPJ_INT32 * p_tx0,\n        OPJ_INT32 * p_tx1,\n        OPJ_INT32 * p_ty0,\n        OPJ_INT32 * p_ty1,\n        OPJ_UINT32 * p_dx_min,\n        OPJ_UINT32 * p_dy_min,\n        OPJ_UINT32 * p_max_prec,\n        OPJ_UINT32 * p_max_res,\n        OPJ_UINT32 ** p_resolutions)\n{\n    /* loop*/\n    OPJ_UINT32 compno, resno;\n\n    /* pointers*/\n    const opj_tcp_t *tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* to store l_dx, l_dy, w and h for each resolution and component.*/\n    OPJ_UINT32 * lResolutionPtr;\n\n    /* position in x and y of tile*/\n    OPJ_UINT32 p, q;\n\n    /* non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    tcp = &p_cp->tcps [tileno];\n    l_tccp = tcp->tccps;\n    l_img_comp = p_image->comps;\n\n    /* position in x and y of tile*/\n    p = tileno % p_cp->tw;\n    q = tileno / p_cp->tw;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n    l_tx0 = p_cp->tx0 + p *\n            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n    l_ty0 = p_cp->ty0 + q *\n            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n    /* max precision and resolution is 0 (can only grow)*/\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min*/\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* aritmetic variables to calculate*/\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n        OPJ_UINT32 l_pdx, l_pdy, l_pw, l_ph;\n\n        lResolutionPtr = p_resolutions[compno];\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts*/\n        l_level_no = l_tccp->numresolutions;\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            --l_level_no;\n\n            /* precinct width and height*/\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            *lResolutionPtr++ = l_pdx;\n            *lResolutionPtr++ = l_pdy;\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n            /* take the minimum size for l_dx for each comp and resolution*/\n            *p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32) * p_dx_min, (OPJ_INT32)l_dx);\n            *p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32) * p_dy_min, (OPJ_INT32)l_dy);\n\n            /* various calculations of extents*/\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n            *lResolutionPtr++ = l_pw;\n            *lResolutionPtr++ = l_ph;\n            l_product = l_pw * l_ph;\n\n            /* update precision*/\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n\n        }\n        ++l_tccp;\n        ++l_img_comp;\n    }\n}\n\nstatic opj_pi_iterator_t * opj_pi_create(const opj_image_t *image,\n        const opj_cp_t *cp,\n        OPJ_UINT32 tileno)\n{\n    /* loop*/\n    OPJ_UINT32 pino, compno;\n    /* number of poc in the p_pi*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* pointers to tile coding parameters and components.*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *tcp = 00;\n    const opj_tccp_t *tccp = 00;\n\n    /* current packet iterator being allocated*/\n    opj_pi_iterator_t *l_current_pi = 00;\n\n    /* preconditions in debug*/\n    assert(cp != 00);\n    assert(image != 00);\n    assert(tileno < cp->tw * cp->th);\n\n    /* initializations*/\n    tcp = &cp->tcps[tileno];\n    l_poc_bound = tcp->numpocs + 1;\n\n    /* memory allocations*/\n    l_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound),\n                                           sizeof(opj_pi_iterator_t));\n    if (!l_pi) {\n        return NULL;\n    }\n\n    l_current_pi = l_pi;\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n\n        l_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps,\n                              sizeof(opj_pi_comp_t));\n        if (! l_current_pi->comps) {\n            opj_pi_destroy(l_pi, l_poc_bound);\n            return NULL;\n        }\n\n        l_current_pi->numcomps = image->numcomps;\n\n        for (compno = 0; compno < image->numcomps; ++compno) {\n            opj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n            tccp = &tcp->tccps[compno];\n\n            comp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions,\n                                sizeof(opj_pi_resolution_t));\n            if (!comp->resolutions) {\n                opj_pi_destroy(l_pi, l_poc_bound);\n                return 00;\n            }\n\n            comp->numresolutions = tccp->numresolutions;\n        }\n        ++l_current_pi;\n    }\n    return l_pi;\n}\n\nstatic void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    /* tile coding parameter*/\n    opj_tcp_t *l_tcp = 00;\n    /* current poc being updated*/\n    opj_poc_t * l_current_poc = 00;\n\n    /* number of pocs*/\n    OPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps [p_tileno];\n    /* number of iterations in the loop */\n    l_poc_bound = l_tcp->numpocs + 1;\n\n    /* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n       store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n    l_current_poc = l_tcp->pocs;\n\n    l_current_poc->compS = l_current_poc->compno0;\n    l_current_poc->compE = l_current_poc->compno1;\n    l_current_poc->resS = l_current_poc->resno0;\n    l_current_poc->resE = l_current_poc->resno1;\n    l_current_poc->layE = l_current_poc->layno1;\n\n    /* special treatment for the first element*/\n    l_current_poc->layS = 0;\n    l_current_poc->prg  = l_current_poc->prg1;\n    l_current_poc->prcS = 0;\n\n    l_current_poc->prcE = p_max_prec;\n    l_current_poc->txS = (OPJ_UINT32)p_tx0;\n    l_current_poc->txE = (OPJ_UINT32)p_tx1;\n    l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n    l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n    l_current_poc->dx = p_dx_min;\n    l_current_poc->dy = p_dy_min;\n\n    ++ l_current_poc;\n    for (pino = 1; pino < l_poc_bound ; ++pino) {\n        l_current_poc->compS = l_current_poc->compno0;\n        l_current_poc->compE = l_current_poc->compno1;\n        l_current_poc->resS = l_current_poc->resno0;\n        l_current_poc->resE = l_current_poc->resno1;\n        l_current_poc->layE = l_current_poc->layno1;\n        l_current_poc->prg  = l_current_poc->prg1;\n        l_current_poc->prcS = 0;\n        /* special treatment here different from the first element*/\n        l_current_poc->layS = (l_current_poc->layE > (l_current_poc - 1)->layE) ?\n                              l_current_poc->layE : 0;\n\n        l_current_poc->prcE = p_max_prec;\n        l_current_poc->txS = (OPJ_UINT32)p_tx0;\n        l_current_poc->txE = (OPJ_UINT32)p_tx1;\n        l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n        l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n        l_current_poc->dx = p_dx_min;\n        l_current_poc->dy = p_dy_min;\n        ++ l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_encode_not_poc(opj_cp_t *p_cp,\n        OPJ_UINT32 p_num_comps,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    /* tile coding parameter*/\n    opj_tcp_t *l_tcp = 00;\n    /* current poc being updated*/\n    opj_poc_t * l_current_poc = 00;\n    /* number of pocs*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps [p_tileno];\n\n    /* number of iterations in the loop */\n    l_poc_bound = l_tcp->numpocs + 1;\n\n    /* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n       store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n    l_current_poc = l_tcp->pocs;\n\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n        l_current_poc->compS = 0;\n        l_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n        l_current_poc->resS = 0;\n        l_current_poc->resE = p_max_res;\n        l_current_poc->layS = 0;\n        l_current_poc->layE = l_tcp->numlayers;\n        l_current_poc->prg  = l_tcp->prg;\n        l_current_poc->prcS = 0;\n        l_current_poc->prcE = p_max_prec;\n        l_current_poc->txS = (OPJ_UINT32)p_tx0;\n        l_current_poc->txE = (OPJ_UINT32)p_tx1;\n        l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n        l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n        l_current_poc->dx = p_dx_min;\n        l_current_poc->dy = p_dy_min;\n        ++ l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_decode_poc(opj_pi_iterator_t * p_pi,\n                                     opj_tcp_t * p_tcp,\n                                     OPJ_UINT32 p_max_precision,\n                                     OPJ_UINT32 p_max_res)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_bound;\n\n    opj_pi_iterator_t * l_current_pi = 00;\n    opj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n    /* preconditions in debug*/\n    assert(p_pi != 00);\n    assert(p_tcp != 00);\n\n    /* initializations*/\n    l_bound = p_tcp->numpocs + 1;\n    l_current_pi = p_pi;\n    l_current_poc = p_tcp->pocs;\n\n    for (pino = 0; pino < l_bound; ++pino) {\n        l_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n        l_current_pi->first = 1;\n\n        l_current_pi->poc.resno0 =\n            l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n        l_current_pi->poc.compno0 =\n            l_current_poc->compno0; /* Component Index #0 (Start) */\n        l_current_pi->poc.layno0 = 0;\n        l_current_pi->poc.precno0 = 0;\n        l_current_pi->poc.resno1 =\n            l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n        l_current_pi->poc.compno1 =\n            l_current_poc->compno1; /* Component Index #0 (End) */\n        l_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n        l_current_pi->poc.precno1 = p_max_precision;\n        ++l_current_pi;\n        ++l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_decode_not_poc(opj_pi_iterator_t * p_pi,\n        opj_tcp_t * p_tcp,\n        OPJ_UINT32 p_max_precision,\n        OPJ_UINT32 p_max_res)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_bound;\n\n    opj_pi_iterator_t * l_current_pi = 00;\n    /* preconditions in debug*/\n    assert(p_tcp != 00);\n    assert(p_pi != 00);\n\n    /* initializations*/\n    l_bound = p_tcp->numpocs + 1;\n    l_current_pi = p_pi;\n\n    for (pino = 0; pino < l_bound; ++pino) {\n        l_current_pi->poc.prg = p_tcp->prg;\n        l_current_pi->first = 1;\n        l_current_pi->poc.resno0 = 0;\n        l_current_pi->poc.compno0 = 0;\n        l_current_pi->poc.layno0 = 0;\n        l_current_pi->poc.precno0 = 0;\n        l_current_pi->poc.resno1 = p_max_res;\n        l_current_pi->poc.compno1 = l_current_pi->numcomps;\n        l_current_pi->poc.layno1 = p_tcp->numlayers;\n        l_current_pi->poc.precno1 = p_max_precision;\n        ++l_current_pi;\n    }\n}\n\n\n\nstatic OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos,\n                                        opj_cp_t *cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_UINT32 pino,\n                                        const OPJ_CHAR *prog)\n{\n    OPJ_INT32 i;\n    opj_tcp_t *tcps = &cp->tcps[tileno];\n    opj_poc_t *tcp = &tcps->pocs[pino];\n\n    if (pos >= 0) {\n        for (i = pos; pos >= 0; i--) {\n            switch (prog[i]) {\n            case 'R':\n                if (tcp->res_t == tcp->resE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'C':\n                if (tcp->comp_t == tcp->compE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'L':\n                if (tcp->lay_t == tcp->layE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'P':\n                switch (tcp->prg) {\n                case OPJ_LRCP: /* fall through */\n                case OPJ_RLCP:\n                    if (tcp->prc_t == tcp->prcE) {\n                        if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                            return OPJ_TRUE;\n                        } else {\n                            return OPJ_FALSE;\n                        }\n                    } else {\n                        return OPJ_TRUE;\n                    }\n                    break;\n                default:\n                    if (tcp->tx0_t == tcp->txE) {\n                        /*TY*/\n                        if (tcp->ty0_t == tcp->tyE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                return OPJ_TRUE;\n                            } else {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            return OPJ_TRUE;\n                        }/*TY*/\n                    } else {\n                        return OPJ_TRUE;\n                    }\n                    break;\n                }/*end case P*/\n            }/*end switch*/\n        }/*end for*/\n    }/*end if*/\n    return OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no)\n{\n    /* loop */\n    OPJ_UINT32 pino;\n    OPJ_UINT32 compno, resno;\n\n    /* to store w, h, dx and dy fro all components and resolutions */\n    OPJ_UINT32 * l_tmp_data;\n    OPJ_UINT32 ** l_tmp_ptr;\n\n    /* encoding prameters to set */\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n    OPJ_UINT32 l_bound;\n    OPJ_UINT32 l_step_p, l_step_c, l_step_r, l_step_l ;\n    OPJ_UINT32 l_data_stride;\n\n    /* pointers */\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t *l_tccp = 00;\n    opj_pi_comp_t *l_current_comp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_pi_iterator_t * l_current_pi = 00;\n    OPJ_UINT32 * l_encoding_value_ptr = 00;\n\n    /* preconditions in debug */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps[p_tile_no];\n    l_bound = l_tcp->numpocs + 1;\n\n    l_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n    l_tmp_data = (OPJ_UINT32*)opj_malloc(\n                     l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n    if\n    (! l_tmp_data) {\n        return 00;\n    }\n    l_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n                    p_image->numcomps * sizeof(OPJ_UINT32 *));\n    if\n    (! l_tmp_ptr) {\n        opj_free(l_tmp_data);\n        return 00;\n    }\n\n    /* memory allocation for pi */\n    l_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n    if (!l_pi) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        return 00;\n    }\n\n    l_encoding_value_ptr = l_tmp_data;\n    /* update pointer array */\n    for\n    (compno = 0; compno < p_image->numcomps; ++compno) {\n        l_tmp_ptr[compno] = l_encoding_value_ptr;\n        l_encoding_value_ptr += l_data_stride;\n    }\n    /* get encoding parameters */\n    opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1,\n                                    &l_ty0, &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res, l_tmp_ptr);\n\n    /* step calculations */\n    l_step_p = 1;\n    l_step_c = l_max_prec * l_step_p;\n    l_step_r = p_image->numcomps * l_step_c;\n    l_step_l = l_max_res * l_step_r;\n\n    /* set values for first packet iterator */\n    l_current_pi = l_pi;\n\n    /* memory allocation for include */\n    /* prevent an integer overflow issue */\n    /* 0 < l_tcp->numlayers < 65536 c.f. opj_j2k_read_cod in j2k.c */\n    l_current_pi->include = 00;\n    if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U))) {\n        l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(\n                                    l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));\n    }\n\n    if (!l_current_pi->include) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        opj_pi_destroy(l_pi, l_bound);\n        return 00;\n    }\n\n    /* special treatment for the first packet iterator */\n    l_current_comp = l_current_pi->comps;\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    l_current_pi->tx0 = l_tx0;\n    l_current_pi->ty0 = l_ty0;\n    l_current_pi->tx1 = l_tx1;\n    l_current_pi->ty1 = l_ty1;\n\n    /*l_current_pi->dx = l_img_comp->dx;*/\n    /*l_current_pi->dy = l_img_comp->dy;*/\n\n    l_current_pi->step_p = l_step_p;\n    l_current_pi->step_c = l_step_c;\n    l_current_pi->step_r = l_step_r;\n    l_current_pi->step_l = l_step_l;\n\n    /* allocation for components and number of components has already been calculated by opj_pi_create */\n    for\n    (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n        opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n        l_encoding_value_ptr = l_tmp_ptr[compno];\n\n        l_current_comp->dx = l_img_comp->dx;\n        l_current_comp->dy = l_img_comp->dy;\n        /* resolutions have already been initialized */\n        for\n        (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n            l_res->pdx = *(l_encoding_value_ptr++);\n            l_res->pdy = *(l_encoding_value_ptr++);\n            l_res->pw =  *(l_encoding_value_ptr++);\n            l_res->ph =  *(l_encoding_value_ptr++);\n            ++l_res;\n        }\n        ++l_current_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n    ++l_current_pi;\n\n    for (pino = 1 ; pino < l_bound ; ++pino) {\n        l_current_comp = l_current_pi->comps;\n        l_img_comp = p_image->comps;\n        l_tccp = l_tcp->tccps;\n\n        l_current_pi->tx0 = l_tx0;\n        l_current_pi->ty0 = l_ty0;\n        l_current_pi->tx1 = l_tx1;\n        l_current_pi->ty1 = l_ty1;\n        /*l_current_pi->dx = l_dx_min;*/\n        /*l_current_pi->dy = l_dy_min;*/\n        l_current_pi->step_p = l_step_p;\n        l_current_pi->step_c = l_step_c;\n        l_current_pi->step_r = l_step_r;\n        l_current_pi->step_l = l_step_l;\n\n        /* allocation for components and number of components has already been calculated by opj_pi_create */\n        for\n        (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n            opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n            l_encoding_value_ptr = l_tmp_ptr[compno];\n\n            l_current_comp->dx = l_img_comp->dx;\n            l_current_comp->dy = l_img_comp->dy;\n            /* resolutions have already been initialized */\n            for\n            (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n                l_res->pdx = *(l_encoding_value_ptr++);\n                l_res->pdy = *(l_encoding_value_ptr++);\n                l_res->pw =  *(l_encoding_value_ptr++);\n                l_res->ph =  *(l_encoding_value_ptr++);\n                ++l_res;\n            }\n            ++l_current_comp;\n            ++l_img_comp;\n            ++l_tccp;\n        }\n        /* special treatment*/\n        l_current_pi->include = (l_current_pi - 1)->include;\n        ++l_current_pi;\n    }\n    opj_free(l_tmp_data);\n    l_tmp_data = 00;\n    opj_free(l_tmp_ptr);\n    l_tmp_ptr = 00;\n    if\n    (l_tcp->POC) {\n        opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);\n    } else {\n        opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);\n    }\n    return l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n        opj_cp_t *p_cp,\n        OPJ_UINT32 p_tile_no,\n        J2K_T2_MODE p_t2_mode)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    OPJ_UINT32 compno, resno;\n\n    /* to store w, h, dx and dy fro all components and resolutions*/\n    OPJ_UINT32 * l_tmp_data;\n    OPJ_UINT32 ** l_tmp_ptr;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n    OPJ_UINT32 l_bound;\n    OPJ_UINT32 l_step_p, l_step_c, l_step_r, l_step_l ;\n    OPJ_UINT32 l_data_stride;\n\n    /* pointers*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t *l_tccp = 00;\n    opj_pi_comp_t *l_current_comp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_pi_iterator_t * l_current_pi = 00;\n    OPJ_UINT32 * l_encoding_value_ptr = 00;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps[p_tile_no];\n    l_bound = l_tcp->numpocs + 1;\n\n    l_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n    l_tmp_data = (OPJ_UINT32*)opj_malloc(\n                     l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n    if (! l_tmp_data) {\n        return 00;\n    }\n\n    l_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n                    p_image->numcomps * sizeof(OPJ_UINT32 *));\n    if (! l_tmp_ptr) {\n        opj_free(l_tmp_data);\n        return 00;\n    }\n\n    /* memory allocation for pi*/\n    l_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n    if (!l_pi) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        return 00;\n    }\n\n    l_encoding_value_ptr = l_tmp_data;\n    /* update pointer array*/\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        l_tmp_ptr[compno] = l_encoding_value_ptr;\n        l_encoding_value_ptr += l_data_stride;\n    }\n\n    /* get encoding parameters*/\n    opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1,\n                                    &l_ty0, &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res, l_tmp_ptr);\n\n    /* step calculations*/\n    l_step_p = 1;\n    l_step_c = l_max_prec * l_step_p;\n    l_step_r = p_image->numcomps * l_step_c;\n    l_step_l = l_max_res * l_step_r;\n\n    /* set values for first packet iterator*/\n    l_pi->tp_on = (OPJ_BYTE)p_cp->m_specific_param.m_enc.m_tp_on;\n    l_current_pi = l_pi;\n\n    /* memory allocation for include*/\n    l_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l,\n                            sizeof(OPJ_INT16));\n    if (!l_current_pi->include) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        opj_pi_destroy(l_pi, l_bound);\n        return 00;\n    }\n\n    /* special treatment for the first packet iterator*/\n    l_current_comp = l_current_pi->comps;\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n    l_current_pi->tx0 = l_tx0;\n    l_current_pi->ty0 = l_ty0;\n    l_current_pi->tx1 = l_tx1;\n    l_current_pi->ty1 = l_ty1;\n    l_current_pi->dx = l_dx_min;\n    l_current_pi->dy = l_dy_min;\n    l_current_pi->step_p = l_step_p;\n    l_current_pi->step_c = l_step_c;\n    l_current_pi->step_r = l_step_r;\n    l_current_pi->step_l = l_step_l;\n\n    /* allocation for components and number of components has already been calculated by opj_pi_create */\n    for (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n        opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n        l_encoding_value_ptr = l_tmp_ptr[compno];\n\n        l_current_comp->dx = l_img_comp->dx;\n        l_current_comp->dy = l_img_comp->dy;\n\n        /* resolutions have already been initialized */\n        for (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n            l_res->pdx = *(l_encoding_value_ptr++);\n            l_res->pdy = *(l_encoding_value_ptr++);\n            l_res->pw =  *(l_encoding_value_ptr++);\n            l_res->ph =  *(l_encoding_value_ptr++);\n            ++l_res;\n        }\n\n        ++l_current_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n    ++l_current_pi;\n\n    for (pino = 1 ; pino < l_bound ; ++pino) {\n        l_current_comp = l_current_pi->comps;\n        l_img_comp = p_image->comps;\n        l_tccp = l_tcp->tccps;\n\n        l_current_pi->tx0 = l_tx0;\n        l_current_pi->ty0 = l_ty0;\n        l_current_pi->tx1 = l_tx1;\n        l_current_pi->ty1 = l_ty1;\n        l_current_pi->dx = l_dx_min;\n        l_current_pi->dy = l_dy_min;\n        l_current_pi->step_p = l_step_p;\n        l_current_pi->step_c = l_step_c;\n        l_current_pi->step_r = l_step_r;\n        l_current_pi->step_l = l_step_l;\n\n        /* allocation for components and number of components has already been calculated by opj_pi_create */\n        for (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n            opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n            l_encoding_value_ptr = l_tmp_ptr[compno];\n\n            l_current_comp->dx = l_img_comp->dx;\n            l_current_comp->dy = l_img_comp->dy;\n            /* resolutions have already been initialized */\n            for (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n                l_res->pdx = *(l_encoding_value_ptr++);\n                l_res->pdy = *(l_encoding_value_ptr++);\n                l_res->pw =  *(l_encoding_value_ptr++);\n                l_res->ph =  *(l_encoding_value_ptr++);\n                ++l_res;\n            }\n            ++l_current_comp;\n            ++l_img_comp;\n            ++l_tccp;\n        }\n\n        /* special treatment*/\n        l_current_pi->include = (l_current_pi - 1)->include;\n        ++l_current_pi;\n    }\n\n    opj_free(l_tmp_data);\n    l_tmp_data = 00;\n    opj_free(l_tmp_ptr);\n    l_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,\n                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    } else {\n        opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,\n                                     l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    }\n\n    return l_pi;\n}\n\nvoid opj_pi_create_encode(opj_pi_iterator_t *pi,\n                          opj_cp_t *cp,\n                          OPJ_UINT32 tileno,\n                          OPJ_UINT32 pino,\n                          OPJ_UINT32 tpnum,\n                          OPJ_INT32 tppos,\n                          J2K_T2_MODE t2_mode)\n{\n    const OPJ_CHAR *prog;\n    OPJ_INT32 i;\n    OPJ_UINT32 incr_top = 1, resetX = 0;\n    opj_tcp_t *tcps = &cp->tcps[tileno];\n    opj_poc_t *tcp = &tcps->pocs[pino];\n\n    prog = opj_j2k_convert_progression_order(tcp->prg);\n\n    pi[pino].first = 1;\n    pi[pino].poc.prg = tcp->prg;\n\n    if (!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) &&\n            (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))) {\n        pi[pino].poc.resno0 = tcp->resS;\n        pi[pino].poc.resno1 = tcp->resE;\n        pi[pino].poc.compno0 = tcp->compS;\n        pi[pino].poc.compno1 = tcp->compE;\n        pi[pino].poc.layno0 = tcp->layS;\n        pi[pino].poc.layno1 = tcp->layE;\n        pi[pino].poc.precno0 = tcp->prcS;\n        pi[pino].poc.precno1 = tcp->prcE;\n        pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n        pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n        pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n        pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n    } else {\n        for (i = tppos + 1; i < 4; i++) {\n            switch (prog[i]) {\n            case 'R':\n                pi[pino].poc.resno0 = tcp->resS;\n                pi[pino].poc.resno1 = tcp->resE;\n                break;\n            case 'C':\n                pi[pino].poc.compno0 = tcp->compS;\n                pi[pino].poc.compno1 = tcp->compE;\n                break;\n            case 'L':\n                pi[pino].poc.layno0 = tcp->layS;\n                pi[pino].poc.layno1 = tcp->layE;\n                break;\n            case 'P':\n                switch (tcp->prg) {\n                case OPJ_LRCP:\n                case OPJ_RLCP:\n                    pi[pino].poc.precno0 = tcp->prcS;\n                    pi[pino].poc.precno1 = tcp->prcE;\n                    break;\n                default:\n                    pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n                    pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n                    pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n                    pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n                    break;\n                }\n                break;\n            }\n        }\n\n        if (tpnum == 0) {\n            for (i = tppos; i >= 0; i--) {\n                switch (prog[i]) {\n                case 'C':\n                    tcp->comp_t = tcp->compS;\n                    pi[pino].poc.compno0 = tcp->comp_t;\n                    pi[pino].poc.compno1 = tcp->comp_t + 1;\n                    tcp->comp_t += 1;\n                    break;\n                case 'R':\n                    tcp->res_t = tcp->resS;\n                    pi[pino].poc.resno0 = tcp->res_t;\n                    pi[pino].poc.resno1 = tcp->res_t + 1;\n                    tcp->res_t += 1;\n                    break;\n                case 'L':\n                    tcp->lay_t = tcp->layS;\n                    pi[pino].poc.layno0 = tcp->lay_t;\n                    pi[pino].poc.layno1 = tcp->lay_t + 1;\n                    tcp->lay_t += 1;\n                    break;\n                case 'P':\n                    switch (tcp->prg) {\n                    case OPJ_LRCP:\n                    case OPJ_RLCP:\n                        tcp->prc_t = tcp->prcS;\n                        pi[pino].poc.precno0 = tcp->prc_t;\n                        pi[pino].poc.precno1 = tcp->prc_t + 1;\n                        tcp->prc_t += 1;\n                        break;\n                    default:\n                        tcp->tx0_t = tcp->txS;\n                        tcp->ty0_t = tcp->tyS;\n                        pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                        pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                        pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                        pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                        tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                        tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                        break;\n                    }\n                    break;\n                }\n            }\n            incr_top = 1;\n        } else {\n            for (i = tppos; i >= 0; i--) {\n                switch (prog[i]) {\n                case 'C':\n                    pi[pino].poc.compno0 = tcp->comp_t - 1;\n                    pi[pino].poc.compno1 = tcp->comp_t;\n                    break;\n                case 'R':\n                    pi[pino].poc.resno0 = tcp->res_t - 1;\n                    pi[pino].poc.resno1 = tcp->res_t;\n                    break;\n                case 'L':\n                    pi[pino].poc.layno0 = tcp->lay_t - 1;\n                    pi[pino].poc.layno1 = tcp->lay_t;\n                    break;\n                case 'P':\n                    switch (tcp->prg) {\n                    case OPJ_LRCP:\n                    case OPJ_RLCP:\n                        pi[pino].poc.precno0 = tcp->prc_t - 1;\n                        pi[pino].poc.precno1 = tcp->prc_t;\n                        break;\n                    default:\n                        pi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n                        pi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n                        pi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n                        pi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n                        break;\n                    }\n                    break;\n                }\n                if (incr_top == 1) {\n                    switch (prog[i]) {\n                    case 'R':\n                        if (tcp->res_t == tcp->resE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->res_t = tcp->resS;\n                                pi[pino].poc.resno0 = tcp->res_t;\n                                pi[pino].poc.resno1 = tcp->res_t + 1;\n                                tcp->res_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.resno0 = tcp->res_t;\n                            pi[pino].poc.resno1 = tcp->res_t + 1;\n                            tcp->res_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'C':\n                        if (tcp->comp_t == tcp->compE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->comp_t = tcp->compS;\n                                pi[pino].poc.compno0 = tcp->comp_t;\n                                pi[pino].poc.compno1 = tcp->comp_t + 1;\n                                tcp->comp_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.compno0 = tcp->comp_t;\n                            pi[pino].poc.compno1 = tcp->comp_t + 1;\n                            tcp->comp_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'L':\n                        if (tcp->lay_t == tcp->layE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->lay_t = tcp->layS;\n                                pi[pino].poc.layno0 = tcp->lay_t;\n                                pi[pino].poc.layno1 = tcp->lay_t + 1;\n                                tcp->lay_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.layno0 = tcp->lay_t;\n                            pi[pino].poc.layno1 = tcp->lay_t + 1;\n                            tcp->lay_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'P':\n                        switch (tcp->prg) {\n                        case OPJ_LRCP:\n                        case OPJ_RLCP:\n                            if (tcp->prc_t == tcp->prcE) {\n                                if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                    tcp->prc_t = tcp->prcS;\n                                    pi[pino].poc.precno0 = tcp->prc_t;\n                                    pi[pino].poc.precno1 = tcp->prc_t + 1;\n                                    tcp->prc_t += 1;\n                                    incr_top = 1;\n                                } else {\n                                    incr_top = 0;\n                                }\n                            } else {\n                                pi[pino].poc.precno0 = tcp->prc_t;\n                                pi[pino].poc.precno1 = tcp->prc_t + 1;\n                                tcp->prc_t += 1;\n                                incr_top = 0;\n                            }\n                            break;\n                        default:\n                            if (tcp->tx0_t >= tcp->txE) {\n                                if (tcp->ty0_t >= tcp->tyE) {\n                                    if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                        tcp->ty0_t = tcp->tyS;\n                                        pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                                        pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                                        tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                                        incr_top = 1;\n                                        resetX = 1;\n                                    } else {\n                                        incr_top = 0;\n                                        resetX = 0;\n                                    }\n                                } else {\n                                    pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                                    pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                                    tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                                    incr_top = 0;\n                                    resetX = 1;\n                                }\n                                if (resetX == 1) {\n                                    tcp->tx0_t = tcp->txS;\n                                    pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                                    pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                                    tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                                }\n                            } else {\n                                pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                                pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                                tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                                incr_top = 0;\n                            }\n                            break;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n    OPJ_UINT32 compno, pino;\n    opj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n        if (p_pi->include) {\n            opj_free(p_pi->include);\n            p_pi->include = 00;\n        }\n        for (pino = 0; pino < p_nb_elements; ++pino) {\n            if (l_current_pi->comps) {\n                opj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++) {\n                    if (l_current_component->resolutions) {\n                        opj_free(l_current_component->resolutions);\n                        l_current_component->resolutions = 00;\n                    }\n\n                    ++l_current_component;\n                }\n                opj_free(l_current_pi->comps);\n                l_current_pi->comps = 0;\n            }\n            ++l_current_pi;\n        }\n        opj_free(p_pi);\n    }\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(const opj_image_t *p_image,\n                                       opj_cp_t *p_cp,\n                                       OPJ_UINT32 p_tile_no)\n{\n    /* encoding parameters to set */\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n\n    /* pointers */\n    opj_tcp_t *l_tcp = 00;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    l_tcp = &(p_cp->tcps[p_tile_no]);\n\n    /* get encoding parameters */\n    opj_get_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1, &l_ty0,\n                                &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res);\n\n    if (l_tcp->POC) {\n        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,\n                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    } else {\n        opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,\n                                     l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    }\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi)\n{\n    switch (pi->poc.prg) {\n    case OPJ_LRCP:\n        return opj_pi_next_lrcp(pi);\n    case OPJ_RLCP:\n        return opj_pi_next_rlcp(pi);\n    case OPJ_RPCL:\n        return opj_pi_next_rpcl(pi);\n    case OPJ_PCRL:\n        return opj_pi_next_pcrl(pi);\n    case OPJ_CPRL:\n        return opj_pi_next_cprl(pi);\n    case OPJ_PROG_UNKNOWN:\n        return OPJ_FALSE;\n    }\n\n    return OPJ_FALSE;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param   p_cp        the coding parameters to modify\n * @param   p_tileno    the tile index being concerned.\n * @param   p_tx0       X0 parameter for the tile\n * @param   p_tx1       X1 parameter for the tile\n * @param   p_ty0       Y0 parameter for the tile\n * @param   p_ty1       Y1 parameter for the tile\n * @param   p_max_prec  the maximum precision for all the bands of the tile\n * @param   p_max_res   the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param   p_cp        the coding parameters to modify\n * @param   p_num_comps     the number of components\n * @param   p_tileno    the tile index being concerned.\n * @param   p_tx0       X0 parameter for the tile\n * @param   p_tx1       X1 parameter for the tile\n * @param   p_ty0       Y0 parameter for the tile\n * @param   p_ty1       Y1 parameter for the tile\n * @param   p_max_prec  the maximum precision for all the bands of the tile\n * @param   p_max_res   the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc(opj_cp_t *p_cp,\n        OPJ_UINT32 p_num_comps,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n *\n * @param   p_image         the image being encoded.\n * @param   p_cp            the coding parameters.\n * @param   tileno          the tile index of the tile being encoded.\n * @param   p_tx0           pointer that will hold the X0 parameter for the tile\n * @param   p_tx1           pointer that will hold the X1 parameter for the tile\n * @param   p_ty0           pointer that will hold the Y0 parameter for the tile\n * @param   p_ty1           pointer that will hold the Y1 parameter for the tile\n * @param   p_max_prec      pointer that will hold the maximum precision for all the bands of the tile\n * @param   p_max_res       pointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min            pointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min            pointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res);\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param   p_image         the image being encoded.\n * @param   p_cp            the coding parameters.\n * @param   tileno          the tile index of the tile being encoded.\n * @param   p_tx0           pointer that will hold the X0 parameter for the tile\n * @param   p_tx1           pointer that will hold the X1 parameter for the tile\n * @param   p_ty0           pointer that will hold the Y0 parameter for the tile\n * @param   p_ty1           pointer that will hold the Y1 parameter for the tile\n * @param   p_max_prec      pointer that will hold the maximum precision for all the bands of the tile\n * @param   p_max_res       pointer that will hold the maximum number of resolutions for all the poc inside the tile.\n * @param   p_dx_min        pointer that will hold the minimum dx of all the components of all the resolutions for the tile.\n * @param   p_dy_min        pointer that will hold the minimum dy of all the components of all the resolutions for the tile.\n * @param   p_resolutions   pointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno,\n        OPJ_INT32 * p_tx0,\n        OPJ_INT32 * p_tx1,\n        OPJ_INT32 * p_ty0,\n        OPJ_INT32 * p_ty1,\n        OPJ_UINT32 * p_dx_min,\n        OPJ_UINT32 * p_dy_min,\n        OPJ_UINT32 * p_max_prec,\n        OPJ_UINT32 * p_max_res,\n        OPJ_UINT32 ** p_resolutions);\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n *\n * @param   p_image     the image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param   p_cp        the coding parameters.\n * @param   tileno  the index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc(opj_pi_iterator_t * p_pi,\n        opj_tcp_t * p_tcp,\n        OPJ_UINT32 p_max_precision,\n        OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc(opj_pi_iterator_t * p_pi,\n                                     opj_tcp_t * p_tcp,\n                                     OPJ_UINT32 p_max_precision,\n                                     OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nstatic OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos,\n                                        opj_cp_t *cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_UINT32 pino,\n                                        const OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        OPJ_UINT32 compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                OPJ_UINT32 dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32  trx1, try1;\n                    OPJ_UINT32  rpx, rpy;\n                    OPJ_INT32  prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    /* in below tests */\n                    /* Fixes reading id:000026,sig:08,src:002419,op:int32,pos:60,val:+32 */\n                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    /* See ISO-15441. B.12.1.3 Resolution level-position-component-layer progression */\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        OPJ_UINT32 compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                OPJ_UINT32 dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32 trx1, try1;\n                    OPJ_UINT32 rpx, rpy;\n                    OPJ_INT32 prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    /* in below tests */\n                    /* Relates to id:000019,sig:08,src:001098,op:flip1,pos:49 */\n                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    /* See ISO-15441. B.12.1.4 Position-component-resolution level-layer progression */\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        OPJ_UINT32 resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            OPJ_UINT32 dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32 trx1, try1;\n                    OPJ_UINT32 rpx, rpy;\n                    OPJ_INT32 prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                    try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    /* in below tests */\n                    /* Fixes reading id:000019,sig:08,src:001098,op:flip1,pos:49 */\n                    /* of https://github.com/uclouvain/openjpeg/issues/938 */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    /* See ISO-15441. B.12.1.5 Component-position-resolution level-layer progression */\n                    if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32  * p_tx1,\n                                        OPJ_INT32  * p_ty0,\n                                        OPJ_INT32  * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res)\n{\n    /* loop */\n    OPJ_UINT32  compno, resno;\n    /* pointers */\n    const opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* position in x and y of tile */\n    OPJ_UINT32 p, q;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps [p_tileno];\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n    p = p_tileno % p_cp->tw;\n    q = p_tileno / p_cp->tw;\n\n    /* find extent of tile */\n    *p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx),\n                         (OPJ_INT32)p_image->x0);\n    *p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx),\n                         (OPJ_INT32)p_image->x1);\n    *p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy),\n                         (OPJ_INT32)p_image->y0);\n    *p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy),\n                         (OPJ_INT32)p_image->y1);\n\n    /* max precision is 0 (can only grow) */\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min */\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min  = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* arithmetic variables to calculate */\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_pdx, l_pdy;\n        OPJ_UINT32 l_pw, l_ph;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts */\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            /* precinct width and height */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n            /* take the minimum size for dx for each comp and resolution */\n            *p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n            *p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n            /* various calculations of extents */\n            l_level_no = l_tccp->numresolutions - 1 - resno;\n\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n            l_product = l_pw * l_ph;\n\n            /* update precision */\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n        }\n        ++l_img_comp;\n        ++l_tccp;\n    }\n}\n\n\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n        const opj_cp_t *p_cp,\n        OPJ_UINT32 tileno,\n        OPJ_INT32 * p_tx0,\n        OPJ_INT32 * p_tx1,\n        OPJ_INT32 * p_ty0,\n        OPJ_INT32 * p_ty1,\n        OPJ_UINT32 * p_dx_min,\n        OPJ_UINT32 * p_dy_min,\n        OPJ_UINT32 * p_max_prec,\n        OPJ_UINT32 * p_max_res,\n        OPJ_UINT32 ** p_resolutions)\n{\n    /* loop*/\n    OPJ_UINT32 compno, resno;\n\n    /* pointers*/\n    const opj_tcp_t *tcp = 00;\n    const opj_tccp_t * l_tccp = 00;\n    const opj_image_comp_t * l_img_comp = 00;\n\n    /* to store l_dx, l_dy, w and h for each resolution and component.*/\n    OPJ_UINT32 * lResolutionPtr;\n\n    /* position in x and y of tile*/\n    OPJ_UINT32 p, q;\n\n    /* non-corrected (in regard to image offset) tile offset */\n    OPJ_UINT32 l_tx0, l_ty0;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    tcp = &p_cp->tcps [tileno];\n    l_tccp = tcp->tccps;\n    l_img_comp = p_image->comps;\n\n    /* position in x and y of tile*/\n    p = tileno % p_cp->tw;\n    q = tileno / p_cp->tw;\n\n    /* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n    l_tx0 = p_cp->tx0 + p *\n            p_cp->tdx; /* can't be greater than p_image->x1 so won't overflow */\n    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);\n    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);\n    l_ty0 = p_cp->ty0 + q *\n            p_cp->tdy; /* can't be greater than p_image->y1 so won't overflow */\n    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);\n    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);\n\n    /* max precision and resolution is 0 (can only grow)*/\n    *p_max_prec = 0;\n    *p_max_res = 0;\n\n    /* take the largest value for dx_min and dy_min*/\n    *p_dx_min = 0x7fffffff;\n    *p_dy_min = 0x7fffffff;\n\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        /* aritmetic variables to calculate*/\n        OPJ_UINT32 l_level_no;\n        OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n        OPJ_INT32 l_px0, l_py0, l_px1, py1;\n        OPJ_UINT32 l_product;\n        OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n        OPJ_UINT32 l_pdx, l_pdy, l_pw, l_ph;\n\n        lResolutionPtr = p_resolutions[compno];\n\n        l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n        l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n        l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n        l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n        if (l_tccp->numresolutions > *p_max_res) {\n            *p_max_res = l_tccp->numresolutions;\n        }\n\n        /* use custom size for precincts*/\n        l_level_no = l_tccp->numresolutions;\n        for (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n            OPJ_UINT32 l_dx, l_dy;\n\n            --l_level_no;\n\n            /* precinct width and height*/\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            *lResolutionPtr++ = l_pdx;\n            *lResolutionPtr++ = l_pdy;\n            l_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n            l_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n            /* take the minimum size for l_dx for each comp and resolution*/\n            *p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32) * p_dx_min, (OPJ_INT32)l_dx);\n            *p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32) * p_dy_min, (OPJ_INT32)l_dy);\n\n            /* various calculations of extents*/\n            l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n            l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n            l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n            l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n            l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n            py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n            l_pw = (l_rx0 == l_rx1) ? 0 : (OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n            l_ph = (l_ry0 == l_ry1) ? 0 : (OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n            *lResolutionPtr++ = l_pw;\n            *lResolutionPtr++ = l_ph;\n            l_product = l_pw * l_ph;\n\n            /* update precision*/\n            if (l_product > *p_max_prec) {\n                *p_max_prec = l_product;\n            }\n\n        }\n        ++l_tccp;\n        ++l_img_comp;\n    }\n}\n\nstatic opj_pi_iterator_t * opj_pi_create(const opj_image_t *image,\n        const opj_cp_t *cp,\n        OPJ_UINT32 tileno)\n{\n    /* loop*/\n    OPJ_UINT32 pino, compno;\n    /* number of poc in the p_pi*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* pointers to tile coding parameters and components.*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *tcp = 00;\n    const opj_tccp_t *tccp = 00;\n\n    /* current packet iterator being allocated*/\n    opj_pi_iterator_t *l_current_pi = 00;\n\n    /* preconditions in debug*/\n    assert(cp != 00);\n    assert(image != 00);\n    assert(tileno < cp->tw * cp->th);\n\n    /* initializations*/\n    tcp = &cp->tcps[tileno];\n    l_poc_bound = tcp->numpocs + 1;\n\n    /* memory allocations*/\n    l_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound),\n                                           sizeof(opj_pi_iterator_t));\n    if (!l_pi) {\n        return NULL;\n    }\n\n    l_current_pi = l_pi;\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n\n        l_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps,\n                              sizeof(opj_pi_comp_t));\n        if (! l_current_pi->comps) {\n            opj_pi_destroy(l_pi, l_poc_bound);\n            return NULL;\n        }\n\n        l_current_pi->numcomps = image->numcomps;\n\n        for (compno = 0; compno < image->numcomps; ++compno) {\n            opj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n            tccp = &tcp->tccps[compno];\n\n            comp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions,\n                                sizeof(opj_pi_resolution_t));\n            if (!comp->resolutions) {\n                opj_pi_destroy(l_pi, l_poc_bound);\n                return 00;\n            }\n\n            comp->numresolutions = tccp->numresolutions;\n        }\n        ++l_current_pi;\n    }\n    return l_pi;\n}\n\nstatic void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    /* tile coding parameter*/\n    opj_tcp_t *l_tcp = 00;\n    /* current poc being updated*/\n    opj_poc_t * l_current_poc = 00;\n\n    /* number of pocs*/\n    OPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps [p_tileno];\n    /* number of iterations in the loop */\n    l_poc_bound = l_tcp->numpocs + 1;\n\n    /* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n       store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n    l_current_poc = l_tcp->pocs;\n\n    l_current_poc->compS = l_current_poc->compno0;\n    l_current_poc->compE = l_current_poc->compno1;\n    l_current_poc->resS = l_current_poc->resno0;\n    l_current_poc->resE = l_current_poc->resno1;\n    l_current_poc->layE = l_current_poc->layno1;\n\n    /* special treatment for the first element*/\n    l_current_poc->layS = 0;\n    l_current_poc->prg  = l_current_poc->prg1;\n    l_current_poc->prcS = 0;\n\n    l_current_poc->prcE = p_max_prec;\n    l_current_poc->txS = (OPJ_UINT32)p_tx0;\n    l_current_poc->txE = (OPJ_UINT32)p_tx1;\n    l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n    l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n    l_current_poc->dx = p_dx_min;\n    l_current_poc->dy = p_dy_min;\n\n    ++ l_current_poc;\n    for (pino = 1; pino < l_poc_bound ; ++pino) {\n        l_current_poc->compS = l_current_poc->compno0;\n        l_current_poc->compE = l_current_poc->compno1;\n        l_current_poc->resS = l_current_poc->resno0;\n        l_current_poc->resE = l_current_poc->resno1;\n        l_current_poc->layE = l_current_poc->layno1;\n        l_current_poc->prg  = l_current_poc->prg1;\n        l_current_poc->prcS = 0;\n        /* special treatment here different from the first element*/\n        l_current_poc->layS = (l_current_poc->layE > (l_current_poc - 1)->layE) ?\n                              l_current_poc->layE : 0;\n\n        l_current_poc->prcE = p_max_prec;\n        l_current_poc->txS = (OPJ_UINT32)p_tx0;\n        l_current_poc->txE = (OPJ_UINT32)p_tx1;\n        l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n        l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n        l_current_poc->dx = p_dx_min;\n        l_current_poc->dy = p_dy_min;\n        ++ l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_encode_not_poc(opj_cp_t *p_cp,\n        OPJ_UINT32 p_num_comps,\n        OPJ_UINT32 p_tileno,\n        OPJ_INT32 p_tx0,\n        OPJ_INT32 p_tx1,\n        OPJ_INT32 p_ty0,\n        OPJ_INT32 p_ty1,\n        OPJ_UINT32 p_max_prec,\n        OPJ_UINT32 p_max_res,\n        OPJ_UINT32 p_dx_min,\n        OPJ_UINT32 p_dy_min)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    /* tile coding parameter*/\n    opj_tcp_t *l_tcp = 00;\n    /* current poc being updated*/\n    opj_poc_t * l_current_poc = 00;\n    /* number of pocs*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_tileno < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps [p_tileno];\n\n    /* number of iterations in the loop */\n    l_poc_bound = l_tcp->numpocs + 1;\n\n    /* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n       store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n    l_current_poc = l_tcp->pocs;\n\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n        l_current_poc->compS = 0;\n        l_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n        l_current_poc->resS = 0;\n        l_current_poc->resE = p_max_res;\n        l_current_poc->layS = 0;\n        l_current_poc->layE = l_tcp->numlayers;\n        l_current_poc->prg  = l_tcp->prg;\n        l_current_poc->prcS = 0;\n        l_current_poc->prcE = p_max_prec;\n        l_current_poc->txS = (OPJ_UINT32)p_tx0;\n        l_current_poc->txE = (OPJ_UINT32)p_tx1;\n        l_current_poc->tyS = (OPJ_UINT32)p_ty0;\n        l_current_poc->tyE = (OPJ_UINT32)p_ty1;\n        l_current_poc->dx = p_dx_min;\n        l_current_poc->dy = p_dy_min;\n        ++ l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_decode_poc(opj_pi_iterator_t * p_pi,\n                                     opj_tcp_t * p_tcp,\n                                     OPJ_UINT32 p_max_precision,\n                                     OPJ_UINT32 p_max_res)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_bound;\n\n    opj_pi_iterator_t * l_current_pi = 00;\n    opj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n    /* preconditions in debug*/\n    assert(p_pi != 00);\n    assert(p_tcp != 00);\n\n    /* initializations*/\n    l_bound = p_tcp->numpocs + 1;\n    l_current_pi = p_pi;\n    l_current_poc = p_tcp->pocs;\n\n    for (pino = 0; pino < l_bound; ++pino) {\n        l_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n        l_current_pi->first = 1;\n\n        l_current_pi->poc.resno0 =\n            l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n        l_current_pi->poc.compno0 =\n            l_current_poc->compno0; /* Component Index #0 (Start) */\n        l_current_pi->poc.layno0 = 0;\n        l_current_pi->poc.precno0 = 0;\n        l_current_pi->poc.resno1 =\n            l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n        l_current_pi->poc.compno1 =\n            l_current_poc->compno1; /* Component Index #0 (End) */\n        l_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n        l_current_pi->poc.precno1 = p_max_precision;\n        ++l_current_pi;\n        ++l_current_poc;\n    }\n}\n\nstatic void opj_pi_update_decode_not_poc(opj_pi_iterator_t * p_pi,\n        opj_tcp_t * p_tcp,\n        OPJ_UINT32 p_max_precision,\n        OPJ_UINT32 p_max_res)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_bound;\n\n    opj_pi_iterator_t * l_current_pi = 00;\n    /* preconditions in debug*/\n    assert(p_tcp != 00);\n    assert(p_pi != 00);\n\n    /* initializations*/\n    l_bound = p_tcp->numpocs + 1;\n    l_current_pi = p_pi;\n\n    for (pino = 0; pino < l_bound; ++pino) {\n        l_current_pi->poc.prg = p_tcp->prg;\n        l_current_pi->first = 1;\n        l_current_pi->poc.resno0 = 0;\n        l_current_pi->poc.compno0 = 0;\n        l_current_pi->poc.layno0 = 0;\n        l_current_pi->poc.precno0 = 0;\n        l_current_pi->poc.resno1 = p_max_res;\n        l_current_pi->poc.compno1 = l_current_pi->numcomps;\n        l_current_pi->poc.layno1 = p_tcp->numlayers;\n        l_current_pi->poc.precno1 = p_max_precision;\n        ++l_current_pi;\n    }\n}\n\n\n\nstatic OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos,\n                                        opj_cp_t *cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_UINT32 pino,\n                                        const OPJ_CHAR *prog)\n{\n    OPJ_INT32 i;\n    opj_tcp_t *tcps = &cp->tcps[tileno];\n    opj_poc_t *tcp = &tcps->pocs[pino];\n\n    if (pos >= 0) {\n        for (i = pos; pos >= 0; i--) {\n            switch (prog[i]) {\n            case 'R':\n                if (tcp->res_t == tcp->resE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'C':\n                if (tcp->comp_t == tcp->compE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'L':\n                if (tcp->lay_t == tcp->layE) {\n                    if (opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog)) {\n                        return OPJ_TRUE;\n                    } else {\n                        return OPJ_FALSE;\n                    }\n                } else {\n                    return OPJ_TRUE;\n                }\n                break;\n            case 'P':\n                switch (tcp->prg) {\n                case OPJ_LRCP: /* fall through */\n                case OPJ_RLCP:\n                    if (tcp->prc_t == tcp->prcE) {\n                        if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                            return OPJ_TRUE;\n                        } else {\n                            return OPJ_FALSE;\n                        }\n                    } else {\n                        return OPJ_TRUE;\n                    }\n                    break;\n                default:\n                    if (tcp->tx0_t == tcp->txE) {\n                        /*TY*/\n                        if (tcp->ty0_t == tcp->tyE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                return OPJ_TRUE;\n                            } else {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            return OPJ_TRUE;\n                        }/*TY*/\n                    } else {\n                        return OPJ_TRUE;\n                    }\n                    break;\n                }/*end case P*/\n            }/*end switch*/\n        }/*end for*/\n    }/*end if*/\n    return OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no)\n{\n    /* loop */\n    OPJ_UINT32 pino;\n    OPJ_UINT32 compno, resno;\n\n    /* to store w, h, dx and dy fro all components and resolutions */\n    OPJ_UINT32 * l_tmp_data;\n    OPJ_UINT32 ** l_tmp_ptr;\n\n    /* encoding prameters to set */\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n    OPJ_UINT32 l_bound;\n    OPJ_UINT32 l_step_p, l_step_c, l_step_r, l_step_l ;\n    OPJ_UINT32 l_data_stride;\n\n    /* pointers */\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t *l_tccp = 00;\n    opj_pi_comp_t *l_current_comp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_pi_iterator_t * l_current_pi = 00;\n    OPJ_UINT32 * l_encoding_value_ptr = 00;\n\n    /* preconditions in debug */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    /* initializations */\n    l_tcp = &p_cp->tcps[p_tile_no];\n    l_bound = l_tcp->numpocs + 1;\n\n    l_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n    l_tmp_data = (OPJ_UINT32*)opj_malloc(\n                     l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n    if\n    (! l_tmp_data) {\n        return 00;\n    }\n    l_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n                    p_image->numcomps * sizeof(OPJ_UINT32 *));\n    if\n    (! l_tmp_ptr) {\n        opj_free(l_tmp_data);\n        return 00;\n    }\n\n    /* memory allocation for pi */\n    l_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n    if (!l_pi) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        return 00;\n    }\n\n    l_encoding_value_ptr = l_tmp_data;\n    /* update pointer array */\n    for\n    (compno = 0; compno < p_image->numcomps; ++compno) {\n        l_tmp_ptr[compno] = l_encoding_value_ptr;\n        l_encoding_value_ptr += l_data_stride;\n    }\n    /* get encoding parameters */\n    opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1,\n                                    &l_ty0, &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res, l_tmp_ptr);\n\n    /* step calculations */\n    l_step_p = 1;\n    l_step_c = l_max_prec * l_step_p;\n    l_step_r = p_image->numcomps * l_step_c;\n    l_step_l = l_max_res * l_step_r;\n\n    /* set values for first packet iterator */\n    l_current_pi = l_pi;\n\n    /* memory allocation for include */\n    /* prevent an integer overflow issue */\n    /* 0 < l_tcp->numlayers < 65536 c.f. opj_j2k_read_cod in j2k.c */\n    l_current_pi->include = 00;\n    if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U))) {\n        l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(\n                                    l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));\n    }\n\n    if (!l_current_pi->include) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        opj_pi_destroy(l_pi, l_bound);\n        return 00;\n    }\n\n    /* special treatment for the first packet iterator */\n    l_current_comp = l_current_pi->comps;\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n\n    l_current_pi->tx0 = l_tx0;\n    l_current_pi->ty0 = l_ty0;\n    l_current_pi->tx1 = l_tx1;\n    l_current_pi->ty1 = l_ty1;\n\n    /*l_current_pi->dx = l_img_comp->dx;*/\n    /*l_current_pi->dy = l_img_comp->dy;*/\n\n    l_current_pi->step_p = l_step_p;\n    l_current_pi->step_c = l_step_c;\n    l_current_pi->step_r = l_step_r;\n    l_current_pi->step_l = l_step_l;\n\n    /* allocation for components and number of components has already been calculated by opj_pi_create */\n    for\n    (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n        opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n        l_encoding_value_ptr = l_tmp_ptr[compno];\n\n        l_current_comp->dx = l_img_comp->dx;\n        l_current_comp->dy = l_img_comp->dy;\n        /* resolutions have already been initialized */\n        for\n        (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n            l_res->pdx = *(l_encoding_value_ptr++);\n            l_res->pdy = *(l_encoding_value_ptr++);\n            l_res->pw =  *(l_encoding_value_ptr++);\n            l_res->ph =  *(l_encoding_value_ptr++);\n            ++l_res;\n        }\n        ++l_current_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n    ++l_current_pi;\n\n    for (pino = 1 ; pino < l_bound ; ++pino) {\n        l_current_comp = l_current_pi->comps;\n        l_img_comp = p_image->comps;\n        l_tccp = l_tcp->tccps;\n\n        l_current_pi->tx0 = l_tx0;\n        l_current_pi->ty0 = l_ty0;\n        l_current_pi->tx1 = l_tx1;\n        l_current_pi->ty1 = l_ty1;\n        /*l_current_pi->dx = l_dx_min;*/\n        /*l_current_pi->dy = l_dy_min;*/\n        l_current_pi->step_p = l_step_p;\n        l_current_pi->step_c = l_step_c;\n        l_current_pi->step_r = l_step_r;\n        l_current_pi->step_l = l_step_l;\n\n        /* allocation for components and number of components has already been calculated by opj_pi_create */\n        for\n        (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n            opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n            l_encoding_value_ptr = l_tmp_ptr[compno];\n\n            l_current_comp->dx = l_img_comp->dx;\n            l_current_comp->dy = l_img_comp->dy;\n            /* resolutions have already been initialized */\n            for\n            (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n                l_res->pdx = *(l_encoding_value_ptr++);\n                l_res->pdy = *(l_encoding_value_ptr++);\n                l_res->pw =  *(l_encoding_value_ptr++);\n                l_res->ph =  *(l_encoding_value_ptr++);\n                ++l_res;\n            }\n            ++l_current_comp;\n            ++l_img_comp;\n            ++l_tccp;\n        }\n        /* special treatment*/\n        l_current_pi->include = (l_current_pi - 1)->include;\n        ++l_current_pi;\n    }\n    opj_free(l_tmp_data);\n    l_tmp_data = 00;\n    opj_free(l_tmp_ptr);\n    l_tmp_ptr = 00;\n    if\n    (l_tcp->POC) {\n        opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);\n    } else {\n        opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);\n    }\n    return l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n        opj_cp_t *p_cp,\n        OPJ_UINT32 p_tile_no,\n        J2K_T2_MODE p_t2_mode)\n{\n    /* loop*/\n    OPJ_UINT32 pino;\n    OPJ_UINT32 compno, resno;\n\n    /* to store w, h, dx and dy fro all components and resolutions*/\n    OPJ_UINT32 * l_tmp_data;\n    OPJ_UINT32 ** l_tmp_ptr;\n\n    /* encoding prameters to set*/\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n    OPJ_UINT32 l_bound;\n    OPJ_UINT32 l_step_p, l_step_c, l_step_r, l_step_l ;\n    OPJ_UINT32 l_data_stride;\n\n    /* pointers*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *l_tcp = 00;\n    const opj_tccp_t *l_tccp = 00;\n    opj_pi_comp_t *l_current_comp = 00;\n    opj_image_comp_t * l_img_comp = 00;\n    opj_pi_iterator_t * l_current_pi = 00;\n    OPJ_UINT32 * l_encoding_value_ptr = 00;\n\n    /* preconditions in debug*/\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    /* initializations*/\n    l_tcp = &p_cp->tcps[p_tile_no];\n    l_bound = l_tcp->numpocs + 1;\n\n    l_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n    l_tmp_data = (OPJ_UINT32*)opj_malloc(\n                     l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n    if (! l_tmp_data) {\n        return 00;\n    }\n\n    l_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n                    p_image->numcomps * sizeof(OPJ_UINT32 *));\n    if (! l_tmp_ptr) {\n        opj_free(l_tmp_data);\n        return 00;\n    }\n\n    /* memory allocation for pi*/\n    l_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n    if (!l_pi) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        return 00;\n    }\n\n    l_encoding_value_ptr = l_tmp_data;\n    /* update pointer array*/\n    for (compno = 0; compno < p_image->numcomps; ++compno) {\n        l_tmp_ptr[compno] = l_encoding_value_ptr;\n        l_encoding_value_ptr += l_data_stride;\n    }\n\n    /* get encoding parameters*/\n    opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1,\n                                    &l_ty0, &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res, l_tmp_ptr);\n\n    /* step calculations*/\n    l_step_p = 1;\n    l_step_c = l_max_prec * l_step_p;\n    l_step_r = p_image->numcomps * l_step_c;\n    l_step_l = l_max_res * l_step_r;\n\n    /* set values for first packet iterator*/\n    l_pi->tp_on = (OPJ_BYTE)p_cp->m_specific_param.m_enc.m_tp_on;\n    l_current_pi = l_pi;\n\n    /* memory allocation for include*/\n    l_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l,\n                            sizeof(OPJ_INT16));\n    if (!l_current_pi->include) {\n        opj_free(l_tmp_data);\n        opj_free(l_tmp_ptr);\n        opj_pi_destroy(l_pi, l_bound);\n        return 00;\n    }\n\n    /* special treatment for the first packet iterator*/\n    l_current_comp = l_current_pi->comps;\n    l_img_comp = p_image->comps;\n    l_tccp = l_tcp->tccps;\n    l_current_pi->tx0 = l_tx0;\n    l_current_pi->ty0 = l_ty0;\n    l_current_pi->tx1 = l_tx1;\n    l_current_pi->ty1 = l_ty1;\n    l_current_pi->dx = l_dx_min;\n    l_current_pi->dy = l_dy_min;\n    l_current_pi->step_p = l_step_p;\n    l_current_pi->step_c = l_step_c;\n    l_current_pi->step_r = l_step_r;\n    l_current_pi->step_l = l_step_l;\n\n    /* allocation for components and number of components has already been calculated by opj_pi_create */\n    for (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n        opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n        l_encoding_value_ptr = l_tmp_ptr[compno];\n\n        l_current_comp->dx = l_img_comp->dx;\n        l_current_comp->dy = l_img_comp->dy;\n\n        /* resolutions have already been initialized */\n        for (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n            l_res->pdx = *(l_encoding_value_ptr++);\n            l_res->pdy = *(l_encoding_value_ptr++);\n            l_res->pw =  *(l_encoding_value_ptr++);\n            l_res->ph =  *(l_encoding_value_ptr++);\n            ++l_res;\n        }\n\n        ++l_current_comp;\n        ++l_img_comp;\n        ++l_tccp;\n    }\n    ++l_current_pi;\n\n    for (pino = 1 ; pino < l_bound ; ++pino) {\n        l_current_comp = l_current_pi->comps;\n        l_img_comp = p_image->comps;\n        l_tccp = l_tcp->tccps;\n\n        l_current_pi->tx0 = l_tx0;\n        l_current_pi->ty0 = l_ty0;\n        l_current_pi->tx1 = l_tx1;\n        l_current_pi->ty1 = l_ty1;\n        l_current_pi->dx = l_dx_min;\n        l_current_pi->dy = l_dy_min;\n        l_current_pi->step_p = l_step_p;\n        l_current_pi->step_c = l_step_c;\n        l_current_pi->step_r = l_step_r;\n        l_current_pi->step_l = l_step_l;\n\n        /* allocation for components and number of components has already been calculated by opj_pi_create */\n        for (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n            opj_pi_resolution_t *l_res = l_current_comp->resolutions;\n            l_encoding_value_ptr = l_tmp_ptr[compno];\n\n            l_current_comp->dx = l_img_comp->dx;\n            l_current_comp->dy = l_img_comp->dy;\n            /* resolutions have already been initialized */\n            for (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n                l_res->pdx = *(l_encoding_value_ptr++);\n                l_res->pdy = *(l_encoding_value_ptr++);\n                l_res->pw =  *(l_encoding_value_ptr++);\n                l_res->ph =  *(l_encoding_value_ptr++);\n                ++l_res;\n            }\n            ++l_current_comp;\n            ++l_img_comp;\n            ++l_tccp;\n        }\n\n        /* special treatment*/\n        l_current_pi->include = (l_current_pi - 1)->include;\n        ++l_current_pi;\n    }\n\n    opj_free(l_tmp_data);\n    l_tmp_data = 00;\n    opj_free(l_tmp_ptr);\n    l_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,\n                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    } else {\n        opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,\n                                     l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    }\n\n    return l_pi;\n}\n\nvoid opj_pi_create_encode(opj_pi_iterator_t *pi,\n                          opj_cp_t *cp,\n                          OPJ_UINT32 tileno,\n                          OPJ_UINT32 pino,\n                          OPJ_UINT32 tpnum,\n                          OPJ_INT32 tppos,\n                          J2K_T2_MODE t2_mode)\n{\n    const OPJ_CHAR *prog;\n    OPJ_INT32 i;\n    OPJ_UINT32 incr_top = 1, resetX = 0;\n    opj_tcp_t *tcps = &cp->tcps[tileno];\n    opj_poc_t *tcp = &tcps->pocs[pino];\n\n    prog = opj_j2k_convert_progression_order(tcp->prg);\n\n    pi[pino].first = 1;\n    pi[pino].poc.prg = tcp->prg;\n\n    if (!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) &&\n            (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))) {\n        pi[pino].poc.resno0 = tcp->resS;\n        pi[pino].poc.resno1 = tcp->resE;\n        pi[pino].poc.compno0 = tcp->compS;\n        pi[pino].poc.compno1 = tcp->compE;\n        pi[pino].poc.layno0 = tcp->layS;\n        pi[pino].poc.layno1 = tcp->layE;\n        pi[pino].poc.precno0 = tcp->prcS;\n        pi[pino].poc.precno1 = tcp->prcE;\n        pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n        pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n        pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n        pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n    } else {\n        for (i = tppos + 1; i < 4; i++) {\n            switch (prog[i]) {\n            case 'R':\n                pi[pino].poc.resno0 = tcp->resS;\n                pi[pino].poc.resno1 = tcp->resE;\n                break;\n            case 'C':\n                pi[pino].poc.compno0 = tcp->compS;\n                pi[pino].poc.compno1 = tcp->compE;\n                break;\n            case 'L':\n                pi[pino].poc.layno0 = tcp->layS;\n                pi[pino].poc.layno1 = tcp->layE;\n                break;\n            case 'P':\n                switch (tcp->prg) {\n                case OPJ_LRCP:\n                case OPJ_RLCP:\n                    pi[pino].poc.precno0 = tcp->prcS;\n                    pi[pino].poc.precno1 = tcp->prcE;\n                    break;\n                default:\n                    pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n                    pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n                    pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n                    pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n                    break;\n                }\n                break;\n            }\n        }\n\n        if (tpnum == 0) {\n            for (i = tppos; i >= 0; i--) {\n                switch (prog[i]) {\n                case 'C':\n                    tcp->comp_t = tcp->compS;\n                    pi[pino].poc.compno0 = tcp->comp_t;\n                    pi[pino].poc.compno1 = tcp->comp_t + 1;\n                    tcp->comp_t += 1;\n                    break;\n                case 'R':\n                    tcp->res_t = tcp->resS;\n                    pi[pino].poc.resno0 = tcp->res_t;\n                    pi[pino].poc.resno1 = tcp->res_t + 1;\n                    tcp->res_t += 1;\n                    break;\n                case 'L':\n                    tcp->lay_t = tcp->layS;\n                    pi[pino].poc.layno0 = tcp->lay_t;\n                    pi[pino].poc.layno1 = tcp->lay_t + 1;\n                    tcp->lay_t += 1;\n                    break;\n                case 'P':\n                    switch (tcp->prg) {\n                    case OPJ_LRCP:\n                    case OPJ_RLCP:\n                        tcp->prc_t = tcp->prcS;\n                        pi[pino].poc.precno0 = tcp->prc_t;\n                        pi[pino].poc.precno1 = tcp->prc_t + 1;\n                        tcp->prc_t += 1;\n                        break;\n                    default:\n                        tcp->tx0_t = tcp->txS;\n                        tcp->ty0_t = tcp->tyS;\n                        pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                        pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                        pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                        pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                        tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                        tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                        break;\n                    }\n                    break;\n                }\n            }\n            incr_top = 1;\n        } else {\n            for (i = tppos; i >= 0; i--) {\n                switch (prog[i]) {\n                case 'C':\n                    pi[pino].poc.compno0 = tcp->comp_t - 1;\n                    pi[pino].poc.compno1 = tcp->comp_t;\n                    break;\n                case 'R':\n                    pi[pino].poc.resno0 = tcp->res_t - 1;\n                    pi[pino].poc.resno1 = tcp->res_t;\n                    break;\n                case 'L':\n                    pi[pino].poc.layno0 = tcp->lay_t - 1;\n                    pi[pino].poc.layno1 = tcp->lay_t;\n                    break;\n                case 'P':\n                    switch (tcp->prg) {\n                    case OPJ_LRCP:\n                    case OPJ_RLCP:\n                        pi[pino].poc.precno0 = tcp->prc_t - 1;\n                        pi[pino].poc.precno1 = tcp->prc_t;\n                        break;\n                    default:\n                        pi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n                        pi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n                        pi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n                        pi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n                        break;\n                    }\n                    break;\n                }\n                if (incr_top == 1) {\n                    switch (prog[i]) {\n                    case 'R':\n                        if (tcp->res_t == tcp->resE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->res_t = tcp->resS;\n                                pi[pino].poc.resno0 = tcp->res_t;\n                                pi[pino].poc.resno1 = tcp->res_t + 1;\n                                tcp->res_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.resno0 = tcp->res_t;\n                            pi[pino].poc.resno1 = tcp->res_t + 1;\n                            tcp->res_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'C':\n                        if (tcp->comp_t == tcp->compE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->comp_t = tcp->compS;\n                                pi[pino].poc.compno0 = tcp->comp_t;\n                                pi[pino].poc.compno1 = tcp->comp_t + 1;\n                                tcp->comp_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.compno0 = tcp->comp_t;\n                            pi[pino].poc.compno1 = tcp->comp_t + 1;\n                            tcp->comp_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'L':\n                        if (tcp->lay_t == tcp->layE) {\n                            if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                tcp->lay_t = tcp->layS;\n                                pi[pino].poc.layno0 = tcp->lay_t;\n                                pi[pino].poc.layno1 = tcp->lay_t + 1;\n                                tcp->lay_t += 1;\n                                incr_top = 1;\n                            } else {\n                                incr_top = 0;\n                            }\n                        } else {\n                            pi[pino].poc.layno0 = tcp->lay_t;\n                            pi[pino].poc.layno1 = tcp->lay_t + 1;\n                            tcp->lay_t += 1;\n                            incr_top = 0;\n                        }\n                        break;\n                    case 'P':\n                        switch (tcp->prg) {\n                        case OPJ_LRCP:\n                        case OPJ_RLCP:\n                            if (tcp->prc_t == tcp->prcE) {\n                                if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                    tcp->prc_t = tcp->prcS;\n                                    pi[pino].poc.precno0 = tcp->prc_t;\n                                    pi[pino].poc.precno1 = tcp->prc_t + 1;\n                                    tcp->prc_t += 1;\n                                    incr_top = 1;\n                                } else {\n                                    incr_top = 0;\n                                }\n                            } else {\n                                pi[pino].poc.precno0 = tcp->prc_t;\n                                pi[pino].poc.precno1 = tcp->prc_t + 1;\n                                tcp->prc_t += 1;\n                                incr_top = 0;\n                            }\n                            break;\n                        default:\n                            if (tcp->tx0_t >= tcp->txE) {\n                                if (tcp->ty0_t >= tcp->tyE) {\n                                    if (opj_pi_check_next_level(i - 1, cp, tileno, pino, prog)) {\n                                        tcp->ty0_t = tcp->tyS;\n                                        pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                                        pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                                        tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                                        incr_top = 1;\n                                        resetX = 1;\n                                    } else {\n                                        incr_top = 0;\n                                        resetX = 0;\n                                    }\n                                } else {\n                                    pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n                                    pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n                                    tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n                                    incr_top = 0;\n                                    resetX = 1;\n                                }\n                                if (resetX == 1) {\n                                    tcp->tx0_t = tcp->txS;\n                                    pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                                    pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                                    tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                                }\n                            } else {\n                                pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n                                pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n                                tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n                                incr_top = 0;\n                            }\n                            break;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n    OPJ_UINT32 compno, pino;\n    opj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n        if (p_pi->include) {\n            opj_free(p_pi->include);\n            p_pi->include = 00;\n        }\n        for (pino = 0; pino < p_nb_elements; ++pino) {\n            if (l_current_pi->comps) {\n                opj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++) {\n                    if (l_current_component->resolutions) {\n                        opj_free(l_current_component->resolutions);\n                        l_current_component->resolutions = 00;\n                    }\n\n                    ++l_current_component;\n                }\n                opj_free(l_current_pi->comps);\n                l_current_pi->comps = 0;\n            }\n            ++l_current_pi;\n        }\n        opj_free(p_pi);\n    }\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(const opj_image_t *p_image,\n                                       opj_cp_t *p_cp,\n                                       OPJ_UINT32 p_tile_no)\n{\n    /* encoding parameters to set */\n    OPJ_UINT32 l_max_res;\n    OPJ_UINT32 l_max_prec;\n    OPJ_INT32 l_tx0, l_tx1, l_ty0, l_ty1;\n    OPJ_UINT32 l_dx_min, l_dy_min;\n\n    /* pointers */\n    opj_tcp_t *l_tcp = 00;\n\n    /* preconditions */\n    assert(p_cp != 00);\n    assert(p_image != 00);\n    assert(p_tile_no < p_cp->tw * p_cp->th);\n\n    l_tcp = &(p_cp->tcps[p_tile_no]);\n\n    /* get encoding parameters */\n    opj_get_encoding_parameters(p_image, p_cp, p_tile_no, &l_tx0, &l_tx1, &l_ty0,\n                                &l_ty1, &l_dx_min, &l_dy_min, &l_max_prec, &l_max_res);\n\n    if (l_tcp->POC) {\n        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,\n                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    } else {\n        opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,\n                                     l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);\n    }\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi)\n{\n    switch (pi->poc.prg) {\n    case OPJ_LRCP:\n        return opj_pi_next_lrcp(pi);\n    case OPJ_RLCP:\n        return opj_pi_next_rlcp(pi);\n    case OPJ_RPCL:\n        return opj_pi_next_rpcl(pi);\n    case OPJ_PCRL:\n        return opj_pi_next_pcrl(pi);\n    case OPJ_CPRL:\n        return opj_pi_next_cprl(pi);\n    case OPJ_PROG_UNKNOWN:\n        return OPJ_FALSE;\n    }\n\n    return OPJ_FALSE;\n}\n"], "filenames": ["src/lib/openjp2/pi.c"], "buggy_code_start_loc": [371], "buggy_code_end_loc": [559], "fixing_code_start_loc": [372], "fixing_code_end_loc": [593], "type": "CWE-369", "message": "Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.", "other": {"cve": {"id": "CVE-2016-10506", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-30T09:29:00.327", "lastModified": "2020-09-09T19:57:18.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files."}, {"lang": "es", "value": "Existen vulnerabilidades de divisi\u00f3n entre cero en las funciones opj_pi_next_cprl, opj_pi_next_pcrl y opj_pi_next_rpcl de pi.c en OpenJPEG en versiones anteriores a la 2.2.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (fallo de servicio) mediante archivos j2k manipulados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.2", "matchCriteriaId": "2A0A42B9-5905-4F51-8513-59CDC67CF06E"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100573", "source": "cve@mitre.org"}, {"url": "https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/731", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/732", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/777", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/778", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/779", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/780", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b"}}