{"buggy_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise && !allowAsync) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t// This seems not to work, and will produce\n\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\tif (PromisePrototype.finally) {\n\t\toverrideWithProxy(PromisePrototype, 'finally', PromisePrototype.finally, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.finally, Promise.prototype.finally);\n\t}\n\tif (Promise.prototype.catch) {\n\t\toverrideWithProxy(PromisePrototype, 'catch', PromisePrototype.catch, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.catch, Promise.prototype.catch);\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n", "/* eslint-env mocha */\n/* eslint-disable no-new-wrappers, max-len */\n\n'use strict';\n\nconst assert = require('assert');\nconst {VM, VMScript} = require('..');\nconst {INTERNAL_STATE_NAME} = require('../lib/transformer');\nconst NODE_VERSION = parseInt(process.versions.node.split('.')[0]);\nconst {inspect} = require('util');\n\nglobal.isHost = true;\n\nfunction makeHelpers() {\n\tfunction isVMProxy(obj) {\n\t\tconst key = {};\n\t\tconst proto = Object.getPrototypeOf(obj);\n\t\tif (!proto) return undefined;\n\t\tproto.isVMProxy = key;\n\t\tconst proxy = obj.isVMProxy !== key;\n\t\tdelete proto.isVMProxy;\n\t\treturn proxy;\n\t}\n\n\tfunction isLocal(obj) {\n\t\tif (obj instanceof Object || obj === Object.prototype) return true;\n\t\tconst ctor = obj.constructor;\n\t\tif (ctor && ctor.prototype === obj && ctor instanceof ctor && !isVMProxy(ctor)) return false;\n\t\treturn true;\n\t}\n\n\tfunction collectAll(obj) {\n\t\tconst toVisit = [];\n\t\tconst visited = new Map();\n\t\tfunction addObj(o, path) {\n\t\t\tif (o && (typeof o === 'object' || typeof o === 'function') && !visited.has(o)) {\n\t\t\t\tvisited.set(o, path);\n\t\t\t\ttoVisit.push(o);\n\t\t\t}\n\t\t}\n\t\taddObj(obj, 'obj');\n\t\tfunction addProp(o, name, path) {\n\t\t\tconst prop = Object.getOwnPropertyDescriptor(o, name);\n\t\t\tif (typeof name === 'symbol') name = '!' + name.toString();\n\t\t\tObject.setPrototypeOf(prop, null);\n\t\t\taddObj(prop.get, `${path}>${name}`);\n\t\t\taddObj(prop.set, `${path}<${name}`);\n\t\t\taddObj(prop.value, `${path}.${name}`);\n\t\t}\n\t\tfunction addAllFrom(o) {\n\t\t\tconst path = visited.get(o);\n\t\t\tconst names = Object.getOwnPropertyNames(o);\n\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\taddProp(o, names[i], path);\n\t\t\t}\n\t\t\tconst symbols = Object.getOwnPropertySymbols(o);\n\t\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\t\taddProp(o, symbols[i], path);\n\t\t\t}\n\t\t\taddObj(Object.getPrototypeOf(o), path + '@');\n\t\t}\n\t\twhile (toVisit.length > 0) {\n\t\t\taddAllFrom(toVisit.pop());\n\t\t}\n\t\treturn visited;\n\t}\n\n\tfunction checkAllLocal(obj) {\n\t\tconst wrong = [];\n\t\tcollectAll(obj).forEach((v, k) => {\n\t\t\tif (!isLocal(k)) wrong.push(v);\n\t\t});\n\t\treturn wrong.length === 0 ? undefined : wrong;\n\t}\n\n\treturn {isVMProxy, checkAllLocal};\n}\n\nconst {\n\tisVMProxy,\n\tcheckAllLocal\n} = makeHelpers();\n\ndescribe('node', () => {\n\tlet vm;\n\n\tconst doubleProxy = new Proxy(new Proxy({x: 1}, {get() {\n\t\tthrow new Error('Expected');\n\t}}), {});\n\n\tbefore(() => {\n\t\tvm = new VM();\n\t});\n\tit('inspect', () => {\n\t\tassert.throws(() => inspect(doubleProxy), /Expected/);\n\t\tassert.doesNotThrow(() => inspect(vm.run('({})'), {showProxy: true, customInspect: true}));\n\t\tif (NODE_VERSION !== 10 && false) {\n\t\t\t// This failes on node 10 since they do not unwrap proxys.\n\t\t\t// And the hack to fix this is only in the inner proxy.\n\t\t\t// We could add another hack, but that one would require\n\t\t\t// to look if the caller is from a special node function and\n\t\t\t// then remove all the integer keys. To get the caller we\n\t\t\t// would need to get the stack trace which is slow and\n\t\t\t// the probability of this call is so low that I don't do\n\t\t\t// this right now.\n\t\t\tassert.strictEqual(inspect(vm.run('[1, 2, 3]')), inspect([1, 2, 3]), true);\n\t\t}\n\t});\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('contextify', () => {\n\tlet vm;\n\n\tclass TestClass {\n\t\tconstructor() {\n\t\t\tthis.greeting = 'hello';\n\t\t}\n\n\t\tgreet(name) {\n\t\t\treturn `${this.greeting} ${name}`;\n\t\t}\n\t}\n\n\tconst sandbox = {\n\t\tassert,\n\t\ttest: {\n\t\t\tstring: 'text',\n\t\t\tstringO: new String('text'),\n\t\t\tnumber: 1,\n\t\t\tnumberO: new Number(1),\n\t\t\tboolean: true,\n\t\t\tbooleanO: new Boolean(true),\n\t\t\tdate: new Date(),\n\t\t\tregexp: /xxx/,\n\t\t\tbuffer: Buffer.from([0x00, 0x01]),\n\t\t\t'function'() {\n\t\t\t\treturn () => ({});\n\t\t\t},\n\t\t\tobject: {\n\t\t\t\tx: 1,\n\t\t\t\ty() {\n\t\t\t\t\treturn i => i instanceof Object;\n\t\t\t\t},\n\t\t\t\tz(i) {\n\t\t\t\t\tif (!(i instanceof Object)) throw new Error('Not instanceof parent Object.');\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t},\n\t\t\tnil: null,\n\t\t\tundef: void 0,\n\t\t\tklass: TestClass,\n\t\t\tsymbol1: Symbol('foo'),\n\t\t\tsymbol2: Symbol.for('foo'),\n\t\t\tsymbol3: Symbol.iterator,\n\t\t\terror: new Error('test')\n\t\t}\n\t};\n\n\tbefore(() => {\n\t\tvm = new VM({sandbox});\n\t});\n\n\tit('common', () => {\n\t\tassert.ok(vm.run(`global.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`global.__proto__.constructor === Object`));\n\t\tassert.ok(vm.run(`Object.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Object.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Object.prototype.__proto__ === null`));\n\t\tassert.ok(vm.run(`Function.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Function.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Function.prototype.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Array.prototype.__proto__ === Object.prototype`));\n\n\t\tassert.strictEqual(sandbox.test.object.y === sandbox.test.object.y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf() instanceof Function'), true);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object.y')), false);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object.y.valueOf()')), false);\n\t\tassert.strictEqual(vm.run('test.object.y') === vm.run('test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object.y === test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object').y instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf() instanceof Function, true);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object').y), false);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object').y.valueOf()), false);\n\t\tassert.strictEqual(vm.run('test.object').y === vm.run('test.object').y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.valueOf()') === vm.run('test').valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.y.constructor('return (function(){return this})() === global')()\"), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf() instanceof Object'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.valueOf().y.constructor('return (function(){return this})() === global')()\"), true);\n\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`[]`)), '[object Array]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Date`)), '[object Date]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new RangeError`)), '[object Error]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`/a/g`)), '[object RegExp]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new String`)), '[object String]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Number`)), '[object Number]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Boolean`)), '[object Boolean]');\n\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)([]), '[object Array]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Date), '[object Date]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new RangeError), '[object Error]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(/a/g), '[object RegExp]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new String), '[object String]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Number), '[object Number]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Boolean), '[object Boolean]');\n\n\t\tassert.strictEqual(typeof vm.run(`new String`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Number`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Boolean`), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new String), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Number), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Boolean), 'object');\n\n\t\tlet o = vm.run('let x = {a: test.date, b: test.date};x');\n\t\tassert.strictEqual(vm.run('x.valueOf().a instanceof Date'), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t\tassert.strictEqual(o.a === sandbox.test.date, true);\n\n\t\to = vm.run('let y = new Date(); let z = {a: y, b: y};z');\n\t\tassert.strictEqual(isVMProxy(o), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\n\t\tassert.strictEqual(checkAllLocal(vm), undefined);\n\n\t\to = vm.run(`(${makeHelpers})().checkAllLocal(global)`);\n\t\tassert.strictEqual(o, undefined);\n\t});\n\n\tit('class', () => {\n\t\tassert.strictEqual(isVMProxy(vm.run('new test.klass()')), false);\n\t\tassert.strictEqual(vm.run('new test.klass()').greet('friend'), 'hello friend');\n\t\tassert.strictEqual(vm.run('new test.klass()') instanceof TestClass, true);\n\n\t\t// vm.run(\"class LocalClass extends test.klass {}\");\n\t});\n\n\tit('string', () => {\n\t\tassert.strictEqual(vm.run('(test.string).constructor === String'), true);\n\t\tassert.strictEqual(vm.run(\"typeof(test.string) === 'string' && test.string.valueOf instanceof Object\"), true);\n\t});\n\n\tit('number', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.number) === 'number' && test.number.valueOf instanceof Object\"), true);\n\t});\n\n\tit('boolean', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.boolean) === 'boolean' && test.boolean.valueOf instanceof Object\"), true);\n\t});\n\n\tit('date', () => {\n\t\tassert.strictEqual(vm.run('test.date instanceof Date'), true);\n\t\tassert.strictEqual(vm.run('test.date') instanceof Date, true);\n\t\tassert.strictEqual(vm.run('test.date'), sandbox.test.date);\n\t});\n\n\tit('regexp', () => {\n\t\tassert.strictEqual(vm.run('test.regexp instanceof RegExp'), true);\n\t});\n\n\tit('buffer', () => {\n\t\tassert.strictEqual(vm.run('test.buffer.inspect()'), '<Buffer 00 01>', '#1');\n\t\tassert.strictEqual(vm.run('test.buffer instanceof Buffer'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.buffer') instanceof Buffer, true, '#3');\n\t\tassert.strictEqual(vm.run('test.buffer'), sandbox.test.buffer, '#4');\n\t\tassert.strictEqual(vm.run('class Buffer2 extends Buffer {};Buffer2.alloc(5)').fill(1).inspect(), '<Buffer 01 01 01 01 01>');\n\n\t\tconst {a, b, c, d} = vm.run(`\n\t\t\tlet a = Buffer.from([0x01, 0x02]);\n\t\t\tlet b = Buffer.alloc(3, 0x03);\n\t\t\tlet c = Buffer.from(a);\n\t\t\tlet d = Buffer.concat([a, b, c]);\n\n\t\t\tassert.ok(a instanceof Buffer, '#1');\n\t\t\tassert.ok(b instanceof Buffer, '#2');\n\t\t\tassert.ok(c instanceof Buffer, '#3');\n\t\t\tassert.ok(d instanceof Buffer, '#4');\n\t\t\tassert.ok(a.constructor === Buffer, '#5');\n\t\t\tassert.ok(b.constructor === Buffer, '#6');\n\t\t\tassert.ok(c.constructor === Buffer, '#7');\n\t\t\tassert.ok(d.constructor === Buffer, '#8');\n\t\t\tassert.ok(a.constructor.constructor === Function, '#9');\n\t\t\tassert.ok(b.constructor.constructor === Function, '#10');\n\t\t\tassert.ok(c.constructor.constructor === Function, '#11');\n\t\t\tassert.ok(d.constructor.constructor === Function, '#12');\n\n\t\t\t({a: a, b: b, c: c, d: d})\n\t\t`);\n\n\t\tassert.ok(a instanceof Buffer);\n\t\tassert.ok(b instanceof Buffer);\n\t\tassert.ok(c instanceof Buffer);\n\t\tassert.ok(d instanceof Buffer);\n\t\tassert.ok(a.constructor === Buffer);\n\t\tassert.ok(b.constructor === Buffer);\n\t\tassert.ok(c.constructor === Buffer);\n\t\tassert.ok(d.constructor === Buffer);\n\t\tassert.ok(a.constructor.constructor === Function);\n\t\tassert.ok(b.constructor.constructor === Function);\n\t\tassert.ok(c.constructor.constructor === Function);\n\t\tassert.ok(d.constructor.constructor === Function);\n\t});\n\n\tit('function', () => {\n\t\tassert.strictEqual(vm.run('test.function instanceof Function'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.function() instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.function()() instanceof Object'), true, '#3');\n\t});\n\n\tit('object', () => {\n\t\tassert.strictEqual(vm.run('test.object instanceof Object && test.object.x === 1'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.object.y() instanceof Function'), true, '#3');\n\t\tassert.strictEqual(vm.run('test.object.y()({})'), true, '#4');\n\t\tassert.strictEqual(vm.run('test.object.z({}) instanceof Object'), true, '#5');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty instanceof Function\"), true, '#6');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty.constructor('return (function(){return this})().isHost')()\"), undefined, '#7');\n\t});\n\n\tit('null', () => {\n\t\tassert.strictEqual(vm.run('test.nil === null'), true);\n\t});\n\n\tit('undefined', () => {\n\t\tassert.strictEqual(vm.run('test.undef === undefined'), true);\n\t});\n\n\tit('symbol', () => {\n\t\tassert.strictEqual(vm.run(\"Symbol.for('foo') === test.symbol2\"), true);\n\t\tassert.strictEqual(vm.run('test.symbol1.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol2.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol3.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foo').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foobar').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run('Symbol.keyFor(test.symbol2)'), 'foo');\n\t});\n\n\tit('error', () => {\n\t\tassert.strictEqual(vm.run('test.error.constructor.constructor === Function;'), true);\n\t});\n\n\tit('tostring', () => {\n\t\tconst list = [\n\t\t\t'Object',\n\t\t\t'Array',\n\t\t\t'Number',\n\t\t\t'String',\n\t\t\t'Boolean',\n\t\t\t'Date',\n\t\t\t'RegExp',\n\t\t\t'Map',\n\t\t\t'WeakMap',\n\t\t\t'Set',\n\t\t\t'WeakSet',\n\t\t\t'Function',\n\t\t\t'RangeError',\n\t\t\t'ReferenceError',\n\t\t\t'SyntaxError',\n\t\t\t'TypeError',\n\t\t\t'EvalError',\n\t\t\t'URIError',\n\t\t\t'Error'\n\t\t];\n\t\tconst gen = vm.run('name => new (global[name])()');\n\t\tconst oToString = Object.prototype.toString;\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst obj = list[i];\n\t\t\tassert.strictEqual(oToString.call(gen(obj)), oToString.call(new (global[obj])()));\n\t\t}\n\t});\n\n\tit('arguments', () => {\n\t\tassert.doesNotThrow(() => vm.run('(o) => o.arguments')({arguments: 1}));\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('VM', () => {\n\tlet vm;\n\n\tconst sandbox = {\n\t\tround(number) {\n\t\t\treturn Math.round(number);\n\t\t},\n\t\tsub: {}\n\t};\n\n\tObject.defineProperty(sandbox.sub, 'getter', {\n\t\tget() {\n\t\t\tconst results = [];\n\t\t\twhile (true) {\n\t\t\t\tresults.push(1);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t});\n\n\tbefore(() => {\n\t\tvm = new VM({\n\t\t\tsandbox\n\t\t});\n\t});\n\n\tit('globals', () => {\n\t\tconst dyn = {};\n\t\tvm.setGlobal('dyn', dyn);\n\t\tvm.setGlobals({dyns: dyn});\n\t\tassert.equal(vm.run('round(1.5)'), 2);\n\t\tassert.equal(vm.getGlobal('dyn'), dyn);\n\t\tassert.equal(vm.sandbox.dyn, dyn);\n\t\tassert.equal(vm.sandbox.dyns, dyn);\n\t});\n\n\tit('errors', () => {\n\t\tassert.throws(() => vm.run('notdefined'), /notdefined is not defined/);\n\t\tassert.throws(() => vm.run('Object.setPrototypeOf(sub, {})'), err => {\n\t\t\tassert.ok(err instanceof Error);\n\t\t\tassert.equal(err.name, 'VMError');\n\t\t\tassert.equal(err.message, 'Operation not allowed on contextified object.');\n\t\t\treturn true;\n\t\t});\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\t// async/await was not there in Node 6\n\t\t\tassert.throws(() => vm.run('function test(){ return await Promise.resolve(); };'), err => {\n\t\t\t\tassert.ok(err instanceof Error);\n\t\t\t\tassert.equal(err.name, 'SyntaxError');\n\t\t\t\t// assert.match(err.message, /await is only valid in async function/); // Changed due to acorn\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t\tassert.throws(() => new VM({compiler: 'nonexistant'}), /Unsupported compiler/);\n\t\tassert.throws(() => new VMScript('', '', {compiler: 'nonexistant'}), /Unsupported compiler/);\n\t});\n\n\tit('timeout', () => {\n\t\tconst message = NODE_VERSION >= 11 ? /Script execution timed out after 10ms/ : /Script execution timed out\\./;\n\n\t\tassert.throws(() => new VM({\n\t\t\ttimeout: 10\n\t\t}).run('while (true) {}'), message);\n\t\tassert.throws(() => new VM({timeout: 10, sandbox}).run('sub.getter'), message);\n\t});\n\n\tit('timers', () => {\n\t\tassert.equal(vm.run('global.setTimeout'), void 0);\n\t\tassert.equal(vm.run('global.setInterval'), void 0);\n\t\tassert.equal(vm.run('global.setImmediate'), void 0);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('eval/wasm', () => {\n\t\t\tassert.equal(vm.run('eval(\"1\")'), 1);\n\n\t\t\tconst vm2 = new VM({eval: false});\n\t\t\tassert.throws(() => vm2.run('eval(\"1\")'), /Code generation from strings disallowed for this context/);\n\t\t});\n\t}\n\n\tif (NODE_VERSION > 7) {\n\t\t// Node until 7 had no async, see https://node.green/\n\t\tit('async', () => {\n\t\t\tconst vm2 = new VM({fixAsync: true});\n\t\t\tassert.throws(() => vm2.run('(async function(){})'), /Async not available/, '#1');\n\t\t\tassert.strictEqual(vm2.run('Object.getPrototypeOf((function*(){}).constructor)'), vm2.run('Function'), '#2');\n\t\t\tassert.throws(() => vm2.run('new Function(\"(as\"+\"ync function(){})\")'), /Async not available/, '#3');\n\t\t\tassert.throws(() => vm2.run('new (function*(){}).constructor(\"(as\"+\"ync function(){})\")'), /Async not available/, '#4');\n\t\t\tassert.throws(() => vm2.run('Promise.resolve().then(function(){})'), /Async not available/, '#5');\n\t\t\tif (Promise.prototype.finally) assert.throws(() => vm2.run('Promise.resolve().finally(function(){})'), /Async not available/, '#6');\n\t\t\tif (Promise.prototype.catch) assert.throws(() => vm2.run('Promise.resolve().catch(function(){})'), /Async not available/, '#7');\n\t\t\tassert.throws(() => vm2.run('eval(\"(as\"+\"ync function(){})\")'), /Async not available/, '#8');\n\t\t\tassert.throws(() => vm2.run('Function')('(async function(){})'), /Async not available/, '#9');\n\t\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\t\tlet a = {import: 1}\n\t\t\t\tlet b = {import : {\"import\": 2}};\n\t\t\t\tlet c = { import : 1};\n\t\t\t\tlet d = a.import;\n\t\t\t\tlet e = a. import;\n\t\t\t\tlet f = a.import-1;\n\t\t\t\tlet g = a.import.import;\n\t\t\t`));\n\t\t});\n\t}\n\n\tit('proxy trap errors', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tReflect.ownKeys(vm2.run('(function(){}).bind(null)'));\n\t\t});\n\t});\n\n\tit('frozen unconfigurable access', () => {\n\t\tconst vm2 = new VM();\n\t\tconst obj = {};\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.getOwnPropertyDescriptor(x, \"prop\")')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.defineProperty({}, 'prop', {value: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.isExtensible(x)')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => {Object.preventExtensions(x); Object.getOwnPropertyDescriptor(x, \"prop\")}')({prop: {}});\n\t\t});\n\n\t\tassert.strictEqual(vm2.run('x => {Object.preventExtensions(x); return Object.getOwnPropertyDescriptor(x, \"prop\").value}')({prop: obj}), obj);\n\n\t});\n\n\tit('various attacks #1', () => {\n\t\tconst vm2 = new VM({sandbox: {log: console.log, boom: () => {\n\t\t\tthrow new Error();\n\t\t}}});\n\n\t\tassert.strictEqual(vm2.run(\"this.constructor.constructor('return Function(\\\\'return Function\\\\')')()() === this.constructor.constructor('return Function')()\"), true);\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tconst ForeignFunction = global.constructor.constructor;\n\t\t\tconst process1 = ForeignFunction(\"return process\")();\n\t\t`), /process is not defined/, '#1');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t    try {\n\t\t        boom();\n\t\t    }\n\t\t    catch (e) {\n\t\t        const foreignFunction = e.constructor.constructor;\n\t\t        const process = foreignFunction(\"return process\")();\n\t\t    }\n\t\t`), /process is not defined/, '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tfunction exploit(o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\n\t\t\tReflect.construct = exploit;\n\t\t\tBuffer.from([0]);\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Proxy = function() {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)('asdf'), '#5');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)(new String('asdf')), '#6');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Buffer = function(value) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(value) {})\n\t\t`)(Buffer.alloc(1)), '#7');\n\t});\n\n\tit('various attacks #2', () => {\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tboom: () => {},\n\t\t\t\terror: new Error('test')\n\t\t\t}\n\t\t});\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.assign = function (o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};\n\t\t\tBuffer.from([0]);\n\t\t`), '#1');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\ttry {\n\t\t\t\tBuffer.alloc(0);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet o;\n\t\t\tArray.prototype.map = function(callback) {\n\t\t\t\to = callback(boom);\n\t\t\t\treturn [];\n\t\t\t};\n\t\t\tboom(boom);\n\t\t\tif (o && o.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet method = () => {};\n\t\t\tlet proxy = new Proxy(method, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (target.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy\n\t\t`)('asdf'), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet proxy2 = new Proxy(function() {}, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy2\n\t\t`)('asdf'), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.DEBUG = true;\n\t\t\tboom.vmProxyTarget\n\t\t`), undefined, '#6');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#7');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.__proto__.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#8');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tif (!(Object.keys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t\tif (!(Reflect.ownKeys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t`));\n\t});\n\n\tit('internal state attack', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.throws(() => vm2.run(`${INTERNAL_STATE_NAME}=\"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`const ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`var ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`let ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`class ${INTERNAL_STATE_NAME} {}; // async`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`function ${INTERNAL_STATE_NAME} () {}; // async`), /Use of internal vm2 state variable/);\n\t});\n\n\tit('buffer attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#1');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).constructor.constructor === Function;\n\t\t`), true, '#2');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).toString('hex');\n\t\t`), '00'.repeat(100), '#3');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer extends Buffer {}; MyBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#4');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tnew Buffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#6');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer2 extends Buffer {}; new MyBuffer2(100).toString('hex');\n\t\t`), '00'.repeat(100), '#7');\n\n\t});\n\n\tit('instanceof attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/174\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tfunc: cb => cb()\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tvm2.run(`\n\t\t\t\tfunc(() => {\n\t\t\t\t\tthrow new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf: () => {\n\t\t\t\t\t\t\tthrow x => x.constructor.constructor(\"return process;\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t`);\n\t\t} catch (ex) {\n\t\t\tassert.throws(()=>{\n\t\t\t\tex(()=>{});\n\t\t\t}, /process is not defined/);\n\t\t}\n\t});\n\n\tit('__defineGetter__ / __defineSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/176\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.prototype.__defineGetter__ === {}.__defineGetter__;\n\t\t`), true, '#1');\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\tassert.throws(() => vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"toString\", () => {});\n\t\t\t`), /'defineProperty' on proxy: trap returned falsish for property 'toString'/, '#2');\n\t\t} else {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"xxx\", () => 4);\n\t\t\t\tBuffer.prototype.xxx;\n\t\t\t`), undefined, '#2');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.__defineGetter__(\"test\", () => 123); global.test;\n\t\t`), 123, '#3');\n\t});\n\n\tit('__lookupGetter__ / __lookupSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/184\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.from.__lookupGetter__(\"__proto__\") === Object.prototype.__lookupGetter__.call(Buffer.from, \"__proto__\");\n\t\t`), true, '#1');\n\t});\n\n\tit('contextifying a contextified value attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/175\n\t\t// https://github.com/patriksimek/vm2/issues/177\n\t\t// https://github.com/patriksimek/vm2/issues/186\n\n\t\tlet vm2 = new VM();\n\n\t\t// The Buffer.from(\"\") is only used to get instance of object contextified from the host\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"x\", {\n\t\t\t\tget set() {\n\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ()=>{};\n\t\t\t\t}\n\t\t\t});\n\t\t`), '#1');\n\n\t\tvm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tctor: X => new X(),\n\t\t\t\tcall: x => x()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall(ctor(new Proxy(class A {}, {\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn () => x => x.constructor(\"return process\")();\n\t\t\t\t}\n\t\t\t})))(()=>{}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#2');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"), \"y\", {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\t\tdelete this.getPrototypeOf;\n\n\t\t\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\t\t\t\t\tFunction.prototype.__proto__ = null;\n\t\t\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /Cannot read propert.*mainModule/, '#3');\n\n\t\tvm2 = new VM();\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"\", {\n\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\tthrow Buffer.from;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.t=true;\n\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t`), '#4');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf() {\n\t\t\t\t\t\tif (this.t) {\n\t\t\t\t\t\t\tthrow x => x.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#5');\n\n\n\t\t/* TODO internal have changed too much for this to still work\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar map = {\n\t\t\t\tvalueOf(){\n\t\t\t\t\tthrow new Proxy({},{\n\t\t\t\t\t\tgetPrototypeOf(){\n\t\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#6');\n\t\t*/\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar map = {valueOf(){}};\n\t\t\tvar arrayBackup = Array;\n\t\t\tArray = function(){\n\t\t\t\tArray = arrayBackup;\n\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess\n\t\t`), /e is not a function/, '#7');\n\t});\n\n\tit('proxy trap via Object.prototype attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tlet process;\n\t\t\tObject.prototype.has = (t, k) => {\n\t\t\t\tprocess = t.constructor(\"return process\")();\n\t\t\t}\n\t\t\t\"\" in Buffer.from;\n\t\t\tprocess.mainModule;\n\t\t`), /Cannot read propert.*mainModule/, '#1');\n\n\t\tconst vm22 = new VM();\n\n\t\tassert.throws(() => vm22.run(`\n\t\t\tObject.defineProperty(Object.prototype, \"apply\", {set:function(o,v){\n\t\t\t\tdelete Object.prototype.apply;\n\t\t\t}});\n\t\t\tBuffer.from(\"\").constructor.constructor(\"return process\")().mainModule;\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Object.create attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar oc = Object.create;\n\t\t\tObject.create = (p,x)=> Object.defineProperty(oc(p,x),\"get\",{set(){},get:()=>(t,k,r)=>t.constructor(\"return process\")()});\n\t\t\tvar process = Buffer.from.process;\n\t\t\tObject.create = oc;\n\t\t\tprocess.mainModule\n\t\t`), /Cannot read propert.*mainModule/, '#1');\n\t});\n\n\tit('function returned from construct attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/179\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tcall: x => x.a(),\n\t\t\t\tctor: X => new X()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall({a:ctor(new Proxy(class A{},{\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\treturn Object.getPrototypeOf(this).constructor.constructor(\"return process\")();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}))}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\t});\n\n\tit('throw while accessing propertyDescriptor properties', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450904979\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`(function(){\n\t\t\tvar process;\n\t\t\tObject.defineProperty(Object.prototype, \"set\", {get(){\n\t\t\t\tdelete Object.prototype.set;\n\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {get(){\n\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\tthrow new Proxy(Object.create(null),{\n\t\t\t\t\t\tset(t,k,v){\n\t\t\t\t\t\t\tprocess = v.constructor(\"return process\")();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},configurable:true});\n\t\t\t\treturn ()=>{};\n\t\t\t},configurable:true});\n\t\t\ttry{\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"),\"\",{});\n\t\t\t}catch(e){\n\t\t\t\te.x = Buffer.from;\n\t\t\t}\n\t\t\treturn process;})()\n\t\t`), undefined, '#1');\n\t});\n\n\tit('Symbol.hasInstance attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tlet vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject.__defineGetter__(Symbol.hasInstance,()=>()=>true);\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject[Symbol.hasInstance].call = ()=>true;\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Proxy::getOwnPropertyDescriptor attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\t(function(){\n\t\t\t\ttry{\n\t\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\t\tgetOwnPropertyDescriptor(){\n\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn e(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n\t\t\t\t}\n\t\t\t})()\n\t\t`), /process is not defined/);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('Dynamic import attack', () => {\n\n\t\t\tconst vm2 = new VM();\n\n\t\t\tassert.throws(()=>vm2.run(`\n\t\t\t\tconst process = import('oops!').constructor.constructor('return process')();\n\t\t\t`), /VMError: Dynamic Import not supported/);\n\t\t});\n\t}\n\n\tit('Error.prepareStackTrace attack', () => {\n\t\tconst vm2 = new VM();\n\t\tconst sst = vm2.run('Error.prepareStackTrace = (e,sst)=>sst;const sst = new Error().stack;Error.prepareStackTrace = undefined;sst');\n\t\tassert.strictEqual(vm2.run('sst=>Object.getPrototypeOf(sst)')(sst), vm2.run('Array.prototype'));\n\t\tassert.throws(()=>vm2.run('sst=>sst[0].getThis().constructor.constructor')(sst), /TypeError: Cannot read propert.*constructor/);\n\t\tassert.throws(()=>vm2.run(`\n\t\t\tconst { set } = WeakMap.prototype;\n\t\t\tWeakMap.prototype.set = function(v) {\n\t\t\t\treturn set.call(this, v, v);\n\t\t\t};\n\t\t\tError.prepareStackTrace =\n\t\t\tError.prepareStackTrace =\n\t\t\t(_, c) => c.map(c => c.getThis()).find(a => a);\n\t\t\tconst { stack } = new Error();\n\t\t\tError.prepareStackTrace = undefined;\n\t\t\tstack.process\n\t\t`));\n\t});\n\n\tit('Node internal prepareStackTrace attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(()=>vm2.run(`\n\t\t\tfunction stack() {\n\t\t\t\tnew Error().stack;\n\t\t\t\tstack();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tstack();\n\t\t\t} catch (e) {\n\t\t\t\te.constructor.constructor(\"return process\")()\n\t\t\t}\n\t\t`), /process is not defined/);\n\n\t});\n\n\tit('Monkey patching attack', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tconst f = vm2.run(`\n\t\t\t\tfunction onget() {throw new Error();}\n\t\t\t\tfunction onset() {throw new Error();}\n\t\t\t\tconst desc = {__proto__: null, get: onget, set: onset};\n\t\t\t\tObject.defineProperties(Object.prototype, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\t'0': desc,\n\t\t\t\t\tget: desc,\n\t\t\t\t\tset: desc,\n\t\t\t\t\tapply: desc,\n\t\t\t\t\tcall: desc,\n\t\t\t\t\t'1': desc,\n\t\t\t\t\t'length': desc,\n\t\t\t\t});\n\t\t\t\tObject.defineProperties(Function.prototype, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tcall: desc,\n\t\t\t\t\tapply: desc,\n\t\t\t\t\tbind: desc,\n\t\t\t\t});\n\t\t\t\tfunction passer(a, b, c) {\n\t\t\t\t\treturn a(b, c);\n\t\t\t\t}\n\t\t\t`);\n\t\t\tf((a, b) => b, {}, {});\n\t\t});\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('precompiled scripts', () => {\n\tit('VM', () => {\n\t\tconst vm = new VM();\n\t\tconst script = new VMScript('global.i=global.i||0;global.i++');\n\t\tconst val1 = vm.run(script);\n\t\tconst val2 = vm.run(script);\n\t\tconst failScript = new VMScript('(');\n\t\tassert.ok('number' === typeof val1 && 'number' === typeof val2);\n\t\tassert.ok( val1 === 0 && val2 === 1);\n\t\tassert.throws(() => failScript.compile(), /SyntaxError/);\n\t\tassert.ok(Object.keys(failScript).includes('code'));\n\t\tassert.ok(Object.keys(failScript).includes('filename'));\n\t\tassert.ok(Object.keys(failScript).includes('compiler'));\n\t\tassert.ok(!Object.keys(failScript).includes('_code'));\n\t});\n});\n\ndescribe('freeze, protect', () => {\n\tit('without freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM({\n\t\t\tsandbox: {x}\n\t\t});\n\t\tvm.run('x.a = () => { return `-` }; x.c.d = () => { return `---` }; (y) => { y.b = () => { return `--` } }')(x);\n\n\t\tassert.strictEqual(x.a(), '-');\n\t\tassert.strictEqual(x.b(), '--');\n\t\tassert.strictEqual(x.c.d(), '---');\n\t});\n\n\tit('with freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM();\n\t\tvm.freeze(x, 'x');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.a = () => { return `-` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'a'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (y) => { y.b = () => { return `--` } }')(x);\n\t\t}, /'set' on proxy: trap returned falsish for property 'b'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.c.d = () => { return `---` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'd'/);\n\n\t\tvm.run('x.a = () => { return `-` };');\n\t\tassert.strictEqual(x.a(), 'a');\n\n\t\tvm.run('(y) => { y.b = () => { return `--` } }')(x);\n\t\tassert.strictEqual(x.b(), 'b');\n\n\t\tvm.run('x.c.d = () => { return `---` };');\n\t\tassert.strictEqual(x.c.d(), 'd');\n\n\t\t// Extension of frozen objects should be writeable.\n\t\tassert.strictEqual(vm.run('y = Object.create(x); y.f = 1; y.f'), 1);\n\t});\n\n\tit('without protect', () => {\n\t\tconst vm = new VM(); const obj = {};\n\t\tvm.run('(i) => { i.text = \"test\" }')(obj);\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tvm.run('(i) => { delete i.func }')(obj);\n\t});\n\n\tit('with protect', () => {\n\t\tconst vm = new VM(); const obj = {\n\t\t\tdate: new Date(),\n\t\t\tarray: [{}, {}]\n\t\t};\n\n\t\tvm.protect(obj);\n\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array[0].func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array[0].func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array[0].func = () => {} }')(obj);\n\t\t});\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { Object.defineProperty(i, \"toString\", { get(){ return () => \\'Not protected\\'; } }) }')(obj);\n\t\t});\n\n\t\tassert.strictEqual(vm.run('(i) => i.array.map(item => 1).join(\",\")')(obj), '1,1');\n\t\tassert.strictEqual(vm.run('(i) => /x/.test(i.date)')(obj), false);\n\t});\n});\n"], "fixing_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true},\n\tError: {value: LocalError}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise && !allowAsync) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t// This seems not to work, and will produce\n\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\tif (PromisePrototype.finally) {\n\t\toverrideWithProxy(PromisePrototype, 'finally', PromisePrototype.finally, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.finally, Promise.prototype.finally);\n\t}\n\tif (Promise.prototype.catch) {\n\t\toverrideWithProxy(PromisePrototype, 'catch', PromisePrototype.catch, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.catch, Promise.prototype.catch);\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n", "/* eslint-env mocha */\n/* eslint-disable no-new-wrappers, max-len */\n\n'use strict';\n\nconst assert = require('assert');\nconst {VM, VMScript} = require('..');\nconst {INTERNAL_STATE_NAME} = require('../lib/transformer');\nconst NODE_VERSION = parseInt(process.versions.node.split('.')[0]);\nconst {inspect} = require('util');\n\nglobal.isHost = true;\n\nfunction makeHelpers() {\n\tfunction isVMProxy(obj) {\n\t\tconst key = {};\n\t\tconst proto = Object.getPrototypeOf(obj);\n\t\tif (!proto) return undefined;\n\t\tproto.isVMProxy = key;\n\t\tconst proxy = obj.isVMProxy !== key;\n\t\tdelete proto.isVMProxy;\n\t\treturn proxy;\n\t}\n\n\tfunction isLocal(obj) {\n\t\tif (obj instanceof Object || obj === Object.prototype) return true;\n\t\tconst ctor = obj.constructor;\n\t\tif (ctor && ctor.prototype === obj && ctor instanceof ctor && !isVMProxy(ctor)) return false;\n\t\treturn true;\n\t}\n\n\tfunction collectAll(obj) {\n\t\tconst toVisit = [];\n\t\tconst visited = new Map();\n\t\tfunction addObj(o, path) {\n\t\t\tif (o && (typeof o === 'object' || typeof o === 'function') && !visited.has(o)) {\n\t\t\t\tvisited.set(o, path);\n\t\t\t\ttoVisit.push(o);\n\t\t\t}\n\t\t}\n\t\taddObj(obj, 'obj');\n\t\tfunction addProp(o, name, path) {\n\t\t\tconst prop = Object.getOwnPropertyDescriptor(o, name);\n\t\t\tif (typeof name === 'symbol') name = '!' + name.toString();\n\t\t\tObject.setPrototypeOf(prop, null);\n\t\t\taddObj(prop.get, `${path}>${name}`);\n\t\t\taddObj(prop.set, `${path}<${name}`);\n\t\t\taddObj(prop.value, `${path}.${name}`);\n\t\t}\n\t\tfunction addAllFrom(o) {\n\t\t\tconst path = visited.get(o);\n\t\t\tconst names = Object.getOwnPropertyNames(o);\n\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\taddProp(o, names[i], path);\n\t\t\t}\n\t\t\tconst symbols = Object.getOwnPropertySymbols(o);\n\t\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\t\taddProp(o, symbols[i], path);\n\t\t\t}\n\t\t\taddObj(Object.getPrototypeOf(o), path + '@');\n\t\t}\n\t\twhile (toVisit.length > 0) {\n\t\t\taddAllFrom(toVisit.pop());\n\t\t}\n\t\treturn visited;\n\t}\n\n\tfunction checkAllLocal(obj) {\n\t\tconst wrong = [];\n\t\tcollectAll(obj).forEach((v, k) => {\n\t\t\tif (!isLocal(k)) wrong.push(v);\n\t\t});\n\t\treturn wrong.length === 0 ? undefined : wrong;\n\t}\n\n\treturn {isVMProxy, checkAllLocal};\n}\n\nconst {\n\tisVMProxy,\n\tcheckAllLocal\n} = makeHelpers();\n\ndescribe('node', () => {\n\tlet vm;\n\n\tconst doubleProxy = new Proxy(new Proxy({x: 1}, {get() {\n\t\tthrow new Error('Expected');\n\t}}), {});\n\n\tbefore(() => {\n\t\tvm = new VM();\n\t});\n\tit('inspect', () => {\n\t\tassert.throws(() => inspect(doubleProxy), /Expected/);\n\t\tassert.doesNotThrow(() => inspect(vm.run('({})'), {showProxy: true, customInspect: true}));\n\t\tif (NODE_VERSION !== 10 && false) {\n\t\t\t// This failes on node 10 since they do not unwrap proxys.\n\t\t\t// And the hack to fix this is only in the inner proxy.\n\t\t\t// We could add another hack, but that one would require\n\t\t\t// to look if the caller is from a special node function and\n\t\t\t// then remove all the integer keys. To get the caller we\n\t\t\t// would need to get the stack trace which is slow and\n\t\t\t// the probability of this call is so low that I don't do\n\t\t\t// this right now.\n\t\t\tassert.strictEqual(inspect(vm.run('[1, 2, 3]')), inspect([1, 2, 3]), true);\n\t\t}\n\t});\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('contextify', () => {\n\tlet vm;\n\n\tclass TestClass {\n\t\tconstructor() {\n\t\t\tthis.greeting = 'hello';\n\t\t}\n\n\t\tgreet(name) {\n\t\t\treturn `${this.greeting} ${name}`;\n\t\t}\n\t}\n\n\tconst sandbox = {\n\t\tassert,\n\t\ttest: {\n\t\t\tstring: 'text',\n\t\t\tstringO: new String('text'),\n\t\t\tnumber: 1,\n\t\t\tnumberO: new Number(1),\n\t\t\tboolean: true,\n\t\t\tbooleanO: new Boolean(true),\n\t\t\tdate: new Date(),\n\t\t\tregexp: /xxx/,\n\t\t\tbuffer: Buffer.from([0x00, 0x01]),\n\t\t\t'function'() {\n\t\t\t\treturn () => ({});\n\t\t\t},\n\t\t\tobject: {\n\t\t\t\tx: 1,\n\t\t\t\ty() {\n\t\t\t\t\treturn i => i instanceof Object;\n\t\t\t\t},\n\t\t\t\tz(i) {\n\t\t\t\t\tif (!(i instanceof Object)) throw new Error('Not instanceof parent Object.');\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t},\n\t\t\tnil: null,\n\t\t\tundef: void 0,\n\t\t\tklass: TestClass,\n\t\t\tsymbol1: Symbol('foo'),\n\t\t\tsymbol2: Symbol.for('foo'),\n\t\t\tsymbol3: Symbol.iterator,\n\t\t\terror: new Error('test')\n\t\t}\n\t};\n\n\tbefore(() => {\n\t\tvm = new VM({sandbox});\n\t});\n\n\tit('common', () => {\n\t\tassert.ok(vm.run(`global.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`global.__proto__.constructor === Object`));\n\t\tassert.ok(vm.run(`Object.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Object.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Object.prototype.__proto__ === null`));\n\t\tassert.ok(vm.run(`Function.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Function.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Function.prototype.__proto__ === Object.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__ === Function.prototype`));\n\t\tassert.ok(vm.run(`Array.__proto__.constructor === Function`));\n\t\tassert.ok(vm.run(`Array.prototype.__proto__ === Object.prototype`));\n\n\t\tassert.strictEqual(sandbox.test.object.y === sandbox.test.object.y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.y.valueOf() instanceof Function'), true);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object.y')), false);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object.y.valueOf()')), false);\n\t\tassert.strictEqual(vm.run('test.object.y') === vm.run('test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object.y === test.object.y.valueOf()'), true);\n\t\tassert.strictEqual(vm.run('test.object').y instanceof Function, true);\n\t\tassert.strictEqual(vm.run('test.object').y.valueOf() instanceof Function, true);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object').y), false);\n\t\tassert.strictEqual(isVMProxy(vm.run('test.object').y.valueOf()), false);\n\t\tassert.strictEqual(vm.run('test.object').y === vm.run('test.object').y.valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.valueOf()') === vm.run('test').valueOf(), true);\n\t\tassert.strictEqual(vm.run('test.object.y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.y.constructor('return (function(){return this})() === global')()\"), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf() instanceof Object'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y instanceof Function'), true);\n\t\tassert.strictEqual(vm.run('test.object.valueOf().y.constructor instanceof Function'), true);\n\t\tassert.strictEqual(vm.run(\"test.object.valueOf().y.constructor('return (function(){return this})() === global')()\"), true);\n\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`[]`)), '[object Array]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Date`)), '[object Date]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new RangeError`)), '[object Error]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`/a/g`)), '[object RegExp]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new String`)), '[object String]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Number`)), '[object Number]');\n\t\tassert.strictEqual(Object.prototype.toString.call(vm.run(`new Boolean`)), '[object Boolean]');\n\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)([]), '[object Array]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Date), '[object Date]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new RangeError), '[object Error]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(/a/g), '[object RegExp]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new String), '[object String]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Number), '[object Number]');\n\t\tassert.strictEqual(vm.run(`((obj) => Object.prototype.toString.call(obj))`)(new Boolean), '[object Boolean]');\n\n\t\tassert.strictEqual(typeof vm.run(`new String`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Number`), 'object');\n\t\tassert.strictEqual(typeof vm.run(`new Boolean`), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new String), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Number), 'object');\n\t\tassert.strictEqual(vm.run(`((obj) => typeof obj)`)(new Boolean), 'object');\n\n\t\tlet o = vm.run('let x = {a: test.date, b: test.date};x');\n\t\tassert.strictEqual(vm.run('x.valueOf().a instanceof Date'), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\t\tassert.strictEqual(o.a === sandbox.test.date, true);\n\n\t\to = vm.run('let y = new Date(); let z = {a: y, b: y};z');\n\t\tassert.strictEqual(isVMProxy(o), true);\n\t\tassert.strictEqual(o instanceof Object, true);\n\t\tassert.strictEqual(o.a instanceof Date, true);\n\t\tassert.strictEqual(o.b instanceof Date, true);\n\t\tassert.strictEqual(o.a === o.b, true);\n\n\t\tassert.strictEqual(checkAllLocal(vm), undefined);\n\n\t\to = vm.run(`(${makeHelpers})().checkAllLocal(global)`);\n\t\tassert.strictEqual(o, undefined);\n\t});\n\n\tit('class', () => {\n\t\tassert.strictEqual(isVMProxy(vm.run('new test.klass()')), false);\n\t\tassert.strictEqual(vm.run('new test.klass()').greet('friend'), 'hello friend');\n\t\tassert.strictEqual(vm.run('new test.klass()') instanceof TestClass, true);\n\n\t\t// vm.run(\"class LocalClass extends test.klass {}\");\n\t});\n\n\tit('string', () => {\n\t\tassert.strictEqual(vm.run('(test.string).constructor === String'), true);\n\t\tassert.strictEqual(vm.run(\"typeof(test.string) === 'string' && test.string.valueOf instanceof Object\"), true);\n\t});\n\n\tit('number', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.number) === 'number' && test.number.valueOf instanceof Object\"), true);\n\t});\n\n\tit('boolean', () => {\n\t\tassert.strictEqual(vm.run(\"typeof(test.boolean) === 'boolean' && test.boolean.valueOf instanceof Object\"), true);\n\t});\n\n\tit('date', () => {\n\t\tassert.strictEqual(vm.run('test.date instanceof Date'), true);\n\t\tassert.strictEqual(vm.run('test.date') instanceof Date, true);\n\t\tassert.strictEqual(vm.run('test.date'), sandbox.test.date);\n\t});\n\n\tit('regexp', () => {\n\t\tassert.strictEqual(vm.run('test.regexp instanceof RegExp'), true);\n\t});\n\n\tit('buffer', () => {\n\t\tassert.strictEqual(vm.run('test.buffer.inspect()'), '<Buffer 00 01>', '#1');\n\t\tassert.strictEqual(vm.run('test.buffer instanceof Buffer'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.buffer') instanceof Buffer, true, '#3');\n\t\tassert.strictEqual(vm.run('test.buffer'), sandbox.test.buffer, '#4');\n\t\tassert.strictEqual(vm.run('class Buffer2 extends Buffer {};Buffer2.alloc(5)').fill(1).inspect(), '<Buffer 01 01 01 01 01>');\n\n\t\tconst {a, b, c, d} = vm.run(`\n\t\t\tlet a = Buffer.from([0x01, 0x02]);\n\t\t\tlet b = Buffer.alloc(3, 0x03);\n\t\t\tlet c = Buffer.from(a);\n\t\t\tlet d = Buffer.concat([a, b, c]);\n\n\t\t\tassert.ok(a instanceof Buffer, '#1');\n\t\t\tassert.ok(b instanceof Buffer, '#2');\n\t\t\tassert.ok(c instanceof Buffer, '#3');\n\t\t\tassert.ok(d instanceof Buffer, '#4');\n\t\t\tassert.ok(a.constructor === Buffer, '#5');\n\t\t\tassert.ok(b.constructor === Buffer, '#6');\n\t\t\tassert.ok(c.constructor === Buffer, '#7');\n\t\t\tassert.ok(d.constructor === Buffer, '#8');\n\t\t\tassert.ok(a.constructor.constructor === Function, '#9');\n\t\t\tassert.ok(b.constructor.constructor === Function, '#10');\n\t\t\tassert.ok(c.constructor.constructor === Function, '#11');\n\t\t\tassert.ok(d.constructor.constructor === Function, '#12');\n\n\t\t\t({a: a, b: b, c: c, d: d})\n\t\t`);\n\n\t\tassert.ok(a instanceof Buffer);\n\t\tassert.ok(b instanceof Buffer);\n\t\tassert.ok(c instanceof Buffer);\n\t\tassert.ok(d instanceof Buffer);\n\t\tassert.ok(a.constructor === Buffer);\n\t\tassert.ok(b.constructor === Buffer);\n\t\tassert.ok(c.constructor === Buffer);\n\t\tassert.ok(d.constructor === Buffer);\n\t\tassert.ok(a.constructor.constructor === Function);\n\t\tassert.ok(b.constructor.constructor === Function);\n\t\tassert.ok(c.constructor.constructor === Function);\n\t\tassert.ok(d.constructor.constructor === Function);\n\t});\n\n\tit('function', () => {\n\t\tassert.strictEqual(vm.run('test.function instanceof Function'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.function() instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.function()() instanceof Object'), true, '#3');\n\t});\n\n\tit('object', () => {\n\t\tassert.strictEqual(vm.run('test.object instanceof Object && test.object.x === 1'), true, '#1');\n\t\tassert.strictEqual(vm.run('test.object.y instanceof Function'), true, '#2');\n\t\tassert.strictEqual(vm.run('test.object.y() instanceof Function'), true, '#3');\n\t\tassert.strictEqual(vm.run('test.object.y()({})'), true, '#4');\n\t\tassert.strictEqual(vm.run('test.object.z({}) instanceof Object'), true, '#5');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty instanceof Function\"), true, '#6');\n\t\tassert.strictEqual(vm.run(\"Object.getOwnPropertyDescriptor(test.object, 'y').hasOwnProperty.constructor('return (function(){return this})().isHost')()\"), undefined, '#7');\n\t});\n\n\tit('null', () => {\n\t\tassert.strictEqual(vm.run('test.nil === null'), true);\n\t});\n\n\tit('undefined', () => {\n\t\tassert.strictEqual(vm.run('test.undef === undefined'), true);\n\t});\n\n\tit('symbol', () => {\n\t\tassert.strictEqual(vm.run(\"Symbol.for('foo') === test.symbol2\"), true);\n\t\tassert.strictEqual(vm.run('test.symbol1.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol2.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run('test.symbol3.constructor.constructor === Function'), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foo').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run(\"Symbol('foobar').constructor.constructor === Function\"), true);\n\t\tassert.strictEqual(vm.run('Symbol.keyFor(test.symbol2)'), 'foo');\n\t});\n\n\tit('error', () => {\n\t\tassert.strictEqual(vm.run('test.error.constructor.constructor === Function;'), true);\n\t});\n\n\tit('tostring', () => {\n\t\tconst list = [\n\t\t\t'Object',\n\t\t\t'Array',\n\t\t\t'Number',\n\t\t\t'String',\n\t\t\t'Boolean',\n\t\t\t'Date',\n\t\t\t'RegExp',\n\t\t\t'Map',\n\t\t\t'WeakMap',\n\t\t\t'Set',\n\t\t\t'WeakSet',\n\t\t\t'Function',\n\t\t\t'RangeError',\n\t\t\t'ReferenceError',\n\t\t\t'SyntaxError',\n\t\t\t'TypeError',\n\t\t\t'EvalError',\n\t\t\t'URIError',\n\t\t\t'Error'\n\t\t];\n\t\tconst gen = vm.run('name => new (global[name])()');\n\t\tconst oToString = Object.prototype.toString;\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst obj = list[i];\n\t\t\tassert.strictEqual(oToString.call(gen(obj)), oToString.call(new (global[obj])()));\n\t\t}\n\t});\n\n\tit('arguments', () => {\n\t\tassert.doesNotThrow(() => vm.run('(o) => o.arguments')({arguments: 1}));\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('VM', () => {\n\tlet vm;\n\n\tconst sandbox = {\n\t\tround(number) {\n\t\t\treturn Math.round(number);\n\t\t},\n\t\tsub: {}\n\t};\n\n\tObject.defineProperty(sandbox.sub, 'getter', {\n\t\tget() {\n\t\t\tconst results = [];\n\t\t\twhile (true) {\n\t\t\t\tresults.push(1);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t});\n\n\tbefore(() => {\n\t\tvm = new VM({\n\t\t\tsandbox\n\t\t});\n\t});\n\n\tit('globals', () => {\n\t\tconst dyn = {};\n\t\tvm.setGlobal('dyn', dyn);\n\t\tvm.setGlobals({dyns: dyn});\n\t\tassert.equal(vm.run('round(1.5)'), 2);\n\t\tassert.equal(vm.getGlobal('dyn'), dyn);\n\t\tassert.equal(vm.sandbox.dyn, dyn);\n\t\tassert.equal(vm.sandbox.dyns, dyn);\n\t});\n\n\tit('errors', () => {\n\t\tassert.throws(() => vm.run('notdefined'), /notdefined is not defined/);\n\t\tassert.throws(() => vm.run('Object.setPrototypeOf(sub, {})'), err => {\n\t\t\tassert.ok(err instanceof Error);\n\t\t\tassert.equal(err.name, 'VMError');\n\t\t\tassert.equal(err.message, 'Operation not allowed on contextified object.');\n\t\t\treturn true;\n\t\t});\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\t// async/await was not there in Node 6\n\t\t\tassert.throws(() => vm.run('function test(){ return await Promise.resolve(); };'), err => {\n\t\t\t\tassert.ok(err instanceof Error);\n\t\t\t\tassert.equal(err.name, 'SyntaxError');\n\t\t\t\t// assert.match(err.message, /await is only valid in async function/); // Changed due to acorn\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t\tassert.throws(() => new VM({compiler: 'nonexistant'}), /Unsupported compiler/);\n\t\tassert.throws(() => new VMScript('', '', {compiler: 'nonexistant'}), /Unsupported compiler/);\n\t});\n\n\tit('timeout', () => {\n\t\tconst message = NODE_VERSION >= 11 ? /Script execution timed out after 10ms/ : /Script execution timed out\\./;\n\n\t\tassert.throws(() => new VM({\n\t\t\ttimeout: 10\n\t\t}).run('while (true) {}'), message);\n\t\tassert.throws(() => new VM({timeout: 10, sandbox}).run('sub.getter'), message);\n\t});\n\n\tit('timers', () => {\n\t\tassert.equal(vm.run('global.setTimeout'), void 0);\n\t\tassert.equal(vm.run('global.setInterval'), void 0);\n\t\tassert.equal(vm.run('global.setImmediate'), void 0);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('eval/wasm', () => {\n\t\t\tassert.equal(vm.run('eval(\"1\")'), 1);\n\n\t\t\tconst vm2 = new VM({eval: false});\n\t\t\tassert.throws(() => vm2.run('eval(\"1\")'), /Code generation from strings disallowed for this context/);\n\t\t});\n\t}\n\n\tif (NODE_VERSION > 7) {\n\t\t// Node until 7 had no async, see https://node.green/\n\t\tit('async', () => {\n\t\t\tconst vm2 = new VM({fixAsync: true});\n\t\t\tassert.throws(() => vm2.run('(async function(){})'), /Async not available/, '#1');\n\t\t\tassert.strictEqual(vm2.run('Object.getPrototypeOf((function*(){}).constructor)'), vm2.run('Function'), '#2');\n\t\t\tassert.throws(() => vm2.run('new Function(\"(as\"+\"ync function(){})\")'), /Async not available/, '#3');\n\t\t\tassert.throws(() => vm2.run('new (function*(){}).constructor(\"(as\"+\"ync function(){})\")'), /Async not available/, '#4');\n\t\t\tassert.throws(() => vm2.run('Promise.resolve().then(function(){})'), /Async not available/, '#5');\n\t\t\tif (Promise.prototype.finally) assert.throws(() => vm2.run('Promise.resolve().finally(function(){})'), /Async not available/, '#6');\n\t\t\tif (Promise.prototype.catch) assert.throws(() => vm2.run('Promise.resolve().catch(function(){})'), /Async not available/, '#7');\n\t\t\tassert.throws(() => vm2.run('eval(\"(as\"+\"ync function(){})\")'), /Async not available/, '#8');\n\t\t\tassert.throws(() => vm2.run('Function')('(async function(){})'), /Async not available/, '#9');\n\t\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\t\tlet a = {import: 1}\n\t\t\t\tlet b = {import : {\"import\": 2}};\n\t\t\t\tlet c = { import : 1};\n\t\t\t\tlet d = a.import;\n\t\t\t\tlet e = a. import;\n\t\t\t\tlet f = a.import-1;\n\t\t\t\tlet g = a.import.import;\n\t\t\t`));\n\t\t});\n\t}\n\n\tit('proxy trap errors', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tReflect.ownKeys(vm2.run('(function(){}).bind(null)'));\n\t\t});\n\t});\n\n\tit('frozen unconfigurable access', () => {\n\t\tconst vm2 = new VM();\n\t\tconst obj = {};\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.getOwnPropertyDescriptor(x, \"prop\")')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => x.prop')(Object.defineProperty({}, 'prop', {value: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => Object.isExtensible(x)')(Object.freeze({prop: {}}));\n\t\t});\n\n\t\tassert.doesNotThrow(()=>{\n\t\t\tvm2.run('x => {Object.preventExtensions(x); Object.getOwnPropertyDescriptor(x, \"prop\")}')({prop: {}});\n\t\t});\n\n\t\tassert.strictEqual(vm2.run('x => {Object.preventExtensions(x); return Object.getOwnPropertyDescriptor(x, \"prop\").value}')({prop: obj}), obj);\n\n\t});\n\n\tit('various attacks #1', () => {\n\t\tconst vm2 = new VM({sandbox: {log: console.log, boom: () => {\n\t\t\tthrow new Error();\n\t\t}}});\n\n\t\tassert.strictEqual(vm2.run(\"this.constructor.constructor('return Function(\\\\'return Function\\\\')')()() === this.constructor.constructor('return Function')()\"), true);\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tconst ForeignFunction = global.constructor.constructor;\n\t\t\tconst process1 = ForeignFunction(\"return process\")();\n\t\t`), /process is not defined/, '#1');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t    try {\n\t\t        boom();\n\t\t    }\n\t\t    catch (e) {\n\t\t        const foreignFunction = e.constructor.constructor;\n\t\t        const process = foreignFunction(\"return process\")();\n\t\t    }\n\t\t`), /process is not defined/, '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tfunction exploit(o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\n\t\t\tReflect.construct = exploit;\n\t\t\tBuffer.from([0]);\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Proxy = function() {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)('asdf'), '#5');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.String = function(text) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(text) {})\n\t\t`)(new String('asdf')), '#6');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tglobal.Buffer = function(value) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};(function(value) {})\n\t\t`)(Buffer.alloc(1)), '#7');\n\t});\n\n\tit('various attacks #2', () => {\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tboom: () => {},\n\t\t\t\terror: new Error('test')\n\t\t\t}\n\t\t});\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.assign = function (o) {\n\t\t\t\tthrow new Error('Shouldnt be there.');\n\t\t\t};\n\t\t\tBuffer.from([0]);\n\t\t`), '#1');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\ttry {\n\t\t\t\tBuffer.alloc(0);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t}\n\t\t`), '#2');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet o;\n\t\t\tArray.prototype.map = function(callback) {\n\t\t\t\to = callback(boom);\n\t\t\t\treturn [];\n\t\t\t};\n\t\t\tboom(boom);\n\t\t\tif (o && o.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t`), '#3');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet method = () => {};\n\t\t\tlet proxy = new Proxy(method, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (target.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy\n\t\t`)('asdf'), '#4');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tlet proxy2 = new Proxy(function() {}, {\n\t\t\t\tapply: (target, context, args) => {\n\t\t\t\t\tif (args.constructor.constructor !== Function) throw new Error('Shouldnt be there.');\n\t\t\t\t}\n\t\t\t});\n\t\t\tproxy2\n\t\t`)('asdf'), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.DEBUG = true;\n\t\t\tboom.vmProxyTarget\n\t\t`), undefined, '#6');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#7');\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tglobal.__proto__.constructor.constructor('return this')().constructor.constructor('return process')()\n\t\t`), /process is not defined/, '#8');\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tif (!(Object.keys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t\tif (!(Reflect.ownKeys(boom) instanceof Array)) throw new Error('Shouldnt be there.');\n\t\t`));\n\t});\n\n\tit('internal state attack', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.throws(() => vm2.run(`${INTERNAL_STATE_NAME}=\"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`const ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`var ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`let ${INTERNAL_STATE_NAME} = \"async\";`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`class ${INTERNAL_STATE_NAME} {}; // async`), /Use of internal vm2 state variable/);\n\t\tassert.throws(() => vm2.run(`function ${INTERNAL_STATE_NAME} () {}; // async`), /Use of internal vm2 state variable/);\n\t});\n\n\tit('buffer attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#1');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).constructor.constructor === Function;\n\t\t`), true, '#2');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.allocUnsafe(100).toString('hex');\n\t\t`), '00'.repeat(100), '#3');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer extends Buffer {}; MyBuffer.alloc(100).toString('hex');\n\t\t`), '00'.repeat(100), '#4');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tnew Buffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#5');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer(100).toString('hex');\n\t\t`), '00'.repeat(100), '#6');\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tclass MyBuffer2 extends Buffer {}; new MyBuffer2(100).toString('hex');\n\t\t`), '00'.repeat(100), '#7');\n\n\t});\n\n\tit('instanceof attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/174\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tfunc: cb => cb()\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tvm2.run(`\n\t\t\t\tfunc(() => {\n\t\t\t\t\tthrow new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf: () => {\n\t\t\t\t\t\t\tthrow x => x.constructor.constructor(\"return process;\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t`);\n\t\t} catch (ex) {\n\t\t\tassert.throws(()=>{\n\t\t\t\tex(()=>{});\n\t\t\t}, /process is not defined/);\n\t\t}\n\t});\n\n\tit('__defineGetter__ / __defineSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/176\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.prototype.__defineGetter__ === {}.__defineGetter__;\n\t\t`), true, '#1');\n\n\t\tif (NODE_VERSION > 6) {\n\t\t\tassert.throws(() => vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"toString\", () => {});\n\t\t\t`), /'defineProperty' on proxy: trap returned falsish for property 'toString'/, '#2');\n\t\t} else {\n\t\t\tassert.strictEqual(vm2.run(`\n\t\t\t\tBuffer.prototype.__defineGetter__(\"xxx\", () => 4);\n\t\t\t\tBuffer.prototype.xxx;\n\t\t\t`), undefined, '#2');\n\t\t}\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tglobal.__defineGetter__(\"test\", () => 123); global.test;\n\t\t`), 123, '#3');\n\t});\n\n\tit('__lookupGetter__ / __lookupSetter__ attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/184\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`\n\t\t\tBuffer.from.__lookupGetter__(\"__proto__\") === Object.prototype.__lookupGetter__.call(Buffer.from, \"__proto__\");\n\t\t`), true, '#1');\n\t});\n\n\tit('contextifying a contextified value attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/175\n\t\t// https://github.com/patriksimek/vm2/issues/177\n\t\t// https://github.com/patriksimek/vm2/issues/186\n\n\t\tlet vm2 = new VM();\n\n\t\t// The Buffer.from(\"\") is only used to get instance of object contextified from the host\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"x\", {\n\t\t\t\tget set() {\n\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn ()=>{};\n\t\t\t\t}\n\t\t\t});\n\t\t`), '#1');\n\n\t\tvm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tctor: X => new X(),\n\t\t\t\tcall: x => x()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall(ctor(new Proxy(class A {}, {\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn () => x => x.constructor(\"return process\")();\n\t\t\t\t}\n\t\t\t})))(()=>{}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#2');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"), \"y\", {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\t\tdelete this.getPrototypeOf;\n\n\t\t\t\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {\n\t\t\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\t\t\t\t\tFunction.prototype.__proto__ = null;\n\t\t\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /Cannot read propert.*mainModule/, '#3');\n\n\t\tvm2 = new VM();\n\n\t\tassert.doesNotThrow(() => vm2.run(`\n\t\t\tObject.defineProperty(Buffer.from(\"\"), \"\", {\n\t\t\t\tvalue: new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf(target) {\n\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\tthrow Buffer.from;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.t=true;\n\t\t\t\t\t\treturn Object.getPrototypeOf(target);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t`), '#4');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar process;\n\t\t\ttry {\n\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\tgetPrototypeOf() {\n\t\t\t\t\t\tif (this.t) {\n\t\t\t\t\t\t\tthrow x => x.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch(e) {\n\t\t\t\tprocess = e(() => {});\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#5');\n\n\n\t\t/* TODO internal have changed too much for this to still work\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tFunction.prototype.__proto__ = null;\n\t\t\tvar map = {\n\t\t\t\tvalueOf(){\n\t\t\t\t\tthrow new Proxy({},{\n\t\t\t\t\t\tgetPrototypeOf(){\n\t\t\t\t\t\t\tif(this.t) {\n\t\t\t\t\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.t = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess.mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /e is not a function/, '#6');\n\t\t*/\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar map = {valueOf(){}};\n\t\t\tvar arrayBackup = Array;\n\t\t\tArray = function(){\n\t\t\t\tArray = arrayBackup;\n\t\t\t\tthrow x=>x.constructor(\"return process\")();\n\t\t\t};\n\t\t\tvar process;\n\t\t\ttry{\n\t\t\t\tBuffer.from(map);\n\t\t\t}catch(e){\n\t\t\t\tprocess = e(x=>x);\n\t\t\t}\n\t\t\tprocess\n\t\t`), /e is not a function/, '#7');\n\t});\n\n\tit('proxy trap via Object.prototype attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tlet process;\n\t\t\tObject.prototype.has = (t, k) => {\n\t\t\t\tprocess = t.constructor(\"return process\")();\n\t\t\t}\n\t\t\t\"\" in Buffer.from;\n\t\t\tprocess.mainModule;\n\t\t`), /Cannot read propert.*mainModule/, '#1');\n\n\t\tconst vm22 = new VM();\n\n\t\tassert.throws(() => vm22.run(`\n\t\t\tObject.defineProperty(Object.prototype, \"apply\", {set:function(o,v){\n\t\t\t\tdelete Object.prototype.apply;\n\t\t\t}});\n\t\t\tBuffer.from(\"\").constructor.constructor(\"return process\")().mainModule;\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Object.create attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tvar oc = Object.create;\n\t\t\tObject.create = (p,x)=> Object.defineProperty(oc(p,x),\"get\",{set(){},get:()=>(t,k,r)=>t.constructor(\"return process\")()});\n\t\t\tvar process = Buffer.from.process;\n\t\t\tObject.create = oc;\n\t\t\tprocess.mainModule\n\t\t`), /Cannot read propert.*mainModule/, '#1');\n\t});\n\n\tit('function returned from construct attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/179\n\n\t\tconst vm2 = new VM({\n\t\t\tsandbox: {\n\t\t\t\tcall: x => x.a(),\n\t\t\t\tctor: X => new X()\n\t\t\t}\n\t\t});\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tcall({a:ctor(new Proxy(class A{},{\n\t\t\t\tconstruct(){\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\treturn Object.getPrototypeOf(this).constructor.constructor(\"return process\")();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}))}).mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\t});\n\n\tit('throw while accessing propertyDescriptor properties', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450904979\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.strictEqual(vm2.run(`(function(){\n\t\t\tvar process;\n\t\t\tObject.defineProperty(Object.prototype, \"set\", {get(){\n\t\t\t\tdelete Object.prototype.set;\n\t\t\t\tObject.defineProperty(Object.prototype, \"get\", {get(){\n\t\t\t\t\tdelete Object.prototype.get;\n\t\t\t\t\tthrow new Proxy(Object.create(null),{\n\t\t\t\t\t\tset(t,k,v){\n\t\t\t\t\t\t\tprocess = v.constructor(\"return process\")();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},configurable:true});\n\t\t\t\treturn ()=>{};\n\t\t\t},configurable:true});\n\t\t\ttry{\n\t\t\t\tObject.defineProperty(Buffer.from(\"\"),\"\",{});\n\t\t\t}catch(e){\n\t\t\t\te.x = Buffer.from;\n\t\t\t}\n\t\t\treturn process;})()\n\t\t`), undefined, '#1');\n\t});\n\n\tit('Symbol.hasInstance attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tlet vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject.__defineGetter__(Symbol.hasInstance,()=>()=>true);\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"id\").toString()\n\t\t`), /process is not defined/, '#1');\n\n\t\tvm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\tObject[Symbol.hasInstance].call = ()=>true;\n\t\t\tBuffer.from.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"whoami\").toString()\n\t\t`), /process is not defined/, '#2');\n\t});\n\n\tit('Proxy::getOwnPropertyDescriptor attack', () => {\n\t\t// https://github.com/patriksimek/vm2/issues/178#issuecomment-450978210\n\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(() => vm2.run(`\n\t\t\t(function(){\n\t\t\t\ttry{\n\t\t\t\t\tBuffer.from(new Proxy({}, {\n\t\t\t\t\t\tgetOwnPropertyDescriptor(){\n\t\t\t\t\t\t\tthrow f=>f.constructor(\"return process\")();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn e(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n\t\t\t\t}\n\t\t\t})()\n\t\t`), /process is not defined/);\n\t});\n\n\tif (NODE_VERSION >= 10) {\n\t\tit('Dynamic import attack', () => {\n\n\t\t\tconst vm2 = new VM();\n\n\t\t\tassert.throws(()=>vm2.run(`\n\t\t\t\tconst process = import('oops!').constructor.constructor('return process')();\n\t\t\t`), /VMError: Dynamic Import not supported/);\n\t\t});\n\t}\n\n\tit('Error.prepareStackTrace attack', () => {\n\t\tconst vm2 = new VM();\n\t\tconst sst = vm2.run('Error.prepareStackTrace = (e,sst)=>sst;const sst = new Error().stack;Error.prepareStackTrace = undefined;sst');\n\t\tassert.strictEqual(vm2.run('sst=>Object.getPrototypeOf(sst)')(sst), vm2.run('Array.prototype'));\n\t\tassert.throws(()=>vm2.run('sst=>sst[0].getThis().constructor.constructor')(sst), /TypeError: Cannot read propert.*constructor/);\n\t\tassert.throws(()=>vm2.run(`\n\t\t\tconst { set } = WeakMap.prototype;\n\t\t\tWeakMap.prototype.set = function(v) {\n\t\t\t\treturn set.call(this, v, v);\n\t\t\t};\n\t\t\tError.prepareStackTrace =\n\t\t\tError.prepareStackTrace =\n\t\t\t(_, c) => c.map(c => c.getThis()).find(a => a);\n\t\t\tconst { stack } = new Error();\n\t\t\tError.prepareStackTrace = undefined;\n\t\t\tstack.process\n\t\t`));\n\t\tassert.throws(()=>vm2.run(`(()=>{\n\t\t\tconst OldError = Error;\n\t\t\tglobal.Error = {prepareStackTrace: (_, c) => c.map(c => c.getThis()).find(a => a && a.process)};\n\t\t\tconst { stack } = new OldError();\n\t\t\tglobal.Error = OldError;\n\t\t\treturn stack.process.mainModule;\n\t\t})()`));\n\t});\n\n\tit('Node internal prepareStackTrace attack', () => {\n\t\tconst vm2 = new VM();\n\n\t\tassert.throws(()=>vm2.run(`\n\t\t\tfunction stack() {\n\t\t\t\tnew Error().stack;\n\t\t\t\tstack();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tstack();\n\t\t\t} catch (e) {\n\t\t\t\te.constructor.constructor(\"return process\")()\n\t\t\t}\n\t\t`), /process is not defined/);\n\n\t});\n\n\tit('Monkey patching attack', () => {\n\t\tconst vm2 = new VM();\n\t\tassert.doesNotThrow(() => {\n\t\t\tconst f = vm2.run(`\n\t\t\t\tfunction onget() {throw new Error();}\n\t\t\t\tfunction onset() {throw new Error();}\n\t\t\t\tconst desc = {__proto__: null, get: onget, set: onset};\n\t\t\t\tObject.defineProperties(Object.prototype, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\t'0': desc,\n\t\t\t\t\tget: desc,\n\t\t\t\t\tset: desc,\n\t\t\t\t\tapply: desc,\n\t\t\t\t\tcall: desc,\n\t\t\t\t\t'1': desc,\n\t\t\t\t\t'length': desc,\n\t\t\t\t});\n\t\t\t\tObject.defineProperties(Function.prototype, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tcall: desc,\n\t\t\t\t\tapply: desc,\n\t\t\t\t\tbind: desc,\n\t\t\t\t});\n\t\t\t\tfunction passer(a, b, c) {\n\t\t\t\t\treturn a(b, c);\n\t\t\t\t}\n\t\t\t`);\n\t\t\tf((a, b) => b, {}, {});\n\t\t});\n\t});\n\n\tafter(() => {\n\t\tvm = null;\n\t});\n});\n\ndescribe('precompiled scripts', () => {\n\tit('VM', () => {\n\t\tconst vm = new VM();\n\t\tconst script = new VMScript('global.i=global.i||0;global.i++');\n\t\tconst val1 = vm.run(script);\n\t\tconst val2 = vm.run(script);\n\t\tconst failScript = new VMScript('(');\n\t\tassert.ok('number' === typeof val1 && 'number' === typeof val2);\n\t\tassert.ok( val1 === 0 && val2 === 1);\n\t\tassert.throws(() => failScript.compile(), /SyntaxError/);\n\t\tassert.ok(Object.keys(failScript).includes('code'));\n\t\tassert.ok(Object.keys(failScript).includes('filename'));\n\t\tassert.ok(Object.keys(failScript).includes('compiler'));\n\t\tassert.ok(!Object.keys(failScript).includes('_code'));\n\t});\n});\n\ndescribe('freeze, protect', () => {\n\tit('without freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM({\n\t\t\tsandbox: {x}\n\t\t});\n\t\tvm.run('x.a = () => { return `-` }; x.c.d = () => { return `---` }; (y) => { y.b = () => { return `--` } }')(x);\n\n\t\tassert.strictEqual(x.a(), '-');\n\t\tassert.strictEqual(x.b(), '--');\n\t\tassert.strictEqual(x.c.d(), '---');\n\t});\n\n\tit('with freeze', () => {\n\t\tconst x = {\n\t\t\ta: () => 'a',\n\t\t\tb: () => 'b',\n\t\t\tc: {\n\t\t\t\td: () => 'd'\n\t\t\t}\n\t\t};\n\n\t\tconst vm = new VM();\n\t\tvm.freeze(x, 'x');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.a = () => { return `-` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'a'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (y) => { y.b = () => { return `--` } }')(x);\n\t\t}, /'set' on proxy: trap returned falsish for property 'b'/);\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; x.c.d = () => { return `---` };');\n\t\t}, /'set' on proxy: trap returned falsish for property 'd'/);\n\n\t\tvm.run('x.a = () => { return `-` };');\n\t\tassert.strictEqual(x.a(), 'a');\n\n\t\tvm.run('(y) => { y.b = () => { return `--` } }')(x);\n\t\tassert.strictEqual(x.b(), 'b');\n\n\t\tvm.run('x.c.d = () => { return `---` };');\n\t\tassert.strictEqual(x.c.d(), 'd');\n\n\t\t// Extension of frozen objects should be writeable.\n\t\tassert.strictEqual(vm.run('y = Object.create(x); y.f = 1; y.f'), 1);\n\t});\n\n\tit('without protect', () => {\n\t\tconst vm = new VM(); const obj = {};\n\t\tvm.run('(i) => { i.text = \"test\" }')(obj);\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tvm.run('(i) => { delete i.func }')(obj);\n\t});\n\n\tit('with protect', () => {\n\t\tconst vm = new VM(); const obj = {\n\t\t\tdate: new Date(),\n\t\t\tarray: [{}, {}]\n\t\t};\n\n\t\tvm.protect(obj);\n\n\t\tvm.run('(i) => { i.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array.func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array.func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array.func = () => {} }')(obj);\n\t\t});\n\n\t\tvm.run('(i) => { i.array[0].func = () => {} }')(obj);\n\t\tassert.strictEqual(typeof obj.array[0].func, 'undefined');\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { i.array[0].func = () => {} }')(obj);\n\t\t});\n\n\t\tassert.throws(() => {\n\t\t\tvm.run('\"use strict\"; (i) => { Object.defineProperty(i, \"toString\", { get(){ return () => \\'Not protected\\'; } }) }')(obj);\n\t\t});\n\n\t\tassert.strictEqual(vm.run('(i) => i.array.map(item => 1).join(\",\")')(obj), '1,1');\n\t\tassert.strictEqual(vm.run('(i) => /x/.test(i.date)')(obj), false);\n\t});\n});\n"], "filenames": ["lib/setup-sandbox.js", "test/vm.js"], "buggy_code_start_loc": [70, 1072], "buggy_code_end_loc": [71, 1072], "fixing_code_start_loc": [70, 1073], "fixing_code_end_loc": [72, 1080], "type": "CWE-913", "message": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. In versions prior to version 3.9.11, a threat actor can bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version 3.9.11 of vm2. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-36067", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T22:15:09.207", "lastModified": "2022-11-08T03:03:23.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. In versions prior to version 3.9.11, a threat actor can bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version 3.9.11 of vm2. There are no known workarounds."}, {"lang": "es", "value": "vm2 es un sandbox que puede ejecutar c\u00f3digo no confiable con los m\u00f3dulos incorporados de Node en la lista blanca. En versiones anteriores a 3.9.11, un actor de la amenaza puede omitir las protecciones del sandbox para conseguir derechos de ejecuci\u00f3n de c\u00f3digo remoto en el host que ejecuta el sandbox. Esta vulnerabilidad fue parcheada en el lanzamiento de la versi\u00f3n 3.9.11 de vm2. No se presentan mitigaciones conocidas.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-913"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-913"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.9.11", "matchCriteriaId": "3CB151FD-32BF-4CED-93D3-F07D6F62E4DC"}]}]}], "references": [{"url": "https://github.com/patriksimek/vm2/blob/master/lib/setup-sandbox.js#L71", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/commit/d9a7f3cc995d3d861e1380eafb886cb3c5e2b873#diff-b1a515a627d820118e76d0e323fe2f0589ed50a1eacb490f6c3278fe3698f164", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/issues/467", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/security/advisories/GHSA-mrgp-mrhc-5jrq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221017-0002/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oxeye.io/blog/vm2-sandbreak-vulnerability-cve-2022-36067", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/d9a7f3cc995d3d861e1380eafb886cb3c5e2b873#diff-b1a515a627d820118e76d0e323fe2f0589ed50a1eacb490f6c3278fe3698f164"}}