{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIIIIIIII    PPPPPPPP      LL                          %\n%                         II        PP      PP    LL                          %\n%                         II        PP       PP   LL                          %\n%                         II        PP      PP    LL                          %\n%                         II        PPPPPPPP      LL                          %\n%                         II        PP            LL                          %\n%                         II        PP            LL                          %\n%                     IIIIIIIIII    PP            LLLLLLLL                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Scanalytics IPLab Image Format                 %\n%                                  Sean Burke                                 %\n%                                  2008.05.07                                 %\n%                                     v 0.9                                   %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n/*\n Include declarations.\n */\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\n/*\n  Typedef declarations.\n*/\n\ntypedef struct _IPLInfo\n{\n  unsigned int\n    tag,\n    size,\n    time,\n    z,\n    width,\n    height,\n    colors,\n    depth,\n    byteType;\n} IPLInfo;\n\nstatic MagickBooleanType\n  WriteIPLImage(const ImageInfo *,Image *);\n\n/*\nstatic void increase (void *pixel, int byteType){\n  switch(byteType){\n    case 0:(*((unsigned char *) pixel))++; break;\n    case 1:(*((signed int *) pixel))++; break;\n    case 2:(*((unsigned int *) pixel))++; break;\n    case 3:(*((signed long *) pixel))++; break;\n    default:(*((unsigned int *) pixel))++; break;\n  }\n}\n*/\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   I s I P L                                                                 %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  IsIPL() returns MagickTrue if the image format type, identified by the\n %  magick string, is IPL.\n %\n %  The format of the IsIPL method is:\n %\n %      MagickBooleanType IsIPL(const unsigned char *magick,const size_t length)\n %\n %  A description of each parameter follows:\n %\n %    o magick: compare image format pattern against these bytes.\n %\n %    o length: Specifies the length of the magick string.\n %\n */\nstatic MagickBooleanType IsIPL(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"data\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %    R e a d I P L I m a g e                                                  %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  ReadIPLImage() reads a Scanalytics IPLab image file and returns it.  It\n %  allocates the memory necessary for the new Image structure and returns a\n %  pointer to the new image.\n %\n %  According to the IPLab spec, the data is blocked out in five dimensions:\n %  { t, z, c, y, x }.  When we return the image, the latter three are folded\n %  into the standard \"Image\" structure.  The \"scenes\" (image_info->scene)\n %  correspond to the order: { {t0,z0}, {t0, z1}, ..., {t1,z0}, {t1,z1}... }\n %  The number of scenes is t*z.\n %\n %  The format of the ReadIPLImage method is:\n %\n %      Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n %\n %  A description of each parameter follows:\n %\n %    o image_info: The image info.\n %\n %    o exception: return any errors or warnings in this structure.\n %\n */\n\nstatic void SetHeaderFromIPL(Image *image, IPLInfo *ipl){\n  image->columns = ipl->width;\n  image->rows = ipl->height;\n  image->depth = ipl->depth;\n  image->x_resolution = 1;\n  image->y_resolution = 1;\n}\n\n\nstatic Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n\n  /*\n    Declare variables.\n  */\n  Image *image;\n\n  MagickBooleanType status;\n  register PixelPacket *q;\n  unsigned char magick[12], *pixels;\n  ssize_t count;\n  ssize_t y;\n  size_t t_count=0;\n  size_t length;\n  IPLInfo\n    ipl_info;\n  QuantumFormatType\n    quantum_format;\n  QuantumInfo\n    *quantum_info;\n  QuantumType\n    quantum_type;\n\n  /*\n   Open Image\n   */\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if ( image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent, GetMagickModule(), \"%s\",\n                image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    image=DestroyImageList(image);\n    return((Image *) NULL);\n  }\n\n  /*\n    Read IPL image\n  */\n\n  /*\n    Determine endianness\n    If we get back \"iiii\", we have LSB,\"mmmm\", MSB\n  */\n  count=ReadBlob(image,4,magick);\n  (void) count;\n  if((LocaleNCompare((char *) magick,\"iiii\",4) == 0))\n    image->endian=LSBEndian;\n  else{\n    if((LocaleNCompare((char *) magick,\"mmmm\",4) == 0))\n      image->endian=MSBEndian;\n    else{\n      ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n    }\n  }\n  /* Skip o'er the next 8 bytes (garbage) */\n  count=ReadBlob(image, 8, magick);\n  /*\n   Excellent, now we read the header unimpeded.\n   */\n  count=ReadBlob(image,4,magick);\n  if((LocaleNCompare((char *) magick,\"data\",4) != 0))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  ipl_info.size=ReadBlobLong(image);\n  ipl_info.width=ReadBlobLong(image);\n  ipl_info.height=ReadBlobLong(image);\n  if((ipl_info.width == 0UL) || (ipl_info.height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  ipl_info.colors=ReadBlobLong(image);\n  if(ipl_info.colors == 3){ SetImageColorspace(image,sRGBColorspace);}\n  else { image->colorspace = GRAYColorspace; }\n  ipl_info.z=ReadBlobLong(image);\n  ipl_info.time=ReadBlobLong(image);\n\n  ipl_info.byteType=ReadBlobLong(image);\n\n\n  /* Initialize Quantum Info */\n\n  switch (ipl_info.byteType) {\n    case 0:\n      ipl_info.depth=8;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 1:\n      ipl_info.depth=16;\n      quantum_format = SignedQuantumFormat;\n      break;\n    case 2:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 3:\n      ipl_info.depth=32;\n      quantum_format = SignedQuantumFormat;\n      break;\n    case 4: ipl_info.depth=32;\n      quantum_format = FloatingPointQuantumFormat;\n      break;\n    case 5:\n      ipl_info.depth=8;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 6:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 10:\n      ipl_info.depth=64;\n      quantum_format = FloatingPointQuantumFormat;\n      break;\n    default:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n  }\n\n  /*\n    Set number of scenes of image\n  */\n\n  SetHeaderFromIPL(image, &ipl_info);\n\n  /* Thats all we need if we are pinging. */\n  if (image_info->ping != MagickFalse)\n  {\n    (void) CloseBlob(image);\n    return(GetFirstImageInList(image));\n  }\n  length=image->columns;\n  quantum_type=GetQuantumType(image,exception);\n do\n  {\n    SetHeaderFromIPL(image, &ipl_info);\n\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n/*\n   printf(\"Length: %.20g, Memory size: %.20g\\n\", (double) length,(double)\n     image->depth);\n*/\n     quantum_info=AcquireQuantumInfo(image_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     status=SetQuantumFormat(image,quantum_info,quantum_format);\n     if (status == MagickFalse)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixels=GetQuantumPixels(quantum_info);\n     if(image->columns != ipl_info.width){\n/*\n     printf(\"Columns not set correctly!  Wanted: %.20g, got: %.20g\\n\",\n       (double) ipl_info.width, (double) image->columns);\n*/\n     }\n\n    /*\n      Covert IPL binary to pixel packets\n    */\n\n  if(ipl_info.colors == 1){\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n                break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          GrayQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n    }\n  }\n  else{\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n                break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          RedQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          GreenQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          BlueQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n   }\n   SetQuantumImageType(image,quantum_type);\n\n    t_count++;\n  quantum_info = DestroyQuantumInfo(quantum_info);\n\n    if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n                 image->filename);\n      break;\n    }\n   if(t_count < ipl_info.z * ipl_info.time){\n      /*\n       Proceed to next image.\n       */\n      AcquireNextImage(image_info, image);\n      if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n        GetBlobSize(image));\n      if (status == MagickFalse)\n        break;\n    }\n  } while (t_count < ipl_info.z*ipl_info.time);\n  CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   R e g i s t e r I P L I m a g e                                           %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n % RegisterIPLImage() add attributes for the Scanalytics IPL image format to the\n % list of supported formats.\n %\n %\n */\nModuleExport size_t RegisterIPLImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"IPL\");\n  entry->decoder=(DecodeImageHandler *) ReadIPLImage;\n  entry->encoder=(EncodeImageHandler *) WriteIPLImage;\n  entry->magick=(IsImageFormatHandler *) IsIPL;\n  entry->adjoin=MagickTrue;\n  entry->description=ConstantString(\"IPL Image Sequence\");\n  entry->module=ConstantString(\"IPL\");\n  entry->endian_support=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   U n r e g i s t e r I P L I m a g e                                       %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  UnregisterIPLImage() removes format registrations made by the\n %  IPL module from the list of supported formats.\n %\n %  The format of the UnregisterIPLImage method is:\n %\n %      UnregisterIPLImage(void)\n %\n */\nModuleExport void UnregisterIPLImage(void)\n{\n  (void) UnregisterMagickInfo(\"IPL\");\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   W r i t e I P L I m a g e                                                 %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  WriteIPLImage() writes an image to a file in Scanalytics IPLabimage format.\n %\n %  The format of the WriteIPLImage method is:\n %\n %      MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n %\n %  A description of each parameter follows.\n %\n %    o image_info: The image info.\n %\n %    o image:  The image.\n %\n */\n\nstatic MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  IPLInfo\n    ipl_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const PixelPacket\n    *p;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n\n  quantum_info=AcquireQuantumInfo(image_info, image);\n  if ((quantum_info->format == UndefinedQuantumFormat) &&\n      (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n    SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n  switch(quantum_info->depth){\n  case 8:\n    ipl_info.byteType = 0;\n    break;\n  case 16:\n    if(quantum_info->format == SignedQuantumFormat){\n      ipl_info.byteType = 2;\n    }\n    else{\n      ipl_info.byteType = 1;\n    }\n    break;\n  case 32:\n    if(quantum_info->format == FloatingPointQuantumFormat){\n      ipl_info.byteType = 3;\n    }\n    else{\n      ipl_info.byteType = 4;\n    }\n    break;\n  case 64:\n    ipl_info.byteType = 10;\n    break;\n  default:\n    ipl_info.byteType = 2;\n    break;\n\n  }\n  ipl_info.z = (unsigned int) GetImageListLength(image);\n  /* There is no current method for detecting whether we have T or Z stacks */\n  ipl_info.time = 1;\n  ipl_info.width = (unsigned int) image->columns;\n  ipl_info.height = (unsigned int) image->rows;\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }\n  else{ ipl_info.colors = 1; }\n\n  ipl_info.size = (unsigned int) (28 +\n    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);\n\n  /* Ok!  Calculations are done.  Lets write this puppy down! */\n\n  /*\n    Write IPL header.\n  */\n  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian\n  files!   The reader above can, but they cannot.  For compatability reasons, I will leave\n  the code in here, but it is all but useless if you want to use IPLab. */\n\n  if(image_info->endian == MSBEndian)\n    (void) WriteBlob(image, 4, (const unsigned char *) \"mmmm\");\n  else{\n    image->endian = LSBEndian;\n    (void) WriteBlob(image, 4, (const unsigned char *) \"iiii\");\n  }\n  (void) WriteBlobLong(image, 4);\n  (void) WriteBlob(image, 4, (const unsigned char *) \"100f\");\n  (void) WriteBlob(image, 4, (const unsigned char *) \"data\");\n  (void) WriteBlobLong(image, ipl_info.size);\n  (void) WriteBlobLong(image, ipl_info.width);\n  (void) WriteBlobLong(image, ipl_info.height);\n  (void) WriteBlobLong(image, ipl_info.colors);\n  if(image_info->adjoin == MagickFalse)\n  (void) WriteBlobLong(image, 1);\n  else\n  (void) WriteBlobLong(image, ipl_info.z);\n  (void) WriteBlobLong(image, ipl_info.time);\n  (void) WriteBlobLong(image, ipl_info.byteType);\n\n  exception=(&image->exception);\n  do\n    {\n      /*\n  Convert MIFF to IPL raster pixels.\n      */\n      pixels=GetQuantumPixels(quantum_info);\n  if(ipl_info.colors == 1){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      GrayQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n}\n  if(ipl_info.colors == 3){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      RedQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n    /* Green frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        GreenQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n    }\n    /* Blue frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        BlueQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    break;\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,SaveImagesTag,scene++,\n        GetImageListLength(image));\n      if (status == MagickFalse)\n        break;\n    }while (image_info->adjoin != MagickFalse);\n\n  (void) WriteBlob(image, 4, (const unsigned char *) \"fini\");\n  (void) WriteBlobLong(image, 0);\n\nCloseBlob(image);\nreturn(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIIIIIIII    PPPPPPPP      LL                          %\n%                         II        PP      PP    LL                          %\n%                         II        PP       PP   LL                          %\n%                         II        PP      PP    LL                          %\n%                         II        PPPPPPPP      LL                          %\n%                         II        PP            LL                          %\n%                         II        PP            LL                          %\n%                     IIIIIIIIII    PP            LLLLLLLL                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Scanalytics IPLab Image Format                 %\n%                                  Sean Burke                                 %\n%                                  2008.05.07                                 %\n%                                     v 0.9                                   %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\n/*\n Include declarations.\n */\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\n/*\n  Typedef declarations.\n*/\n\ntypedef struct _IPLInfo\n{\n  unsigned int\n    tag,\n    size,\n    time,\n    z,\n    width,\n    height,\n    colors,\n    depth,\n    byteType;\n} IPLInfo;\n\nstatic MagickBooleanType\n  WriteIPLImage(const ImageInfo *,Image *);\n\n/*\nstatic void increase (void *pixel, int byteType){\n  switch(byteType){\n    case 0:(*((unsigned char *) pixel))++; break;\n    case 1:(*((signed int *) pixel))++; break;\n    case 2:(*((unsigned int *) pixel))++; break;\n    case 3:(*((signed long *) pixel))++; break;\n    default:(*((unsigned int *) pixel))++; break;\n  }\n}\n*/\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   I s I P L                                                                 %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  IsIPL() returns MagickTrue if the image format type, identified by the\n %  magick string, is IPL.\n %\n %  The format of the IsIPL method is:\n %\n %      MagickBooleanType IsIPL(const unsigned char *magick,const size_t length)\n %\n %  A description of each parameter follows:\n %\n %    o magick: compare image format pattern against these bytes.\n %\n %    o length: Specifies the length of the magick string.\n %\n */\nstatic MagickBooleanType IsIPL(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"data\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %    R e a d I P L I m a g e                                                  %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  ReadIPLImage() reads a Scanalytics IPLab image file and returns it.  It\n %  allocates the memory necessary for the new Image structure and returns a\n %  pointer to the new image.\n %\n %  According to the IPLab spec, the data is blocked out in five dimensions:\n %  { t, z, c, y, x }.  When we return the image, the latter three are folded\n %  into the standard \"Image\" structure.  The \"scenes\" (image_info->scene)\n %  correspond to the order: { {t0,z0}, {t0, z1}, ..., {t1,z0}, {t1,z1}... }\n %  The number of scenes is t*z.\n %\n %  The format of the ReadIPLImage method is:\n %\n %      Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n %\n %  A description of each parameter follows:\n %\n %    o image_info: The image info.\n %\n %    o exception: return any errors or warnings in this structure.\n %\n */\n\nstatic void SetHeaderFromIPL(Image *image, IPLInfo *ipl){\n  image->columns = ipl->width;\n  image->rows = ipl->height;\n  image->depth = ipl->depth;\n  image->x_resolution = 1;\n  image->y_resolution = 1;\n}\n\n\nstatic Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n\n  /*\n    Declare variables.\n  */\n  Image *image;\n\n  MagickBooleanType status;\n  register PixelPacket *q;\n  unsigned char magick[12], *pixels;\n  ssize_t count;\n  ssize_t y;\n  size_t t_count=0;\n  size_t length;\n  IPLInfo\n    ipl_info;\n  QuantumFormatType\n    quantum_format;\n  QuantumInfo\n    *quantum_info;\n  QuantumType\n    quantum_type;\n\n  /*\n   Open Image\n   */\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if ( image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent, GetMagickModule(), \"%s\",\n                image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    image=DestroyImageList(image);\n    return((Image *) NULL);\n  }\n\n  /*\n    Read IPL image\n  */\n\n  /*\n    Determine endianness\n    If we get back \"iiii\", we have LSB,\"mmmm\", MSB\n  */\n  count=ReadBlob(image,4,magick);\n  (void) count;\n  if((LocaleNCompare((char *) magick,\"iiii\",4) == 0))\n    image->endian=LSBEndian;\n  else{\n    if((LocaleNCompare((char *) magick,\"mmmm\",4) == 0))\n      image->endian=MSBEndian;\n    else{\n      ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n    }\n  }\n  /* Skip o'er the next 8 bytes (garbage) */\n  count=ReadBlob(image, 8, magick);\n  /*\n   Excellent, now we read the header unimpeded.\n   */\n  count=ReadBlob(image,4,magick);\n  if((LocaleNCompare((char *) magick,\"data\",4) != 0))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  ipl_info.size=ReadBlobLong(image);\n  ipl_info.width=ReadBlobLong(image);\n  ipl_info.height=ReadBlobLong(image);\n  if((ipl_info.width == 0UL) || (ipl_info.height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  ipl_info.colors=ReadBlobLong(image);\n  if(ipl_info.colors == 3){ SetImageColorspace(image,sRGBColorspace);}\n  else { image->colorspace = GRAYColorspace; }\n  ipl_info.z=ReadBlobLong(image);\n  ipl_info.time=ReadBlobLong(image);\n\n  ipl_info.byteType=ReadBlobLong(image);\n\n\n  /* Initialize Quantum Info */\n\n  switch (ipl_info.byteType) {\n    case 0:\n      ipl_info.depth=8;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 1:\n      ipl_info.depth=16;\n      quantum_format = SignedQuantumFormat;\n      break;\n    case 2:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 3:\n      ipl_info.depth=32;\n      quantum_format = SignedQuantumFormat;\n      break;\n    case 4: ipl_info.depth=32;\n      quantum_format = FloatingPointQuantumFormat;\n      break;\n    case 5:\n      ipl_info.depth=8;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 6:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n    case 10:\n      ipl_info.depth=64;\n      quantum_format = FloatingPointQuantumFormat;\n      break;\n    default:\n      ipl_info.depth=16;\n      quantum_format = UnsignedQuantumFormat;\n      break;\n  }\n\n  /*\n    Set number of scenes of image\n  */\n\n  SetHeaderFromIPL(image, &ipl_info);\n\n  /* Thats all we need if we are pinging. */\n  if (image_info->ping != MagickFalse)\n  {\n    (void) CloseBlob(image);\n    return(GetFirstImageInList(image));\n  }\n  length=image->columns;\n  quantum_type=GetQuantumType(image,exception);\n do\n  {\n    SetHeaderFromIPL(image, &ipl_info);\n\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n/*\n   printf(\"Length: %.20g, Memory size: %.20g\\n\", (double) length,(double)\n     image->depth);\n*/\n     quantum_info=AcquireQuantumInfo(image_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     status=SetQuantumFormat(image,quantum_info,quantum_format);\n     if (status == MagickFalse)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixels=GetQuantumPixels(quantum_info);\n     if(image->columns != ipl_info.width){\n/*\n     printf(\"Columns not set correctly!  Wanted: %.20g, got: %.20g\\n\",\n       (double) ipl_info.width, (double) image->columns);\n*/\n     }\n\n    /*\n      Covert IPL binary to pixel packets\n    */\n\n  if(ipl_info.colors == 1){\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n                break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          GrayQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n    }\n  }\n  else{\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n                break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          RedQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          GreenQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      for(y = 0; y < (ssize_t) image->rows; y++){\n        (void) ReadBlob(image, length*image->depth/8, pixels);\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n          BlueQuantum,pixels,exception);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n   }\n   SetQuantumImageType(image,quantum_type);\n\n    t_count++;\n  quantum_info = DestroyQuantumInfo(quantum_info);\n\n    if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n                 image->filename);\n      break;\n    }\n   if(t_count < ipl_info.z * ipl_info.time){\n      /*\n       Proceed to next image.\n       */\n      AcquireNextImage(image_info, image);\n      if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n        GetBlobSize(image));\n      if (status == MagickFalse)\n        break;\n    }\n  } while (t_count < ipl_info.z*ipl_info.time);\n  CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   R e g i s t e r I P L I m a g e                                           %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n % RegisterIPLImage() add attributes for the Scanalytics IPL image format to the\n % list of supported formats.\n %\n %\n */\nModuleExport size_t RegisterIPLImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"IPL\");\n  entry->decoder=(DecodeImageHandler *) ReadIPLImage;\n  entry->encoder=(EncodeImageHandler *) WriteIPLImage;\n  entry->magick=(IsImageFormatHandler *) IsIPL;\n  entry->adjoin=MagickTrue;\n  entry->description=ConstantString(\"IPL Image Sequence\");\n  entry->module=ConstantString(\"IPL\");\n  entry->endian_support=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   U n r e g i s t e r I P L I m a g e                                       %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  UnregisterIPLImage() removes format registrations made by the\n %  IPL module from the list of supported formats.\n %\n %  The format of the UnregisterIPLImage method is:\n %\n %      UnregisterIPLImage(void)\n %\n */\nModuleExport void UnregisterIPLImage(void)\n{\n  (void) UnregisterMagickInfo(\"IPL\");\n}\n\n/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %   W r i t e I P L I m a g e                                                 %\n %                                                                             %\n %                                                                             %\n %                                                                             %\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %\n %  WriteIPLImage() writes an image to a file in Scanalytics IPLabimage format.\n %\n %  The format of the WriteIPLImage method is:\n %\n %      MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n %\n %  A description of each parameter follows.\n %\n %    o image_info: The image info.\n %\n %    o image:  The image.\n %\n */\n\nstatic MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  IPLInfo\n    ipl_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const PixelPacket\n    *p;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n\n  quantum_info=AcquireQuantumInfo(image_info, image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((quantum_info->format == UndefinedQuantumFormat) &&\n      (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n    SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n  switch(quantum_info->depth){\n  case 8:\n    ipl_info.byteType = 0;\n    break;\n  case 16:\n    if(quantum_info->format == SignedQuantumFormat){\n      ipl_info.byteType = 2;\n    }\n    else{\n      ipl_info.byteType = 1;\n    }\n    break;\n  case 32:\n    if(quantum_info->format == FloatingPointQuantumFormat){\n      ipl_info.byteType = 3;\n    }\n    else{\n      ipl_info.byteType = 4;\n    }\n    break;\n  case 64:\n    ipl_info.byteType = 10;\n    break;\n  default:\n    ipl_info.byteType = 2;\n    break;\n\n  }\n  ipl_info.z = (unsigned int) GetImageListLength(image);\n  /* There is no current method for detecting whether we have T or Z stacks */\n  ipl_info.time = 1;\n  ipl_info.width = (unsigned int) image->columns;\n  ipl_info.height = (unsigned int) image->rows;\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }\n  else{ ipl_info.colors = 1; }\n\n  ipl_info.size = (unsigned int) (28 +\n    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);\n\n  /* Ok!  Calculations are done.  Lets write this puppy down! */\n\n  /*\n    Write IPL header.\n  */\n  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian\n  files!   The reader above can, but they cannot.  For compatability reasons, I will leave\n  the code in here, but it is all but useless if you want to use IPLab. */\n\n  if(image_info->endian == MSBEndian)\n    (void) WriteBlob(image, 4, (const unsigned char *) \"mmmm\");\n  else{\n    image->endian = LSBEndian;\n    (void) WriteBlob(image, 4, (const unsigned char *) \"iiii\");\n  }\n  (void) WriteBlobLong(image, 4);\n  (void) WriteBlob(image, 4, (const unsigned char *) \"100f\");\n  (void) WriteBlob(image, 4, (const unsigned char *) \"data\");\n  (void) WriteBlobLong(image, ipl_info.size);\n  (void) WriteBlobLong(image, ipl_info.width);\n  (void) WriteBlobLong(image, ipl_info.height);\n  (void) WriteBlobLong(image, ipl_info.colors);\n  if(image_info->adjoin == MagickFalse)\n  (void) WriteBlobLong(image, 1);\n  else\n  (void) WriteBlobLong(image, ipl_info.z);\n  (void) WriteBlobLong(image, ipl_info.time);\n  (void) WriteBlobLong(image, ipl_info.byteType);\n\n  exception=(&image->exception);\n  do\n    {\n      /*\n  Convert MIFF to IPL raster pixels.\n      */\n      pixels=GetQuantumPixels(quantum_info);\n  if(ipl_info.colors == 1){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      GrayQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n}\n  if(ipl_info.colors == 3){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      RedQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n    /* Green frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        GreenQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n    }\n    /* Blue frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        BlueQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    break;\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,SaveImagesTag,scene++,\n        GetImageListLength(image));\n      if (status == MagickFalse)\n        break;\n    }while (image_info->adjoin != MagickFalse);\n\n  (void) WriteBlob(image, 4, (const unsigned char *) \"fini\");\n  (void) WriteBlobLong(image, 0);\n\nCloseBlob(image);\nreturn(MagickTrue);\n}\n"], "filenames": ["coders/ipl.c"], "buggy_code_start_loc": [547], "buggy_code_end_loc": [547], "fixing_code_start_loc": [548], "fixing_code_end_loc": [550], "type": "CWE-284", "message": "coders/ipl.c in ImageMagick allows remote attackers to have unspecific impact by leveraging a missing malloc check.", "other": {"cve": {"id": "CVE-2016-10144", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:00.403", "lastModified": "2017-11-04T01:29:15.677", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "coders/ipl.c in ImageMagick allows remote attackers to have unspecific impact by leveraging a missing malloc check."}, {"lang": "es", "value": "coders/ipl.c en ImageMagick permite a los atacantes remotos tener un impacto inespec\u00edfico aprovechando un check perdido de malloc."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "matchCriteriaId": "BE6EA542-A222-4E6A-869B-F3805CAFCDD0"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3799", "source": "security@debian.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/16/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/17/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95750", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=851485", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/97566cf2806c0a5a86e884c96831a0c3b1ec6c20", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-09", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/97566cf2806c0a5a86e884c96831a0c3b1ec6c20"}}