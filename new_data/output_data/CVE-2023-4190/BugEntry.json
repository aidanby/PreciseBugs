{"buggy_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handle session data of Admidio and is connected to database table adm_sessions\n *\n * This class should be used together with the PHP session handling. If you\n * create a PHP session than you should also create this session object. The\n * class will create a recordset in adm_sessions which stores the PHP session id.\n * With this class it should be easy to add other objects to the session and read\n * them out if you need them elsewhere.\n *\n * **Code examples**\n * ```\n * // add a new object to the session\n * $organization = new Organization($gDb, $organizationId);\n * $session = new Session($gDb, $sessionId);\n * $session->addObject('organization', $organization, true);\n *\n * // read object out of session\n * if($session->hasObject('organization'))\n * {\n *     $organization =& $session->getObject('organization');\n * }\n * ```\n */\nclass Session extends TableAccess\n{\n    /**\n     * @var array<string,mixed> Array with all objects of this session object.\n     */\n    protected $mObjectArray = array();\n    /**\n     * @var AutoLogin|null Object of table auto login that will handle an auto login\n     */\n    protected $mAutoLogin;\n    /**\n     * @var string\n     */\n    protected $cookieAutoLoginId;\n    /**\n     * @var string a 30 character long CSRF token\n     */\n    protected $csrfToken = '';\n\n    /**\n     * Constructor that will create an object of a recordset of the table adm_sessions.\n     * If the id is set than the specific session will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $cookiePrefix The prefix that is used for cookies\n     */\n    public function __construct(Database $database, $cookiePrefix = '')\n    {\n        parent::__construct($database, TBL_SESSIONS, 'ses');\n\n        // determine session id\n        if (array_key_exists(COOKIE_PREFIX . '_SESSION_ID', $_COOKIE)) {\n            $sessionId = $_COOKIE[COOKIE_PREFIX . '_SESSION_ID'];\n        } else {\n            $sessionId = session_id();\n        }\n\n        $this->cookieAutoLoginId = $cookiePrefix . '_AUTO_LOGIN_ID';\n\n        if (is_int($sessionId)) {\n            $this->readDataById($sessionId);\n        } else {\n            $this->readDataByColumns(array('ses_session_id' => $sessionId));\n\n            if ($this->newRecord) {\n                // if PHP session id was committed then store them in that field\n                $this->setValue('ses_session_id', $sessionId);\n                $this->setValue('ses_timestamp', DATETIME_NOW);\n            }\n        }\n\n        // check for a valid auto login\n        $this->refreshAutoLogin();\n    }\n\n    /**\n     * Adds an object to the object array of this class. Objects in this array\n     * will be stored in the session and could be read with the method **getObject**.\n     * @param string $objectName Internal unique name of the object.\n     * @param object $object     The object that should be stored in this class.\n     * @return bool Return false if object isn't type object or objectName already exists\n     */\n    public function addObject(string $objectName, &$object): bool\n    {\n        if (is_object($object) && !array_key_exists($objectName, $this->mObjectArray)) {\n            $this->mObjectArray[$objectName] = &$object;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * clear user data\n     */\n    protected function clearUserData()\n    {\n        global $gCurrentUser;\n\n        if (isset($gCurrentUser) && $gCurrentUser instanceof User) {\n            $gCurrentUser->clear();\n        }\n        $this->setValue('ses_usr_id', '');\n    }\n\n    /**\n     * Returns a CSRF token from the session. If no CSRF token exists a new one will be\n     * generated and stored within the session. The next call of the method will than\n     * return the existing token. The CSRF token has 30 characters. A new token could\n     * be forced by the parameter **$newToken**\n     * @param bool $newToken If set to true, always a new token will be generated.\n     * @return string Returns the CSRF token\n     * @throws AdmException\n     * @throws AdmException\n     */\n    public function getCsrfToken(bool $newToken = false): string\n    {\n        if ($this->csrfToken === '' || $newToken) {\n            $this->csrfToken = SecurityUtils::getRandomString(30);\n        }\n\n        return $this->csrfToken;\n    }\n\n    /**\n     * Returns a reference of an object that is stored in the session.\n     * This is necessary because the old database connection is not valid anymore.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return object|false Returns the reference to the object or false if the object was not found.\n     */\n    public function &getObject(string $objectName)\n    {\n        if (!array_key_exists($objectName, $this->mObjectArray)) {\n            // use parameter because we return a reference so only value will return an error\n            $returnValue = false;\n            return $returnValue;\n        }\n\n        // return reference of object\n        return $this->mObjectArray[$objectName];\n    }\n\n    /**\n     * Return the organization id of this session. If AutoLogin is enabled then the\n     * organization may not be the organization of the config.php because the\n     * user had set the AutoLogin to a different organization.\n     * @return int Returns the organization id of this session\n     */\n    public function getOrganizationId(): int\n    {\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            return (int) $this->mAutoLogin->getValue('atl_org_id');\n        }\n\n        return (int) $this->getValue('ses_org_id');\n    }\n\n    /**\n     * Checks if the object with this name exists in the object array of this class.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return bool Returns **true** if the object exits otherwise **false**\n     */\n    public function hasObject(string $objectName): bool\n    {\n        return array_key_exists($objectName, $this->mObjectArray);\n    }\n\n    /**\n     * Initialize the array with all objects except the gNavigation object. If the session got a refresh\n     * the existing navigation should still be stored in the refreshed session.\n     */\n    public function initializeObjects()\n    {\n        foreach($this->mObjectArray as $key => $element) {\n            if($key !== 'gNavigation') {\n                unset($this->mObjectArray[$key]);\n            }\n        }\n    }\n\n    /**\n     * Check if the current session has a valid user login. Therefore the user id must be stored\n     * within the session and the timestamps must be valid\n     * @param int $userId The user id must be stored in this session and will be checked if valid.\n     * @return bool Returns **true** if the user has a valid session login otherwise **false**;\n     */\n    public function isValidLogin(int $userId): bool\n    {\n        global $gSettingsManager;\n\n        if ($userId > 0) {\n            if ((int) $this->getValue('ses_usr_id') === $userId) {\n                // session has a user assigned -> check if login is still valid\n                $timeGap = time() - strtotime($this->getValue('ses_timestamp', 'Y-m-d H:i:s'));\n\n                // Check how long the user was inactive. If time range is too long -> logout\n                // if user has auto login than session is also valid\n                if ($this->mAutoLogin instanceof AutoLogin || $timeGap < $gSettingsManager->getInt('logout_minutes') * 60) {\n                    return true;\n                }\n            }\n\n            // user was inactive -> clear user data and remove him from session\n            // something is wrong -> clear user data\n            $this->clearUserData();\n        }\n\n        return false;\n    }\n\n    /**\n     * The current user should be removed from the session and auto login.\n     * Also the auto login cookie should be removed.\n     */\n    public function logout()\n    {\n        $this->db->startTransaction();\n\n        // remove user from current session\n        $this->setValue('ses_usr_id', '');\n        $this->save();\n\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            // remove auto login cookie from users browser by setting expired timestamp to 0\n            self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'));\n\n            // delete auto login and remove all data\n            $this->mAutoLogin->delete();\n            $this->mAutoLogin = null;\n        }\n\n        $this->db->endTransaction();\n    }\n\n    /**\n     * Reload auto login data from database table adm_auto_login. if cookie PREFIX_AUTO_LOGIN_ID\n     * is set then there could be an auto login the auto login must be done here because after\n     * that the corresponding organization must be set.\n     */\n    public function refreshAutoLogin()\n    {\n        if (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            // restore user from auto login session\n            $this->mAutoLogin = new AutoLogin($this->db, $_COOKIE[$this->cookieAutoLoginId]);\n\n            // valid AutoLogin found\n            if ($this->mAutoLogin->getValue('atl_id') > 0) {\n                $autoLoginId = $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id'));\n                $this->mAutoLogin->setValue('atl_auto_login_id', $autoLoginId);\n                $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n                $this->mAutoLogin->save();\n\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n\n                // save cookie for autologin\n                $currDateTime = new DateTime();\n                $oneYearDateInterval = new DateInterval('P1Y');\n                $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n                $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n                self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n            } else {\n                // an invalid AutoLogin should made the current AutoLogin unusable\n                $this->mAutoLogin = null;\n                self::setCookie($this->cookieAutoLoginId, $_COOKIE[$this->cookieAutoLoginId]);\n\n                // now count invalid auto login for this user and delete all auto login of this users if number of wrong logins > 3\n                $autoLoginParts = explode(':', $_COOKIE[$this->cookieAutoLoginId]);\n                $userId = $autoLoginParts[0];\n\n                if ($userId > 0) {\n                    $sql = 'UPDATE '.TBL_AUTO_LOGIN.'\n                               SET atl_number_invalid = atl_number_invalid + 1\n                             WHERE atl_usr_id = ? -- $userId';\n                    $this->db->queryPrepared($sql, array($userId));\n\n                    $sql = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                             WHERE atl_usr_id = ? -- $userId\n                               AND atl_number_invalid > 3 ';\n                    $this->db->queryPrepared($sql, array($userId));\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload session data from database table adm_sessions. If IP address check is activated than check if the IP\n     * address has changed. Refresh AutoLogin with new auto_login_id.\n     */\n    public function refresh()\n    {\n        // read session data from database to update the reload flag\n        if(!$this->readDataById((int) $this->getValue('ses_id'))) {\n            // if session was not found than destroy session object\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n        }\n\n        // check if current connection has same ip address as of session initialization\n        // if config parameter $gCheckIpAddress = 0 then don't check ip address\n        $sesIpAddress = $this->getValue('ses_ip_address');\n        if (isset($GLOBALS['gCheckIpAddress']) && $GLOBALS['gCheckIpAddress'] && $sesIpAddress !== '' && $sesIpAddress !== $_SERVER['REMOTE_ADDR']) {\n            $GLOBALS['gLogger']->warning('Admidio stored session ip address: ' . $sesIpAddress . ' :: Remote ip address: ' . $_SERVER['REMOTE_ADDR']);\n            $GLOBALS['gLogger']->warning('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n\n            exit('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n        }\n\n        // session in database could be deleted if user was some time inactive and another user\n        // clears the table. Therefor we must reset the user id\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            if ((int) $this->getValue('ses_usr_id') === 0) {\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n            }\n        } elseif (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            $this->refreshAutoLogin();\n        }\n    }\n\n    /**\n     * This method will replace the current session ID with a new one, and keep the current session information.\n     * The new session id will be stored in the database.\n     */\n    public function regenerateId()\n    {\n        session_regenerate_id();\n\n        $this->setValue('ses_session_id', session_id());\n        $this->save();\n    }\n\n    /**\n     * This method will reload all stored objects of all active sessions. The session will be\n     * reloaded if the user will open a new page.\n     */\n    public function reloadAllSessions()\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true ';\n        $this->db->queryPrepared($sql, array(), false); // don't show error because column ses_reload doesn't exist within update from version 3.x\n    }\n\n    /**\n     * This method will reload the session of a specific user. All stored objects of the session will be initialized\n     * and reloaded if the user opens a new page.\n     * @param int $userId Id of the user whose session should be relaoded.\n     */\n    public function reload(int $userId)\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true\n                 WHERE ses_usr_id = ?  -- $userId';\n        $this->db->queryPrepared($sql, array($userId), false); // don't show error because column ses_reload doesn't exist within update from version 3.x\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update\n     * the changed columns. If the table has columns for creator or editor than these column\n     * with their timestamp will be updated.\n     * For new records the organization, timestamp, begin date and ip address will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true): bool\n    {\n        global $gCurrentOrgId;\n\n        if ($this->newRecord) {\n            // Insert\n            $this->setValue('ses_org_id', $gCurrentOrgId);\n            $this->setValue('ses_begin', DATETIME_NOW);\n            // remove the last part of the IP because of privacy (GDPR)\n            $ip = preg_replace(array('/\\.\\d+$/', '/[\\da-f]*:[\\da-f]*$/'), array('.XXX', 'XXXX:XXXX'), $_SERVER['REMOTE_ADDR']);\n            $this->setValue('ses_ip_address', $ip);\n        }\n\n        // Insert & Update\n        $this->setValue('ses_timestamp', DATETIME_NOW);\n\n        return parent::save($updateFingerPrint);\n    }\n\n    /**\n     * Save all data that is necessary for an auto login. Therefore an AutoLogin object\n     * will be created with an auto_login_id and this id will be stored in a cookie\n     * in the browser of the current user.\n     */\n    public function setAutoLogin()\n    {\n        // create object and set current session data to AutoLogin\n        $this->mAutoLogin = new AutoLogin($this->db);\n        $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n        $this->mAutoLogin->setValue('atl_org_id', (int) $this->getValue('ses_org_id'));\n        $this->mAutoLogin->setValue('atl_usr_id', (int) $this->getValue('ses_usr_id'));\n\n        // set new auto_login_id and save data\n        $this->mAutoLogin->setValue('atl_auto_login_id', $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id')));\n        $this->mAutoLogin->save();\n\n        // save cookie for autologin\n        $currDateTime = new DateTime();\n        $oneYearDateInterval = new DateInterval('P1Y');\n        $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n        $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n        self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n    }\n\n    /**\n     * @param string $name     Name of the cookie.\n     * @param string $value    Value of the cookie. If value is \"empty string\" or \"false\",\n     *                         the cookie will be set as deleted (Expire is set to 1 year in the past).\n     * @param int $expire   The Unix-Timestamp (Seconds) of the Date/Time when the cookie should expire.\n     *                         With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path     Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain   Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure   If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly If \"true\" cookie is accessible only via HTTP.\n     *                         Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @return bool Returns \"true\" if the cookie is successfully set.\n     */\n    public static function setCookie(\n        string $name,\n        string $value = '',\n        int $expire = 0,\n        string $path = '',\n        string $domain = '',\n        bool $secure = null,\n        bool $httpOnly = true\n    ): bool {\n        global $gLogger, $gSetCookieForDomain;\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n        if ($domain === '') {\n            $domain = DOMAIN;\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        $gLogger->info('Set Cookie!', array('name' => $name, 'value' => $value, 'expire' => $expire, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax'));\n\n        if (PHP_VERSION_ID < 70300) {\n            return setcookie($name, $value, $expire, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            return setcookie($name, $value, array(\n                'expires'  => $expire,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n    }\n\n    /**\n     * @param string $cookiePrefix The prefix name of the Cookie.\n     * @param int $limit        The Lifetime (Seconds) of the cookie when it should expire.\n     *                             With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path         Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain       Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure       If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly     If \"true\" cookie is accessible only via HTTP.\n     *                             Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @throws RuntimeException\n     */\n    public static function start(string $cookiePrefix, int $limit = 0, string $path = '', string $domain = '', bool $secure = null, bool $httpOnly = true)\n    {\n        global $gLogger, $gSetCookieForDomain;\n\n        if (headers_sent()) {\n            $message = 'HTTP-Headers already sent!';\n            $gLogger->alert($message);\n\n            throw new RuntimeException($message);\n        }\n\n        $sessionName = $cookiePrefix . '_SESSION_ID';\n\n        // Set the cookie name\n        session_name($sessionName);\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n\n        if ($domain === '') {\n            $domain = DOMAIN;\n\n            // TODO: Test if this is necessary\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        if (PHP_VERSION_ID < 70300) {\n            session_set_cookie_params($limit, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            session_set_cookie_params(array(\n                'lifetime' => $limit,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $gLogger->notice('Session is already started!', array('sessionId' => session_id()));\n        }\n\n        // Start session\n        session_start();\n\n        $gLogger->info('Session Started!', array('name' => $sessionName, 'limit' => $limit, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax', 'sessionId' => session_id()));\n    }\n\n    /**\n     * Deletes all sessions in table admSessions that are inactive since **$maxInactiveTime** minutes..\n     * @param int $maxInactiveMinutes Time in Minutes after that a session will be deleted.\n     * @throws Exception\n     * @throws Exception\n     */\n    public function tableCleanup(int $maxInactiveMinutes = 30)\n    {\n        $now = new DateTime();\n        $minutesBack = new DateInterval('PT' . $maxInactiveMinutes . 'M');\n        $timestamp = $now->sub($minutesBack)->format('Y-m-d H:i:s');\n\n        $sql = 'DELETE FROM '.TBL_SESSIONS.'\n                 WHERE ses_timestamp < ? -- $timestamp\n                   AND ses_session_id <> ? -- $this->getValue(\\'ses_session_id\\')';\n        $this->db->queryPrepared($sql, array($timestamp, $this->getValue('ses_session_id')));\n    }\n}\n"], "fixing_code": ["<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Handle session data of Admidio and is connected to database table adm_sessions\n *\n * This class should be used together with the PHP session handling. If you\n * create a PHP session than you should also create this session object. The\n * class will create a recordset in adm_sessions which stores the PHP session id.\n * With this class it should be easy to add other objects to the session and read\n * them out if you need them elsewhere.\n *\n * **Code examples**\n * ```\n * // add a new object to the session\n * $organization = new Organization($gDb, $organizationId);\n * $session = new Session($gDb, $sessionId);\n * $session->addObject('organization', $organization, true);\n *\n * // read object out of session\n * if($session->hasObject('organization'))\n * {\n *     $organization =& $session->getObject('organization');\n * }\n * ```\n */\nclass Session extends TableAccess\n{\n    /**\n     * @var array<string,mixed> Array with all objects of this session object.\n     */\n    protected $mObjectArray = array();\n    /**\n     * @var AutoLogin|null Object of table auto login that will handle an auto login\n     */\n    protected $mAutoLogin;\n    /**\n     * @var string\n     */\n    protected $cookieAutoLoginId;\n    /**\n     * @var string a 30 character long CSRF token\n     */\n    protected $csrfToken = '';\n\n    /**\n     * Constructor that will create an object of a recordset of the table adm_sessions.\n     * If the id is set than the specific session will be loaded.\n     * @param Database   $database     Object of the class Database. This should be the default global object **$gDb**.\n     * @param string     $cookiePrefix The prefix that is used for cookies\n     */\n    public function __construct(Database $database, $cookiePrefix = '')\n    {\n        parent::__construct($database, TBL_SESSIONS, 'ses');\n\n        // determine session id\n        if (array_key_exists(COOKIE_PREFIX . '_SESSION_ID', $_COOKIE)) {\n            $sessionId = $_COOKIE[COOKIE_PREFIX . '_SESSION_ID'];\n        } else {\n            $sessionId = session_id();\n        }\n\n        $this->cookieAutoLoginId = $cookiePrefix . '_AUTO_LOGIN_ID';\n\n        if (is_int($sessionId)) {\n            $this->readDataById($sessionId);\n        } else {\n            $this->readDataByColumns(array('ses_session_id' => $sessionId));\n\n            if ($this->newRecord) {\n                // if PHP session id was committed then store them in that field\n                $this->setValue('ses_session_id', $sessionId);\n                $this->setValue('ses_timestamp', DATETIME_NOW);\n            }\n        }\n\n        // check for a valid auto login\n        $this->refreshAutoLogin();\n    }\n\n    /**\n     * Adds an object to the object array of this class. Objects in this array\n     * will be stored in the session and could be read with the method **getObject**.\n     * @param string $objectName Internal unique name of the object.\n     * @param object $object     The object that should be stored in this class.\n     * @return bool Return false if object isn't type object or objectName already exists\n     */\n    public function addObject(string $objectName, &$object): bool\n    {\n        if (is_object($object) && !array_key_exists($objectName, $this->mObjectArray)) {\n            $this->mObjectArray[$objectName] = &$object;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * clear user data\n     */\n    protected function clearUserData()\n    {\n        global $gCurrentUser;\n\n        if (isset($gCurrentUser) && $gCurrentUser instanceof User) {\n            $gCurrentUser->clear();\n        }\n        $this->setValue('ses_usr_id', '');\n    }\n\n    /**\n     * Returns a CSRF token from the session. If no CSRF token exists a new one will be\n     * generated and stored within the session. The next call of the method will than\n     * return the existing token. The CSRF token has 30 characters. A new token could\n     * be forced by the parameter **$newToken**\n     * @param bool $newToken If set to true, always a new token will be generated.\n     * @return string Returns the CSRF token\n     * @throws AdmException\n     * @throws AdmException\n     */\n    public function getCsrfToken(bool $newToken = false): string\n    {\n        if ($this->csrfToken === '' || $newToken) {\n            $this->csrfToken = SecurityUtils::getRandomString(30);\n        }\n\n        return $this->csrfToken;\n    }\n\n    /**\n     * Returns a reference of an object that is stored in the session.\n     * This is necessary because the old database connection is not valid anymore.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return object|false Returns the reference to the object or false if the object was not found.\n     */\n    public function &getObject(string $objectName)\n    {\n        if (!array_key_exists($objectName, $this->mObjectArray)) {\n            // use parameter because we return a reference so only value will return an error\n            $returnValue = false;\n            return $returnValue;\n        }\n\n        // return reference of object\n        return $this->mObjectArray[$objectName];\n    }\n\n    /**\n     * Return the organization id of this session. If AutoLogin is enabled then the\n     * organization may not be the organization of the config.php because the\n     * user had set the AutoLogin to a different organization.\n     * @return int Returns the organization id of this session\n     */\n    public function getOrganizationId(): int\n    {\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            return (int) $this->mAutoLogin->getValue('atl_org_id');\n        }\n\n        return (int) $this->getValue('ses_org_id');\n    }\n\n    /**\n     * Checks if the object with this name exists in the object array of this class.\n     * @param string $objectName Internal unique name of the object. The name was set with the method **addObject**\n     * @return bool Returns **true** if the object exits otherwise **false**\n     */\n    public function hasObject(string $objectName): bool\n    {\n        return array_key_exists($objectName, $this->mObjectArray);\n    }\n\n    /**\n     * Initialize the array with all objects except the gNavigation object. If the session got a refresh\n     * the existing navigation should still be stored in the refreshed session.\n     */\n    public function initializeObjects()\n    {\n        foreach($this->mObjectArray as $key => $element) {\n            if($key !== 'gNavigation') {\n                unset($this->mObjectArray[$key]);\n            }\n        }\n    }\n\n    /**\n     * Check if the current session has a valid user login. Therefore the user id must be stored\n     * within the session and the timestamps must be valid\n     * @param int $userId The user id must be stored in this session and will be checked if valid.\n     * @return bool Returns **true** if the user has a valid session login otherwise **false**;\n     */\n    public function isValidLogin(int $userId): bool\n    {\n        global $gSettingsManager;\n\n        if ($userId > 0) {\n            if ((int) $this->getValue('ses_usr_id') === $userId) {\n                // session has a user assigned -> check if login is still valid\n                $timeGap = time() - strtotime($this->getValue('ses_timestamp', 'Y-m-d H:i:s'));\n\n                // Check how long the user was inactive. If time range is too long -> logout\n                // if user has auto login than session is also valid\n                if ($this->mAutoLogin instanceof AutoLogin || $timeGap < $gSettingsManager->getInt('logout_minutes') * 60) {\n                    return true;\n                }\n            }\n\n            // user was inactive -> clear user data and remove him from session\n            // something is wrong -> clear user data\n            $this->clearUserData();\n        }\n\n        return false;\n    }\n\n    /**\n     * The current user should be removed from the session and auto login.\n     * Also the auto login cookie should be removed.\n     */\n    public function logout()\n    {\n        $this->db->startTransaction();\n\n        // remove user from current session\n        $this->setValue('ses_usr_id', '');\n        $this->save();\n\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            // remove auto login cookie from users browser by setting expired timestamp to 0\n            self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'));\n\n            // delete auto login and remove all data\n            $this->mAutoLogin->delete();\n            $this->mAutoLogin = null;\n        }\n\n        $this->db->endTransaction();\n\n        // remove session object with all data\n        session_unset();\n        session_destroy();\n    }\n\n    /**\n     * Reload auto login data from database table adm_auto_login. if cookie PREFIX_AUTO_LOGIN_ID\n     * is set then there could be an auto login the auto login must be done here because after\n     * that the corresponding organization must be set.\n     */\n    public function refreshAutoLogin()\n    {\n        if (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            // restore user from auto login session\n            $this->mAutoLogin = new AutoLogin($this->db, $_COOKIE[$this->cookieAutoLoginId]);\n\n            // valid AutoLogin found\n            if ($this->mAutoLogin->getValue('atl_id') > 0) {\n                $autoLoginId = $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id'));\n                $this->mAutoLogin->setValue('atl_auto_login_id', $autoLoginId);\n                $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n                $this->mAutoLogin->save();\n\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n\n                // save cookie for autologin\n                $currDateTime = new DateTime();\n                $oneYearDateInterval = new DateInterval('P1Y');\n                $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n                $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n                self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n            } else {\n                // an invalid AutoLogin should made the current AutoLogin unusable\n                $this->mAutoLogin = null;\n                self::setCookie($this->cookieAutoLoginId, $_COOKIE[$this->cookieAutoLoginId]);\n\n                // now count invalid auto login for this user and delete all auto login of this users if number of wrong logins > 3\n                $autoLoginParts = explode(':', $_COOKIE[$this->cookieAutoLoginId]);\n                $userId = $autoLoginParts[0];\n\n                if ($userId > 0) {\n                    $sql = 'UPDATE '.TBL_AUTO_LOGIN.'\n                               SET atl_number_invalid = atl_number_invalid + 1\n                             WHERE atl_usr_id = ? -- $userId';\n                    $this->db->queryPrepared($sql, array($userId));\n\n                    $sql = 'DELETE FROM '.TBL_AUTO_LOGIN.'\n                             WHERE atl_usr_id = ? -- $userId\n                               AND atl_number_invalid > 3 ';\n                    $this->db->queryPrepared($sql, array($userId));\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload session data from database table adm_sessions. If IP address check is activated than check if the IP\n     * address has changed. Refresh AutoLogin with new auto_login_id.\n     */\n    public function refresh()\n    {\n        // read session data from database to update the reload flag\n        if(!$this->readDataById((int) $this->getValue('ses_id'))) {\n            // if session was not found than destroy session object\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n        }\n\n        // check if current connection has same ip address as of session initialization\n        // if config parameter $gCheckIpAddress = 0 then don't check ip address\n        $sesIpAddress = $this->getValue('ses_ip_address');\n        if (isset($GLOBALS['gCheckIpAddress']) && $GLOBALS['gCheckIpAddress'] && $sesIpAddress !== '' && $sesIpAddress !== $_SERVER['REMOTE_ADDR']) {\n            $GLOBALS['gLogger']->warning('Admidio stored session ip address: ' . $sesIpAddress . ' :: Remote ip address: ' . $_SERVER['REMOTE_ADDR']);\n            $GLOBALS['gLogger']->warning('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n\n            unset($_SESSION['gCurrentSession']);\n            $this->initializeObjects();\n            $this->clear();\n\n            exit('The IP address does not match with the IP address the current session was started! For safety reasons the current session was closed.');\n        }\n\n        // session in database could be deleted if user was some time inactive and another user\n        // clears the table. Therefor we must reset the user id\n        if ($this->mAutoLogin instanceof AutoLogin) {\n            if ((int) $this->getValue('ses_usr_id') === 0) {\n                $this->setValue('ses_usr_id', (int) $this->mAutoLogin->getValue('atl_usr_id'));\n            }\n        } elseif (array_key_exists($this->cookieAutoLoginId, $_COOKIE)) {\n            $this->refreshAutoLogin();\n        }\n    }\n\n    /**\n     * This method will replace the current session ID with a new one, and keep the current session information.\n     * The new session id will be stored in the database.\n     */\n    public function regenerateId()\n    {\n        session_regenerate_id();\n\n        $this->setValue('ses_session_id', session_id());\n        $this->save();\n    }\n\n    /**\n     * This method will reload all stored objects of all active sessions. The session will be\n     * reloaded if the user will open a new page.\n     */\n    public function reloadAllSessions()\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true ';\n        $this->db->queryPrepared($sql, array(), false); // don't show error because column ses_reload doesn't exist within update from version 3.x\n    }\n\n    /**\n     * This method will reload the session of a specific user. All stored objects of the session will be initialized\n     * and reloaded if the user opens a new page.\n     * @param int $userId Id of the user whose session should be relaoded.\n     */\n    public function reload(int $userId)\n    {\n        $sql = 'UPDATE ' . TBL_SESSIONS . ' SET ses_reload = true\n                 WHERE ses_usr_id = ?  -- $userId';\n        $this->db->queryPrepared($sql, array($userId), false); // don't show error because column ses_reload doesn't exist within update from version 3.x\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update\n     * the changed columns. If the table has columns for creator or editor than these column\n     * with their timestamp will be updated.\n     * For new records the organization, timestamp, begin date and ip address will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true): bool\n    {\n        global $gCurrentOrgId;\n\n        if ($this->newRecord) {\n            // Insert\n            $this->setValue('ses_org_id', $gCurrentOrgId);\n            $this->setValue('ses_begin', DATETIME_NOW);\n            // remove the last part of the IP because of privacy (GDPR)\n            $ip = preg_replace(array('/\\.\\d+$/', '/[\\da-f]*:[\\da-f]*$/'), array('.XXX', 'XXXX:XXXX'), $_SERVER['REMOTE_ADDR']);\n            $this->setValue('ses_ip_address', $ip);\n        }\n\n        // Insert & Update\n        $this->setValue('ses_timestamp', DATETIME_NOW);\n\n        return parent::save($updateFingerPrint);\n    }\n\n    /**\n     * Save all data that is necessary for an auto login. Therefore an AutoLogin object\n     * will be created with an auto_login_id and this id will be stored in a cookie\n     * in the browser of the current user.\n     */\n    public function setAutoLogin()\n    {\n        // create object and set current session data to AutoLogin\n        $this->mAutoLogin = new AutoLogin($this->db);\n        $this->mAutoLogin->setValue('atl_session_id', $this->getValue('ses_session_id'));\n        $this->mAutoLogin->setValue('atl_org_id', (int) $this->getValue('ses_org_id'));\n        $this->mAutoLogin->setValue('atl_usr_id', (int) $this->getValue('ses_usr_id'));\n\n        // set new auto_login_id and save data\n        $this->mAutoLogin->setValue('atl_auto_login_id', $this->mAutoLogin->generateAutoLoginId((int) $this->getValue('ses_usr_id')));\n        $this->mAutoLogin->save();\n\n        // save cookie for autologin\n        $currDateTime = new DateTime();\n        $oneYearDateInterval = new DateInterval('P1Y');\n        $oneYearAfterDateTime = $currDateTime->add($oneYearDateInterval);\n        $timestampExpired = $oneYearAfterDateTime->getTimestamp();\n\n        self::setCookie($this->cookieAutoLoginId, $this->mAutoLogin->getValue('atl_auto_login_id'), $timestampExpired);\n    }\n\n    /**\n     * @param string $name     Name of the cookie.\n     * @param string $value    Value of the cookie. If value is \"empty string\" or \"false\",\n     *                         the cookie will be set as deleted (Expire is set to 1 year in the past).\n     * @param int $expire   The Unix-Timestamp (Seconds) of the Date/Time when the cookie should expire.\n     *                         With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path     Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain   Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure   If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly If \"true\" cookie is accessible only via HTTP.\n     *                         Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @return bool Returns \"true\" if the cookie is successfully set.\n     */\n    public static function setCookie(\n        string $name,\n        string $value = '',\n        int $expire = 0,\n        string $path = '',\n        string $domain = '',\n        bool $secure = null,\n        bool $httpOnly = true\n    ): bool {\n        global $gLogger, $gSetCookieForDomain;\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n        if ($domain === '') {\n            $domain = DOMAIN;\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        $gLogger->info('Set Cookie!', array('name' => $name, 'value' => $value, 'expire' => $expire, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax'));\n\n        if (PHP_VERSION_ID < 70300) {\n            return setcookie($name, $value, $expire, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            return setcookie($name, $value, array(\n                'expires'  => $expire,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n    }\n\n    /**\n     * @param string $cookiePrefix The prefix name of the Cookie.\n     * @param int $limit        The Lifetime (Seconds) of the cookie when it should expire.\n     *                             With \"0\" the cookie will expire if the session ends. (When Browser gets closed)\n     * @param string $path         Specify the path where the cookie should be available. (Also in sub-paths)\n     * @param string $domain       Specify the domain where the cookie should be available. (Set \".example.org\" to allow sub-domains)\n     * @param bool|null $secure       If \"true\" cookie is only set if connection is HTTPS. Default is an auto detection.\n     * @param bool $httpOnly     If \"true\" cookie is accessible only via HTTP.\n     *                             Set to \"false\" to allow access for JavaScript. (Possible XSS security leak)\n     * @throws RuntimeException\n     */\n    public static function start(string $cookiePrefix, int $limit = 0, string $path = '', string $domain = '', bool $secure = null, bool $httpOnly = true)\n    {\n        global $gLogger, $gSetCookieForDomain;\n\n        if (headers_sent()) {\n            $message = 'HTTP-Headers already sent!';\n            $gLogger->alert($message);\n\n            throw new RuntimeException($message);\n        }\n\n        $sessionName = $cookiePrefix . '_SESSION_ID';\n\n        // Set the cookie name\n        session_name($sessionName);\n\n        if ($path === '') {\n            if ($gSetCookieForDomain) {\n                $path = '/';\n            } else {\n                $path = ADMIDIO_URL_PATH . '/';\n            }\n        }\n\n        if ($domain === '') {\n            $domain = DOMAIN;\n\n            // TODO: Test if this is necessary\n            // https://www.php.net/manual/en/function.setcookie.php#73107\n            if ($domain === 'localhost') {\n                $domain = false;\n            }\n        }\n        if ($secure === null) {\n            $secure = HTTPS;\n        }\n\n        if (PHP_VERSION_ID < 70300) {\n            session_set_cookie_params($limit, $path. ';samesite=lax', $domain, $secure, $httpOnly);\n        } else {\n            session_set_cookie_params(array(\n                'lifetime' => $limit,\n                'path'     => $path,\n                'domain'   => $domain,\n                'secure'   => $secure,\n                'httponly' => $httpOnly,\n                'samesite' => 'lax'\n            ));\n        }\n\n        if (session_status() === PHP_SESSION_ACTIVE) {\n            $gLogger->notice('Session is already started!', array('sessionId' => session_id()));\n        }\n\n        // Start session\n        session_start();\n\n        $gLogger->info('Session Started!', array('name' => $sessionName, 'limit' => $limit, 'path' => $path, 'domain' => $domain, 'secure' => $secure, 'httpOnly' => $httpOnly, 'sameSite' => 'lax', 'sessionId' => session_id()));\n    }\n\n    /**\n     * Deletes all sessions in table admSessions that are inactive since **$maxInactiveTime** minutes..\n     * @param int $maxInactiveMinutes Time in Minutes after that a session will be deleted.\n     * @throws Exception\n     * @throws Exception\n     */\n    public function tableCleanup(int $maxInactiveMinutes = 30)\n    {\n        $now = new DateTime();\n        $minutesBack = new DateInterval('PT' . $maxInactiveMinutes . 'M');\n        $timestamp = $now->sub($minutesBack)->format('Y-m-d H:i:s');\n\n        $sql = 'DELETE FROM '.TBL_SESSIONS.'\n                 WHERE ses_timestamp < ? -- $timestamp\n                   AND ses_session_id <> ? -- $this->getValue(\\'ses_session_id\\')';\n        $this->db->queryPrepared($sql, array($timestamp, $this->getValue('ses_session_id')));\n    }\n}\n"], "filenames": ["adm_program/system/classes/Session.php"], "buggy_code_start_loc": [242], "buggy_code_end_loc": [242], "fixing_code_start_loc": [243], "fixing_code_end_loc": [247], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository admidio/admidio prior to 4.2.11.", "other": {"cve": {"id": "CVE-2023-4190", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-06T01:15:10.693", "lastModified": "2023-08-09T16:20:21.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository admidio/admidio prior to 4.2.11."}, {"lang": "es", "value": "Expiraci\u00f3n de sesi\u00f3n insuficiente en el repositorio de GitHub admidio/admidio anterior a 4.2.11. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:admidio:admidio:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.11", "matchCriteriaId": "B3B20C94-6908-42A0-94E4-F2BE129F7B84"}]}]}], "references": [{"url": "https://github.com/admidio/admidio/commit/391fb2af5bee641837a58e7dd66ff76eac92bb74", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/71bc75d2-320c-4332-ad11-9de535a06d92", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/admidio/admidio/commit/391fb2af5bee641837a58e7dd66ff76eac92bb74"}}