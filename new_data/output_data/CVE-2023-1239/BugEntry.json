{"buggy_code": ["package install\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm/schemas\"\n)\n\n// CheckConfigFileResp check config file if exist or not response\ntype CheckConfigFileResp struct {\n\tConfigFileExist     bool `json:\"config_file_exist\"`\n\tDBConnectionSuccess bool `json:\"db_connection_success\"`\n\tDbTableExist        bool `json:\"db_table_exist\"`\n}\n\n// CheckDatabaseReq check database\ntype CheckDatabaseReq struct {\n\tDbType     string `validate:\"required,oneof=postgres sqlite3 mysql\" json:\"db_type\"`\n\tDbUsername string `json:\"db_username\"`\n\tDbPassword string `json:\"db_password\"`\n\tDbHost     string `json:\"db_host\"`\n\tDbName     string `json:\"db_name\"`\n\tDbFile     string `json:\"db_file\"`\n}\n\n// GetConnection get connection string\nfunc (r *CheckDatabaseReq) GetConnection() string {\n\tif r.DbType == string(schemas.SQLITE) {\n\t\treturn r.DbFile\n\t}\n\tif r.DbType == string(schemas.MYSQL) {\n\t\treturn fmt.Sprintf(\"%s:%s@tcp(%s)/%s\",\n\t\t\tr.DbUsername, r.DbPassword, r.DbHost, r.DbName)\n\t}\n\tif r.DbType == string(schemas.POSTGRES) {\n\t\thost, port := parsePgSQLHostPort(r.DbHost)\n\t\treturn fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n\t\t\thost, port, r.DbUsername, r.DbPassword, r.DbName)\n\t}\n\treturn \"\"\n}\n\nfunc parsePgSQLHostPort(dbHost string) (host string, port string) {\n\tif strings.Contains(dbHost, \":\") {\n\t\tidx := strings.LastIndex(dbHost, \":\")\n\t\thost, port = dbHost[:idx], dbHost[idx+1:]\n\t} else if len(dbHost) > 0 {\n\t\thost = dbHost\n\t}\n\tif host == \"\" {\n\t\thost = \"127.0.0.1\"\n\t}\n\tif port == \"\" {\n\t\tport = \"5432\"\n\t}\n\treturn host, port\n}\n\n// CheckDatabaseResp check database response\ntype CheckDatabaseResp struct {\n\tConnectionSuccess bool `json:\"connection_success\"`\n}\n\n// InitEnvironmentResp init environment response\ntype InitEnvironmentResp struct {\n\tSuccess            bool   `json:\"success\"`\n\tCreateConfigFailed bool   `json:\"create_config_failed\"`\n\tDefaultConfig      string `json:\"default_config\"`\n\tErrType            string `json:\"err_type\"`\n}\n\n// InitBaseInfoReq init base info request\ntype InitBaseInfoReq struct {\n\tLanguage      string `validate:\"required,gt=0,lte=30\" json:\"lang\"`\n\tSiteName      string `validate:\"required,gt=0,lte=30\" json:\"site_name\"`\n\tSiteURL       string `validate:\"required,gt=0,lte=512,url\" json:\"site_url\"`\n\tContactEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"contact_email\"`\n\tAdminName     string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\tAdminPassword string `validate:\"required,gte=8,lte=32\" json:\"password\"`\n\tAdminEmail    string `validate:\"required,email,gt=0,lte=500\" json:\"email\"`\n}\n\nfunc (r *InitBaseInfoReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif checker.IsInvalidUsername(r.AdminName) {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t}\n\treturn\n}\n\nfunc (r *InitBaseInfoReq) FormatSiteUrl() {\n\tparsedUrl, err := url.Parse(r.SiteURL)\n\tif err != nil {\n\t\treturn\n\t}\n\tr.SiteURL = fmt.Sprintf(\"%s://%s\", parsedUrl.Scheme, parsedUrl.Host)\n}\n"], "fixing_code": ["package install\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/pkg/checker\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm/schemas\"\n)\n\n// CheckConfigFileResp check config file if exist or not response\ntype CheckConfigFileResp struct {\n\tConfigFileExist     bool `json:\"config_file_exist\"`\n\tDBConnectionSuccess bool `json:\"db_connection_success\"`\n\tDbTableExist        bool `json:\"db_table_exist\"`\n}\n\n// CheckDatabaseReq check database\ntype CheckDatabaseReq struct {\n\tDbType     string `validate:\"required,oneof=postgres sqlite3 mysql\" json:\"db_type\"`\n\tDbUsername string `json:\"db_username\"`\n\tDbPassword string `json:\"db_password\"`\n\tDbHost     string `json:\"db_host\"`\n\tDbName     string `json:\"db_name\"`\n\tDbFile     string `json:\"db_file\"`\n}\n\n// GetConnection get connection string\nfunc (r *CheckDatabaseReq) GetConnection() string {\n\tif r.DbType == string(schemas.SQLITE) {\n\t\treturn r.DbFile\n\t}\n\tif r.DbType == string(schemas.MYSQL) {\n\t\treturn fmt.Sprintf(\"%s:%s@tcp(%s)/%s\",\n\t\t\tr.DbUsername, r.DbPassword, r.DbHost, r.DbName)\n\t}\n\tif r.DbType == string(schemas.POSTGRES) {\n\t\thost, port := parsePgSQLHostPort(r.DbHost)\n\t\treturn fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n\t\t\thost, port, r.DbUsername, r.DbPassword, r.DbName)\n\t}\n\treturn \"\"\n}\n\nfunc parsePgSQLHostPort(dbHost string) (host string, port string) {\n\tif strings.Contains(dbHost, \":\") {\n\t\tidx := strings.LastIndex(dbHost, \":\")\n\t\thost, port = dbHost[:idx], dbHost[idx+1:]\n\t} else if len(dbHost) > 0 {\n\t\thost = dbHost\n\t}\n\tif host == \"\" {\n\t\thost = \"127.0.0.1\"\n\t}\n\tif port == \"\" {\n\t\tport = \"5432\"\n\t}\n\treturn host, port\n}\n\n// CheckDatabaseResp check database response\ntype CheckDatabaseResp struct {\n\tConnectionSuccess bool `json:\"connection_success\"`\n}\n\n// InitEnvironmentResp init environment response\ntype InitEnvironmentResp struct {\n\tSuccess            bool   `json:\"success\"`\n\tCreateConfigFailed bool   `json:\"create_config_failed\"`\n\tDefaultConfig      string `json:\"default_config\"`\n\tErrType            string `json:\"err_type\"`\n}\n\n// InitBaseInfoReq init base info request\ntype InitBaseInfoReq struct {\n\tLanguage      string `validate:\"required,gt=0,lte=30\" json:\"lang\"`\n\tSiteName      string `validate:\"required,sanitizer,gt=0,lte=30\" json:\"site_name\"`\n\tSiteURL       string `validate:\"required,gt=0,lte=512,url\" json:\"site_url\"`\n\tContactEmail  string `validate:\"required,email,gt=0,lte=500\" json:\"contact_email\"`\n\tAdminName     string `validate:\"required,gt=3,lte=30\" json:\"name\"`\n\tAdminPassword string `validate:\"required,gte=8,lte=32\" json:\"password\"`\n\tAdminEmail    string `validate:\"required,email,gt=0,lte=500\" json:\"email\"`\n}\n\nfunc (r *InitBaseInfoReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif checker.IsInvalidUsername(r.AdminName) {\n\t\terrField := &validator.FormErrorField{\n\t\t\tErrorField: \"name\",\n\t\t\tErrorMsg:   reason.UsernameInvalid,\n\t\t}\n\t\terrFields = append(errFields, errField)\n\t\treturn errFields, errors.BadRequest(reason.UsernameInvalid)\n\t}\n\treturn\n}\n\nfunc (r *InitBaseInfoReq) FormatSiteUrl() {\n\tparsedUrl, err := url.Parse(r.SiteURL)\n\tif err != nil {\n\t\treturn\n\t}\n\tr.SiteURL = fmt.Sprintf(\"%s://%s\", parsedUrl.Scheme, parsedUrl.Host)\n}\n"], "filenames": ["internal/install/install_req.go"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [82], "fixing_code_start_loc": [81], "fixing_code_end_loc": [82], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository answerdev/answer prior to 1.0.6.", "other": {"cve": {"id": "CVE-2023-1239", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-07T08:15:09.500", "lastModified": "2023-03-13T15:15:57.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository answerdev/answer prior to 1.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.6", "matchCriteriaId": "BC30C65B-0A27-4181-94A2-75BDAD7D7145"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/9870ed87fb24ed468aaf1e169c2d028e0f375106", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/3a22c609-d2d8-4613-815d-58f5990b8bd8", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/9870ed87fb24ed468aaf1e169c2d028e0f375106"}}