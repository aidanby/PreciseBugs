{"buggy_code": ["/* radare - LGPL - Copyright 2008-2021 nibble, pancake, inisider */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <r_hash.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"pe.h\"\n#include <time.h>\n#include <ht_uu.h>\n\n#define PE_IMAGE_FILE_MACHINE_RPI2 452\n#define MAX_METADATA_STRING_LENGTH 256\n#define pe_printf if (pe->verbose) eprintf\n#define COFF_SYMBOL_SIZE 18\n#define PE_READ_STRUCT_FIELD(var, struct_type, field, size) var->field = r_read_le##size (buf + offsetof (struct_type, field))\n\nstruct SCV_NB10_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tut32 offset;\n\tut32 timestamp;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_NB10_HEADER* cv_nb10_header);\n} SCV_NB10_HEADER;\n\ntypedef struct {\n\tut32 data1;\n\tut16 data2;\n\tut16 data3;\n\tut8 data4[8];\n} SGUID;\n\nstruct SCV_RSDS_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tSGUID guid;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_RSDS_HEADER* rsds_hdr);\n} SCV_RSDS_HEADER;\n\nR_API RBinPEObj* PE_(get)(RBinFile *bf) {\n\treturn (bf && bf->o)? bf->o->bin_obj: NULL;\n}\n\nstatic inline int is_thumb(RBinPEObj* pe) {\n\treturn pe->nt_headers->optional_header.AddressOfEntryPoint & 1;\n}\n\nstatic inline int is_arm(RBinPEObj* pe) {\n\tswitch (pe->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool read_and_follow_jump(struct r_bin_pe_addr_t *entry, RBuffer *buf, ut8 *b, int len, bool big_endian) {\n\tif (!r_buf_read_at (buf, entry->paddr, b, len)) {\n\t\treturn false;\n\t}\n\tif (b[0] != 0xe9) {\n\t\treturn true;\n\t}\n\tconst st32 jmp_dst = r_read_ble32 (b + 1, big_endian) + 5;\n\tentry->paddr += jmp_dst;\n\tentry->vaddr += jmp_dst;\n\treturn r_buf_read_at (buf, entry->paddr, b, len) > 0;\n}\n\nstatic inline bool follow_offset(struct r_bin_pe_addr_t *entry, RBuffer *buf, ut8 *b, int len, bool big_endian, size_t instr_off) {\n\tconst st32 dst_offset = r_read_ble32 (b + instr_off + 1, big_endian) + instr_off + 5;\n\tentry->paddr += dst_offset;\n\tentry->vaddr += dst_offset;\n\treturn read_and_follow_jump (entry, buf, b, len, big_endian);\n}\n\nstruct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj *pe) {\n\tr_return_val_if_fail (pe && pe->b, NULL);\n\tut8 b[512];\n\tsize_t n = 0;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\n\tread_and_follow_jump (entry, pe->b, b, sizeof (b), pe->big_endian);\n\n\t// MSVC SEH\n\t// E8 13 09 00 00  call    0x44C388\n\t// E9 05 00 00 00  jmp     0x44BA7F\n\tif (b[0] == 0xe8 && b[5] == 0xe9) {\n\t\tif (follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 5)) {\n\t\t\t// case1:\n\t\t\t// from des address of jmp search for 68 xx xx xx xx e8 and test xx xx xx xx = imagebase\n\t\t\t// 68 00 00 40 00  push    0x400000\n\t\t\t// E8 3E F9 FF FF  call    0x44B4FF\n\t\t\tut32 imageBase = pe->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tconst ut32 tmp_imgbase = r_read_ble32 (b + n + 1, pe->big_endian);\n\t\t\t\tif (b[n] == 0x68 && tmp_imgbase == imageBase && b[n + 5] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case2:\n\t\t\t// from des address of jmp search for 50 FF xx FF xx E8\n\t\t\t//50\t\t\t push    eax\n\t\t\t//FF 37\t\t\t push    dword ptr[edi]\n\t\t\t//FF 36          push    dword ptr[esi]\n\t\t\t//E8 6F FC FF FF call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n+1] == 0xff && b[n + 3] == 0xff && b[n + 5] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case3:\n\t\t\t//50                                         push    eax\n\t\t\t//FF 35 0C E2 40 00                          push    xxxxxxxx\n\t\t\t//FF 35 08 E2 40 00                          push    xxxxxxxx\n\t\t\t//E8 2B FD FF FF                             call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 20; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0xff && b[n + 7] == 0xff && b[n + 13] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 13);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case4:\n\t\t\t//50                                        push    eax\n\t\t\t//57                                        push    edi\n\t\t\t//FF 36                                     push    dword ptr[esi]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0x57 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case5:\n\t\t\t//57                                        push    edi\n\t\t\t//56                                        push    esi\n\t\t\t//FF 36                                     push    dword ptr[eax]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x57 && b[n + 1] == 0x56 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// MSVC 32bit debug\n\tif (b[3] == 0xe8) {\n\t\t// 55                    push ebp\n\t\t// 8B EC                 mov ebp, esp\n\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t// 5D                    pop ebp\n\t\t// C3                    ret\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 3);\n\t\tif (b[8] == 0xe8) {\n\t\t\t// 55                    push ebp\n\t\t\t// 8B EC                 mov ebp, esp\n\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t// E8 xx xx xx xx        call xxxxxxxx <- Follow this\n\t\t\t// 5D                    pop ebp\n\t\t\t// C3                    ret\n\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 8);\n\t\t\tfor (n = 0; n + 16 < sizeof (b); n++) {\n\t\t\t\t// E8 xx xx xx xx    call sub.ucrtbased.dll__register_thread_local_exe_atexit_callback\n\t\t\t\t// 83 C4 04          add esp, 4\n\t\t\t\t// E8 xx xx xx xx    call xxxxxxxx <- Follow this\n\t\t\t\t// 89 xx xx          mov dword [xxxx], eax\n\t\t\t\t// E8 xx xx xx xx    call xxxxxxxx\n\t\t\t\tif (b[n] == 0xe8 && n + 8 <= sizeof (b) && !memcmp (b + n + 5, \"\\x83\\xc4\\x04\", 3)\n\t\t\t\t\t&& b[n + 8] == 0xe8 && b[n + 13] == 0x89 && b[n + 16] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\t\tint j, calls = 0;\n\t\t\t\t\tfor (j = 0; j < sizeof (b) - 4; j++) {\n\t\t\t\t\t\tif (b[j] == 0xe8) {\n\t\t\t\t\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t\t\t\t\tcalls++;\n\t\t\t\t\t\t\tif (calls == 4) {\n\t\t\t\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, j);\n\t\t\t\t\t\t\t\treturn entry;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// MSVC AMD64\n\tif (b[4] == 0xe8) {\n\t\tbool found_caller = false;\n\t\tif (b[13] == 0xe9) {\n\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t// E9 xx xx xx xx    jmp     xxxxxxxx <- Follow this\n\t\t\tfound_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 13);\n\t\t} else {\n\t\t\t// Debug\n\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t// C3                ret\n\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 4);\n\t\t\tif (b[9] == 0xe8) {\n\t\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t\t// E8 xx xx xx xx    call    xxxxxxxx <- Follow this\n\t\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t\t// C3                ret\n\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 9);\n\t\t\t\tif (b[0x129] == 0xe8) {\n\t\t\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t\t\tfound_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 0x129);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found_caller) {\n\t\t\t// from des address of jmp, search for 4C ... 48 ... 8B ... E8\n\t\t\t// 4C 8B C0                    mov     r8, rax\n\t\t\t// 48 8B 17                    mov     rdx, qword [rdi]\n\t\t\t// 8B 0B                       mov     ecx, dword [rbx]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\t// or\n\t\t\t// 4C 8B 44 24 28              mov r8, qword [rsp + 0x28]\n\t\t\t// 48 8B 54 24 30              mov rdx, qword [rsp + 0x30]\n\t\t\t// 8B 4C 24 20                 mov ecx, dword [rsp + 0x20]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\tfor (n = 0; n + 14 < sizeof (b); n++) {\n\t\t\t\tif (b[n] == 0x4c && b[n + 3] == 0x48 && b[n + 6] == 0x8b && b[n + 8] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t\tif (b[n] == 0x4c && b [n + 5] == 0x48 && b[n + 10] == 0x8b && b[n + 14] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 14);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Microsoft Visual-C\n\t// 50                  push eax\n\t// FF 75 9C            push dword [ebp - local_64h]\n\t// 56                  push    esi\n\t// 56                  push    esi\n\t// FF 15 CC C0  44 00  call dword [sym.imp.KERNEL32.dll_GetModuleHandleA]\n\t// 50                  push    eax\n\t// E8 DB DA 00 00      call    main\n\t// 89 45 A0            mov dword [ebp - local_60h], eax\n\t// 50                  push    eax\n\t// E8 2D 00 00  00     call 0x4015a6\n\tif (b[188] == 0x50 && b[201] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 201);\n\t\treturn entry;\n\t}\n\n\tif (b[292] == 0x50 && b[303] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 303);\n\t\treturn entry;\n\t}\n\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t* entry;\n\tbool sw = false;\n\tut8 b[1024];\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// mingw\n\t//55                                         push    ebp\n\t//89 E5                                      mov     ebp, esp\n\t//83 EC 08                                   sub     esp, 8\n\t//C7 04 24 01 00 00 00                       mov     dword ptr[esp], 1\n\t//FF 15 C8 63 41 00                          call    ds : __imp____set_app_type\n\t//E8 B8 FE FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\t//83 EC 1C                                   sub     esp, 1Ch\n\t//C7 04 24 01 00 00 00                       mov[esp + 1Ch + var_1C], 1\n\t//FF 15 F8 60 40 00                          call    ds : __imp____set_app_type\n\t//E8 6B FD FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\t//83 EC 0C                                            sub     esp, 0Ch\n\t//C7 05 F4 0A 81 00 00 00 00 00                       mov     ds : _mingw_app_type, 0\n\t//ED E8 3E AD 24 00                                      call    ___security_init_cookie\n\t//F2 83 C4 0C                                            add     esp, 0Ch\n\t//F5 E9 86 FC FF FF                                      jmp     ___tmainCRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\t// case1:\n\t\t// from des address of call search for a1 xx xx xx xx 89 xx xx e8 xx xx xx xx\n\t\t//A1 04 50 44 00                             mov     eax, ds:dword_445004\n\t\t//89 04 24                                   mov[esp + 28h + lpTopLevelExceptionFilter], eax\n\t\t//E8 A3 01 00 00                             call    sub_4013EE\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\t// option2: /x 8bff558bec83ec20\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t/* Decode the jmp instruction, this gets the address of the 'main'\n\t   function for PE produced by a compiler whose name someone forgot to\n\t   write down. */\n\t// this is dirty only a single byte check, can return false positives\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\t// 5. ff 15 .. .. .. .. 50 e8 [main]\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (pe);\n\tif (!winmain) {\n\t\twinmain = PE_(check_mingw) (pe);\n\t\tif (!winmain) {\n\t\t\twinmain = PE_(check_unknow) (pe);\n\t\t}\n\t}\n\treturn winmain;\n}\n\nR_API PE_DWord PE_(va2pa)(RBinPEObj* pe, PE_DWord rva) {\n\tPE_DWord section_base;\n\tint i, section_size;\n\tut32 image_base = pe->nt_headers->optional_header.ImageBase;\n\tif (rva > image_base) {\n\t\trva -= image_base;\n\t}\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\tsection_base = pe->sections[i].vaddr;\n\t\tsection_size = pe->sections[i].vsize;\n\t\tif (rva >= section_base && rva < section_base + section_size) {\n\t\t\treturn pe->sections[i].paddr + (rva - section_base);\n\t\t}\n\t}\n\treturn rva;\n}\n\nut64 PE_(r_bin_pe_get_image_base)(RBinPEObj* pe) {\n\tut64 imageBase = 0;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn 0LL;\n\t}\n\timageBase = pe->nt_headers->optional_header.ImageBase;\n\tif (!imageBase) {\n\t\t//this should only happens with messed up binaries\n\t\t//XXX this value should be user defined by bin.baddr\n\t\t//but from here we can not access config API\n\t\timageBase = 0x10000;\n\t}\n\treturn imageBase;\n}\n\nstatic PE_DWord bin_pe_rva_to_va(RBinPEObj* pe, PE_DWord rva) {\n\treturn PE_(r_bin_pe_get_image_base) (pe) + rva;\n}\n\nstatic PE_DWord bin_pe_va_to_rva(RBinPEObj* pe, PE_DWord va) {\n\tut64 imageBase = PE_(r_bin_pe_get_image_base) (pe);\n\tif (va < imageBase) {\n\t\treturn va;\n\t}\n\treturn va - imageBase;\n}\n\nstatic char* resolveModuleOrdinal(Sdb* sdb, const char* module, int ordinal) {\n\tSdb* db = sdb;\n\tr_strf_var (key, 32, \"%d\", ordinal);\n\tchar* foo = sdb_get (db, key, 0);\n\tif (foo && *foo) {\n\t\treturn foo;\n\t} else {\n\t\tfree (foo); // should never happen\n\t}\n\treturn NULL;\n}\n\nstatic int bin_pe_parse_imports(RBinPEObj* pe,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname = NULL;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || !*dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&\n\t!(off = PE_(va2pa) (pe, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof (PE_DWord) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\timport_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));\n\t\tif (import_table == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"Ordinal_%i\", import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tchar* filename = NULL;\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = r_str_newf (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (filename && r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *lower_symdllname = strdup (symdllname);\n\t\t\t\t\t\tr_str_case (lower_symdllname, false);\n\t\t\t\t\t\tfilename = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, lower_symdllname);\n\t\t\t\t\t\tfree (lower_symdllname);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s\", symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", filename);\n\t\t\t\t}\n\t\t\t\tfree (filename);\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = PE_(va2pa) (pe, import_table);\n\t\t\t\tif (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\timport_hint = r_buf_read_le16_at (pe->b, off);\n\t\t\t\tif (import_hint == UT16_MAX) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tint len = snprintf (import_name, sizeof (import_name), \"%s\" , name);\n\t\t\t\tif (len >= sizeof (import_name)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", import_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!new_importp) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*importp = new_importp;\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}\n\nint PE_(read_dos_header)(RBuffer *b, PE_(image_dos_header) *header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, 0, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\theader->e_magic = r_buf_read_le16 (b);\n\theader->e_cblp = r_buf_read_le16 (b);\n\theader->e_cp = r_buf_read_le16 (b);\n\theader->e_crlc = r_buf_read_le16 (b);\n\theader->e_cparhdr = r_buf_read_le16 (b);\n\theader->e_minalloc = r_buf_read_le16 (b);\n\theader->e_maxalloc = r_buf_read_le16 (b);\n\theader->e_ss = r_buf_read_le16 (b);\n\theader->e_sp = r_buf_read_le16 (b);\n\theader->e_csum = r_buf_read_le16 (b);\n\theader->e_ip = r_buf_read_le16 (b);\n\theader->e_cs = r_buf_read_le16 (b);\n\theader->e_lfarlc = r_buf_read_le16 (b);\n\theader->e_ovno = r_buf_read_le16 (b);\n\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\theader->e_res[i] = r_buf_read_le16 (b);\n\t}\n\theader->e_oemid = r_buf_read_le16 (b);\n\theader->e_oeminfo = r_buf_read_le16 (b);\n\tfor (i = 0; i < 10; i++) {\n\t\theader->e_res2[i] = r_buf_read_le16 (b);\n\t}\n\theader->e_lfanew = r_buf_read_le32 (b);\n\tif (r_buf_seek (b, o_addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn sizeof (PE_(image_dos_header));\n}\n\nint PE_(read_nt_headers)(RBuffer *b, ut64 addr, PE_(image_nt_headers) *headers) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\theaders->Signature = r_buf_read_le32 (b);\n\theaders->file_header.Machine = r_buf_read_le16 (b);\n\theaders->file_header.NumberOfSections = r_buf_read_le16 (b);\n\theaders->file_header.TimeDateStamp = r_buf_read_le32 (b);\n\theaders->file_header.PointerToSymbolTable = r_buf_read_le32 (b);\n\theaders->file_header.NumberOfSymbols = r_buf_read_le32 (b);\n\theaders->file_header.SizeOfOptionalHeader = r_buf_read_le16 (b);\n\theaders->file_header.Characteristics = r_buf_read_le16 (b);\n\theaders->optional_header.Magic = r_buf_read_le16 (b);\n\theaders->optional_header.MajorLinkerVersion = r_buf_read8 (b);\n\theaders->optional_header.MinorLinkerVersion = r_buf_read8 (b);\n\theaders->optional_header.SizeOfCode = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfInitializedData = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfUninitializedData = r_buf_read_le32 (b);\n\theaders->optional_header.AddressOfEntryPoint = r_buf_read_le32 (b);\n\theaders->optional_header.BaseOfCode = r_buf_read_le32 (b);\n#ifdef R_BIN_PE64\n\theaders->optional_header.ImageBase = r_buf_read_le64 (b);\n#else\n\theaders->optional_header.BaseOfData = r_buf_read_le32 (b);\n\theaders->optional_header.ImageBase = r_buf_read_le32 (b);\n#endif\n\theaders->optional_header.SectionAlignment = r_buf_read_le32 (b);\n\theaders->optional_header.FileAlignment = r_buf_read_le32 (b);\n\theaders->optional_header.MajorOperatingSystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorOperatingSystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MajorImageVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorImageVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MajorSubsystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorSubsystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.Win32VersionValue = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfImage = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeaders = r_buf_read_le32 (b);\n\theaders->optional_header.CheckSum = r_buf_read_le32 (b);\n\theaders->optional_header.Subsystem = r_buf_read_le16 (b);\n\theaders->optional_header.DllCharacteristics = r_buf_read_le16 (b);\n#ifdef R_BIN_PE64\n\theaders->optional_header.SizeOfStackReserve = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfStackCommit = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfHeapReserve = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfHeapCommit = r_buf_read_le64 (b);\n#else\n\theaders->optional_header.SizeOfStackReserve = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfStackCommit = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeapReserve = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeapCommit = r_buf_read_le32 (b);\n#endif\n\theaders->optional_header.LoaderFlags = r_buf_read_le32 (b);\n\theaders->optional_header.NumberOfRvaAndSizes = r_buf_read_le32 (b);\n\tint i;\n\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\theaders->optional_header.DataDirectory[i].VirtualAddress = r_buf_read_le32 (b);\n\t\theaders->optional_header.DataDirectory[i].Size = r_buf_read_le32 (b);\n\t}\n\tif (r_buf_seek (b, o_addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn sizeof (PE_(image_nt_headers));\n}\n\nstatic int bin_pe_init_hdr(RBinPEObj* pe) {\n\tif (!(pe->dos_header = malloc (sizeof (PE_(image_dos_header))))) {\n\t\tr_sys_perror (\"malloc (dos header)\");\n\t\treturn false;\n\t}\n\tif (PE_(read_dos_header) (pe->b, pe->dos_header) < 0) {\n\t\tpe_printf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_num_set (pe->kv, \"pe_dos_header.offset\", 0, 0);\n\tsdb_set (pe->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"\n\t\t\" e_magic e_cblp e_cp e_crlc e_cparhdr e_minalloc e_maxalloc\"\n\t\t\" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"\n\t\t\" e_oeminfo e_res2 e_lfanew\", 0);\n\tif (pe->dos_header->e_lfanew > (unsigned int) pe->size) {\n\t\tpe_printf (\"Invalid e_lfanew field\\n\");\n\t\treturn false;\n\t}\n\tif (!(pe->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {\n\t\tr_sys_perror (\"malloc (nt header)\");\n\t\treturn false;\n\t}\n\tpe->nt_header_offset = pe->dos_header->e_lfanew;\n\tif (PE_(read_nt_headers) (pe->b, pe->dos_header->e_lfanew, pe->nt_headers) < 0) {\n\t\tpe_printf (\"Warning: read (nt header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (pe->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);\n\tsdb_set (pe->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"\n\t\t\" IMAGE_SUBSYSTEM_WINDOWS_CUI=3, IMAGE_SUBSYSTEM_OS2_CUI=5, IMAGE_SUBSYSTEM_POSIX_CUI=7, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI=9, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_APPLICATION=10, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER=11, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER=12, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_ROM=13, IMAGE_SUBSYSTEM_XBOX=14, IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION=16 };\", 0);\n\tsdb_set (pe->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"\n\t\t\" IMAGE_LIBRARY_THREAD_INIT=0x0004, IMAGE_LIBRARY_THREAD_TERM=0x0008, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA=0x0020, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE=0x0040, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY=0x0080, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NX_COMPAT=0x0100, IMAGE_DLLCHARACTERISTICS_NO_ISOLATION=0x0200,IMAGE_DLLCHARACTERISTICS_NO_SEH=0x0400, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NO_BIND=0x0800, IMAGE_DLLCHARACTERISTICS_APPCONTAINER=0x1000, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER=0x2000, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_GUARD_CF=0x4000, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE=0x8000};\", 0);\n#if R_BIN_PE64\n\tsdb_num_set (pe->kv, \"pe_nt_image_headers64.offset\", pe->dos_header->e_lfanew, 0);\n\tsdb_set (pe->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);\n\tsdb_set (pe->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags\"\n\t\t\" numberOfRvaAndSizes (pe_image_data_directory)dataDirectory\", 0);\n#else\n\tsdb_num_set (pe->kv, \"pe_nt_image_headers32.offset\", pe->dos_header->e_lfanew, 0);\n\tsdb_set (pe->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);\n\tsdb_set (pe->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode baseOfData imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags numberOfRvaAndSizes\"\n\t\t\" (pe_image_data_directory)dataDirectory\", 0);\n#endif\n\tsdb_set (pe->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);\n\tsdb_set (pe->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"\n\t\t\" IMAGE_FILE_RELOCS_STRIPPED=0x0001, IMAGE_FILE_EXECUTABLE_IMAGE=0x0002, IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004, \"\n\t\t\" IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008, IMAGE_FILE_AGGRESIVE_WS_TRIM=0x0010, IMAGE_FILE_LARGE_ADDRESS_AWARE=0x0020, \"\n\t\t\" IMAGE_FILE_BYTES_REVERSED_LO=0x0080, IMAGE_FILE_32BIT_MACHINE=0x0100, IMAGE_FILE_DEBUG_STRIPPED=0x0200, \"\n\t\t\" IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP=0x0400, IMAGE_FILE_NET_RUN_FROM_SWAP=0x0800, IMAGE_FILE_SYSTEM=0x1000, \"\n\t\t\" IMAGE_FILE_DLL=0x2000, IMAGE_FILE_UP_SYSTEM_ONLY=0x4000, IMAGE_FILE_BYTES_REVERSED_HI=0x8000 };\", 0);\n\tsdb_set (pe->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"\n\t\t\" (pe_machine)machine numberOfSections timeDateStamp pointerToSymbolTable\"\n\t\t\" numberOfSymbols sizeOfOptionalHeader (pe_characteristics)characteristics\", 0);\n\tsdb_set (pe->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);\n\n\t// adding compile time to the SDB\n\t{\n\t\tsdb_num_set (pe->kv, \"image_file_header.TimeDateStamp\", pe->nt_headers->file_header.TimeDateStamp, 0);\n\t\tchar *timestr = r_time_stamp_to_str (pe->nt_headers->file_header.TimeDateStamp);\n\t\tsdb_set_owned (pe->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);\n\t}\n\tpe->optional_header = &pe->nt_headers->optional_header;\n\tpe->data_directory = (PE_(image_data_directory*)) & pe->optional_header->DataDirectory;\n\n\tif (pe->dos_header->e_magic != 0x5a4d || // \"MZ\"\n\t\t(pe->nt_headers->Signature != 0x4550 && // \"PE\"\n\t\t/* Check also for Phar Lap TNT DOS extender PL executable */\n\t\tpe->nt_headers->Signature != 0x4c50)) { // \"PL\"\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tut64 shortname;\n\tut32 value;\n\tut16 secnum;\n\tut16 symtype;\n\tut8 symclass;\n\tut8 numaux;\n} SymbolRecord;\n\nstatic struct r_bin_pe_export_t* parse_symbol_table(RBinPEObj* pe, struct r_bin_pe_export_t* exports, int sz) {\n\tut64 sym_tbl_off, num = 0;\n\tconst int srsz = COFF_SYMBOL_SIZE; // symbol record size\n\tstruct r_bin_pe_section_t* sections;\n\tstruct r_bin_pe_export_t* exp;\n\tstruct r_bin_pe_export_t* new_exports = NULL;\n\tconst size_t export_t_sz = sizeof (struct r_bin_pe_export_t);\n\tint bufsz, i, shsz;\n\tSymbolRecord sr;\n\tut64 text_off = 0LL;\n\tut64 text_rva = 0LL;\n\tint textn = 0;\n\tint exports_sz;\n\tint symctr = 0;\n\tchar* buf;\n\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\n\tsym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;\n\tnum = pe->nt_headers->file_header.NumberOfSymbols;\n\tshsz = bufsz = num * srsz;\n\tif (bufsz < 1 || bufsz > pe->size) {\n\t\treturn NULL;\n\t}\n\tbuf = calloc (num, srsz);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\texports_sz = export_t_sz * num;\n\tif (exports) {\n\t\tint osz = sz;\n\t\tsz += exports_sz;\n\t\tnew_exports = realloc (exports, sz + export_t_sz);\n\t\tif (!new_exports) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\texports = new_exports;\n\t\tnew_exports = NULL;\n\t\texp = (struct r_bin_pe_export_t*) (((const ut8*) exports) + osz);\n\t} else {\n\t\tsz = exports_sz;\n\t\texports = malloc (sz + export_t_sz);\n\t\texp = exports;\n\t}\n\n\tsections = pe->sections;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t//XXX search by section with +x permission since the section can be left blank\n\t\tif (!strcmp ((char*) sections[i].name, \".text\")) {\n\t\t\ttext_rva = sections[i].vaddr;\n\t\t\ttext_off = sections[i].paddr;\n\t\t\ttextn = i + 1;\n\t\t}\n\t}\n\tsymctr = 0;\n\tif (r_buf_read_at (pe->b, sym_tbl_off, (ut8*) buf, bufsz) > 0) {\n\t\tfor (i = 0; i < shsz; i += srsz) {\n\t\t\t// sr = (SymbolRecord*) (buf + i);\n\t\t\tif (i + sizeof (sr) >= bufsz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy (&sr, buf + i, sizeof (sr));\n\t\t\t//pe_printf (\"SECNUM %d\\n\", sr.secnum);\n\t\t\tif (sr.secnum == textn) {\n\t\t\t\tif (sr.symtype == 32) {\n\t\t\t\t\tchar shortname[9];\n\t\t\t\t\tmemcpy (shortname, &sr.shortname, 8);\n\t\t\t\t\tshortname[8] = 0;\n\t\t\t\t\tif (*shortname) {\n\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, shortname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar* longname, name[128];\n\t\t\t\t\t\tut32 idx = r_read_le32 (buf + i + 4);\n\t\t\t\t\t\tif (r_buf_read_at (pe->b, sym_tbl_off + idx + shsz, (ut8*) name, 128)) { // == 128) {\n\t\t\t\t\t\t\tlongname = name;\n\t\t\t\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, longname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf ((char*) exp[symctr].name, \"unk_%d\", symctr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texp[symctr].name[PE_NAME_LENGTH] = '\\0';\n\t\t\t\t\texp[symctr].libname[0] = '\\0';\n\t\t\t\t\texp[symctr].vaddr = bin_pe_rva_to_va (pe, text_rva + sr.value);\n\t\t\t\t\texp[symctr].paddr = text_off + sr.value;\n\t\t\t\t\texp[symctr].ordinal = symctr;\n\t\t\t\t\texp[symctr].forwarder[0] = 0;\n\t\t\t\t\texp[symctr].last = 0;\n\t\t\t\t\tsymctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t} // for\n\t} // if read ok\n\texp[symctr].last = 1;\n\tfree (buf);\n\treturn exports;\n}\n\nint PE_(read_image_section_header)(RBuffer *b, ut64 addr, PE_(image_section_header) *section_header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\tsection_header->Name[0] = 0;\n\t\treturn -1;\n\t}\n\n\tut8 buf[sizeof (PE_(image_section_header))] = {0};\n\tr_buf_read (b, buf, sizeof (buf));\n\tmemcpy (section_header->Name, buf, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), Misc.PhysicalAddress, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), VirtualAddress, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), SizeOfRawData, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToRawData, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToRelocations, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToLinenumbers, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), NumberOfRelocations, 16);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), NumberOfLinenumbers, 16);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), Characteristics, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_section_header));\n}\n\nvoid PE_(write_image_section_header)(RBuffer *b, ut64 addr, PE_(image_section_header) *section_header) {\n\tut8 buf[sizeof (PE_(image_section_header))];\n\tmemcpy (buf, section_header->Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tr_write_at_le32 (buf, section_header->Misc.PhysicalAddress, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tr_write_at_le32 (buf, section_header->VirtualAddress, PE_IMAGE_SIZEOF_SHORT_NAME + 4);\n\tr_write_at_le32 (buf, section_header->SizeOfRawData, PE_IMAGE_SIZEOF_SHORT_NAME + 8);\n\tr_write_at_le32 (buf, section_header->PointerToRawData, PE_IMAGE_SIZEOF_SHORT_NAME + 12);\n\tr_write_at_le32 (buf, section_header->PointerToRelocations, PE_IMAGE_SIZEOF_SHORT_NAME + 16);\n\tr_write_at_le32 (buf, section_header->PointerToLinenumbers, PE_IMAGE_SIZEOF_SHORT_NAME + 20);\n\tr_write_at_le16 (buf, section_header->NumberOfRelocations, PE_IMAGE_SIZEOF_SHORT_NAME + 24);\n\tr_write_at_le16 (buf, section_header->NumberOfLinenumbers, PE_IMAGE_SIZEOF_SHORT_NAME + 26);\n\tr_write_at_le32 (buf, section_header->Characteristics, PE_IMAGE_SIZEOF_SHORT_NAME + 28);\n\tr_buf_write_at (b, addr, buf, sizeof (PE_(image_section_header)));\n}\n\nstatic struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe);\nstatic int bin_pe_init_sections(RBinPEObj* pe) {\n\tpe->num_sections = pe->nt_headers->file_header.NumberOfSections;\n\tif (pe->num_sections < 1) {\n\t\treturn true;\n\t}\n\tint sections_size = sizeof (PE_(image_section_header)) * pe->num_sections;\n\tif (sections_size > pe->size) {\n\t\tsections_size = pe->size;\n\t\tpe->num_sections = pe->size / sizeof (PE_(image_section_header));\n\t\t// massage this to make corkami happy\n\t\t//pe_printf (\"Invalid NumberOfSections value\\n\");\n\t\t//goto out_error;\n\t}\n\tif (!(pe->section_header = malloc (sections_size))) {\n\t\tr_sys_perror (\"malloc (section header)\");\n\t\tgoto out_error;\n\t}\n\tpe->section_header_offset = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +\n\t\tpe->nt_headers->file_header.SizeOfOptionalHeader;\n\tint i;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\tif (PE_(read_image_section_header) (pe->b, pe->section_header_offset + i * sizeof (PE_(image_section_header)),\n\t\t\tpe->section_header + i) < 0) {\n\t\t\tpe_printf (\"Warning: read (sections)\\n\");\n\t\t\tR_FREE (pe->section_header);\n\t\t\tgoto out_error;\n\t\t}\n\t}\n#if 0\n\tEach symbol table entry includes a name, storage class, type, value and section number.Short names (8 characters or fewer) are stored directly in the symbol table;\n\tlonger names are stored as an paddr into the string table at the end of the COFF object.\n\n\t================================================================\n\tCOFF SYMBOL TABLE RECORDS (18 BYTES)\n\t================================================================\n\trecord\n\tpaddr\n\n\tstruct symrec {\n\t\tunion {\n\t\t\tchar string[8]; // short name\n\t\t\tstruct {\n\t\t\t\tut32 seros;\n\t\t\t\tut32 stridx;\n\t\t\t} stridx;\n\t\t} name;\n\t\tut32 value;\n\t\tut16 secnum;\n\t\tut16 symtype;\n\t\tut8 symclass;\n\t\tut8 numaux;\n\t}\n\t------------------------------------------------------ -\n\t0 | 8 - char symbol name |\n\t| or 32 - bit zeroes followed by 32 - bit |\n\t| index into string table |\n\t------------------------------------------------------ -\n\t8 | symbol value |\n\t------------------------------------------------------ -\n\t0Ch | section number | symbol type |\n\t------------------------------------------------------ -\n\t10h | sym class | num aux |\n\t-------------------------- -\n\t12h\n\n#endif\n\treturn true;\nout_error:\n\tpe->num_sections = 0;\n\treturn false;\n}\n\nint PE_(bin_pe_get_claimed_checksum)(RBinPEObj* pe) {\n\tif (!pe || !pe->optional_header) {\n\t\treturn 0;\n\t}\n\treturn pe->optional_header->CheckSum;\n}\n\nint PE_(bin_pe_get_actual_checksum)(RBinPEObj* pe) {\n\tsize_t i, j, checksum_offset = 0;\n\tut64 computed_cs = 0;\n\tint remaining_bytes;\n\tint shift;\n\tut32 cur;\n\tif (!pe || !pe->nt_header_offset) {\n\t\treturn 0;\n\t}\n\tconst size_t buf_sz = 0x1000;\n\tut32 *buf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\tif (r_buf_read_at (pe->b, 0, (ut8 *)buf, buf_sz) < 0) {\n\t\tfree (buf);\n\t\treturn 0;\n\t}\n\tchecksum_offset = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;\n\tfor (i = 0, j = 0; i < pe->size / 4; i++) {\n\t\tcur = r_read_at_ble32 (buf, j * 4, pe->endian);\n\t\tj++;\n\t\t// skip the checksum bytes\n\t\tif (i * 4 == checksum_offset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t\tif (j == buf_sz / 4) {\n\t\t\tif (r_buf_read_at (pe->b, (i + 1) * 4, (ut8 *)buf, buf_sz) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t// add resultant bytes to checksum\n\tremaining_bytes = pe->size % 4;\n\ti = i * 4;\n\tif (remaining_bytes != 0) {\n\t\tcur = r_buf_read8_at (pe->b, i);\n\t\tshift = 8;\n\t\tfor (j = 1; j < remaining_bytes; j++, shift += 8) {\n\t\t\tcur |= r_buf_read8_at (pe->b, i + j) << shift;\n\t\t}\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// 32bits -> 16bits\n\tcomputed_cs = (computed_cs & 0xFFFF) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs & 0xFFFF);\n\n\t// add filesize\n\tcomputed_cs += pe->size;\n\tfree (buf);\n\treturn computed_cs;\n}\n\nstatic const char* PE_(bin_pe_get_claimed_authentihash)(RBinPEObj* pe) {\n\tif (!pe->spcinfo) {\n\t\treturn NULL;\n\t}\n\tRASN1Binary *digest = pe->spcinfo->messageDigest.digest;\n\treturn digest? r_hex_bin2strdup (digest->binary, digest->length): NULL;\n}\n\nconst char* PE_(bin_pe_compute_authentihash)(RBinPEObj* pe) {\n\tif (!pe->spcinfo || !pe->spcinfo->messageDigest.digestAlgorithm.algorithm) {\n\t\treturn NULL;\n\t}\n\n\tchar *hashtype = strdup (pe->spcinfo->messageDigest.digestAlgorithm.algorithm->string);\n\tr_str_replace_char (hashtype, '-', 0);\n\tut64 algobit = r_hash_name_to_bits (hashtype);\n\tif (!(algobit & (R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256))) {\n\t\teprintf (\"Authenticode only supports md5, sha1, sha256. This PE uses %s\\n\", hashtype);\n\t\tfree (hashtype);\n\t\treturn NULL;\n\t}\n\tfree (hashtype);\n\tut32 checksum_paddr = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;\n\tut32 security_entry_offset =  pe->nt_header_offset + sizeof (PE_(image_nt_headers)) - 96;\n\tPE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];\n\tPE_DWord security_dir_offset = data_dir_security->VirtualAddress;\n\tut32 security_dir_size = data_dir_security->Size;\n\n\tRBuffer *buf = r_buf_new ();\n\tr_buf_append_buf_slice (buf, pe->b, 0, checksum_paddr);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tchecksum_paddr + 4,\n\t\tsecurity_entry_offset - checksum_paddr - 4);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tsecurity_entry_offset + 8,\n\t\tsecurity_dir_offset - security_entry_offset - 8);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tsecurity_dir_offset + security_dir_size,\n\t\tr_buf_size (pe->b) - security_dir_offset - security_dir_size);\n\n\tut64 len;\n\tconst ut8 *data = r_buf_data (buf, &len);\n\tchar *hashstr = NULL;\n\tRHash *ctx = r_hash_new (true, algobit);\n\tif (ctx) {\n\t\tr_hash_do_begin (ctx, algobit);\n\t\tint digest_size = r_hash_calculate (ctx, algobit, data, len);\n\t\tr_hash_do_end (ctx, algobit);\n\t\thashstr = r_hex_bin2strdup (ctx->digest, digest_size);\n\t\tr_buf_free (buf);\n\t\tr_hash_free (ctx);\n\t}\n\treturn hashstr;\n}\n\nconst char* PE_(bin_pe_get_authentihash)(RBinPEObj* pe) {\n\treturn pe->authentihash;\n}\n\nint PE_(bin_pe_is_authhash_valid)(RBinPEObj* pe) {\n\treturn pe? pe->is_authhash_valid: false;\n}\n\nstatic void computeOverlayOffset(ut64 offset, ut64 size, ut64 file_size, ut64* largest_offset, ut64* largest_size) {\n\tif (offset + size <= file_size && offset + size > (*largest_offset + *largest_size)) {\n\t\t*largest_offset = offset;\n\t\t*largest_size = size;\n\t}\n}\n\n/* Inspired from https://github.com/erocarrera/pefile/blob/master/pefile.py#L5425 */\nint PE_(bin_pe_get_overlay)(RBinPEObj* pe, ut64* size) {\n\tut64 largest_offset = 0;\n\tut64 largest_size = 0;\n\t*size = 0;\n\tint i;\n\n\tif (!pe) {\n\t\treturn 0;\n\t}\n\n\tif (pe->optional_header) {\n\t\tcomputeOverlayOffset (\n\t\t\t\tpe->nt_header_offset+4+sizeof (pe->nt_headers->file_header),\n\t\t\t\tpe->nt_headers->file_header.SizeOfOptionalHeader,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t}\n\n\tstruct r_bin_pe_section_t *sects = pe->sections;\n\tfor (i = 0; !sects[i].last; i++) {\n\t\tcomputeOverlayOffset(\n\t\t\t\tsects[i].paddr,\n\t\t\t\tsects[i].size,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size\n\t\t\t\t);\n\t}\n\n\tif (pe->optional_header) {\n\t\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\t\tif (i == PE_IMAGE_DIRECTORY_ENTRY_SECURITY) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomputeOverlayOffset (\n\t\t\t\tPE_(va2pa) (pe, pe->data_directory[i].VirtualAddress),\n\t\t\t\tpe->data_directory[i].Size,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t\t}\n\n\t}\n\n\tif ((ut64) pe->size > largest_offset + largest_size) {\n\t\t*size = pe->size - largest_offset - largest_size;\n\t\treturn largest_offset + largest_size;\n\t}\n\treturn 0;\n}\n\nstatic int bin_pe_read_metadata_string(char* to, RBuffer *frombuf, int fromoff) {\n\tint covered = 0;\n\t*to = 0;\n\twhile (covered < MAX_METADATA_STRING_LENGTH) {\n\t\tconst char covch = r_buf_read8_at (frombuf, fromoff + covered);\n\t\tto[covered++] = covch;\n\t\tif (!covch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (covered % 4 != 0) { covered++; }\n\treturn covered;\n}\n\nstatic bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {\n\tPE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));\n\tif (!metadata) {\n\t\treturn false;\n\t}\n\tPE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;\n\tif (!metadata_directory) {\n\t\tfree (metadata);\n\t\treturn false;\n\t}\n\tint rr = r_buf_fread_at (pe->b, metadata_directory,\n\t\t(ut8*) metadata, pe->big_endian? \"1I2S\": \"1i2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 8,\n\t\t(ut8*) (&metadata->Reserved), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 12,\n\t\t(ut8*) (&metadata->VersionStringLength), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Metadata Signature: 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d\\n\",\n\t\t(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);\n\n\t// read the version string\n\tint len = metadata->VersionStringLength; // XXX: dont trust this length\n\tif (len > 0) {\n\t\tmetadata->VersionString = calloc (1, len + 1);\n\t\tif (!metadata->VersionString) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\trr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);\n\t\tif (rr != len) {\n\t\t\teprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");\n\t\t\tfree (metadata->VersionString);\n\t\t\tfree (metadata);\n\t\t\treturn 0;\n\t\t}\n\t\teprintf (\".NET Version: %s\\n\", metadata->VersionString);\n\t}\n\n\t// read the header after the string\n\trr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,\n\t\t(ut8*) (&metadata->Flags), pe->big_endian? \"2S\": \"2s\", 1);\n\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);\n\tpe->metadata_header = metadata;\n\n\n\t// read metadata streams\n\tint stream_addr = metadata_directory + 20 + metadata->VersionStringLength;\n\tPE_(image_metadata_stream) * stream;\n\tPE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);\n\tif (!streams) {\n\t\tgoto fail;\n\t}\n\tint count;\n\tfor (count = 0; count < metadata->NumberOfStreams; count++) {\n\t\tstream = R_NEW0 (PE_(image_metadata_stream));\n\t\tif (!stream) {\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {\n\t\t\teprintf (\"Truncated\\n\");\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? \"2I\": \"2i\", 1) < 1) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"DirectoryAddress: %x Size: %x\\n\", stream->Offset, stream->Size);\n\t\tchar* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);\n\n\t\tif (!stream_name) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tint c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);\n\t\tif (c == 0) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"Stream name: %s %d\\n\", stream_name, c);\n\t\tstream->Name = stream_name;\n\t\tstreams[count] = stream;\n\t\tstream_addr += 8 + c;\n\t}\n\tpe->streams = streams;\n\treturn true;\nfail:\n\teprintf (\"Warning: read (metadata header)\\n\");\n\tfree (metadata);\n\treturn false;\n}\n\nstatic int bin_pe_init_overlay(RBinPEObj* pe) {\n\tut64 pe_overlay_size;\n\tut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (pe, &pe_overlay_size);\n\tif (pe_overlay_offset) {\n\t\tsdb_num_set (pe->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);\n\t\tsdb_num_set (pe->kv, \"pe_overlay.size\", pe_overlay_size, 0);\n\t}\n\treturn 0;\n}\n\nstatic int read_image_clr_header(RBuffer *b, ut64 addr, PE_(image_clr_header) *header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_clr_header))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), HeaderSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MajorRuntimeVersion, 16);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MinorRuntimeVersion, 16);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MetaDataDirectoryAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MetaDataDirectorySize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), Flags, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), EntryPointToken, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ResourcesDirectoryAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ResourcesDirectorySize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), StrongNameSignatureAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), StrongNameSignatureSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), CodeManagerTableAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), CodeManagerTableSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), VTableFixupsAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), VTableFixupsSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ExportAddressTableJumpsAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ExportAddressTableJumpsSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ManagedNativeHeaderAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ManagedNativeHeaderSize, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_clr_header));\n}\n\nstatic int bin_pe_init_clr_hdr(RBinPEObj* pe) {\n\tPE_(image_data_directory) * clr_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];\n\tPE_DWord image_clr_hdr_paddr = PE_(va2pa) (pe, clr_dir->VirtualAddress);\n\t// int clr_dir_size = clr_dir? clr_dir->Size: 0;\n\tPE_(image_clr_header) * clr_hdr = R_NEW0 (PE_(image_clr_header));\n\tint rr, len = sizeof (PE_(image_clr_header));\n\n\tif (!clr_hdr) {\n\t\treturn 0;\n\t}\n\trr = read_image_clr_header (pe->b, image_clr_hdr_paddr, clr_hdr);\n\n//\tprintf(\"%x\\n\", clr_hdr->HeaderSize);\n\n\tif (clr_hdr->HeaderSize != 0x48) {\n\t\t// probably not a .NET binary\n\t\t// 64bit?\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\tif (rr != len) {\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\n\tpe->clr_hdr = clr_hdr;\n\treturn 1;\n}\n\nstatic int read_image_import_directory(RBuffer *b, ut64 addr, PE_(image_import_directory) *import_dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_import_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), ForwarderChain, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), FirstThunk, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_import_directory));\n}\n\nstatic int read_image_delay_import_directory(RBuffer *b, ut64 addr, PE_(image_delay_import_directory) *directory) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_delay_import_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), Attributes, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), ModulePlugin, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), DelayImportAddressTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), DelayImportNameTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), BoundDelayImportTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), UnloadDelayImportTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), TimeStamp, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_delay_import_directory));\n}\n\nstatic int bin_pe_init_imports(RBinPEObj* pe) {\n\tPE_(image_data_directory) * data_dir_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];\n\tPE_(image_data_directory) * data_dir_delay_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];\n\n\tPE_DWord import_dir_paddr = PE_(va2pa) (pe, data_dir_import->VirtualAddress);\n\tPE_DWord import_dir_offset = PE_(va2pa) (pe, data_dir_import->VirtualAddress);\n\tPE_DWord delay_import_dir_offset = data_dir_delay_import\n\t? PE_(va2pa) (pe, data_dir_delay_import->VirtualAddress)\n\t\t\t\t\t: 0;\n\n\tPE_(image_import_directory) * import_dir = NULL;\n\tPE_(image_import_directory) * new_import_dir = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\n\tPE_(image_delay_import_directory) * delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * new_delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\n\tint dir_size = sizeof (PE_(image_import_directory));\n\tint delay_import_size = sizeof (PE_(image_delay_import_directory));\n\tint indx = 0;\n\tint rr, count = 0;\n\tint import_dir_size = data_dir_import->Size;\n\tint delay_import_dir_size = data_dir_delay_import->Size;\n\t/// HACK to modify import size because of begin 0.. this may report wrong info con corkami tests\n\tif (!import_dir_size) {\n\t\t// asume 1 entry for each\n\t\timport_dir_size = data_dir_import->Size = 0xffff;\n\t}\n\tif (!delay_import_dir_size) {\n\t\t// asume 1 entry for each\n\t\tdelay_import_dir_size = data_dir_delay_import->Size = 0xffff;\n\t}\n\tint maxidsz = R_MIN ((PE_DWord) pe->size, import_dir_offset + import_dir_size);\n\tmaxidsz -= import_dir_offset;\n\tif (maxidsz < 0) {\n\t\tmaxidsz = 0;\n\t}\n\t//int maxcount = maxidsz/ sizeof (struct r_bin_pe_import_t);\n\n\tR_FREE (pe->import_directory);\n\tif (import_dir_paddr != 0) {\n\t\tif (import_dir_size < 1 || import_dir_size > maxidsz) {\n\t\t\tpe_printf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);\n\t\t\timport_dir_size = maxidsz;\n\t\t}\n\t\tpe->import_directory_offset = import_dir_offset;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tnew_import_dir = (PE_(image_import_directory)*)realloc (import_dir, ((1 + indx) * dir_size));\n\t\t\tif (!new_import_dir) {\n\t\t\t\tr_sys_perror (\"malloc (import directory)\");\n\t\t\t\tR_FREE (import_dir);\n\t\t\t\tbreak; //\n\t\t\t\t//\t\t\tgoto fail;\n\t\t\t}\n\t\t\timport_dir = new_import_dir;\n\t\t\tnew_import_dir = NULL;\n\t\t\tcurr_import_dir = import_dir + indx;\n\t\t\tif (read_image_import_directory (pe->b, import_dir_offset + indx * dir_size, curr_import_dir) <= 0) {\n\t\t\t\tpe_printf (\"Warning: read (import directory)\\n\");\n\t\t\t\tR_FREE (import_dir);\n\t\t\t\tbreak; //return false;\n\t\t\t}\n\t\t\tif (((2 + indx) * dir_size) > import_dir_size) {\n\t\t\t\tbreak; //goto fail;\n\t\t\t}\n\t\t\tindx++;\n\t\t\tcount++;\n\t\t} while (curr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\tcurr_import_dir->ForwarderChain != 0);\n\n\t\tpe->import_directory = import_dir;\n\t\tpe->import_directory_size = import_dir_size;\n\t}\n\n\tindx = 0;\n\tif (r_buf_size (pe->b) > 0) {\n\t\tif ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32)r_buf_size (pe->b))) {\n\t\t\tut64 off;\n\t\t\tpe->delay_import_directory_offset = delay_import_dir_offset;\n\t\t\tdo {\n\t\t\t\tindx++;\n\t\t\t\toff = indx * delay_import_size;\n\t\t\t\tif (off >= r_buf_size (pe->b)) {\n\t\t\t\t\tpe_printf (\"Warning: Cannot find end of import symbols\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew_delay_import_dir = (PE_(image_delay_import_directory)*)realloc (\n\t\t\t\t\tdelay_import_dir, (indx * delay_import_size) + 1);\n\t\t\t\tif (!new_delay_import_dir) {\n\t\t\t\t\tr_sys_perror (\"malloc (delay import directory)\");\n\t\t\t\t\tfree (delay_import_dir);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdelay_import_dir = new_delay_import_dir;\n\t\t\t\tcurr_delay_import_dir = delay_import_dir + (indx - 1);\n\t\t\t\trr = read_image_delay_import_directory (pe->b, delay_import_dir_offset + (indx - 1) * delay_import_size,\n\t\t\t\t\tcurr_delay_import_dir);\n\t\t\t\tif (rr != dir_size) {\n\t\t\t\t\tpe_printf (\"Warning: read (delay import directory)\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t} while (curr_delay_import_dir->Name != 0);\n\t\t\tpe->delay_import_directory = delay_import_dir;\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\tR_FREE (import_dir);\n\tpe->import_directory = import_dir;\n\tfree (delay_import_dir);\n\treturn false;\n}\n\nstatic int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_export_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_export_directory));\n}\n\nstatic int bin_pe_init_exports(RBinPEObj* pe) {\n\tPE_(image_data_directory) * data_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\tPE_DWord export_dir_paddr = PE_(va2pa) (pe, data_dir_export->VirtualAddress);\n\tif (!export_dir_paddr) {\n\t\t// This export-dir-paddr should only appear in DLL files\n\t\t// pe_printf (\"Warning: Cannot find the paddr of the export directory\\n\");\n\t\treturn false;\n\t}\n\t// sdb_setn (DB, \"hdr.exports_directory\", export_dir_paddr);\n\t// pe_printf (\"Pexports paddr at 0x%\"PFMT64x\"\\n\", export_dir_paddr);\n\tif (!(pe->export_directory = malloc (sizeof (PE_(image_export_directory))))) {\n\t\tr_sys_perror (\"malloc (export directory)\");\n\t\treturn false;\n\t}\n\tif (read_image_export_directory (pe->b, export_dir_paddr, pe->export_directory) < 0) {\n\t\tpe_printf (\"Warning: read (export directory)\\n\");\n\t\tR_FREE (pe->export_directory);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _free_resource(r_pe_resource *rs) {\n\tif (rs) {\n\t\tfree (rs->name);\n\t\tfree (rs->timestr);\n\t\tfree (rs->data);\n\t\tfree (rs->type);\n\t\tfree (rs->language);\n\t\tfree (rs);\n\t}\n}\n\nstatic int read_image_resource_directory(RBuffer *b, ut64 addr, Pe_image_resource_directory *dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tdir->Characteristics = r_buf_read_le32 (b);\n\tdir->TimeDateStamp = r_buf_read_le32 (b);\n\tdir->MajorVersion = r_buf_read_le16 (b);\n\tdir->MinorVersion = r_buf_read_le16 (b);\n\tdir->NumberOfNamedEntries = r_buf_read_le16 (b);\n\tdir->NumberOfIdEntries = r_buf_read_le16 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_directory);\n}\n\nstatic int bin_pe_init_resource(RBinPEObj* pe) {\n\tPE_(image_data_directory) * resource_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];\n\tPE_DWord resource_dir_paddr = PE_(va2pa) (pe, resource_dir->VirtualAddress);\n\tif (!resource_dir_paddr) {\n\t\treturn false;\n\t}\n\n\tpe->resources = r_list_newf ((RListFree)_free_resource);\n\tif (!pe->resources) {\n\t\treturn false;\n\t}\n\tif (!(pe->resource_directory = malloc (sizeof (*pe->resource_directory)))) {\n\t\tr_sys_perror (\"malloc (resource directory)\");\n\t\treturn false;\n\t}\n\tif (read_image_resource_directory (pe->b, resource_dir_paddr, pe->resource_directory) < 0) {\n\t\tpe_printf (\"Warning: read (resource directory)\\n\");\n\t\tR_FREE (pe->resource_directory);\n\t\treturn false;\n\t}\n\tpe->resource_directory_offset = resource_dir_paddr;\n\treturn true;\n}\n\nstatic void bin_pe_store_tls_callbacks(RBinPEObj* pe, PE_DWord callbacks) {\n\tr_strf_buffer (64);\n\tPE_DWord paddr, haddr;\n\tint count = 0;\n\tPE_DWord addressOfTLSCallback = 1;\n\tchar* key;\n\n\twhile (addressOfTLSCallback != 0) {\n\t\taddressOfTLSCallback = R_BUF_READ_PE_DWORD_AT (pe->b, callbacks);\n\t\tif (addressOfTLSCallback == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (tls_callback)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!addressOfTLSCallback) {\n\t\t\tbreak;\n\t\t}\n\t\tif (pe->optional_header->SizeOfImage) {\n\t\t\tint rva_callback = bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback);\n\t\t\tif (rva_callback > pe->optional_header->SizeOfImage) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkey = r_strf (\"pe.tls_callback%d_vaddr\", count);\n\t\tsdb_num_set (pe->kv, key, addressOfTLSCallback, 0);\n\t\tkey = r_strf (\"pe.tls_callback%d_paddr\", count);\n\t\tpaddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback));\n\t\tsdb_num_set (pe->kv, key, paddr, 0);\n\t\tkey = r_strf (\"pe.tls_callback%d_haddr\", count);\n\t\thaddr = callbacks;\n\t\tsdb_num_set (pe->kv, key, haddr, 0);\n\t\tcount++;\n\t\tcallbacks += sizeof (addressOfTLSCallback);\n\t}\n}\n\nstatic int read_tls_directory(RBuffer *b, ut64 addr, PE_(image_tls_directory) *tls_directory) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\ttls_directory->StartAddressOfRawData = r_buf_read_le32 (b);\n\ttls_directory->EndAddressOfRawData = r_buf_read_le32 (b);\n\ttls_directory->AddressOfIndex = r_buf_read_le32 (b);\n\ttls_directory->AddressOfCallBacks = r_buf_read_le32 (b);\n\ttls_directory->SizeOfZeroFill = r_buf_read_le32 (b);\n\ttls_directory->Characteristics = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_tls_directory));\n}\n\nstatic int bin_pe_init_tls(RBinPEObj* pe) {\n\tPE_(image_tls_directory) * image_tls_directory;\n\tPE_(image_data_directory) * data_dir_tls = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];\n\tPE_DWord tls_paddr = PE_(va2pa) (pe, data_dir_tls->VirtualAddress);\n\n\timage_tls_directory = R_NEW0 (PE_(image_tls_directory));\n\tif (read_tls_directory (pe->b, tls_paddr, image_tls_directory) < 0) {\n\t\tpe_printf (\"Warning: read (image_tls_directory)\\n\");\n\t\tfree (image_tls_directory);\n\t\treturn 0;\n\t}\n\tpe->tls_directory = image_tls_directory;\n\tif (!image_tls_directory->AddressOfCallBacks) {\n\t\treturn 0;\n\t}\n\tif (image_tls_directory->EndAddressOfRawData < image_tls_directory->StartAddressOfRawData) {\n\t\treturn 0;\n\t}\n\tPE_DWord callbacks_paddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe,\n\t\t\t(PE_DWord) image_tls_directory->AddressOfCallBacks));\n\tbin_pe_store_tls_callbacks (pe, callbacks_paddr);\n\treturn 0;\n}\n\nstatic void free_Var(Var* var) {\n\tif (var) {\n\t\tfree (var->szKey);\n\t\tfree (var->Value);\n\t\tfree (var);\n\t}\n}\n\nstatic void free_VarFileInfo(VarFileInfo* varFileInfo) {\n\tif (varFileInfo) {\n\t\tfree (varFileInfo->szKey);\n\t\tif (varFileInfo->Children) {\n\t\t\tut32 children = 0;\n\t\t\tfor (; children < varFileInfo->numOfChildren; children++) {\n\t\t\t\tfree_Var (varFileInfo->Children[children]);\n\t\t\t}\n\t\t\tfree (varFileInfo->Children);\n\t\t}\n\t\tfree (varFileInfo);\n\t}\n}\n\nstatic void free_String(String* string) {\n\tif (string) {\n\t\tfree (string->szKey);\n\t\tfree (string->Value);\n\t\tfree (string);\n\t}\n}\n\nstatic void free_StringTable(StringTable* stringTable) {\n\tif (stringTable) {\n\t\tfree (stringTable->szKey);\n\t\tif (stringTable->Children) {\n\t\t\tut32 childrenST = 0;\n\t\t\tfor (; childrenST < stringTable->numOfChildren; childrenST++) {\n\t\t\t\tfree_String (stringTable->Children[childrenST]);\n\t\t\t}\n\t\t\tfree (stringTable->Children);\n\t\t}\n\t\tfree (stringTable);\n\t}\n}\n\nstatic void free_StringFileInfo(StringFileInfo* stringFileInfo) {\n\tif (stringFileInfo) {\n\t\tfree (stringFileInfo->szKey);\n\t\tif (stringFileInfo->Children) {\n\t\t\tut32 childrenSFI = 0;\n\t\t\tfor (; childrenSFI < stringFileInfo->numOfChildren; childrenSFI++) {\n\t\t\t\tfree_StringTable (stringFileInfo->Children[childrenSFI]);\n\t\t\t}\n\t\t\tfree (stringFileInfo->Children);\n\t\t}\n\t\tfree (stringFileInfo);\n\t}\n}\n\n#define align32(x) x = (((x) & 0x3) == 0)? (x): ((x) & ~0x3) + 0x4;\n\nstatic void free_VS_VERSIONINFO(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (vs_VersionInfo) {\n\t\tfree (vs_VersionInfo->szKey);\n\t\tfree (vs_VersionInfo->Value);\n\t\tfree_VarFileInfo (vs_VersionInfo->varFileInfo);\n\t\tfree_StringFileInfo (vs_VersionInfo->stringFileInfo);\n\t\tfree (vs_VersionInfo);\n\t}\n}\n\nvoid PE_(free_VS_VERSIONINFO)(PE_VS_VERSIONINFO * vs_VersionInfo) {\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n}\n\nstatic Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {\n\tVar* var = calloc (1, sizeof (*var));\n\tif (!var) {\n\t\tpe_printf (\"Warning: calloc (Var)\\n\");\n\t\treturn NULL;\n\t}\n\tif ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wLength);\n\tif ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wValueLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wValueLength);\n\tif ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wType);\n\tif (var->wType != 0 && var->wType != 1) {\n\t\tpe_printf (\"Warning: check (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\tvar->numOfValues = var->wValueLength / 4;\n\tif (!var->numOfValues) {\n\t\tpe_printf (\"Warning: check (Var numOfValues)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tvar->Value = (ut32*) malloc (var->wValueLength);\n\tif (!var->Value) {\n\t\tpe_printf (\"Warning: malloc (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {\n\t\tpe_printf (\"Warning: read (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += var->wValueLength;\n\treturn var;\n}\n\nstatic VarFileInfo* Pe_r_bin_pe_parse_var_file_info(RBinPEObj* pe, PE_DWord* curAddr) {\n\tVarFileInfo* varFileInfo = calloc (1, sizeof (*varFileInfo));\n\tif (!varFileInfo) {\n\t\tpe_printf (\"Warning: calloc (VarFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = *curAddr;\n\tif ((varFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wLength);\n\n\tif ((varFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wValueLength);\n\n\tif (varFileInfo->wValueLength != 0) {\n\t\tpe_printf (\"Warning: check (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif ((varFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wType);\n\tif (varFileInfo->wType && varFileInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tvarFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (VARFILEINFO_UTF_16_LEN ));  //L\"VarFileInfo\"\n\tif (!varFileInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += VARFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\twhile (startAddr + varFileInfo->wLength > *curAddr) {\n\t\tVar** tmp = (Var**) realloc (varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof (*varFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (VarFileInfo Children)\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->Children = tmp;\n\t\tif (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing Var\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\treturn varFileInfo;\n}\n\nstatic String* Pe_r_bin_pe_parse_string(RBinPEObj* pe, PE_DWord* curAddr) {\n\tString* string = calloc (1, sizeof (*string));\n\tPE_DWord begAddr = *curAddr;\n\tint len_value = 0;\n\tint i = 0;\n\tif (!string) {\n\t\tpe_printf (\"Warning: calloc (String)\\n\");\n\t\treturn NULL;\n\t}\n\tif (begAddr > pe->size || begAddr + sizeof (string->wLength) > pe->size) {\n\t\tfree_String (string);\n\t\treturn NULL;\n\t}\n\tif ((string->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wLength);\n\tif (*curAddr > pe->size || *curAddr + sizeof (string->wValueLength) > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif ((string->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wValueLength);\n\n\tif (*curAddr > pe->size || *curAddr + sizeof (string->wType) > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif ((string->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wType);\n\tif (string->wType != 0 && string->wType != 1) {\n\t\tpe_printf (\"Warning: check (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tfor (i = 0; *curAddr < begAddr + string->wLength; i++, *curAddr += sizeof (ut16)) {\n\t\tut16 utf16_char;\n\t\tut16 *tmpKey;\n\t\tif (*curAddr > pe->size || *curAddr + sizeof (ut16) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\tpe_printf (\"Warning: check (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\ttmpKey = (ut16*) realloc (string->szKey, (i + 1) * sizeof (ut16));\n\t\tif (!tmpKey) {\n\t\t\tpe_printf (\"Warning: realloc (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tstring->szKey = tmpKey;\n\t\tstring->szKey[i] = utf16_char;\n\t\tstring->wKeyLen += sizeof (ut16);\n\t\tif (!utf16_char) {\n\t\t\t*curAddr += sizeof (ut16);\n\t\t\tbreak;\n\t\t}\n\t}\n\talign32 (*curAddr);\n\tlen_value = R_MIN (string->wValueLength * 2, string->wLength - (*curAddr - begAddr));\n\tstring->wValueLength = len_value;\n\tif (len_value < 0) {\n\t\tlen_value = 0;\n\t}\n\tstring->Value = (ut16*) calloc (len_value + 1, 1);\n\tif (!string->Value) {\n\t\tpe_printf (\"Warning: malloc (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\tif (*curAddr > pe->size || *curAddr + len_value > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {\n\t\tpe_printf (\"Warning: read (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += len_value;\n\treturn string;\nout_error:\n\tfree_String (string);\n\treturn NULL;\n}\n\nstatic StringTable* Pe_r_bin_pe_parse_string_table(RBinPEObj* pe, PE_DWord* curAddr) {\n\tStringTable* stringTable = calloc (1, sizeof (*stringTable));\n\tif (!stringTable) {\n\t\tpe_printf (\"Warning: calloc (stringTable)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\tif ((stringTable->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wLength);\n\n\tif ((stringTable->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wValueLength);\n\n\tif (stringTable->wValueLength) {\n\t\tpe_printf (\"Warning: check (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif ((stringTable->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wType);\n\tif (stringTable->wType && stringTable->wType != 1) {\n\t\tpe_printf (\"Warning: check (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\tstringTable->szKey = (ut16*) malloc (UT16_ALIGN (EIGHT_HEX_DIG_UTF_16_LEN));  //EIGHT_HEX_DIG_UTF_16_LEN\n\tif (!stringTable->szKey) {\n\t\tpe_printf (\"Warning: malloc (stringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (StringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += EIGHT_HEX_DIG_UTF_16_LEN;\n\talign32 (*curAddr);\n\twhile (startAddr + stringTable->wLength > *curAddr) {\n\t\tString** tmp = (String**) realloc (stringTable->Children, (stringTable->numOfChildren + 1) * sizeof (*stringTable->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (StringTable Children)\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->Children = tmp;\n\t\tif (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing String\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringTable->numOfChildren) {\n\t\tpe_printf (\"Warning: check (StringTable numOfChildren)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\treturn stringTable;\n}\n\nstatic StringFileInfo* Pe_r_bin_pe_parse_string_file_info(RBinPEObj* pe, PE_DWord* curAddr) {\n\tStringFileInfo* stringFileInfo = calloc (1, sizeof (*stringFileInfo));\n\tif (!stringFileInfo) {\n\t\tpe_printf (\"Warning: calloc (StringFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\n\tif ((stringFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wLength);\n\n\tif ((stringFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wValueLength);\n\n\tif (stringFileInfo->wValueLength) {\n\t\tpe_printf (\"Warning: check (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif ((stringFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wType);\n\n\tif (stringFileInfo->wType && stringFileInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tstringFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (STRINGFILEINFO_UTF_16_LEN));  //L\"StringFileInfo\"\n\tif (!stringFileInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += STRINGFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {\n\t\tpe_printf (\"Warning: check (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\talign32 (*curAddr);\n\n\twhile (startAddr + stringFileInfo->wLength > *curAddr) {\n\t\tStringTable** tmp = (StringTable**) realloc (stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof (*stringFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (StringFileInfo Children)\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->Children = tmp;\n\t\tif (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing StringTable\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringFileInfo->numOfChildren) {\n\t\tpe_printf (\"Warning: check (StringFileInfo numOfChildren)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\treturn stringFileInfo;\n}\n\n#define EXIT_ON_OVERFLOW(S)\\\n\tif (curAddr > pe->size || curAddr + (S) > pe->size) { \\\n\t\tgoto out_error; }\nstatic PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(RBinPEObj* pe, PE_DWord version_info_paddr) {\n\tut32 sz;\n\tPE_VS_VERSIONINFO* vs_VersionInfo = calloc (1, sizeof (PE_VS_VERSIONINFO));\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = version_info_paddr;\n\tPE_DWord curAddr = version_info_paddr;\n\t//align32(curAddr); // XXX: do we really need this? Because in msdn\n\t//wLength is The length, in bytes, of the VS_VERSIONINFO structure.\n\t//This length does not include any padding that aligns any subsequent\n\t//version resource data on a 32-bit boundary.\n\t//Mb we are in subsequent version resource data and not aligned.\n\tsz = sizeof (ut16);\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wValueLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wType = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tvs_VersionInfo->szKey = (ut16*) malloc (UT16_ALIGN (VS_VERSION_INFO_UTF_16_LEN));  //L\"VS_VERSION_INFO\"\n\tif (!vs_VersionInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tsz = VS_VERSION_INFO_UTF_16_LEN;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (memcmp (vs_VersionInfo->szKey, VS_VERSION_INFO_UTF_16, sz)) {\n\t\tgoto out_error;\n\t}\n\talign32 (curAddr);\n\tif (vs_VersionInfo->wValueLength) {\n\t\tif (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {\n\t\t\tpe_printf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tvs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO*) malloc (sizeof (*vs_VersionInfo->Value));\n\t\tif (!vs_VersionInfo->Value) {\n\t\t\tpe_printf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tsz = sizeof (PE_VS_FIXEDFILEINFO);\n\t\tEXIT_ON_OVERFLOW (sz);\n\t\tif (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {\n\t\t\tpe_printf (\"Warning: read (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {\n\t\t\tpe_printf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurAddr += sz;\n\t\talign32 (curAddr);\n\t}\n\n\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\tchar t = '\\0';\n\t\tif (curAddr + 3 * sizeof (ut16) > pe->size || curAddr + 3 + sizeof (ut64) + 1 > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, curAddr + 3 * sizeof (ut16), (ut8*) &t, 1) != 1) {\n\t\t\tpe_printf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (!(t == 'S' || t == 'V')) {\n\t\t\tpe_printf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (t == 'S') {\n\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t\tif (t == 'V') {\n\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\n\t\talign32 (curAddr);\n\n\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\tif (t == 'V') {\n\t\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {\n\t\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t} else if (t == 'S') {\n\t\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {\n\t\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\treturn vs_VersionInfo;\nout_error:\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\treturn NULL;\n\n}\n\nstatic Sdb* Pe_r_bin_store_var(Var* var) {\n\tunsigned int i = 0;\n\tchar key[20];\n\tSdb* sdb = NULL;\n\tif (var) {\n\t\tsdb = sdb_new0 ();\n\t\tif (sdb) {\n\t\t\tfor (; i < var->numOfValues; i++) {\n\t\t\t\tsnprintf (key, 20, \"%d\", i);\n\t\t\t\tsdb_num_set (sdb, key, var->Value[i], 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_var_file_info(VarFileInfo* varFileInfo) {\n\tchar key[20];\n\tunsigned int i = 0;\n\tif (!varFileInfo) {\n\t\treturn NULL;\n\t}\n\tSdb* sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < varFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"var%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_var (varFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string(String* string) {\n\tSdb* sdb = NULL;\n\tchar* encodedVal = NULL, * encodedKey = NULL;\n\tif (!string) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) string->szKey, string->wKeyLen);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tencodedVal = sdb_encode ((unsigned char*) string->Value, string->wValueLength);\n\tif (!encodedVal) {\n\t\tfree (encodedKey);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\",   encodedKey, 0);\n\tsdb_set (sdb, \"value\", encodedVal, 0);\n\tfree (encodedKey);\n\tfree (encodedVal);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_table(StringTable* stringTable) {\n\tchar key[20];\n\tchar* encodedKey = NULL;\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringTable) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\", encodedKey, 0);\n\tfree (encodedKey);\n\tfor (; i < stringTable->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"string%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string (stringTable->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_file_info(StringFileInfo* stringFileInfo) {\n\tchar key[30];\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < stringFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 30, \"stringtable%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string_table (stringFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_fixed_file_info(PE_VS_FIXEDFILEINFO* vs_fixedFileInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_fixedFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tsdb_num_set (sdb, \"Signature\",        vs_fixedFileInfo->dwSignature,        0);\n\tsdb_num_set (sdb, \"StrucVersion\",     vs_fixedFileInfo->dwStrucVersion,     0);\n\tsdb_num_set (sdb, \"FileVersionMS\",    vs_fixedFileInfo->dwFileVersionMS,    0);\n\tsdb_num_set (sdb, \"FileVersionLS\",    vs_fixedFileInfo->dwFileVersionLS,    0);\n\tsdb_num_set (sdb, \"ProductVersionMS\", vs_fixedFileInfo->dwProductVersionMS, 0);\n\tsdb_num_set (sdb, \"ProductVersionLS\", vs_fixedFileInfo->dwProductVersionLS, 0);\n\tsdb_num_set (sdb, \"FileFlagsMask\",    vs_fixedFileInfo->dwFileFlagsMask,    0);\n\tsdb_num_set (sdb, \"FileFlags\",        vs_fixedFileInfo->dwFileFlags,        0);\n\tsdb_num_set (sdb, \"FileOS\",           vs_fixedFileInfo->dwFileOS,           0);\n\tsdb_num_set (sdb, \"FileType\",         vs_fixedFileInfo->dwFileType,         0);\n\tsdb_num_set (sdb, \"FileSubtype\",      vs_fixedFileInfo->dwFileSubtype,      0);\n\tsdb_num_set (sdb, \"FileDateMS\",       vs_fixedFileInfo->dwFileDateMS,       0);\n\tsdb_num_set (sdb, \"FileDateLS\",       vs_fixedFileInfo->dwFileDateLS,       0);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_resource_version_info(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (vs_VersionInfo->Value) {\n\t\tsdb_ns_set (sdb, \"fixed_file_info\", Pe_r_bin_store_fixed_file_info (vs_VersionInfo->Value));\n\t}\n\tif (vs_VersionInfo->varFileInfo) {\n\t\tsdb_ns_set (sdb, \"var_file_info\", Pe_r_bin_store_var_file_info (vs_VersionInfo->varFileInfo));\n\t}\n\tif (vs_VersionInfo->stringFileInfo) {\n\t\tsdb_ns_set (sdb, \"string_file_info\", Pe_r_bin_store_string_file_info (vs_VersionInfo->stringFileInfo));\n\t}\n\treturn sdb;\n}\n\nstatic char* _known_product_ids(int id) {\n\tswitch (id) {\n\tcase 0: return  \"Unknown\";\n\tcase 1: return  \"Import0\";\n\tcase 2: return  \"Linker510\";\n\tcase 3: return  \"Cvtomf510\";\n\tcase 4: return  \"Linker600\";\n\tcase 5: return  \"Cvtomf600\";\n\tcase 6: return  \"Cvtres500\";\n\tcase 7: return  \"Utc11_Basic\";\n\tcase 8: return  \"Utc11_C\";\n\tcase 9: return  \"Utc12_Basic\";\n\tcase 10: return  \"Utc12_C\";\n\tcase 11: return  \"Utc12_CPP\";\n\tcase 12: return  \"AliasObj60\";\n\tcase 13: return  \"VisualBasic60\";\n\tcase 14: return  \"Masm613\";\n\tcase 15: return  \"Masm710\";\n\tcase 16: return  \"Linker511\";\n\tcase 17: return  \"Cvtomf511\";\n\tcase 18: return  \"Masm614\";\n\tcase 19: return  \"Linker512\";\n\tcase 20: return  \"Cvtomf512\";\n\tcase 21: return  \"Utc12_C_Std\";\n\tcase 22: return  \"Utc12_CPP_Std\";\n\tcase 23: return  \"Utc12_C_Book\";\n\tcase 24: return  \"Utc12_CPP_Book\";\n\tcase 25: return  \"Implib700\";\n\tcase 26: return  \"Cvtomf700\";\n\tcase 27: return  \"Utc13_Basic\";\n\tcase 28: return  \"Utc13_C\";\n\tcase 29: return  \"Utc13_CPP\";\n\tcase 30: return  \"Linker610\";\n\tcase 31: return  \"Cvtomf610\";\n\tcase 32: return  \"Linker601\";\n\tcase 33: return  \"Cvtomf601\";\n\tcase 34: return  \"Utc12_1_Basic\";\n\tcase 35: return  \"Utc12_1_C\";\n\tcase 36: return  \"Utc12_1_CPP\";\n\tcase 37: return  \"Linker620\";\n\tcase 38: return  \"Cvtomf620\";\n\tcase 39: return  \"AliasObj70\";\n\tcase 40: return  \"Linker621\";\n\tcase 41: return  \"Cvtomf621\";\n\tcase 42: return  \"Masm615\";\n\tcase 43: return  \"Utc13_LTCG_C\";\n\tcase 44: return  \"Utc13_LTCG_CPP\";\n\tcase 45: return  \"Masm620\";\n\tcase 46: return  \"ILAsm100\";\n\tcase 47: return  \"Utc12_2_Basic\";\n\tcase 48: return  \"Utc12_2_C\";\n\tcase 49: return  \"Utc12_2_CPP\";\n\tcase 50: return  \"Utc12_2_C_Std\";\n\tcase 51: return  \"Utc12_2_CPP_Std\";\n\tcase 52: return  \"Utc12_2_C_Book\";\n\tcase 53: return  \"Utc12_2_CPP_Book\";\n\tcase 54: return  \"Implib622\";\n\tcase 55: return  \"Cvtomf622\";\n\tcase 56: return  \"Cvtres501\";\n\tcase 57: return  \"Utc13_C_Std\";\n\tcase 58: return  \"Utc13_CPP_Std\";\n\tcase 59: return  \"Cvtpgd1300\";\n\tcase 60: return  \"Linker622\";\n\tcase 61: return  \"Linker700\";\n\tcase 62: return  \"Export622\";\n\tcase 63: return  \"Export700\";\n\tcase 64: return  \"Masm700\";\n\tcase 65: return  \"Utc13_POGO_I_C\";\n\tcase 66: return  \"Utc13_POGO_I_CPP\";\n\tcase 67: return  \"Utc13_POGO_O_C\";\n\tcase 68: return  \"Utc13_POGO_O_CPP\";\n\tcase 69: return  \"Cvtres700\";\n\tcase 70: return  \"Cvtres710p\";\n\tcase 71: return  \"Linker710p\";\n\tcase 72: return  \"Cvtomf710p\";\n\tcase 73: return  \"Export710p\";\n\tcase 74: return  \"Implib710p\";\n\tcase 75: return  \"Masm710p\";\n\tcase 76: return  \"Utc1310p_C\";\n\tcase 77: return  \"Utc1310p_CPP\";\n\tcase 78: return  \"Utc1310p_C_Std\";\n\tcase 79: return  \"Utc1310p_CPP_Std\";\n\tcase 80: return  \"Utc1310p_LTCG_C\";\n\tcase 81: return  \"Utc1310p_LTCG_CPP\";\n\tcase 82: return  \"Utc1310p_POGO_I_C\";\n\tcase 83: return  \"Utc1310p_POGO_I_CPP\";\n\tcase 84: return  \"Utc1310p_POGO_O_C\";\n\tcase 85: return  \"Utc1310p_POGO_O_CPP\";\n\tcase 86: return  \"Linker624\";\n\tcase 87: return  \"Cvtomf624\";\n\tcase 88: return  \"Export624\";\n\tcase 89: return  \"Implib624\";\n\tcase 90: return  \"Linker710\";\n\tcase 91: return  \"Cvtomf710\";\n\tcase 92: return  \"Export710\";\n\tcase 93: return  \"Implib710\";\n\tcase 94: return  \"Cvtres710\";\n\tcase 95: return  \"Utc1310_C\";\n\tcase 96: return  \"Utc1310_CPP\";\n\tcase 97: return  \"Utc1310_C_Std\";\n\tcase 98: return  \"Utc1310_CPP_Std\";\n\tcase 99: return  \"Utc1310_LTCG_C\";\n\tcase 100: return  \"Utc1310_LTCG_CPP\";\n\tcase 101: return  \"Utc1310_POGO_I_C\";\n\tcase 102: return  \"Utc1310_POGO_I_CPP\";\n\tcase 103: return  \"Utc1310_POGO_O_C\";\n\tcase 104: return  \"Utc1310_POGO_O_CPP\";\n\tcase 105: return  \"AliasObj710\";\n\tcase 106: return  \"AliasObj710p\";\n\tcase 107: return  \"Cvtpgd1310\";\n\tcase 108: return  \"Cvtpgd1310p\";\n\tcase 109: return  \"Utc1400_C\";\n\tcase 110: return  \"Utc1400_CPP\";\n\tcase 111: return  \"Utc1400_C_Std\";\n\tcase 112: return  \"Utc1400_CPP_Std\";\n\tcase 113: return  \"Utc1400_LTCG_C\";\n\tcase 114: return  \"Utc1400_LTCG_CPP\";\n\tcase 115: return  \"Utc1400_POGO_I_C\";\n\tcase 116: return  \"Utc1400_POGO_I_CPP\";\n\tcase 117: return  \"Utc1400_POGO_O_C\";\n\tcase 118: return  \"Utc1400_POGO_O_CPP\";\n\tcase 119: return  \"Cvtpgd1400\";\n\tcase 120: return  \"Linker800\";\n\tcase 121: return  \"Cvtomf800\";\n\tcase 122: return  \"Export800\";\n\tcase 123: return  \"Implib800\";\n\tcase 124: return  \"Cvtres800\";\n\tcase 125: return  \"Masm800\";\n\tcase 126: return  \"AliasObj800\";\n\tcase 127: return  \"PhoenixPrerelease\";\n\tcase 128: return  \"Utc1400_CVTCIL_C\";\n\tcase 129: return  \"Utc1400_CVTCIL_CPP\";\n\tcase 130: return  \"Utc1400_LTCG_MSIL\";\n\tcase 131: return  \"Utc1500_C\";\n\tcase 132: return  \"Utc1500_CPP\";\n\tcase 133: return  \"Utc1500_C_Std\";\n\tcase 134: return  \"Utc1500_CPP_Std\";\n\tcase 135: return  \"Utc1500_CVTCIL_C\";\n\tcase 136: return  \"Utc1500_CVTCIL_CPP\";\n\tcase 137: return  \"Utc1500_LTCG_C\";\n\tcase 138: return  \"Utc1500_LTCG_CPP\";\n\tcase 139: return  \"Utc1500_LTCG_MSIL\";\n\tcase 140: return  \"Utc1500_POGO_I_C\";\n\tcase 141: return  \"Utc1500_POGO_I_CPP\";\n\tcase 142: return  \"Utc1500_POGO_O_C\";\n\tcase 143: return  \"Utc1500_POGO_O_CPP\";\n\n\tcase 144: return  \"Cvtpgd1500\";\n\tcase 145: return  \"Linker900\";\n\tcase 146: return  \"Export900\";\n\tcase 147: return  \"Implib900\";\n\tcase 148: return  \"Cvtres900\";\n\tcase 149: return  \"Masm900\";\n\tcase 150: return  \"AliasObj900\";\n\tcase 151: return  \"Resource900\";\n\n\tcase 152: return  \"AliasObj1000\";\n\tcase 154: return  \"Cvtres1000\";\n\tcase 155: return  \"Export1000\";\n\tcase 156: return  \"Implib1000\";\n\tcase 157: return  \"Linker1000\";\n\tcase 158: return  \"Masm1000\";\n\n\tcase 170: return  \"Utc1600_C\";\n\tcase 171: return  \"Utc1600_CPP\";\n\tcase 172: return  \"Utc1600_CVTCIL_C\";\n\tcase 173: return  \"Utc1600_CVTCIL_CPP\";\n\tcase 174: return  \"Utc1600_LTCG_C \";\n\tcase 175: return  \"Utc1600_LTCG_CPP\";\n\tcase 176: return  \"Utc1600_LTCG_MSIL\";\n\tcase 177: return  \"Utc1600_POGO_I_C\";\n\tcase 178: return  \"Utc1600_POGO_I_CPP\";\n\tcase 179: return  \"Utc1600_POGO_O_C\";\n\tcase 180: return  \"Utc1600_POGO_O_CPP\";\n\n\tcase 183: return  \"Linker1010\";\n\tcase 184: return  \"Export1010\";\n\tcase 185: return  \"Implib1010\";\n\tcase 186: return  \"Cvtres1010\";\n\tcase 187: return  \"Masm1010\";\n\tcase 188: return  \"AliasObj1010\";\n\n\tcase 199: return  \"AliasObj1100\";\n\tcase 201: return  \"Cvtres1100\";\n\tcase 202: return  \"Export1100\";\n\tcase 203: return  \"Implib1100\";\n\tcase 204: return  \"Linker1100\";\n\tcase 205: return  \"Masm1100\";\n\n\tcase 206: return  \"Utc1700_C\";\n\tcase 207: return  \"Utc1700_CPP\";\n\tcase 208: return  \"Utc1700_CVTCIL_C\";\n\tcase 209: return  \"Utc1700_CVTCIL_CPP\";\n\tcase 210: return  \"Utc1700_LTCG_C \";\n\tcase 211: return  \"Utc1700_LTCG_CPP\";\n\tcase 212: return  \"Utc1700_LTCG_MSIL\";\n\tcase 213: return  \"Utc1700_POGO_I_C\";\n\tcase 214: return  \"Utc1700_POGO_I_CPP\";\n\tcase 215: return  \"Utc1700_POGO_O_C\";\n\tcase 216: return  \"Utc1700_POGO_O_CPP\";\n\n\tcase 219: return  \"Cvtres1200\";\n\tcase 220: return  \"Export1200\";\n\tcase 221: return  \"Implib1200\";\n\tcase 222: return  \"Linker1200\";\n\tcase 223: return  \"Masm1200\";\n\t\t// Speculation\n\tcase 224: return  \"AliasObj1200\";\n\n\tcase 237: return  \"Cvtres1210\";\n\tcase 238: return  \"Export1210\";\n\tcase 239: return  \"Implib1210\";\n\tcase 240: return  \"Linker1210\";\n\tcase 241: return  \"Masm1210\";\n\t\t// Speculation\n\tcase 242: return  \"Utc1810_C\";\n\tcase 243: return  \"Utc1810_CPP\";\n\tcase 244: return  \"Utc1810_CVTCIL_C\";\n\tcase 245: return  \"Utc1810_CVTCIL_CPP\";\n\tcase 246: return  \"Utc1810_LTCG_C \";\n\tcase 247: return  \"Utc1810_LTCG_CPP\";\n\tcase 248: return  \"Utc1810_LTCG_MSIL\";\n\tcase 249: return  \"Utc1810_POGO_I_C\";\n\tcase 250: return  \"Utc1810_POGO_I_CPP\";\n\tcase 251: return  \"Utc1810_POGO_O_C\";\n\tcase 252: return  \"Utc1810_POGO_O_CPP\";\n\n\tcase 255: return  \"Cvtres1400\";\n\tcase 256: return  \"Export1400\";\n\tcase 257: return  \"Implib1400\";\n\tcase 258: return  \"Linker1400\";\n\tcase 259: return  \"Masm1400\";\n\n\tcase 260: return  \"Utc1900_C\";\n\tcase 261: return  \"Utc1900_CPP\";\n\t\t// Speculation\n\tcase 262: return  \"Utc1900_CVTCIL_C\";\n\tcase 263: return  \"Utc1900_CVTCIL_CPP\";\n\tcase 264: return  \"Utc1900_LTCG_C \";\n\tcase 265: return  \"Utc1900_LTCG_CPP\";\n\tcase 266: return  \"Utc1900_LTCG_MSIL\";\n\tcase 267: return  \"Utc1900_POGO_I_C\";\n\tcase 268: return  \"Utc1900_POGO_I_CPP\";\n\tcase 269: return  \"Utc1900_POGO_O_C\";\n\tcase 270: return  \"Utc1900_POGO_O_CPP\";\n\tdefault: return \"Unknown\";\n\t}\n}\n\nstatic void bin_pe_init_rich_info(RBinPEObj *pe) {\n\tif (!pe->rich_entries) {\n\t\tpe->rich_entries = r_list_newf (free);\n\t}\n\tpe->rich_header_offset = pe->nt_header_offset;\n\tut64 off = pe->nt_header_offset - sizeof (ut32);\n\tut32 magic = 0x68636952; // Rich\n\tif (off % sizeof (ut32)) {\n\t\treturn;\n\t}\n\twhile ((r_buf_read_le32_at (pe->b, off) != magic) && off) {\n\t\toff -= sizeof (ut32);\n\t}\n\tif (!off) {\n\t\treturn;\n\t}\n\tut32 mask = r_buf_read_le32_at (pe->b, off + sizeof (ut32));\n\tmagic = 0x536E6144; // DanS\n\tint data;\n\toff -= sizeof (ut32);\n\twhile (((data = r_buf_read_le32_at (pe->b, off)) != magic) && data ^ mask && off > 0x80) {\n\t\tPe_image_rich_entry *entry = R_NEW0 (Pe_image_rich_entry);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\t\tentry->timesUsed = data ^ mask;\n\t\toff -= sizeof (ut32);\n\t\tdata = r_buf_read_le32_at (pe->b, off) ^ mask;\n\t\tentry->productId = data >> 16;\n\t\tentry->minVersion = data & 0xFFFF;\n\t\tentry->productName = _known_product_ids (entry->productId);\n\t\toff -= sizeof (ut32);\n\t\tr_list_append (pe->rich_entries, entry);\n\t}\n\tpe->rich_header_offset = off + sizeof (ut32);\n}\n\nstatic char* _resource_lang_str(int id) {\n\tswitch (id) {\n\tcase 0x00: return \"LANG_NEUTRAL\";\n\tcase 0x7f: return \"LANG_INVARIANT\";\n\tcase 0x36: return \"LANG_AFRIKAANS\";\n\tcase 0x1c: return \"LANG_ALBANIAN \";\n\tcase 0x01: return \"LANG_ARABIC\";\n\tcase 0x2b: return \"LANG_ARMENIAN\";\n\tcase 0x4d: return \"LANG_ASSAMESE\";\n\tcase 0x2c: return \"LANG_AZERI\";\n\tcase 0x2d: return \"LANG_BASQUE\";\n\tcase 0x23: return \"LANG_BELARUSIAN\";\n\tcase 0x45: return \"LANG_BENGALI\";\n\tcase 0x02: return \"LANG_BULGARIAN\";\n\tcase 0x03: return \"LANG_CATALAN\";\n\tcase 0x04: return \"LANG_CHINESE\";\n\tcase 0x1a: return \"LANG_CROATIAN\";\n\tcase 0x05: return \"LANG_CZECH\";\n\tcase 0x06: return \"LANG_DANISH\";\n\tcase 0x65: return \"LANG_DIVEHI\";\n\tcase 0x13: return \"LANG_DUTCH\";\n\tcase 0x09: return \"LANG_ENGLISH\";\n\tcase 0x25: return \"LANG_ESTONIAN\";\n\tcase 0x38: return \"LANG_FAEROESE\";\n\tcase 0x29: return \"LANG_FARSI\";\n\tcase 0x0b: return \"LANG_FINNISH\";\n\tcase 0x0c: return \"LANG_FRENCH\";\n\tcase 0x56: return \"LANG_GALICIAN\";\n\tcase 0x37: return \"LANG_GEORGIAN\";\n\tcase 0x07: return \"LANG_GERMAN\";\n\tcase 0x08: return \"LANG_GREEK\";\n\tcase 0x47: return \"LANG_GUJARATI\";\n\tcase 0x0d: return \"LANG_HEBREW\";\n\tcase 0x39: return \"LANG_HINDI\";\n\tcase 0x0e: return \"LANG_HUNGARIAN\";\n\tcase 0x0f: return \"LANG_ICELANDIC\";\n\tcase 0x21: return \"LANG_INDONESIAN\";\n\tcase 0x10: return \"LANG_ITALIAN\";\n\tcase 0x11: return \"LANG_JAPANESE\";\n\tcase 0x4b: return \"LANG_KANNADA\";\n\tcase 0x60: return \"LANG_KASHMIRI\";\n\tcase 0x3f: return \"LANG_KAZAK\";\n\tcase 0x57: return \"LANG_KONKANI\";\n\tcase 0x12: return \"LANG_KOREAN\";\n\tcase 0x40: return \"LANG_KYRGYZ\";\n\tcase 0x26: return \"LANG_LATVIAN\";\n\tcase 0x27: return \"LANG_LITHUANIAN\";\n\tcase 0x2f: return \"LANG_MACEDONIAN\";\n\tcase 0x3e: return \"LANG_MALAY\";\n\tcase 0x4c: return \"LANG_MALAYALAM\";\n\tcase 0x58: return \"LANG_MANIPURI\";\n\tcase 0x4e: return \"LANG_MARATHI\";\n\tcase 0x50: return \"LANG_MONGOLIAN\";\n\tcase 0x61: return \"LANG_NEPALI\";\n\tcase 0x14: return \"LANG_NORWEGIAN\";\n\tcase 0x48: return \"LANG_ORIYA\";\n\tcase 0x15: return \"LANG_POLISH\";\n\tcase 0x16: return \"LANG_PORTUGUESE\";\n\tcase 0x46: return \"LANG_PUNJABI\";\n\tcase 0x18: return \"LANG_ROMANIAN\";\n\tcase 0x19: return \"LANG_RUSSIAN\";\n\tcase 0x4f: return \"LANG_SANSKRIT\";\n\tcase 0x59: return \"LANG_SINDHI\";\n\tcase 0x1b: return \"LANG_SLOVAK\";\n\tcase 0x24: return \"LANG_SLOVENIAN\";\n\tcase 0x0a: return \"LANG_SPANISH \";\n\tcase 0x41: return \"LANG_SWAHILI\";\n\tcase 0x1d: return \"LANG_SWEDISH\";\n\tcase 0x5a: return \"LANG_SYRIAC\";\n\tcase 0x49: return \"LANG_TAMIL\";\n\tcase 0x44: return \"LANG_TATAR\";\n\tcase 0x4a: return \"LANG_TELUGU\";\n\tcase 0x1e: return \"LANG_THAI\";\n\tcase 0x1f: return \"LANG_TURKISH\";\n\tcase 0x22: return \"LANG_UKRAINIAN\";\n\tcase 0x20: return \"LANG_URDU\";\n\tcase 0x43: return \"LANG_UZBEK\";\n\tcase 0x2a: return \"LANG_VIETNAMESE\";\n\tcase 0x3c: return \"LANG_GAELIC\";\n\tcase 0x3a: return \"LANG_MALTESE\";\n\tcase 0x28: return \"LANG_MAORI\";\n\tcase 0x17: return \"LANG_RHAETO_ROMANCE\";\n\tcase 0x3b: return \"LANG_SAAMI\";\n\tcase 0x2e: return \"LANG_SORBIAN\";\n\tcase 0x30: return \"LANG_SUTU\";\n\tcase 0x31: return \"LANG_TSONGA\";\n\tcase 0x32: return \"LANG_TSWANA\";\n\tcase 0x33: return \"LANG_VENDA\";\n\tcase 0x34: return \"LANG_XHOSA\";\n\tcase 0x35: return \"LANG_ZULU\";\n\tcase 0x8f: return \"LANG_ESPERANTO\";\n\tcase 0x90: return \"LANG_WALON\";\n\tcase 0x91: return \"LANG_CORNISH\";\n\tcase 0x92: return \"LANG_WELSH\";\n\tcase 0x93: return \"LANG_BRETON\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic char* _resource_type_str(int type) {\n\tconst char * typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \"CURSOR\";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \"BITMAP\";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \"ICON\";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \"MENU\";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \"DIALOG\";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \"STRING\";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \"FONTDIR\";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \"FONT\";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \"ACCELERATOR\";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \"RCDATA\";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \"MESSAGETABLE\";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \"GROUP_CURSOR\";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \"GROUP_ICON\";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \"VERSION\";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \"DLGINCLUDE\";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \"PLUGPLAY\";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \"VXD\";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \"ANICURSOR\";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \"ANIICON\";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \"HTML\";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \"MANIFEST\";\n\t\tbreak;\n\tdefault: return r_str_newf (\"UNKNOWN (%d)\",type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic int read_image_resource_directory_entry(RBuffer *b, ut64 addr, Pe_image_resource_directory_entry *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tentry->u1.Name = r_buf_read_le32 (b);\n\tentry->u2.OffsetToData = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_directory_entry);\n}\n\nstatic int read_image_resource_data_entry(RBuffer *b, ut64 addr, Pe_image_resource_data_entry *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (Pe_image_resource_data_entry)];\n\tr_buf_read (b, buf, sizeof (Pe_image_resource_data_entry));\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, OffsetToData, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, Size, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, CodePage, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, Reserved, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_data_entry);\n}\n\nstatic void _parse_resource_directory(RBinPEObj *pe, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, HtUU *dirs, const char *resource_name) {\n\tchar *resourceEntryName = NULL;\n\tint index = 0;\n\tut32 totalRes = dir->NumberOfNamedEntries + dir->NumberOfIdEntries;\n\tut64 rsrc_base = pe->resource_directory_offset;\n\tut64 off;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry entry;\n\t\toff = rsrc_base + offDir + sizeof (*dir) + index * sizeof (entry);\n\t\tif (ht_uu_find (dirs, off, NULL)) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_insert (dirs, off, 1);\n\t\tif (off > pe->size || off + sizeof (entry) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_directory_entry (pe->b, off, &entry) < 0) {\n\t\t\teprintf (\"Warning: read resource entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (entry.u1.Name >> 31) {\n\t\t\tint i;\n\t\t\tut16 buf;\n\t\t\tut32 NameOffset = entry.u1.Name & 0x7fffffff;\n\t\t\tif (r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset, (ut8*)&buf, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut16 resourceEntryNameLength = r_read_le16 (&buf);\n\t\t\tresourceEntryName = calloc (resourceEntryNameLength + 1, 1);\n\t\t\tif (resourceEntryName) {\n\t\t\t\tfor (i = 0; i < resourceEntryNameLength; i++) { /* Convert Unicode to ASCII */\n\t\t\t\t\tut8 byte;\n\t\t\t\t\tint r = r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset + 2 + (i*2), &byte, sizeof (ut8));\n\t\t\t\t\tif (r != sizeof (ut8) || !byte) {\n\t\t\t\t\t\tR_FREE (resourceEntryName);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresourceEntryName[i] = byte;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry.u2.OffsetToData >> 31) {\n\t\t\t//detect here malicious file trying to making us infinite loop\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\tut32 OffsetToDirectory = entry.u2.OffsetToData & 0x7fffffff;\n\t\t\toff = rsrc_base + OffsetToDirectory;\n\t\t\tint len = read_image_resource_directory (pe->b, off, &identEntry);\n\t\t\tif (len < 1 || len != sizeof (Pe_image_resource_directory)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (pe, &identEntry, OffsetToDirectory, type, entry.u1.Name & 0xffff, dirs, resourceEntryName);\n\t\t\tR_FREE (resourceEntryName);\n\t\t\tcontinue;\n\t\t}\n\t\tR_FREE (resourceEntryName);\n\n\t\tPe_image_resource_data_entry *data = R_NEW0 (Pe_image_resource_data_entry);\n\t\tif (!data) {\n\t\t\tbreak;\n\t\t}\n\t\toff = rsrc_base + entry.u2.OffsetToData;\n\t\tif (off > pe->size || off + sizeof (*data) > pe->size) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_data_entry (pe->b, off, data) != sizeof (*data)) {\n\t\t\teprintf (\"Warning: read (resource data entry)\\n\");\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (type == PE_RESOURCE_ENTRY_VERSION) {\n\t\t\tchar key[64];\n\t\t\tint counter = 0;\n\t\t\tSdb *sdb = sdb_new0 ();\n\t\t\tif (!sdb) {\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord data_paddr = PE_(va2pa) (pe, data->OffsetToData);\n\t\t\tif (!data_paddr) {\n\t\t\t\tpe_printf (\"Warning: bad RVA in resource data entry\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord cur_paddr = data_paddr;\n\t\t\tif ((cur_paddr & 0x3) != 0) {\n\t\t\t\tpe_printf (\"Warning: not aligned version info address\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (cur_paddr < (data_paddr + data->Size) && cur_paddr < pe->size) {\n\t\t\t\tPE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (pe, cur_paddr);\n\t\t\t\tif (!vs_VersionInfo) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnprintf (key, 30, \"VS_VERSIONINFO%d\", counter++);\n\t\t\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_resource_version_info (vs_VersionInfo));\n\t\t\t\tif (vs_VersionInfo->wLength < 1) {\n\t\t\t\t\t// Invalid version length\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_paddr += vs_VersionInfo->wLength;\n\t\t\t\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\t\t\t\talign32 (cur_paddr);\n\t\t\t}\n\t\t\tsdb_ns_set (pe->kv, \"vs_version_info\", sdb);\n\t\t}\n\t\tr_pe_resource *rs = R_NEW0 (r_pe_resource);\n\t\tif (!rs) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\t/* Compare compileTimeStamp to resource timestamp to figure out if DOS date or POSIX date */\n\t\tif (r_time_stamp_is_dos_format ((ut32) sdb_num_get (pe->kv, \"image_file_header.TimeDateStamp\", 0), dir->TimeDateStamp)) {\n\t\t\trs->timestr = r_time_stamp_to_str ( r_time_dos_time_stamp_to_posix (dir->TimeDateStamp));\n\t\t} else {\n\t\t\trs->timestr = r_time_stamp_to_str (dir->TimeDateStamp);\n\t\t}\n\t\trs->type = _resource_type_str (type);\n\t\trs->language = strdup (_resource_lang_str (entry.u1.Name & 0x3ff));\n\t\trs->data = data;\n\t\tif (resource_name) {\n\t\t\trs->name = strdup (resource_name);\n\t\t} else {\n\t\t\trs->name = r_str_newf (\"%d\", id);\n\t\t}\n\t\tr_list_append (pe->resources, rs);\n\t}\n}\n\nstatic void _store_resource_sdb(RBinPEObj *pe) {\n\tr_strf_buffer (64);\n\tRListIter *iter;\n\tr_pe_resource *rs;\n\tint index = 0;\n\tut64 vaddr = 0;\n\tchar *key;\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn;\n\t}\n\tr_list_foreach (pe->resources, iter, rs) {\n\t\tkey = r_strf (\"resource.%d.timestr\", index);\n\t\tsdb_set (sdb, key, rs->timestr, 0);\n\t\tkey = r_strf (\"resource.%d.vaddr\", index);\n\t\tvaddr = bin_pe_rva_to_va (pe, rs->data->OffsetToData);\n\t\tsdb_num_set (sdb, key, vaddr, 0);\n\t\tkey = r_strf (\"resource.%d.name\", index);\n\t\tsdb_set (sdb, key, rs->name, 0);\n\t\tkey = r_strf (\"resource.%d.size\", index);\n\t\tsdb_num_set (sdb, key, rs->data->Size, 0);\n\t\tkey = r_strf (\"resource.%d.type\", index);\n\t\tsdb_set (sdb, key, rs->type, 0);\n\t\tkey = r_strf (\"resource.%d.language\", index);\n\t\tsdb_set (sdb, key, rs->language, 0);\n\t\tindex++;\n\t}\n\tsdb_ns_set (pe->kv, \"pe_resource\", sdb);\n}\n\n\nR_API void PE_(bin_pe_parse_resource)(RBinPEObj *pe) {\n\tint index = 0;\n\tut64 off = 0, rsrc_base = pe->resource_directory_offset;\n\tPe_image_resource_directory *rs_directory = pe->resource_directory;\n\tut32 curRes = 0;\n\tint totalRes = 0;\n\tHtUUOptions opt = { 0 };\n\tHtUU *dirs = ht_uu_new_opt (&opt); //to avoid infinite loops\n\tif (!dirs) {\n\t\treturn;\n\t}\n\tif (!rs_directory) {\n\t\tht_uu_free (dirs);\n\t\treturn;\n\t}\n\tcurRes = rs_directory->NumberOfNamedEntries;\n\ttotalRes = curRes + rs_directory->NumberOfIdEntries;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\teprintf (\"Error parsing resource directory\\n\");\n\t\tht_uu_free (dirs);\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry typeEntry;\n\t\toff = rsrc_base + sizeof (*rs_directory) + index * sizeof (typeEntry);\n\t\tht_uu_insert (dirs, off, 1);\n\t\tif (off > pe->size || off + sizeof (typeEntry) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_directory_entry (pe->b, off, &typeEntry) < 0) {\n\t\t\teprintf (\"Warning: read resource directory entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (typeEntry.u2.OffsetToData >> 31) {\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\tut32 OffsetToDirectory = typeEntry.u2.OffsetToData & 0x7fffffff;\n\t\t\toff = rsrc_base + OffsetToDirectory;\n\t\t\tint len = read_image_resource_directory (pe->b, off, &identEntry);\n\t\t\tif (len != sizeof (identEntry)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t(void)_parse_resource_directory (pe, &identEntry, OffsetToDirectory, typeEntry.u1.Name & 0xffff, 0, dirs, NULL);\n\t\t}\n\t}\n\tht_uu_free (dirs);\n\t_store_resource_sdb (pe);\n}\n\nstatic int bin_pe_init_security(RBinPEObj *pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\tif (pe->nt_headers->optional_header.NumberOfRvaAndSizes < 5) {\n\t\treturn false;\n\t}\n\tPE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];\n\tPE_DWord paddr = data_dir_security->VirtualAddress;\n\tut32 size = data_dir_security->Size;\n\tif (size < 8 || paddr > pe->size || paddr + size > pe->size) {\n\t\tpe_printf (\"Invalid certificate table\");\n\t\treturn false;\n\t}\n\n\tPe_image_security_directory *security_directory = R_NEW0 (Pe_image_security_directory);\n\tif (!security_directory) {\n\t\treturn false;\n\t}\n\tpe->security_directory = security_directory;\n\n\tPE_DWord offset = paddr;\n\twhile (offset < paddr + size) {\n\t\tPe_certificate **tmp = (Pe_certificate **)realloc (security_directory->certificates, (security_directory->length + 1) * sizeof (Pe_certificate *));\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\t\tsecurity_directory->certificates = tmp;\n\t\tPe_certificate *cert = R_NEW0 (Pe_certificate);\n\t\tif (!cert) {\n\t\t\treturn false;\n\t\t}\n\t\tcert->dwLength = r_buf_read_le32_at (pe->b, offset);\n\t\tcert->dwLength += (8 - (cert->dwLength & 7)) & 7; // align32\n\t\tif (offset + cert->dwLength > paddr + size) {\n\t\t\tpe_printf (\"Invalid certificate entry\");\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tcert->wRevision = r_buf_read_le16_at (pe->b, offset + 4);\n\t\tcert->wCertificateType = r_buf_read_le16_at (pe->b, offset + 6);\n\t\tif (cert->dwLength < 6) {\n\t\t\teprintf (\"Cert.dwLength must be > 6\\n\");\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(cert->bCertificate = malloc (cert->dwLength - 6))) {\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tr_buf_read_at (pe->b, offset + 8, cert->bCertificate, cert->dwLength - 6);\n\n\t\tif (!pe->cms && cert->wCertificateType == PE_WIN_CERT_TYPE_PKCS_SIGNED_DATA) {\n\t\t\tpe->cms = r_pkcs7_parse_cms (cert->bCertificate, cert->dwLength - 6);\n\t\t\tif (pe->cms) {\n\t\t\t\tpe->spcinfo = r_pkcs7_parse_spcinfo (pe->cms);\n\t\t\t}\n\t\t}\n\n\t\tsecurity_directory->certificates[security_directory->length] = cert;\n\t\tsecurity_directory->length++;\n\t\toffset += cert->dwLength;\n\t}\n\n\tif (pe->cms && pe->spcinfo) {\n\t\tconst char *actual_authentihash = PE_(bin_pe_compute_authentihash) (pe);\n\t\tconst char *claimed_authentihash = PE_(bin_pe_get_claimed_authentihash) (pe);\n\t\tif (actual_authentihash && claimed_authentihash) {\n\t\t\tpe->is_authhash_valid = !strcmp (actual_authentihash, claimed_authentihash);\n\t\t} else {\n\t\t\tpe->is_authhash_valid = false;\n\t\t}\n\t\tif (actual_authentihash) {\n\t\t\tfree ((void *)actual_authentihash);\n\t\t}\n\t\tfree ((void *)claimed_authentihash);\n\t}\n\tpe->is_signed = pe->cms != NULL;\n\treturn true;\n}\n\nstatic void free_security_directory(Pe_image_security_directory *security_directory) {\n\tif (!security_directory) {\n\t\treturn;\n\t}\n\tsize_t numCert = 0;\n\tfor (; numCert < security_directory->length; numCert++) {\n\t\tfree (security_directory->certificates[numCert]);\n\t}\n\tfree (security_directory->certificates);\n\tfree (security_directory);\n}\n\nstatic int bin_pe_init(RBinPEObj* pe) {\n\tpe->dos_header = NULL;\n\tpe->nt_headers = NULL;\n\tpe->section_header = NULL;\n\tpe->export_directory = NULL;\n\tpe->import_directory = NULL;\n\tpe->resource_directory = NULL;\n\tpe->security_directory = NULL;\n\tpe->delay_import_directory = NULL;\n\tpe->optional_header = NULL;\n\tpe->data_directory = NULL;\n\tpe->big_endian = 0;\n\tpe->cms = NULL;\n\tpe->spcinfo = NULL;\n\tif (!bin_pe_init_hdr (pe)) {\n\t\teprintf (\"Warning: File is not PE\\n\");\n\t\treturn false;\n\t}\n\tif (!bin_pe_init_sections (pe)) {\n\t\teprintf (\"Warning: Cannot initialize sections\\n\");\n\t\treturn false;\n\t}\n\tpe->sections = PE_(r_bin_pe_get_sections) (pe);\n\tbin_pe_init_imports (pe);\n\tbin_pe_init_exports (pe);\n\tbin_pe_init_resource (pe);\n\tbin_pe_init_security (pe);\n\n\tpe->big_endian = PE_(r_bin_pe_is_big_endian) (pe);\n\n\tbin_pe_init_rich_info (pe);\n\tbin_pe_init_tls (pe);\n\tbin_pe_init_clr_hdr (pe);\n\tbin_pe_init_metadata_hdr (pe);\n\tbin_pe_init_overlay (pe);\n\tPE_(bin_pe_parse_resource) (pe);\n\tpe->relocs = NULL;\n\treturn true;\n}\n\nchar* PE_(r_bin_pe_get_arch)(RBinPEObj* pe) {\n\tchar* arch;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn strdup (\"x86\");\n\t}\n\tswitch (pe->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA:\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA64:\n\t\tarch = strdup (\"alpha\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_M68K:\n\t\tarch = strdup (\"m68k\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_MIPS16:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16:\n\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2:\n\t\tarch = strdup (\"mips\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_POWERPC:\n\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP:\n\t\tarch = strdup (\"ppc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_EBC:\n\t\tarch = strdup (\"ebc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_ARM64:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RISCV32:\n\tcase PE_IMAGE_FILE_MACHINE_RISCV64:\n\tcase PE_IMAGE_FILE_MACHINE_RISCV128:\n\t\tarch = strdup (\"riscv\");\n\t\tbreak;\n\tdefault:\n\t\tarch = strdup (\"x86\");\n\t}\n\treturn arch;\n}\n\nstruct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(RBinPEObj* pe) {\n\tstruct r_bin_pe_addr_t* entry = NULL;\n\tstatic bool debug = false;\n\tint i;\n\tut64 base_addr = PE_(r_bin_pe_get_image_base) (pe);\n\tif (!pe || !pe->optional_header) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = malloc (sizeof (struct r_bin_pe_addr_t)))) {\n\t\tr_sys_perror (\"malloc (entrypoint)\");\n\t\treturn NULL;\n\t}\n\tPE_DWord pe_entry = pe->optional_header->AddressOfEntryPoint;\n\tentry->vaddr = bin_pe_rva_to_va (pe, pe_entry);\n\tentry->paddr = PE_(va2pa) (pe, pe_entry);\n\t// haddr is the address of AddressOfEntryPoint in header.\n\tentry->haddr = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;\n\n\tif (entry->paddr >= pe->size) {\n\t\tstruct r_bin_pe_section_t* sections = pe->sections;\n\t\tut64 paddr = 0;\n\t\tif (!debug) {\n\t\t\tpe_printf (\"Warning: Invalid entrypoint ... \"\n\t\t\t\t\"trying to fix it but i do not promise nothing\\n\");\n\t\t}\n\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\tif (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tpaddr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (!paddr) {\n\t\t\tut64 min_off = -1;\n\t\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\t\t//get the lowest section's paddr\n\t\t\t\tif (sections[i].paddr < min_off) {\n\t\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\t\tmin_off = sections[i].paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_off == -1) {\n\t\t\t\t//no section just a hack to try to fix entrypoint\n\t\t\t\t//maybe doesn't work always\n\t\t\t\tint sa = R_MAX (pe->optional_header->SectionAlignment, 0x1000);\n\t\t\t\tentry->paddr = pe_entry & ((sa << 1) - 1);\n\t\t\t\tentry->vaddr = entry->paddr + base_addr;\n\t\t\t}\n\t\t}\n\t}\n\tif (!entry->paddr) {\n\t\tif (!debug) {\n\t\t\tpe_printf (\"Warning: NULL entrypoint\\n\");\n\t\t}\n\t\tstruct r_bin_pe_section_t* sections = pe->sections;\n\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\t//If there is a section with x without w perm is a good candidate to be the entrypoint\n\t\t\tif (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE && !(sections[i].perm & PE_IMAGE_SCN_MEM_WRITE)) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (is_arm (pe) && entry->vaddr & 1) {\n\t\tentry->vaddr--;\n\t\tif (entry->paddr & 1) {\n\t\t\tentry->paddr--;\n\t\t}\n\t}\n\tif (!debug) {\n\t\tdebug = true;\n\t}\n\treturn entry;\n}\n\nstruct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(RBinPEObj* pe) {\n\tr_return_val_if_fail (pe, NULL);\n\tstruct r_bin_pe_export_t* exp, * exports = NULL;\n\tPE_Word function_ordinal = 0;\n\tPE_VWord functions_paddr, names_paddr, ordinals_paddr, function_rva, name_vaddr, name_paddr;\n\tchar function_name[PE_NAME_LENGTH + 1], forwarder_name[PE_NAME_LENGTH + 1];\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tPE_(image_data_directory) * data_dir_export;\n\tPE_VWord export_dir_rva;\n\tint n,i, export_dir_size;\n\tst64 exports_sz = 0;\n\n\tif (!pe->data_directory) {\n\t\treturn NULL;\n\t}\n\tdata_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\texport_dir_rva = data_dir_export->VirtualAddress;\n\texport_dir_size = data_dir_export->Size;\n\tPE_VWord *func_rvas = NULL;\n\tPE_Word *ordinals = NULL;\n\tif (pe->export_directory) {\n\t\tif (pe->export_directory->NumberOfFunctions + 1 <\n\t\tpe->export_directory->NumberOfFunctions) {\n\t\t\t// avoid integer overflow\n\t\t\treturn NULL;\n\t\t}\n\t\texports_sz = (pe->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);\n\t\t// we cant exit with export_sz > pe->size, us r_bin_pe_export_t is 256+256+8+8+8+4 bytes is easy get over file size\n\t\t// to avoid fuzzing we can abort on export_directory->NumberOfFunctions>0xffff\n\t\tif (exports_sz < 0 || pe->export_directory->NumberOfFunctions + 1 > 0xffff) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(exports = malloc (exports_sz))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, PE_(va2pa) (pe, pe->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {\n\t\t\t// we dont stop if dll name cant be read, we set dllname to null and continue\n\t\t\tpe_printf (\"Warning: read (dll name)\\n\");\n\t\t\tdll_name[0] = '\\0';\n\t\t}\n\t\tfunctions_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfFunctions);\n\t\tnames_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfNames);\n\t\tordinals_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfOrdinals);\n\n\t\tconst size_t names_sz = pe->export_directory->NumberOfNames * sizeof (PE_Word);\n\t\tconst size_t funcs_sz = pe->export_directory->NumberOfFunctions * sizeof (PE_VWord);\n\t\tordinals = malloc (names_sz);\n\t\tfunc_rvas = malloc (funcs_sz);\n\t\tif (!ordinals || !func_rvas) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint r = r_buf_read_at (pe->b, ordinals_paddr, (ut8 *)ordinals, names_sz);\n\t\tif (r != names_sz) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr = r_buf_read_at (pe->b, functions_paddr, (ut8 *)func_rvas, funcs_sz);\n\t\tif (r != funcs_sz) {\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < pe->export_directory->NumberOfFunctions; i++) {\n\t\t\t// get vaddr from AddressOfFunctions array\n\t\t\tfunction_rva = r_read_at_ble32 ((ut8 *)func_rvas, i * sizeof (PE_VWord), pe->endian);\n\t\t\t// have exports by name?\n\t\t\tif (pe->export_directory->NumberOfNames > 0) {\n\t\t\t\t// search for value of i into AddressOfOrdinals\n\t\t\t\tname_vaddr = 0;\n\t\t\t\tfor (n = 0; n < pe->export_directory->NumberOfNames; n++) {\n\t\t\t\t\tPE_Word fo = r_read_at_ble16 ((ut8 *)ordinals, n * sizeof (PE_Word), pe->endian);\n\t\t\t\t\t// if exist this index into AddressOfOrdinals\n\t\t\t\t\tif (i == fo) {\n\t\t\t\t\t\tfunction_ordinal = fo;\n\t\t\t\t\t\t// get the VA of export name  from AddressOfNames\n\t\t\t\t\t\tname_vaddr = r_buf_read_le32_at (pe->b, names_paddr + n * sizeof (PE_VWord));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// have an address into name_vaddr?\n\t\t\t\tif (name_vaddr) {\n\t\t\t\t\t// get the name of the Export\n\t\t\t\t\tname_paddr = PE_(va2pa) (pe, name_vaddr);\n\t\t\t\t\tif (r_buf_read_at (pe->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\t\tpe_printf (\"Warning: read (function name)\\n\");\n\t\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\t\treturn exports;\n\t\t\t\t\t}\n\t\t\t\t} else { // No name export, get the ordinal\n\t\t\t\t\tfunction_ordinal = i;\n\t\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);\n\t\t\t\t}\n\t\t\t} else { // if export by name dont exist, get the ordinal taking in mind the Base value.\n\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);\n\t\t\t}\n\t\t\t// check if VA are into export directory, this mean a forwarder export\n\t\t\tif (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {\n\t\t\t\t// if forwarder, the VA point to Forwarded name\n\t\t\t\tif (r_buf_read_at (pe->b, PE_(va2pa) (pe, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\treturn exports;\n\t\t\t\t}\n\t\t\t} else { // no forwarder export\n\t\t\t\tsnprintf (forwarder_name, PE_NAME_LENGTH, \"NONE\");\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tfunction_name[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].vaddr = bin_pe_rva_to_va (pe, function_rva);\n\t\t\texports[i].paddr = PE_(va2pa) (pe, function_rva);\n\t\t\texports[i].ordinal = function_ordinal + pe->export_directory->Base;\n\t\t\tmemcpy (exports[i].forwarder, forwarder_name, PE_NAME_LENGTH);\n\t\t\texports[i].forwarder[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].name, function_name, PE_NAME_LENGTH);\n\t\t\texports[i].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].libname, dll_name, PE_NAME_LENGTH);\n\t\t\texports[i].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].last = 0;\n\t\t}\n\t\texports[i].last = 1;\n\t\tfree (ordinals);\n\t\tfree (func_rvas);\n\t}\n\texp = parse_symbol_table (pe, exports, exports_sz - sizeof (struct r_bin_pe_export_t));\n\tif (exp) {\n\t\texports = exp;\n\t}\n\treturn exports;\nbeach:\n\tfree (exports);\n\tfree (ordinals);\n\tfree (func_rvas);\n\treturn NULL;\n}\n\nstatic void free_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tR_FREE (rsds_hdr->file_name);\n}\n\nstatic void init_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tmemset (rsds_hdr, 0, sizeof (SCV_RSDS_HEADER));\n\trsds_hdr->free = (void (*)(struct SCV_RSDS_HEADER*))free_rsdr_hdr;\n}\n\nstatic void free_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tR_FREE (cv_nb10_header->file_name);\n}\n\nstatic void init_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tmemset (cv_nb10_header, 0, sizeof (SCV_NB10_HEADER));\n\tcv_nb10_header->free = (void (*)(struct SCV_NB10_HEADER*))free_cv_nb10_header;\n}\n\nstatic bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n\tconst int rsds_sz = 4 + sizeof (SGUID) + 4;\n\tif (dbg_data_len < rsds_sz) {\n\t\treturn false;\n\t}\n\tmemcpy (res, dbg_data, rsds_sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + rsds_sz);\n\treturn true;\n}\n\nstatic void get_nb10(ut8* dbg_data, int dbg_data_len, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tif (dbg_data_len < nb10sz) {\n\t\treturn;\n\t}\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}\n\nstatic int get_debug_info(RBinPEObj* pe, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* dbgname;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tpe_printf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tdbgname = (char*) rsds_hdr.file_name;\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tdbgname, sizeof (res->file_name));\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n\t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tif (dbg_data_len < 20) {\n\t\t\t\teprintf (\"Truncated NB10 entry, not enough data to parse\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tSCV_NB10_HEADER nb10_hdr = {{0}};\n\t\t\tinit_cv_nb10_header (&nb10_hdr);\n\t\t\tget_nb10 (dbg_data, dbg_data_len, &nb10_hdr);\n\t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n\t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tres->file_name[0] = 0;\n\t\t\tif (nb10_hdr.file_name) {\n\t\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\t\t\tnb10_hdr.file_name, sizeof (res->file_name) - 1);\n\t\t\t}\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n\t\t} else {\n\t\t\tpe_printf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//pe_printf(\"get_debug_info(): not supported type\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((ut8) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}\n\nstatic int read_image_debug_directory_entry(RBuffer *b, ut64 addr, PE_(image_debug_directory_entry) *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_debug_directory_entry))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), MajorVersion, 16);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), MinorVersion, 16);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), Type, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), SizeOfData, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), AddressOfRawData, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), PointerToRawData, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_debug_directory_entry));\n}\n\nint PE_(r_bin_pe_get_debug_data)(RBinPEObj* pe, SDebugInfo* res) {\n\tPE_(image_debug_directory_entry) img_dbg_dir_entry = {0};\n\tPE_(image_data_directory) *dbg_dir = NULL;\n\tPE_DWord dbg_dir_offset;\n\tut8* dbg_data = 0;\n\tint result = 0;\n\tif (!pe) {\n\t\treturn 0;\n\t}\n\tdbg_dir = &pe->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];\n\tdbg_dir_offset = PE_(va2pa) (pe, dbg_dir->VirtualAddress);\n\tif ((int) dbg_dir_offset < 0 || dbg_dir_offset >= pe->size) {\n\t\treturn false;\n\t}\n\tif (dbg_dir_offset >= r_buf_size (pe->b)) {\n\t\treturn false;\n\t}\n\tread_image_debug_directory_entry (pe->b, dbg_dir_offset, &img_dbg_dir_entry);\n\tif ((r_buf_size (pe->b) - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {\n\t\treturn false;\n\t}\n\tut32 dbg_data_poff = R_MIN (img_dbg_dir_entry.PointerToRawData, r_buf_size (pe->b));\n\tint dbg_data_len = R_MIN (img_dbg_dir_entry.SizeOfData, r_buf_size (pe->b) - dbg_data_poff);\n\tif (dbg_data_len < 1) {\n\t\treturn false;\n\t}\n\tdbg_data = (ut8*) calloc (1, dbg_data_len + 1);\n\tif (dbg_data) {\n\t\tr_buf_read_at (pe->b, dbg_data_poff, dbg_data, dbg_data_len);\n\t\tresult = get_debug_info (pe, &img_dbg_dir_entry, dbg_data, dbg_data_len, res);\n\t\tR_FREE (dbg_data);\n\t}\n\treturn result;\n}\n\nstruct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(RBinPEObj* pe) {\n\tstruct r_bin_pe_import_t* imps, * imports = NULL;\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tint nimp = 0;\n\tut64 off; //used to cache value\n\tPE_DWord dll_name_offset = 0;\n\tPE_DWord paddr = 0;\n\tPE_DWord import_func_name_offset;\n\tPE_(image_import_directory) curr_import_dir;\n\tPE_(image_delay_import_directory) curr_delay_import_dir;\n\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tif (pe->import_directory_offset >= pe->size) {\n\t\treturn NULL;\n\t}\n\tif (pe->import_directory_offset + 20 > pe->size) {\n\t\treturn NULL;\n\t}\n\n\toff = pe->import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 last;\n\t\tint idi = 0;\n\t\tif (off + sizeof (PE_(image_import_directory)) > pe->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tint r = read_image_import_directory (pe->b, pe->import_directory_offset +\n\t\t\tidi * sizeof (curr_import_dir), &curr_import_dir);\n\t\tif (r < 0) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (pe->import_directory_size < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (off + pe->import_directory_size > pe->size) {\n\t\t\t//why chopping instead of returning and cleaning?\n\t\t\tpe_printf (\"Warning: read (import directory too big)\\n\");\n\t\t\tpe->import_directory_size = pe->size - pe->import_directory_offset;\n\t\t}\n\t\tlast = pe->import_directory_offset + pe->import_directory_size;\n\t\twhile (r == sizeof (curr_import_dir) && pe->import_directory_offset + (idi + 1) * sizeof (curr_import_dir) <= last && (\n\t\t\tcurr_import_dir.FirstThunk != 0 || curr_import_dir.Name != 0 ||\n\t\t\tcurr_import_dir.TimeDateStamp != 0 || curr_import_dir.Characteristics != 0 ||\n\t\t\tcurr_import_dir.ForwarderChain != 0)) {\n\t\t\tint rr;\n\t\t\tdll_name_offset = curr_import_dir.Name;\n\t\t\tpaddr = PE_(va2pa) (pe, dll_name_offset);\n\t\t\tif (paddr > pe->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (paddr + PE_NAME_LENGTH > pe->size) {\n\t\t\t\trr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, pe->size - paddr);\n\t\t\t\tif (rr != pe->size - paddr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[pe->size - paddr] = '\\0';\n\t\t\t} else {\n\t\t\t\trr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\t\tif (rr != PE_NAME_LENGTH) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\t}\n\t\t\tif (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name,\n\t\t\t\tcurr_import_dir.Characteristics,\n\t\t\t\tcurr_import_dir.FirstThunk)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidi++;\n\t\t\tr = read_image_import_directory (pe->b, pe->import_directory_offset +\n\t\t\t\tidi * sizeof (curr_import_dir), &curr_import_dir);\n\t\t\tif (r < 0) {\n\t\t\t\tfree (imports);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\toff = pe->delay_import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tif (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint didi;\n\t\tfor (didi = 0;; didi++) {\n\t\t\tint r = read_image_delay_import_directory (pe->b, off + didi * sizeof (curr_delay_import_dir),\n\t\t\t\t\t&curr_delay_import_dir);\n\t\t\tif (r != sizeof (curr_delay_import_dir)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif ((curr_delay_import_dir.Name == 0) || (curr_delay_import_dir.DelayImportAddressTable == 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!curr_delay_import_dir.Attributes) {\n\t\t\t\tdll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name - PE_(r_bin_pe_get_image_base)(pe));\n\t\t\t\timport_func_name_offset = curr_delay_import_dir.DelayImportNameTable - PE_(r_bin_pe_get_image_base)(pe);\n\t\t\t} else {\n\t\t\t\tdll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name);\n\t\t\t\timport_func_name_offset = curr_delay_import_dir.DelayImportNameTable;\n\t\t\t}\n\t\t\tif (dll_name_offset > pe->size || dll_name_offset + PE_NAME_LENGTH > pe->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tint rr = r_buf_read_at (pe->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\tif (rr < 5) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tif (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name, import_func_name_offset,\n\t\t\t\tcurr_delay_import_dir.DelayImportAddressTable)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tif (nimp) {\n\t\timps = realloc (imports, (nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\tif (!imps) {\n\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\timports = imps;\n\t\timports[nimp].last = 1;\n\t}\n\treturn imports;\n}\n\nstruct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(RBinPEObj* pe) {\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_pe_lib_t* libs = NULL;\n\tstruct r_bin_pe_lib_t* new_libs = NULL;\n\tPE_(image_import_directory) curr_import_dir;\n\tPE_(image_delay_import_directory) curr_delay_import_dir;\n\tPE_DWord name_off = 0;\n\tHtPP *lib_map = NULL;\n\tut64 off; //cache value\n\tint index = 0;\n\tint len = 0;\n\tint max_libs = 20;\n\tlibs = calloc (max_libs + 1, sizeof (struct r_bin_pe_lib_t));\n\tif (!libs) {\n\t\tr_sys_perror (\"malloc (libs)\");\n\t\treturn NULL;\n\t}\n\n\tif (pe->import_directory_offset + pe->import_directory_size > pe->size) {\n\t\tpe_printf (\"import directory offset bigger than file\\n\");\n\t\tgoto out_error;\n\t}\n\tlib_map = sdb_ht_new ();\n\toff = pe->import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 last;\n\t\tint iidi = 0;\n\t\t// normal imports\n\t\tif (off + sizeof (PE_(image_import_directory)) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tint r = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),\n\t\t\t&curr_import_dir);\n\t\tlast = off + pe->import_directory_size;\n\t\twhile (r == sizeof (curr_import_dir) && off + (iidi + 1) * sizeof (curr_import_dir) <= last && (\n\t\t\tcurr_import_dir.FirstThunk || curr_import_dir.Name ||\n\t\t\tcurr_import_dir.TimeDateStamp || curr_import_dir.Characteristics ||\n\t\t\tcurr_import_dir.ForwarderChain)) {\n\t\t\tname_off = PE_(va2pa) (pe, curr_import_dir.Name);\n\t\t\tlen = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (!libs[index].name[0]) { // minimum string length\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (len < 2 || libs[index].name[0] == 0) { // minimum string length\n\t\t\t\tpe_printf (\"Warning: read (libs - import dirs) %d\\n\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tnew_libs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!new_libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tlibs = new_libs;\n\t\t\t\t\tnew_libs = NULL;\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tiidi++;\n\t\t\tr = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),\n\t\t\t\t&curr_import_dir);\n\t\t}\n\t}\n\toff = pe->delay_import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 did = 0;\n\t\tif (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tint r = read_image_delay_import_directory (pe->b, off, &curr_delay_import_dir);\n\t\tif (r != sizeof (curr_delay_import_dir)) {\n\t\t\tgoto out_error;\n\t\t}\n\t\twhile (r == sizeof (curr_delay_import_dir) &&\n\t\t\tcurr_delay_import_dir.Name != 0 && curr_delay_import_dir.DelayImportNameTable != 0) {\n\t\t\tname_off = PE_(va2pa) (pe, curr_delay_import_dir.Name);\n\t\t\tif (name_off > pe->size || name_off + PE_STRING_LENGTH > pe->size) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tlen = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (len != PE_STRING_LENGTH) {\n\t\t\t\tpe_printf (\"Warning: read (libs - delay import dirs)\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tnew_libs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!new_libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tlibs = new_libs;\n\t\t\t\t\tnew_libs = NULL;\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdid++;\n\t\t\tr = read_image_delay_import_directory (pe->b, off + did * sizeof (curr_delay_import_dir),\n\t\t\t\t&curr_delay_import_dir);\n\t\t}\n\t}\n\tsdb_ht_free (lib_map);\n\tlibs[index].last = 1;\n\treturn libs;\nout_error:\n\tsdb_ht_free (lib_map);\n\tfree (libs);\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_image_size)(RBinPEObj* pe) {\n\treturn pe->nt_headers->optional_header.SizeOfImage;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_machine)(RBinPEObj* pe) {\n\tchar* machine = NULL;\n\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->file_header.Machine) {\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA: machine = \"Alpha\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA64: machine = \"Alpha 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AM33: machine = \"AM33\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AMD64: machine = \"AMD 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ARM: machine = \"ARM\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEE: machine = \"CEE\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEF: machine = \"CEF\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_EBC: machine = \"EBC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_I386: machine = \"i386\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_IA64: machine = \"ia64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M32R: machine = \"M32R\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M68K: machine = \"M68K\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPS16: machine = \"Mips 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU: machine = \"Mips FPU\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16: machine = \"Mips FPU 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPC: machine = \"PowerPC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP: machine = \"PowerPC FP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R10000: machine = \"R10000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R3000: machine = \"R3000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R4000: machine = \"R4000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3: machine = \"SH3\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3DSP: machine = \"SH3DSP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3E: machine = \"SH3E\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH4: machine = \"SH4\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH5: machine = \"SH5\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_THUMB: machine = \"Thumb\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_TRICORE: machine = \"Tricore\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2: machine = \"WCE Mips V2\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV32: machine = \"RISC-V 32-bit\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV64: machine = \"RISC-V 64-bit\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV128: machine = \"RISC-V 128-bit\"; break;\n\t\tdefault: machine = \"unknown\";\n\t\t}\n\t}\n\treturn machine? strdup (machine): NULL;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_os)(RBinPEObj* pe) {\n\tchar* os;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\tswitch (pe->nt_headers->optional_header.Subsystem) {\n\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\tos = strdup (\"native\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\tos = strdup (\"windows\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\tos = strdup (\"posix\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\tos = strdup (\"efi\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\tos = strdup (\"xbox\");\n\t\tbreak;\n\tdefault:\n\t\t// XXX: this is unknown\n\t\tos = strdup (\"windows\");\n\t}\n\treturn os;\n}\n\n// TODO: make it const\nchar* PE_(r_bin_pe_get_class)(RBinPEObj* pe) {\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"PE32\");\n\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"PE32+\");\n\t\tdefault: return strdup (\"Unknown\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_bits)(RBinPEObj* pe) {\n\tint bits = 32;\n\tif (pe && pe->nt_headers) {\n\t\tif (is_arm (pe)) {\n\t\t\tif (is_thumb (pe)) {\n\t\t\t\tbits = 16;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: bits = 32; break;\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: bits = 64; break;\n\t\t\tdefault: bits = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn bits;\n}\n\nchar *PE_(r_bin_pe_get_cc)(RBinPEObj* pe) {\n\tif (pe && pe->nt_headers) {\n\t\tif (is_arm (pe)) {\n\t\t\tif (is_thumb (pe)) {\n\t\t\t\treturn strdup (\"arm16\");\n\t\t\t}\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"arm32\");\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"arm64\");\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"cdecl\");\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"ms\");\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n//This function try to detect anomalies within section\n//we check if there is a section mapped at entrypoint, otherwise add it up\nvoid PE_(r_bin_pe_check_sections)(RBinPEObj* pe, struct r_bin_pe_section_t* * sects) {\n\tint i = 0;\n\tstruct r_bin_pe_section_t* sections = *sects;\n\tut64 addr_beg, addr_end, new_section_size, new_perm, base_addr;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n\n\tif (!entry) {\n\t\treturn;\n\t}\n\tnew_section_size = pe->size;\n\tnew_section_size -= entry->paddr > pe->size? 0: entry->paddr;\n\tnew_perm = (PE_IMAGE_SCN_MEM_READ | PE_IMAGE_SCN_MEM_WRITE | PE_IMAGE_SCN_MEM_EXECUTE);\n\tbase_addr = PE_(r_bin_pe_get_image_base) (pe);\n\n\tfor (i = 0; !sections[i].last; i++) {\n\t\t//strcmp against .text doesn't work in somes cases\n\t\tif (strstr ((const char*) sections[i].name, \"text\")) {\n\t\t\tbool fix = false;\n\t\t\tint j;\n\t\t\t//check paddr boundaries\n\t\t\taddr_beg = sections[i].paddr;\n\t\t\taddr_end = addr_beg + sections[i].size;\n\t\t\tif (entry->paddr < addr_beg || entry->paddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//check vaddr boundaries\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//look for other segment with x that is already mapped and hold entrypoint\n\t\t\tfor (j = 0; !sections[j].last; j++) {\n\t\t\t\taddr_beg = sections[j].paddr;\n\t\t\t\taddr_end = addr_beg + sections[j].size;\n\t\t\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\t\t\tif (!sections[j].vsize) {\n\t\t\t\t\t\tsections[j].vsize = sections[j].size;\n\t\t\t\t\t}\n\t\t\t\t\taddr_beg = sections[j].vaddr + base_addr;\n\t\t\t\t\taddr_end = addr_beg + sections[j].vsize;\n\t\t\t\t\tif (addr_beg <= entry->vaddr || entry->vaddr < addr_end) {\n\t\t\t\t\t\tif (!(sections[j].perm & PE_IMAGE_SCN_MEM_EXECUTE)) {\n\t\t\t\t\t\t\tif (pe->verbose) {\n\t\t\t\t\t\t\t\teprintf (\"Warning: Found entrypoint in non-executable section.\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsections[j].perm |= PE_IMAGE_SCN_MEM_EXECUTE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfix = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if either vaddr or paddr fail we should update this section\n\t\t\tif (fix) {\n\t\t\t\tstrcpy ((char*) sections[i].name, \"blob\");\n\t\t\t\tsections[i].paddr = entry->paddr;\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t\tsections[i].size = sections[i].vsize = new_section_size;\n\t\t\t\tsections[i].perm = new_perm;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//if we arrive til here means there is no text section find one that is holding the code\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tif (sections[i].size > pe->size) {\n\t\t\tcontinue;\n\t\t}\n\t\taddr_beg = sections[i].paddr;\n\t\taddr_end = addr_beg + sections[i].size;\n\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\tif (!sections[i].vsize) {\n\t\t\t\tsections[i].vsize = sections[i].size;\n\t\t\t}\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//we need to create another section in order to load the entrypoint\n\tvoid *ss = realloc (sections, (pe->num_sections + 2) * sizeof (struct r_bin_pe_section_t));\n\tif (!ss) {\n\t\tgoto out_function;\n\t}\n\tpe->sections = sections = ss;\n\ti = pe->num_sections;\n\tsections[i].last = 0;\n\tstrcpy ((char*) sections[i].name, \"blob\");\n\tsections[i].paddr = entry->paddr;\n\tsections[i].vaddr = entry->vaddr - base_addr;\n\tsections[i].size = sections[i].vsize = new_section_size;\n\tsections[i].perm = new_perm;\n\tsections[i + 1].last = 1;\n\t*sects = sections;\nout_function:\n\tfree (entry);\n\treturn;\n\n}\n\nstatic struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe) {\n\tstruct r_bin_pe_section_t* sections = NULL;\n\tint i, j, section_count = 0;\n\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\tPE_(image_section_header) * shdr = pe->section_header;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t//just allocate the needed\n\t\tif (shdr[i].SizeOfRawData || shdr[i].Misc.VirtualSize) {\n\t\t\tsection_count++;\n\t\t}\n\t}\n\tsections = calloc (section_count + 1, sizeof (struct r_bin_pe_section_t));\n\tif (!sections) {\n\t\tr_sys_perror (\"malloc (sections)\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0, j = 0; i < pe->num_sections; i++) {\n\t\tif (!shdr[i].SizeOfRawData && !shdr[i].Misc.VirtualSize) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (shdr[i].Name[0] == '\\0') {\n\t\t\tchar* new_name = r_str_newf (\"sect_%d\", j);\n\t\t\tr_str_ncpy ((char*) sections[j].name, new_name, R_ARRAY_SIZE (sections[j].name) - 1);\n\t\t\tfree (new_name);\n\t\t} else if (shdr[i].Name[0] == '/') {\n\t\t\t// section header is not null terminated, so use ndup\n\t\t\tchar *n = r_str_ndup ((const char *)shdr[i].Name + 1, sizeof (shdr[i].Name) - 1);\n\t\t\tint idx = atoi (n);\n\t\t\tfree (n);\n\t\t\tut64 sym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;\n\t\t\tint num_symbols = pe->nt_headers->file_header.NumberOfSymbols;\n\t\t\tst64 off = num_symbols * COFF_SYMBOL_SIZE;\n\t\t\tif (off > 0 && sym_tbl_off &&\n\t\t\t    sym_tbl_off + off + idx < pe->size &&\n\t\t\t    sym_tbl_off + off + idx > off) {\n\t\t\t\tint sz = PE_IMAGE_SIZEOF_SHORT_NAME * 3;\n\t\t\t\tchar* buf[64] = {0};\n\t\t\t\tif (r_buf_read_at (pe->b,\n\t\t\t\t\t\t   sym_tbl_off + off + idx,\n\t\t\t\t\t\t   (ut8*)buf, 64)) {\n\t\t\t\t\tmemcpy (sections[j].name, buf, sz);\n\t\t\t\t\tsections[j].name[sz - 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy (sections[j].name, shdr[i].Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\t\t\tsections[j].name[PE_IMAGE_SIZEOF_SHORT_NAME] = '\\0';\n\t\t}\n\t\tsections[j].vaddr = shdr[i].VirtualAddress;\n\t\tsections[j].size = shdr[i].SizeOfRawData;\n\t\tif (shdr[i].Misc.VirtualSize) {\n\t\t\tsections[j].vsize = shdr[i].Misc.VirtualSize;\n\t\t} else {\n\t\t\tsections[j].vsize = shdr[i].SizeOfRawData;\n\t\t}\n\t\tsections[j].paddr = shdr[i].PointerToRawData;\n\t\tif (pe->optional_header) {\n\t\t\tut32 sa = pe->optional_header->SectionAlignment;\n\t\t\tif (sa) {\n\t\t\t\tut64 diff = sections[j].vsize % sa;\n\t\t\t\tif (diff) {\n\t\t\t\t\tsections[j].vsize += sa - diff;\n\t\t\t\t}\n\t\t\t\tif (sections[j].vaddr % sa) {\n\t\t\t\t\tpe_printf (\"Warning: section %s not aligned to SectionAlignment.\\n\",\n\t\t\t\t\t\t\tsections[j].name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst ut32 fa = pe->optional_header->FileAlignment;\n\t\t\tif (fa) {\n\t\t\t\tconst ut64 diff = sections[j].paddr % fa;\n\t\t\t\tif (diff) {\n\t\t\t\t\tpe_printf (\"Warning: section %s not aligned to FileAlignment.\\n\", sections[j].name);\n\t\t\t\t\tsections[j].paddr -= diff;\n\t\t\t\t\tsections[j].size += diff;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsections[j].perm = shdr[i].Characteristics;\n\t\tsections[j].last = 0;\n\t\tj++;\n\t}\n\tsections[j].last = 1;\n\tpe->num_sections = section_count;\n\treturn sections;\n}\n\nchar* PE_(r_bin_pe_get_subsystem)(RBinPEObj* pe) {\n\tchar* subsystem = NULL;\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->optional_header.Subsystem) {\n\t\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\t\tsubsystem = \"Native\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\t\t\tsubsystem = \"Windows GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\t\t\tsubsystem = \"Windows CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\t\tsubsystem = \"POSIX CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\t\tsubsystem = \"Windows CE GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\t\t\tsubsystem = \"EFI Application\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\t\t\tsubsystem = \"EFI Boot Service Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\t\t\tsubsystem = \"EFI Runtime Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\t\tsubsystem = \"EFI ROM\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\t\tsubsystem = \"XBOX\"; break;\n\t\tdefault:\n\t\t\tsubsystem = \"Unknown\"; break;\n\t\t}\n\t}\n\treturn subsystem? strdup (subsystem): NULL;\n}\n\n#define HASCHR(x) (pe->nt_headers->file_header.Characteristics & (x))\n\nint PE_(r_bin_pe_is_dll)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DLL);\n}\n\nint PE_(r_bin_pe_is_pie)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);\n#if 0\n\tBOOL aslr = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;\n//TODO: implement dep?\n\tBOOL dep = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT;\n#endif\n}\n\nint PE_(r_bin_pe_is_big_endian)(RBinPEObj* pe) {\n\tut16 arch;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\tarch = pe->nt_headers->file_header.Machine;\n\tif (arch == PE_IMAGE_FILE_MACHINE_I386 ||\n\tarch == PE_IMAGE_FILE_MACHINE_AMD64) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_BYTES_REVERSED_HI);\n}\n\nint PE_(r_bin_pe_is_stripped_relocs)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_RELOCS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_line_nums)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LINE_NUMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_local_syms)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_debug)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DEBUG_STRIPPED);\n}\n\nvoid* PE_(r_bin_pe_free)(RBinPEObj* pe) {\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tfree (pe->dos_header);\n\tfree (pe->nt_headers);\n\tfree (pe->section_header);\n\tfree (pe->export_directory);\n\tfree (pe->import_directory);\n\tfree (pe->resource_directory);\n\tfree_security_directory (pe->security_directory);\n\tfree (pe->delay_import_directory);\n\tfree (pe->tls_directory);\n\tfree (pe->sections);\n\tfree (pe->authentihash);\n\tr_list_free (pe->rich_entries);\n\tr_list_free (pe->resources);\n\tr_pkcs7_free_cms (pe->cms);\n\tr_pkcs7_free_spcinfo (pe->spcinfo);\n\tr_buf_free (pe->b);\n\tpe->b = NULL;\n\tfree (pe);\n\treturn NULL;\n}\n\nRBinPEObj* PE_(r_bin_pe_new)(const char* file, bool verbose) {\n\tRBinPEObj* pe = R_NEW0 (RBinPEObj);\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tpe->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8*)r_file_slurp (file, &binsz);\n\tpe->size = binsz;\n\tif (!buf) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\tpe->b = r_buf_new ();\n\tif (!r_buf_set_bytes (pe->b, buf, pe->size)) {\n\t\tfree (buf);\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\tpe->verbose = verbose;\n\tfree (buf);\n\tif (!bin_pe_init (pe)) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\treturn pe;\n}\n\nR_API RBinPEObj* PE_(r_bin_pe_new_buf)(RBuffer *buf, bool verbose) {\n\tRBinPEObj *pe = R_NEW0 (RBinPEObj);\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tpe->kv = sdb_new0 ();\n\tpe->b = r_buf_ref (buf);\n\tpe->verbose = verbose;\n\tpe->size = r_buf_size (buf);\n\tif (!bin_pe_init (pe)) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\treturn pe;\n}\n", "/* radare2 - LGPL - Copyright 2018-2022 - pancake, mrmacete, keegan */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_io.h>\n#include <ht_pu.h>\n// #include \"../format/mach0/mach0_defines.h\"\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n\n#define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)\n#define MAX_N_HDR 16\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n} RDyldRebaseInfo;\n\ntypedef struct {\n\tut64 start;\n\tut64 end;\n\tRDyldRebaseInfo *info;\n} RDyldRebaseInfosEntry;\n\ntypedef struct {\n\tRDyldRebaseInfosEntry *entries;\n\tsize_t length;\n} RDyldRebaseInfos;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut64 delta_mask;\n\tut32 delta_shift;\n\tut64 auth_value_add;\n} RDyldRebaseInfo3;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut16 *page_extras;\n\tut32 page_extras_count;\n\tut64 delta_mask;\n\tut64 value_mask;\n\tut32 delta_shift;\n\tut64 value_add;\n} RDyldRebaseInfo2;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *toc;\n\tut32 toc_count;\n\tut8 *entries;\n\tut32 entries_size;\n} RDyldRebaseInfo1;\n\ntypedef struct {\n\tut64 local_symbols_offset;\n\tut64 nlists_offset;\n\tut64 nlists_count;\n\tut64 strings_offset;\n\tut64 strings_size;\n} RDyldLocSym;\n\ntypedef struct _r_dyldcache {\n\tut8 magic[8];\n\n\tcache_hdr_t *hdr;\n\tut64 *hdr_offset;\n\tut32 *maps_index;\n\tut32 n_hdr;\n\tcache_map_t *maps;\n\tut32 n_maps;\n\n\tRList *bins;\n\tRBuffer *buf;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tRDyldRebaseInfos *rebase_infos;\n\tcache_accel_t *accel;\n\tRDyldLocSym *locsym;\n\tobjc_cache_opt_info *oi;\n\tbool objc_opt_info_loaded;\n} RDyldCache;\n\ntypedef struct _r_bin_image {\n\tchar *file;\n\tut64 header_at;\n\tut64 hdr_offset;\n\tut64 symbols_off;\n\tut64 va;\n\tut32 nlist_start_index;\n\tut32 nlist_count;\n} RDyldBinImage;\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\n\tR_FREE (bin->file);\n\tR_FREE (bin);\n}\n\nstatic void rebase_info3_free(RDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info2_free(RDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info->page_extras);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info1_free(RDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->toc);\n\tR_FREE (rebase_info->entries);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info_free(RDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free ((RDyldRebaseInfo1*) rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free ((RDyldRebaseInfo2*) rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free ((RDyldRebaseInfo3*) rebase_info);\n\t} else {\n\t\tR_FREE (rebase_info);\n\t}\n}\n\nstatic cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RDyldCache *cache, void *entries) {\n\tr_return_if_fail (cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRDyldBinImage *bin = NULL;\n\tRListIter *it = r_list_iterator (cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tR_FREE (imgs);\n}\n\nstatic RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {\n\tr_return_val_if_fail (cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof (cache_locsym_info_t);\n\t\tinfo = R_NEW0 (cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {\n\t\t\teprintf (\"locsym err 01\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\teprintf (\"locsym err 02\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 03\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 04\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRDyldLocSym * locsym = R_NEW0 (RDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries (cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\treturn locsym;\n\nbeach:\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\teprintf (\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic ut64 rebase_infos_get_slide(RDyldCache *cache) {\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {\n\tRDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\teprintf (\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof (struct MACH0_(nlist));\n\tif (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree (nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains (hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add (hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tsym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = r_str_newf (\"unk_local%d\", k++);\n\t\t}\n\n\t\tr_list_append (symbols, sym);\n\t}\n\n\tfree (nlists);\n}\n\nstatic void r_dyldcache_free(RDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tr_list_free (cache->bins);\n\tcache->bins = NULL;\n\tr_buf_free (cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free (cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tR_FREE (cache->rebase_infos->entries);\n\t\tR_FREE (cache->rebase_infos);\n\t}\n\tR_FREE (cache->hdr);\n\tR_FREE (cache->maps);\n\tR_FREE (cache->maps_index);\n\tR_FREE (cache->hdr_offset);\n\tR_FREE (cache->accel);\n\tR_FREE (cache->locsym);\n\tR_FREE (cache->oi);\n\tR_FREE (cache);\n}\n\nstatic ut64 bin_obj_va2pa(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf) {\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn 0;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) ((struct MACH0_(obj_t)*)bf->o->bin_obj)->user;\n\tif (!cache) {\n\t\treturn 0;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic struct MACH0_(obj_t) *bin_to_mach0(RBinFile *bf, RDyldBinImage *bin) {\n\tif (!bin || !bf) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.header_at = bin->header_at - bin->hdr_offset;\n\topts.symbols_off = bin->symbols_off;\n\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\n\tmach0->user = cache;\n\tmach0->va2pa = &bin_obj_va2pa;\n\n\tr_buf_free (buf);\n\n\treturn mach0;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}\n\nstatic RDyldRebaseInfo *get_rebase_info(RBinFile *bf, RDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (r_buf_read_at (cache_buf, offset, (ut8*) &slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof (cache_slide3_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc (page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo3 *rebase_info = R_NEW0 (RDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof (cache_slide2_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo2 *rebase_info = R_NEW0 (RDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16*) tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll (rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof (cache_slide1_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64) slide_info.entries_count * (ut64) slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_read_at (cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc (4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfo1 *rebase_info = R_NEW0 (RDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16*) tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else {\n\t\teprintf (\"unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tR_FREE (tmp_buf_1);\n\tR_FREE (tmp_buf_2);\n\tR_FREE (one_page_buf);\n\treturn NULL;\n}\n\nstatic RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {\n\tRDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tut64 slide_infos_offset;\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree (infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree (infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);\n\t\t\tfree (infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info (bf, cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree (result);\n\treturn NULL;\n}\n\nstatic bool check_magic(const char *magic) {\n\treturn !strcmp (magic, \"dyld_v1   arm64\")\n\t\t|| !strcmp (magic, \"dyld_v1  arm64e\")\n\t\t|| !strcmp (magic, \"dyld_v1  x86_64\")\n\t\t|| !strcmp (magic, \"dyld_v1 x86_64h\");\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tif (r_buf_size (buf) < 32) {\n\t\treturn false;\n\t}\n\n\tchar hdr[17] = { 0 };\n\tint rhdr = r_buf_read_at (buf, 0, (ut8 *)&hdr, sizeof (hdr) - 1);\n\tif (rhdr != sizeof (hdr) - 1) {\n\t\treturn false;\n\t}\n\n\treturn check_magic (hdr);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = R_NEWS0 (cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, accel->imagesExtrasOffset, (ut8*) images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (r_buf_read_at (cache_buf, img->pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\tfile[255] = 0;\n\t\t/*char * last_slash = strrchr (file, '/');\n\t\tif (last_slash && *last_slash) {\n\t\t\tlib_name = last_slash + 1;\n\t\t}*/\n\t\treturn strdup (lib_name);\n\t}\n\treturn strdup (\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr ((const char*) a, (const char*) b);\n}\n\nstatic HtPU *create_path_to_index(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0 ();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tfor (i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) != sizeof (file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[sizeof (file) - 1] = 0;\n\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\n\t\tconst char versions_pattern[] = \".framework/Versions/\";\n\t\tchar *versions = strstr (file, versions_pattern);\n\t\tif (versions) {\n\t\t\tchar *next_slash = strchr (versions + 20, '/');\n\t\t\tif (next_slash) {\n\t\t\t\tchar *tail = strdup (next_slash);\n\t\t\t\tif (!tail) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (versions + 10, tail);\n\t\t\t\tfree (tail);\n\t\t\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\t\t\t}\n\t\t}\n\t}\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut8 *cmds = malloc (mh.sizeofcmds + 1);\n\tif (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_read_le32 (cursor);\n\t\tut32 cmdsize = r_read_le32 (cursor + sizeof (ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *) cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\teprintf (\"Warning: alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\teprintf (\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree (cmds);\n}\n\nstatic ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn 0;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn 0;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut64 cursor = cmds_at;\n\tut64 end = cursor + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_buf_read_le32_at (cache->buf, cursor);\n\t\tif (cmd == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tut32 cmdsize = r_buf_read_le32_at (cache->buf, cursor + sizeof (ut32));\n\t\tif (cmdsize == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (cmd == LC_SEGMENT || cmd == LC_SEGMENT_64) {\n\t\t\tchar segname[17];\n\t\t\tsegname[16] = 0;\n\t\t\tif (r_buf_read_at (cache->buf, cursor + 2 * sizeof (ut32), (ut8 *)segname, 16) != 16) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!strncmp (segname, \"__LINKEDIT\", 16)) {\n\t\t\t\tut64 vmaddr = r_buf_read_le64_at (cache->buf, cursor + 2 * sizeof (ut32) + 16);\n\t\t\t\tif (vmaddr == UT64_MAX) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tut32 i,j;\n\t\t\t\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\t\t\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\t\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\t\t\tut32 maps_index = cache->maps_index[i];\n\t\t\t\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\t\t\t\tut64 map_start = cache->maps[maps_index + j].address;\n\t\t\t\t\t\tut64 map_end = map_start + cache->maps[maps_index + j].size;\n\t\t\t\t\t\tif (vmaddr >= map_start && vmaddr < map_end) {\n\t\t\t\t\t\t\treturn hdr_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\treturn 0;\n}\n\nstatic RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}\n\nstatic void rebase_bytes_v1(RDyldRebaseInfo1 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\t\tut64 entry_index = page_offset / 32;\n\t\tut64 offset_in_entry = (page_offset % 32) / 4;\n\n\t\tif (entry_index >= rebase_info->entries_size) {\n\t\t\tin_buf += to_next_page;\n\t\t\toffset += to_next_page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (page_index >= rebase_info->toc_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut8 *entry = &rebase_info->entries[rebase_info->toc[page_index] * rebase_info->entries_size];\n\t\tut8 b = entry[entry_index];\n\n\t\tif (b & (1 << offset_in_entry)) {\n\t\t\tut64 value = r_read_le64 (buf + in_buf);\n\t\t\tvalue += rebase_info->slide;\n\t\t\tr_write_le64 (buf + in_buf, value);\n\t\t\tin_buf += 8;\n\t\t\toffset += 8;\n\t\t} else {\n\t\t\tin_buf += 4;\n\t\t\toffset += 4;\n\t\t}\n\t}\n}\n\nstatic void rebase_bytes_v2(RDyldRebaseInfo2 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut16 page_flag = rebase_info->page_starts[page_index];\n\n\t\tif (page_flag == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!(page_flag & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA)) {\n\t\t\tut64 first_rebase_off = rebase_info->page_starts[page_index] * 4;\n\t\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\t\tut32 delta = 1;\n\t\t\t\twhile (delta) {\n\t\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\t\tif (position >= count) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift);\n\t\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\t\tut64 new_value = raw_value & rebase_info->value_mask;\n\t\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\t\tnew_value += rebase_info->value_add;\n\t\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t\t}\n\t\t\t\t\tfirst_rebase_off += delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic void rebase_bytes_v3(RDyldRebaseInfo3 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut64 delta = rebase_info->page_starts[page_index];\n\n\t\tif (delta == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tut64 first_rebase_off = delta;\n\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\tdo {\n\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\tif (position >= count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift) * 8;\n\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\tut64 new_value = 0;\n\t\t\t\t\tif (R_IS_PTR_AUTHENTICATED (raw_value)) {\n\t\t\t\t\t\tnew_value = (raw_value & 0xFFFFFFFFULL) + rebase_info->auth_value_add;\n\t\t\t\t\t\t// TODO: don't throw auth info away\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_value = ((raw_value << 13) & 0xFF00000000000000ULL) | (raw_value & 0x7ffffffffffULL);\n\t\t\t\t\t\tnew_value &= 0x00FFFFFFFFFFFFFFULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t}\n\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t}\n\t\t\t\tfirst_rebase_off += delta;\n\t\t\t} while (delta);\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic RDyldRebaseInfo *rebase_info_by_range(RDyldRebaseInfos *infos, ut64 offset, int count) {\n\tint imid;\n\tint imin = 0;\n\tint imax = infos->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRDyldRebaseInfosEntry *entry = &infos->entries[imid];\n\t\tif ((entry->end) <= offset) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRDyldRebaseInfosEntry *minEntry = &infos->entries[imin];\n\tif ((imax == imin) && (minEntry->start <= offset + count) && (minEntry->end >= offset)) {\n\t\treturn minEntry->info;\n\t}\n\treturn NULL;\n}\n\nstatic void rebase_bytes(RDyldRebaseInfo *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tif (!rebase_info || !buf) {\n\t\treturn;\n\t}\n\n\tif (rebase_info->version == 3) {\n\t\trebase_bytes_v3 ((RDyldRebaseInfo3*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 2 || rebase_info->version == 4) {\n\t\trebase_bytes_v2 ((RDyldRebaseInfo2*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 1) {\n\t\trebase_bytes_v1 ((RDyldRebaseInfo1*) rebase_info, buf, offset, count, start_of_write);\n\t}\n}\n\nstatic int dyldcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRDyldCache *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t} else {\n\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t}\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->o) {\n\t\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t\t} else {\n\t\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read) {\n\t\tif (fd->plugin->read == &dyldcache_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tRDyldRebaseInfo *rebase_info = rebase_info_by_range (cache->rebase_infos, io->off, count);\n\n\tint result = 0;\n\n\tif (rebase_info && count > 0) {\n\t\tut64 offset_in_data = io->off - rebase_info->start_of_data;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\n\t\tut64 internal_offset = io->off & ~(rebase_info->page_size - 1);\n\t\tut64 internal_end = io->off + count;\n\t\tint rounded_count = internal_end - internal_offset;\n\n\t\tut8 *internal_buf = rebase_info->one_page_buf;\n\t\tif (rounded_count > rebase_info->page_size) {\n\t\t\tinternal_buf = malloc (rounded_count);\n\t\t\tif (!internal_buf) {\n\t\t\t\teprintf (\"Cannot allocate memory for 'internal_buf'\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tut64 original_off = io->off;\n\t\tio->off = internal_offset;\n\n\t\tint internal_result = cache->original_io_read (io, fd, internal_buf, rounded_count);\n\n\t\tio->off = original_off;\n\n\t\tif (internal_result >= page_offset + count) {\n\t\t\trebase_bytes (rebase_info, internal_buf, internal_offset, internal_result, page_offset);\n\t\t\tresult = R_MIN (count, internal_result);\n\t\t\tmemcpy (buf, internal_buf + page_offset, result);\n\t\t} else {\n\t\t\teprintf (\"ERROR rebasing\\n\");\n\t\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t\t}\n\n\t\tif (internal_buf != rebase_info->one_page_buf) {\n\t\t\tR_FREE (internal_buf);\n\t\t}\n\t} else {\n\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t}\n\n\treturn result;\n}\n\nstatic void swizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tcache->original_io_read = plugin->read;\n\tplugin->read = &dyldcache_io_read;\n}\n\nstatic cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = R_NEW0 (cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_hdr_t);\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\tif (!check_magic (hdr->magic)) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\thdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);\n\t\thdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);\n\t}\n\treturn hdr;\n}\n\n\nstatic void populate_cache_headers(RDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRList *hdrs = r_list_newf (NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header (cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE (h->mappingOffset);\n\t\tSHIFT_MAYBE (h->imagesOffset);\n\t\tSHIFT_MAYBE (h->codeSignatureOffset);\n\t\tSHIFT_MAYBE (h->slideInfoOffset);\n\t\tSHIFT_MAYBE (h->localSymbolsOffset);\n\t\tSHIFT_MAYBE (h->branchPoolsOffset);\n\t\tSHIFT_MAYBE (h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tR_FREE (cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));\n\n\tut32 i = 0;\n\tRListIter *iter;\n\tcache_hdr_t *item;\n\tr_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));\n\t}\n\nbeach:\n\tr_list_free (hdrs);\n}\n\nstatic void populate_cache_maps(RDyldCache *cache) {\n\tr_return_if_fail (cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tcache_map_t *maps = NULL;\n\tif (n_maps != 0) {\n\t\tcache->maps_index = R_NEWS0 (ut32, cache->n_hdr);\n\t\tif (!cache->maps_index) {\n\t\t\treturn;\n\t\t}\n\t\tmaps = R_NEWS0 (cache_map_t, n_maps);\n\t}\n\tif (!maps) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tut32 next_map = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof (cache_map_t) * hdr->mappingCount;\n\t\tif (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n}\n\nstatic cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nstatic objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 selrefs_offset = 0;\n\t\tut64 selrefs_size = 0;\n\t\tut8 remaining = 2;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__DATA.__objc_selrefs\")) {\n\t\t\t\tselrefs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tselrefs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tut64 sel_string_base = 0;\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tif (!selrefs_offset || !selrefs_size || cache->n_hdr == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 cursor = selrefs_offset;\n\t\t\tut64 end = cursor + selrefs_size;\n\t\t\twhile (cursor < end) {\n\t\t\t\tut64 sel_ptr = r_buf_read_le64_at (cache->buf, cursor);\n\t\t\t\tif (sel_ptr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut64 sel_offset = va2pa (sel_ptr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tchar * selector = r_buf_get_string (cache->buf, sel_offset);\n\t\t\t\tif (!selector) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool is_magic_selector = !strncmp (selector, \"\\xf0\\x9f\\xa4\\xaf\", 4);\n\t\t\t\tfree (selector);\n\n\t\t\t\tif (is_magic_selector) {\n\t\t\t\t\tsel_string_base = sel_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcursor += 8;\n\t\t\t}\n\t\t\tif (sel_string_base == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);\n\t\t\tif (check != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);\n\t\t\tif (sel_string_base == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);\n\t\t\tif (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult = R_NEW0 (objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRBinAddr *ptr = NULL;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\n\tif (!bf || !bf->o) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tbool big_endian = 0;\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"dyldcache\");\n\tret->rclass = strdup (\"ios\");\n\tret->os = strdup (\"iOS\");\n\tif (strstr (cache->hdr->magic, \"x86_64\")) {\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t} else {\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = strstr (cache->hdr->magic, \"arm64\")? 64: 32;\n\t}\n\tret->machine = strdup (ret->arch);\n\tret->subsystem = strdup (\"xnu\");\n\tret->type = strdup (\"library-cache\");\n\tret->has_va = true;\n\tret->big_endian = big_endian;\n\tret->dbg_info = 0;\n\treturn ret;\n}\n\n#if 0\nstatic void parse_mach0(RList *ret, ut64 paddr, RBinFile *bf) {\n\t// TODO\n}\n#endif\n\nstatic ut64 baddr(RBinFile *bf) {\n\t// XXX hardcoded\n\treturn 0x180000000;\n}\n\nvoid symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\t// const RList*symbols = MACH0_(get_symbols_list) (mach0);\n\tconst struct symbol_t *symbols = MACH0_(get_symbols) (mach0);\n\tif (!symbols) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (symbols[i].name, \"<redacted>\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = strdup (symbols[i].name);\n\t\tsym->vaddr = symbols[i].addr;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = (symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->paddr = symbols[i].offset + bf->o->boffset;\n\t\tsym->size = symbols[i].size;\n\t\tsym->ordinal = i;\n\n\t\tset_u_add (hash, sym->vaddr);\n\t\tr_list_append (ret, sym);\n\t}\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic bool __is_data_section(const char *name) {\n\tif (strstr (name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_os_log\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\tstruct section_t *sections = NULL;\n\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\treturn;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tint i;\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->file) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", bin->file, (char*)sections[i].name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)sections[i].name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = sections[i].size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\tptr->is_data = __is_data_section (ptr->name);\n\t\tptr->size = sections[i].size;\n\t\tptr->vsize = sections[i].vsize;\n\t\tptr->vaddr = sections[i].addr;\n\t\tptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = sections[i].perm;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (sections);\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tsections_from_bin (ret, bf, bin);\n\t}\n\n\tRBinSection *ptr = NULL;\n\tint i;\n\tfor (i = 0; i < cache->n_maps; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr->name = r_str_newf (\"cache_map.%d\", i);\n\t\tptr->size = cache->maps[i].size;\n\t\tptr->vsize = ptr->size;\n\t\tptr->paddr = cache->maps[i].fileOffset;\n\t\tptr->vaddr = cache->maps[i].address;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tptr->perm = prot2perm (cache->maps[i].initProt);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSection *section;\n\t\tr_list_foreach (ret, iter, section) {\n\t\t\tsection->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tSetU *hash = set_u_new ();\n\t\tif (!hash) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_from_bin (cache, ret, bf, bin, hash);\n\t\tsymbols_from_locsym (cache, bin, ret, hash);\n\t\tset_u_free (hash);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSymbol *sym;\n\t\tr_list_foreach (ret, iter, sym) {\n\t\t\tsym->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* static void unswizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin || !cache->original_io_read) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tplugin->read = cache->original_io_read;\n\tcache->original_io_read = NULL;\n} */\n\nstatic void destroy(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\t// unswizzle_io_read (cache, bf->rbin->iob.io); // XXX io may be dead here\n\tr_dyldcache_free (cache);\n}\n\nstatic RList *classes(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->objc_opt_info_loaded) {\n\t\tcache->oi = get_objc_opt_info (bf, cache);\n\t\tcache->objc_opt_info_loaded = true;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\n\tRBuffer *orig_buf = bf->buf;\n\tut32 num_of_unnamed_class = 0;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool is_classlist = strstr (sections[i].name, \"__objc_classlist\");\n\t\t\tbool is_catlist = strstr (sections[i].name, \"__objc_catlist\");\n\n\t\t\tif (!is_classlist && !is_catlist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut8 *pointers = malloc (sections[i].size);\n\t\t\tif (!pointers) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\tif (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {\n\t\t\t\tR_FREE (pointers);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 *cursor = pointers;\n\t\t\tut8 *pointers_end = pointers + sections[i].size;\n\n\t\t\tfor (; cursor < pointers_end; cursor += 8) {\n\t\t\t\tut64 pointer_to_class = r_read_le64 (cursor);\n\n\t\t\t\tRBinClass *klass;\n\t\t\t\tif (!(klass = R_NEW0 (RBinClass)) ||\n\t\t\t\t\t!(klass->methods = r_list_new ()) ||\n\t\t\t\t\t!(klass->fields = r_list_new ())) {\n\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tbf->o->bin_obj = mach0;\n\t\t\t\tbf->buf = cache->buf;\n\t\t\t\tif (is_classlist) {\n\t\t\t\t\tMACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);\n\t\t\t\t} else {\n\t\t\t\t\tMACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);\n\t\t\t\t}\n\t\t\t\tbf->o->bin_obj = cache;\n\t\t\t\tbf->buf = orig_buf;\n\n\t\t\t\tif (!klass->name) {\n\t\t\t\t\teprintf (\"KLASS ERROR AT 0x%\"PFMT64x\", is_classlist %d\\n\", pointer_to_class, is_classlist);\n\t\t\t\t\tklass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);\n\t\t\t\t\tif (!klass->name) {\n\t\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tnum_of_unnamed_class++;\n\t\t\t\t}\n\t\t\t\tr_list_append (ret, klass);\n\t\t\t}\n\n\t\t\tR_FREE (pointers);\n\t\t}\n\n\t\tR_FREE (sections);\n\t\tMACH0_(mach0_free) (mach0);\n\t}\n\n\treturn ret;\n\nbeach:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic void header(RBinFile *bf) {\n\tif (!bf || !bf->o) {\n\t\treturn;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\tPrintfCallback p = bin->cb_printf;\n\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_k (pj, \"header\");\n\tpj_o (pj);\n\tpj_ks (pj, \"magic\", cache->hdr->magic);\n\tpj_kn (pj, \"mappingOffset\", cache->hdr->mappingOffset);\n\tpj_kn (pj, \"mappingCount\", cache->hdr->mappingCount);\n\tpj_kn (pj, \"imagesOffset\", cache->hdr->imagesOffset);\n\tpj_kn (pj, \"imagesCount\", cache->hdr->imagesCount);\n\tpj_kn (pj, \"dyldBaseAddress\", cache->hdr->dyldBaseAddress);\n\tpj_kn (pj, \"codeSignatureOffset\", cache->hdr->codeSignatureOffset);\n\tpj_kn (pj, \"codeSignatureSize\", cache->hdr->codeSignatureSize);\n\tpj_kn (pj, \"slideInfoOffset\", cache->hdr->slideInfoOffset);\n\tpj_kn (pj, \"slideInfoSize\", cache->hdr->slideInfoSize);\n\tpj_kn (pj, \"localSymbolsOffset\", cache->hdr->localSymbolsOffset);\n\tpj_kn (pj, \"localSymbolsSize\", cache->hdr->localSymbolsSize);\n\tchar uuidstr[128];\n\tr_hex_bin2str ((ut8*)cache->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_ks (pj, \"cacheType\", (cache->hdr->cacheType == 0) ? \"development\" : \"production\");\n\tpj_kn (pj, \"branchPoolsOffset\", cache->hdr->branchPoolsOffset);\n\tpj_kn (pj, \"branchPoolsCount\", cache->hdr->branchPoolsCount);\n\tpj_kn (pj, \"accelerateInfoAddr\", cache->hdr->accelerateInfoAddr + slide);\n\tpj_kn (pj, \"accelerateInfoSize\", cache->hdr->accelerateInfoSize);\n\tpj_kn (pj, \"imagesTextOffset\", cache->hdr->imagesTextOffset);\n\tpj_kn (pj, \"imagesTextCount\", cache->hdr->imagesTextCount);\n\tpj_end (pj);\n\n\tif (cache->accel) {\n\t\tpj_k (pj, \"accelerator\");\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"version\", cache->accel->version);\n\t\tpj_kn (pj, \"imageExtrasCount\", cache->accel->imageExtrasCount);\n\t\tpj_kn (pj, \"imagesExtrasOffset\", cache->accel->imagesExtrasOffset);\n\t\tpj_kn (pj, \"bottomUpListOffset\", cache->accel->bottomUpListOffset);\n\t\tpj_kn (pj, \"dylibTrieOffset\", cache->accel->dylibTrieOffset);\n\t\tpj_kn (pj, \"dylibTrieSize\", cache->accel->dylibTrieSize);\n\t\tpj_kn (pj, \"initializersOffset\", cache->accel->initializersOffset);\n\t\tpj_kn (pj, \"initializersCount\", cache->accel->initializersCount);\n\t\tpj_kn (pj, \"dofSectionsOffset\", cache->accel->dofSectionsOffset);\n\t\tpj_kn (pj, \"dofSectionsCount\", cache->accel->dofSectionsCount);\n\t\tpj_kn (pj, \"reExportListOffset\", cache->accel->reExportListOffset);\n\t\tpj_kn (pj, \"reExportCount\", cache->accel->reExportCount);\n\t\tpj_kn (pj, \"depListOffset\", cache->accel->depListOffset);\n\t\tpj_kn (pj, \"depListCount\", cache->accel->depListCount);\n\t\tpj_kn (pj, \"rangeTableOffset\", cache->accel->rangeTableOffset);\n\t\tpj_kn (pj, \"rangeTableCount\", cache->accel->rangeTableCount);\n\t\tpj_kn (pj, \"dyldSectionAddr\", cache->accel->dyldSectionAddr + slide);\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->rebase_infos) {\n\t\tsize_t i;\n\t\tpj_k (pj, \"slideInfo\");\n\t\tpj_a (pj);\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\tRDyldRebaseInfo * rebase_info = cache->rebase_infos->entries[i].info;\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"start\", cache->rebase_infos->entries[i].start);\n\t\t\tpj_kn (pj, \"end\", cache->rebase_infos->entries[i].end);\n\t\t\tif (rebase_info) {\n\t\t\t\tut8 version = rebase_info->version;\n\t\t\t\tpj_kn (pj, \"version\", version);\n\t\t\t\tpj_kn (pj, \"slide\", slide);\n\t\t\t\tif (version == 3) {\n\t\t\t\t\tRDyldRebaseInfo3 *info3 = (RDyldRebaseInfo3*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info3->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info3->page_size);\n\t\t\t\t\tpj_kn (pj, \"auth_value_add\", info3->auth_value_add);\n\t\t\t\t} else if (version == 2 || version == 4) {\n\t\t\t\t\tRDyldRebaseInfo2 *info2 = (RDyldRebaseInfo2*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info2->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_extras_count\", info2->page_extras_count);\n\t\t\t\t\tpj_kn (pj, \"delta_mask\", info2->delta_mask);\n\t\t\t\t\tpj_kn (pj, \"value_mask\", info2->value_mask);\n\t\t\t\t\tpj_kn (pj, \"value_add\", info2->value_add);\n\t\t\t\t\tpj_kn (pj, \"delta_shift\", info2->delta_shift);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info2->page_size);\n\t\t\t\t} else if (version == 1) {\n\t\t\t\t\tRDyldRebaseInfo1 *info1 = (RDyldRebaseInfo1*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"toc_count\", info1->toc_count);\n\t\t\t\t\tpj_kn (pj, \"entries_size\", info1->entries_size);\n\t\t\t\t\tpj_kn (pj, \"page_size\", 4096);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->hdr->imagesTextCount) {\n\t\tpj_k (pj, \"images\");\n\t\tpj_a (pj);\n\t\tut64 total_size = cache->hdr->imagesTextCount * sizeof (cache_text_info_t);\n\t\tcache_text_info_t * text_infos = malloc (total_size);\n\t\tif (!text_infos) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, cache->hdr->imagesTextOffset, (ut8*)text_infos, \"16clii\", cache->hdr->imagesTextCount) != total_size) {\n\t\t\tfree (text_infos);\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i != cache->hdr->imagesTextCount; i++) {\n\t\t\tcache_text_info_t * text_info = &text_infos[i];\n\t\t\tr_hex_bin2str ((ut8*)text_info->uuid, 16, uuidstr);\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"uuid\", uuidstr);\n\t\t\tpj_kn (pj, \"address\", text_info->loadAddress + slide);\n\t\t\tpj_kn (pj, \"textSegmentSize\", text_info->textSegmentSize);\n\t\t\tchar file[256];\n\t\t\tif (r_buf_read_at (cache->buf, text_info->pathOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\tfile[255] = 0;\n\t\t\t\tpj_ks (pj, \"path\", file);\n\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\tpj_ks (pj, \"name\", last_slash + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"name\", file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tfree (text_infos);\n\t}\n\n\tpj_end (pj);\n\tp (\"%s\", pj_string (pj));\n\nbeach:\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_dyldcache = {\n\t.name = \"dyldcache\",\n\t.desc = \"dyldcache bin plugin\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check_buffer = &check_buffer,\n\t.destroy = &destroy,\n\t.classes = &classes,\n\t.header = &header,\n\t.info = &info,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dyldcache,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2015-2018 - Dax89, pancake */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"../i/private.h\"\n#include \"psxexe/psxexe.h\"\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 magic[PSXEXE_ID_LEN];\n\tif (r_buf_read_at (b, 0, magic, sizeof (magic)) == PSXEXE_ID_LEN) {\n\t\treturn !memcmp (magic, PSXEXE_ID, PSXEXE_ID_LEN);\n\t}\n\treturn false;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {\n\treturn check_buffer (bf, b);\n}\n\nstatic RBinInfo* info(RBinFile* bf) {\n\tRBinInfo* ret = NULL;\n\tpsxexe_header psxheader = {0};\n\n\tif (r_buf_read_at (bf->buf, 0, (ut8*)&psxheader, sizeof(psxexe_header)) < sizeof(psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\n\tret->file = strdup (bf->file);\n\tret->type = strdup (\"Sony PlayStation 1 Executable\");\n\tret->machine = strdup (\"Sony PlayStation 1\");\n\tret->os = strdup (\"psx\");\n\tret->arch = strdup (\"mips\");\n\tret->bits = 32;\n\tret->has_va = true;\n\treturn ret;\n}\n\nstatic RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tsz = r_buf_size (bf->buf);\n\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\n\tr_list_append (ret, sect);\n\treturn ret;\n}\n\nstatic RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\n\tr_list_append (ret, addr);\n\treturn ret;\n}\n\nstatic RList* strings(RBinFile* bf) {\n\t// hardcode minstrlen = 20\n\treturn r_bin_file_get_strings (bf, 20, 0, 2);\n}\n\nRBinPlugin r_bin_plugin_psxexe = {\n\t.name = \"psxexe\",\n\t.desc = \"Sony PlayStation 1 Executable\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.info = &info,\n\t.sections = &sections,\n\t.entries = &entries,\n\t.strings = &strings,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_psxexe,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare2 - LGPL3 - 2015-2022 - deepakchethan */\n\n#include \"qnx/qnx.h\"\n#include \"../i/private.h\"\n\nstatic int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tut8 tmp[6];\n\tint r = r_buf_read_at (buf, 0, tmp, sizeof (tmp));\n\treturn r == sizeof (tmp) && !memcmp (tmp, QNX_MAGIC, sizeof (tmp));\n}\n\n// Frees the bin_obj of the binary file\nstatic void destroy(RBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\tr_list_free (qo->sections);\n\tr_list_free (qo->fixups);\n\tbf->o->bin_obj = NULL;\n\tfree (qo);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tQnxObj *qo = R_NEW0 (QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\tRList *sections = NULL;\n\tRList *fixups = NULL;\n\n\tif (!qo) {\n\t\tgoto beach;\n\t}\n\tif (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {\n\t\tgoto beach;\n\t}\n\tqo->kv = sdb_new0 ();\n\tif (!qo->kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load (&qo->lmfh, bf->buf, qo->kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof (lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof (lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_RESOURCE\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_LOAD\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vaddr = ldata.offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_data);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'f'; // \"LMF_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'F'; // \"LMF_8087_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\tr_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, \"si\", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set (sdb, \"info\", qo->kv);\n\tqo->sections = sections;\n\tqo->fixups = fixups;\n\t*bin_obj = qo;\n\treturn true;\nbeach:\n\tfree (qo);\n\tr_list_free (fixups);\n\tr_list_free (sections);\n\treturn false;\n}\n\n/*\n * Provides the info about the binary file\n * @param RBinFile to extract the data from\n * @return RBinInfo file with the info\n */\nstatic RBinInfo *info(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = bf->file? strdup (bf->file): NULL;\n\tret->type = strdup (\"QNX Executable\");\n\tret->bclass = strdup (\"qnx\");\n\tret->machine = strdup (\"i386\");\n\tret->rclass = strdup (\"QNX\");\n\tret->arch = strdup (\"x86\");\n\tret->os = strdup (\"any\");\n\tret->subsystem = strdup (\"any\");\n\tret->lang = \"C/C++\";\n\tret->signature = true;\n\treturn ret;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn r_list_clone (qo->fixups);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o && bf->rbin);\n\tQnxObj *bin = bf->o->bin_obj;\n\tRBin *rbin = bf->rbin;\n\trbin->cb_printf (\"QNX file header:\\n\");\n\trbin->cb_printf (\"version : 0x%xH\\n\", bin->lmfh.version);\n\trbin->cb_printf (\"cflags : 0x%xH\\n\", bin->lmfh.cflags);\n\trbin->cb_printf (\"cpu : 0x%xH\\n\", bin->lmfh.cpu);\n\trbin->cb_printf (\"fpu : 0x%xH\\n\", bin->lmfh.fpu);\n\trbin->cb_printf (\"code_index : 0x%xH\\n\", bin->lmfh.code_index);\n\trbin->cb_printf (\"stack_index : 0x%xH\\n\", bin->lmfh.stack_index);\n\trbin->cb_printf (\"heap_index : 0x%xH\\n\", bin->lmfh.heap_index);\n\trbin->cb_printf (\"argv_index : 0x%xH\\n\", bin->lmfh.argv_index);\n\trbin->cb_printf (\"spare2[4] : 0x0H\\n\");\n\trbin->cb_printf (\"code_offset : 0x%xH\\n\", bin->lmfh.code_offset);\n\trbin->cb_printf (\"stack_nbytes : 0x%xH\\n\", bin->lmfh.stack_nbytes);\n\trbin->cb_printf (\"heap_nbytes : 0x%xH\\n\", bin->lmfh.heap_nbytes);\n\trbin->cb_printf (\"image_base : 0x%xH\\n\", bin->lmfh.image_base);\n\trbin->cb_printf (\"spare3[2] : 0x0H\\n\");\n}\n\n/*\n * No mention of symbols in the doc\n */\nstatic RList* symbols(RBinFile *bf) {\n\treturn NULL;\n}\n\n// Returns the sections\nstatic RList* sections(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn r_list_clone (qo->sections);\n}\n\n/*\n * Returns the sdb\n * @param RBinFile\n * @return sdb of the bin_obj\n */\nstatic Sdb *get_sdb(RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tQnxObj *qo = o->bin_obj;\n\treturn qo? qo->kv: NULL;\n}\n\n/*\n * Returns the base address of the image from the binary header\n * @param RBinFile\n * @return image_base address\n */\nstatic ut64 baddr(RBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? qo->lmfh.image_base: 0;\n}\n\n/*\n * Currently both physical and virtual address are set to 0\n * The memory map has different values for entry\n */\nstatic RList* entries(RBinFile *bf) {\n\tRList *ret;\n\tRBinAddr *ptr = NULL;\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = qo->lmfh.code_offset;\n\tptr->vaddr = qo->lmfh.code_offset + baddr (bf);\n\tr_list_append (ret, ptr);\n\treturn ret;\n}\n\n/*\n * @param RBinFile\n * @return signature of the binary\n */\nstatic char *signature(RBinFile *bf, bool json) {\n \tchar buf[64];\n \tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? r_str_dup (NULL, sdb_itoa (qo->rwend.signature, buf, 10)): NULL;\n}\n\n/*\n * @return: returns the vaddr\n */\nstatic ut64 get_vaddr(RBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {\n\treturn vaddr;\n}\n\n// Declaration of the plugin\nRBinPlugin r_bin_plugin_qnx = {\n\t.name = \"qnx\",\n\t.desc = \"QNX executable file support\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.relocs = &relocs,\n\t.baddr = &baddr,\n\t.author = \"deepakchethan\",\n\t.check_buffer = &check_buffer,\n\t.header = &header,\n\t.get_sdb = &get_sdb,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.signature = &signature,\n\t.get_vaddr = &get_vaddr,\n\t.info = &info\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_qnx,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2022 - ret2libc, pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_io.h>\n\ntypedef enum {\n\tR_BUFFER_FILE,\n\tR_BUFFER_IO,\n\tR_BUFFER_BYTES,\n\tR_BUFFER_MMAP,\n\tR_BUFFER_SPARSE,\n\tR_BUFFER_REF,\n} RBufferType;\n\n#include \"buf_file.c\"\n#include \"buf_sparse.c\"\n#include \"buf_bytes.c\"\n#include \"buf_mmap.c\"\n#include \"buf_io.c\"\n#include \"buf_ref.c\"\n\nstatic bool buf_init(RBuffer *b, const void *user) {\n\tr_return_val_if_fail (b && b->methods, false);\n\treturn b->methods->init? b->methods->init (b, user): true;\n}\n\nstatic void buf_wholefree(RBuffer *b) {\n\tif (!b->methods->get_whole_buf) {\n\t\tR_FREE (b->whole_buf);\n\t}\n}\n\nstatic bool buf_fini(RBuffer *b) {\n\tr_return_val_if_fail (b && b->methods, false);\n\treturn b->methods->fini? b->methods->fini (b): true;\n}\n\nstatic ut64 buf_get_size(RBuffer *b) {\n\tr_return_val_if_fail (b && b->methods, UT64_MAX);\n\treturn b->methods->get_size? b->methods->get_size (b): UT64_MAX;\n}\n\nstatic st64 buf_read(RBuffer *b, ut8 *buf, size_t len) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->read? b->methods->read (b, buf, len): -1;\n}\n\nstatic st64 buf_write(RBuffer *b, const ut8 *buf, size_t len) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\tbuf_wholefree (b);\n\treturn b->methods->write? b->methods->write (b, buf, len): -1;\n}\n\nstatic st64 buf_seek(RBuffer *b, st64 addr, int whence) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->seek? b->methods->seek (b, addr, whence): -1;\n}\n\nstatic bool buf_resize(RBuffer *b, ut64 newsize) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->resize? b->methods->resize (b, newsize): false;\n}\n\nstatic ut8 *get_whole_buf(RBuffer *b, ut64 *sz) {\n\tr_return_val_if_fail (b && b->methods, NULL);\n\tif (b->methods->get_whole_buf) {\n\t\treturn b->methods->get_whole_buf (b, sz);\n\t}\n\tut64 bsz = r_buf_size (b);\n\t// bsz = 4096; // FAKE MINIMUM SIZE TO READ THE BIN HEADER\n\tif (bsz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tfree (b->whole_buf);\n\tb->whole_buf = R_NEWS (ut8, bsz);\n\tif (!b->whole_buf) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (b, 0, b->whole_buf, bsz);\n\tif (sz) {\n\t\t*sz = bsz;\n\t}\n\treturn b->whole_buf;\n}\n\nstatic RBuffer *new_buffer(RBufferType type, const void *user) {\n\tRBuffer *b = R_NEW0 (RBuffer);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tswitch (type) {\n\tcase R_BUFFER_BYTES:\n\t\tb->methods = &buffer_bytes_methods;\n\t\tbreak;\n\tcase R_BUFFER_MMAP:\n\t\tb->methods = &buffer_mmap_methods;\n\t\tbreak;\n\tcase R_BUFFER_SPARSE:\n\t\tb->methods = &buffer_sparse_methods;\n\t\tbreak;\n\tcase R_BUFFER_FILE:\n\t\tb->methods = &buffer_file_methods;\n\t\tbreak;\n\tcase R_BUFFER_IO:\n\t\tb->methods = &buffer_io_methods;\n\t\tbreak;\n\tcase R_BUFFER_REF:\n\t\tb->methods = &buffer_ref_methods;\n\t\tbreak;\n\tdefault:\n\t\tr_warn_if_reached ();\n\t\tbreak;\n\t}\n\tif (!buf_init (b, user)) {\n\t\tfree (b);\n\t\treturn NULL;\n\t}\n\treturn b;\n}\n\n// TODO: Optimize to use memcpy when buffers are not in range..\n// check buf boundaries and offsets and use memcpy or memmove\n\n// copied from libr/io/cache.c:r_io_cache_read\n// ret # of bytes copied\nR_API RBuffer *r_buf_new_with_io(void *iob, int fd) {\n\tr_return_val_if_fail (iob && fd >= 0, NULL);\n\tstruct buf_io_user u = { 0 };\n\tu.iob = (RIOBind *)iob;\n\tu.fd = fd;\n\treturn new_buffer (R_BUFFER_IO, &u);\n}\n\nR_API RBuffer *r_buf_new_with_pointers(const ut8 *bytes, ut64 len, bool steal) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = bytes;\n\tu.length = len;\n\tu.steal = steal;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API RBuffer *r_buf_new_empty(ut64 len) {\n\tut8 *buf = R_NEWS0 (ut8, len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = buf;\n\tu.length = len;\n\tu.steal = true;\n\tRBuffer *res = new_buffer (R_BUFFER_BYTES, &u);\n\tif (!res) {\n\t\tfree (buf);\n\t}\n\treturn res;\n}\n\nR_API RBuffer *r_buf_new_with_bytes(const ut8 *bytes, ut64 len) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data = bytes;\n\tu.length = len;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API RBuffer *r_buf_new_slice(RBuffer *b, ut64 offset, ut64 size) {\n\tstruct buf_ref_user u = { 0 };\n\tu.parent = b;\n\tu.offset = offset;\n\tu.size = size;\n\treturn new_buffer (R_BUFFER_REF, &u);\n}\n\nR_API RBuffer *r_buf_new_with_string(const char *msg) {\n\treturn r_buf_new_with_bytes ((const ut8 *)msg, (ut64)strlen (msg));\n}\n\nR_API RBuffer *r_buf_new_with_buf(RBuffer *b) {\n\tut64 sz = 0;\n\tconst ut8 *tmp = r_buf_data (b, &sz);\n\treturn r_buf_new_with_bytes (tmp, sz);\n}\n\nR_API RBuffer *r_buf_new_sparse(ut8 Oxff) {\n\tRBuffer *b = new_buffer (R_BUFFER_SPARSE, NULL);\n\tif (b) {\n\t\tb->Oxff_priv = Oxff;\n\t}\n\treturn b;\n}\n\nR_API RBuffer *r_buf_new(void) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data = NULL;\n\tu.length = 0;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_DEPRECATE R_API const ut8 *r_buf_data(RBuffer *b, ut64 *size) {\n\tr_return_val_if_fail (b, NULL);\n\tb->whole_buf = get_whole_buf (b, size);\n\treturn b->whole_buf;\n}\n\nR_API ut64 r_buf_size(RBuffer *b) {\n\tr_return_val_if_fail (b, 0);\n\treturn buf_get_size (b);\n}\n\n// rename to new?\nR_API RBuffer *r_buf_new_mmap(const char *filename, int perm) {\n\tr_return_val_if_fail (filename, NULL);\n\tstruct buf_mmap_user u = { 0 };\n\tu.filename = filename;\n\tu.perm = perm;\n\treturn new_buffer (R_BUFFER_MMAP, &u);\n}\n\nR_API RBuffer *r_buf_new_file(const char *file, int perm, int mode) {\n\tstruct buf_file_user u = { 0 };\n\tu.file = file;\n\tu.perm = perm;\n\tu.mode = mode;\n\treturn new_buffer (R_BUFFER_FILE, &u);\n}\n\n// TODO: rename to new_from_file ?\nR_API RBuffer *r_buf_new_slurp(const char *file) {\n\tsize_t len;\n\tchar *tmp = r_file_slurp (file, &len);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = (ut8 *)tmp;\n\tu.length = (ut64)len;\n\tu.steal = true;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API bool r_buf_dump(RBuffer *b, const char *file) {\n\t// TODO: need to redo this\n\tif (!b || !file) {\n\t\treturn false;\n\t}\n\tut64 tmpsz = 0;\n\tconst ut8 *tmp = r_buf_data (b, &tmpsz);\n\treturn r_file_dump (file, tmp, tmpsz, 0);\n}\n\nR_API st64 r_buf_seek(RBuffer *b, st64 addr, int whence) {\n\tr_return_val_if_fail (b, -1);\n\treturn buf_seek (b, addr, whence);\n}\n\nR_API ut64 r_buf_tell(RBuffer *b) {\n\treturn r_buf_seek (b, 0, R_BUF_CUR);\n}\n\nR_API bool r_buf_set_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\tif (!r_buf_resize (b, 0)) {\n\t\treturn false;\n\t}\n\tif (r_buf_seek (b, 0, R_BUF_SET) < 0) {\n\t\treturn false;\n\t}\n\tif (!r_buf_append_bytes (b, buf, length)) {\n\t\treturn false;\n\t}\n\treturn r_buf_seek (b, 0, R_BUF_SET) >= 0;\n}\n\nR_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\treturn r_buf_insert_bytes (b, 0, buf, length) >= 0;\n}\n\nR_API char *r_buf_to_string(RBuffer *b) {\n\tut64 sz = r_buf_size (b);\n\tchar *s = malloc (sz + 1);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (b, 0, (ut8 *)s, sz) < 0) {\n\t\tfree (s);\n\t\treturn NULL;\n\t}\n\ts[sz] = '\\0';\n\treturn s;\n}\n\nR_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\n\tif (r_buf_seek (b, 0, R_BUF_END) < 0) {\n\t\treturn false;\n\t}\n\treturn r_buf_write (b, buf, length) >= 0;\n}\n\nR_API bool r_buf_append_nbytes(RBuffer *b, ut64 length) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\tut8 *buf = R_NEWS0 (ut8, length);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tbool res = r_buf_append_bytes (b, buf, length);\n\tfree (buf);\n\treturn res;\n}\n\nR_API st64 r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && !b->readonly, -1);\n\tst64 pos, r = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tpos = r;\n\tr = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto restore_pos;\n\t}\n\n\tut64 sz = r_buf_size (b);\n\tut8 *tmp = R_NEWS (ut8, sz - addr);\n\tr = r_buf_read (b, tmp, sz - addr);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tst64 tmp_length = r;\n\tif (!r_buf_resize (b, sz + length)) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_seek (b, addr + length, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_write (b, tmp, tmp_length);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_write (b, buf, length);\nfree_tmp:\n\tfree (tmp);\nrestore_pos:\n\tr_buf_seek (b, pos, R_BUF_SET);\n\treturn r;\n}\n\nR_API bool r_buf_append_ut8(RBuffer *b, ut8 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut16(RBuffer *b, ut16 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut32(RBuffer *b, ut32 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut64(RBuffer *b, ut64 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_buf(RBuffer *b, RBuffer *a) {\n\tr_return_val_if_fail (b && a && !b->readonly, false);\n\tut64 sz = 0;\n\tconst ut8 *tmp = r_buf_data (a, &sz);\n\treturn r_buf_append_bytes (b, tmp, sz);\n}\n\nR_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, ut64 size) {\n\tr_return_val_if_fail (b && a && !b->readonly, false);\n\tut8 *tmp = R_NEWS (ut8, size);\n\tbool res = false;\n\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\tst64 r = r_buf_read_at (a, offset, tmp, size);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\tres = r_buf_append_bytes (b, tmp, r);\nerr:\n\tfree (tmp);\n\treturn res;\n}\n\n// return an heap-allocated string read from the RBuffer b at address addr. The\n// length depends on the first '\\0' found in the buffer. If there is no '\\0' in\n// the buffer, there is no string, thus NULL is returned.\nR_API char *r_buf_get_string(RBuffer *b, ut64 addr) {\n\tconst int MIN_RES_SZ = 64;\n\tut8 *res = R_NEWS (ut8, MIN_RES_SZ + 1);\n\tut64 sz = 0;\n\tst64 r = r_buf_read_at (b, addr, res, MIN_RES_SZ);\n\tbool null_found = false;\n\twhile (r > 0) {\n\t\tconst ut8 *needle = r_mem_mem (res + sz, r, (ut8 *)\"\\x00\", 1);\n\t\tif (needle) {\n\t\t\tnull_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tsz += r;\n\t\taddr += r;\n\n\t\tut8 *restmp = realloc (res, sz + MIN_RES_SZ + 1);\n\t\tif (!restmp) {\n\t\t\tfree (res);\n\t\t\treturn NULL;\n\t\t}\n\t\tres = restmp;\n\t\tr = r_buf_read_at (b, addr, res + sz, MIN_RES_SZ);\n\t}\n\tif (r < 0 || !null_found) {\n\t\tfree (res);\n\t\treturn NULL;\n\t}\n\treturn (char *)res;\n}\n\nR_API ut8 *r_buf_read_all(RBuffer *b, int *blen) {\n\tr_return_val_if_fail (b, NULL);\n\tint buflen = r_buf_size (b);\n\tif (buflen < 0) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = malloc (buflen + 1);\n\tbuf_seek (b, 0, R_BUF_SET);\n\tbuf_read (b, buf, buflen);\n\tif (blen) {\n\t\t*blen = buflen;\n\t}\n\treturn buf;\n}\n\nR_API st64 r_buf_read(RBuffer *b, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 r = buf_read (b, buf, len);\n\tif (r >= 0 && r < len) {\n\t\tmemset (buf + r, b->Oxff_priv, len - r);\n\t}\n\treturn r;\n}\n\nR_API st64 r_buf_write(RBuffer *b, const ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf && !b->readonly, -1);\n\treturn buf_write (b, buf, len);\n}\n\nR_API ut8 r_buf_read8(RBuffer *b) {\n\tut8 res;\n\tst64 r = r_buf_read (b, &res, sizeof (res));\n\treturn r == sizeof (res)? res: b->Oxff_priv;\n}\n\nR_API ut8 r_buf_read8_at(RBuffer *b, ut64 addr) {\n\tut8 res;\n\tst64 r = r_buf_read_at (b, addr, &res, sizeof (res));\n\treturn r == sizeof (res)? res: b->Oxff_priv;\n}\n\nstatic st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {\n\tst64 res = 0;\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tint j;\n\t\tint m = 1;\n\t\tint tsize = 2;\n\t\tbool bigendian = true;\n\n\t\tfor (j = 0; fmt[j]; j++) {\n\t\t\tswitch (fmt[j]) {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tif (m == 1) {\n\t\t\t\t\tm = r_num_get (NULL, &fmt[j]);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase 's': tsize = 2; bigendian = false; break;\n\t\t\tcase 'S': tsize = 2; bigendian = true; break;\n\t\t\tcase 'i': tsize = 4; bigendian = false; break;\n\t\t\tcase 'I': tsize = 4; bigendian = true; break;\n\t\t\tcase 'l': tsize = 8; bigendian = false; break;\n\t\t\tcase 'L': tsize = 8; bigendian = true; break;\n\t\t\tcase 'c': tsize = 1; bigendian = false; break;\n\t\t\tdefault: return -1;\n\t\t\t}\n\n\t\t\tint k;\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tut8 tmp[sizeof (ut64)];\n\t\t\t\tut8 d1;\n\t\t\t\tut16 d2;\n\t\t\t\tut32 d3;\n\t\t\t\tut64 d4;\n\t\t\t\tst64 r = r_buf_read (src, tmp, tsize);\n\t\t\t\tif (r < tsize) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tswitch (tsize) {\n\t\t\t\tcase 1:\n\t\t\t\t\td1 = r_read_ble8 (tmp);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d1, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\td2 = r_read_ble16 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d2, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\td3 = r_read_ble32 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d3, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\td4 = r_read_ble64 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d4, 8);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tres += r;\n\t\t\t}\n\t\t\tm = 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API st64 r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\t// XXX: we assume the caller knows what he's doing\n\tRBuffer *dst = r_buf_new_with_pointers (buf, UT64_MAX, false);\n\tst64 res = buf_format (dst, b, fmt, n);\n\tr_buf_free (dst);\n\treturn res;\n}\n\nR_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt && !b->readonly, -1);\n\t// XXX: we assume the caller knows what he's doing\n\tRBuffer *src = r_buf_new_with_pointers (buf, UT64_MAX, false);\n\tst64 res = buf_format (b, src, fmt, n);\n\tr_buf_free (src);\n\treturn res;\n}\n\nR_API st64 r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt && !b->readonly, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fwrite (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf && !b->readonly, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_write (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API void r_buf_fini(RBuffer *b) {\n\tif (!b) {\n\t\treturn;\n\t}\n\tif (b->refctr > 0) {\n\t\tb->refctr--;\n\t\treturn;\n\t}\n\n\t// free the whole_buf only if it was initially allocated by the buf types\n\tif (b->methods->get_whole_buf) {\n\t\tif (b->methods->free_whole_buf) {\n\t\t\tb->methods->free_whole_buf (b);\n\t\t}\n\t} else {\n\t\tbuf_wholefree (b);\n\t}\n\tbuf_fini (b);\n}\n\nR_API void r_buf_free(RBuffer *b) {\n\tbool unreferenced = b && b->refctr == 0;\n\tr_buf_fini (b);\n\tif (unreferenced) {\n\t\tfree (b);\n\t}\n}\n\nR_API st64 r_buf_append_string(RBuffer *b, const char *str) {\n\tr_return_val_if_fail (b && str && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)str, strlen (str));\n}\n\nR_API bool r_buf_resize(RBuffer *b, ut64 newsize) {\n\tr_return_val_if_fail (b, false);\n\treturn buf_resize (b, newsize);\n}\n\nR_API RBuffer *r_buf_ref(RBuffer *b) {\n\tif (b) {\n\t\tb->refctr++;\n\t}\n\treturn b;\n}\n\nR_API RList *r_buf_nonempty_list(RBuffer *b) {\n\treturn b->methods->nonempty_list? b->methods->nonempty_list (b): NULL;\n}\n\nR_API st64 r_buf_uleb128(RBuffer *b, ut64 *v) {\n\tut8 c = 0xff;\n\tut64 s = 0, sum = 0, l = 0;\n\tdo {\n\t\tut8 data;\n\t\tst64 r = r_buf_read (b, &data, sizeof (data));\n\t\tif (r < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tc = data & 0xff;\n\t\tif (s < 64) {\n\t\t\tsum |= ((ut64) (c & 0x7f) << s);\n\t\t\ts += 7;\n\t\t} else {\n\t\t\tsum = 0;\n\t\t}\n\t\tl++;\n\t} while (c & 0x80);\n\tif (v) {\n\t\t*v = sum;\n\t}\n\treturn l;\n}\n\nR_API st64 r_buf_sleb128(RBuffer *b, st64 *v) {\n\tst64 result = 0, offset = 0;\n\tut8 value;\n\tdo {\n\t\tst64 chunk;\n\t\tst64 r = r_buf_read (b, &value, sizeof (value));\n\t\tif (r != sizeof (value)) {\n\t\t\treturn -1;\n\t\t}\n\t\tchunk = value & 0x7f;\n\t\tif (offset < 64) {\n\t\t\tresult |= (chunk << offset);\n\t\t\toffset += 7;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t} while (value & 0x80);\n\n\tif ((value & 0x40) != 0) {\n\t\tif (offset < 64) {\n\t\t\tresult |= ~0ULL << offset;\n\t\t}\n\t}\n\tif (v) {\n\t\t*v = result;\n\t}\n\treturn offset / 7;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2008-2022 nibble, pancake, inisider */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <r_hash.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"pe.h\"\n#include <time.h>\n#include <ht_uu.h>\n\n#define PE_IMAGE_FILE_MACHINE_RPI2 452\n#define MAX_METADATA_STRING_LENGTH 256\n#define pe_printf if (pe->verbose) eprintf\n#define COFF_SYMBOL_SIZE 18\n#define PE_READ_STRUCT_FIELD(var, struct_type, field, size) var->field = r_read_le##size (buf + offsetof (struct_type, field))\n\nstruct SCV_NB10_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tut32 offset;\n\tut32 timestamp;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_NB10_HEADER* cv_nb10_header);\n} SCV_NB10_HEADER;\n\ntypedef struct {\n\tut32 data1;\n\tut16 data2;\n\tut16 data3;\n\tut8 data4[8];\n} SGUID;\n\nstruct SCV_RSDS_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tSGUID guid;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_RSDS_HEADER* rsds_hdr);\n} SCV_RSDS_HEADER;\n\nR_API RBinPEObj* PE_(get)(RBinFile *bf) {\n\treturn (bf && bf->o)? bf->o->bin_obj: NULL;\n}\n\nstatic inline int is_thumb(RBinPEObj* pe) {\n\treturn pe->nt_headers->optional_header.AddressOfEntryPoint & 1;\n}\n\nstatic inline int is_arm(RBinPEObj* pe) {\n\tswitch (pe->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool read_and_follow_jump(struct r_bin_pe_addr_t *entry, RBuffer *buf, ut8 *b, int len, bool big_endian) {\n\tif (!r_buf_read_at (buf, entry->paddr, b, len)) {\n\t\treturn false;\n\t}\n\tif (b[0] != 0xe9) {\n\t\treturn true;\n\t}\n\tconst st32 jmp_dst = r_read_ble32 (b + 1, big_endian) + 5;\n\tentry->paddr += jmp_dst;\n\tentry->vaddr += jmp_dst;\n\treturn r_buf_read_at (buf, entry->paddr, b, len) > 0;\n}\n\nstatic inline bool follow_offset(struct r_bin_pe_addr_t *entry, RBuffer *buf, ut8 *b, int len, bool big_endian, size_t instr_off) {\n\tconst st32 dst_offset = r_read_ble32 (b + instr_off + 1, big_endian) + instr_off + 5;\n\tentry->paddr += dst_offset;\n\tentry->vaddr += dst_offset;\n\treturn read_and_follow_jump (entry, buf, b, len, big_endian);\n}\n\nstruct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj *pe) {\n\tr_return_val_if_fail (pe && pe->b, NULL);\n\tut8 b[512];\n\tsize_t n = 0;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\n\tread_and_follow_jump (entry, pe->b, b, sizeof (b), pe->big_endian);\n\n\t// MSVC SEH\n\t// E8 13 09 00 00  call    0x44C388\n\t// E9 05 00 00 00  jmp     0x44BA7F\n\tif (b[0] == 0xe8 && b[5] == 0xe9) {\n\t\tif (follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 5)) {\n\t\t\t// case1:\n\t\t\t// from des address of jmp search for 68 xx xx xx xx e8 and test xx xx xx xx = imagebase\n\t\t\t// 68 00 00 40 00  push    0x400000\n\t\t\t// E8 3E F9 FF FF  call    0x44B4FF\n\t\t\tut32 imageBase = pe->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tconst ut32 tmp_imgbase = r_read_ble32 (b + n + 1, pe->big_endian);\n\t\t\t\tif (b[n] == 0x68 && tmp_imgbase == imageBase && b[n + 5] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case2:\n\t\t\t// from des address of jmp search for 50 FF xx FF xx E8\n\t\t\t//50\t\t\t push    eax\n\t\t\t//FF 37\t\t\t push    dword ptr[edi]\n\t\t\t//FF 36          push    dword ptr[esi]\n\t\t\t//E8 6F FC FF FF call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n+1] == 0xff && b[n + 3] == 0xff && b[n + 5] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case3:\n\t\t\t//50                                         push    eax\n\t\t\t//FF 35 0C E2 40 00                          push    xxxxxxxx\n\t\t\t//FF 35 08 E2 40 00                          push    xxxxxxxx\n\t\t\t//E8 2B FD FF FF                             call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 20; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0xff && b[n + 7] == 0xff && b[n + 13] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 13);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case4:\n\t\t\t//50                                        push    eax\n\t\t\t//57                                        push    edi\n\t\t\t//FF 36                                     push    dword ptr[esi]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0x57 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case5:\n\t\t\t//57                                        push    edi\n\t\t\t//56                                        push    esi\n\t\t\t//FF 36                                     push    dword ptr[eax]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x57 && b[n + 1] == 0x56 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// MSVC 32bit debug\n\tif (b[3] == 0xe8) {\n\t\t// 55                    push ebp\n\t\t// 8B EC                 mov ebp, esp\n\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t// 5D                    pop ebp\n\t\t// C3                    ret\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 3);\n\t\tif (b[8] == 0xe8) {\n\t\t\t// 55                    push ebp\n\t\t\t// 8B EC                 mov ebp, esp\n\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t// E8 xx xx xx xx        call xxxxxxxx <- Follow this\n\t\t\t// 5D                    pop ebp\n\t\t\t// C3                    ret\n\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 8);\n\t\t\tfor (n = 0; n + 16 < sizeof (b); n++) {\n\t\t\t\t// E8 xx xx xx xx    call sub.ucrtbased.dll__register_thread_local_exe_atexit_callback\n\t\t\t\t// 83 C4 04          add esp, 4\n\t\t\t\t// E8 xx xx xx xx    call xxxxxxxx <- Follow this\n\t\t\t\t// 89 xx xx          mov dword [xxxx], eax\n\t\t\t\t// E8 xx xx xx xx    call xxxxxxxx\n\t\t\t\tif (b[n] == 0xe8 && n + 8 <= sizeof (b) && !memcmp (b + n + 5, \"\\x83\\xc4\\x04\", 3)\n\t\t\t\t\t&& b[n + 8] == 0xe8 && b[n + 13] == 0x89 && b[n + 16] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\t\tint j, calls = 0;\n\t\t\t\t\tfor (j = 0; j < sizeof (b) - 4; j++) {\n\t\t\t\t\t\tif (b[j] == 0xe8) {\n\t\t\t\t\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t\t\t\t\tcalls++;\n\t\t\t\t\t\t\tif (calls == 4) {\n\t\t\t\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, j);\n\t\t\t\t\t\t\t\treturn entry;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// MSVC AMD64\n\tif (b[4] == 0xe8) {\n\t\tbool found_caller = false;\n\t\tif (b[13] == 0xe9) {\n\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t// E9 xx xx xx xx    jmp     xxxxxxxx <- Follow this\n\t\t\tfound_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 13);\n\t\t} else {\n\t\t\t// Debug\n\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t// C3                ret\n\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 4);\n\t\t\tif (b[9] == 0xe8) {\n\t\t\t\t// 48 83 EC 28       sub     rsp, 0x28\n\t\t\t\t// E8 xx xx xx xx    call    xxxxxxxx\n\t\t\t\t// E8 xx xx xx xx    call    xxxxxxxx <- Follow this\n\t\t\t\t// 48 83 C4 28       add     rsp, 0x28\n\t\t\t\t// C3                ret\n\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 9);\n\t\t\t\tif (b[0x129] == 0xe8) {\n\t\t\t\t\t// E8 xx xx xx xx        call xxxxxxxx\n\t\t\t\t\tfound_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 0x129);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found_caller) {\n\t\t\t// from des address of jmp, search for 4C ... 48 ... 8B ... E8\n\t\t\t// 4C 8B C0                    mov     r8, rax\n\t\t\t// 48 8B 17                    mov     rdx, qword [rdi]\n\t\t\t// 8B 0B                       mov     ecx, dword [rbx]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\t// or\n\t\t\t// 4C 8B 44 24 28              mov r8, qword [rsp + 0x28]\n\t\t\t// 48 8B 54 24 30              mov rdx, qword [rsp + 0x30]\n\t\t\t// 8B 4C 24 20                 mov ecx, dword [rsp + 0x20]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\tfor (n = 0; n + 14 < sizeof (b); n++) {\n\t\t\t\tif (b[n] == 0x4c && b[n + 3] == 0x48 && b[n + 6] == 0x8b && b[n + 8] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t\tif (b[n] == 0x4c && b [n + 5] == 0x48 && b[n + 10] == 0x8b && b[n + 14] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 14);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Microsoft Visual-C\n\t// 50                  push eax\n\t// FF 75 9C            push dword [ebp - local_64h]\n\t// 56                  push    esi\n\t// 56                  push    esi\n\t// FF 15 CC C0  44 00  call dword [sym.imp.KERNEL32.dll_GetModuleHandleA]\n\t// 50                  push    eax\n\t// E8 DB DA 00 00      call    main\n\t// 89 45 A0            mov dword [ebp - local_60h], eax\n\t// 50                  push    eax\n\t// E8 2D 00 00  00     call 0x4015a6\n\tif (b[188] == 0x50 && b[201] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 201);\n\t\treturn entry;\n\t}\n\n\tif (b[292] == 0x50 && b[303] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 303);\n\t\treturn entry;\n\t}\n\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tbool sw = false;\n\tut8 b[1024] = {0};\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// mingw\n\t//55                                         push    ebp\n\t//89 E5                                      mov     ebp, esp\n\t//83 EC 08                                   sub     esp, 8\n\t//C7 04 24 01 00 00 00                       mov     dword ptr[esp], 1\n\t//FF 15 C8 63 41 00                          call    ds : __imp____set_app_type\n\t//E8 B8 FE FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\t//83 EC 1C                                   sub     esp, 1Ch\n\t//C7 04 24 01 00 00 00                       mov[esp + 1Ch + var_1C], 1\n\t//FF 15 F8 60 40 00                          call    ds : __imp____set_app_type\n\t//E8 6B FD FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\t//83 EC 0C                                            sub     esp, 0Ch\n\t//C7 05 F4 0A 81 00 00 00 00 00                       mov     ds : _mingw_app_type, 0\n\t//ED E8 3E AD 24 00                                      call    ___security_init_cookie\n\t//F2 83 C4 0C                                            add     esp, 0Ch\n\t//F5 E9 86 FC FF FF                                      jmp     ___tmainCRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\t// case1:\n\t\t// from des address of call search for a1 xx xx xx xx 89 xx xx e8 xx xx xx xx\n\t\t//A1 04 50 44 00                             mov     eax, ds:dword_445004\n\t\t//89 04 24                                   mov[esp + 28h + lpTopLevelExceptionFilter], eax\n\t\t//E8 A3 01 00 00                             call    sub_4013EE\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512] = {0};\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\t// option2: /x 8bff558bec83ec20\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) != sizeof (b)) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t/* Decode the jmp instruction, this gets the address of the 'main'\n\t   function for PE produced by a compiler whose name someone forgot to\n\t   write down. */\n\t// this is dirty only a single byte check, can return false positives\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\t// 5. ff 15 .. .. .. .. 50 e8 [main]\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (pe);\n\tif (!winmain) {\n\t\twinmain = PE_(check_mingw) (pe);\n\t\tif (!winmain) {\n\t\t\twinmain = PE_(check_unknow) (pe);\n\t\t}\n\t}\n\treturn winmain;\n}\n\nR_API PE_DWord PE_(va2pa)(RBinPEObj* pe, PE_DWord rva) {\n\tPE_DWord section_base;\n\tint i, section_size;\n\tut32 image_base = pe->nt_headers->optional_header.ImageBase;\n\tif (rva > image_base) {\n\t\trva -= image_base;\n\t}\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\tsection_base = pe->sections[i].vaddr;\n\t\tsection_size = pe->sections[i].vsize;\n\t\tif (rva >= section_base && rva < section_base + section_size) {\n\t\t\treturn pe->sections[i].paddr + (rva - section_base);\n\t\t}\n\t}\n\treturn rva;\n}\n\nut64 PE_(r_bin_pe_get_image_base)(RBinPEObj* pe) {\n\tut64 imageBase = 0;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn 0LL;\n\t}\n\timageBase = pe->nt_headers->optional_header.ImageBase;\n\tif (!imageBase) {\n\t\t//this should only happens with messed up binaries\n\t\t//XXX this value should be user defined by bin.baddr\n\t\t//but from here we can not access config API\n\t\timageBase = 0x10000;\n\t}\n\treturn imageBase;\n}\n\nstatic PE_DWord bin_pe_rva_to_va(RBinPEObj* pe, PE_DWord rva) {\n\treturn PE_(r_bin_pe_get_image_base) (pe) + rva;\n}\n\nstatic PE_DWord bin_pe_va_to_rva(RBinPEObj* pe, PE_DWord va) {\n\tut64 imageBase = PE_(r_bin_pe_get_image_base) (pe);\n\tif (va < imageBase) {\n\t\treturn va;\n\t}\n\treturn va - imageBase;\n}\n\nstatic char* resolveModuleOrdinal(Sdb* sdb, const char* module, int ordinal) {\n\tSdb* db = sdb;\n\tr_strf_var (key, 32, \"%d\", ordinal);\n\tchar* foo = sdb_get (db, key, 0);\n\tif (foo && *foo) {\n\t\treturn foo;\n\t} else {\n\t\tfree (foo); // should never happen\n\t}\n\treturn NULL;\n}\n\nstatic int bin_pe_parse_imports(RBinPEObj* pe,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname = NULL;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || !*dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&\n\t!(off = PE_(va2pa) (pe, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof (PE_DWord) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\timport_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));\n\t\tif (import_table == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"Ordinal_%i\", import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tchar* filename = NULL;\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = r_str_newf (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (filename && r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *lower_symdllname = strdup (symdllname);\n\t\t\t\t\t\tr_str_case (lower_symdllname, false);\n\t\t\t\t\t\tfilename = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, lower_symdllname);\n\t\t\t\t\t\tfree (lower_symdllname);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s\", symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", filename);\n\t\t\t\t}\n\t\t\t\tfree (filename);\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = PE_(va2pa) (pe, import_table);\n\t\t\t\tif (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\timport_hint = r_buf_read_le16_at (pe->b, off);\n\t\t\t\tif (import_hint == UT16_MAX) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tif (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tint len = snprintf (import_name, sizeof (import_name), \"%s\" , name);\n\t\t\t\tif (len >= sizeof (import_name)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", import_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!new_importp) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*importp = new_importp;\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}\n\nint PE_(read_dos_header)(RBuffer *b, PE_(image_dos_header) *header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, 0, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\theader->e_magic = r_buf_read_le16 (b);\n\theader->e_cblp = r_buf_read_le16 (b);\n\theader->e_cp = r_buf_read_le16 (b);\n\theader->e_crlc = r_buf_read_le16 (b);\n\theader->e_cparhdr = r_buf_read_le16 (b);\n\theader->e_minalloc = r_buf_read_le16 (b);\n\theader->e_maxalloc = r_buf_read_le16 (b);\n\theader->e_ss = r_buf_read_le16 (b);\n\theader->e_sp = r_buf_read_le16 (b);\n\theader->e_csum = r_buf_read_le16 (b);\n\theader->e_ip = r_buf_read_le16 (b);\n\theader->e_cs = r_buf_read_le16 (b);\n\theader->e_lfarlc = r_buf_read_le16 (b);\n\theader->e_ovno = r_buf_read_le16 (b);\n\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\theader->e_res[i] = r_buf_read_le16 (b);\n\t}\n\theader->e_oemid = r_buf_read_le16 (b);\n\theader->e_oeminfo = r_buf_read_le16 (b);\n\tfor (i = 0; i < 10; i++) {\n\t\theader->e_res2[i] = r_buf_read_le16 (b);\n\t}\n\theader->e_lfanew = r_buf_read_le32 (b);\n\tif (r_buf_seek (b, o_addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn sizeof (PE_(image_dos_header));\n}\n\nint PE_(read_nt_headers)(RBuffer *b, ut64 addr, PE_(image_nt_headers) *headers) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\theaders->Signature = r_buf_read_le32 (b);\n\theaders->file_header.Machine = r_buf_read_le16 (b);\n\theaders->file_header.NumberOfSections = r_buf_read_le16 (b);\n\theaders->file_header.TimeDateStamp = r_buf_read_le32 (b);\n\theaders->file_header.PointerToSymbolTable = r_buf_read_le32 (b);\n\theaders->file_header.NumberOfSymbols = r_buf_read_le32 (b);\n\theaders->file_header.SizeOfOptionalHeader = r_buf_read_le16 (b);\n\theaders->file_header.Characteristics = r_buf_read_le16 (b);\n\theaders->optional_header.Magic = r_buf_read_le16 (b);\n\theaders->optional_header.MajorLinkerVersion = r_buf_read8 (b);\n\theaders->optional_header.MinorLinkerVersion = r_buf_read8 (b);\n\theaders->optional_header.SizeOfCode = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfInitializedData = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfUninitializedData = r_buf_read_le32 (b);\n\theaders->optional_header.AddressOfEntryPoint = r_buf_read_le32 (b);\n\theaders->optional_header.BaseOfCode = r_buf_read_le32 (b);\n#ifdef R_BIN_PE64\n\theaders->optional_header.ImageBase = r_buf_read_le64 (b);\n#else\n\theaders->optional_header.BaseOfData = r_buf_read_le32 (b);\n\theaders->optional_header.ImageBase = r_buf_read_le32 (b);\n#endif\n\theaders->optional_header.SectionAlignment = r_buf_read_le32 (b);\n\theaders->optional_header.FileAlignment = r_buf_read_le32 (b);\n\theaders->optional_header.MajorOperatingSystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorOperatingSystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MajorImageVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorImageVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MajorSubsystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.MinorSubsystemVersion = r_buf_read_le16 (b);\n\theaders->optional_header.Win32VersionValue = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfImage = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeaders = r_buf_read_le32 (b);\n\theaders->optional_header.CheckSum = r_buf_read_le32 (b);\n\theaders->optional_header.Subsystem = r_buf_read_le16 (b);\n\theaders->optional_header.DllCharacteristics = r_buf_read_le16 (b);\n#ifdef R_BIN_PE64\n\theaders->optional_header.SizeOfStackReserve = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfStackCommit = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfHeapReserve = r_buf_read_le64 (b);\n\theaders->optional_header.SizeOfHeapCommit = r_buf_read_le64 (b);\n#else\n\theaders->optional_header.SizeOfStackReserve = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfStackCommit = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeapReserve = r_buf_read_le32 (b);\n\theaders->optional_header.SizeOfHeapCommit = r_buf_read_le32 (b);\n#endif\n\theaders->optional_header.LoaderFlags = r_buf_read_le32 (b);\n\theaders->optional_header.NumberOfRvaAndSizes = r_buf_read_le32 (b);\n\tint i;\n\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\theaders->optional_header.DataDirectory[i].VirtualAddress = r_buf_read_le32 (b);\n\t\theaders->optional_header.DataDirectory[i].Size = r_buf_read_le32 (b);\n\t}\n\tif (r_buf_seek (b, o_addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn sizeof (PE_(image_nt_headers));\n}\n\nstatic int bin_pe_init_hdr(RBinPEObj* pe) {\n\tif (!(pe->dos_header = malloc (sizeof (PE_(image_dos_header))))) {\n\t\tr_sys_perror (\"malloc (dos header)\");\n\t\treturn false;\n\t}\n\tif (PE_(read_dos_header) (pe->b, pe->dos_header) < 0) {\n\t\tpe_printf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_num_set (pe->kv, \"pe_dos_header.offset\", 0, 0);\n\tsdb_set (pe->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"\n\t\t\" e_magic e_cblp e_cp e_crlc e_cparhdr e_minalloc e_maxalloc\"\n\t\t\" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"\n\t\t\" e_oeminfo e_res2 e_lfanew\", 0);\n\tif (pe->dos_header->e_lfanew > (unsigned int) pe->size) {\n\t\tpe_printf (\"Invalid e_lfanew field\\n\");\n\t\treturn false;\n\t}\n\tif (!(pe->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {\n\t\tr_sys_perror (\"malloc (nt header)\");\n\t\treturn false;\n\t}\n\tpe->nt_header_offset = pe->dos_header->e_lfanew;\n\tif (PE_(read_nt_headers) (pe->b, pe->dos_header->e_lfanew, pe->nt_headers) < 0) {\n\t\tpe_printf (\"Warning: read (nt header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (pe->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);\n\tsdb_set (pe->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"\n\t\t\" IMAGE_SUBSYSTEM_WINDOWS_CUI=3, IMAGE_SUBSYSTEM_OS2_CUI=5, IMAGE_SUBSYSTEM_POSIX_CUI=7, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI=9, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_APPLICATION=10, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER=11, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER=12, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_ROM=13, IMAGE_SUBSYSTEM_XBOX=14, IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION=16 };\", 0);\n\tsdb_set (pe->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"\n\t\t\" IMAGE_LIBRARY_THREAD_INIT=0x0004, IMAGE_LIBRARY_THREAD_TERM=0x0008, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA=0x0020, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE=0x0040, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY=0x0080, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NX_COMPAT=0x0100, IMAGE_DLLCHARACTERISTICS_NO_ISOLATION=0x0200,IMAGE_DLLCHARACTERISTICS_NO_SEH=0x0400, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NO_BIND=0x0800, IMAGE_DLLCHARACTERISTICS_APPCONTAINER=0x1000, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER=0x2000, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_GUARD_CF=0x4000, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE=0x8000};\", 0);\n#if R_BIN_PE64\n\tsdb_num_set (pe->kv, \"pe_nt_image_headers64.offset\", pe->dos_header->e_lfanew, 0);\n\tsdb_set (pe->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);\n\tsdb_set (pe->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags\"\n\t\t\" numberOfRvaAndSizes (pe_image_data_directory)dataDirectory\", 0);\n#else\n\tsdb_num_set (pe->kv, \"pe_nt_image_headers32.offset\", pe->dos_header->e_lfanew, 0);\n\tsdb_set (pe->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);\n\tsdb_set (pe->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode baseOfData imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags numberOfRvaAndSizes\"\n\t\t\" (pe_image_data_directory)dataDirectory\", 0);\n#endif\n\tsdb_set (pe->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);\n\tsdb_set (pe->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"\n\t\t\" IMAGE_FILE_RELOCS_STRIPPED=0x0001, IMAGE_FILE_EXECUTABLE_IMAGE=0x0002, IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004, \"\n\t\t\" IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008, IMAGE_FILE_AGGRESIVE_WS_TRIM=0x0010, IMAGE_FILE_LARGE_ADDRESS_AWARE=0x0020, \"\n\t\t\" IMAGE_FILE_BYTES_REVERSED_LO=0x0080, IMAGE_FILE_32BIT_MACHINE=0x0100, IMAGE_FILE_DEBUG_STRIPPED=0x0200, \"\n\t\t\" IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP=0x0400, IMAGE_FILE_NET_RUN_FROM_SWAP=0x0800, IMAGE_FILE_SYSTEM=0x1000, \"\n\t\t\" IMAGE_FILE_DLL=0x2000, IMAGE_FILE_UP_SYSTEM_ONLY=0x4000, IMAGE_FILE_BYTES_REVERSED_HI=0x8000 };\", 0);\n\tsdb_set (pe->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"\n\t\t\" (pe_machine)machine numberOfSections timeDateStamp pointerToSymbolTable\"\n\t\t\" numberOfSymbols sizeOfOptionalHeader (pe_characteristics)characteristics\", 0);\n\tsdb_set (pe->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);\n\n\t// adding compile time to the SDB\n\t{\n\t\tsdb_num_set (pe->kv, \"image_file_header.TimeDateStamp\", pe->nt_headers->file_header.TimeDateStamp, 0);\n\t\tchar *timestr = r_time_stamp_to_str (pe->nt_headers->file_header.TimeDateStamp);\n\t\tsdb_set_owned (pe->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);\n\t}\n\tpe->optional_header = &pe->nt_headers->optional_header;\n\tpe->data_directory = (PE_(image_data_directory*)) & pe->optional_header->DataDirectory;\n\n\tif (pe->dos_header->e_magic != 0x5a4d || // \"MZ\"\n\t\t(pe->nt_headers->Signature != 0x4550 && // \"PE\"\n\t\t/* Check also for Phar Lap TNT DOS extender PL executable */\n\t\tpe->nt_headers->Signature != 0x4c50)) { // \"PL\"\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tut64 shortname;\n\tut32 value;\n\tut16 secnum;\n\tut16 symtype;\n\tut8 symclass;\n\tut8 numaux;\n} SymbolRecord;\n\nstatic struct r_bin_pe_export_t* parse_symbol_table(RBinPEObj* pe, struct r_bin_pe_export_t* exports, int sz) {\n\tut64 sym_tbl_off, num = 0;\n\tconst int srsz = COFF_SYMBOL_SIZE; // symbol record size\n\tstruct r_bin_pe_section_t* sections;\n\tstruct r_bin_pe_export_t* exp;\n\tstruct r_bin_pe_export_t* new_exports = NULL;\n\tconst size_t export_t_sz = sizeof (struct r_bin_pe_export_t);\n\tint bufsz, i, shsz;\n\tSymbolRecord sr;\n\tut64 text_off = 0LL;\n\tut64 text_rva = 0LL;\n\tint textn = 0;\n\tint exports_sz;\n\tint symctr = 0;\n\tchar* buf;\n\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\n\tsym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;\n\tnum = pe->nt_headers->file_header.NumberOfSymbols;\n\tshsz = bufsz = num * srsz;\n\tif (bufsz < 1 || bufsz > pe->size) {\n\t\treturn NULL;\n\t}\n\tbuf = calloc (num, srsz);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\texports_sz = export_t_sz * num;\n\tif (exports) {\n\t\tint osz = sz;\n\t\tsz += exports_sz;\n\t\tnew_exports = realloc (exports, sz + export_t_sz);\n\t\tif (!new_exports) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\texports = new_exports;\n\t\tnew_exports = NULL;\n\t\texp = (struct r_bin_pe_export_t*) (((const ut8*) exports) + osz);\n\t} else {\n\t\tsz = exports_sz;\n\t\texports = malloc (sz + export_t_sz);\n\t\texp = exports;\n\t}\n\n\tsections = pe->sections;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t//XXX search by section with +x permission since the section can be left blank\n\t\tif (!strcmp ((char*) sections[i].name, \".text\")) {\n\t\t\ttext_rva = sections[i].vaddr;\n\t\t\ttext_off = sections[i].paddr;\n\t\t\ttextn = i + 1;\n\t\t}\n\t}\n\tsymctr = 0;\n\tif (r_buf_read_at (pe->b, sym_tbl_off, (ut8*) buf, bufsz) > 0) {\n\t\tfor (i = 0; i < shsz; i += srsz) {\n\t\t\t// sr = (SymbolRecord*) (buf + i);\n\t\t\tif (i + sizeof (sr) >= bufsz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy (&sr, buf + i, sizeof (sr));\n\t\t\t//pe_printf (\"SECNUM %d\\n\", sr.secnum);\n\t\t\tif (sr.secnum == textn) {\n\t\t\t\tif (sr.symtype == 32) {\n\t\t\t\t\tchar shortname[9];\n\t\t\t\t\tmemcpy (shortname, &sr.shortname, 8);\n\t\t\t\t\tshortname[8] = 0;\n\t\t\t\t\tif (*shortname) {\n\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, shortname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar* longname, name[128];\n\t\t\t\t\t\tut32 idx = r_read_le32 (buf + i + 4);\n\t\t\t\t\t\tif (r_buf_read_at (pe->b, sym_tbl_off + idx + shsz, (ut8*) name, 128)) { // == 128) {\n\t\t\t\t\t\t\tlongname = name;\n\t\t\t\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, longname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf ((char*) exp[symctr].name, \"unk_%d\", symctr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texp[symctr].name[PE_NAME_LENGTH] = '\\0';\n\t\t\t\t\texp[symctr].libname[0] = '\\0';\n\t\t\t\t\texp[symctr].vaddr = bin_pe_rva_to_va (pe, text_rva + sr.value);\n\t\t\t\t\texp[symctr].paddr = text_off + sr.value;\n\t\t\t\t\texp[symctr].ordinal = symctr;\n\t\t\t\t\texp[symctr].forwarder[0] = 0;\n\t\t\t\t\texp[symctr].last = 0;\n\t\t\t\t\tsymctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t} // for\n\t} // if read ok\n\texp[symctr].last = 1;\n\tfree (buf);\n\treturn exports;\n}\n\nint PE_(read_image_section_header)(RBuffer *b, ut64 addr, PE_(image_section_header) *section_header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\tsection_header->Name[0] = 0;\n\t\treturn -1;\n\t}\n\n\tut8 buf[sizeof (PE_(image_section_header))] = {0};\n\tr_buf_read (b, buf, sizeof (buf));\n\tmemcpy (section_header->Name, buf, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), Misc.PhysicalAddress, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), VirtualAddress, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), SizeOfRawData, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToRawData, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToRelocations, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), PointerToLinenumbers, 32);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), NumberOfRelocations, 16);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), NumberOfLinenumbers, 16);\n\tPE_READ_STRUCT_FIELD (section_header, PE_(image_section_header), Characteristics, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_section_header));\n}\n\nvoid PE_(write_image_section_header)(RBuffer *b, ut64 addr, PE_(image_section_header) *section_header) {\n\tut8 buf[sizeof (PE_(image_section_header))];\n\tmemcpy (buf, section_header->Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tr_write_at_le32 (buf, section_header->Misc.PhysicalAddress, PE_IMAGE_SIZEOF_SHORT_NAME);\n\tr_write_at_le32 (buf, section_header->VirtualAddress, PE_IMAGE_SIZEOF_SHORT_NAME + 4);\n\tr_write_at_le32 (buf, section_header->SizeOfRawData, PE_IMAGE_SIZEOF_SHORT_NAME + 8);\n\tr_write_at_le32 (buf, section_header->PointerToRawData, PE_IMAGE_SIZEOF_SHORT_NAME + 12);\n\tr_write_at_le32 (buf, section_header->PointerToRelocations, PE_IMAGE_SIZEOF_SHORT_NAME + 16);\n\tr_write_at_le32 (buf, section_header->PointerToLinenumbers, PE_IMAGE_SIZEOF_SHORT_NAME + 20);\n\tr_write_at_le16 (buf, section_header->NumberOfRelocations, PE_IMAGE_SIZEOF_SHORT_NAME + 24);\n\tr_write_at_le16 (buf, section_header->NumberOfLinenumbers, PE_IMAGE_SIZEOF_SHORT_NAME + 26);\n\tr_write_at_le32 (buf, section_header->Characteristics, PE_IMAGE_SIZEOF_SHORT_NAME + 28);\n\tr_buf_write_at (b, addr, buf, sizeof (PE_(image_section_header)));\n}\n\nstatic struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe);\nstatic int bin_pe_init_sections(RBinPEObj* pe) {\n\tpe->num_sections = pe->nt_headers->file_header.NumberOfSections;\n\tif (pe->num_sections < 1) {\n\t\treturn true;\n\t}\n\tint sections_size = sizeof (PE_(image_section_header)) * pe->num_sections;\n\tif (sections_size > pe->size) {\n\t\tsections_size = pe->size;\n\t\tpe->num_sections = pe->size / sizeof (PE_(image_section_header));\n\t\t// massage this to make corkami happy\n\t\t//pe_printf (\"Invalid NumberOfSections value\\n\");\n\t\t//goto out_error;\n\t}\n\tif (!(pe->section_header = malloc (sections_size))) {\n\t\tr_sys_perror (\"malloc (section header)\");\n\t\tgoto out_error;\n\t}\n\tpe->section_header_offset = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +\n\t\tpe->nt_headers->file_header.SizeOfOptionalHeader;\n\tint i;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\tif (PE_(read_image_section_header) (pe->b, pe->section_header_offset + i * sizeof (PE_(image_section_header)),\n\t\t\tpe->section_header + i) < 0) {\n\t\t\tpe_printf (\"Warning: read (sections)\\n\");\n\t\t\tR_FREE (pe->section_header);\n\t\t\tgoto out_error;\n\t\t}\n\t}\n#if 0\n\tEach symbol table entry includes a name, storage class, type, value and section number.Short names (8 characters or fewer) are stored directly in the symbol table;\n\tlonger names are stored as an paddr into the string table at the end of the COFF object.\n\n\t================================================================\n\tCOFF SYMBOL TABLE RECORDS (18 BYTES)\n\t================================================================\n\trecord\n\tpaddr\n\n\tstruct symrec {\n\t\tunion {\n\t\t\tchar string[8]; // short name\n\t\t\tstruct {\n\t\t\t\tut32 seros;\n\t\t\t\tut32 stridx;\n\t\t\t} stridx;\n\t\t} name;\n\t\tut32 value;\n\t\tut16 secnum;\n\t\tut16 symtype;\n\t\tut8 symclass;\n\t\tut8 numaux;\n\t}\n\t------------------------------------------------------ -\n\t0 | 8 - char symbol name |\n\t| or 32 - bit zeroes followed by 32 - bit |\n\t| index into string table |\n\t------------------------------------------------------ -\n\t8 | symbol value |\n\t------------------------------------------------------ -\n\t0Ch | section number | symbol type |\n\t------------------------------------------------------ -\n\t10h | sym class | num aux |\n\t-------------------------- -\n\t12h\n\n#endif\n\treturn true;\nout_error:\n\tpe->num_sections = 0;\n\treturn false;\n}\n\nint PE_(bin_pe_get_claimed_checksum)(RBinPEObj* pe) {\n\tif (!pe || !pe->optional_header) {\n\t\treturn 0;\n\t}\n\treturn pe->optional_header->CheckSum;\n}\n\nint PE_(bin_pe_get_actual_checksum)(RBinPEObj* pe) {\n\tsize_t i, j, checksum_offset = 0;\n\tut64 computed_cs = 0;\n\tint remaining_bytes;\n\tint shift;\n\tut32 cur;\n\tif (!pe || !pe->nt_header_offset) {\n\t\treturn 0;\n\t}\n\tconst size_t buf_sz = 0x1000;\n\tut32 *buf = malloc (buf_sz);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\tif (r_buf_read_at (pe->b, 0, (ut8 *)buf, buf_sz) < 0) {\n\t\tfree (buf);\n\t\treturn 0;\n\t}\n\tchecksum_offset = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;\n\tfor (i = 0, j = 0; i < pe->size / 4; i++) {\n\t\tcur = r_read_at_ble32 (buf, j * 4, pe->endian);\n\t\tj++;\n\t\t// skip the checksum bytes\n\t\tif (i * 4 == checksum_offset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t\tif (j == buf_sz / 4) {\n\t\t\tif (r_buf_read_at (pe->b, (i + 1) * 4, (ut8 *)buf, buf_sz) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t// add resultant bytes to checksum\n\tremaining_bytes = pe->size % 4;\n\ti = i * 4;\n\tif (remaining_bytes != 0) {\n\t\tcur = r_buf_read8_at (pe->b, i);\n\t\tshift = 8;\n\t\tfor (j = 1; j < remaining_bytes; j++, shift += 8) {\n\t\t\tcur |= r_buf_read8_at (pe->b, i + j) << shift;\n\t\t}\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// 32bits -> 16bits\n\tcomputed_cs = (computed_cs & 0xFFFF) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs & 0xFFFF);\n\n\t// add filesize\n\tcomputed_cs += pe->size;\n\tfree (buf);\n\treturn computed_cs;\n}\n\nstatic const char* PE_(bin_pe_get_claimed_authentihash)(RBinPEObj* pe) {\n\tif (!pe->spcinfo) {\n\t\treturn NULL;\n\t}\n\tRASN1Binary *digest = pe->spcinfo->messageDigest.digest;\n\treturn digest? r_hex_bin2strdup (digest->binary, digest->length): NULL;\n}\n\nconst char* PE_(bin_pe_compute_authentihash)(RBinPEObj* pe) {\n\tif (!pe->spcinfo || !pe->spcinfo->messageDigest.digestAlgorithm.algorithm) {\n\t\treturn NULL;\n\t}\n\n\tchar *hashtype = strdup (pe->spcinfo->messageDigest.digestAlgorithm.algorithm->string);\n\tr_str_replace_char (hashtype, '-', 0);\n\tut64 algobit = r_hash_name_to_bits (hashtype);\n\tif (!(algobit & (R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256))) {\n\t\teprintf (\"Authenticode only supports md5, sha1, sha256. This PE uses %s\\n\", hashtype);\n\t\tfree (hashtype);\n\t\treturn NULL;\n\t}\n\tfree (hashtype);\n\tut32 checksum_paddr = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;\n\tut32 security_entry_offset =  pe->nt_header_offset + sizeof (PE_(image_nt_headers)) - 96;\n\tPE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];\n\tPE_DWord security_dir_offset = data_dir_security->VirtualAddress;\n\tut32 security_dir_size = data_dir_security->Size;\n\n\tRBuffer *buf = r_buf_new ();\n\tr_buf_append_buf_slice (buf, pe->b, 0, checksum_paddr);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tchecksum_paddr + 4,\n\t\tsecurity_entry_offset - checksum_paddr - 4);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tsecurity_entry_offset + 8,\n\t\tsecurity_dir_offset - security_entry_offset - 8);\n\tr_buf_append_buf_slice (buf, pe->b,\n\t\tsecurity_dir_offset + security_dir_size,\n\t\tr_buf_size (pe->b) - security_dir_offset - security_dir_size);\n\n\tut64 len;\n\tconst ut8 *data = r_buf_data (buf, &len);\n\tchar *hashstr = NULL;\n\tRHash *ctx = r_hash_new (true, algobit);\n\tif (ctx) {\n\t\tr_hash_do_begin (ctx, algobit);\n\t\tint digest_size = r_hash_calculate (ctx, algobit, data, len);\n\t\tr_hash_do_end (ctx, algobit);\n\t\thashstr = r_hex_bin2strdup (ctx->digest, digest_size);\n\t\tr_buf_free (buf);\n\t\tr_hash_free (ctx);\n\t}\n\treturn hashstr;\n}\n\nconst char* PE_(bin_pe_get_authentihash)(RBinPEObj* pe) {\n\treturn pe->authentihash;\n}\n\nint PE_(bin_pe_is_authhash_valid)(RBinPEObj* pe) {\n\treturn pe? pe->is_authhash_valid: false;\n}\n\nstatic void computeOverlayOffset(ut64 offset, ut64 size, ut64 file_size, ut64* largest_offset, ut64* largest_size) {\n\tif (offset + size <= file_size && offset + size > (*largest_offset + *largest_size)) {\n\t\t*largest_offset = offset;\n\t\t*largest_size = size;\n\t}\n}\n\n/* Inspired from https://github.com/erocarrera/pefile/blob/master/pefile.py#L5425 */\nint PE_(bin_pe_get_overlay)(RBinPEObj* pe, ut64* size) {\n\tut64 largest_offset = 0;\n\tut64 largest_size = 0;\n\t*size = 0;\n\tint i;\n\n\tif (!pe) {\n\t\treturn 0;\n\t}\n\n\tif (pe->optional_header) {\n\t\tcomputeOverlayOffset (\n\t\t\t\tpe->nt_header_offset+4+sizeof (pe->nt_headers->file_header),\n\t\t\t\tpe->nt_headers->file_header.SizeOfOptionalHeader,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t}\n\n\tstruct r_bin_pe_section_t *sects = pe->sections;\n\tfor (i = 0; !sects[i].last; i++) {\n\t\tcomputeOverlayOffset(\n\t\t\t\tsects[i].paddr,\n\t\t\t\tsects[i].size,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size\n\t\t\t\t);\n\t}\n\n\tif (pe->optional_header) {\n\t\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\t\tif (i == PE_IMAGE_DIRECTORY_ENTRY_SECURITY) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomputeOverlayOffset (\n\t\t\t\tPE_(va2pa) (pe, pe->data_directory[i].VirtualAddress),\n\t\t\t\tpe->data_directory[i].Size,\n\t\t\t\tpe->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t\t}\n\n\t}\n\n\tif ((ut64) pe->size > largest_offset + largest_size) {\n\t\t*size = pe->size - largest_offset - largest_size;\n\t\treturn largest_offset + largest_size;\n\t}\n\treturn 0;\n}\n\nstatic int bin_pe_read_metadata_string(char* to, RBuffer *frombuf, int fromoff) {\n\tint covered = 0;\n\t*to = 0;\n\twhile (covered < MAX_METADATA_STRING_LENGTH) {\n\t\tconst char covch = r_buf_read8_at (frombuf, fromoff + covered);\n\t\tto[covered++] = covch;\n\t\tif (!covch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (covered % 4 != 0) { covered++; }\n\treturn covered;\n}\n\nstatic bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {\n\tPE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));\n\tif (!metadata) {\n\t\treturn false;\n\t}\n\tPE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;\n\tif (!metadata_directory) {\n\t\tfree (metadata);\n\t\treturn false;\n\t}\n\tint rr = r_buf_fread_at (pe->b, metadata_directory,\n\t\t(ut8*) metadata, pe->big_endian? \"1I2S\": \"1i2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 8,\n\t\t(ut8*) (&metadata->Reserved), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (pe->b, metadata_directory + 12,\n\t\t(ut8*) (&metadata->VersionStringLength), pe->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Metadata Signature: 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d\\n\",\n\t\t(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);\n\n\t// read the version string\n\tint len = metadata->VersionStringLength; // XXX: dont trust this length\n\tif (len > 0) {\n\t\tmetadata->VersionString = calloc (1, len + 1);\n\t\tif (!metadata->VersionString) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\trr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);\n\t\tif (rr != len) {\n\t\t\teprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");\n\t\t\tfree (metadata->VersionString);\n\t\t\tfree (metadata);\n\t\t\treturn 0;\n\t\t}\n\t\teprintf (\".NET Version: %s\\n\", metadata->VersionString);\n\t}\n\n\t// read the header after the string\n\trr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,\n\t\t(ut8*) (&metadata->Flags), pe->big_endian? \"2S\": \"2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);\n\tpe->metadata_header = metadata;\n\n\n\t// read metadata streams\n\tint stream_addr = metadata_directory + 20 + metadata->VersionStringLength;\n\tPE_(image_metadata_stream) * stream;\n\tPE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);\n\tif (!streams) {\n\t\tgoto fail;\n\t}\n\tint count;\n\tfor (count = 0; count < metadata->NumberOfStreams; count++) {\n\t\tstream = R_NEW0 (PE_(image_metadata_stream));\n\t\tif (!stream) {\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {\n\t\t\teprintf (\"Truncated\\n\");\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? \"2I\": \"2i\", 1) < 1) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"DirectoryAddress: %x Size: %x\\n\", stream->Offset, stream->Size);\n\t\tchar* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);\n\n\t\tif (!stream_name) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tint c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);\n\t\tif (c == 0) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"Stream name: %s %d\\n\", stream_name, c);\n\t\tstream->Name = stream_name;\n\t\tstreams[count] = stream;\n\t\tstream_addr += 8 + c;\n\t}\n\tpe->streams = streams;\n\treturn true;\nfail:\n\teprintf (\"Warning: read (metadata header)\\n\");\n\tfree (metadata);\n\treturn false;\n}\n\nstatic int bin_pe_init_overlay(RBinPEObj* pe) {\n\tut64 pe_overlay_size;\n\tut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (pe, &pe_overlay_size);\n\tif (pe_overlay_offset) {\n\t\tsdb_num_set (pe->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);\n\t\tsdb_num_set (pe->kv, \"pe_overlay.size\", pe_overlay_size, 0);\n\t}\n\treturn 0;\n}\n\nstatic int read_image_clr_header(RBuffer *b, ut64 addr, PE_(image_clr_header) *header) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_clr_header))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), HeaderSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MajorRuntimeVersion, 16);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MinorRuntimeVersion, 16);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MetaDataDirectoryAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), MetaDataDirectorySize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), Flags, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), EntryPointToken, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ResourcesDirectoryAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ResourcesDirectorySize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), StrongNameSignatureAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), StrongNameSignatureSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), CodeManagerTableAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), CodeManagerTableSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), VTableFixupsAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), VTableFixupsSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ExportAddressTableJumpsAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ExportAddressTableJumpsSize, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ManagedNativeHeaderAddress, 32);\n\tPE_READ_STRUCT_FIELD (header, PE_(image_clr_header), ManagedNativeHeaderSize, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_clr_header));\n}\n\nstatic int bin_pe_init_clr_hdr(RBinPEObj* pe) {\n\tPE_(image_data_directory) * clr_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];\n\tPE_DWord image_clr_hdr_paddr = PE_(va2pa) (pe, clr_dir->VirtualAddress);\n\t// int clr_dir_size = clr_dir? clr_dir->Size: 0;\n\tPE_(image_clr_header) * clr_hdr = R_NEW0 (PE_(image_clr_header));\n\tint rr, len = sizeof (PE_(image_clr_header));\n\n\tif (!clr_hdr) {\n\t\treturn 0;\n\t}\n\trr = read_image_clr_header (pe->b, image_clr_hdr_paddr, clr_hdr);\n\n//\tprintf(\"%x\\n\", clr_hdr->HeaderSize);\n\n\tif (clr_hdr->HeaderSize != 0x48) {\n\t\t// probably not a .NET binary\n\t\t// 64bit?\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\tif (rr != len) {\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\n\tpe->clr_hdr = clr_hdr;\n\treturn 1;\n}\n\nstatic int read_image_import_directory(RBuffer *b, ut64 addr, PE_(image_import_directory) *import_dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_import_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), ForwarderChain, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (import_dir, PE_(image_import_directory), FirstThunk, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_import_directory));\n}\n\nstatic int read_image_delay_import_directory(RBuffer *b, ut64 addr, PE_(image_delay_import_directory) *directory) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_delay_import_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), Attributes, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), ModulePlugin, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), DelayImportAddressTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), DelayImportNameTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), BoundDelayImportTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), UnloadDelayImportTable, 32);\n\tPE_READ_STRUCT_FIELD (directory, PE_(image_delay_import_directory), TimeStamp, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_delay_import_directory));\n}\n\nstatic int bin_pe_init_imports(RBinPEObj* pe) {\n\tPE_(image_data_directory) * data_dir_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];\n\tPE_(image_data_directory) * data_dir_delay_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];\n\n\tPE_DWord import_dir_paddr = PE_(va2pa) (pe, data_dir_import->VirtualAddress);\n\tPE_DWord import_dir_offset = PE_(va2pa) (pe, data_dir_import->VirtualAddress);\n\tPE_DWord delay_import_dir_offset = data_dir_delay_import\n\t? PE_(va2pa) (pe, data_dir_delay_import->VirtualAddress)\n\t\t\t\t\t: 0;\n\n\tPE_(image_import_directory) * import_dir = NULL;\n\tPE_(image_import_directory) * new_import_dir = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\n\tPE_(image_delay_import_directory) * delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * new_delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\n\tint dir_size = sizeof (PE_(image_import_directory));\n\tint delay_import_size = sizeof (PE_(image_delay_import_directory));\n\tint indx = 0;\n\tint rr, count = 0;\n\tint import_dir_size = data_dir_import->Size;\n\tint delay_import_dir_size = data_dir_delay_import->Size;\n\t/// HACK to modify import size because of begin 0.. this may report wrong info con corkami tests\n\tif (!import_dir_size) {\n\t\t// asume 1 entry for each\n\t\timport_dir_size = data_dir_import->Size = 0xffff;\n\t}\n\tif (!delay_import_dir_size) {\n\t\t// asume 1 entry for each\n\t\tdelay_import_dir_size = data_dir_delay_import->Size = 0xffff;\n\t}\n\tint maxidsz = R_MIN ((PE_DWord) pe->size, import_dir_offset + import_dir_size);\n\tmaxidsz -= import_dir_offset;\n\tif (maxidsz < 0) {\n\t\tmaxidsz = 0;\n\t}\n\t//int maxcount = maxidsz/ sizeof (struct r_bin_pe_import_t);\n\n\tR_FREE (pe->import_directory);\n\tif (import_dir_paddr != 0) {\n\t\tif (import_dir_size < 1 || import_dir_size > maxidsz) {\n\t\t\tpe_printf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);\n\t\t\timport_dir_size = maxidsz;\n\t\t}\n\t\tpe->import_directory_offset = import_dir_offset;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tnew_import_dir = (PE_(image_import_directory)*)realloc (import_dir, ((1 + indx) * dir_size));\n\t\t\tif (!new_import_dir) {\n\t\t\t\tr_sys_perror (\"malloc (import directory)\");\n\t\t\t\tR_FREE (import_dir);\n\t\t\t\tbreak; //\n\t\t\t\t//\t\t\tgoto fail;\n\t\t\t}\n\t\t\timport_dir = new_import_dir;\n\t\t\tnew_import_dir = NULL;\n\t\t\tcurr_import_dir = import_dir + indx;\n\t\t\tif (read_image_import_directory (pe->b, import_dir_offset + indx * dir_size, curr_import_dir) <= 0) {\n\t\t\t\tpe_printf (\"Warning: read (import directory)\\n\");\n\t\t\t\tR_FREE (import_dir);\n\t\t\t\tbreak; //return false;\n\t\t\t}\n\t\t\tif (((2 + indx) * dir_size) > import_dir_size) {\n\t\t\t\tbreak; //goto fail;\n\t\t\t}\n\t\t\tindx++;\n\t\t\tcount++;\n\t\t} while (curr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\tcurr_import_dir->ForwarderChain != 0);\n\n\t\tpe->import_directory = import_dir;\n\t\tpe->import_directory_size = import_dir_size;\n\t}\n\n\tindx = 0;\n\tif (r_buf_size (pe->b) > 0) {\n\t\tif ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32)r_buf_size (pe->b))) {\n\t\t\tut64 off;\n\t\t\tpe->delay_import_directory_offset = delay_import_dir_offset;\n\t\t\tdo {\n\t\t\t\tindx++;\n\t\t\t\toff = indx * delay_import_size;\n\t\t\t\tif (off >= r_buf_size (pe->b)) {\n\t\t\t\t\tpe_printf (\"Warning: Cannot find end of import symbols\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew_delay_import_dir = (PE_(image_delay_import_directory)*)realloc (\n\t\t\t\t\tdelay_import_dir, (indx * delay_import_size) + 1);\n\t\t\t\tif (!new_delay_import_dir) {\n\t\t\t\t\tr_sys_perror (\"malloc (delay import directory)\");\n\t\t\t\t\tfree (delay_import_dir);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdelay_import_dir = new_delay_import_dir;\n\t\t\t\tcurr_delay_import_dir = delay_import_dir + (indx - 1);\n\t\t\t\trr = read_image_delay_import_directory (pe->b, delay_import_dir_offset + (indx - 1) * delay_import_size,\n\t\t\t\t\tcurr_delay_import_dir);\n\t\t\t\tif (rr != dir_size) {\n\t\t\t\t\tpe_printf (\"Warning: read (delay import directory)\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t} while (curr_delay_import_dir->Name != 0);\n\t\t\tpe->delay_import_directory = delay_import_dir;\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\tR_FREE (import_dir);\n\tpe->import_directory = import_dir;\n\tfree (delay_import_dir);\n\treturn false;\n}\n\nstatic int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_export_directory))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);\n\tPE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_export_directory));\n}\n\nstatic int bin_pe_init_exports(RBinPEObj* pe) {\n\tPE_(image_data_directory) * data_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\tPE_DWord export_dir_paddr = PE_(va2pa) (pe, data_dir_export->VirtualAddress);\n\tif (!export_dir_paddr) {\n\t\t// This export-dir-paddr should only appear in DLL files\n\t\t// pe_printf (\"Warning: Cannot find the paddr of the export directory\\n\");\n\t\treturn false;\n\t}\n\t// sdb_setn (DB, \"hdr.exports_directory\", export_dir_paddr);\n\t// pe_printf (\"Pexports paddr at 0x%\"PFMT64x\"\\n\", export_dir_paddr);\n\tif (!(pe->export_directory = malloc (sizeof (PE_(image_export_directory))))) {\n\t\tr_sys_perror (\"malloc (export directory)\");\n\t\treturn false;\n\t}\n\tif (read_image_export_directory (pe->b, export_dir_paddr, pe->export_directory) < 0) {\n\t\tpe_printf (\"Warning: read (export directory)\\n\");\n\t\tR_FREE (pe->export_directory);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _free_resource(r_pe_resource *rs) {\n\tif (rs) {\n\t\tfree (rs->name);\n\t\tfree (rs->timestr);\n\t\tfree (rs->data);\n\t\tfree (rs->type);\n\t\tfree (rs->language);\n\t\tfree (rs);\n\t}\n}\n\nstatic int read_image_resource_directory(RBuffer *b, ut64 addr, Pe_image_resource_directory *dir) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tdir->Characteristics = r_buf_read_le32 (b);\n\tdir->TimeDateStamp = r_buf_read_le32 (b);\n\tdir->MajorVersion = r_buf_read_le16 (b);\n\tdir->MinorVersion = r_buf_read_le16 (b);\n\tdir->NumberOfNamedEntries = r_buf_read_le16 (b);\n\tdir->NumberOfIdEntries = r_buf_read_le16 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_directory);\n}\n\nstatic int bin_pe_init_resource(RBinPEObj* pe) {\n\tPE_(image_data_directory) * resource_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];\n\tPE_DWord resource_dir_paddr = PE_(va2pa) (pe, resource_dir->VirtualAddress);\n\tif (!resource_dir_paddr) {\n\t\treturn false;\n\t}\n\n\tpe->resources = r_list_newf ((RListFree)_free_resource);\n\tif (!pe->resources) {\n\t\treturn false;\n\t}\n\tif (!(pe->resource_directory = malloc (sizeof (*pe->resource_directory)))) {\n\t\tr_sys_perror (\"malloc (resource directory)\");\n\t\treturn false;\n\t}\n\tif (read_image_resource_directory (pe->b, resource_dir_paddr, pe->resource_directory) < 0) {\n\t\tpe_printf (\"Warning: read (resource directory)\\n\");\n\t\tR_FREE (pe->resource_directory);\n\t\treturn false;\n\t}\n\tpe->resource_directory_offset = resource_dir_paddr;\n\treturn true;\n}\n\nstatic void bin_pe_store_tls_callbacks(RBinPEObj* pe, PE_DWord callbacks) {\n\tr_strf_buffer (64);\n\tPE_DWord paddr, haddr;\n\tint count = 0;\n\tPE_DWord addressOfTLSCallback = 1;\n\tchar* key;\n\n\twhile (addressOfTLSCallback != 0) {\n\t\taddressOfTLSCallback = R_BUF_READ_PE_DWORD_AT (pe->b, callbacks);\n\t\tif (addressOfTLSCallback == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (tls_callback)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!addressOfTLSCallback) {\n\t\t\tbreak;\n\t\t}\n\t\tif (pe->optional_header->SizeOfImage) {\n\t\t\tint rva_callback = bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback);\n\t\t\tif (rva_callback > pe->optional_header->SizeOfImage) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkey = r_strf (\"pe.tls_callback%d_vaddr\", count);\n\t\tsdb_num_set (pe->kv, key, addressOfTLSCallback, 0);\n\t\tkey = r_strf (\"pe.tls_callback%d_paddr\", count);\n\t\tpaddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback));\n\t\tsdb_num_set (pe->kv, key, paddr, 0);\n\t\tkey = r_strf (\"pe.tls_callback%d_haddr\", count);\n\t\thaddr = callbacks;\n\t\tsdb_num_set (pe->kv, key, haddr, 0);\n\t\tcount++;\n\t\tcallbacks += sizeof (addressOfTLSCallback);\n\t}\n}\n\nstatic int read_tls_directory(RBuffer *b, ut64 addr, PE_(image_tls_directory) *tls_directory) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\ttls_directory->StartAddressOfRawData = r_buf_read_le32 (b);\n\ttls_directory->EndAddressOfRawData = r_buf_read_le32 (b);\n\ttls_directory->AddressOfIndex = r_buf_read_le32 (b);\n\ttls_directory->AddressOfCallBacks = r_buf_read_le32 (b);\n\ttls_directory->SizeOfZeroFill = r_buf_read_le32 (b);\n\ttls_directory->Characteristics = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_tls_directory));\n}\n\nstatic int bin_pe_init_tls(RBinPEObj* pe) {\n\tPE_(image_tls_directory) * image_tls_directory;\n\tPE_(image_data_directory) * data_dir_tls = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];\n\tPE_DWord tls_paddr = PE_(va2pa) (pe, data_dir_tls->VirtualAddress);\n\n\timage_tls_directory = R_NEW0 (PE_(image_tls_directory));\n\tif (read_tls_directory (pe->b, tls_paddr, image_tls_directory) < 0) {\n\t\tpe_printf (\"Warning: read (image_tls_directory)\\n\");\n\t\tfree (image_tls_directory);\n\t\treturn 0;\n\t}\n\tpe->tls_directory = image_tls_directory;\n\tif (!image_tls_directory->AddressOfCallBacks) {\n\t\treturn 0;\n\t}\n\tif (image_tls_directory->EndAddressOfRawData < image_tls_directory->StartAddressOfRawData) {\n\t\treturn 0;\n\t}\n\tPE_DWord callbacks_paddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe,\n\t\t\t(PE_DWord) image_tls_directory->AddressOfCallBacks));\n\tbin_pe_store_tls_callbacks (pe, callbacks_paddr);\n\treturn 0;\n}\n\nstatic void free_Var(Var* var) {\n\tif (var) {\n\t\tfree (var->szKey);\n\t\tfree (var->Value);\n\t\tfree (var);\n\t}\n}\n\nstatic void free_VarFileInfo(VarFileInfo* varFileInfo) {\n\tif (varFileInfo) {\n\t\tfree (varFileInfo->szKey);\n\t\tif (varFileInfo->Children) {\n\t\t\tut32 children = 0;\n\t\t\tfor (; children < varFileInfo->numOfChildren; children++) {\n\t\t\t\tfree_Var (varFileInfo->Children[children]);\n\t\t\t}\n\t\t\tfree (varFileInfo->Children);\n\t\t}\n\t\tfree (varFileInfo);\n\t}\n}\n\nstatic void free_String(String* string) {\n\tif (string) {\n\t\tfree (string->szKey);\n\t\tfree (string->Value);\n\t\tfree (string);\n\t}\n}\n\nstatic void free_StringTable(StringTable* stringTable) {\n\tif (stringTable) {\n\t\tfree (stringTable->szKey);\n\t\tif (stringTable->Children) {\n\t\t\tut32 childrenST = 0;\n\t\t\tfor (; childrenST < stringTable->numOfChildren; childrenST++) {\n\t\t\t\tfree_String (stringTable->Children[childrenST]);\n\t\t\t}\n\t\t\tfree (stringTable->Children);\n\t\t}\n\t\tfree (stringTable);\n\t}\n}\n\nstatic void free_StringFileInfo(StringFileInfo* stringFileInfo) {\n\tif (stringFileInfo) {\n\t\tfree (stringFileInfo->szKey);\n\t\tif (stringFileInfo->Children) {\n\t\t\tut32 childrenSFI = 0;\n\t\t\tfor (; childrenSFI < stringFileInfo->numOfChildren; childrenSFI++) {\n\t\t\t\tfree_StringTable (stringFileInfo->Children[childrenSFI]);\n\t\t\t}\n\t\t\tfree (stringFileInfo->Children);\n\t\t}\n\t\tfree (stringFileInfo);\n\t}\n}\n\n#define align32(x) x = (((x) & 0x3) == 0)? (x): ((x) & ~0x3) + 0x4;\n\nstatic void free_VS_VERSIONINFO(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (vs_VersionInfo) {\n\t\tfree (vs_VersionInfo->szKey);\n\t\tfree (vs_VersionInfo->Value);\n\t\tfree_VarFileInfo (vs_VersionInfo->varFileInfo);\n\t\tfree_StringFileInfo (vs_VersionInfo->stringFileInfo);\n\t\tfree (vs_VersionInfo);\n\t}\n}\n\nvoid PE_(free_VS_VERSIONINFO)(PE_VS_VERSIONINFO * vs_VersionInfo) {\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n}\n\nstatic Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {\n\tVar* var = calloc (1, sizeof (*var));\n\tif (!var) {\n\t\tpe_printf (\"Warning: calloc (Var)\\n\");\n\t\treturn NULL;\n\t}\n\tif ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wLength);\n\tif ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wValueLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wValueLength);\n\tif ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (var->wType);\n\tif (var->wType != 0 && var->wType != 1) {\n\t\tpe_printf (\"Warning: check (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\tvar->numOfValues = var->wValueLength / 4;\n\tif (!var->numOfValues) {\n\t\tpe_printf (\"Warning: check (Var numOfValues)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tvar->Value = (ut32*) malloc (var->wValueLength);\n\tif (!var->Value) {\n\t\tpe_printf (\"Warning: malloc (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {\n\t\tpe_printf (\"Warning: read (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += var->wValueLength;\n\treturn var;\n}\n\nstatic VarFileInfo* Pe_r_bin_pe_parse_var_file_info(RBinPEObj* pe, PE_DWord* curAddr) {\n\tVarFileInfo* varFileInfo = calloc (1, sizeof (*varFileInfo));\n\tif (!varFileInfo) {\n\t\tpe_printf (\"Warning: calloc (VarFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = *curAddr;\n\tif ((varFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wLength);\n\n\tif ((varFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wValueLength);\n\n\tif (varFileInfo->wValueLength != 0) {\n\t\tpe_printf (\"Warning: check (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif ((varFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (varFileInfo->wType);\n\tif (varFileInfo->wType && varFileInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tvarFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (VARFILEINFO_UTF_16_LEN ));  //L\"VarFileInfo\"\n\tif (!varFileInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += VARFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\twhile (startAddr + varFileInfo->wLength > *curAddr) {\n\t\tVar** tmp = (Var**) realloc (varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof (*varFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (VarFileInfo Children)\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->Children = tmp;\n\t\tif (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing Var\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\treturn varFileInfo;\n}\n\nstatic String* Pe_r_bin_pe_parse_string(RBinPEObj* pe, PE_DWord* curAddr) {\n\tString* string = calloc (1, sizeof (*string));\n\tPE_DWord begAddr = *curAddr;\n\tint len_value = 0;\n\tint i = 0;\n\tif (!string) {\n\t\tpe_printf (\"Warning: calloc (String)\\n\");\n\t\treturn NULL;\n\t}\n\tif (begAddr > pe->size || begAddr + sizeof (string->wLength) > pe->size) {\n\t\tfree_String (string);\n\t\treturn NULL;\n\t}\n\tif ((string->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wLength);\n\tif (*curAddr > pe->size || *curAddr + sizeof (string->wValueLength) > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif ((string->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wValueLength);\n\n\tif (*curAddr > pe->size || *curAddr + sizeof (string->wType) > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif ((string->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof (string->wType);\n\tif (string->wType != 0 && string->wType != 1) {\n\t\tpe_printf (\"Warning: check (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tfor (i = 0; *curAddr < begAddr + string->wLength; i++, *curAddr += sizeof (ut16)) {\n\t\tut16 utf16_char;\n\t\tut16 *tmpKey;\n\t\tif (*curAddr > pe->size || *curAddr + sizeof (ut16) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\tpe_printf (\"Warning: check (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\ttmpKey = (ut16*) realloc (string->szKey, (i + 1) * sizeof (ut16));\n\t\tif (!tmpKey) {\n\t\t\tpe_printf (\"Warning: realloc (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tstring->szKey = tmpKey;\n\t\tstring->szKey[i] = utf16_char;\n\t\tstring->wKeyLen += sizeof (ut16);\n\t\tif (!utf16_char) {\n\t\t\t*curAddr += sizeof (ut16);\n\t\t\tbreak;\n\t\t}\n\t}\n\talign32 (*curAddr);\n\tlen_value = R_MIN (string->wValueLength * 2, string->wLength - (*curAddr - begAddr));\n\tstring->wValueLength = len_value;\n\tif (len_value < 0) {\n\t\tlen_value = 0;\n\t}\n\tstring->Value = (ut16*) calloc (len_value + 1, 1);\n\tif (!string->Value) {\n\t\tpe_printf (\"Warning: malloc (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\tif (*curAddr > pe->size || *curAddr + len_value > pe->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {\n\t\tpe_printf (\"Warning: read (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += len_value;\n\treturn string;\nout_error:\n\tfree_String (string);\n\treturn NULL;\n}\n\nstatic StringTable* Pe_r_bin_pe_parse_string_table(RBinPEObj* pe, PE_DWord* curAddr) {\n\tStringTable* stringTable = calloc (1, sizeof (*stringTable));\n\tif (!stringTable) {\n\t\tpe_printf (\"Warning: calloc (stringTable)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\tif ((stringTable->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wLength);\n\n\tif ((stringTable->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wValueLength);\n\n\tif (stringTable->wValueLength) {\n\t\tpe_printf (\"Warning: check (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif ((stringTable->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringTable->wType);\n\tif (stringTable->wType && stringTable->wType != 1) {\n\t\tpe_printf (\"Warning: check (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\tstringTable->szKey = (ut16*) malloc (UT16_ALIGN (EIGHT_HEX_DIG_UTF_16_LEN));  //EIGHT_HEX_DIG_UTF_16_LEN\n\tif (!stringTable->szKey) {\n\t\tpe_printf (\"Warning: malloc (stringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (StringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += EIGHT_HEX_DIG_UTF_16_LEN;\n\talign32 (*curAddr);\n\twhile (startAddr + stringTable->wLength > *curAddr) {\n\t\tString** tmp = (String**) realloc (stringTable->Children, (stringTable->numOfChildren + 1) * sizeof (*stringTable->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (StringTable Children)\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->Children = tmp;\n\t\tif (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing String\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringTable->numOfChildren) {\n\t\tpe_printf (\"Warning: check (StringTable numOfChildren)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\treturn stringTable;\n}\n\nstatic StringFileInfo* Pe_r_bin_pe_parse_string_file_info(RBinPEObj* pe, PE_DWord* curAddr) {\n\tStringFileInfo* stringFileInfo = calloc (1, sizeof (*stringFileInfo));\n\tif (!stringFileInfo) {\n\t\tpe_printf (\"Warning: calloc (StringFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\n\tif ((stringFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wLength);\n\n\tif ((stringFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wValueLength);\n\n\tif (stringFileInfo->wValueLength) {\n\t\tpe_printf (\"Warning: check (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif ((stringFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof (stringFileInfo->wType);\n\n\tif (stringFileInfo->wType && stringFileInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tstringFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (STRINGFILEINFO_UTF_16_LEN));  //L\"StringFileInfo\"\n\tif (!stringFileInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += STRINGFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {\n\t\tpe_printf (\"Warning: check (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\talign32 (*curAddr);\n\n\twhile (startAddr + stringFileInfo->wLength > *curAddr) {\n\t\tStringTable** tmp = (StringTable**) realloc (stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof (*stringFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tpe_printf (\"Warning: realloc (StringFileInfo Children)\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->Children = tmp;\n\t\tif (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (pe, curAddr))) {\n\t\t\tpe_printf (\"Warning: bad parsing StringTable\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringFileInfo->numOfChildren) {\n\t\tpe_printf (\"Warning: check (StringFileInfo numOfChildren)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\treturn stringFileInfo;\n}\n\n#define EXIT_ON_OVERFLOW(S)\\\n\tif (curAddr > pe->size || curAddr + (S) > pe->size) { \\\n\t\tgoto out_error; }\nstatic PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(RBinPEObj* pe, PE_DWord version_info_paddr) {\n\tut32 sz;\n\tPE_VS_VERSIONINFO* vs_VersionInfo = calloc (1, sizeof (PE_VS_VERSIONINFO));\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = version_info_paddr;\n\tPE_DWord curAddr = version_info_paddr;\n\t//align32(curAddr); // XXX: do we really need this? Because in msdn\n\t//wLength is The length, in bytes, of the VS_VERSIONINFO structure.\n\t//This length does not include any padding that aligns any subsequent\n\t//version resource data on a 32-bit boundary.\n\t//Mb we are in subsequent version resource data and not aligned.\n\tsz = sizeof (ut16);\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wValueLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif ((vs_VersionInfo->wType = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {\n\t\tpe_printf (\"Warning: check (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tvs_VersionInfo->szKey = (ut16*) malloc (UT16_ALIGN (VS_VERSION_INFO_UTF_16_LEN));  //L\"VS_VERSION_INFO\"\n\tif (!vs_VersionInfo->szKey) {\n\t\tpe_printf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tsz = VS_VERSION_INFO_UTF_16_LEN;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {\n\t\tpe_printf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (memcmp (vs_VersionInfo->szKey, VS_VERSION_INFO_UTF_16, sz)) {\n\t\tgoto out_error;\n\t}\n\talign32 (curAddr);\n\tif (vs_VersionInfo->wValueLength) {\n\t\tif (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {\n\t\t\tpe_printf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tvs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO*) malloc (sizeof (*vs_VersionInfo->Value));\n\t\tif (!vs_VersionInfo->Value) {\n\t\t\tpe_printf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tsz = sizeof (PE_VS_FIXEDFILEINFO);\n\t\tEXIT_ON_OVERFLOW (sz);\n\t\tif (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {\n\t\t\tpe_printf (\"Warning: read (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {\n\t\t\tpe_printf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurAddr += sz;\n\t\talign32 (curAddr);\n\t}\n\n\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\tchar t = '\\0';\n\t\tif (curAddr + 3 * sizeof (ut16) > pe->size || curAddr + 3 + sizeof (ut64) + 1 > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, curAddr + 3 * sizeof (ut16), (ut8*) &t, 1) != 1) {\n\t\t\tpe_printf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (!(t == 'S' || t == 'V')) {\n\t\t\tpe_printf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (t == 'S') {\n\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t\tif (t == 'V') {\n\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\n\t\talign32 (curAddr);\n\n\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\tif (t == 'V') {\n\t\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {\n\t\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t} else if (t == 'S') {\n\t\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {\n\t\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\t\tpe_printf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\treturn vs_VersionInfo;\nout_error:\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\treturn NULL;\n\n}\n\nstatic Sdb* Pe_r_bin_store_var(Var* var) {\n\tunsigned int i = 0;\n\tchar key[20];\n\tSdb* sdb = NULL;\n\tif (var) {\n\t\tsdb = sdb_new0 ();\n\t\tif (sdb) {\n\t\t\tfor (; i < var->numOfValues; i++) {\n\t\t\t\tsnprintf (key, 20, \"%d\", i);\n\t\t\t\tsdb_num_set (sdb, key, var->Value[i], 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_var_file_info(VarFileInfo* varFileInfo) {\n\tchar key[20];\n\tunsigned int i = 0;\n\tif (!varFileInfo) {\n\t\treturn NULL;\n\t}\n\tSdb* sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < varFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"var%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_var (varFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string(String* string) {\n\tSdb* sdb = NULL;\n\tchar* encodedVal = NULL, * encodedKey = NULL;\n\tif (!string) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) string->szKey, string->wKeyLen);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tencodedVal = sdb_encode ((unsigned char*) string->Value, string->wValueLength);\n\tif (!encodedVal) {\n\t\tfree (encodedKey);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\",   encodedKey, 0);\n\tsdb_set (sdb, \"value\", encodedVal, 0);\n\tfree (encodedKey);\n\tfree (encodedVal);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_table(StringTable* stringTable) {\n\tchar key[20];\n\tchar* encodedKey = NULL;\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringTable) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\", encodedKey, 0);\n\tfree (encodedKey);\n\tfor (; i < stringTable->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"string%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string (stringTable->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_file_info(StringFileInfo* stringFileInfo) {\n\tchar key[30];\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < stringFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 30, \"stringtable%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string_table (stringFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_fixed_file_info(PE_VS_FIXEDFILEINFO* vs_fixedFileInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_fixedFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tsdb_num_set (sdb, \"Signature\",        vs_fixedFileInfo->dwSignature,        0);\n\tsdb_num_set (sdb, \"StrucVersion\",     vs_fixedFileInfo->dwStrucVersion,     0);\n\tsdb_num_set (sdb, \"FileVersionMS\",    vs_fixedFileInfo->dwFileVersionMS,    0);\n\tsdb_num_set (sdb, \"FileVersionLS\",    vs_fixedFileInfo->dwFileVersionLS,    0);\n\tsdb_num_set (sdb, \"ProductVersionMS\", vs_fixedFileInfo->dwProductVersionMS, 0);\n\tsdb_num_set (sdb, \"ProductVersionLS\", vs_fixedFileInfo->dwProductVersionLS, 0);\n\tsdb_num_set (sdb, \"FileFlagsMask\",    vs_fixedFileInfo->dwFileFlagsMask,    0);\n\tsdb_num_set (sdb, \"FileFlags\",        vs_fixedFileInfo->dwFileFlags,        0);\n\tsdb_num_set (sdb, \"FileOS\",           vs_fixedFileInfo->dwFileOS,           0);\n\tsdb_num_set (sdb, \"FileType\",         vs_fixedFileInfo->dwFileType,         0);\n\tsdb_num_set (sdb, \"FileSubtype\",      vs_fixedFileInfo->dwFileSubtype,      0);\n\tsdb_num_set (sdb, \"FileDateMS\",       vs_fixedFileInfo->dwFileDateMS,       0);\n\tsdb_num_set (sdb, \"FileDateLS\",       vs_fixedFileInfo->dwFileDateLS,       0);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_resource_version_info(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (vs_VersionInfo->Value) {\n\t\tsdb_ns_set (sdb, \"fixed_file_info\", Pe_r_bin_store_fixed_file_info (vs_VersionInfo->Value));\n\t}\n\tif (vs_VersionInfo->varFileInfo) {\n\t\tsdb_ns_set (sdb, \"var_file_info\", Pe_r_bin_store_var_file_info (vs_VersionInfo->varFileInfo));\n\t}\n\tif (vs_VersionInfo->stringFileInfo) {\n\t\tsdb_ns_set (sdb, \"string_file_info\", Pe_r_bin_store_string_file_info (vs_VersionInfo->stringFileInfo));\n\t}\n\treturn sdb;\n}\n\nstatic char* _known_product_ids(int id) {\n\tswitch (id) {\n\tcase 0: return  \"Unknown\";\n\tcase 1: return  \"Import0\";\n\tcase 2: return  \"Linker510\";\n\tcase 3: return  \"Cvtomf510\";\n\tcase 4: return  \"Linker600\";\n\tcase 5: return  \"Cvtomf600\";\n\tcase 6: return  \"Cvtres500\";\n\tcase 7: return  \"Utc11_Basic\";\n\tcase 8: return  \"Utc11_C\";\n\tcase 9: return  \"Utc12_Basic\";\n\tcase 10: return  \"Utc12_C\";\n\tcase 11: return  \"Utc12_CPP\";\n\tcase 12: return  \"AliasObj60\";\n\tcase 13: return  \"VisualBasic60\";\n\tcase 14: return  \"Masm613\";\n\tcase 15: return  \"Masm710\";\n\tcase 16: return  \"Linker511\";\n\tcase 17: return  \"Cvtomf511\";\n\tcase 18: return  \"Masm614\";\n\tcase 19: return  \"Linker512\";\n\tcase 20: return  \"Cvtomf512\";\n\tcase 21: return  \"Utc12_C_Std\";\n\tcase 22: return  \"Utc12_CPP_Std\";\n\tcase 23: return  \"Utc12_C_Book\";\n\tcase 24: return  \"Utc12_CPP_Book\";\n\tcase 25: return  \"Implib700\";\n\tcase 26: return  \"Cvtomf700\";\n\tcase 27: return  \"Utc13_Basic\";\n\tcase 28: return  \"Utc13_C\";\n\tcase 29: return  \"Utc13_CPP\";\n\tcase 30: return  \"Linker610\";\n\tcase 31: return  \"Cvtomf610\";\n\tcase 32: return  \"Linker601\";\n\tcase 33: return  \"Cvtomf601\";\n\tcase 34: return  \"Utc12_1_Basic\";\n\tcase 35: return  \"Utc12_1_C\";\n\tcase 36: return  \"Utc12_1_CPP\";\n\tcase 37: return  \"Linker620\";\n\tcase 38: return  \"Cvtomf620\";\n\tcase 39: return  \"AliasObj70\";\n\tcase 40: return  \"Linker621\";\n\tcase 41: return  \"Cvtomf621\";\n\tcase 42: return  \"Masm615\";\n\tcase 43: return  \"Utc13_LTCG_C\";\n\tcase 44: return  \"Utc13_LTCG_CPP\";\n\tcase 45: return  \"Masm620\";\n\tcase 46: return  \"ILAsm100\";\n\tcase 47: return  \"Utc12_2_Basic\";\n\tcase 48: return  \"Utc12_2_C\";\n\tcase 49: return  \"Utc12_2_CPP\";\n\tcase 50: return  \"Utc12_2_C_Std\";\n\tcase 51: return  \"Utc12_2_CPP_Std\";\n\tcase 52: return  \"Utc12_2_C_Book\";\n\tcase 53: return  \"Utc12_2_CPP_Book\";\n\tcase 54: return  \"Implib622\";\n\tcase 55: return  \"Cvtomf622\";\n\tcase 56: return  \"Cvtres501\";\n\tcase 57: return  \"Utc13_C_Std\";\n\tcase 58: return  \"Utc13_CPP_Std\";\n\tcase 59: return  \"Cvtpgd1300\";\n\tcase 60: return  \"Linker622\";\n\tcase 61: return  \"Linker700\";\n\tcase 62: return  \"Export622\";\n\tcase 63: return  \"Export700\";\n\tcase 64: return  \"Masm700\";\n\tcase 65: return  \"Utc13_POGO_I_C\";\n\tcase 66: return  \"Utc13_POGO_I_CPP\";\n\tcase 67: return  \"Utc13_POGO_O_C\";\n\tcase 68: return  \"Utc13_POGO_O_CPP\";\n\tcase 69: return  \"Cvtres700\";\n\tcase 70: return  \"Cvtres710p\";\n\tcase 71: return  \"Linker710p\";\n\tcase 72: return  \"Cvtomf710p\";\n\tcase 73: return  \"Export710p\";\n\tcase 74: return  \"Implib710p\";\n\tcase 75: return  \"Masm710p\";\n\tcase 76: return  \"Utc1310p_C\";\n\tcase 77: return  \"Utc1310p_CPP\";\n\tcase 78: return  \"Utc1310p_C_Std\";\n\tcase 79: return  \"Utc1310p_CPP_Std\";\n\tcase 80: return  \"Utc1310p_LTCG_C\";\n\tcase 81: return  \"Utc1310p_LTCG_CPP\";\n\tcase 82: return  \"Utc1310p_POGO_I_C\";\n\tcase 83: return  \"Utc1310p_POGO_I_CPP\";\n\tcase 84: return  \"Utc1310p_POGO_O_C\";\n\tcase 85: return  \"Utc1310p_POGO_O_CPP\";\n\tcase 86: return  \"Linker624\";\n\tcase 87: return  \"Cvtomf624\";\n\tcase 88: return  \"Export624\";\n\tcase 89: return  \"Implib624\";\n\tcase 90: return  \"Linker710\";\n\tcase 91: return  \"Cvtomf710\";\n\tcase 92: return  \"Export710\";\n\tcase 93: return  \"Implib710\";\n\tcase 94: return  \"Cvtres710\";\n\tcase 95: return  \"Utc1310_C\";\n\tcase 96: return  \"Utc1310_CPP\";\n\tcase 97: return  \"Utc1310_C_Std\";\n\tcase 98: return  \"Utc1310_CPP_Std\";\n\tcase 99: return  \"Utc1310_LTCG_C\";\n\tcase 100: return  \"Utc1310_LTCG_CPP\";\n\tcase 101: return  \"Utc1310_POGO_I_C\";\n\tcase 102: return  \"Utc1310_POGO_I_CPP\";\n\tcase 103: return  \"Utc1310_POGO_O_C\";\n\tcase 104: return  \"Utc1310_POGO_O_CPP\";\n\tcase 105: return  \"AliasObj710\";\n\tcase 106: return  \"AliasObj710p\";\n\tcase 107: return  \"Cvtpgd1310\";\n\tcase 108: return  \"Cvtpgd1310p\";\n\tcase 109: return  \"Utc1400_C\";\n\tcase 110: return  \"Utc1400_CPP\";\n\tcase 111: return  \"Utc1400_C_Std\";\n\tcase 112: return  \"Utc1400_CPP_Std\";\n\tcase 113: return  \"Utc1400_LTCG_C\";\n\tcase 114: return  \"Utc1400_LTCG_CPP\";\n\tcase 115: return  \"Utc1400_POGO_I_C\";\n\tcase 116: return  \"Utc1400_POGO_I_CPP\";\n\tcase 117: return  \"Utc1400_POGO_O_C\";\n\tcase 118: return  \"Utc1400_POGO_O_CPP\";\n\tcase 119: return  \"Cvtpgd1400\";\n\tcase 120: return  \"Linker800\";\n\tcase 121: return  \"Cvtomf800\";\n\tcase 122: return  \"Export800\";\n\tcase 123: return  \"Implib800\";\n\tcase 124: return  \"Cvtres800\";\n\tcase 125: return  \"Masm800\";\n\tcase 126: return  \"AliasObj800\";\n\tcase 127: return  \"PhoenixPrerelease\";\n\tcase 128: return  \"Utc1400_CVTCIL_C\";\n\tcase 129: return  \"Utc1400_CVTCIL_CPP\";\n\tcase 130: return  \"Utc1400_LTCG_MSIL\";\n\tcase 131: return  \"Utc1500_C\";\n\tcase 132: return  \"Utc1500_CPP\";\n\tcase 133: return  \"Utc1500_C_Std\";\n\tcase 134: return  \"Utc1500_CPP_Std\";\n\tcase 135: return  \"Utc1500_CVTCIL_C\";\n\tcase 136: return  \"Utc1500_CVTCIL_CPP\";\n\tcase 137: return  \"Utc1500_LTCG_C\";\n\tcase 138: return  \"Utc1500_LTCG_CPP\";\n\tcase 139: return  \"Utc1500_LTCG_MSIL\";\n\tcase 140: return  \"Utc1500_POGO_I_C\";\n\tcase 141: return  \"Utc1500_POGO_I_CPP\";\n\tcase 142: return  \"Utc1500_POGO_O_C\";\n\tcase 143: return  \"Utc1500_POGO_O_CPP\";\n\n\tcase 144: return  \"Cvtpgd1500\";\n\tcase 145: return  \"Linker900\";\n\tcase 146: return  \"Export900\";\n\tcase 147: return  \"Implib900\";\n\tcase 148: return  \"Cvtres900\";\n\tcase 149: return  \"Masm900\";\n\tcase 150: return  \"AliasObj900\";\n\tcase 151: return  \"Resource900\";\n\n\tcase 152: return  \"AliasObj1000\";\n\tcase 154: return  \"Cvtres1000\";\n\tcase 155: return  \"Export1000\";\n\tcase 156: return  \"Implib1000\";\n\tcase 157: return  \"Linker1000\";\n\tcase 158: return  \"Masm1000\";\n\n\tcase 170: return  \"Utc1600_C\";\n\tcase 171: return  \"Utc1600_CPP\";\n\tcase 172: return  \"Utc1600_CVTCIL_C\";\n\tcase 173: return  \"Utc1600_CVTCIL_CPP\";\n\tcase 174: return  \"Utc1600_LTCG_C \";\n\tcase 175: return  \"Utc1600_LTCG_CPP\";\n\tcase 176: return  \"Utc1600_LTCG_MSIL\";\n\tcase 177: return  \"Utc1600_POGO_I_C\";\n\tcase 178: return  \"Utc1600_POGO_I_CPP\";\n\tcase 179: return  \"Utc1600_POGO_O_C\";\n\tcase 180: return  \"Utc1600_POGO_O_CPP\";\n\n\tcase 183: return  \"Linker1010\";\n\tcase 184: return  \"Export1010\";\n\tcase 185: return  \"Implib1010\";\n\tcase 186: return  \"Cvtres1010\";\n\tcase 187: return  \"Masm1010\";\n\tcase 188: return  \"AliasObj1010\";\n\n\tcase 199: return  \"AliasObj1100\";\n\tcase 201: return  \"Cvtres1100\";\n\tcase 202: return  \"Export1100\";\n\tcase 203: return  \"Implib1100\";\n\tcase 204: return  \"Linker1100\";\n\tcase 205: return  \"Masm1100\";\n\n\tcase 206: return  \"Utc1700_C\";\n\tcase 207: return  \"Utc1700_CPP\";\n\tcase 208: return  \"Utc1700_CVTCIL_C\";\n\tcase 209: return  \"Utc1700_CVTCIL_CPP\";\n\tcase 210: return  \"Utc1700_LTCG_C \";\n\tcase 211: return  \"Utc1700_LTCG_CPP\";\n\tcase 212: return  \"Utc1700_LTCG_MSIL\";\n\tcase 213: return  \"Utc1700_POGO_I_C\";\n\tcase 214: return  \"Utc1700_POGO_I_CPP\";\n\tcase 215: return  \"Utc1700_POGO_O_C\";\n\tcase 216: return  \"Utc1700_POGO_O_CPP\";\n\n\tcase 219: return  \"Cvtres1200\";\n\tcase 220: return  \"Export1200\";\n\tcase 221: return  \"Implib1200\";\n\tcase 222: return  \"Linker1200\";\n\tcase 223: return  \"Masm1200\";\n\t\t// Speculation\n\tcase 224: return  \"AliasObj1200\";\n\n\tcase 237: return  \"Cvtres1210\";\n\tcase 238: return  \"Export1210\";\n\tcase 239: return  \"Implib1210\";\n\tcase 240: return  \"Linker1210\";\n\tcase 241: return  \"Masm1210\";\n\t\t// Speculation\n\tcase 242: return  \"Utc1810_C\";\n\tcase 243: return  \"Utc1810_CPP\";\n\tcase 244: return  \"Utc1810_CVTCIL_C\";\n\tcase 245: return  \"Utc1810_CVTCIL_CPP\";\n\tcase 246: return  \"Utc1810_LTCG_C \";\n\tcase 247: return  \"Utc1810_LTCG_CPP\";\n\tcase 248: return  \"Utc1810_LTCG_MSIL\";\n\tcase 249: return  \"Utc1810_POGO_I_C\";\n\tcase 250: return  \"Utc1810_POGO_I_CPP\";\n\tcase 251: return  \"Utc1810_POGO_O_C\";\n\tcase 252: return  \"Utc1810_POGO_O_CPP\";\n\n\tcase 255: return  \"Cvtres1400\";\n\tcase 256: return  \"Export1400\";\n\tcase 257: return  \"Implib1400\";\n\tcase 258: return  \"Linker1400\";\n\tcase 259: return  \"Masm1400\";\n\n\tcase 260: return  \"Utc1900_C\";\n\tcase 261: return  \"Utc1900_CPP\";\n\t\t// Speculation\n\tcase 262: return  \"Utc1900_CVTCIL_C\";\n\tcase 263: return  \"Utc1900_CVTCIL_CPP\";\n\tcase 264: return  \"Utc1900_LTCG_C \";\n\tcase 265: return  \"Utc1900_LTCG_CPP\";\n\tcase 266: return  \"Utc1900_LTCG_MSIL\";\n\tcase 267: return  \"Utc1900_POGO_I_C\";\n\tcase 268: return  \"Utc1900_POGO_I_CPP\";\n\tcase 269: return  \"Utc1900_POGO_O_C\";\n\tcase 270: return  \"Utc1900_POGO_O_CPP\";\n\tdefault: return \"Unknown\";\n\t}\n}\n\nstatic void bin_pe_init_rich_info(RBinPEObj *pe) {\n\tif (!pe->rich_entries) {\n\t\tpe->rich_entries = r_list_newf (free);\n\t}\n\tpe->rich_header_offset = pe->nt_header_offset;\n\tut64 off = pe->nt_header_offset - sizeof (ut32);\n\tut32 magic = 0x68636952; // Rich\n\tif (off % sizeof (ut32)) {\n\t\treturn;\n\t}\n\twhile ((r_buf_read_le32_at (pe->b, off) != magic) && off) {\n\t\toff -= sizeof (ut32);\n\t}\n\tif (!off) {\n\t\treturn;\n\t}\n\tut32 mask = r_buf_read_le32_at (pe->b, off + sizeof (ut32));\n\tmagic = 0x536E6144; // DanS\n\tint data;\n\toff -= sizeof (ut32);\n\twhile (((data = r_buf_read_le32_at (pe->b, off)) != magic) && data ^ mask && off > 0x80) {\n\t\tPe_image_rich_entry *entry = R_NEW0 (Pe_image_rich_entry);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\t\tentry->timesUsed = data ^ mask;\n\t\toff -= sizeof (ut32);\n\t\tdata = r_buf_read_le32_at (pe->b, off) ^ mask;\n\t\tentry->productId = data >> 16;\n\t\tentry->minVersion = data & 0xFFFF;\n\t\tentry->productName = _known_product_ids (entry->productId);\n\t\toff -= sizeof (ut32);\n\t\tr_list_append (pe->rich_entries, entry);\n\t}\n\tpe->rich_header_offset = off + sizeof (ut32);\n}\n\nstatic char* _resource_lang_str(int id) {\n\tswitch (id) {\n\tcase 0x00: return \"LANG_NEUTRAL\";\n\tcase 0x7f: return \"LANG_INVARIANT\";\n\tcase 0x36: return \"LANG_AFRIKAANS\";\n\tcase 0x1c: return \"LANG_ALBANIAN \";\n\tcase 0x01: return \"LANG_ARABIC\";\n\tcase 0x2b: return \"LANG_ARMENIAN\";\n\tcase 0x4d: return \"LANG_ASSAMESE\";\n\tcase 0x2c: return \"LANG_AZERI\";\n\tcase 0x2d: return \"LANG_BASQUE\";\n\tcase 0x23: return \"LANG_BELARUSIAN\";\n\tcase 0x45: return \"LANG_BENGALI\";\n\tcase 0x02: return \"LANG_BULGARIAN\";\n\tcase 0x03: return \"LANG_CATALAN\";\n\tcase 0x04: return \"LANG_CHINESE\";\n\tcase 0x1a: return \"LANG_CROATIAN\";\n\tcase 0x05: return \"LANG_CZECH\";\n\tcase 0x06: return \"LANG_DANISH\";\n\tcase 0x65: return \"LANG_DIVEHI\";\n\tcase 0x13: return \"LANG_DUTCH\";\n\tcase 0x09: return \"LANG_ENGLISH\";\n\tcase 0x25: return \"LANG_ESTONIAN\";\n\tcase 0x38: return \"LANG_FAEROESE\";\n\tcase 0x29: return \"LANG_FARSI\";\n\tcase 0x0b: return \"LANG_FINNISH\";\n\tcase 0x0c: return \"LANG_FRENCH\";\n\tcase 0x56: return \"LANG_GALICIAN\";\n\tcase 0x37: return \"LANG_GEORGIAN\";\n\tcase 0x07: return \"LANG_GERMAN\";\n\tcase 0x08: return \"LANG_GREEK\";\n\tcase 0x47: return \"LANG_GUJARATI\";\n\tcase 0x0d: return \"LANG_HEBREW\";\n\tcase 0x39: return \"LANG_HINDI\";\n\tcase 0x0e: return \"LANG_HUNGARIAN\";\n\tcase 0x0f: return \"LANG_ICELANDIC\";\n\tcase 0x21: return \"LANG_INDONESIAN\";\n\tcase 0x10: return \"LANG_ITALIAN\";\n\tcase 0x11: return \"LANG_JAPANESE\";\n\tcase 0x4b: return \"LANG_KANNADA\";\n\tcase 0x60: return \"LANG_KASHMIRI\";\n\tcase 0x3f: return \"LANG_KAZAK\";\n\tcase 0x57: return \"LANG_KONKANI\";\n\tcase 0x12: return \"LANG_KOREAN\";\n\tcase 0x40: return \"LANG_KYRGYZ\";\n\tcase 0x26: return \"LANG_LATVIAN\";\n\tcase 0x27: return \"LANG_LITHUANIAN\";\n\tcase 0x2f: return \"LANG_MACEDONIAN\";\n\tcase 0x3e: return \"LANG_MALAY\";\n\tcase 0x4c: return \"LANG_MALAYALAM\";\n\tcase 0x58: return \"LANG_MANIPURI\";\n\tcase 0x4e: return \"LANG_MARATHI\";\n\tcase 0x50: return \"LANG_MONGOLIAN\";\n\tcase 0x61: return \"LANG_NEPALI\";\n\tcase 0x14: return \"LANG_NORWEGIAN\";\n\tcase 0x48: return \"LANG_ORIYA\";\n\tcase 0x15: return \"LANG_POLISH\";\n\tcase 0x16: return \"LANG_PORTUGUESE\";\n\tcase 0x46: return \"LANG_PUNJABI\";\n\tcase 0x18: return \"LANG_ROMANIAN\";\n\tcase 0x19: return \"LANG_RUSSIAN\";\n\tcase 0x4f: return \"LANG_SANSKRIT\";\n\tcase 0x59: return \"LANG_SINDHI\";\n\tcase 0x1b: return \"LANG_SLOVAK\";\n\tcase 0x24: return \"LANG_SLOVENIAN\";\n\tcase 0x0a: return \"LANG_SPANISH \";\n\tcase 0x41: return \"LANG_SWAHILI\";\n\tcase 0x1d: return \"LANG_SWEDISH\";\n\tcase 0x5a: return \"LANG_SYRIAC\";\n\tcase 0x49: return \"LANG_TAMIL\";\n\tcase 0x44: return \"LANG_TATAR\";\n\tcase 0x4a: return \"LANG_TELUGU\";\n\tcase 0x1e: return \"LANG_THAI\";\n\tcase 0x1f: return \"LANG_TURKISH\";\n\tcase 0x22: return \"LANG_UKRAINIAN\";\n\tcase 0x20: return \"LANG_URDU\";\n\tcase 0x43: return \"LANG_UZBEK\";\n\tcase 0x2a: return \"LANG_VIETNAMESE\";\n\tcase 0x3c: return \"LANG_GAELIC\";\n\tcase 0x3a: return \"LANG_MALTESE\";\n\tcase 0x28: return \"LANG_MAORI\";\n\tcase 0x17: return \"LANG_RHAETO_ROMANCE\";\n\tcase 0x3b: return \"LANG_SAAMI\";\n\tcase 0x2e: return \"LANG_SORBIAN\";\n\tcase 0x30: return \"LANG_SUTU\";\n\tcase 0x31: return \"LANG_TSONGA\";\n\tcase 0x32: return \"LANG_TSWANA\";\n\tcase 0x33: return \"LANG_VENDA\";\n\tcase 0x34: return \"LANG_XHOSA\";\n\tcase 0x35: return \"LANG_ZULU\";\n\tcase 0x8f: return \"LANG_ESPERANTO\";\n\tcase 0x90: return \"LANG_WALON\";\n\tcase 0x91: return \"LANG_CORNISH\";\n\tcase 0x92: return \"LANG_WELSH\";\n\tcase 0x93: return \"LANG_BRETON\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic char* _resource_type_str(int type) {\n\tconst char * typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \"CURSOR\";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \"BITMAP\";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \"ICON\";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \"MENU\";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \"DIALOG\";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \"STRING\";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \"FONTDIR\";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \"FONT\";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \"ACCELERATOR\";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \"RCDATA\";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \"MESSAGETABLE\";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \"GROUP_CURSOR\";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \"GROUP_ICON\";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \"VERSION\";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \"DLGINCLUDE\";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \"PLUGPLAY\";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \"VXD\";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \"ANICURSOR\";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \"ANIICON\";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \"HTML\";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \"MANIFEST\";\n\t\tbreak;\n\tdefault: return r_str_newf (\"UNKNOWN (%d)\",type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic int read_image_resource_directory_entry(RBuffer *b, ut64 addr, Pe_image_resource_directory_entry *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tentry->u1.Name = r_buf_read_le32 (b);\n\tentry->u2.OffsetToData = r_buf_read_le32 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_directory_entry);\n}\n\nstatic int read_image_resource_data_entry(RBuffer *b, ut64 addr, Pe_image_resource_data_entry *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (Pe_image_resource_data_entry)];\n\tr_buf_read (b, buf, sizeof (Pe_image_resource_data_entry));\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, OffsetToData, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, Size, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, CodePage, 32);\n\tPE_READ_STRUCT_FIELD (entry, Pe_image_resource_data_entry, Reserved, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (Pe_image_resource_data_entry);\n}\n\nstatic void _parse_resource_directory(RBinPEObj *pe, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, HtUU *dirs, const char *resource_name) {\n\tchar *resourceEntryName = NULL;\n\tint index = 0;\n\tut32 totalRes = dir->NumberOfNamedEntries + dir->NumberOfIdEntries;\n\tut64 rsrc_base = pe->resource_directory_offset;\n\tut64 off;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry entry;\n\t\toff = rsrc_base + offDir + sizeof (*dir) + index * sizeof (entry);\n\t\tif (ht_uu_find (dirs, off, NULL)) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_insert (dirs, off, 1);\n\t\tif (off > pe->size || off + sizeof (entry) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_directory_entry (pe->b, off, &entry) < 0) {\n\t\t\teprintf (\"Warning: read resource entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (entry.u1.Name >> 31) {\n\t\t\tint i;\n\t\t\tut16 buf;\n\t\t\tut32 NameOffset = entry.u1.Name & 0x7fffffff;\n\t\t\tif (r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset, (ut8*)&buf, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut16 resourceEntryNameLength = r_read_le16 (&buf);\n\t\t\tresourceEntryName = calloc (resourceEntryNameLength + 1, 1);\n\t\t\tif (resourceEntryName) {\n\t\t\t\tfor (i = 0; i < resourceEntryNameLength; i++) { /* Convert Unicode to ASCII */\n\t\t\t\t\tut8 byte;\n\t\t\t\t\tint r = r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset + 2 + (i*2), &byte, sizeof (ut8));\n\t\t\t\t\tif (r != sizeof (ut8) || !byte) {\n\t\t\t\t\t\tR_FREE (resourceEntryName);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresourceEntryName[i] = byte;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry.u2.OffsetToData >> 31) {\n\t\t\t//detect here malicious file trying to making us infinite loop\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\tut32 OffsetToDirectory = entry.u2.OffsetToData & 0x7fffffff;\n\t\t\toff = rsrc_base + OffsetToDirectory;\n\t\t\tint len = read_image_resource_directory (pe->b, off, &identEntry);\n\t\t\tif (len < 1 || len != sizeof (Pe_image_resource_directory)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (pe, &identEntry, OffsetToDirectory, type, entry.u1.Name & 0xffff, dirs, resourceEntryName);\n\t\t\tR_FREE (resourceEntryName);\n\t\t\tcontinue;\n\t\t}\n\t\tR_FREE (resourceEntryName);\n\n\t\tPe_image_resource_data_entry *data = R_NEW0 (Pe_image_resource_data_entry);\n\t\tif (!data) {\n\t\t\tbreak;\n\t\t}\n\t\toff = rsrc_base + entry.u2.OffsetToData;\n\t\tif (off > pe->size || off + sizeof (*data) > pe->size) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_data_entry (pe->b, off, data) != sizeof (*data)) {\n\t\t\teprintf (\"Warning: read (resource data entry)\\n\");\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (type == PE_RESOURCE_ENTRY_VERSION) {\n\t\t\tchar key[64];\n\t\t\tint counter = 0;\n\t\t\tSdb *sdb = sdb_new0 ();\n\t\t\tif (!sdb) {\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord data_paddr = PE_(va2pa) (pe, data->OffsetToData);\n\t\t\tif (!data_paddr) {\n\t\t\t\tpe_printf (\"Warning: bad RVA in resource data entry\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord cur_paddr = data_paddr;\n\t\t\tif ((cur_paddr & 0x3) != 0) {\n\t\t\t\tpe_printf (\"Warning: not aligned version info address\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (cur_paddr < (data_paddr + data->Size) && cur_paddr < pe->size) {\n\t\t\t\tPE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (pe, cur_paddr);\n\t\t\t\tif (!vs_VersionInfo) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnprintf (key, 30, \"VS_VERSIONINFO%d\", counter++);\n\t\t\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_resource_version_info (vs_VersionInfo));\n\t\t\t\tif (vs_VersionInfo->wLength < 1) {\n\t\t\t\t\t// Invalid version length\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_paddr += vs_VersionInfo->wLength;\n\t\t\t\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\t\t\t\talign32 (cur_paddr);\n\t\t\t}\n\t\t\tsdb_ns_set (pe->kv, \"vs_version_info\", sdb);\n\t\t}\n\t\tr_pe_resource *rs = R_NEW0 (r_pe_resource);\n\t\tif (!rs) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\t/* Compare compileTimeStamp to resource timestamp to figure out if DOS date or POSIX date */\n\t\tif (r_time_stamp_is_dos_format ((ut32) sdb_num_get (pe->kv, \"image_file_header.TimeDateStamp\", 0), dir->TimeDateStamp)) {\n\t\t\trs->timestr = r_time_stamp_to_str ( r_time_dos_time_stamp_to_posix (dir->TimeDateStamp));\n\t\t} else {\n\t\t\trs->timestr = r_time_stamp_to_str (dir->TimeDateStamp);\n\t\t}\n\t\trs->type = _resource_type_str (type);\n\t\trs->language = strdup (_resource_lang_str (entry.u1.Name & 0x3ff));\n\t\trs->data = data;\n\t\tif (resource_name) {\n\t\t\trs->name = strdup (resource_name);\n\t\t} else {\n\t\t\trs->name = r_str_newf (\"%d\", id);\n\t\t}\n\t\tr_list_append (pe->resources, rs);\n\t}\n}\n\nstatic void _store_resource_sdb(RBinPEObj *pe) {\n\tr_strf_buffer (64);\n\tRListIter *iter;\n\tr_pe_resource *rs;\n\tint index = 0;\n\tut64 vaddr = 0;\n\tchar *key;\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn;\n\t}\n\tr_list_foreach (pe->resources, iter, rs) {\n\t\tkey = r_strf (\"resource.%d.timestr\", index);\n\t\tsdb_set (sdb, key, rs->timestr, 0);\n\t\tkey = r_strf (\"resource.%d.vaddr\", index);\n\t\tvaddr = bin_pe_rva_to_va (pe, rs->data->OffsetToData);\n\t\tsdb_num_set (sdb, key, vaddr, 0);\n\t\tkey = r_strf (\"resource.%d.name\", index);\n\t\tsdb_set (sdb, key, rs->name, 0);\n\t\tkey = r_strf (\"resource.%d.size\", index);\n\t\tsdb_num_set (sdb, key, rs->data->Size, 0);\n\t\tkey = r_strf (\"resource.%d.type\", index);\n\t\tsdb_set (sdb, key, rs->type, 0);\n\t\tkey = r_strf (\"resource.%d.language\", index);\n\t\tsdb_set (sdb, key, rs->language, 0);\n\t\tindex++;\n\t}\n\tsdb_ns_set (pe->kv, \"pe_resource\", sdb);\n}\n\n\nR_API void PE_(bin_pe_parse_resource)(RBinPEObj *pe) {\n\tint index = 0;\n\tut64 off = 0, rsrc_base = pe->resource_directory_offset;\n\tPe_image_resource_directory *rs_directory = pe->resource_directory;\n\tut32 curRes = 0;\n\tint totalRes = 0;\n\tHtUUOptions opt = { 0 };\n\tHtUU *dirs = ht_uu_new_opt (&opt); //to avoid infinite loops\n\tif (!dirs) {\n\t\treturn;\n\t}\n\tif (!rs_directory) {\n\t\tht_uu_free (dirs);\n\t\treturn;\n\t}\n\tcurRes = rs_directory->NumberOfNamedEntries;\n\ttotalRes = curRes + rs_directory->NumberOfIdEntries;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\teprintf (\"Error parsing resource directory\\n\");\n\t\tht_uu_free (dirs);\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry typeEntry;\n\t\toff = rsrc_base + sizeof (*rs_directory) + index * sizeof (typeEntry);\n\t\tht_uu_insert (dirs, off, 1);\n\t\tif (off > pe->size || off + sizeof (typeEntry) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (read_image_resource_directory_entry (pe->b, off, &typeEntry) < 0) {\n\t\t\teprintf (\"Warning: read resource directory entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (typeEntry.u2.OffsetToData >> 31) {\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\tut32 OffsetToDirectory = typeEntry.u2.OffsetToData & 0x7fffffff;\n\t\t\toff = rsrc_base + OffsetToDirectory;\n\t\t\tint len = read_image_resource_directory (pe->b, off, &identEntry);\n\t\t\tif (len != sizeof (identEntry)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t(void)_parse_resource_directory (pe, &identEntry, OffsetToDirectory, typeEntry.u1.Name & 0xffff, 0, dirs, NULL);\n\t\t}\n\t}\n\tht_uu_free (dirs);\n\t_store_resource_sdb (pe);\n}\n\nstatic int bin_pe_init_security(RBinPEObj *pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\tif (pe->nt_headers->optional_header.NumberOfRvaAndSizes < 5) {\n\t\treturn false;\n\t}\n\tPE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];\n\tPE_DWord paddr = data_dir_security->VirtualAddress;\n\tut32 size = data_dir_security->Size;\n\tif (size < 8 || paddr > pe->size || paddr + size > pe->size) {\n\t\tpe_printf (\"Invalid certificate table\");\n\t\treturn false;\n\t}\n\n\tPe_image_security_directory *security_directory = R_NEW0 (Pe_image_security_directory);\n\tif (!security_directory) {\n\t\treturn false;\n\t}\n\tpe->security_directory = security_directory;\n\n\tPE_DWord offset = paddr;\n\twhile (offset < paddr + size) {\n\t\tPe_certificate **tmp = (Pe_certificate **)realloc (security_directory->certificates, (security_directory->length + 1) * sizeof (Pe_certificate *));\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\t\tsecurity_directory->certificates = tmp;\n\t\tPe_certificate *cert = R_NEW0 (Pe_certificate);\n\t\tif (!cert) {\n\t\t\treturn false;\n\t\t}\n\t\tcert->dwLength = r_buf_read_le32_at (pe->b, offset);\n\t\tcert->dwLength += (8 - (cert->dwLength & 7)) & 7; // align32\n\t\tif (offset + cert->dwLength > paddr + size) {\n\t\t\tpe_printf (\"Invalid certificate entry\");\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tcert->wRevision = r_buf_read_le16_at (pe->b, offset + 4);\n\t\tcert->wCertificateType = r_buf_read_le16_at (pe->b, offset + 6);\n\t\tif (cert->dwLength < 6) {\n\t\t\teprintf (\"Cert.dwLength must be > 6\\n\");\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(cert->bCertificate = malloc (cert->dwLength - 6))) {\n\t\t\tR_FREE (cert);\n\t\t\treturn false;\n\t\t}\n\t\tr_buf_read_at (pe->b, offset + 8, cert->bCertificate, cert->dwLength - 6);\n\n\t\tif (!pe->cms && cert->wCertificateType == PE_WIN_CERT_TYPE_PKCS_SIGNED_DATA) {\n\t\t\tpe->cms = r_pkcs7_parse_cms (cert->bCertificate, cert->dwLength - 6);\n\t\t\tif (pe->cms) {\n\t\t\t\tpe->spcinfo = r_pkcs7_parse_spcinfo (pe->cms);\n\t\t\t}\n\t\t}\n\n\t\tsecurity_directory->certificates[security_directory->length] = cert;\n\t\tsecurity_directory->length++;\n\t\toffset += cert->dwLength;\n\t}\n\n\tif (pe->cms && pe->spcinfo) {\n\t\tconst char *actual_authentihash = PE_(bin_pe_compute_authentihash) (pe);\n\t\tconst char *claimed_authentihash = PE_(bin_pe_get_claimed_authentihash) (pe);\n\t\tif (actual_authentihash && claimed_authentihash) {\n\t\t\tpe->is_authhash_valid = !strcmp (actual_authentihash, claimed_authentihash);\n\t\t} else {\n\t\t\tpe->is_authhash_valid = false;\n\t\t}\n\t\tif (actual_authentihash) {\n\t\t\tfree ((void *)actual_authentihash);\n\t\t}\n\t\tfree ((void *)claimed_authentihash);\n\t}\n\tpe->is_signed = pe->cms != NULL;\n\treturn true;\n}\n\nstatic void free_security_directory(Pe_image_security_directory *security_directory) {\n\tif (!security_directory) {\n\t\treturn;\n\t}\n\tsize_t numCert = 0;\n\tfor (; numCert < security_directory->length; numCert++) {\n\t\tfree (security_directory->certificates[numCert]);\n\t}\n\tfree (security_directory->certificates);\n\tfree (security_directory);\n}\n\nstatic int bin_pe_init(RBinPEObj* pe) {\n\tpe->dos_header = NULL;\n\tpe->nt_headers = NULL;\n\tpe->section_header = NULL;\n\tpe->export_directory = NULL;\n\tpe->import_directory = NULL;\n\tpe->resource_directory = NULL;\n\tpe->security_directory = NULL;\n\tpe->delay_import_directory = NULL;\n\tpe->optional_header = NULL;\n\tpe->data_directory = NULL;\n\tpe->big_endian = 0;\n\tpe->cms = NULL;\n\tpe->spcinfo = NULL;\n\tif (!bin_pe_init_hdr (pe)) {\n\t\teprintf (\"Warning: File is not PE\\n\");\n\t\treturn false;\n\t}\n\tif (!bin_pe_init_sections (pe)) {\n\t\teprintf (\"Warning: Cannot initialize sections\\n\");\n\t\treturn false;\n\t}\n\tpe->sections = PE_(r_bin_pe_get_sections) (pe);\n\tbin_pe_init_imports (pe);\n\tbin_pe_init_exports (pe);\n\tbin_pe_init_resource (pe);\n\tbin_pe_init_security (pe);\n\n\tpe->big_endian = PE_(r_bin_pe_is_big_endian) (pe);\n\n\tbin_pe_init_rich_info (pe);\n\tbin_pe_init_tls (pe);\n\tbin_pe_init_clr_hdr (pe);\n\tbin_pe_init_metadata_hdr (pe);\n\tbin_pe_init_overlay (pe);\n\tPE_(bin_pe_parse_resource) (pe);\n\tpe->relocs = NULL;\n\treturn true;\n}\n\nchar* PE_(r_bin_pe_get_arch)(RBinPEObj* pe) {\n\tchar* arch;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn strdup (\"x86\");\n\t}\n\tswitch (pe->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA:\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA64:\n\t\tarch = strdup (\"alpha\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_M68K:\n\t\tarch = strdup (\"m68k\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_MIPS16:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16:\n\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2:\n\t\tarch = strdup (\"mips\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_POWERPC:\n\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP:\n\t\tarch = strdup (\"ppc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_EBC:\n\t\tarch = strdup (\"ebc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_ARM64:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RISCV32:\n\tcase PE_IMAGE_FILE_MACHINE_RISCV64:\n\tcase PE_IMAGE_FILE_MACHINE_RISCV128:\n\t\tarch = strdup (\"riscv\");\n\t\tbreak;\n\tdefault:\n\t\tarch = strdup (\"x86\");\n\t}\n\treturn arch;\n}\n\nstruct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(RBinPEObj* pe) {\n\tstruct r_bin_pe_addr_t* entry = NULL;\n\tstatic bool debug = false;\n\tint i;\n\tut64 base_addr = PE_(r_bin_pe_get_image_base) (pe);\n\tif (!pe || !pe->optional_header) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = malloc (sizeof (struct r_bin_pe_addr_t)))) {\n\t\tr_sys_perror (\"malloc (entrypoint)\");\n\t\treturn NULL;\n\t}\n\tPE_DWord pe_entry = pe->optional_header->AddressOfEntryPoint;\n\tentry->vaddr = bin_pe_rva_to_va (pe, pe_entry);\n\tentry->paddr = PE_(va2pa) (pe, pe_entry);\n\t// haddr is the address of AddressOfEntryPoint in header.\n\tentry->haddr = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;\n\n\tif (entry->paddr >= pe->size) {\n\t\tstruct r_bin_pe_section_t* sections = pe->sections;\n\t\tut64 paddr = 0;\n\t\tif (!debug) {\n\t\t\tpe_printf (\"Warning: Invalid entrypoint ... \"\n\t\t\t\t\"trying to fix it but i do not promise nothing\\n\");\n\t\t}\n\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\tif (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tpaddr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (!paddr) {\n\t\t\tut64 min_off = -1;\n\t\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\t\t//get the lowest section's paddr\n\t\t\t\tif (sections[i].paddr < min_off) {\n\t\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\t\tmin_off = sections[i].paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_off == -1) {\n\t\t\t\t//no section just a hack to try to fix entrypoint\n\t\t\t\t//maybe doesn't work always\n\t\t\t\tint sa = R_MAX (pe->optional_header->SectionAlignment, 0x1000);\n\t\t\t\tentry->paddr = pe_entry & ((sa << 1) - 1);\n\t\t\t\tentry->vaddr = entry->paddr + base_addr;\n\t\t\t}\n\t\t}\n\t}\n\tif (!entry->paddr) {\n\t\tif (!debug) {\n\t\t\tpe_printf (\"Warning: NULL entrypoint\\n\");\n\t\t}\n\t\tstruct r_bin_pe_section_t* sections = pe->sections;\n\t\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t\t//If there is a section with x without w perm is a good candidate to be the entrypoint\n\t\t\tif (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE && !(sections[i].perm & PE_IMAGE_SCN_MEM_WRITE)) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (is_arm (pe) && entry->vaddr & 1) {\n\t\tentry->vaddr--;\n\t\tif (entry->paddr & 1) {\n\t\t\tentry->paddr--;\n\t\t}\n\t}\n\tif (!debug) {\n\t\tdebug = true;\n\t}\n\treturn entry;\n}\n\nstruct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(RBinPEObj* pe) {\n\tr_return_val_if_fail (pe, NULL);\n\tstruct r_bin_pe_export_t* exp, * exports = NULL;\n\tPE_Word function_ordinal = 0;\n\tPE_VWord functions_paddr, names_paddr, ordinals_paddr, function_rva, name_vaddr, name_paddr;\n\tchar function_name[PE_NAME_LENGTH + 1], forwarder_name[PE_NAME_LENGTH + 1];\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tPE_(image_data_directory) * data_dir_export;\n\tPE_VWord export_dir_rva;\n\tint n,i, export_dir_size;\n\tst64 exports_sz = 0;\n\n\tif (!pe->data_directory) {\n\t\treturn NULL;\n\t}\n\tdata_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\texport_dir_rva = data_dir_export->VirtualAddress;\n\texport_dir_size = data_dir_export->Size;\n\tPE_VWord *func_rvas = NULL;\n\tPE_Word *ordinals = NULL;\n\tif (pe->export_directory) {\n\t\tif (pe->export_directory->NumberOfFunctions + 1 <\n\t\tpe->export_directory->NumberOfFunctions) {\n\t\t\t// avoid integer overflow\n\t\t\treturn NULL;\n\t\t}\n\t\texports_sz = (pe->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);\n\t\t// we cant exit with export_sz > pe->size, us r_bin_pe_export_t is 256+256+8+8+8+4 bytes is easy get over file size\n\t\t// to avoid fuzzing we can abort on export_directory->NumberOfFunctions>0xffff\n\t\tif (exports_sz < 0 || pe->export_directory->NumberOfFunctions + 1 > 0xffff) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(exports = malloc (exports_sz))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (r_buf_read_at (pe->b, PE_(va2pa) (pe, pe->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {\n\t\t\t// we dont stop if dll name cant be read, we set dllname to null and continue\n\t\t\tpe_printf (\"Warning: read (dll name)\\n\");\n\t\t\tdll_name[0] = '\\0';\n\t\t}\n\t\tfunctions_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfFunctions);\n\t\tnames_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfNames);\n\t\tordinals_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfOrdinals);\n\n\t\tconst size_t names_sz = pe->export_directory->NumberOfNames * sizeof (PE_Word);\n\t\tconst size_t funcs_sz = pe->export_directory->NumberOfFunctions * sizeof (PE_VWord);\n\t\tordinals = malloc (names_sz);\n\t\tfunc_rvas = malloc (funcs_sz);\n\t\tif (!ordinals || !func_rvas) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint r = r_buf_read_at (pe->b, ordinals_paddr, (ut8 *)ordinals, names_sz);\n\t\tif (r != names_sz) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr = r_buf_read_at (pe->b, functions_paddr, (ut8 *)func_rvas, funcs_sz);\n\t\tif (r != funcs_sz) {\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < pe->export_directory->NumberOfFunctions; i++) {\n\t\t\t// get vaddr from AddressOfFunctions array\n\t\t\tfunction_rva = r_read_at_ble32 ((ut8 *)func_rvas, i * sizeof (PE_VWord), pe->endian);\n\t\t\t// have exports by name?\n\t\t\tif (pe->export_directory->NumberOfNames > 0) {\n\t\t\t\t// search for value of i into AddressOfOrdinals\n\t\t\t\tname_vaddr = 0;\n\t\t\t\tfor (n = 0; n < pe->export_directory->NumberOfNames; n++) {\n\t\t\t\t\tPE_Word fo = r_read_at_ble16 ((ut8 *)ordinals, n * sizeof (PE_Word), pe->endian);\n\t\t\t\t\t// if exist this index into AddressOfOrdinals\n\t\t\t\t\tif (i == fo) {\n\t\t\t\t\t\tfunction_ordinal = fo;\n\t\t\t\t\t\t// get the VA of export name  from AddressOfNames\n\t\t\t\t\t\tname_vaddr = r_buf_read_le32_at (pe->b, names_paddr + n * sizeof (PE_VWord));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// have an address into name_vaddr?\n\t\t\t\tif (name_vaddr) {\n\t\t\t\t\t// get the name of the Export\n\t\t\t\t\tname_paddr = PE_(va2pa) (pe, name_vaddr);\n\t\t\t\t\tif (r_buf_read_at (pe->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\t\tpe_printf (\"Warning: read (function name)\\n\");\n\t\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\t\treturn exports;\n\t\t\t\t\t}\n\t\t\t\t} else { // No name export, get the ordinal\n\t\t\t\t\tfunction_ordinal = i;\n\t\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);\n\t\t\t\t}\n\t\t\t} else { // if export by name dont exist, get the ordinal taking in mind the Base value.\n\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);\n\t\t\t}\n\t\t\t// check if VA are into export directory, this mean a forwarder export\n\t\t\tif (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {\n\t\t\t\t// if forwarder, the VA point to Forwarded name\n\t\t\t\tif (r_buf_read_at (pe->b, PE_(va2pa) (pe, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\treturn exports;\n\t\t\t\t}\n\t\t\t} else { // no forwarder export\n\t\t\t\tsnprintf (forwarder_name, PE_NAME_LENGTH, \"NONE\");\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tfunction_name[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].vaddr = bin_pe_rva_to_va (pe, function_rva);\n\t\t\texports[i].paddr = PE_(va2pa) (pe, function_rva);\n\t\t\texports[i].ordinal = function_ordinal + pe->export_directory->Base;\n\t\t\tmemcpy (exports[i].forwarder, forwarder_name, PE_NAME_LENGTH);\n\t\t\texports[i].forwarder[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].name, function_name, PE_NAME_LENGTH);\n\t\t\texports[i].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].libname, dll_name, PE_NAME_LENGTH);\n\t\t\texports[i].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].last = 0;\n\t\t}\n\t\texports[i].last = 1;\n\t\tfree (ordinals);\n\t\tfree (func_rvas);\n\t}\n\texp = parse_symbol_table (pe, exports, exports_sz - sizeof (struct r_bin_pe_export_t));\n\tif (exp) {\n\t\texports = exp;\n\t}\n\treturn exports;\nbeach:\n\tfree (exports);\n\tfree (ordinals);\n\tfree (func_rvas);\n\treturn NULL;\n}\n\nstatic void free_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tR_FREE (rsds_hdr->file_name);\n}\n\nstatic void init_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tmemset (rsds_hdr, 0, sizeof (SCV_RSDS_HEADER));\n\trsds_hdr->free = (void (*)(struct SCV_RSDS_HEADER*))free_rsdr_hdr;\n}\n\nstatic void free_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tR_FREE (cv_nb10_header->file_name);\n}\n\nstatic void init_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tmemset (cv_nb10_header, 0, sizeof (SCV_NB10_HEADER));\n\tcv_nb10_header->free = (void (*)(struct SCV_NB10_HEADER*))free_cv_nb10_header;\n}\n\nstatic bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n\tconst int rsds_sz = 4 + sizeof (SGUID) + 4;\n\tif (dbg_data_len < rsds_sz) {\n\t\treturn false;\n\t}\n\tmemcpy (res, dbg_data, rsds_sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + rsds_sz);\n\treturn true;\n}\n\nstatic void get_nb10(ut8* dbg_data, int dbg_data_len, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tif (dbg_data_len < nb10sz) {\n\t\treturn;\n\t}\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}\n\nstatic int get_debug_info(RBinPEObj* pe, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* dbgname;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tpe_printf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tdbgname = (char*) rsds_hdr.file_name;\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tdbgname, sizeof (res->file_name));\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n\t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tif (dbg_data_len < 20) {\n\t\t\t\teprintf (\"Truncated NB10 entry, not enough data to parse\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tSCV_NB10_HEADER nb10_hdr = {{0}};\n\t\t\tinit_cv_nb10_header (&nb10_hdr);\n\t\t\tget_nb10 (dbg_data, dbg_data_len, &nb10_hdr);\n\t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n\t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tres->file_name[0] = 0;\n\t\t\tif (nb10_hdr.file_name) {\n\t\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\t\t\tnb10_hdr.file_name, sizeof (res->file_name) - 1);\n\t\t\t}\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n\t\t} else {\n\t\t\tpe_printf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//pe_printf(\"get_debug_info(): not supported type\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((ut8) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}\n\nstatic int read_image_debug_directory_entry(RBuffer *b, ut64 addr, PE_(image_debug_directory_entry) *entry) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r_buf_seek (b, addr, R_BUF_SET) < 0) {\n\t\treturn -1;\n\t}\n\tut8 buf[sizeof (PE_(image_debug_directory_entry))];\n\tr_buf_read (b, buf, sizeof (buf));\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), Characteristics, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), TimeDateStamp, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), MajorVersion, 16);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), MinorVersion, 16);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), Type, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), SizeOfData, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), AddressOfRawData, 32);\n\tPE_READ_STRUCT_FIELD (entry, PE_(image_debug_directory_entry), PointerToRawData, 32);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn sizeof (PE_(image_debug_directory_entry));\n}\n\nint PE_(r_bin_pe_get_debug_data)(RBinPEObj* pe, SDebugInfo* res) {\n\tPE_(image_debug_directory_entry) img_dbg_dir_entry = {0};\n\tPE_(image_data_directory) *dbg_dir = NULL;\n\tPE_DWord dbg_dir_offset;\n\tut8* dbg_data = 0;\n\tint result = 0;\n\tif (!pe) {\n\t\treturn 0;\n\t}\n\tdbg_dir = &pe->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];\n\tdbg_dir_offset = PE_(va2pa) (pe, dbg_dir->VirtualAddress);\n\tif ((int) dbg_dir_offset < 0 || dbg_dir_offset >= pe->size) {\n\t\treturn false;\n\t}\n\tif (dbg_dir_offset >= r_buf_size (pe->b)) {\n\t\treturn false;\n\t}\n\tread_image_debug_directory_entry (pe->b, dbg_dir_offset, &img_dbg_dir_entry);\n\tif ((r_buf_size (pe->b) - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {\n\t\treturn false;\n\t}\n\tut32 dbg_data_poff = R_MIN (img_dbg_dir_entry.PointerToRawData, r_buf_size (pe->b));\n\tint dbg_data_len = R_MIN (img_dbg_dir_entry.SizeOfData, r_buf_size (pe->b) - dbg_data_poff);\n\tif (dbg_data_len < 1) {\n\t\treturn false;\n\t}\n\tdbg_data = (ut8*) calloc (1, dbg_data_len + 1);\n\tif (dbg_data) {\n\t\tr_buf_read_at (pe->b, dbg_data_poff, dbg_data, dbg_data_len);\n\t\tresult = get_debug_info (pe, &img_dbg_dir_entry, dbg_data, dbg_data_len, res);\n\t\tR_FREE (dbg_data);\n\t}\n\treturn result;\n}\n\nstruct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(RBinPEObj* pe) {\n\tstruct r_bin_pe_import_t* imps, * imports = NULL;\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tint nimp = 0;\n\tut64 off; //used to cache value\n\tPE_DWord dll_name_offset = 0;\n\tPE_DWord paddr = 0;\n\tPE_DWord import_func_name_offset;\n\tPE_(image_import_directory) curr_import_dir;\n\tPE_(image_delay_import_directory) curr_delay_import_dir;\n\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tif (pe->import_directory_offset >= pe->size) {\n\t\treturn NULL;\n\t}\n\tif (pe->import_directory_offset + 20 > pe->size) {\n\t\treturn NULL;\n\t}\n\n\toff = pe->import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 last;\n\t\tint idi = 0;\n\t\tif (off + sizeof (PE_(image_import_directory)) > pe->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tint r = read_image_import_directory (pe->b, pe->import_directory_offset +\n\t\t\tidi * sizeof (curr_import_dir), &curr_import_dir);\n\t\tif (r < 0) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (pe->import_directory_size < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (off + pe->import_directory_size > pe->size) {\n\t\t\t//why chopping instead of returning and cleaning?\n\t\t\tpe_printf (\"Warning: read (import directory too big)\\n\");\n\t\t\tpe->import_directory_size = pe->size - pe->import_directory_offset;\n\t\t}\n\t\tlast = pe->import_directory_offset + pe->import_directory_size;\n\t\twhile (r == sizeof (curr_import_dir) && pe->import_directory_offset + (idi + 1) * sizeof (curr_import_dir) <= last && (\n\t\t\tcurr_import_dir.FirstThunk != 0 || curr_import_dir.Name != 0 ||\n\t\t\tcurr_import_dir.TimeDateStamp != 0 || curr_import_dir.Characteristics != 0 ||\n\t\t\tcurr_import_dir.ForwarderChain != 0)) {\n\t\t\tint rr;\n\t\t\tdll_name_offset = curr_import_dir.Name;\n\t\t\tpaddr = PE_(va2pa) (pe, dll_name_offset);\n\t\t\tif (paddr > pe->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (paddr + PE_NAME_LENGTH > pe->size) {\n\t\t\t\trr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, pe->size - paddr);\n\t\t\t\tif (rr != pe->size - paddr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[pe->size - paddr] = '\\0';\n\t\t\t} else {\n\t\t\t\trr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\t\tif (rr != PE_NAME_LENGTH) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\t}\n\t\t\tif (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name,\n\t\t\t\tcurr_import_dir.Characteristics,\n\t\t\t\tcurr_import_dir.FirstThunk)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidi++;\n\t\t\tr = read_image_import_directory (pe->b, pe->import_directory_offset +\n\t\t\t\tidi * sizeof (curr_import_dir), &curr_import_dir);\n\t\t\tif (r < 0) {\n\t\t\t\tfree (imports);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\toff = pe->delay_import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tif (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {\n\t\t\tgoto beach;\n\t\t}\n\t\tint didi;\n\t\tfor (didi = 0;; didi++) {\n\t\t\tint r = read_image_delay_import_directory (pe->b, off + didi * sizeof (curr_delay_import_dir),\n\t\t\t\t\t&curr_delay_import_dir);\n\t\t\tif (r != sizeof (curr_delay_import_dir)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif ((curr_delay_import_dir.Name == 0) || (curr_delay_import_dir.DelayImportAddressTable == 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!curr_delay_import_dir.Attributes) {\n\t\t\t\tdll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name - PE_(r_bin_pe_get_image_base)(pe));\n\t\t\t\timport_func_name_offset = curr_delay_import_dir.DelayImportNameTable - PE_(r_bin_pe_get_image_base)(pe);\n\t\t\t} else {\n\t\t\t\tdll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name);\n\t\t\t\timport_func_name_offset = curr_delay_import_dir.DelayImportNameTable;\n\t\t\t}\n\t\t\tif (dll_name_offset > pe->size || dll_name_offset + PE_NAME_LENGTH > pe->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tint rr = r_buf_read_at (pe->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\tif (rr < 5) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tif (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name, import_func_name_offset,\n\t\t\t\tcurr_delay_import_dir.DelayImportAddressTable)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tif (nimp) {\n\t\timps = realloc (imports, (nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\tif (!imps) {\n\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\timports = imps;\n\t\timports[nimp].last = 1;\n\t}\n\treturn imports;\n}\n\nstruct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(RBinPEObj* pe) {\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_pe_lib_t* libs = NULL;\n\tstruct r_bin_pe_lib_t* new_libs = NULL;\n\tPE_(image_import_directory) curr_import_dir;\n\tPE_(image_delay_import_directory) curr_delay_import_dir;\n\tPE_DWord name_off = 0;\n\tHtPP *lib_map = NULL;\n\tut64 off; //cache value\n\tint index = 0;\n\tint len = 0;\n\tint max_libs = 20;\n\tlibs = calloc (max_libs + 1, sizeof (struct r_bin_pe_lib_t));\n\tif (!libs) {\n\t\tr_sys_perror (\"malloc (libs)\");\n\t\treturn NULL;\n\t}\n\n\tif (pe->import_directory_offset + pe->import_directory_size > pe->size) {\n\t\tpe_printf (\"import directory offset bigger than file\\n\");\n\t\tgoto out_error;\n\t}\n\tlib_map = sdb_ht_new ();\n\toff = pe->import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 last;\n\t\tint iidi = 0;\n\t\t// normal imports\n\t\tif (off + sizeof (PE_(image_import_directory)) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tint r = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),\n\t\t\t&curr_import_dir);\n\t\tlast = off + pe->import_directory_size;\n\t\twhile (r == sizeof (curr_import_dir) && off + (iidi + 1) * sizeof (curr_import_dir) <= last && (\n\t\t\tcurr_import_dir.FirstThunk || curr_import_dir.Name ||\n\t\t\tcurr_import_dir.TimeDateStamp || curr_import_dir.Characteristics ||\n\t\t\tcurr_import_dir.ForwarderChain)) {\n\t\t\tname_off = PE_(va2pa) (pe, curr_import_dir.Name);\n\t\t\tlen = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (!libs[index].name[0]) { // minimum string length\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (len < 2 || libs[index].name[0] == 0) { // minimum string length\n\t\t\t\tpe_printf (\"Warning: read (libs - import dirs) %d\\n\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tnew_libs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!new_libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tlibs = new_libs;\n\t\t\t\t\tnew_libs = NULL;\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tiidi++;\n\t\t\tr = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),\n\t\t\t\t&curr_import_dir);\n\t\t}\n\t}\n\toff = pe->delay_import_directory_offset;\n\tif (off < pe->size && off > 0) {\n\t\tut64 did = 0;\n\t\tif (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tint r = read_image_delay_import_directory (pe->b, off, &curr_delay_import_dir);\n\t\tif (r != sizeof (curr_delay_import_dir)) {\n\t\t\tgoto out_error;\n\t\t}\n\t\twhile (r == sizeof (curr_delay_import_dir) &&\n\t\t\tcurr_delay_import_dir.Name != 0 && curr_delay_import_dir.DelayImportNameTable != 0) {\n\t\t\tname_off = PE_(va2pa) (pe, curr_delay_import_dir.Name);\n\t\t\tif (name_off > pe->size || name_off + PE_STRING_LENGTH > pe->size) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tlen = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (len != PE_STRING_LENGTH) {\n\t\t\t\tpe_printf (\"Warning: read (libs - delay import dirs)\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tnew_libs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!new_libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tlibs = new_libs;\n\t\t\t\t\tnew_libs = NULL;\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdid++;\n\t\t\tr = read_image_delay_import_directory (pe->b, off + did * sizeof (curr_delay_import_dir),\n\t\t\t\t&curr_delay_import_dir);\n\t\t}\n\t}\n\tsdb_ht_free (lib_map);\n\tlibs[index].last = 1;\n\treturn libs;\nout_error:\n\tsdb_ht_free (lib_map);\n\tfree (libs);\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_image_size)(RBinPEObj* pe) {\n\treturn pe->nt_headers->optional_header.SizeOfImage;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_machine)(RBinPEObj* pe) {\n\tchar* machine = NULL;\n\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->file_header.Machine) {\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA: machine = \"Alpha\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA64: machine = \"Alpha 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AM33: machine = \"AM33\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AMD64: machine = \"AMD 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ARM: machine = \"ARM\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEE: machine = \"CEE\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEF: machine = \"CEF\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_EBC: machine = \"EBC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_I386: machine = \"i386\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_IA64: machine = \"ia64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M32R: machine = \"M32R\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M68K: machine = \"M68K\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPS16: machine = \"Mips 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU: machine = \"Mips FPU\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16: machine = \"Mips FPU 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPC: machine = \"PowerPC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP: machine = \"PowerPC FP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R10000: machine = \"R10000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R3000: machine = \"R3000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R4000: machine = \"R4000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3: machine = \"SH3\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3DSP: machine = \"SH3DSP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3E: machine = \"SH3E\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH4: machine = \"SH4\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH5: machine = \"SH5\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_THUMB: machine = \"Thumb\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_TRICORE: machine = \"Tricore\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2: machine = \"WCE Mips V2\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV32: machine = \"RISC-V 32-bit\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV64: machine = \"RISC-V 64-bit\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_RISCV128: machine = \"RISC-V 128-bit\"; break;\n\t\tdefault: machine = \"unknown\";\n\t\t}\n\t}\n\treturn machine? strdup (machine): NULL;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_os)(RBinPEObj* pe) {\n\tchar* os;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\tswitch (pe->nt_headers->optional_header.Subsystem) {\n\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\tos = strdup (\"native\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\tos = strdup (\"windows\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\tos = strdup (\"posix\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\tos = strdup (\"efi\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\tos = strdup (\"xbox\");\n\t\tbreak;\n\tdefault:\n\t\t// XXX: this is unknown\n\t\tos = strdup (\"windows\");\n\t}\n\treturn os;\n}\n\n// TODO: make it const\nchar* PE_(r_bin_pe_get_class)(RBinPEObj* pe) {\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"PE32\");\n\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"PE32+\");\n\t\tdefault: return strdup (\"Unknown\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_bits)(RBinPEObj* pe) {\n\tint bits = 32;\n\tif (pe && pe->nt_headers) {\n\t\tif (is_arm (pe)) {\n\t\t\tif (is_thumb (pe)) {\n\t\t\t\tbits = 16;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: bits = 32; break;\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: bits = 64; break;\n\t\t\tdefault: bits = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn bits;\n}\n\nchar *PE_(r_bin_pe_get_cc)(RBinPEObj* pe) {\n\tif (pe && pe->nt_headers) {\n\t\tif (is_arm (pe)) {\n\t\t\tif (is_thumb (pe)) {\n\t\t\t\treturn strdup (\"arm16\");\n\t\t\t}\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"arm32\");\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"arm64\");\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (pe->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"cdecl\");\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"ms\");\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n//This function try to detect anomalies within section\n//we check if there is a section mapped at entrypoint, otherwise add it up\nvoid PE_(r_bin_pe_check_sections)(RBinPEObj* pe, struct r_bin_pe_section_t* * sects) {\n\tint i = 0;\n\tstruct r_bin_pe_section_t* sections = *sects;\n\tut64 addr_beg, addr_end, new_section_size, new_perm, base_addr;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n\n\tif (!entry) {\n\t\treturn;\n\t}\n\tnew_section_size = pe->size;\n\tnew_section_size -= entry->paddr > pe->size? 0: entry->paddr;\n\tnew_perm = (PE_IMAGE_SCN_MEM_READ | PE_IMAGE_SCN_MEM_WRITE | PE_IMAGE_SCN_MEM_EXECUTE);\n\tbase_addr = PE_(r_bin_pe_get_image_base) (pe);\n\n\tfor (i = 0; !sections[i].last; i++) {\n\t\t//strcmp against .text doesn't work in somes cases\n\t\tif (strstr ((const char*) sections[i].name, \"text\")) {\n\t\t\tbool fix = false;\n\t\t\tint j;\n\t\t\t//check paddr boundaries\n\t\t\taddr_beg = sections[i].paddr;\n\t\t\taddr_end = addr_beg + sections[i].size;\n\t\t\tif (entry->paddr < addr_beg || entry->paddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//check vaddr boundaries\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//look for other segment with x that is already mapped and hold entrypoint\n\t\t\tfor (j = 0; !sections[j].last; j++) {\n\t\t\t\taddr_beg = sections[j].paddr;\n\t\t\t\taddr_end = addr_beg + sections[j].size;\n\t\t\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\t\t\tif (!sections[j].vsize) {\n\t\t\t\t\t\tsections[j].vsize = sections[j].size;\n\t\t\t\t\t}\n\t\t\t\t\taddr_beg = sections[j].vaddr + base_addr;\n\t\t\t\t\taddr_end = addr_beg + sections[j].vsize;\n\t\t\t\t\tif (addr_beg <= entry->vaddr || entry->vaddr < addr_end) {\n\t\t\t\t\t\tif (!(sections[j].perm & PE_IMAGE_SCN_MEM_EXECUTE)) {\n\t\t\t\t\t\t\tif (pe->verbose) {\n\t\t\t\t\t\t\t\teprintf (\"Warning: Found entrypoint in non-executable section.\\n\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsections[j].perm |= PE_IMAGE_SCN_MEM_EXECUTE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfix = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if either vaddr or paddr fail we should update this section\n\t\t\tif (fix) {\n\t\t\t\tstrcpy ((char*) sections[i].name, \"blob\");\n\t\t\t\tsections[i].paddr = entry->paddr;\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t\tsections[i].size = sections[i].vsize = new_section_size;\n\t\t\t\tsections[i].perm = new_perm;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//if we arrive til here means there is no text section find one that is holding the code\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tif (sections[i].size > pe->size) {\n\t\t\tcontinue;\n\t\t}\n\t\taddr_beg = sections[i].paddr;\n\t\taddr_end = addr_beg + sections[i].size;\n\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\tif (!sections[i].vsize) {\n\t\t\t\tsections[i].vsize = sections[i].size;\n\t\t\t}\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//we need to create another section in order to load the entrypoint\n\tvoid *ss = realloc (sections, (pe->num_sections + 2) * sizeof (struct r_bin_pe_section_t));\n\tif (!ss) {\n\t\tgoto out_function;\n\t}\n\tpe->sections = sections = ss;\n\ti = pe->num_sections;\n\tsections[i].last = 0;\n\tstrcpy ((char*) sections[i].name, \"blob\");\n\tsections[i].paddr = entry->paddr;\n\tsections[i].vaddr = entry->vaddr - base_addr;\n\tsections[i].size = sections[i].vsize = new_section_size;\n\tsections[i].perm = new_perm;\n\tsections[i + 1].last = 1;\n\t*sects = sections;\nout_function:\n\tfree (entry);\n\treturn;\n\n}\n\nstatic struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe) {\n\tstruct r_bin_pe_section_t* sections = NULL;\n\tint i, j, section_count = 0;\n\n\tif (!pe || !pe->nt_headers) {\n\t\treturn NULL;\n\t}\n\tPE_(image_section_header) * shdr = pe->section_header;\n\tfor (i = 0; i < pe->num_sections; i++) {\n\t\t//just allocate the needed\n\t\tif (shdr[i].SizeOfRawData || shdr[i].Misc.VirtualSize) {\n\t\t\tsection_count++;\n\t\t}\n\t}\n\tsections = calloc (section_count + 1, sizeof (struct r_bin_pe_section_t));\n\tif (!sections) {\n\t\tr_sys_perror (\"malloc (sections)\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0, j = 0; i < pe->num_sections; i++) {\n\t\tif (!shdr[i].SizeOfRawData && !shdr[i].Misc.VirtualSize) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (shdr[i].Name[0] == '\\0') {\n\t\t\tchar* new_name = r_str_newf (\"sect_%d\", j);\n\t\t\tr_str_ncpy ((char*) sections[j].name, new_name, R_ARRAY_SIZE (sections[j].name) - 1);\n\t\t\tfree (new_name);\n\t\t} else if (shdr[i].Name[0] == '/') {\n\t\t\t// section header is not null terminated, so use ndup\n\t\t\tchar *n = r_str_ndup ((const char *)shdr[i].Name + 1, sizeof (shdr[i].Name) - 1);\n\t\t\tint idx = atoi (n);\n\t\t\tfree (n);\n\t\t\tut64 sym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;\n\t\t\tint num_symbols = pe->nt_headers->file_header.NumberOfSymbols;\n\t\t\tst64 off = num_symbols * COFF_SYMBOL_SIZE;\n\t\t\tif (off > 0 && sym_tbl_off &&\n\t\t\t    sym_tbl_off + off + idx < pe->size &&\n\t\t\t    sym_tbl_off + off + idx > off) {\n\t\t\t\tint sz = PE_IMAGE_SIZEOF_SHORT_NAME * 3;\n\t\t\t\tchar* buf[64] = {0};\n\t\t\t\tif (r_buf_read_at (pe->b,\n\t\t\t\t\t\t   sym_tbl_off + off + idx,\n\t\t\t\t\t\t   (ut8*)buf, 64)) {\n\t\t\t\t\tmemcpy (sections[j].name, buf, sz);\n\t\t\t\t\tsections[j].name[sz - 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy (sections[j].name, shdr[i].Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\t\t\tsections[j].name[PE_IMAGE_SIZEOF_SHORT_NAME] = '\\0';\n\t\t}\n\t\tsections[j].vaddr = shdr[i].VirtualAddress;\n\t\tsections[j].size = shdr[i].SizeOfRawData;\n\t\tif (shdr[i].Misc.VirtualSize) {\n\t\t\tsections[j].vsize = shdr[i].Misc.VirtualSize;\n\t\t} else {\n\t\t\tsections[j].vsize = shdr[i].SizeOfRawData;\n\t\t}\n\t\tsections[j].paddr = shdr[i].PointerToRawData;\n\t\tif (pe->optional_header) {\n\t\t\tut32 sa = pe->optional_header->SectionAlignment;\n\t\t\tif (sa) {\n\t\t\t\tut64 diff = sections[j].vsize % sa;\n\t\t\t\tif (diff) {\n\t\t\t\t\tsections[j].vsize += sa - diff;\n\t\t\t\t}\n\t\t\t\tif (sections[j].vaddr % sa) {\n\t\t\t\t\tpe_printf (\"Warning: section %s not aligned to SectionAlignment.\\n\",\n\t\t\t\t\t\t\tsections[j].name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst ut32 fa = pe->optional_header->FileAlignment;\n\t\t\tif (fa) {\n\t\t\t\tconst ut64 diff = sections[j].paddr % fa;\n\t\t\t\tif (diff) {\n\t\t\t\t\tpe_printf (\"Warning: section %s not aligned to FileAlignment.\\n\", sections[j].name);\n\t\t\t\t\tsections[j].paddr -= diff;\n\t\t\t\t\tsections[j].size += diff;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsections[j].perm = shdr[i].Characteristics;\n\t\tsections[j].last = 0;\n\t\tj++;\n\t}\n\tsections[j].last = 1;\n\tpe->num_sections = section_count;\n\treturn sections;\n}\n\nchar* PE_(r_bin_pe_get_subsystem)(RBinPEObj* pe) {\n\tchar* subsystem = NULL;\n\tif (pe && pe->nt_headers) {\n\t\tswitch (pe->nt_headers->optional_header.Subsystem) {\n\t\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\t\tsubsystem = \"Native\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\t\t\tsubsystem = \"Windows GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\t\t\tsubsystem = \"Windows CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\t\tsubsystem = \"POSIX CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\t\tsubsystem = \"Windows CE GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\t\t\tsubsystem = \"EFI Application\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\t\t\tsubsystem = \"EFI Boot Service Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\t\t\tsubsystem = \"EFI Runtime Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\t\tsubsystem = \"EFI ROM\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\t\tsubsystem = \"XBOX\"; break;\n\t\tdefault:\n\t\t\tsubsystem = \"Unknown\"; break;\n\t\t}\n\t}\n\treturn subsystem? strdup (subsystem): NULL;\n}\n\n#define HASCHR(x) (pe->nt_headers->file_header.Characteristics & (x))\n\nint PE_(r_bin_pe_is_dll)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DLL);\n}\n\nint PE_(r_bin_pe_is_pie)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);\n#if 0\n\tBOOL aslr = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;\n//TODO: implement dep?\n\tBOOL dep = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT;\n#endif\n}\n\nint PE_(r_bin_pe_is_big_endian)(RBinPEObj* pe) {\n\tut16 arch;\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\tarch = pe->nt_headers->file_header.Machine;\n\tif (arch == PE_IMAGE_FILE_MACHINE_I386 ||\n\tarch == PE_IMAGE_FILE_MACHINE_AMD64) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_BYTES_REVERSED_HI);\n}\n\nint PE_(r_bin_pe_is_stripped_relocs)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_RELOCS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_line_nums)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LINE_NUMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_local_syms)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_debug)(RBinPEObj* pe) {\n\tif (!pe || !pe->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DEBUG_STRIPPED);\n}\n\nvoid* PE_(r_bin_pe_free)(RBinPEObj* pe) {\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tfree (pe->dos_header);\n\tfree (pe->nt_headers);\n\tfree (pe->section_header);\n\tfree (pe->export_directory);\n\tfree (pe->import_directory);\n\tfree (pe->resource_directory);\n\tfree_security_directory (pe->security_directory);\n\tfree (pe->delay_import_directory);\n\tfree (pe->tls_directory);\n\tfree (pe->sections);\n\tfree (pe->authentihash);\n\tr_list_free (pe->rich_entries);\n\tr_list_free (pe->resources);\n\tr_pkcs7_free_cms (pe->cms);\n\tr_pkcs7_free_spcinfo (pe->spcinfo);\n\tr_buf_free (pe->b);\n\tpe->b = NULL;\n\tfree (pe);\n\treturn NULL;\n}\n\nRBinPEObj* PE_(r_bin_pe_new)(const char* file, bool verbose) {\n\tRBinPEObj* pe = R_NEW0 (RBinPEObj);\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tpe->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8*)r_file_slurp (file, &binsz);\n\tpe->size = binsz;\n\tif (!buf) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\tpe->b = r_buf_new ();\n\tif (!r_buf_set_bytes (pe->b, buf, pe->size)) {\n\t\tfree (buf);\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\tpe->verbose = verbose;\n\tfree (buf);\n\tif (!bin_pe_init (pe)) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\treturn pe;\n}\n\nR_API RBinPEObj* PE_(r_bin_pe_new_buf)(RBuffer *buf, bool verbose) {\n\tRBinPEObj *pe = R_NEW0 (RBinPEObj);\n\tif (!pe) {\n\t\treturn NULL;\n\t}\n\tpe->kv = sdb_new0 ();\n\tpe->b = r_buf_ref (buf);\n\tpe->verbose = verbose;\n\tpe->size = r_buf_size (buf);\n\tif (!bin_pe_init (pe)) {\n\t\treturn PE_(r_bin_pe_free)(pe);\n\t}\n\treturn pe;\n}\n", "/* radare2 - LGPL - Copyright 2018-2022 - pancake, mrmacete, keegan */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_io.h>\n#include <ht_pu.h>\n// #include \"../format/mach0/mach0_defines.h\"\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n\n#define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)\n#define MAX_N_HDR 16\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n} RDyldRebaseInfo;\n\ntypedef struct {\n\tut64 start;\n\tut64 end;\n\tRDyldRebaseInfo *info;\n} RDyldRebaseInfosEntry;\n\ntypedef struct {\n\tRDyldRebaseInfosEntry *entries;\n\tsize_t length;\n} RDyldRebaseInfos;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut64 delta_mask;\n\tut32 delta_shift;\n\tut64 auth_value_add;\n} RDyldRebaseInfo3;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut16 *page_extras;\n\tut32 page_extras_count;\n\tut64 delta_mask;\n\tut64 value_mask;\n\tut32 delta_shift;\n\tut64 value_add;\n} RDyldRebaseInfo2;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *toc;\n\tut32 toc_count;\n\tut8 *entries;\n\tut32 entries_size;\n} RDyldRebaseInfo1;\n\ntypedef struct {\n\tut64 local_symbols_offset;\n\tut64 nlists_offset;\n\tut64 nlists_count;\n\tut64 strings_offset;\n\tut64 strings_size;\n} RDyldLocSym;\n\ntypedef struct _r_dyldcache {\n\tut8 magic[8];\n\n\tcache_hdr_t *hdr;\n\tut64 *hdr_offset;\n\tut32 *maps_index;\n\tut32 n_hdr;\n\tcache_map_t *maps;\n\tut32 n_maps;\n\n\tRList *bins;\n\tRBuffer *buf;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tRDyldRebaseInfos *rebase_infos;\n\tcache_accel_t *accel;\n\tRDyldLocSym *locsym;\n\tobjc_cache_opt_info *oi;\n\tbool objc_opt_info_loaded;\n} RDyldCache;\n\ntypedef struct _r_bin_image {\n\tchar *file;\n\tut64 header_at;\n\tut64 hdr_offset;\n\tut64 symbols_off;\n\tut64 va;\n\tut32 nlist_start_index;\n\tut32 nlist_count;\n} RDyldBinImage;\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\n\tR_FREE (bin->file);\n\tR_FREE (bin);\n}\n\nstatic void rebase_info3_free(RDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info2_free(RDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info->page_extras);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info1_free(RDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->toc);\n\tR_FREE (rebase_info->entries);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info_free(RDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free ((RDyldRebaseInfo1*) rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free ((RDyldRebaseInfo2*) rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free ((RDyldRebaseInfo3*) rebase_info);\n\t} else {\n\t\tR_FREE (rebase_info);\n\t}\n}\n\nstatic cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RDyldCache *cache, void *entries) {\n\tr_return_if_fail (cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRDyldBinImage *bin = NULL;\n\tRListIter *it = r_list_iterator (cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tR_FREE (imgs);\n}\n\nstatic RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {\n\tr_return_val_if_fail (cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof (cache_locsym_info_t);\n\t\tinfo = R_NEW0 (cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {\n\t\t\teprintf (\"locsym err 01\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\teprintf (\"locsym err 02\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 03\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 04\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRDyldLocSym * locsym = R_NEW0 (RDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries (cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\treturn locsym;\n\nbeach:\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\teprintf (\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic ut64 rebase_infos_get_slide(RDyldCache *cache) {\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {\n\tRDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\teprintf (\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof (struct MACH0_(nlist));\n\tif (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree (nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains (hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add (hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tsym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = r_str_newf (\"unk_local%d\", k++);\n\t\t}\n\n\t\tr_list_append (symbols, sym);\n\t}\n\n\tfree (nlists);\n}\n\nstatic void r_dyldcache_free(RDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tr_list_free (cache->bins);\n\tcache->bins = NULL;\n\tr_buf_free (cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free (cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tR_FREE (cache->rebase_infos->entries);\n\t\tR_FREE (cache->rebase_infos);\n\t}\n\tR_FREE (cache->hdr);\n\tR_FREE (cache->maps);\n\tR_FREE (cache->maps_index);\n\tR_FREE (cache->hdr_offset);\n\tR_FREE (cache->accel);\n\tR_FREE (cache->locsym);\n\tR_FREE (cache->oi);\n\tR_FREE (cache);\n}\n\nstatic ut64 bin_obj_va2pa(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf) {\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn 0;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) ((struct MACH0_(obj_t)*)bf->o->bin_obj)->user;\n\tif (!cache) {\n\t\treturn 0;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic struct MACH0_(obj_t) *bin_to_mach0(RBinFile *bf, RDyldBinImage *bin) {\n\tif (!bin || !bf) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.header_at = bin->header_at - bin->hdr_offset;\n\topts.symbols_off = bin->symbols_off;\n\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\n\tmach0->user = cache;\n\tmach0->va2pa = &bin_obj_va2pa;\n\n\tr_buf_free (buf);\n\n\treturn mach0;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}\n\nstatic RDyldRebaseInfo *get_rebase_info(RBinFile *bf, RDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (r_buf_read_at (cache_buf, offset, (ut8*) &slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof (cache_slide3_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc (page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo3 *rebase_info = R_NEW0 (RDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof (cache_slide2_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo2 *rebase_info = R_NEW0 (RDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16*) tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll (rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof (cache_slide1_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64) slide_info.entries_count * (ut64) slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_read_at (cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc (4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfo1 *rebase_info = R_NEW0 (RDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16*) tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else {\n\t\teprintf (\"unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tR_FREE (tmp_buf_1);\n\tR_FREE (tmp_buf_2);\n\tR_FREE (one_page_buf);\n\treturn NULL;\n}\n\nstatic RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {\n\tRDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tut64 slide_infos_offset;\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree (infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree (infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);\n\t\t\tfree (infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info (bf, cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree (result);\n\treturn NULL;\n}\n\nstatic bool check_magic(const char *magic) {\n\treturn !strcmp (magic, \"dyld_v1   arm64\")\n\t\t|| !strcmp (magic, \"dyld_v1  arm64e\")\n\t\t|| !strcmp (magic, \"dyld_v1  x86_64\")\n\t\t|| !strcmp (magic, \"dyld_v1 x86_64h\");\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tif (r_buf_size (buf) < 32) {\n\t\treturn false;\n\t}\n\n\tchar hdr[17] = { 0 };\n\tint rhdr = r_buf_read_at (buf, 0, (ut8 *)&hdr, sizeof (hdr) - 1);\n\tif (rhdr != sizeof (hdr) - 1) {\n\t\treturn false;\n\t}\n\n\treturn check_magic (hdr);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = R_NEWS0 (cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, accel->imagesExtrasOffset, (ut8*) images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (r_buf_read_at (cache_buf, img->pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\tfile[255] = 0;\n\t\t/*char * last_slash = strrchr (file, '/');\n\t\tif (last_slash && *last_slash) {\n\t\t\tlib_name = last_slash + 1;\n\t\t}*/\n\t\treturn strdup (lib_name);\n\t}\n\treturn strdup (\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr ((const char*) a, (const char*) b);\n}\n\nstatic HtPU *create_path_to_index(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0 ();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tfor (i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) != sizeof (file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[sizeof (file) - 1] = 0;\n\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\n\t\tconst char versions_pattern[] = \".framework/Versions/\";\n\t\tchar *versions = strstr (file, versions_pattern);\n\t\tif (versions) {\n\t\t\tchar *next_slash = strchr (versions + 20, '/');\n\t\t\tif (next_slash) {\n\t\t\t\tchar *tail = strdup (next_slash);\n\t\t\t\tif (!tail) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (versions + 10, tail);\n\t\t\t\tfree (tail);\n\t\t\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\t\t\t}\n\t\t}\n\t}\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut8 *cmds = malloc (mh.sizeofcmds + 1);\n\tif (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_read_le32 (cursor);\n\t\tut32 cmdsize = r_read_le32 (cursor + sizeof (ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *) cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\teprintf (\"Warning: alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\teprintf (\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree (cmds);\n}\n\nstatic ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn 0;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn 0;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut64 cursor = cmds_at;\n\tut64 end = cursor + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_buf_read_le32_at (cache->buf, cursor);\n\t\tif (cmd == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tut32 cmdsize = r_buf_read_le32_at (cache->buf, cursor + sizeof (ut32));\n\t\tif (cmdsize == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (cmd == LC_SEGMENT || cmd == LC_SEGMENT_64) {\n\t\t\tchar segname[17];\n\t\t\tsegname[16] = 0;\n\t\t\tif (r_buf_read_at (cache->buf, cursor + 2 * sizeof (ut32), (ut8 *)segname, 16) != 16) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!strncmp (segname, \"__LINKEDIT\", 16)) {\n\t\t\t\tut64 vmaddr = r_buf_read_le64_at (cache->buf, cursor + 2 * sizeof (ut32) + 16);\n\t\t\t\tif (vmaddr == UT64_MAX) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tut32 i,j;\n\t\t\t\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\t\t\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\t\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\t\t\tut32 maps_index = cache->maps_index[i];\n\t\t\t\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\t\t\t\tut64 map_start = cache->maps[maps_index + j].address;\n\t\t\t\t\t\tut64 map_end = map_start + cache->maps[maps_index + j].size;\n\t\t\t\t\t\tif (vmaddr >= map_start && vmaddr < map_end) {\n\t\t\t\t\t\t\treturn hdr_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\treturn 0;\n}\n\nstatic RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}\n\nstatic void rebase_bytes_v1(RDyldRebaseInfo1 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\t\tut64 entry_index = page_offset / 32;\n\t\tut64 offset_in_entry = (page_offset % 32) / 4;\n\n\t\tif (entry_index >= rebase_info->entries_size) {\n\t\t\tin_buf += to_next_page;\n\t\t\toffset += to_next_page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (page_index >= rebase_info->toc_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut8 *entry = &rebase_info->entries[rebase_info->toc[page_index] * rebase_info->entries_size];\n\t\tut8 b = entry[entry_index];\n\n\t\tif (b & (1 << offset_in_entry)) {\n\t\t\tut64 value = r_read_le64 (buf + in_buf);\n\t\t\tvalue += rebase_info->slide;\n\t\t\tr_write_le64 (buf + in_buf, value);\n\t\t\tin_buf += 8;\n\t\t\toffset += 8;\n\t\t} else {\n\t\t\tin_buf += 4;\n\t\t\toffset += 4;\n\t\t}\n\t}\n}\n\nstatic void rebase_bytes_v2(RDyldRebaseInfo2 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut16 page_flag = rebase_info->page_starts[page_index];\n\n\t\tif (page_flag == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!(page_flag & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA)) {\n\t\t\tut64 first_rebase_off = rebase_info->page_starts[page_index] * 4;\n\t\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\t\tut32 delta = 1;\n\t\t\t\twhile (delta) {\n\t\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\t\tif (position >= count) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift);\n\t\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\t\tut64 new_value = raw_value & rebase_info->value_mask;\n\t\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\t\tnew_value += rebase_info->value_add;\n\t\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t\t}\n\t\t\t\t\tfirst_rebase_off += delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic void rebase_bytes_v3(RDyldRebaseInfo3 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut64 delta = rebase_info->page_starts[page_index];\n\n\t\tif (delta == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tut64 first_rebase_off = delta;\n\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\tdo {\n\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\tif (position >= count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift) * 8;\n\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\tut64 new_value = 0;\n\t\t\t\t\tif (R_IS_PTR_AUTHENTICATED (raw_value)) {\n\t\t\t\t\t\tnew_value = (raw_value & 0xFFFFFFFFULL) + rebase_info->auth_value_add;\n\t\t\t\t\t\t// TODO: don't throw auth info away\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_value = ((raw_value << 13) & 0xFF00000000000000ULL) | (raw_value & 0x7ffffffffffULL);\n\t\t\t\t\t\tnew_value &= 0x00FFFFFFFFFFFFFFULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t}\n\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t}\n\t\t\t\tfirst_rebase_off += delta;\n\t\t\t} while (delta);\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic RDyldRebaseInfo *rebase_info_by_range(RDyldRebaseInfos *infos, ut64 offset, int count) {\n\tint imid;\n\tint imin = 0;\n\tint imax = infos->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRDyldRebaseInfosEntry *entry = &infos->entries[imid];\n\t\tif ((entry->end) <= offset) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRDyldRebaseInfosEntry *minEntry = &infos->entries[imin];\n\tif ((imax == imin) && (minEntry->start <= offset + count) && (minEntry->end >= offset)) {\n\t\treturn minEntry->info;\n\t}\n\treturn NULL;\n}\n\nstatic void rebase_bytes(RDyldRebaseInfo *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tif (!rebase_info || !buf) {\n\t\treturn;\n\t}\n\n\tif (rebase_info->version == 3) {\n\t\trebase_bytes_v3 ((RDyldRebaseInfo3*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 2 || rebase_info->version == 4) {\n\t\trebase_bytes_v2 ((RDyldRebaseInfo2*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 1) {\n\t\trebase_bytes_v1 ((RDyldRebaseInfo1*) rebase_info, buf, offset, count, start_of_write);\n\t}\n}\n\nstatic int dyldcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRDyldCache *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t} else {\n\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t}\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->o) {\n\t\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t\t} else {\n\t\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read) {\n\t\tif (fd->plugin->read == &dyldcache_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tRDyldRebaseInfo *rebase_info = rebase_info_by_range (cache->rebase_infos, io->off, count);\n\n\tint result = 0;\n\n\tif (rebase_info && count > 0) {\n\t\tut64 offset_in_data = io->off - rebase_info->start_of_data;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\n\t\tut64 internal_offset = io->off & ~(rebase_info->page_size - 1);\n\t\tut64 internal_end = io->off + count;\n\t\tint rounded_count = internal_end - internal_offset;\n\n\t\tut8 *internal_buf = rebase_info->one_page_buf;\n\t\tif (rounded_count > rebase_info->page_size) {\n\t\t\tinternal_buf = malloc (rounded_count);\n\t\t\tif (!internal_buf) {\n\t\t\t\teprintf (\"Cannot allocate memory for 'internal_buf'\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tut64 original_off = io->off;\n\t\tio->off = internal_offset;\n\n\t\tint internal_result = cache->original_io_read (io, fd, internal_buf, rounded_count);\n\n\t\tio->off = original_off;\n\n\t\tif (internal_result >= page_offset + count) {\n\t\t\trebase_bytes (rebase_info, internal_buf, internal_offset, internal_result, page_offset);\n\t\t\tresult = R_MIN (count, internal_result);\n\t\t\tmemcpy (buf, internal_buf + page_offset, result);\n\t\t} else {\n\t\t\teprintf (\"ERROR rebasing\\n\");\n\t\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t\t}\n\n\t\tif (internal_buf != rebase_info->one_page_buf) {\n\t\t\tR_FREE (internal_buf);\n\t\t}\n\t} else {\n\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t}\n\n\treturn result;\n}\n\nstatic void swizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tcache->original_io_read = plugin->read;\n\tplugin->read = &dyldcache_io_read;\n}\n\nstatic cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = R_NEW0 (cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_hdr_t);\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\tif (!check_magic (hdr->magic)) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\thdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);\n\t\thdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);\n\t}\n\treturn hdr;\n}\n\n\nstatic void populate_cache_headers(RDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRList *hdrs = r_list_newf (NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header (cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE (h->mappingOffset);\n\t\tSHIFT_MAYBE (h->imagesOffset);\n\t\tSHIFT_MAYBE (h->codeSignatureOffset);\n\t\tSHIFT_MAYBE (h->slideInfoOffset);\n\t\tSHIFT_MAYBE (h->localSymbolsOffset);\n\t\tSHIFT_MAYBE (h->branchPoolsOffset);\n\t\tSHIFT_MAYBE (h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tR_FREE (cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));\n\n\tut32 i = 0;\n\tRListIter *iter;\n\tcache_hdr_t *item;\n\tr_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));\n\t}\n\nbeach:\n\tr_list_free (hdrs);\n}\n\nstatic void populate_cache_maps(RDyldCache *cache) {\n\tr_return_if_fail (cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tcache_map_t *maps = NULL;\n\tif (n_maps != 0) {\n\t\tcache->maps_index = R_NEWS0 (ut32, cache->n_hdr);\n\t\tif (!cache->maps_index) {\n\t\t\treturn;\n\t\t}\n\t\tmaps = R_NEWS0 (cache_map_t, n_maps);\n\t}\n\tif (!maps) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tut32 next_map = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof (cache_map_t) * hdr->mappingCount;\n\t\tif (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n}\n\nstatic cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nstatic objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 selrefs_offset = 0;\n\t\tut64 selrefs_size = 0;\n\t\tut8 remaining = 2;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__DATA.__objc_selrefs\")) {\n\t\t\t\tselrefs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tselrefs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tut64 sel_string_base = 0;\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tif (!selrefs_offset || !selrefs_size || cache->n_hdr == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 cursor = selrefs_offset;\n\t\t\tut64 end = cursor + selrefs_size;\n\t\t\twhile (cursor < end) {\n\t\t\t\tut64 sel_ptr = r_buf_read_le64_at (cache->buf, cursor);\n\t\t\t\tif (sel_ptr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut64 sel_offset = va2pa (sel_ptr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tchar * selector = r_buf_get_string (cache->buf, sel_offset);\n\t\t\t\tif (!selector) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool is_magic_selector = !strncmp (selector, \"\\xf0\\x9f\\xa4\\xaf\", 4);\n\t\t\t\tfree (selector);\n\n\t\t\t\tif (is_magic_selector) {\n\t\t\t\t\tsel_string_base = sel_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcursor += 8;\n\t\t\t}\n\t\t\tif (sel_string_base == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);\n\t\t\tif (check != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);\n\t\t\tif (sel_string_base == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);\n\t\t\tif (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult = R_NEW0 (objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRBinAddr *ptr = NULL;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\n\tif (!bf || !bf->o) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tbool big_endian = 0;\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"dyldcache\");\n\tret->rclass = strdup (\"ios\");\n\tret->os = strdup (\"iOS\");\n\tif (strstr (cache->hdr->magic, \"x86_64\")) {\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t} else {\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = strstr (cache->hdr->magic, \"arm64\")? 64: 32;\n\t}\n\tret->machine = strdup (ret->arch);\n\tret->subsystem = strdup (\"xnu\");\n\tret->type = strdup (\"library-cache\");\n\tret->has_va = true;\n\tret->big_endian = big_endian;\n\tret->dbg_info = 0;\n\treturn ret;\n}\n\n#if 0\nstatic void parse_mach0(RList *ret, ut64 paddr, RBinFile *bf) {\n\t// TODO\n}\n#endif\n\nstatic ut64 baddr(RBinFile *bf) {\n\t// XXX hardcoded\n\treturn 0x180000000;\n}\n\nvoid symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\t// const RList*symbols = MACH0_(get_symbols_list) (mach0);\n\tconst struct symbol_t *symbols = MACH0_(get_symbols) (mach0);\n\tif (!symbols) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (symbols[i].name, \"<redacted>\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = strdup (symbols[i].name);\n\t\tsym->vaddr = symbols[i].addr;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = (symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->paddr = symbols[i].offset + bf->o->boffset;\n\t\tsym->size = symbols[i].size;\n\t\tsym->ordinal = i;\n\n\t\tset_u_add (hash, sym->vaddr);\n\t\tr_list_append (ret, sym);\n\t}\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic bool __is_data_section(const char *name) {\n\tif (strstr (name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_os_log\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\tstruct section_t *sections = NULL;\n\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\treturn;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tint i;\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->file) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", bin->file, (char*)sections[i].name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)sections[i].name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = sections[i].size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\tptr->is_data = __is_data_section (ptr->name);\n\t\tptr->size = sections[i].size;\n\t\tptr->vsize = sections[i].vsize;\n\t\tptr->vaddr = sections[i].addr;\n\t\tptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = sections[i].perm;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (sections);\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tsections_from_bin (ret, bf, bin);\n\t}\n\n\tRBinSection *ptr = NULL;\n\tint i;\n\tfor (i = 0; i < cache->n_maps; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr->name = r_str_newf (\"cache_map.%d\", i);\n\t\tptr->size = cache->maps[i].size;\n\t\tptr->vsize = ptr->size;\n\t\tptr->paddr = cache->maps[i].fileOffset;\n\t\tptr->vaddr = cache->maps[i].address;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tptr->perm = prot2perm (cache->maps[i].initProt);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSection *section;\n\t\tr_list_foreach (ret, iter, section) {\n\t\t\tsection->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tSetU *hash = set_u_new ();\n\t\tif (!hash) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_from_bin (cache, ret, bf, bin, hash);\n\t\tsymbols_from_locsym (cache, bin, ret, hash);\n\t\tset_u_free (hash);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSymbol *sym;\n\t\tr_list_foreach (ret, iter, sym) {\n\t\t\tsym->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* static void unswizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin || !cache->original_io_read) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tplugin->read = cache->original_io_read;\n\tcache->original_io_read = NULL;\n} */\n\nstatic void destroy(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\t// unswizzle_io_read (cache, bf->rbin->iob.io); // XXX io may be dead here\n\tr_dyldcache_free (cache);\n}\n\nstatic RList *classes(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->objc_opt_info_loaded) {\n\t\tcache->oi = get_objc_opt_info (bf, cache);\n\t\tcache->objc_opt_info_loaded = true;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\n\tRBuffer *orig_buf = bf->buf;\n\tut32 num_of_unnamed_class = 0;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool is_classlist = strstr (sections[i].name, \"__objc_classlist\");\n\t\t\tbool is_catlist = strstr (sections[i].name, \"__objc_catlist\");\n\n\t\t\tif (!is_classlist && !is_catlist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut8 *pointers = malloc (sections[i].size);\n\t\t\tif (!pointers) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\tif (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {\n\t\t\t\tR_FREE (pointers);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 *cursor = pointers;\n\t\t\tut8 *pointers_end = pointers + sections[i].size;\n\n\t\t\tfor (; cursor < pointers_end; cursor += 8) {\n\t\t\t\tut64 pointer_to_class = r_read_le64 (cursor);\n\n\t\t\t\tRBinClass *klass;\n\t\t\t\tif (!(klass = R_NEW0 (RBinClass)) ||\n\t\t\t\t\t!(klass->methods = r_list_new ()) ||\n\t\t\t\t\t!(klass->fields = r_list_new ())) {\n\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tbf->o->bin_obj = mach0;\n\t\t\t\tbf->buf = cache->buf;\n\t\t\t\tif (is_classlist) {\n\t\t\t\t\tMACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);\n\t\t\t\t} else {\n\t\t\t\t\tMACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);\n\t\t\t\t}\n\t\t\t\tbf->o->bin_obj = cache;\n\t\t\t\tbf->buf = orig_buf;\n\n\t\t\t\tif (!klass->name) {\n\t\t\t\t\teprintf (\"KLASS ERROR AT 0x%\"PFMT64x\", is_classlist %d\\n\", pointer_to_class, is_classlist);\n\t\t\t\t\tklass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);\n\t\t\t\t\tif (!klass->name) {\n\t\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tnum_of_unnamed_class++;\n\t\t\t\t}\n\t\t\t\tr_list_append (ret, klass);\n\t\t\t}\n\n\t\t\tR_FREE (pointers);\n\t\t}\n\n\t\tR_FREE (sections);\n\t\tMACH0_(mach0_free) (mach0);\n\t}\n\n\treturn ret;\n\nbeach:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic void header(RBinFile *bf) {\n\tif (!bf || !bf->o) {\n\t\treturn;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\tPrintfCallback p = bin->cb_printf;\n\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_k (pj, \"header\");\n\tpj_o (pj);\n\tpj_ks (pj, \"magic\", cache->hdr->magic);\n\tpj_kn (pj, \"mappingOffset\", cache->hdr->mappingOffset);\n\tpj_kn (pj, \"mappingCount\", cache->hdr->mappingCount);\n\tpj_kn (pj, \"imagesOffset\", cache->hdr->imagesOffset);\n\tpj_kn (pj, \"imagesCount\", cache->hdr->imagesCount);\n\tpj_kn (pj, \"dyldBaseAddress\", cache->hdr->dyldBaseAddress);\n\tpj_kn (pj, \"codeSignatureOffset\", cache->hdr->codeSignatureOffset);\n\tpj_kn (pj, \"codeSignatureSize\", cache->hdr->codeSignatureSize);\n\tpj_kn (pj, \"slideInfoOffset\", cache->hdr->slideInfoOffset);\n\tpj_kn (pj, \"slideInfoSize\", cache->hdr->slideInfoSize);\n\tpj_kn (pj, \"localSymbolsOffset\", cache->hdr->localSymbolsOffset);\n\tpj_kn (pj, \"localSymbolsSize\", cache->hdr->localSymbolsSize);\n\tchar uuidstr[128];\n\tr_hex_bin2str ((ut8*)cache->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_ks (pj, \"cacheType\", (cache->hdr->cacheType == 0) ? \"development\" : \"production\");\n\tpj_kn (pj, \"branchPoolsOffset\", cache->hdr->branchPoolsOffset);\n\tpj_kn (pj, \"branchPoolsCount\", cache->hdr->branchPoolsCount);\n\tpj_kn (pj, \"accelerateInfoAddr\", cache->hdr->accelerateInfoAddr + slide);\n\tpj_kn (pj, \"accelerateInfoSize\", cache->hdr->accelerateInfoSize);\n\tpj_kn (pj, \"imagesTextOffset\", cache->hdr->imagesTextOffset);\n\tpj_kn (pj, \"imagesTextCount\", cache->hdr->imagesTextCount);\n\tpj_end (pj);\n\n\tif (cache->accel) {\n\t\tpj_k (pj, \"accelerator\");\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"version\", cache->accel->version);\n\t\tpj_kn (pj, \"imageExtrasCount\", cache->accel->imageExtrasCount);\n\t\tpj_kn (pj, \"imagesExtrasOffset\", cache->accel->imagesExtrasOffset);\n\t\tpj_kn (pj, \"bottomUpListOffset\", cache->accel->bottomUpListOffset);\n\t\tpj_kn (pj, \"dylibTrieOffset\", cache->accel->dylibTrieOffset);\n\t\tpj_kn (pj, \"dylibTrieSize\", cache->accel->dylibTrieSize);\n\t\tpj_kn (pj, \"initializersOffset\", cache->accel->initializersOffset);\n\t\tpj_kn (pj, \"initializersCount\", cache->accel->initializersCount);\n\t\tpj_kn (pj, \"dofSectionsOffset\", cache->accel->dofSectionsOffset);\n\t\tpj_kn (pj, \"dofSectionsCount\", cache->accel->dofSectionsCount);\n\t\tpj_kn (pj, \"reExportListOffset\", cache->accel->reExportListOffset);\n\t\tpj_kn (pj, \"reExportCount\", cache->accel->reExportCount);\n\t\tpj_kn (pj, \"depListOffset\", cache->accel->depListOffset);\n\t\tpj_kn (pj, \"depListCount\", cache->accel->depListCount);\n\t\tpj_kn (pj, \"rangeTableOffset\", cache->accel->rangeTableOffset);\n\t\tpj_kn (pj, \"rangeTableCount\", cache->accel->rangeTableCount);\n\t\tpj_kn (pj, \"dyldSectionAddr\", cache->accel->dyldSectionAddr + slide);\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->rebase_infos) {\n\t\tsize_t i;\n\t\tpj_k (pj, \"slideInfo\");\n\t\tpj_a (pj);\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\tRDyldRebaseInfo * rebase_info = cache->rebase_infos->entries[i].info;\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"start\", cache->rebase_infos->entries[i].start);\n\t\t\tpj_kn (pj, \"end\", cache->rebase_infos->entries[i].end);\n\t\t\tif (rebase_info) {\n\t\t\t\tut8 version = rebase_info->version;\n\t\t\t\tpj_kn (pj, \"version\", version);\n\t\t\t\tpj_kn (pj, \"slide\", slide);\n\t\t\t\tif (version == 3) {\n\t\t\t\t\tRDyldRebaseInfo3 *info3 = (RDyldRebaseInfo3*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info3->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info3->page_size);\n\t\t\t\t\tpj_kn (pj, \"auth_value_add\", info3->auth_value_add);\n\t\t\t\t} else if (version == 2 || version == 4) {\n\t\t\t\t\tRDyldRebaseInfo2 *info2 = (RDyldRebaseInfo2*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info2->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_extras_count\", info2->page_extras_count);\n\t\t\t\t\tpj_kn (pj, \"delta_mask\", info2->delta_mask);\n\t\t\t\t\tpj_kn (pj, \"value_mask\", info2->value_mask);\n\t\t\t\t\tpj_kn (pj, \"value_add\", info2->value_add);\n\t\t\t\t\tpj_kn (pj, \"delta_shift\", info2->delta_shift);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info2->page_size);\n\t\t\t\t} else if (version == 1) {\n\t\t\t\t\tRDyldRebaseInfo1 *info1 = (RDyldRebaseInfo1*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"toc_count\", info1->toc_count);\n\t\t\t\t\tpj_kn (pj, \"entries_size\", info1->entries_size);\n\t\t\t\t\tpj_kn (pj, \"page_size\", 4096);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->hdr->imagesTextCount) {\n\t\tpj_k (pj, \"images\");\n\t\tpj_a (pj);\n\t\tut64 total_size = cache->hdr->imagesTextCount * sizeof (cache_text_info_t);\n\t\tcache_text_info_t * text_infos = malloc (total_size);\n\t\tif (!text_infos) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, cache->hdr->imagesTextOffset, (ut8*)text_infos, \"16clii\", cache->hdr->imagesTextCount) != total_size) {\n\t\t\tfree (text_infos);\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i != cache->hdr->imagesTextCount; i++) {\n\t\t\tcache_text_info_t * text_info = &text_infos[i];\n\t\t\tr_hex_bin2str ((ut8*)text_info->uuid, 16, uuidstr);\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"uuid\", uuidstr);\n\t\t\tpj_kn (pj, \"address\", text_info->loadAddress + slide);\n\t\t\tpj_kn (pj, \"textSegmentSize\", text_info->textSegmentSize);\n\t\t\tchar file[256];\n\t\t\tif (r_buf_read_at (cache->buf, text_info->pathOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\tfile[255] = 0;\n\t\t\t\tpj_ks (pj, \"path\", file);\n\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\tpj_ks (pj, \"name\", last_slash + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"name\", file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tfree (text_infos);\n\t}\n\n\tpj_end (pj);\n\tp (\"%s\", pj_string (pj));\n\nbeach:\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_dyldcache = {\n\t.name = \"dyldcache\",\n\t.desc = \"dyldcache bin plugin\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check_buffer = &check_buffer,\n\t.destroy = &destroy,\n\t.classes = &classes,\n\t.header = &header,\n\t.info = &info,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dyldcache,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2015-2018 - Dax89, pancake */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"../i/private.h\"\n#include \"psxexe/psxexe.h\"\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 magic[PSXEXE_ID_LEN];\n\tif (r_buf_read_at (b, 0, magic, sizeof (magic)) == PSXEXE_ID_LEN) {\n\t\treturn !memcmp (magic, PSXEXE_ID, PSXEXE_ID_LEN);\n\t}\n\treturn false;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {\n\treturn check_buffer (bf, b);\n}\n\nstatic RBinInfo* info(RBinFile* bf) {\n\tRBinInfo* ret = NULL;\n\tpsxexe_header psxheader = {0};\n\n\tif (r_buf_read_at (bf->buf, 0, (ut8*)&psxheader, sizeof(psxexe_header)) < sizeof(psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\n\tret->file = strdup (bf->file);\n\tret->type = strdup (\"Sony PlayStation 1 Executable\");\n\tret->machine = strdup (\"Sony PlayStation 1\");\n\tret->os = strdup (\"psx\");\n\tret->arch = strdup (\"mips\");\n\tret->bits = 32;\n\tret->has_va = true;\n\treturn ret;\n}\n\nstatic RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) != sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tsz = r_buf_size (bf->buf);\n\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\n\tr_list_append (ret, sect);\n\treturn ret;\n}\n\nstatic RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) != sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\n\tr_list_append (ret, addr);\n\treturn ret;\n}\n\nstatic RList* strings(RBinFile* bf) {\n\t// hardcode minstrlen = 20\n\treturn r_bin_file_get_strings (bf, 20, 0, 2);\n}\n\nRBinPlugin r_bin_plugin_psxexe = {\n\t.name = \"psxexe\",\n\t.desc = \"Sony PlayStation 1 Executable\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.info = &info,\n\t.sections = &sections,\n\t.entries = &entries,\n\t.strings = &strings,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_psxexe,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare2 - LGPL3 - 2015-2022 - deepakchethan */\n\n#include \"qnx/qnx.h\"\n#include \"../i/private.h\"\n\nstatic int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) != QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tut8 tmp[6];\n\tint r = r_buf_read_at (buf, 0, tmp, sizeof (tmp));\n\treturn r == sizeof (tmp) && !memcmp (tmp, QNX_MAGIC, sizeof (tmp));\n}\n\n// Frees the bin_obj of the binary file\nstatic void destroy(RBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\tr_list_free (qo->sections);\n\tr_list_free (qo->fixups);\n\tbf->o->bin_obj = NULL;\n\tfree (qo);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tQnxObj *qo = R_NEW0 (QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\tRList *sections = NULL;\n\tRList *fixups = NULL;\n\n\tif (!qo) {\n\t\tgoto beach;\n\t}\n\tif (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {\n\t\tgoto beach;\n\t}\n\tqo->kv = sdb_new0 ();\n\tif (!qo->kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load (&qo->lmfh, bf->buf, qo->kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof (lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) != sizeof (lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_RESOURCE\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup (\"LMF_LOAD\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vaddr = ldata.offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof (lmf_data);\n\t\t\tptr->size = ptr->vsize;\n\t\t\tptr->add = true;\n\t\t \tr_list_append (sections, ptr);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'f'; // \"LMF_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRBinReloc *ptr = R_NEW0 (RBinReloc);\n\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'F'; // \"LMF_8087_FIXUP\";\n\t\t\tr_list_append (fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\tr_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, \"si\", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set (sdb, \"info\", qo->kv);\n\tqo->sections = sections;\n\tqo->fixups = fixups;\n\t*bin_obj = qo;\n\treturn true;\nbeach:\n\tfree (qo);\n\tr_list_free (fixups);\n\tr_list_free (sections);\n\treturn false;\n}\n\n/*\n * Provides the info about the binary file\n * @param RBinFile to extract the data from\n * @return RBinInfo file with the info\n */\nstatic RBinInfo *info(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = bf->file? strdup (bf->file): NULL;\n\tret->type = strdup (\"QNX Executable\");\n\tret->bclass = strdup (\"qnx\");\n\tret->machine = strdup (\"i386\");\n\tret->rclass = strdup (\"QNX\");\n\tret->arch = strdup (\"x86\");\n\tret->os = strdup (\"any\");\n\tret->subsystem = strdup (\"any\");\n\tret->lang = \"C/C++\";\n\tret->signature = true;\n\treturn ret;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn r_list_clone (qo->fixups);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o && bf->rbin);\n\tQnxObj *bin = bf->o->bin_obj;\n\tRBin *rbin = bf->rbin;\n\trbin->cb_printf (\"QNX file header:\\n\");\n\trbin->cb_printf (\"version : 0x%xH\\n\", bin->lmfh.version);\n\trbin->cb_printf (\"cflags : 0x%xH\\n\", bin->lmfh.cflags);\n\trbin->cb_printf (\"cpu : 0x%xH\\n\", bin->lmfh.cpu);\n\trbin->cb_printf (\"fpu : 0x%xH\\n\", bin->lmfh.fpu);\n\trbin->cb_printf (\"code_index : 0x%xH\\n\", bin->lmfh.code_index);\n\trbin->cb_printf (\"stack_index : 0x%xH\\n\", bin->lmfh.stack_index);\n\trbin->cb_printf (\"heap_index : 0x%xH\\n\", bin->lmfh.heap_index);\n\trbin->cb_printf (\"argv_index : 0x%xH\\n\", bin->lmfh.argv_index);\n\trbin->cb_printf (\"spare2[4] : 0x0H\\n\");\n\trbin->cb_printf (\"code_offset : 0x%xH\\n\", bin->lmfh.code_offset);\n\trbin->cb_printf (\"stack_nbytes : 0x%xH\\n\", bin->lmfh.stack_nbytes);\n\trbin->cb_printf (\"heap_nbytes : 0x%xH\\n\", bin->lmfh.heap_nbytes);\n\trbin->cb_printf (\"image_base : 0x%xH\\n\", bin->lmfh.image_base);\n\trbin->cb_printf (\"spare3[2] : 0x0H\\n\");\n}\n\n/*\n * No mention of symbols in the doc\n */\nstatic RList* symbols(RBinFile *bf) {\n\treturn NULL;\n}\n\n// Returns the sections\nstatic RList* sections(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn r_list_clone (qo->sections);\n}\n\n/*\n * Returns the sdb\n * @param RBinFile\n * @return sdb of the bin_obj\n */\nstatic Sdb *get_sdb(RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tQnxObj *qo = o->bin_obj;\n\treturn qo? qo->kv: NULL;\n}\n\n/*\n * Returns the base address of the image from the binary header\n * @param RBinFile\n * @return image_base address\n */\nstatic ut64 baddr(RBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? qo->lmfh.image_base: 0;\n}\n\n/*\n * Currently both physical and virtual address are set to 0\n * The memory map has different values for entry\n */\nstatic RList* entries(RBinFile *bf) {\n\tRList *ret;\n\tRBinAddr *ptr = NULL;\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = qo->lmfh.code_offset;\n\tptr->vaddr = qo->lmfh.code_offset + baddr (bf);\n\tr_list_append (ret, ptr);\n\treturn ret;\n}\n\n/*\n * @param RBinFile\n * @return signature of the binary\n */\nstatic char *signature(RBinFile *bf, bool json) {\n \tchar buf[64];\n \tQnxObj *qo = bf->o->bin_obj;\n\treturn qo? r_str_dup (NULL, sdb_itoa (qo->rwend.signature, buf, 10)): NULL;\n}\n\n/*\n * @return: returns the vaddr\n */\nstatic ut64 get_vaddr(RBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {\n\treturn vaddr;\n}\n\n// Declaration of the plugin\nRBinPlugin r_bin_plugin_qnx = {\n\t.name = \"qnx\",\n\t.desc = \"QNX executable file support\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.relocs = &relocs,\n\t.baddr = &baddr,\n\t.author = \"deepakchethan\",\n\t.check_buffer = &check_buffer,\n\t.header = &header,\n\t.get_sdb = &get_sdb,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.signature = &signature,\n\t.get_vaddr = &get_vaddr,\n\t.info = &info\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_qnx,\n\t.version = R2_VERSION\n};\n#endif\n", "/* radare - LGPL - Copyright 2009-2022 - ret2libc, pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_io.h>\n\ntypedef enum {\n\tR_BUFFER_FILE,\n\tR_BUFFER_IO,\n\tR_BUFFER_BYTES,\n\tR_BUFFER_MMAP,\n\tR_BUFFER_SPARSE,\n\tR_BUFFER_REF,\n} RBufferType;\n\n#include \"buf_file.c\"\n#include \"buf_sparse.c\"\n#include \"buf_bytes.c\"\n#include \"buf_mmap.c\"\n#include \"buf_io.c\"\n#include \"buf_ref.c\"\n\nstatic bool buf_init(RBuffer *b, const void *user) {\n\tr_return_val_if_fail (b && b->methods, false);\n\treturn b->methods->init? b->methods->init (b, user): true;\n}\n\nstatic void buf_wholefree(RBuffer *b) {\n\tif (!b->methods->get_whole_buf) {\n\t\tR_FREE (b->whole_buf);\n\t}\n}\n\nstatic bool buf_fini(RBuffer *b) {\n\tr_return_val_if_fail (b && b->methods, false);\n\treturn b->methods->fini? b->methods->fini (b): true;\n}\n\nstatic ut64 buf_get_size(RBuffer *b) {\n\tr_return_val_if_fail (b && b->methods, UT64_MAX);\n\treturn b->methods->get_size? b->methods->get_size (b): UT64_MAX;\n}\n\nstatic st64 buf_read(RBuffer *b, ut8 *buf, size_t len) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->read? b->methods->read (b, buf, len): -1;\n}\n\nstatic st64 buf_write(RBuffer *b, const ut8 *buf, size_t len) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\tbuf_wholefree (b);\n\treturn b->methods->write? b->methods->write (b, buf, len): -1;\n}\n\nstatic st64 buf_seek(RBuffer *b, st64 addr, int whence) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->seek? b->methods->seek (b, addr, whence): -1;\n}\n\nstatic bool buf_resize(RBuffer *b, ut64 newsize) {\n\tr_return_val_if_fail (b && b->methods, -1);\n\treturn b->methods->resize? b->methods->resize (b, newsize): false;\n}\n\nstatic ut8 *get_whole_buf(RBuffer *b, ut64 *sz) {\n\tr_return_val_if_fail (b && b->methods, NULL);\n\tif (b->methods->get_whole_buf) {\n\t\treturn b->methods->get_whole_buf (b, sz);\n\t}\n\tut64 bsz = r_buf_size (b);\n\t// bsz = 4096; // FAKE MINIMUM SIZE TO READ THE BIN HEADER\n\tif (bsz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tfree (b->whole_buf);\n\tb->whole_buf = R_NEWS (ut8, bsz);\n\tif (!b->whole_buf) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (b, 0, b->whole_buf, bsz);\n\tif (sz) {\n\t\t*sz = bsz;\n\t}\n\treturn b->whole_buf;\n}\n\nstatic RBuffer *new_buffer(RBufferType type, const void *user) {\n\tRBuffer *b = R_NEW0 (RBuffer);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tswitch (type) {\n\tcase R_BUFFER_BYTES:\n\t\tb->methods = &buffer_bytes_methods;\n\t\tbreak;\n\tcase R_BUFFER_MMAP:\n\t\tb->methods = &buffer_mmap_methods;\n\t\tbreak;\n\tcase R_BUFFER_SPARSE:\n\t\tb->methods = &buffer_sparse_methods;\n\t\tbreak;\n\tcase R_BUFFER_FILE:\n\t\tb->methods = &buffer_file_methods;\n\t\tbreak;\n\tcase R_BUFFER_IO:\n\t\tb->methods = &buffer_io_methods;\n\t\tbreak;\n\tcase R_BUFFER_REF:\n\t\tb->methods = &buffer_ref_methods;\n\t\tbreak;\n\tdefault:\n\t\tr_warn_if_reached ();\n\t\tbreak;\n\t}\n\tif (!buf_init (b, user)) {\n\t\tfree (b);\n\t\treturn NULL;\n\t}\n\treturn b;\n}\n\n// TODO: Optimize to use memcpy when buffers are not in range..\n// check buf boundaries and offsets and use memcpy or memmove\n\n// copied from libr/io/cache.c:r_io_cache_read\n// ret # of bytes copied\nR_API RBuffer *r_buf_new_with_io(void *iob, int fd) {\n\tr_return_val_if_fail (iob && fd >= 0, NULL);\n\tstruct buf_io_user u = { 0 };\n\tu.iob = (RIOBind *)iob;\n\tu.fd = fd;\n\treturn new_buffer (R_BUFFER_IO, &u);\n}\n\nR_API RBuffer *r_buf_new_with_pointers(const ut8 *bytes, ut64 len, bool steal) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = bytes;\n\tu.length = len;\n\tu.steal = steal;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API RBuffer *r_buf_new_empty(ut64 len) {\n\tut8 *buf = R_NEWS0 (ut8, len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = buf;\n\tu.length = len;\n\tu.steal = true;\n\tRBuffer *res = new_buffer (R_BUFFER_BYTES, &u);\n\tif (!res) {\n\t\tfree (buf);\n\t}\n\treturn res;\n}\n\nR_API RBuffer *r_buf_new_with_bytes(const ut8 *bytes, ut64 len) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data = bytes;\n\tu.length = len;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API RBuffer *r_buf_new_slice(RBuffer *b, ut64 offset, ut64 size) {\n\tstruct buf_ref_user u = { 0 };\n\tu.parent = b;\n\tu.offset = offset;\n\tu.size = size;\n\treturn new_buffer (R_BUFFER_REF, &u);\n}\n\nR_API RBuffer *r_buf_new_with_string(const char *msg) {\n\treturn r_buf_new_with_bytes ((const ut8 *)msg, (ut64)strlen (msg));\n}\n\nR_API RBuffer *r_buf_new_with_buf(RBuffer *b) {\n\tut64 sz = 0;\n\tconst ut8 *tmp = r_buf_data (b, &sz);\n\treturn r_buf_new_with_bytes (tmp, sz);\n}\n\nR_API RBuffer *r_buf_new_sparse(ut8 Oxff) {\n\tRBuffer *b = new_buffer (R_BUFFER_SPARSE, NULL);\n\tif (b) {\n\t\tb->Oxff_priv = Oxff;\n\t}\n\treturn b;\n}\n\nR_API RBuffer *r_buf_new(void) {\n\tstruct buf_bytes_user u = { 0 };\n\tu.data = NULL;\n\tu.length = 0;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_DEPRECATE R_API const ut8 *r_buf_data(RBuffer *b, ut64 *size) {\n\tr_return_val_if_fail (b, NULL);\n\tb->whole_buf = get_whole_buf (b, size);\n\treturn b->whole_buf;\n}\n\nR_API ut64 r_buf_size(RBuffer *b) {\n\tr_return_val_if_fail (b, 0);\n\treturn buf_get_size (b);\n}\n\n// rename to new?\nR_API RBuffer *r_buf_new_mmap(const char *filename, int perm) {\n\tr_return_val_if_fail (filename, NULL);\n\tstruct buf_mmap_user u = { 0 };\n\tu.filename = filename;\n\tu.perm = perm;\n\treturn new_buffer (R_BUFFER_MMAP, &u);\n}\n\nR_API RBuffer *r_buf_new_file(const char *file, int perm, int mode) {\n\tstruct buf_file_user u = { 0 };\n\tu.file = file;\n\tu.perm = perm;\n\tu.mode = mode;\n\treturn new_buffer (R_BUFFER_FILE, &u);\n}\n\n// TODO: rename to new_from_file ?\nR_API RBuffer *r_buf_new_slurp(const char *file) {\n\tsize_t len;\n\tchar *tmp = r_file_slurp (file, &len);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tstruct buf_bytes_user u = { 0 };\n\tu.data_steal = (ut8 *)tmp;\n\tu.length = (ut64)len;\n\tu.steal = true;\n\treturn new_buffer (R_BUFFER_BYTES, &u);\n}\n\nR_API bool r_buf_dump(RBuffer *b, const char *file) {\n\t// TODO: need to redo this\n\tif (!b || !file) {\n\t\treturn false;\n\t}\n\tut64 tmpsz = 0;\n\tconst ut8 *tmp = r_buf_data (b, &tmpsz);\n\treturn r_file_dump (file, tmp, tmpsz, 0);\n}\n\nR_API st64 r_buf_seek(RBuffer *b, st64 addr, int whence) {\n\tr_return_val_if_fail (b, -1);\n\treturn buf_seek (b, addr, whence);\n}\n\nR_API ut64 r_buf_tell(RBuffer *b) {\n\treturn r_buf_seek (b, 0, R_BUF_CUR);\n}\n\nR_API bool r_buf_set_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\tif (!r_buf_resize (b, 0)) {\n\t\treturn false;\n\t}\n\tif (r_buf_seek (b, 0, R_BUF_SET) < 0) {\n\t\treturn false;\n\t}\n\tif (!r_buf_append_bytes (b, buf, length)) {\n\t\treturn false;\n\t}\n\treturn r_buf_seek (b, 0, R_BUF_SET) >= 0;\n}\n\nR_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\treturn r_buf_insert_bytes (b, 0, buf, length) >= 0;\n}\n\nR_API char *r_buf_to_string(RBuffer *b) {\n\tut64 sz = r_buf_size (b);\n\tchar *s = malloc (sz + 1);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (b, 0, (ut8 *)s, sz) < 0) {\n\t\tfree (s);\n\t\treturn NULL;\n\t}\n\ts[sz] = '\\0';\n\treturn s;\n}\n\nR_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && buf && !b->readonly, false);\n\n\tif (r_buf_seek (b, 0, R_BUF_END) < 0) {\n\t\treturn false;\n\t}\n\treturn r_buf_write (b, buf, length) >= 0;\n}\n\nR_API bool r_buf_append_nbytes(RBuffer *b, ut64 length) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\tut8 *buf = R_NEWS0 (ut8, length);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tbool res = r_buf_append_bytes (b, buf, length);\n\tfree (buf);\n\treturn res;\n}\n\nR_API st64 r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, ut64 length) {\n\tr_return_val_if_fail (b && !b->readonly, -1);\n\tst64 pos, r = r_buf_seek (b, 0, R_BUF_CUR);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tpos = r;\n\tr = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto restore_pos;\n\t}\n\n\tut64 sz = r_buf_size (b);\n\tut8 *tmp = R_NEWS (ut8, sz - addr);\n\tr = r_buf_read (b, tmp, sz - addr);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tst64 tmp_length = r;\n\tif (!r_buf_resize (b, sz + length)) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_seek (b, addr + length, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_write (b, tmp, tmp_length);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\tgoto free_tmp;\n\t}\n\tr = r_buf_write (b, buf, length);\nfree_tmp:\n\tfree (tmp);\nrestore_pos:\n\tr_buf_seek (b, pos, R_BUF_SET);\n\treturn r;\n}\n\nR_API bool r_buf_append_ut8(RBuffer *b, ut8 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut16(RBuffer *b, ut16 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut32(RBuffer *b, ut32 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_ut64(RBuffer *b, ut64 n) {\n\tr_return_val_if_fail (b && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)&n, sizeof (n));\n}\n\nR_API bool r_buf_append_buf(RBuffer *b, RBuffer *a) {\n\tr_return_val_if_fail (b && a && !b->readonly, false);\n\tut64 sz = 0;\n\tconst ut8 *tmp = r_buf_data (a, &sz);\n\treturn r_buf_append_bytes (b, tmp, sz);\n}\n\nR_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, ut64 size) {\n\tr_return_val_if_fail (b && a && !b->readonly, false);\n\tut8 *tmp = R_NEWS (ut8, size);\n\tbool res = false;\n\n\tif (!tmp) {\n\t\treturn false;\n\t}\n\tst64 r = r_buf_read_at (a, offset, tmp, size);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\tres = r_buf_append_bytes (b, tmp, r);\nerr:\n\tfree (tmp);\n\treturn res;\n}\n\n// return an heap-allocated string read from the RBuffer b at address addr. The\n// length depends on the first '\\0' found in the buffer. If there is no '\\0' in\n// the buffer, there is no string, thus NULL is returned.\nR_API char *r_buf_get_string(RBuffer *b, ut64 addr) {\n\tconst int MIN_RES_SZ = 64;\n\tut8 *res = R_NEWS (ut8, MIN_RES_SZ + 1);\n\tut64 sz = 0;\n\tst64 r = r_buf_read_at (b, addr, res, MIN_RES_SZ);\n\tbool null_found = false;\n\twhile (r > 0) {\n\t\tconst ut8 *needle = r_mem_mem (res + sz, r, (ut8 *)\"\\x00\", 1);\n\t\tif (needle) {\n\t\t\tnull_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tsz += r;\n\t\taddr += r;\n\n\t\tut8 *restmp = realloc (res, sz + MIN_RES_SZ + 1);\n\t\tif (!restmp) {\n\t\t\tfree (res);\n\t\t\treturn NULL;\n\t\t}\n\t\tres = restmp;\n\t\tr = r_buf_read_at (b, addr, res + sz, MIN_RES_SZ);\n\t}\n\tif (r < 0 || !null_found) {\n\t\tfree (res);\n\t\treturn NULL;\n\t}\n\treturn (char *)res;\n}\n\nR_API ut8 *r_buf_read_all(RBuffer *b, int *blen) {\n\tr_return_val_if_fail (b, NULL);\n\tint buflen = r_buf_size (b);\n\tif (buflen < 0) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = malloc (buflen + 1);\n\tbuf_seek (b, 0, R_BUF_SET);\n\tbuf_read (b, buf, buflen);\n\tif (blen) {\n\t\t*blen = buflen;\n\t}\n\treturn buf;\n}\n\nR_API st64 r_buf_read(RBuffer *b, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 r = buf_read (b, buf, len);\n\tif (r >= 0 && r < len) {\n\t\tmemset (buf + r, b->Oxff_priv, len - r);\n\t}\n\treturn r;\n}\n\nR_API st64 r_buf_write(RBuffer *b, const ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf && !b->readonly, -1);\n\treturn buf_write (b, buf, len);\n}\n\nR_API ut8 r_buf_read8(RBuffer *b) {\n\tut8 res;\n\tst64 r = r_buf_read (b, &res, sizeof (res));\n\treturn r == sizeof (res)? res: b->Oxff_priv;\n}\n\nR_API ut8 r_buf_read8_at(RBuffer *b, ut64 addr) {\n\tut8 res;\n\tst64 r = r_buf_read_at (b, addr, &res, sizeof (res));\n\treturn r == sizeof (res)? res: b->Oxff_priv;\n}\n\nstatic st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {\n\tst64 res = 0;\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tint j;\n\t\tint m = 1;\n\t\tint tsize = 2;\n\t\tbool bigendian = true;\n\n\t\tfor (j = 0; fmt[j]; j++) {\n\t\t\tswitch (fmt[j]) {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tif (m == 1) {\n\t\t\t\t\tm = r_num_get (NULL, &fmt[j]);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase 's': tsize = 2; bigendian = false; break;\n\t\t\tcase 'S': tsize = 2; bigendian = true; break;\n\t\t\tcase 'i': tsize = 4; bigendian = false; break;\n\t\t\tcase 'I': tsize = 4; bigendian = true; break;\n\t\t\tcase 'l': tsize = 8; bigendian = false; break;\n\t\t\tcase 'L': tsize = 8; bigendian = true; break;\n\t\t\tcase 'c': tsize = 1; bigendian = false; break;\n\t\t\tdefault: return -1;\n\t\t\t}\n\n\t\t\tint k;\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tut8 tmp[sizeof (ut64)];\n\t\t\t\tut8 d1;\n\t\t\t\tut16 d2;\n\t\t\t\tut32 d3;\n\t\t\t\tut64 d4;\n\t\t\t\tst64 r = r_buf_read (src, tmp, tsize);\n\t\t\t\tif (r != tsize) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tswitch (tsize) {\n\t\t\t\tcase 1:\n\t\t\t\t\td1 = r_read_ble8 (tmp);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d1, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\td2 = r_read_ble16 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d2, 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\td3 = r_read_ble32 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d3, 4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\td4 = r_read_ble64 (tmp, bigendian);\n\t\t\t\t\tr = r_buf_write (dst, (ut8 *)&d4, 8);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tres += r;\n\t\t\t}\n\t\t\tm = 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API st64 r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\t// XXX: we assume the caller knows what he's doing\n\tRBuffer *dst = r_buf_new_with_pointers (buf, UT64_MAX, false);\n\tst64 res = buf_format (dst, b, fmt, n);\n\tr_buf_free (dst);\n\treturn res;\n}\n\nR_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\t(void)r_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt && !b->readonly, -1);\n\t// XXX: we assume the caller knows what he's doing\n\tRBuffer *src = r_buf_new_with_pointers (buf, UT64_MAX, false);\n\tst64 res = buf_format (b, src, fmt, n);\n\tr_buf_free (src);\n\treturn res;\n}\n\nR_API st64 r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt && !b->readonly, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fwrite (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API st64 r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf && !b->readonly, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_write (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}\n\nR_API void r_buf_fini(RBuffer *b) {\n\tif (!b) {\n\t\treturn;\n\t}\n\tif (b->refctr > 0) {\n\t\tb->refctr--;\n\t\treturn;\n\t}\n\n\t// free the whole_buf only if it was initially allocated by the buf types\n\tif (b->methods->get_whole_buf) {\n\t\tif (b->methods->free_whole_buf) {\n\t\t\tb->methods->free_whole_buf (b);\n\t\t}\n\t} else {\n\t\tbuf_wholefree (b);\n\t}\n\tbuf_fini (b);\n}\n\nR_API void r_buf_free(RBuffer *b) {\n\tbool unreferenced = b && b->refctr == 0;\n\tr_buf_fini (b);\n\tif (unreferenced) {\n\t\tfree (b);\n\t}\n}\n\nR_API st64 r_buf_append_string(RBuffer *b, const char *str) {\n\tr_return_val_if_fail (b && str && !b->readonly, false);\n\treturn r_buf_append_bytes (b, (const ut8 *)str, strlen (str));\n}\n\nR_API bool r_buf_resize(RBuffer *b, ut64 newsize) {\n\tr_return_val_if_fail (b, false);\n\treturn buf_resize (b, newsize);\n}\n\nR_API RBuffer *r_buf_ref(RBuffer *b) {\n\tif (b) {\n\t\tb->refctr++;\n\t}\n\treturn b;\n}\n\nR_API RList *r_buf_nonempty_list(RBuffer *b) {\n\treturn b->methods->nonempty_list? b->methods->nonempty_list (b): NULL;\n}\n\nR_API st64 r_buf_uleb128(RBuffer *b, ut64 *v) {\n\tut8 c = 0xff;\n\tut64 s = 0, sum = 0, l = 0;\n\tdo {\n\t\tut8 data;\n\t\tst64 r = r_buf_read (b, &data, sizeof (data));\n\t\tif (r < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tc = data & 0xff;\n\t\tif (s < 64) {\n\t\t\tsum |= ((ut64) (c & 0x7f) << s);\n\t\t\ts += 7;\n\t\t} else {\n\t\t\tsum = 0;\n\t\t}\n\t\tl++;\n\t} while (c & 0x80);\n\tif (v) {\n\t\t*v = sum;\n\t}\n\treturn l;\n}\n\nR_API st64 r_buf_sleb128(RBuffer *b, st64 *v) {\n\tst64 result = 0, offset = 0;\n\tut8 value;\n\tdo {\n\t\tst64 chunk;\n\t\tst64 r = r_buf_read (b, &value, sizeof (value));\n\t\tif (r != sizeof (value)) {\n\t\t\treturn -1;\n\t\t}\n\t\tchunk = value & 0x7f;\n\t\tif (offset < 64) {\n\t\t\tresult |= (chunk << offset);\n\t\t\toffset += 7;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t} while (value & 0x80);\n\n\tif ((value & 0x40) != 0) {\n\t\tif (offset < 64) {\n\t\t\tresult |= ~0ULL << offset;\n\t\t}\n\t}\n\tif (v) {\n\t\t*v = result;\n\t}\n\treturn offset / 7;\n}\n"], "filenames": ["libr/bin/format/pe/pe.c", "libr/bin/p/bin_dyldcache.c", "libr/bin/p/bin_psxexe.c", "libr/bin/p/bin_qnx.c", "libr/util/buf.c"], "buggy_code_start_loc": [1, 590, 60, 10, 519], "buggy_code_end_loc": [1824, 591, 97, 122, 602], "fixing_code_start_loc": [1, 590, 60, 10, 519], "fixing_code_end_loc": [1822, 591, 97, 122, 599], "type": "CWE-400", "message": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.", "other": {"cve": {"id": "CVE-2022-0695", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-24T13:15:07.803", "lastModified": "2022-04-08T13:57:59.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4."}, {"lang": "es", "value": "Una Denegaci\u00f3n de Servicio en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.4", "matchCriteriaId": "257C5522-E8C9-42F8-8891-50EDBDD3E873"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/bdbddc0e-fb06-4211-a90b-7cbedcee2bea", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf"}}