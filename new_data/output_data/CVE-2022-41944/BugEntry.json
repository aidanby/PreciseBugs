{"buggy_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n\n  requires_login\n  before_action :ensure_admin, only: [:create, :update, :destroy]\n  before_action :set_notification, only: [:update, :destroy]\n\n  def index\n    user =\n      if params[:username] && !params[:recent]\n        user_record = User.find_by(username: params[:username].to_s)\n        raise Discourse::NotFound if !user_record\n        user_record\n      else\n        current_user\n      end\n\n    guardian.ensure_can_see_notifications!(user)\n\n    if notification_types = params[:filter_by_types]&.split(\",\").presence\n      notification_types.map! do |type|\n        Notification.types[type.to_sym] || (\n          raise Discourse::InvalidParameters.new(\"invalid notification type: #{type}\")\n        )\n      end\n    end\n\n    if params[:recent].present?\n      limit = (params[:limit] || 15).to_i\n      limit = 50 if limit > 50\n\n      include_reviewables = false\n      if SiteSetting.enable_experimental_sidebar_hamburger\n        notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types)\n        # notification_types is blank for the \"all notifications\" user menu tab\n        include_reviewables = notification_types.blank? && guardian.can_see_review_queue?\n      else\n        notifications = Notification.recent_report(current_user, limit, notification_types)\n      end\n\n      if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)\n        if changed = current_user.bump_last_seen_notification!\n          current_user.reload\n          current_user.publish_notifications_state\n        end\n      end\n\n      if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables\n        current_user_id = current_user.id\n        Scheduler::Defer.later \"bump last seen reviewable for user\" do\n          # we lookup current_user again in the background thread to avoid\n          # concurrency issues where the user object returned by the\n          # current_user controller method is changed by the time the deferred\n          # block is executed\n          User.find_by(id: current_user_id)&.bump_last_seen_reviewable!\n        end\n      end\n\n      json = {\n        notifications: serialize_data(notifications, NotificationSerializer),\n        seen_notification_id: current_user.seen_notification_id\n      }\n      if include_reviewables\n        json[:pending_reviewables] = Reviewable.basic_serializers_for_list(\n          Reviewable.user_menu_list_for(current_user),\n          current_user\n        ).as_json\n      end\n      render_json_dump(json)\n    else\n      offset = params[:offset].to_i\n\n      notifications = Notification.where(user_id: user.id)\n        .visible\n        .includes(:topic)\n        .order(created_at: :desc)\n\n      notifications = notifications.where(read: true) if params[:filter] == \"read\"\n\n      notifications = notifications.where(read: false) if params[:filter] == \"unread\"\n\n      total_rows = notifications.dup.count\n      notifications = notifications.offset(offset).limit(60)\n      render_json_dump(notifications: serialize_data(notifications, NotificationSerializer),\n                       total_rows_notifications: total_rows,\n                       seen_notification_id: user.seen_notification_id,\n                       load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]))\n    end\n\n  end\n\n  def mark_read\n    if params[:id]\n      Notification.read(current_user, [params[:id].to_i])\n    else\n      if types = params[:dismiss_types]&.split(\",\").presence\n        invalid = []\n        types.map! do |type|\n          type_id = Notification.types[type.to_sym]\n          invalid << type if !type_id\n          type_id\n        end\n        if invalid.size > 0\n          raise Discourse::InvalidParameters.new(\"invalid notification types: #{invalid.inspect}\")\n        end\n      end\n\n      Notification.read_types(current_user, types)\n      current_user.bump_last_seen_notification!\n    end\n\n    current_user.reload\n    current_user.publish_notifications_state\n\n    render json: success_json\n  end\n\n  def create\n    @notification = Notification.consolidate_or_create!(notification_params)\n    render_notification\n  end\n\n  def update\n    @notification.update!(notification_params)\n    render_notification\n  end\n\n  def destroy\n    @notification.destroy!\n    render json: success_json\n  end\n\n  private\n\n  def set_notification\n    @notification = Notification.find(params[:id])\n  end\n\n  def notification_params\n    params.permit(:notification_type, :user_id, :data, :read, :topic_id, :post_number, :post_action_id)\n  end\n\n  def render_notification\n    render_json_dump(NotificationSerializer.new(@notification, scope: guardian, root: false))\n  end\n\nend\n", "# frozen_string_literal: true\n\ndef create_notification(user_id, resp_code, matcher)\n  notification_count = Notification.count\n  post \"/notifications.json\",\n    params: {\n      notification_type: Notification.types[:mentioned],\n      user_id: user_id,\n      data: { message: 'tada' }.to_json\n    }\n  expect(response.status).to eq(resp_code)\n  expect(Notification.count).public_send(matcher, eq(notification_count))\nend\n\ndef update_notification(topic_id, resp_code, matcher)\n  notification = Fabricate(:notification)\n  put \"/notifications/#{notification.id}.json\", params: { topic_id: topic_id }\n  expect(response.status).to eq(resp_code)\n  notification.reload\n  expect(notification.topic_id).public_send(matcher, eq(topic_id))\nend\n\ndef delete_notification(resp_code, matcher)\n  notification = Fabricate(:notification)\n  notification_count = Notification.count\n  delete \"/notifications/#{notification.id}.json\"\n  expect(response.status).to eq(resp_code)\n  expect(Notification.count).public_send(matcher, eq(notification_count))\nend\n\nRSpec.describe NotificationsController do\n  context 'when logged in' do\n    context 'as normal user' do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:notification) { Fabricate(:notification, user: user) }\n\n      describe '#index' do\n        it 'should succeed for recent' do\n          get \"/notifications\", params: { recent: true }\n          expect(response.status).to eq(200)\n        end\n\n        it 'should succeed for history' do\n          get \"/notifications.json\"\n\n          expect(response.status).to eq(200)\n\n          notifications = response.parsed_body[\"notifications\"]\n\n          expect(notifications.length).to eq(1)\n          expect(notifications.first[\"id\"]).to eq(notification.id)\n        end\n\n        it 'should mark notifications as viewed' do\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(0)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        end\n\n        it 'should not mark notifications as viewed if silent param is present' do\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true, silent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        end\n\n        it 'should not mark notifications as viewed in readonly mode' do\n          Discourse.received_redis_readonly!\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true, silent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        ensure\n          Discourse.clear_redis_readonly!\n        end\n\n        it \"get notifications with all filters\" do\n          notification = Fabricate(:notification, user: user)\n          notification2 = Fabricate(:notification, user: user)\n          put \"/notifications/mark-read.json\", params: { id: notification.id }\n          expect(response.status).to eq(200)\n\n          get \"/notifications.json\"\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 2\n\n          get \"/notifications.json\", params: { filter: \"read\" }\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 1\n          expect(JSON.parse(response.body)['notifications'][0]['read']).to eq(true)\n\n          get \"/notifications.json\", params: { filter: \"unread\" }\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 1\n          expect(JSON.parse(response.body)['notifications'][0]['read']).to eq(false)\n        end\n\n        context \"with the enable_experimental_sidebar_hamburger setting\" do\n          fab!(:unread_high_priority) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: true,\n              read: false,\n              created_at: 10.minutes.ago\n            )\n          end\n          fab!(:read_high_priority) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: true,\n              read: true,\n              created_at: 8.minutes.ago\n            )\n          end\n          fab!(:unread_regular) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: false,\n              read: false,\n              created_at: 6.minutes.ago\n            )\n          end\n          fab!(:read_regular) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: false,\n              read: true,\n              created_at: 4.minutes.ago\n            )\n          end\n          fab!(:pending_reviewable) { Fabricate(:reviewable) }\n\n          it \"gets notifications list with unread ones at the top when the setting is enabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }).to eq([\n              unread_high_priority.id,\n              notification.id,\n              unread_regular.id,\n              read_regular.id,\n              read_high_priority.id\n            ])\n          end\n\n          it \"gets notifications list with unread high priority notifications at the top when the setting is disabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = false\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }).to eq([\n              unread_high_priority.id,\n              notification.id,\n              read_regular.id,\n              unread_regular.id,\n              read_high_priority.id\n            ])\n          end\n\n          it \"should not bump last seen reviewable in readonly mode\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            Discourse.received_redis_readonly!\n            expect {\n              get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          ensure\n            Discourse.clear_redis_readonly!\n          end\n\n          it \"should not bump last seen reviewable if the user can't see reviewables\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            expect {\n              get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"should not bump last seen reviewable if the silent param is present\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect {\n              get \"/notifications.json\", params: {\n                recent: true,\n                silent: true,\n                bump_last_seen_reviewable: true\n              }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"should not bump last seen reviewable if the bump_last_seen_reviewable param is not present\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect {\n              get \"/notifications.json\", params: { recent: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"bumps last_seen_reviewable_id\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect(user.last_seen_reviewable_id).to eq(nil)\n            get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n            expect(user.reload.last_seen_reviewable_id).to eq(pending_reviewable.id)\n\n            reviewable2 = Fabricate(:reviewable)\n            get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n            expect(user.reload.last_seen_reviewable_id).to eq(reviewable2.id)\n          end\n\n          it \"includes pending reviewables when the setting is enabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            pending_reviewable2 = Fabricate(:reviewable, created_at: 4.minutes.ago)\n            Fabricate(:reviewable, status: Reviewable.statuses[:approved])\n            Fabricate(:reviewable, status: Reviewable.statuses[:rejected])\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"pending_reviewables\"].map { |r| r[\"id\"] }).to eq([\n              pending_reviewable.id,\n              pending_reviewable2.id\n            ])\n          end\n\n          it \"doesn't include reviewables when the setting is disabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = false\n            user.update!(admin: true)\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body.key?(\"pending_reviewables\")).to eq(false)\n          end\n\n          it \"doesn't include reviewables if the user can't see the review queue\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: false)\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body.key?(\"pending_reviewables\")).to eq(false)\n          end\n        end\n\n        context \"when filter_by_types param is present\" do\n          fab!(:liked1) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              created_at: 2.minutes.ago\n            )\n          end\n          fab!(:liked2) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              created_at: 10.minutes.ago\n            )\n          end\n          fab!(:replied) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:replied],\n              created_at: 7.minutes.ago\n            )\n          end\n          fab!(:mentioned) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned]\n            )\n          end\n\n          it \"correctly filters notifications to the type(s) given\" do\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked,replied\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id, replied.id, liked2.id])\n\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"replied\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([replied.id])\n          end\n\n          it \"doesn't include notifications from other users\" do\n            Fabricate(\n              :notification,\n              user: Fabricate(:user),\n              notification_type: Notification.types[:liked]\n            )\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id, liked2.id])\n          end\n\n          it \"limits the number of returned notifications according to the limit param\" do\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked\", limit: 1 }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id])\n          end\n        end\n\n        context 'when username params is not valid' do\n          it 'should raise the right error' do\n            get \"/notifications.json\", params: { username: 'somedude' }\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      it 'should succeed' do\n        put \"/notifications/mark-read.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can update a single notification\" do\n        notification2 = Fabricate(:notification, user: user)\n        put \"/notifications/mark-read.json\", params: { id: notification.id }\n        expect(response.status).to eq(200)\n\n        notification.reload\n        notification2.reload\n\n        expect(notification.read).to eq(true)\n        expect(notification2.read).to eq(false)\n      end\n\n      it \"updates the `read` status\" do\n        expect(user.reload.unread_notifications).to eq(1)\n        expect(user.reload.total_unread_notifications).to eq(1)\n\n        put \"/notifications/mark-read.json\"\n\n        expect(response.status).to eq(200)\n        user.reload\n        expect(user.reload.unread_notifications).to eq(0)\n        expect(user.reload.total_unread_notifications).to eq(0)\n      end\n\n      describe '#create' do\n        it \"can't create notification\" do\n          create_notification(user.id, 403, :to)\n        end\n      end\n\n      describe '#update' do\n        it \"can't update notification\" do\n          update_notification(Fabricate(:topic).id, 403, :to_not)\n        end\n      end\n\n      describe '#destroy' do\n        it \"can't delete notification\" do\n          delete_notification(403, :to)\n        end\n      end\n\n      describe '#mark_read' do\n        context \"when targeting a notification by id\" do\n          it 'can mark a notification as read' do\n            expect {\n              put \"/notifications/mark-read.json\", params: { id: notification.id }\n              expect(response.status).to eq(200)\n              notification.reload\n            }.to change { notification.read }.from(false).to(true)\n          end\n\n          it \"doesn't mark a notification of another user as read\" do\n            notification.update!(user_id: Fabricate(:user).id, read: false)\n            expect {\n              put \"/notifications/mark-read.json\", params: { id: notification.id }\n              expect(response.status).to eq(200)\n              notification.reload\n            }.not_to change { notification.read }\n          end\n        end\n\n        context \"when targeting notifications by type\" do\n          it \"can mark notifications as read\" do\n            replied1 = notification\n            replied1.update!(notification_type: Notification.types[:replied])\n            mentioned = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            liked = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              read: false\n            )\n            replied2 = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:replied],\n              read: true\n            )\n            put \"/notifications/mark-read.json\", params: {\n              dismiss_types: \"replied,mentioned\"\n            }\n            expect(response.status).to eq(200)\n            expect(replied1.reload.read).to eq(true)\n            expect(replied2.reload.read).to eq(true)\n            expect(mentioned.reload.read).to eq(true)\n\n            expect(liked.reload.read).to eq(false)\n          end\n\n          it \"doesn't mark notifications of another user as read\" do\n            mentioned1 = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            mentioned2 = Fabricate(\n              :notification,\n              user: Fabricate(:user),\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            put \"/notifications/mark-read.json\", params: {\n              dismiss_types: \"mentioned\"\n            }\n            expect(mentioned1.reload.read).to eq(true)\n            expect(mentioned2.reload.read).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'as admin' do\n      fab!(:admin) { sign_in(Fabricate(:admin)) }\n\n      describe '#create' do\n        it \"can create notification\" do\n          create_notification(admin.id, 200, :to_not)\n          expect(response.parsed_body[\"id\"]).to_not eq(nil)\n        end\n      end\n\n      describe '#update' do\n        it \"can update notification\" do\n          update_notification(8, 200, :to)\n          expect(response.parsed_body[\"topic_id\"]).to eq(8)\n        end\n      end\n\n      describe '#destroy' do\n        it \"can delete notification\" do\n          delete_notification(200, :to_not)\n        end\n      end\n    end\n  end\n\n  context 'when not logged in' do\n\n    describe '#index' do\n      it 'should raise an error' do\n        get \"/notifications.json\", params: { recent: true }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe '#create' do\n      it \"can't create notification\" do\n        user = Fabricate(:user)\n        create_notification(user.id, 403, :to)\n      end\n    end\n\n    describe '#update' do\n      it \"can't update notification\" do\n        update_notification(Fabricate(:topic).id, 403, :to_not)\n      end\n    end\n\n    describe '#destroy' do\n      it \"can't delete notification\" do\n        delete_notification(403, :to)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n\n  requires_login\n  before_action :ensure_admin, only: [:create, :update, :destroy]\n  before_action :set_notification, only: [:update, :destroy]\n\n  def index\n    user =\n      if params[:username] && !params[:recent]\n        user_record = User.find_by(username: params[:username].to_s)\n        raise Discourse::NotFound if !user_record\n        user_record\n      else\n        current_user\n      end\n\n    guardian.ensure_can_see_notifications!(user)\n\n    if notification_types = params[:filter_by_types]&.split(\",\").presence\n      notification_types.map! do |type|\n        Notification.types[type.to_sym] || (\n          raise Discourse::InvalidParameters.new(\"invalid notification type: #{type}\")\n        )\n      end\n    end\n\n    if params[:recent].present?\n      limit = (params[:limit] || 15).to_i\n      limit = 50 if limit > 50\n\n      include_reviewables = false\n      if SiteSetting.enable_experimental_sidebar_hamburger\n        notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types)\n        # notification_types is blank for the \"all notifications\" user menu tab\n        include_reviewables = notification_types.blank? && guardian.can_see_review_queue?\n      else\n        notifications = Notification.recent_report(current_user, limit, notification_types)\n      end\n\n      if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)\n        if current_user.bump_last_seen_notification!\n          current_user.reload\n          current_user.publish_notifications_state\n        end\n      end\n\n      if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables\n        current_user_id = current_user.id\n        Scheduler::Defer.later \"bump last seen reviewable for user\" do\n          # we lookup current_user again in the background thread to avoid\n          # concurrency issues where the user object returned by the\n          # current_user controller method is changed by the time the deferred\n          # block is executed\n          User.find_by(id: current_user_id)&.bump_last_seen_reviewable!\n        end\n      end\n\n      notifications = filter_inaccessible_notifications(notifications)\n\n      json = {\n        notifications: serialize_data(notifications, NotificationSerializer),\n        seen_notification_id: current_user.seen_notification_id\n      }\n      if include_reviewables\n        json[:pending_reviewables] = Reviewable.basic_serializers_for_list(\n          Reviewable.user_menu_list_for(current_user),\n          current_user\n        ).as_json\n      end\n      render_json_dump(json)\n    else\n      offset = params[:offset].to_i\n\n      notifications = Notification.where(user_id: user.id)\n        .visible\n        .includes(:topic)\n        .order(created_at: :desc)\n\n      notifications = notifications.where(read: true) if params[:filter] == \"read\"\n\n      notifications = notifications.where(read: false) if params[:filter] == \"unread\"\n\n      total_rows = notifications.dup.count\n      notifications = notifications.offset(offset).limit(60)\n      notifications = filter_inaccessible_notifications(notifications)\n      render_json_dump(notifications: serialize_data(notifications, NotificationSerializer),\n                       total_rows_notifications: total_rows,\n                       seen_notification_id: user.seen_notification_id,\n                       load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]))\n    end\n\n  end\n\n  def mark_read\n    if params[:id]\n      Notification.read(current_user, [params[:id].to_i])\n    else\n      if types = params[:dismiss_types]&.split(\",\").presence\n        invalid = []\n        types.map! do |type|\n          type_id = Notification.types[type.to_sym]\n          invalid << type if !type_id\n          type_id\n        end\n        if invalid.size > 0\n          raise Discourse::InvalidParameters.new(\"invalid notification types: #{invalid.inspect}\")\n        end\n      end\n\n      Notification.read_types(current_user, types)\n      current_user.bump_last_seen_notification!\n    end\n\n    current_user.reload\n    current_user.publish_notifications_state\n\n    render json: success_json\n  end\n\n  def create\n    @notification = Notification.consolidate_or_create!(notification_params)\n    render_notification\n  end\n\n  def update\n    @notification.update!(notification_params)\n    render_notification\n  end\n\n  def destroy\n    @notification.destroy!\n    render json: success_json\n  end\n\n  private\n\n  def set_notification\n    @notification = Notification.find(params[:id])\n  end\n\n  def notification_params\n    params.permit(:notification_type, :user_id, :data, :read, :topic_id, :post_number, :post_action_id)\n  end\n\n  def render_notification\n    render_json_dump(NotificationSerializer.new(@notification, scope: guardian, root: false))\n  end\n\n  def filter_inaccessible_notifications(notifications)\n    topic_ids = notifications.map { |n| n.topic_id }.compact.uniq\n    accessible_topic_ids = guardian.can_see_topic_ids(topic_ids: topic_ids)\n    notifications.select { |n| n.topic_id.blank? || accessible_topic_ids.include?(n.topic_id) }\n  end\nend\n", "# frozen_string_literal: true\n\ndef create_notification(user_id, resp_code, matcher)\n  notification_count = Notification.count\n  post \"/notifications.json\",\n    params: {\n      notification_type: Notification.types[:mentioned],\n      user_id: user_id,\n      data: { message: 'tada' }.to_json\n    }\n  expect(response.status).to eq(resp_code)\n  expect(Notification.count).public_send(matcher, eq(notification_count))\nend\n\ndef update_notification(topic_id, resp_code, matcher)\n  notification = Fabricate(:notification)\n  put \"/notifications/#{notification.id}.json\", params: { topic_id: topic_id }\n  expect(response.status).to eq(resp_code)\n  notification.reload\n  expect(notification.topic_id).public_send(matcher, eq(topic_id))\nend\n\ndef delete_notification(resp_code, matcher)\n  notification = Fabricate(:notification)\n  notification_count = Notification.count\n  delete \"/notifications/#{notification.id}.json\"\n  expect(response.status).to eq(resp_code)\n  expect(Notification.count).public_send(matcher, eq(notification_count))\nend\n\nRSpec.describe NotificationsController do\n  context 'when logged in' do\n    context 'as normal user' do\n      fab!(:user) { sign_in(Fabricate(:user)) }\n      fab!(:notification) { Fabricate(:notification, user: user) }\n\n      describe '#index' do\n        it 'should succeed for recent' do\n          get \"/notifications\", params: { recent: true }\n          expect(response.status).to eq(200)\n        end\n\n        it 'should succeed for history' do\n          get \"/notifications.json\"\n\n          expect(response.status).to eq(200)\n\n          notifications = response.parsed_body[\"notifications\"]\n\n          expect(notifications.length).to eq(1)\n          expect(notifications.first[\"id\"]).to eq(notification.id)\n        end\n\n        it 'should mark notifications as viewed' do\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(0)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        end\n\n        it 'should not mark notifications as viewed if silent param is present' do\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true, silent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        end\n\n        it 'should not mark notifications as viewed in readonly mode' do\n          Discourse.received_redis_readonly!\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n\n          get \"/notifications.json\", params: { recent: true, silent: true }\n\n          expect(response.status).to eq(200)\n          expect(user.reload.unread_notifications).to eq(1)\n          expect(user.reload.total_unread_notifications).to eq(1)\n        ensure\n          Discourse.clear_redis_readonly!\n        end\n\n        it \"get notifications with all filters\" do\n          notification = Fabricate(:notification, user: user)\n          notification2 = Fabricate(:notification, user: user)\n          put \"/notifications/mark-read.json\", params: { id: notification.id }\n          expect(response.status).to eq(200)\n\n          get \"/notifications.json\"\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 2\n\n          get \"/notifications.json\", params: { filter: \"read\" }\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 1\n          expect(JSON.parse(response.body)['notifications'][0]['read']).to eq(true)\n\n          get \"/notifications.json\", params: { filter: \"unread\" }\n\n          expect(response.status).to eq(200)\n          expect(JSON.parse(response.body)['notifications'].length).to be >= 1\n          expect(JSON.parse(response.body)['notifications'][0]['read']).to eq(false)\n        end\n\n        context \"with the enable_experimental_sidebar_hamburger setting\" do\n          fab!(:unread_high_priority) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: true,\n              read: false,\n              created_at: 10.minutes.ago\n            )\n          end\n          fab!(:read_high_priority) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: true,\n              read: true,\n              created_at: 8.minutes.ago\n            )\n          end\n          fab!(:unread_regular) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: false,\n              read: false,\n              created_at: 6.minutes.ago\n            )\n          end\n          fab!(:read_regular) do\n            Fabricate(\n              :notification,\n              user: user,\n              high_priority: false,\n              read: true,\n              created_at: 4.minutes.ago\n            )\n          end\n          fab!(:pending_reviewable) { Fabricate(:reviewable) }\n\n          it \"gets notifications list with unread ones at the top when the setting is enabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }).to eq([\n              unread_high_priority.id,\n              notification.id,\n              unread_regular.id,\n              read_regular.id,\n              read_high_priority.id\n            ])\n          end\n\n          it \"gets notifications list with unread high priority notifications at the top when the setting is disabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = false\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }).to eq([\n              unread_high_priority.id,\n              notification.id,\n              read_regular.id,\n              unread_regular.id,\n              read_high_priority.id\n            ])\n          end\n\n          it \"should not bump last seen reviewable in readonly mode\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            Discourse.received_redis_readonly!\n            expect {\n              get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          ensure\n            Discourse.clear_redis_readonly!\n          end\n\n          it \"should not bump last seen reviewable if the user can't see reviewables\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            expect {\n              get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"should not bump last seen reviewable if the silent param is present\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect {\n              get \"/notifications.json\", params: {\n                recent: true,\n                silent: true,\n                bump_last_seen_reviewable: true\n              }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"should not bump last seen reviewable if the bump_last_seen_reviewable param is not present\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect {\n              get \"/notifications.json\", params: { recent: true }\n              expect(response.status).to eq(200)\n            }.not_to change { user.reload.last_seen_reviewable_id }\n          end\n\n          it \"bumps last_seen_reviewable_id\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            expect(user.last_seen_reviewable_id).to eq(nil)\n            get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n            expect(user.reload.last_seen_reviewable_id).to eq(pending_reviewable.id)\n\n            reviewable2 = Fabricate(:reviewable)\n            get \"/notifications.json\", params: { recent: true, bump_last_seen_reviewable: true }\n            expect(user.reload.last_seen_reviewable_id).to eq(reviewable2.id)\n          end\n\n          it \"includes pending reviewables when the setting is enabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: true)\n            pending_reviewable2 = Fabricate(:reviewable, created_at: 4.minutes.ago)\n            Fabricate(:reviewable, status: Reviewable.statuses[:approved])\n            Fabricate(:reviewable, status: Reviewable.statuses[:rejected])\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"pending_reviewables\"].map { |r| r[\"id\"] }).to eq([\n              pending_reviewable.id,\n              pending_reviewable2.id\n            ])\n          end\n\n          it \"doesn't include reviewables when the setting is disabled\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = false\n            user.update!(admin: true)\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body.key?(\"pending_reviewables\")).to eq(false)\n          end\n\n          it \"doesn't include reviewables if the user can't see the review queue\" do\n            SiteSetting.enable_experimental_sidebar_hamburger = true\n            user.update!(admin: false)\n\n            get \"/notifications.json\", params: { recent: true }\n            expect(response.status).to eq(200)\n            expect(response.parsed_body.key?(\"pending_reviewables\")).to eq(false)\n          end\n        end\n\n        context \"when filter_by_types param is present\" do\n          fab!(:liked1) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              created_at: 2.minutes.ago\n            )\n          end\n          fab!(:liked2) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              created_at: 10.minutes.ago\n            )\n          end\n          fab!(:replied) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:replied],\n              created_at: 7.minutes.ago\n            )\n          end\n          fab!(:mentioned) do\n            Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned]\n            )\n          end\n\n          it \"correctly filters notifications to the type(s) given\" do\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked,replied\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id, replied.id, liked2.id])\n\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"replied\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([replied.id])\n          end\n\n          it \"doesn't include notifications from other users\" do\n            Fabricate(\n              :notification,\n              user: Fabricate(:user),\n              notification_type: Notification.types[:liked]\n            )\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked\" }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id, liked2.id])\n          end\n\n          it \"limits the number of returned notifications according to the limit param\" do\n            get \"/notifications.json\", params: { recent: true, filter_by_types: \"liked\", limit: 1 }\n            expect(response.status).to eq(200)\n            expect(\n              response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            ).to eq([liked1.id])\n          end\n        end\n\n        context 'when username params is not valid' do\n          it 'should raise the right error' do\n            get \"/notifications.json\", params: { username: 'somedude' }\n            expect(response.status).to eq(404)\n          end\n        end\n\n        context \"with notifications for inaccessible topics\" do\n          fab!(:sender) { Fabricate.build(:topic_allowed_user, user: Fabricate(:coding_horror)) }\n          fab!(:allowed_user) { Fabricate.build(:topic_allowed_user, user: user) }\n          fab!(:another_allowed_user) { Fabricate.build(:topic_allowed_user, user: Fabricate(:user)) }\n          fab!(:allowed_pm) { Fabricate(:private_message_topic, topic_allowed_users: [sender, allowed_user, another_allowed_user]) }\n          fab!(:forbidden_pm) { Fabricate(:private_message_topic, topic_allowed_users: [sender, another_allowed_user]) }\n          fab!(:allowed_pm_notification) { Fabricate(:private_message_notification, user: user, topic: allowed_pm) }\n          fab!(:forbidden_pm_notification) { Fabricate(:private_message_notification, user: user, topic: forbidden_pm) }\n\n          def expect_correct_notifications(response)\n            notification_ids = response.parsed_body[\"notifications\"].map { |n| n[\"id\"] }\n            expect(notification_ids).to include(allowed_pm_notification.id)\n            expect(notification_ids).to_not include(forbidden_pm_notification.id)\n          end\n\n          context \"with 'recent' filter\" do\n            it \"doesn't include notifications from topics the user isn't allowed to see\" do\n              SiteSetting.enable_experimental_sidebar_hamburger = true\n              get \"/notifications.json\", params: { recent: true }\n              expect(response.status).to eq(200)\n              expect_correct_notifications(response)\n\n              SiteSetting.enable_experimental_sidebar_hamburger = false\n              get \"/notifications.json\", params: { recent: true }\n              expect(response.status).to eq(200)\n              expect_correct_notifications(response)\n            end\n          end\n\n          context \"without 'recent' filter\" do\n            it \"doesn't include notifications from topics the user isn't allowed to see\" do\n              SiteSetting.enable_experimental_sidebar_hamburger = true\n              get \"/notifications.json\"\n              expect(response.status).to eq(200)\n              expect_correct_notifications(response)\n\n              SiteSetting.enable_experimental_sidebar_hamburger = false\n              get \"/notifications.json\"\n              expect(response.status).to eq(200)\n              expect_correct_notifications(response)\n            end\n          end\n        end\n      end\n\n      it 'should succeed' do\n        put \"/notifications/mark-read.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"can update a single notification\" do\n        notification2 = Fabricate(:notification, user: user)\n        put \"/notifications/mark-read.json\", params: { id: notification.id }\n        expect(response.status).to eq(200)\n\n        notification.reload\n        notification2.reload\n\n        expect(notification.read).to eq(true)\n        expect(notification2.read).to eq(false)\n      end\n\n      it \"updates the `read` status\" do\n        expect(user.reload.unread_notifications).to eq(1)\n        expect(user.reload.total_unread_notifications).to eq(1)\n\n        put \"/notifications/mark-read.json\"\n\n        expect(response.status).to eq(200)\n        user.reload\n        expect(user.reload.unread_notifications).to eq(0)\n        expect(user.reload.total_unread_notifications).to eq(0)\n      end\n\n      describe '#create' do\n        it \"can't create notification\" do\n          create_notification(user.id, 403, :to)\n        end\n      end\n\n      describe '#update' do\n        it \"can't update notification\" do\n          update_notification(Fabricate(:topic).id, 403, :to_not)\n        end\n      end\n\n      describe '#destroy' do\n        it \"can't delete notification\" do\n          delete_notification(403, :to)\n        end\n      end\n\n      describe '#mark_read' do\n        context \"when targeting a notification by id\" do\n          it 'can mark a notification as read' do\n            expect {\n              put \"/notifications/mark-read.json\", params: { id: notification.id }\n              expect(response.status).to eq(200)\n              notification.reload\n            }.to change { notification.read }.from(false).to(true)\n          end\n\n          it \"doesn't mark a notification of another user as read\" do\n            notification.update!(user_id: Fabricate(:user).id, read: false)\n            expect {\n              put \"/notifications/mark-read.json\", params: { id: notification.id }\n              expect(response.status).to eq(200)\n              notification.reload\n            }.not_to change { notification.read }\n          end\n        end\n\n        context \"when targeting notifications by type\" do\n          it \"can mark notifications as read\" do\n            replied1 = notification\n            replied1.update!(notification_type: Notification.types[:replied])\n            mentioned = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            liked = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:liked],\n              read: false\n            )\n            replied2 = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:replied],\n              read: true\n            )\n            put \"/notifications/mark-read.json\", params: {\n              dismiss_types: \"replied,mentioned\"\n            }\n            expect(response.status).to eq(200)\n            expect(replied1.reload.read).to eq(true)\n            expect(replied2.reload.read).to eq(true)\n            expect(mentioned.reload.read).to eq(true)\n\n            expect(liked.reload.read).to eq(false)\n          end\n\n          it \"doesn't mark notifications of another user as read\" do\n            mentioned1 = Fabricate(\n              :notification,\n              user: user,\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            mentioned2 = Fabricate(\n              :notification,\n              user: Fabricate(:user),\n              notification_type: Notification.types[:mentioned],\n              read: false\n            )\n            put \"/notifications/mark-read.json\", params: {\n              dismiss_types: \"mentioned\"\n            }\n            expect(mentioned1.reload.read).to eq(true)\n            expect(mentioned2.reload.read).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'as admin' do\n      fab!(:admin) { sign_in(Fabricate(:admin)) }\n\n      describe '#create' do\n        it \"can create notification\" do\n          create_notification(admin.id, 200, :to_not)\n          expect(response.parsed_body[\"id\"]).to_not eq(nil)\n        end\n      end\n\n      describe '#update' do\n        it \"can update notification\" do\n          update_notification(8, 200, :to)\n          expect(response.parsed_body[\"topic_id\"]).to eq(8)\n        end\n      end\n\n      describe '#destroy' do\n        it \"can delete notification\" do\n          delete_notification(200, :to_not)\n        end\n      end\n    end\n  end\n\n  context 'when not logged in' do\n\n    describe '#index' do\n      it 'should raise an error' do\n        get \"/notifications.json\", params: { recent: true }\n        expect(response.status).to eq(403)\n      end\n    end\n\n    describe '#create' do\n      it \"can't create notification\" do\n        user = Fabricate(:user)\n        create_notification(user.id, 403, :to)\n      end\n    end\n\n    describe '#update' do\n      it \"can't update notification\" do\n        update_notification(Fabricate(:topic).id, 403, :to_not)\n      end\n    end\n\n    describe '#destroy' do\n      it \"can't delete notification\" do\n        delete_notification(403, :to)\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/notifications_controller.rb", "spec/requests/notifications_controller_spec.rb"], "buggy_code_start_loc": [43, 341], "buggy_code_end_loc": [147, 341], "fixing_code_start_loc": [43, 342], "fixing_code_end_loc": [156, 386], "type": "CWE-200", "message": "Discourse is an open-source discussion platform. In stable versions prior to 2.8.12 and beta or tests-passed versions prior to 2.9.0.beta.13, under certain conditions, a user can see notifications for topics they no longer have access to. If there is sensitive information in the topic title, it will therefore have been exposed. This issue is patched in stable version 2.8.12, beta version 2.9.0.beta13, and tests-passed version 2.9.0.beta13. There are no workarounds available.", "other": {"cve": {"id": "CVE-2022-41944", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-28T15:15:10.620", "lastModified": "2022-12-01T20:28:26.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. In stable versions prior to 2.8.12 and beta or tests-passed versions prior to 2.9.0.beta.13, under certain conditions, a user can see notifications for topics they no longer have access to. If there is sensitive information in the topic title, it will therefore have been exposed. This issue is patched in stable version 2.8.12, beta version 2.9.0.beta13, and tests-passed version 2.9.0.beta13. There are no workarounds available."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.11", "matchCriteriaId": "6478F103-55A5-4D3E-B655-F394150E4CC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "35BAC488-3622-4B0B-B8EA-879E8C68E8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "406A23B4-B971-4DC8-A132-EE9854FE8546"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "1DD3C47F-E49F-4E19-9EA7-A322C4CFD541"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "0086484D-0164-449C-8AAE-BE7479CB9706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "F9D1B031-96C7-44C0-A0A0-F67ABE55C93C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "750D2AD9-35E7-4AC7-9C22-AA90DAA34F3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "B68E308A-BDAB-4614-A563-4460F7996CBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "5DEDE4C5-2C2A-4B74-BB41-8AAA0EE636E2"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/c6ee28ec756436cc9ce154dd2c8e4c441f92f693", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-354r-jpj5-53c2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/c6ee28ec756436cc9ce154dd2c8e4c441f92f693"}}