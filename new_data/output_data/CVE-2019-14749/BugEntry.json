{"buggy_code": ["<?php\n/*************************************************************************\n    class.export.php\n\n    Exports stuff (details to follow)\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass Export {\n\n    // XXX: This may need to be moved to a print-specific class\n    static $paper_sizes = array(\n        /* @trans */ 'Letter',\n        /* @trans */ 'Legal',\n        'A4',\n        'A3',\n    );\n\n    static function dumpQuery($sql, $headers, $how='csv', $options=array()) {\n        $exporters = array(\n            'csv' => CsvResultsExporter,\n            'json' => JsonResultsExporter\n        );\n        $exp = new $exporters[$how]($sql, $headers, $options);\n        return $exp->dump();\n    }\n\n    # XXX: Think about facilitated exporting. For instance, we might have a\n    #      TicketExporter, which will know how to formulate or lookup a\n    #      format query (SQL), and cooperate with the output process to add\n    #      extra (recursive) information. In this funciton, the top-level\n    #      SQL is exported, but for something like tickets, we will need to\n    #      export attached messages, reponses, and notes, as well as\n    #      attachments associated with each, ...\n    static function dumpTickets($sql, $how='csv') {\n        // Add custom fields to the $sql statement\n        $cdata = $fields = array();\n        foreach (TicketForm::getInstance()->getFields() as $f) {\n            // Ignore core fields\n            if (in_array($f->get('name'), array('priority')))\n                continue;\n            // Ignore non-data fields\n            elseif (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata.'.$name;\n            $fields[$key] = $f;\n            $cdata[$key] = $f->getLocal('label');\n        }\n        // Reset the $sql query\n        $tickets = $sql->models()\n            ->select_related('user', 'user__default_email', 'dept', 'staff',\n                'team', 'staff', 'cdata', 'topic', 'status', 'cdata__:priority')\n            ->options(QuerySet::OPT_NOCACHE)\n            ->annotate(array(\n                'collab_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('collaborators__id'))),\n                'attachment_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->filter(array('entries__attachments__inline' => 0))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('entries__attachments__id'))),\n                'thread_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->exclude(array('entries__flags__hasbit' => ThreadEntry::FLAG_HIDDEN))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('entries__id'))),\n            ));\n\n        // Fetch staff information\n        // FIXME: Adjust Staff model so it doesn't do extra queries\n        foreach (Staff::objects() as $S)\n            $S->get('junk');\n\n        return self::dumpQuery($tickets,\n            array(\n                'number' =>         __('Ticket Number'),\n                'created' =>        __('Date Created'),\n                'cdata.subject' =>  __('Subject'),\n                'user.name' =>      __('From'),\n                'user.default_email.address' => __('From Email'),\n                'cdata.:priority.priority_desc' => __('Priority'),\n                'dept::getLocalName' => __('Department'),\n                'topic::getName' => __('Help Topic'),\n                'source' =>         __('Source'),\n                'status::getName' =>__('Current Status'),\n                'lastupdate' =>     __('Last Updated'),\n                'est_duedate' =>    __('Due Date'),\n                'isoverdue' =>      __('Overdue'),\n                'isanswered' =>     __('Answered'),\n                'staff::getName' => __('Agent Assigned'),\n                'team::getName' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'attachment_count' => __('Attachment Count'),\n            ) + $cdata,\n            $how,\n            array('modify' => function(&$record, $keys) use ($fields) {\n                foreach ($fields as $k=>$f) {\n                    if (($i = array_search($k, $keys)) !== false) {\n                        $record[$i] = $f->export($f->to_php($record[$i]));\n                    }\n                }\n                return $record;\n            })\n            );\n    }\n\n    static  function saveTickets($sql, $filename, $how='csv') {\n        Http::download($filename, \"text/$how\");\n        self::dumpTickets($sql, $how);\n        exit;\n    }\n\n\n    static function dumpTasks($sql, $how='csv') {\n        // Add custom fields to the $sql statement\n        $cdata = $fields = array();\n        foreach (TaskForm::getInstance()->getFields() as $f) {\n            // Ignore non-data fields\n            if (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata.'.$name;\n            $fields[$key] = $f;\n            $cdata[$key] = $f->getLocal('label');\n        }\n        // Reset the $sql query\n        $tasks = $sql->models()\n            ->select_related('dept', 'staff', 'team', 'cdata')\n            ->annotate(array(\n            'collab_count' => SqlAggregate::COUNT('thread__collaborators'),\n            'attachment_count' => SqlAggregate::COUNT('thread__entries__attachments'),\n            'thread_count' => SqlAggregate::COUNT('thread__entries'),\n        ));\n\n        return self::dumpQuery($tasks,\n            array(\n                'number' =>         __('Task Number'),\n                'created' =>        __('Date Created'),\n                'cdata.title' =>    __('Title'),\n                'dept::getLocalName' => __('Department'),\n                '::getStatus' =>    __('Current Status'),\n                'duedate' =>        __('Due Date'),\n                'staff::getName' => __('Agent Assigned'),\n                'team::getName' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'attachment_count' => __('Attachment Count'),\n            ) + $cdata,\n            $how,\n            array('modify' => function(&$record, $keys) use ($fields) {\n                foreach ($fields as $k=>$f) {\n                    if (($i = array_search($k, $keys)) !== false) {\n                        $record[$i] = $f->export($f->to_php($record[$i]));\n                    }\n                }\n                return $record;\n            })\n            );\n    }\n\n\n    static function saveTasks($sql, $filename, $how='csv') {\n\n        ob_start();\n        self::dumpTasks($sql, $how);\n        $stuff = ob_get_contents();\n        ob_end_clean();\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n    static function saveUsers($sql, $filename, $how='csv') {\n\n        $exclude = array('name', 'email');\n        $form = UserForm::getUserForm();\n        $fields = $form->getExportableFields($exclude, 'cdata.');\n\n        $cdata = array_combine(array_keys($fields),\n                array_values(array_map(\n                        function ($f) { return $f->getLocal('label'); }, $fields)));\n\n        $users = $sql->models()\n            ->select_related('org', 'cdata');\n\n        ob_start();\n        echo self::dumpQuery($users,\n                array(\n                    'name'  =>          __('Name'),\n                    'org' =>   __('Organization'),\n                    '::getEmail' =>          __('Email'),\n                    ) + $cdata,\n                $how,\n                array('modify' => function(&$record, $keys) use ($fields) {\n                    foreach ($fields as $k=>$f) {\n                        if ($f && ($i = array_search($k, $keys)) !== false) {\n                            $record[$i] = $f->export($f->to_php($record[$i]));\n                        }\n                    }\n                    return $record;\n                    })\n                );\n        $stuff = ob_get_contents();\n        ob_end_clean();\n\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n    static function saveOrganizations($sql, $filename, $how='csv') {\n\n        $exclude = array('name');\n        $form = OrganizationForm::getDefaultForm();\n        $fields = $form->getExportableFields($exclude, 'cdata.');\n        $cdata = array_combine(array_keys($fields),\n                array_values(array_map(\n                        function ($f) { return $f->getLocal('label'); }, $fields)));\n\n        $cdata += array(\n                '::getNumUsers' => 'Users',\n                '::getAccountManager' => 'Account Manager',\n                );\n\n        $orgs = $sql->models();\n        ob_start();\n        echo self::dumpQuery($orgs,\n                array(\n                    'name'  =>  'Name',\n                    ) + $cdata,\n                $how,\n                array('modify' => function(&$record, $keys) use ($fields) {\n                    foreach ($fields as $k=>$f) {\n                        if ($f && ($i = array_search($k, $keys)) !== false) {\n                            $record[$i] = $f->export($f->to_php($record[$i]));\n                        }\n                    }\n                    return $record;\n                    })\n                );\n        $stuff = ob_get_contents();\n        ob_end_clean();\n\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n}\n\nclass ResultSetExporter {\n    var $output;\n\n    function __construct($sql, $headers, $options=array()) {\n        $this->headers = array_values($headers);\n        // Remove limit and offset\n        $sql->limit(null)->offset(null);\n        # TODO: If $filter, add different LIMIT clause to query\n        $this->options = $options;\n        $this->output = $options['output'] ?: fopen('php://output', 'w');\n\n        $this->headers = array();\n        $this->keys = array();\n        foreach ($headers as $field=>$name) {\n            $this->headers[] = $name;\n            $this->keys[] = $field;\n        }\n        $this->_res = $sql->getIterator();\n        if ($this->_res instanceof IteratorAggregate)\n            $this->_res = $this->_res->getIterator();\n        $this->_res->rewind();\n    }\n\n    function getHeaders() {\n        return $this->headers;\n    }\n\n    function next() {\n        if (!$this->_res->valid())\n            return false;\n\n        $object = $this->_res->current();\n        $this->_res->next();\n\n        $record = array();\n\n        foreach ($this->keys as $field) {\n            list($field, $func) = explode('::', $field);\n            $path = explode('.', $field);\n            $current = $object;\n            // Evaluate dotted ORM path\n            if ($field) {\n                foreach ($path as $P) {\n                    $current = $current->{$P};\n                }\n            }\n            // Evalutate :: function call on target current\n            if ($func && (method_exists($current, $func) || method_exists($current, '__call'))) {\n                $current = $current->{$func}();\n            }\n            $record[] = (string) $current;\n        }\n\n        if (isset($this->options['modify']) && is_callable($this->options['modify']))\n            $record = $this->options['modify']($record, $this->keys);\n\n        return $record;\n    }\n\n    function nextArray() {\n        if (!($row = $this->next()))\n            return false;\n        return array_combine($this->keys, $row);\n    }\n\n    function dump() {\n        # Useful for debug output\n        while ($row=$this->nextArray()) {\n            var_dump($row); //nolint\n        }\n    }\n}\n\nclass CsvResultsExporter extends ResultSetExporter {\n\n    function dump() {\n\n        if (!$this->output)\n             $this->output = fopen('php://output', 'w');\n\n        // Detect delimeter from the current locale settings. For locales\n        // which use comma (,) as the decimal separator, the semicolon (;)\n        // should be used as the field separator\n        $delimiter = ',';\n        if (class_exists('NumberFormatter')) {\n            $nf = NumberFormatter::create(Internationalization::getCurrentLocale(),\n                NumberFormatter::DECIMAL);\n            $s = $nf->getSymbol(NumberFormatter::DECIMAL_SEPARATOR_SYMBOL);\n            if ($s == ',')\n                $delimiter = ';';\n        }\n\n        // Output a UTF-8 BOM (byte order mark)\n        fputs($this->output, chr(0xEF) . chr(0xBB) . chr(0xBF));\n        fputcsv($this->output, $this->getHeaders(), $delimiter);\n        while ($row=$this->next())\n            fputcsv($this->output, $row, $delimiter);\n\n        fclose($this->output);\n    }\n}\n\nclass JsonResultsExporter extends ResultSetExporter {\n    function dump() {\n        require_once(INCLUDE_DIR.'class.json.php');\n        $exp = new JsonDataEncoder();\n        $rows = array();\n        while ($row=$this->nextArray()) {\n            $rows[] = $row;\n        }\n        echo $exp->encode($rows);\n    }\n}\n\nrequire_once INCLUDE_DIR . 'class.json.php';\nrequire_once INCLUDE_DIR . 'class.migrater.php';\nrequire_once INCLUDE_DIR . 'class.signal.php';\n\ndefine('OSTICKET_BACKUP_SIGNATURE', 'osTicket-Backup');\ndefine('OSTICKET_BACKUP_VERSION', 'B');\n\nclass DatabaseExporter {\n\n    var $stream;\n    var $options;\n    var $tables = array(CONFIG_TABLE, SYSLOG_TABLE, FILE_TABLE,\n        FILE_CHUNK_TABLE, STAFF_TABLE, DEPT_TABLE, TOPIC_TABLE, GROUP_TABLE,\n        STAFF_DEPT_TABLE, TEAM_TABLE, TEAM_MEMBER_TABLE, FAQ_TABLE,\n        FAQ_TOPIC_TABLE, FAQ_CATEGORY_TABLE, DRAFT_TABLE,\n        CANNED_TABLE, TICKET_TABLE, ATTACHMENT_TABLE,\n        THREAD_TABLE, THREAD_ENTRY_TABLE, THREAD_ENTRY_EMAIL_TABLE,\n        LOCK_TABLE, THREAD_EVENT_TABLE, TICKET_PRIORITY_TABLE,\n        EMAIL_TABLE, EMAIL_TEMPLATE_TABLE, EMAIL_TEMPLATE_GRP_TABLE,\n        FILTER_TABLE, FILTER_RULE_TABLE, SLA_TABLE, API_KEY_TABLE,\n        TIMEZONE_TABLE, SESSION_TABLE, PAGE_TABLE,\n        FORM_SEC_TABLE, FORM_FIELD_TABLE, LIST_TABLE, LIST_ITEM_TABLE,\n        FORM_ENTRY_TABLE, FORM_ANSWER_TABLE, USER_TABLE, USER_EMAIL_TABLE,\n        PLUGIN_TABLE, THREAD_COLLABORATOR_TABLE, TRANSLATION_TABLE,\n        USER_ACCOUNT_TABLE, ORGANIZATION_TABLE, NOTE_TABLE\n    );\n\n    function __construct($stream, $options=array()) {\n        $this->stream = $stream;\n        $this->options = $options;\n    }\n\n    function write_block($what) {\n        fwrite($this->stream, JsonDataEncoder::encode($what));\n        fwrite($this->stream, \"\\n\");\n    }\n\n    function dump_header() {\n        $header = array(\n            array(OSTICKET_BACKUP_SIGNATURE, OSTICKET_BACKUP_VERSION),\n            array(\n                'version'=>THIS_VERSION,\n                'table_prefix'=>TABLE_PREFIX,\n                'salt'=>SECRET_SALT,\n                'dbtype'=>DBTYPE,\n                'streams'=>DatabaseMigrater::getUpgradeStreams(\n                    UPGRADE_DIR . 'streams/'),\n            ),\n        );\n        $this->write_block($header);\n    }\n\n    function dump($error_stream) {\n        // Allow plugins to change the tables exported\n        Signal::send('export.tables', $this, $this->tables);\n        $this->dump_header();\n\n        foreach ($this->tables as $t) {\n            if ($error_stream) $error_stream->write(\"$t\\n\");\n\n            // Inspect schema\n            $table = array();\n            $res = db_query(\"select column_name from information_schema.columns\n                where table_schema=DATABASE() and table_name='$t'\");\n            while (list($field) = db_fetch_row($res))\n                $table[] = $field;\n\n            if (!$table) {\n                if ($error_stream) $error_stream->write(\n                    sprintf(__(\"%s: Cannot export table with no fields\\n\"), $t));\n                die();\n            }\n            $this->write_block(\n                array('table', substr($t, strlen(TABLE_PREFIX)), $table));\n\n            db_query(\"select * from $t\");\n\n            // Dump row data\n            while ($row = db_fetch_row($res))\n                $this->write_block($row);\n\n            $this->write_block(array('end-table'));\n        }\n    }\n\n    function transfer($destination, $query, $callback=false, $options=array()) {\n        $header_out = false;\n        $res = db_query($query, true, false);\n        $i = 0;\n        while ($row = db_fetch_array($res)) {\n            if (is_callable($callback))\n                $callback($row);\n            if (!$header_out) {\n                $fields = array_keys($row);\n                $this->write_block(\n                    array('table', $destination, $fields, $options));\n                $header_out = true;\n\n            }\n            $this->write_block(array_values($row));\n        }\n        $this->write_block(array('end-table'));\n    }\n\n    function transfer_array($destination, $array, $keys, $options=array()) {\n        $this->write_block(\n            array('table', $destination, $keys, $options));\n        foreach ($array as $row) {\n            $this->write_block(array_values($row));\n        }\n        $this->write_block(array('end-table'));\n    }\n}\n", "<?php\n/*********************************************************************\n    class.forms.php\n\n    osTicket forms framework\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\n/**\n * Form template, used for designing the custom form and for entering custom\n * data for a ticket\n */\nclass Form {\n    static $renderer = 'GridFluidLayout';\n    static $id = 0;\n\n    var $options = array();\n    var $fields = array();\n    var $title = '';\n    var $instructions = '';\n\n    var $validators = array();\n\n    var $_errors = null;\n    var $_source = false;\n\n    function __construct($source=null, $options=array()) {\n\n        $this->options = $options;\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        if (isset($options['id']))\n            $this->id = $options['id'];\n\n        // Use POST data if source was not specified\n        $this->_source = ($source) ? $source : $_POST;\n    }\n\n    function getId() {\n        return static::$id;\n    }\n\n    function data($source) {\n        foreach ($this->fields as $name=>$f)\n            if (isset($source[$name]))\n                $f->value = $source[$name];\n    }\n\n    function setFields($fields) {\n\n        if (!is_array($fields) && !$fields instanceof Traversable)\n            return;\n\n        $this->fields = $fields;\n        foreach ($fields as $k=>$f) {\n            $f->setForm($this);\n            if (!$f->get('name') && $k && !is_numeric($k))\n                $f->set('name', $k);\n        }\n    }\n\n    function getFields() {\n        return $this->fields;\n    }\n\n    function getField($name) {\n        $fields = $this->getFields();\n        foreach($fields as $f)\n            if(!strcasecmp($f->get('name'), $name))\n                return $f;\n        if (isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function hasField($name) {\n        return $this->getField($name);\n    }\n\n    function getTitle() { return $this->title; }\n    function getInstructions() { return $this->instructions; }\n    function getSource() { return $this->_source; }\n    function setSource($source) { $this->_source = $source; }\n\n    /**\n     * Validate the form and indicate if there no errors.\n     *\n     * Parameters:\n     * $filter - (callback) function to receive each field and return\n     *      boolean true if the field's errors are significant\n     */\n    function isValid($include=false) {\n        if (!isset($this->_errors)) {\n            $this->_errors = array();\n            $this->validate($this->getClean());\n            foreach ($this->getFields() as $field)\n                if ($field->errors() && (!$include || $include($field)))\n                    $this->_errors[$field->get('id')] = $field->errors();\n        }\n        return !$this->_errors;\n    }\n\n    function validate($clean_data) {\n        // Validate the whole form so that errors can be added to the\n        // individual fields and collected below.\n        foreach ($this->validators as $V) {\n            $V($this);\n        }\n    }\n\n    function getClean() {\n        if (!$this->_clean) {\n            $this->_clean = array();\n            foreach ($this->getFields() as $key=>$field) {\n                if (!$field->hasData())\n                    continue;\n\n                // Prefer indexing by field.id if indexing numerically\n                if (is_int($key) && $field->get('id'))\n                    $key = $field->get('id');\n                $this->_clean[$key] = $this->_clean[$field->get('name')]\n                    = $field->getClean();\n            }\n            unset($this->_clean[\"\"]);\n        }\n        return $this->_clean;\n    }\n\n    function errors($formOnly=false) {\n        return ($formOnly) ? $this->_errors['form'] : $this->_errors;\n    }\n\n    function addError($message, $index=false) {\n\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors['form'][] = $message;\n    }\n\n    function addErrors($errors=array()) {\n        foreach ($errors as $k => $v) {\n            if (($f=$this->getField($k)))\n                $f->addError($v);\n            else\n                $this->addError($v, $k);\n        }\n    }\n\n    function addValidator($function) {\n        if (!is_callable($function))\n            throw new Exception('Form validator must be callable');\n        $this->validators[] = $function;\n    }\n\n    function render($options=array()) {\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        $form = $this;\n        $template = $options['template'] ?: 'dynamic-form.tmpl.php';\n        if (isset($options['staff']) && $options['staff'])\n            include(STAFFINC_DIR . 'templates/' . $template);\n        else\n            include(CLIENTINC_DIR . 'templates/' . $template);\n        echo $this->getMedia();\n    }\n\n    function getLayout($title=false, $options=array()) {\n        $rc = @$options['renderer'] ?: static::$renderer;\n        return new $rc($title, $options);\n    }\n\n    function asTable($title=false, $options=array()) {\n        return $this->getLayout($title, $options)->asTable($this);\n        // XXX: Media can't go in a table\n        echo $this->getMedia();\n    }\n\n    function getMedia() {\n        static $dedup = array();\n\n        foreach ($this->getFields() as $f) {\n            if (($M = $f->getMedia()) && is_array($M)) {\n                foreach ($M as $type=>$files) {\n                    foreach ($files as $url) {\n                        $key = strtolower($type.$url);\n                        if (isset($dedup[$key]))\n                            continue;\n\n                        self::emitMedia($url, $type);\n\n                        $dedup[$key] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    function emitJavascript($options=array()) {\n\n        // Check if we need to emit javascript\n        if (!($fid=$this->getId()))\n            return;\n        ?>\n        <script type=\"text/javascript\">\n          $(function() {\n            <?php\n            //XXX: We ONLY want to watch field on this form. We'll only\n            // watch form inputs if form_id is specified. Current FORM API\n            // doesn't generate the entire form  (just fields)\n            if ($fid) {\n                ?>\n                $(document).off('change.<?php echo $fid; ?>');\n                $(document).on('change.<?php echo $fid; ?>',\n                    'form#<?php echo $fid; ?> :input',\n                    function() {\n                        //Clear any current errors...\n                        var errors = $('#field'+$(this).attr('id')+'_error');\n                        if (errors.length)\n                            errors.slideUp('fast', function (){\n                                $(this).remove();\n                                });\n                        //TODO: Validation input inplace or via ajax call\n                        // and set any new errors AND visibilty changes\n                    }\n                   );\n            <?php\n            }\n            ?>\n            });\n        </script>\n        <?php\n    }\n\n    static function emitMedia($url, $type) {\n        if ($url[0] == '/')\n            $url = ROOT_PATH . substr($url, 1);\n\n        switch (strtolower($type)) {\n        case 'css': ?>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"<?php echo $url; ?>\"/><?php\n            break;\n        case 'js': ?>\n        <script type=\"text/javascript\" src=\"<?php echo $url; ?>\"></script><?php\n            break;\n        }\n    }\n\n    /**\n     * getState\n     *\n     * Retrieves an array of information which can be passed to the\n     * ::loadState method later to recreate the current state of the form\n     * fields and values.\n     */\n    function getState() {\n        $info = array();\n        foreach ($this->getFields() as $f) {\n            // Skip invisible fields\n            if (!$f->isVisible())\n                continue;\n\n            // Skip fields set to default values\n            $v = $f->getClean();\n            $d = $f->get('default');\n            if ($v == $d)\n                continue;\n\n            // Skip empty values\n            if (!$v)\n                continue;\n\n            $info[$f->get('name') ?: $f->get('id')] = $f->to_database($v);\n        }\n        return $info;\n    }\n\n    /**\n     * loadState\n     *\n     * Reset this form to the state previously recorded by the ::getState()\n     * method\n     */\n    function loadState($state) {\n        foreach ($this->getFields() as $f) {\n            $name = $f->get('name');\n            $f->reset();\n            if (isset($state[$name])) {\n                $f->value = $f->to_php($state[$name]);\n            }\n        }\n    }\n\n    /*\n     * Initialize a generic static form\n     */\n    static function instantiate() {\n        $r = new ReflectionClass(get_called_class());\n        return $r->newInstanceArgs(func_get_args());\n    }\n}\n\n/**\n * SimpleForm\n * Wrapper for inline/static forms.\n *\n */\nclass SimpleForm extends Form {\n    function __construct($fields=array(), $source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($fields);\n    }\n}\n\nclass CustomForm extends SimpleForm {\n\n    function getFields() {\n        global $thisstaff, $thisclient;\n\n        $options = $this->options;\n        $user = $options['user'] ?: $thisstaff ?: $thisclient;\n        $isedit = ($options['mode'] == 'edit');\n        $fields = array();\n        foreach (parent::getFields() as $field) {\n            if ($isedit && !$field->isEditable($user))\n                continue;\n\n            $fields[] = $field;\n        }\n\n        return $fields;\n    }\n}\n\nabstract class AbstractForm extends Form {\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($this->buildFields());\n    }\n    /**\n     * Fetch the fields defined for this form. This method is only called\n     * once.\n     */\n    abstract function buildFields();\n}\n\n/**\n * Container class to represent the connection between the form fields and the\n * rendered state of the form.\n */\ninterface FormRenderer {\n    // Render the form fields into a table\n    function asTable($form);\n    // Render the form fields into divs\n    function asBlock($form);\n}\n\nabstract class FormLayout {\n    static $default_cell_layout = 'Cell';\n\n    var $title;\n    var $options;\n\n    function __construct($title=false, $options=array()) {\n        $this->title = $title;\n        $this->options = $options;\n    }\n\n    function getLayout($field) {\n        $layout = $field->get('layout') ?: static::$default_cell_layout;\n        if (is_string($layout))\n            $layout = new $layout();\n        return $layout;\n    }\n}\n\nclass GridFluidLayout\nextends FormLayout\nimplements FormRenderer {\n    function asTable($form) {\n      ob_start();\n?>\n      <table class=\"<?php echo 'grid form' ?>\">\n          <caption><?php echo Format::htmlchars($this->title ?: $form->getTitle()); ?>\n                  <div><small><?php echo Format::viewableImages($form->getInstructions()); ?></small></div>\n          </caption>\n          <tbody><tr><?php for ($i=0; $i<12; $i++) echo '<td style=\"width:8.3333%\"/>'; ?></tr></tbody>\n<?php\n      $row_size = 12;\n      $cols = $row = 0;\n\n      //Layout and rendering options\n      $options = $this->options;\n\n      foreach ($form->getFields() as $f) {\n          $layout = $this->getLayout($f);\n          $size = $layout->getWidth() ?: 12;\n          if ($offs = $layout->getOffset()) {\n              $size += $offs;\n          }\n          if ($cols < $size || $layout->isBreakForced()) {\n              if ($row) echo '</tr>';\n              echo '<tr>';\n              $cols = $row_size;\n              $row++;\n          }\n          // Render the cell\n          $cols -= $size;\n          $attrs = array('colspan' => $size, 'rowspan' => $layout->getHeight(),\n              'style' => '\"'.$layout->getOption('style').'\"');\n          if ($offs) { ?>\n              <td colspan=\"<?php echo $offs; ?>\"></td> <?php\n          }\n          ?>\n          <td class=\"cell\" <?php echo Format::array_implode('=', ' ', array_filter($attrs)); ?>\n              data-field-id=\"<?php echo $f->get('id'); ?>\">\n              <fieldset class=\"field <?php if (!$f->isVisible()) echo 'hidden'; ?>\"\n                id=\"field<?php echo $f->getWidget()->id; ?>\"\n                data-field-id=\"<?php echo $f->get('id'); ?>\">\n<?php         if ($label = $f->get('label')) { ?>\n              <label class=\"<?php if ($f->isRequired()) echo 'required'; ?>\"\n                  for=\"<?php echo $f->getWidget()->id; ?>\">\n                  <?php echo Format::htmlchars($label); ?>:\n                <?php if ($f->isRequired()) { ?>\n                <span class=\"error\">*</span>\n                <?php\n                }?>\n              </label>\n<?php         }\n              if ($f->get('hint')) { ?>\n                  <div class=\"field-hint-text\">\n                      <?php echo Format::htmlchars($f->get('hint')); ?>\n                  </div>\n<?php         }\n              $f->render($options);\n              if ($f->errors())\n                  foreach ($f->errors() as $e)\n                      echo sprintf('<div class=\"error\">%s</div>', Format::htmlchars($e));\n?>\n              </fieldset>\n          </td>\n      <?php\n      }\n      if ($row)\n        echo  '</tr>';\n\n      echo '</tbody></table>';\n\n      return ob_get_clean();\n    }\n\n    function asBlock($form) {}\n}\n\n/**\n * Basic container for field and form layouts. By default every cell takes\n * a whole output row and does not imply any sort of width.\n */\nclass Cell {\n    function isBreakForced()  { return true; }\n    function getWidth()       { return false; }\n    function getHeight()      { return 1; }\n    function getOffset()      { return 0; }\n    function getOption($prop) { return false; }\n}\n\n/**\n * Fluid grid layout, meaning each cell renders to the right of the previous\n * cell (for left-to-right layouts). A width in columns can be specified for\n * each cell along with an offset from the previous cell. A height of columns\n * along with an optional break is supported.\n */\nclass GridFluidCell\nextends Cell {\n    var $span;\n    var $options;\n\n    function __construct($span, $options=array()) {\n        $this->span = $span;\n        $this->options = $options + array(\n            'rows' => 1,        # rowspan\n            'offset' => 0,      # skip some columns\n            'break' => false,   # start on a new row\n        );\n    }\n\n    function isBreakForced()  { return $this->options['break']; }\n    function getWidth()       { return $this->span; }\n    function getHeight()      { return $this->options['rows']; }\n    function getOffset()      { return $this->options['offset']; }\n    function getOption($prop) { return $this->options[$prop]; }\n}\n\nrequire_once(INCLUDE_DIR . \"class.json.php\");\n\nclass FormField {\n    static $widget = false;\n\n    var $ht = array(\n        'label' => false,\n        'required' => false,\n        'default' => false,\n        'configuration' => array(),\n    );\n\n    var $_form;\n    var $_cform;\n    var $_clean;\n    var $_errors = array();\n    var $_widget;\n    var $answer;\n    var $parent;\n    var $presentation_only = false;\n\n    static $types = array(\n        /* @trans */ 'Basic Fields' => array(\n            'text'  => array(   /* @trans */ 'Short Answer', 'TextboxField'),\n            'memo' => array(    /* @trans */ 'Long Answer', 'TextareaField'),\n            'thread' => array(  /* @trans */ 'Thread Entry', 'ThreadEntryField', false),\n            'datetime' => array(/* @trans */ 'Date and Time', 'DatetimeField'),\n            'timezone' => array(/* @trans */ 'Timezone', 'TimezoneField'),\n            'phone' => array(   /* @trans */ 'Phone Number', 'PhoneField'),\n            'bool' => array(    /* @trans */ 'Checkbox', 'BooleanField'),\n            'choices' => array( /* @trans */ 'Choices', 'ChoiceField'),\n            'files' => array(   /* @trans */ 'File Upload', 'FileUploadField'),\n            'break' => array(   /* @trans */ 'Section Break', 'SectionBreakField'),\n            'info' => array(    /* @trans */ 'Information', 'FreeTextField'),\n        ),\n    );\n    static $more_types = array();\n    static $uid = null;\n\n    function _uid() {\n        return ++self::$uid;\n    }\n\n    function __construct($options=array()) {\n        $this->ht = array_merge($this->ht, $options);\n        if (!isset($this->ht['id']))\n            $this->ht['id'] = self::_uid();\n    }\n\n    function __clone() {\n        $this->_widget = null;\n        $this->ht['id'] = self::_uid();\n    }\n\n    static function addFieldTypes($group, $callable) {\n        static::$more_types[$group][] = $callable;\n    }\n\n    static function allTypes() {\n        if (static::$more_types) {\n            foreach (static::$more_types as $group => $entries)\n                foreach ($entries as $c)\n                    static::$types[$group] = array_merge(\n                            static::$types[$group] ?: array(), call_user_func($c));\n\n            static::$more_types = array();\n        }\n        return static::$types;\n    }\n\n    static function getFieldType($type) {\n        foreach (static::allTypes() as $group=>$types)\n            if (isset($types[$type]))\n                return $types[$type];\n    }\n\n    function get($what, $default=null) {\n        return array_key_exists($what, $this->ht)\n            ? $this->ht[$what]\n            : $default;\n    }\n    function set($field, $value) {\n        $this->ht[$field] = $value;\n    }\n\n    function getId() {\n        return $this->ht['id'];\n    }\n\n    /**\n     * getClean\n     *\n     * Validates and cleans inputs from POST request. This is performed on a\n     * field instance, after a DynamicFormSet / DynamicFormSection is\n     * submitted via POST, in order to kick off parsing and validation of\n     * user-entered data.\n     */\n    function getClean() {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                // XXX: The widget value may be parsed already if this is\n                //      linked to dynamic data via ::getAnswer()\n                ? $this->value : $this->parse($this->getWidget()->value);\n\n            if ($vs = $this->get('cleaners')) {\n                if (is_array($vs)) {\n                    foreach ($vs as $cleaner)\n                        if (is_callable($cleaner))\n                            $this->_clean = call_user_func_array(\n                                    $cleaner, array($this, $this->_clean));\n                }\n                elseif (is_callable($vs))\n                    $this->_clean = call_user_func_array(\n                            $vs, array($this, $this->_clean));\n            }\n\n            if (!isset($this->_clean) && ($d = $this->get('default')))\n                $this->_clean = $d;\n\n            if ($this->isVisible())\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n    function reset() {\n        $this->value = $this->_clean = $this->_widget = null;\n    }\n\n    function getValue() {\n        return $this->getWidget()->getValue();\n    }\n\n    function errors() {\n        return $this->_errors;\n    }\n    function addError($message, $index=false) {\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors[] = $message;\n\n        // Update parent form errors for the field\n        if ($this->_form)\n            $this->_form->addError($this->errors(), $this->get('id'));\n    }\n\n    function isValidEntry() {\n        $this->validateEntry();\n        return count($this->_errors) == 0;\n    }\n\n    /**\n     * validateEntry\n     *\n     * Validates user entry on an instance of the field on a dynamic form.\n     * This is called when an instance of this field (like a TextboxField)\n     * receives data from the user and that value should be validated.\n     *\n     * Parameters:\n     * $value - (string) input from the user\n     */\n    function validateEntry($value) {\n        if (!$value && count($this->_errors))\n            return;\n\n        # Validates a user-input into an instance of this field on a dynamic\n        # form\n        if ($this->get('required') && !$value && $this->hasData())\n            $this->_errors[] = $this->getLabel()\n                ? sprintf(__('%s is a required field'), $this->getLabel())\n                : __('This is a required field');\n\n        # Perform declared validators for the field\n        if ($vs = $this->get('validators')) {\n            if (is_array($vs)) {\n                foreach ($vs as $validator)\n                    if (is_callable($validator))\n                        $validator($this, $value);\n            }\n            elseif (is_callable($vs))\n                $vs($this, $value);\n        }\n    }\n\n    /**\n     * isVisible\n     *\n     * If this field has visibility configuration, then it will parse the\n     * constraints with the visibility configuration to determine if the\n     * field is visible and should be considered for validation\n     */\n    function isVisible() {\n        if ($this->get('visibility') instanceof VisibilityConstraint) {\n            return $this->get('visibility')->isVisible($this);\n        }\n        return true;\n    }\n\n    /**\n     * Check if the user has edit rights\n     *\n     */\n\n    function isEditable($user=null) {\n\n        // Internal editable flag used by internal forms e.g internal lists\n        if (!$user && isset($this->ht['editable']))\n            return $this->ht['editable'];\n\n        if ($user instanceof Staff)\n            $flag = DynamicFormField::FLAG_AGENT_EDIT;\n        else\n            $flag = DynamicFormField::FLAG_CLIENT_EDIT;\n\n        return (($this->get('flags') & $flag) != 0);\n    }\n\n\n    /**\n     * isStorable\n     *\n     * Indicate if this field data is storable locally (default).Some field's data\n     * might beed to be stored elsewhere for optimization reasons at the\n     * application level.\n     *\n     */\n\n    function isStorable() {\n        return (($this->get('flags') & DynamicFormField::FLAG_EXT_STORED) == 0);\n    }\n\n    function isRequired() {\n        return $this->get('required');\n    }\n\n    /**\n     * parse\n     *\n     * Used to transform user-submitted data to a PHP value. This value is\n     * not yet considered valid. The ::validateEntry() method will be called\n     * on the value to determine if the entry is valid. Therefore, if the\n     * data is clearly invalid, return something like NULL that can easily\n     * be deemed invalid in ::validateEntry(), however, can still produce a\n     * useful error message indicating what is wrong with the input.\n     */\n    function parse($value) {\n        return is_string($value) ? trim($value) : $value;\n    }\n\n    /**\n     * to_php\n     *\n     * Transforms the data from the value stored in the database to a PHP\n     * value. The ::to_database() method is used to produce the database\n     * valse, so this method is the compliment to ::to_database().\n     *\n     * Parameters:\n     * $value - (string or null) database representation of the field's\n     *      content\n     */\n    function to_php($value) {\n        return $value;\n    }\n\n    /**\n     * to_config\n     *\n     * Transform the data from the value to config form (as determined by\n     * field). to_php is used for each field returned from\n     * ::getConfigurationOptions(), and when the whole configuration is\n     * built, to_config() is called and receives the config array. The array\n     * should be returned, perhaps with modifications, and will be JSON\n     * encoded and stashed in the database.\n     */\n    function to_config($value) {\n        return $value;\n    }\n\n    /**\n     * to_database\n     *\n     * Determines the value to be stored in the database. The database\n     * backend for all fields is a text field, so this method should return\n     * a text value or NULL to represent the value of the field. The\n     * ::to_php() method will convert this value back to PHP.\n     *\n     * Paremeters:\n     * $value - PHP value of the field's content\n     */\n    function to_database($value) {\n        return $value;\n    }\n\n    /**\n     * toString\n     *\n     * Converts the PHP value created in ::parse() or ::to_php() to a\n     * pretty-printed value to show to the user. This is especially useful\n     * for something like dates which are stored considerably different in\n     * the database from their respective human-friendly versions.\n     * Furthermore, this method allows for internationalization and\n     * localization.\n     *\n     * Parametes:\n     * $value - PHP value of the field's content\n     */\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function __toString() {\n        return $this->toString($this->value);\n    }\n\n    /**\n     * When data for this field is deleted permanently from some storage\n     * backend (like a database), other associated data may need to be\n     * cleaned as well. This hook allows fields to participate when the data\n     * for a field is cleaned up.\n     */\n    function db_cleanup($field=false) {\n    }\n\n    /**\n     * Returns an HTML friendly value for the data in the field.\n     */\n    function display($value) {\n        return Format::htmlchars($this->toString($value));\n    }\n\n    /**\n     * Returns a value suitable for exporting to a foreign system. Mostly\n     * useful for things like dates and phone numbers which should be\n     * formatted using a standard when exported\n     */\n    function export($value) {\n        return $this->toString($value);\n    }\n\n    /**\n     * Fetch a value suitable for embedding the value of this field in an\n     * email template. Reference implementation uses ::to_php();\n     */\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    /**\n     * Fetch the var type used with the email templating system's typeahead\n     * feature. This helps with variable expansion if supported by this\n     * field's ::asVar() method. This method should return a valid classname\n     * which implements the `TemplateVariable` interface.\n     */\n    function asVarType() {\n        return false;\n    }\n\n    /**\n     * Describe the difference between the to two values. Note that the\n     * values should be passed through ::parse() or to_php() before\n     * utilizing this method.\n     */\n    function whatChanged($before, $after) {\n        if ($before)\n            $desc = __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>');\n        else\n            $desc = __('set to <strong>%2$s</strong>');\n        return sprintf($desc, $this->display($before), $this->display($after));\n    }\n\n    /**\n     * Convert the field data to something matchable by filtering. The\n     * primary use of this is for ticket filtering.\n     */\n    function getFilterData() {\n        return $this->toString($this->getClean());\n    }\n\n    /**\n     * Fetches a value that represents this content in a consistent,\n     * searchable format. This is used by the search engine system and\n     * backend.\n     */\n    function searchable($value) {\n        return Format::searchable($this->toString($value));\n    }\n\n    function getKeys($value) {\n        return $this->to_database($value);\n    }\n\n    /**\n     * Fetches a list of options for searching. The values returned from\n     * this method are passed to the widget's `::render()` method so that\n     * the widget can be affected by this setting. For instance, date fields\n     * might have a 'between' search option which should trigger rendering\n     * of two date widgets for search results.\n     */\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('is'),\n            'nequal' =>     __('is not'),\n            'contains' =>   __('contains'),\n            'match' =>      __('matches'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('TextboxField', array()),\n            'nequal' => array('TextboxField', array()),\n            'contains' => array('TextboxField', array()),\n            'match' => array('TextboxField', array(\n                'placeholder' => __('Valid regular expression'),\n                'configuration' => array('size'=>30),\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' ')\n                        && false === @preg_match(\"/$v/\", ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n        );\n    }\n\n    /**\n     * This is used by the searching system to build a query for the search\n     * engine. The function should return a criteria listing to match\n     * content saved by the field by the `::to_database()` function.\n     */\n    function getSearchQ($method, $value, $name=false) {\n        $criteria = array();\n        $Q = new Q();\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n            case 'nset':\n                $Q->negate();\n            case 'set':\n                $criteria[$name . '__isnull'] = false;\n                break;\n\n            case 'nequal':\n                $Q->negate();\n            case 'equal':\n                $criteria[$name] = $value;\n                break;\n\n            case 'contains':\n                $criteria[$name . '__contains'] = $value;\n                break;\n\n            case 'match':\n                $criteria[$name . '__regex'] = $value;\n                break;\n        }\n        return $Q->add($criteria);\n    }\n\n    function getSearchWidget($method) {\n        $methods = $this->getSearchMethodWidgets();\n        $info = $methods[$method];\n        if (is_array($info)) {\n            $class = $info[0];\n            return new $class($info[1]);\n        }\n        return $info;\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'set':\n            return __('%s has a value');\n        case 'nset':\n            return __('%s does not have a value');\n        case 'equal':\n            return __('%s is %s' /* describes an equality */);\n        case 'nequal':\n            return __('%s is not %s' /* describes an inequality */);\n        case 'contains':\n            return __('%s contains \"%s\"');\n        case 'match':\n            return __('%s matches pattern %s');\n        case 'includes':\n            return __('%s in (%s)');\n        case '!includes':\n            return __('%s not in (%s)');\n        }\n    }\n    function describeSearch($method, $value, $name=false) {\n        $desc = $this->describeSearchMethod($method);\n        $value = $this->toString($value);\n        return sprintf($desc, $name, $value);\n    }\n\n    function getLabel() { return $this->get('label'); }\n\n    /**\n     * getImpl\n     *\n     * Magic method that will return an implementation instance of this\n     * field based on the simple text value of the 'type' value of this\n     * field instance. The list of registered fields is determined by the\n     * global get_dynamic_field_types() function. The data from this model\n     * will be used to initialize the returned instance.\n     *\n     * For instance, if the value of this field is 'text', a TextField\n     * instance will be returned.\n     */\n    function getImpl($parent=null) {\n        // Allow registration with ::addFieldTypes and delayed calling\n        $type = static::getFieldType($this->get('type'));\n        $clazz = $type[1];\n        $inst = new $clazz($this->ht);\n        $inst->parent = $parent;\n        $inst->setForm($this->_form);\n        return $inst;\n    }\n\n    function __call($what, $args) {\n        // XXX: Throw exception if $this->parent is not set\n        if (!$this->parent)\n            throw new Exception(sprintf(__('%s: Call to undefined function'),\n                $what));\n        // BEWARE: DynamicFormField has a __call() which will create a new\n        //      FormField instance and invoke __call() on it or bounce\n        //      immediately back\n        return call_user_func_array(\n            array($this->parent, $what), $args);\n    }\n\n    function getAnswer() { return $this->answer; }\n    function setAnswer($ans) { $this->answer = $ans; }\n\n    function setValue($value) {\n        $this->reset();\n        $this->getWidget()->value = $value;\n    }\n\n    function getFormName() {\n        if (is_numeric($this->get('id')))\n            return substr(md5(\n                session_id() . '-field-id-'.$this->get('id')), -16);\n        else\n            return $this->get('name') ?: $this->get('id');\n    }\n\n    function setForm($form) {\n        $this->_form = $form;\n    }\n    function getForm() {\n        return $this->_form;\n    }\n    /**\n     * Returns the data source for this field. If created from a form, the\n     * data source from the form is returned. Otherwise, if the request is a\n     * POST, then _POST is returned.\n     */\n    function getSource() {\n        if ($this->_form)\n            return $this->_form->getSource();\n        elseif ($_SERVER['REQUEST_METHOD'] == 'POST')\n            return $_POST;\n        else\n            return array();\n    }\n\n    function render($options=array()) {\n        $rv = $this->getWidget()->render($options);\n        if ($v = $this->get('visibility')) {\n            $v->emitJavascript($this);\n        }\n        return $rv;\n    }\n\n    function renderExtras($options=array()) {\n        return;\n    }\n\n    function getMedia() {\n        $widget = $this->getWidget();\n        return $widget::$media;\n    }\n\n    function getConfigurationOptions() {\n        return array();\n    }\n\n    /**\n     * getConfiguration\n     *\n     * Loads configuration information from database into hashtable format.\n     * Also, the defaults from ::getConfigurationOptions() are integrated\n     * into the database-backed options, so that if options have not yet\n     * been set or a new option has been added and not saved for this field,\n     * the default value will be reflected in the returned configuration.\n     */\n    function getConfiguration() {\n        if (!$this->_config) {\n            $this->_config = $this->get('configuration');\n            if (is_string($this->_config))\n                $this->_config = JsonDataParser::parse($this->_config);\n            elseif (!$this->_config)\n                $this->_config = array();\n            foreach ($this->getConfigurationOptions() as $name=>$field)\n                if (!isset($this->_config[$name]))\n                    $this->_config[$name] = $field->get('default');\n        }\n        return $this->_config;\n    }\n\n    /**\n     * If the [Config] button should be shown to allow for the configuration\n     * of this field\n     */\n    function isConfigurable() {\n        return true;\n    }\n\n    /**\n     * Field type is changeable in the admin interface\n     */\n    function isChangeable() {\n        return true;\n    }\n\n    /**\n     * Field does not contain data that should be saved to the database. Ie.\n     * non data fields like section headers\n     */\n    function hasData() {\n        return true;\n    }\n\n    /**\n     * Returns true if the field/widget should be rendered as an entire\n     * block in the target form.\n     */\n    function isBlockLevel() {\n        return false;\n    }\n\n    /**\n     * Fields should not be saved with the dynamic data. It is assumed that\n     * some static processing will store the data elsewhere.\n     */\n    function isPresentationOnly() {\n        return $this->presentation_only;\n    }\n\n    /**\n     * Indicates if the field places data in the `value_id` column. This\n     * is currently used by the materialized view system\n     */\n    function hasIdValue() {\n        return false;\n    }\n\n    /**\n     * Indicates if the field has subfields accessible via getSubFields()\n     * method. Useful for filter integration. Should connect with\n     * getFilterData()\n     */\n    function hasSubFields() {\n        return false;\n    }\n    function getSubFields() {\n        return null;\n    }\n\n    /**\n     * Indicates if the field provides for searching for something other\n     * than keywords. For instance, textbox fields can have hits by keyword\n     * searches alone, but selection fields should provide the option to\n     * match a specific value or set of values and therefore need to\n     * participate on any search builder.\n     */\n    function hasSpecialSearch() {\n        return true;\n    }\n\n    function getConfigurationForm($source=null) {\n        if (!$this->_cform) {\n            $type = static::getFieldType($this->get('type'));\n            $clazz = $type[1];\n            $T = new $clazz($this->ht);\n            $config = $this->getConfiguration();\n            $this->_cform = new SimpleForm($T->getConfigurationOptions(), $source);\n            if (!$source) {\n                foreach ($this->_cform->getFields() as $name=>$f) {\n                    if ($config && isset($config[$name]))\n                        $f->value = $config[$name];\n                    elseif ($f->get('default'))\n                        $f->value = $f->get('default');\n                }\n            }\n        }\n        return $this->_cform;\n    }\n\n    function configure($prop, $value) {\n        $this->getConfiguration();\n        $this->_config[$prop] = $value;\n    }\n\n    function getWidget($widgetClass=false) {\n        if (!static::$widget)\n            throw new Exception(__('Widget not defined for this field'));\n        if (!isset($this->_widget)) {\n            $wc = $widgetClass ?: $this->get('widget') ?: static::$widget;\n            $this->_widget = new $wc($this);\n            $this->_widget->parseValue();\n        }\n        return $this->_widget;\n    }\n\n    function getSelectName() {\n        $name = $this->get('name') ?: 'field_'.$this->get('id');\n        if ($this->hasIdValue())\n            $name .= '_id';\n\n        return $name;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('field.%s.%s%s', $subtag, $this->get('id'),\n            $this->get('form_id') ? '' : '*internal*'));\n    }\n    function getLocal($subtag, $default=false) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : ($default ?: $this->get($subtag));\n    }\n}\n\nclass TextboxField extends FormField {\n    static $widget = 'TextboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'size'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Size'), 'required'=>false, 'default'=>16,\n                    'validator' => 'number')),\n            'length' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Max Length'), 'required'=>false, 'default'=>30,\n                    'validator' => 'number')),\n            'validator' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Validator'), 'required'=>false, 'default'=>'',\n                'choices' => array('phone'=>__('Phone Number'),'email'=>__('Email Address'),\n                    'ip'=>__('IP Address'), 'number'=>__('Number'),\n                    'regex'=>__('Custom (Regular Expression)'), ''=>__('None')))),\n            'regex' => new TextboxField(array(\n                'id'=>6, 'label'=>__('Regular Expression'), 'required'=>true,\n                'configuration'=>array('size'=>40, 'length'=>100),\n                'visibility' => new VisibilityConstraint(\n                    new Q(array('validator__eq'=>'regex')),\n                    VisibilityConstraint::HIDDEN\n                ),\n                'cleaners' => function ($self, $value) {\n                    $wrapped = \"/\".$value.\"/iu\";\n                    if (false === @preg_match($value, ' ')\n                            && false !== @preg_match($wrapped, ' ')) {\n                        $value = $wrapped;\n                    }\n                    if ($value == '//iu')\n                        return '';\n\n                    return $value;\n                },\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n            'validator-error' => new TextboxField(array(\n                'id'=>4, 'label'=>__('Validation Error'), 'default'=>'',\n                'configuration'=>array('size'=>40, 'length'=>60,\n                    'translatable'=>$this->getTranslateTag('validator-error')\n                ),\n                'hint'=>__('Message shown to user if the input does not match the validator'))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')\n                ),\n            )),\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' =>       null,\n            'email' =>  array(array('Validator', 'is_valid_email'),\n                __('Enter a valid email address')),\n            'phone' =>  array(array('Validator', 'is_phone'),\n                __('Enter a valid phone number')),\n            'ip' =>     array(array('Validator', 'is_ip'),\n                __('Enter a valid IP address')),\n            'number' => array('is_numeric', __('Enter a number')),\n            'regex' => array(\n                function($v) use ($config) {\n                    $regex = $config['regex'];\n                    return @preg_match($regex, $v);\n                }, __('Value does not match required pattern')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        $valid = $this->get('validator');\n        if (!$valid) {\n            $valid = $config['validator'];\n        }\n        if (!$value || !isset($validators[$valid]))\n            return;\n        $func = $validators[$valid];\n        $error = $func[1];\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func($func[0], $value))\n                $this->_errors[] = $error;\n    }\n\n    function parse($value) {\n        return Format::striptags($value);\n    }\n}\n\nclass PasswordField extends TextboxField {\n    static $widget = 'PasswordWidget';\n\n    function parse($value) {\n        // Don't trim the value\n        return $value;\n    }\n\n    function to_database($value) {\n        // If not set in UI, don't save the empty value\n        if (!$value)\n            throw new FieldUnchanged();\n        return Crypto::encrypt($value, SECRET_SALT, 'pwfield');\n    }\n\n    function to_php($value) {\n        return Crypto::decrypt($value, SECRET_SALT, 'pwfield');\n    }\n}\n\nclass TextareaField extends FormField {\n    static $widget = 'TextareaWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'cols'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Width').' '.__('(chars)'), 'required'=>true, 'default'=>40)),\n            'rows'  =>  new TextboxField(array(\n                'id'=>2, 'label'=>__('Height').' '.__('(rows)'), 'required'=>false, 'default'=>4)),\n            'length' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Max Length'), 'required'=>false, 'default'=>0)),\n            'html' => new BooleanField(array(\n                'id'=>4, 'label'=>__('HTML'), 'required'=>false, 'default'=>true,\n                'configuration'=>array('desc'=>__('Allow HTML input in this box')))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')),\n            )),\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function display($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::safe_html($value);\n        else\n            return nl2br(Format::htmlchars($value));\n    }\n\n    function searchable($value) {\n        $body = new HtmlThreadEntryBody($value);\n        return $body->getSearchable();\n    }\n\n    function export($value) {\n        return (!$value) ? $value : Format::html2text($value);\n    }\n\n    function parse($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::sanitize($value);\n        else\n            return $value;\n    }\n\n}\n\nclass PhoneField extends FormField {\n    static $widget = 'PhoneNumberWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'ext' => new BooleanField(array(\n                'label'=>__('Extension'), 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add a separate field for the extension'),\n                ),\n            )),\n            'digits' => new TextboxField(array(\n                'label'=>__('Minimum length'), 'default'=>7,\n                'hint'=>__('Fewest digits allowed in a valid phone number'),\n                'configuration'=>array('validator'=>'number', 'size'=>5),\n            )),\n            'format' => new ChoiceField(array(\n                'label'=>__('Display format'), 'default'=>'us',\n                'choices'=>array(''=>'-- '.__('Unformatted').' --',\n                    'us'=>__('United States')),\n            )),\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        # Run validator against $this->value for email type\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        if ($phone && (\n                !is_numeric($phone) ||\n                strlen($phone) < $config['digits']))\n            $this->_errors[] = __(\"Enter a valid phone number\");\n        if ($ext && $config['ext']) {\n            if (!is_numeric($ext))\n                $this->_errors[] = __(\"Enter a valid phone extension\");\n            elseif (!$phone)\n                $this->_errors[] = __(\"Enter a phone number for the extension\");\n        }\n    }\n\n    function parse($value) {\n        // NOTE: Value may have a legitimate 'X' to separate the number and\n        // extension parts. Don't remove the 'X'\n        $val = preg_replace('/[^\\dX]/', '', $value);\n        // Pass completely-incorrect string for validation error\n        return $val ?: $value;\n    }\n\n    function toString($value) {\n        $config = $this->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        switch ($config['format']) {\n        case 'us':\n            $phone = Format::phone($phone);\n            break;\n        }\n        if ($ext)\n            $phone.=\" x$ext\";\n        return $phone;\n    }\n}\n\nclass BooleanField extends FormField {\n    static $widget = 'CheckboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'desc' => new TextareaField(array(\n                'id'=>1, 'label'=>__('Description'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown inline with the widget'),\n                'configuration'=>array('rows'=>2)))\n        );\n    }\n\n    function to_database($value) {\n        return ($value) ? '1' : '0';\n    }\n\n    function parse($value) {\n        return $this->to_php($value);\n    }\n    function to_php($value) {\n        return $value ? true : false;\n    }\n\n    function toString($value) {\n        return ($value) ? __('Yes') : __('No');\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('checked'),\n            'nset' =>    __('unchecked'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case 'set':\n            return new Q(array($name => '1'));\n        case 'nset':\n            return new Q(array($name => '0'));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n}\n\nclass ChoiceField extends FormField {\n    static $widget = 'ChoicesWidget';\n    var $_choices;\n\n    function getConfigurationOptions() {\n        return array(\n            'choices'  =>  new TextareaField(array(\n                'id'=>1, 'label'=>__('Choices'), 'required'=>false, 'default'=>'',\n                'hint'=>__('List choices, one per line. To protect against spelling changes, specify key:value names to preserve entries if the list item names change'),\n                'configuration'=>array('html'=>false)\n            )),\n            'default' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'hint'=>__('(Enter a key). Value selected from the list initially'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('prompt'),\n                ),\n            )),\n            'multiselect' => new BooleanField(array(\n                'id'=>1, 'label'=>'Multiselect', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>'Allow multiple selections')\n            )),\n        );\n    }\n\n    function parse($value) {\n        return $this->to_php($value ?: null);\n    }\n\n    function to_database($value) {\n        if (!is_array($value)) {\n            $choices = $this->getChoices();\n            if (isset($choices[$value]))\n                $value = array($value => $choices[$value]);\n        }\n        if (is_array($value))\n            $value = JsonDataEncoder::encode($value);\n\n        return $value;\n    }\n\n    function to_php($value) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        // CDATA table may be built with comma-separated key,value,key,value\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            $choices = $this->getChoices();\n            $vals = explode(',', $value);\n            foreach ($vals as $V) {\n                if (isset($choices[$V]))\n                    $values[$V] = $choices[$V];\n            }\n            if (array_filter($values))\n                $value = $values;\n            elseif($vals)\n                list($value) = $vals;\n\n        }\n        $config = $this->getConfiguration();\n        if (!$config['multiselect'] && is_array($value) && count($value) < 2) {\n            reset($value);\n            $value = key($value);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getKeys($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', array_keys($value));\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $value = $this->to_php($value);\n        return $this->toString($this->getChoice($value));\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = array_map(array($this, 'display'), $added);\n        $deleted = array_map(array($this, 'display'), $deleted);\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n\n    /*\n     Return criteria to which the choice should be filtered by\n     */\n    function getCriteria() {\n        $config = $this->getConfiguration();\n        $criteria = array();\n        if (isset($config['criteria']))\n            $criteria = $config['criteria'];\n\n        return $criteria;\n    }\n\n    function getChoice($value) {\n\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value]))\n            $selection[] = $choices[$value];\n        elseif ($this->get('default'))\n            $selection[] = $choices[$this->get('default')];\n\n        return $selection;\n    }\n\n    function getChoices($verbose=false) {\n        if ($this->_choices === null || $verbose) {\n            // Allow choices to be set in this->ht (for configurationOptions)\n            $this->_choices = $this->get('choices');\n            if (!$this->_choices) {\n                $this->_choices = array();\n                $config = $this->getConfiguration();\n                $choices = explode(\"\\n\", $config['choices']);\n                foreach ($choices as $choice) {\n                    // Allow choices to be key: value\n                    list($key, $val) = explode(':', $choice);\n                    if ($val == null)\n                        $val = $key;\n                    $this->_choices[trim($key)] = trim($val);\n                }\n                // Add old selections if nolonger available\n                // This is necessary so choices made previously can be\n                // retained\n                $values = ($a=$this->getAnswer()) ? $a->getValue() : array();\n                if ($values && is_array($values)) {\n                    foreach ($values as $k => $v) {\n                        if (!isset($this->_choices[$k])) {\n                            if ($verbose) $v .= ' (retired)';\n                            $this->_choices[$k] = $v;\n                        }\n                    }\n                }\n            }\n        }\n        return $this->_choices;\n    }\n\n    function lookupChoice($value) {\n        return null;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>     __('does not have a value'),\n            'includes' =>   __('includes'),\n            '!includes' =>  __('does not include'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n            '!includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case '!includes':\n            return Q::not(array(\"{$name}__in\" => array_keys($value)));\n        case 'includes':\n            return new Q(array(\"{$name}__in\" => array_keys($value)));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'includes':\n            return __('%s includes %s' /* includes -> if a list includes a selection */);\n        case 'includes':\n            return __('%s does not include %s' /* includes -> if a list includes a selection */);\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n}\n\nclass DatetimeField extends FormField {\n    static $widget = 'DatetimePickerWidget';\n\n    var $min = null;\n    var $max = null;\n\n    // Get php DatateTime object of the field  - null if value is empty\n    function getDateTime($value=null) {\n        return Format::parseDateTime($value ?: $this->value);\n    }\n\n    // Get effective timezone for the field\n    function getTimeZone() {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        $timezone = new DateTimeZone($config['timezone'] ?:\n                $cfg->getTimezone());\n\n        return $timezone;\n    }\n\n    function getMinDateTime() {\n\n        if (!isset($this->min)) {\n            $config = $this->getConfiguration();\n            $this->min = $config['min']\n                ? Format::parseDateTime($config['min']) : false;\n        }\n\n        return $this->min;\n    }\n\n    function getMaxDateTime() {\n\n        if (!isset($this->max)) {\n            $config = $this->getConfiguration();\n            $this->max = $config['max']\n                ? Format::parseDateTime($config['max']) : false;\n        }\n\n        return $this->max;\n    }\n\n    function to_database($value) {\n        // Store time in format given by Date Picker (DateTime::W3C)\n        return $value;\n    }\n\n    function to_php($value) {\n\n        if (strtotime($value) <= 0)\n            return 0;\n\n        return $value;\n    }\n\n    function display($value) {\n        global $cfg;\n\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['gmt'])\n            return $this->format((int) $datetime->format('U'));\n\n        // Force timezone if field has one.\n        if ($config['timezone']) {\n            $timezone = new DateTimezone($config['timezone']);\n            $datetime->setTimezone($timezone);\n        }\n\n        $value = $this->format($datetime->format('U'),\n                $datetime->getTimezone()->getName());\n\n        // No need to show timezone\n        if (!$config['time'])\n            return $value;\n\n        // Display is NOT timezone aware show entry's timezone.\n        return sprintf('%s (%s)',\n                $value, $datetime->format('T'));\n    }\n\n    function format($timestamp, $timezone=false) {\n\n        if (!$timestamp || $timestamp <= 0)\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['time'])\n            $formatted = Format::datetime($timestamp, false, $timezone);\n        else\n            $formatted = Format::date($timestamp, false, false, $timezone);\n\n        return $formatted;\n    }\n\n    function toString($value) {\n\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        if ($timestamp <= 0)\n            return '';\n\n        return $this->format($timestamp);\n    }\n\n    function asVar($value, $id=false) {\n        global $cfg;\n\n        if (!$value)\n            return null;\n\n        $datetime = $this->getDateTime($value);\n        $config = $this->getConfiguration();\n        if (!$config['gmt'] || !$config['time'])\n            $timezone  = $datetime->getTimezone()->getName();\n        else\n            $timezone  = false;\n\n        return  new FormattedDate($value, array(\n                    'timezone'  =>  $timezone,\n                    'format'    =>  $config['time'] ? 'long' : 'short'\n                    )\n                );\n    }\n\n    function asVarType() {\n        return 'FormattedDate';\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'time' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Time'), 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>__('Show time selection with date picker')))),\n            'timezone' => new TimezoneField(array(\n                'id'=>2, 'label'=>__('Timezone'), 'required'=>false,\n                'hint'=>__('Timezone of the date time selection'),\n                'configuration' => array('autodetect'=>false,\n                    'prompt' => __(\"User's timezone\")),\n               'visibility' => new VisibilityConstraint(\n                    new Q(array('time__eq'=> true)),\n                    VisibilityConstraint::HIDDEN\n                ),\n                )),\n            'gmt' => new BooleanField(array(\n                'id'=>3, 'label'=>__('Timezone Aware'), 'required'=>false,\n                'configuration'=>array(\n                    'desc'=>__(\"Show date/time relative to user's timezone\")))),\n            'min' => new DatetimeField(array(\n                'id'=>4, 'label'=>__('Earliest'), 'required'=>false,\n                'hint'=>__('Earliest date selectable'))),\n            'max' => new DatetimeField(array(\n                'id'=>5, 'label'=>__('Latest'), 'required'=>false,\n                'default'=>null, 'hint'=>__('Latest date selectable'))),\n            'future' => new BooleanField(array(\n                'id'=>6, 'label'=>__('Allow Future Dates'), 'required'=>false,\n                'default'=>true, 'configuration'=>array(\n                    'desc'=>__('Allow entries into the future' /* Used in the date field */)),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        parent::validateEntry($value);\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return;\n\n        // Parse value to DateTime object\n        $val = Format::parseDateTime($value);\n        // Get configured min/max (if any)\n        $min = $this->getMinDateTime();\n        $max = $this->getMaxDateTime();\n\n        if (!$val) {\n            $this->_errors[] = __('Enter a valid date');\n        } elseif ($min and $val < $min) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is earlier than permitted'),\n                     Format::date($min->getTimestamp(), false, false,\n                         $min->getTimezone()->getName() ?: 'UTC')\n                     );\n        } elseif ($max and $val > $max) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is later than permitted'),\n                    Format::date($max->getTimestamp(), false, false,\n                        $max->getTimezone()->getName() ?: 'UTC')\n                    );\n        }\n    }\n\n    // SearchableField interface ------------------------------\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('on'),\n            'nequal' =>     __('not on'),\n            'before' =>     __('before'),\n            'after' =>      __('after'),\n            'between' =>    __('between'),\n            'ndaysago' =>   __('in the last n days'),\n            'ndays' =>      __('in the next n days'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        $config_notime = $config = $this->getConfiguration();\n        $config_notime['time'] = false;\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'nequal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'before' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'after' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'between' => array('InlineformField', array(\n                'form' => array(\n                    'left' => new DatetimeField(),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'and'))\n                    ),\n                    'right' => new DatetimeField(),\n                ),\n            )),\n            'ndaysago' => array('InlineformField', array(\n                'form' => array(\n                    'until' => new TextboxField(array(\n                        'configuration' => array('validator'=>'number', 'size'=>4))\n                    ),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'days'))\n                    ),\n                ),\n            )),\n            'ndays' => array('InlineformField', array(\n                'form' => array(\n                    'until' => new TextboxField(array(\n                        'configuration' => array('validator'=>'number', 'size'=>4))\n                    ),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'days'))\n                    ),\n                ),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $config = $this->getConfiguration();\n        $value = is_int($value)\n            ? DateTime::createFromFormat('U', !$config['gmt'] ? Misc::gmtime($value) : $value) ?: $value\n            : $value;\n        switch ($method) {\n        case 'equal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return new Q(array(\n                \"{$name}__gte\" => $l,\n                \"{$name}__lt\" => $r\n            ));\n        case 'nequal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return Q::any(array(\n                \"{$name}__lt\" => $l,\n                \"{$name}__gte\" => $r,\n            ));\n        case 'after':\n            return new Q(array(\"{$name}__gte\" => $value));\n        case 'before':\n            return new Q(array(\"{$name}__lt\" => $value));\n        case 'between':\n            foreach (array('left', 'right') as $side) {\n                $value[$side] = is_int($value[$side])\n                    ? DateTime::createFromFormat('U', !$config['gmt']\n                        ? Misc::gmtime($value[$side]) : $value[$side]) ?: $value[$side]\n                    : $value[$side];\n            }\n            return new Q(array(\n                \"{$name}__gte\" => $value['left'],\n                \"{$name}__lte\" => $value['right'],\n            ));\n        case 'ndaysago':\n            $now = Misc::gmtime();\n            return new Q(array(\n                \"{$name}__lt\" => $now,\n                \"{$name}__gte\" => SqlExpression::minus($now, SqlInterval::DAY($value['until'])),\n            ));\n        case 'ndays':\n            $now = Misc::gmtime();\n            return new Q(array(\n                \"{$name}__gt\" => $now,\n                \"{$name}__lte\" => SqlExpression::plus($now, SqlInterval::DAY($value['until'])),\n            ));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'before':\n            return __('%1$s before %2$s' /* occurs before a date and time */);\n        case 'after':\n            return __('%1$s after %2$s' /* occurs after a date and time */);\n        case 'ndays':\n            return __('%1$s in the next %2$s' /* occurs within a window (like 3 days) */);\n        case 'ndaysago':\n            return __('%1$s in the last %2$s' /* occurs within a recent window (like 3 days) */);\n        case 'between':\n            return __('%1$s between %2$s and %3$s');\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n        if ($method === 'between') {\n            $l = $this->toString($value['left']);\n            $r = $this->toString($value['right']);\n            $desc = $this->describeSearchMethod($method);\n            return sprintf($desc, $name, $l, $r);\n        }\n        return parent::describeSearch($method, $value, $name);\n    }\n}\n\n/**\n * This is kind-of a special field that doesn't have any data. It's used as\n * a field to provide a horizontal section break in the display of a form\n */\nclass SectionBreakField extends FormField {\n    static $widget = 'SectionBreakWidget';\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n}\n\nclass ThreadEntryField extends FormField {\n    static $widget = 'ThreadEntryWidget';\n\n    function isChangeable() {\n        return false;\n    }\n    function isBlockLevel() {\n        return true;\n    }\n    function isPresentationOnly() {\n        return true;\n    }\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function getMedia() {\n        $config = $this->getConfiguration();\n        $media = parent::getMedia() ?: array();\n        if ($config['attachments'])\n            $media = array_merge_recursive($media, FileUploadWidget::$media);\n        return $media;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n        $config = parent::getConfiguration();\n        $config['html'] = (bool) ($cfg && $cfg->isRichTextEnabled());\n        return $config;\n    }\n\n    function getConfigurationOptions() {\n        global $cfg;\n\n        $attachments = new FileUploadField();\n        $fileupload_config = $attachments->getConfigurationOptions();\n        if ($cfg->getAllowedFileTypes())\n            $fileupload_config['extensions']->set('default', $cfg->getAllowedFileTypes());\n\n        foreach ($fileupload_config as $C) {\n            $C->set('visibility', new VisibilityConstraint(new Q(array(\n                'attachments__eq'=>true,\n            )), VisibilityConstraint::HIDDEN));\n        }\n        return array(\n            'attachments' => new BooleanField(array(\n                'label'=>__('Enable Attachments'),\n                'default'=>$cfg->allowAttachments(),\n                'configuration'=>array(\n                    'desc'=>__('Enables attachments, regardless of channel'),\n                ),\n                'validators' => function($self, $value) {\n                    if (!ini_get('file_uploads'))\n                        $self->addError(__('The \"file_uploads\" directive is disabled in php.ini'));\n                }\n            )),\n        )\n        + $fileupload_config;\n    }\n\n    function isAttachmentsEnabled() {\n        $config = $this->getConfiguration();\n        return $config['attachments'];\n    }\n\n    function getWidget($widgetClass=false) {\n        if ($hint = $this->getLocal('hint'))\n            $this->set('placeholder', $hint);\n        $this->set('hint', null);\n        $widget = parent::getWidget($widgetClass);\n        return $widget;\n    }\n}\n\nclass PriorityField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Priority)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        $sql = 'SELECT priority_id, priority_desc FROM '.PRIORITY_TABLE\n              .' ORDER BY priority_urgency DESC';\n        $choices = array('' => '\u2014 '.__('Default').' \u2014');\n        if (!($res = db_query($sql)))\n            return $choices;\n\n        while ($row = db_fetch_row($res))\n            $choices[$row[0]] = $row[1];\n        return $choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Priority)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n        if ($id)\n            return Priority::lookup($id);\n    }\n\n    function to_database($prio) {\n        return ($prio instanceof Priority)\n            ? array($prio->getDesc(), $prio->getId())\n            : $prio;\n    }\n\n    function display($prio) {\n        if (!$prio instanceof Priority)\n            return parent::display($prio);\n        return sprintf('<span style=\"padding: 2px; background-color: %s\">%s</span>',\n            $prio->getColor(), Format::htmlchars($prio->getDesc()));\n    }\n\n    function toString($value) {\n        return ($value instanceof Priority) ? $value->getDesc() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return FormField::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        // Priority isn't searchable this way\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Priority) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfigurationOptions() {\n        $choices = $this->getChoices();\n        $choices[''] = __('System Default');\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n            'default' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'choices' => $choices,\n                'hint'=>__('Default selection for this field'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n        );\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultPriorityId();\n        return $config;\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'priority' => array(__('Priority Level'), 'PriorityField'),\n    );\n});\n\n\nclass TimezoneField extends ChoiceField {\n    static $widget = 'TimezoneWidget';\n\n    function hasIdValue() {\n        return false;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        $choices = array();\n        foreach (DateTimeZone::listIdentifiers() as $zone)\n            $choices[$zone] =  str_replace('/',' / ',$zone);\n\n        return $choices;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'autodetect' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Auto Detect'), 'required'=>false, 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add Auto Detect Button'))\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\n\nclass DepartmentField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Dept)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        $choices = array();\n        if (($depts = Dept::getDepartments()))\n            foreach ($depts as $id => $name)\n                $choices[$id] = $name;\n\n        return $choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        return $id;\n    }\n\n    function to_database($dept) {\n        return ($dept instanceof Dept)\n            ? array($dept->getName(), $dept->getId())\n            : $dept;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'department' => array(__('Department'), 'DepartmentField'),\n    );\n});\n\n\nclass AssigneeField extends ChoiceField {\n    var $_choices = null;\n    var $_criteria = null;\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if (is_object($widget->value))\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function getCriteria() {\n\n        if (!isset($this->_criteria)) {\n            $this->_criteria = array('available' => true);\n            if (($c=parent::getCriteria()))\n                $this->_criteria = array_merge($this->_criteria, $c);\n        }\n\n        return $this->_criteria;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function setChoices($choices) {\n        $this->_choices = $choices;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        if (!isset($this->_choices)) {\n            $config = $this->getConfiguration();\n            $choices = array(\n                    __('Agents') => new ArrayObject(),\n                    __('Teams') => new ArrayObject());\n            $A = current($choices);\n            $criteria = $this->getCriteria();\n            $agents = array();\n            if (($dept=$config['dept']) && $dept->assignMembersOnly()) {\n                if (($members = $dept->getAvailableMembers()))\n                    foreach ($members as $member)\n                        $agents[$member->getId()] = $member;\n            } else {\n                $agents = Staff::getStaffMembers($criteria);\n            }\n\n            foreach ($agents as $id => $name)\n                $A['s'.$id] = $name;\n\n            next($choices);\n            $T = current($choices);\n            if (($teams = Team::getActiveTeams()))\n                foreach ($teams as $id => $name)\n                    $T['t'.$id] = $name;\n\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function getValue() {\n\n        if (($value = parent::getValue()) && ($id=$this->getClean()))\n           return $value[$id];\n    }\n\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n\n        if ($id[0] == 's')\n            return Staff::lookup(substr($id, 1));\n        elseif ($id[0] == 't')\n            return Team::lookup(substr($id, 1));\n\n        return $id;\n    }\n\n\n    function to_database($value) {\n        return (is_object($value))\n            ? array($value->getName(), $value->getId())\n            : $value;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'assignee' => array(__('Assignee'), 'AssigneeField'),\n    );\n});\n\n\nclass TicketStateField extends ChoiceField {\n\n    static $_states = array(\n            'open' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Open',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Open'\n                ),\n            'closed' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Closed',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Close'\n                )\n            );\n    // Private states\n    static $_privatestates = array(\n            'archived' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Archived',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Archive'\n                ),\n            'deleted'  => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Deleted',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Delete'\n                )\n            );\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return false;\n    }\n\n    function getChoices($verbose=false) {\n        static $_choices;\n\n        $states = static::$_states;\n        if ($this->options['private_too'])\n            $states += static::$_privatestates;\n\n        if (!isset($_choices)) {\n            // Translate and cache the choices\n            foreach ($states as $k => $v)\n                $_choices[$k] =  _P('ticket state name', $v['name']);\n\n            $this->ht['default'] =  '';\n        }\n\n        return $_choices;\n    }\n\n    function getChoice($state) {\n\n        if ($state && is_array($state))\n            $state = key($state);\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state name', static::$_states[$state]['name']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state name', static::$_privatestates[$state]['name']);\n\n        return $state;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=> __('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=> __('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n\n    static function getVerb($state) {\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state action', static::$_states[$state]['verb']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state action', static::$_privatestates[$state]['verb']);\n    }\n}\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'state' => array('Ticket State', 'TicketStateField', false),\n    );\n});\n\nclass TicketFlagField extends ChoiceField {\n\n    // Supported flags (TODO: move to configurable custom list)\n    static $_flags = array(\n            'onhold' => array(\n                'flag' => 1,\n                'name' => 'Onhold',\n                'states' => array('open'),\n                ),\n            'overdue' => array(\n                'flag' => 2,\n                'name' => 'Overdue',\n                'states' => array('open'),\n                ),\n            'answered' => array(\n                'flag' => 4,\n                'name' => 'Answered',\n                'states' => array('open'),\n                )\n            );\n\n    var $_choices;\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        $this->ht['default'] =  '';\n\n        if (!$this->_choices) {\n            foreach (static::$_flags as $k => $v)\n                $this->_choices[$k] = $v['name'];\n        }\n\n        return $this->_choices;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>'Prompt', 'required'=>false, 'default'=>'',\n                'hint'=>'Leading text shown before a value is selected',\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'flags' => array('Ticket Flags', 'TicketFlagField', false),\n    );\n});\n\nclass FileUploadField extends FormField {\n    static $widget = 'FileUploadWidget';\n\n    protected $attachments;\n    protected $files;\n\n    static function getFileTypes() {\n        static $filetypes;\n\n        if (!isset($filetypes)) {\n            if (function_exists('apcu_fetch')) {\n                $key = md5(SECRET_SALT . GIT_VERSION . 'filetypes');\n                $filetypes = apcu_fetch($key);\n            }\n            if (!$filetypes)\n                $filetypes = YamlDataParser::load(INCLUDE_DIR . '/config/filetype.yaml');\n            if ($key)\n                apcu_store($key, $filetypes, 7200);\n        }\n        return $filetypes;\n    }\n\n    function getConfigurationOptions() {\n        // Compute size selections\n        $sizes = array('262144' => '\u2014 '.__('Small').' \u2014');\n        $next = 512 << 10;\n        $max = strtoupper(ini_get('upload_max_filesize'));\n        $limit = (int) $max;\n        if (!$limit) $limit = 2 << 20; # 2M default value\n        elseif (strpos($max, 'K')) $limit <<= 10;\n        elseif (strpos($max, 'M')) $limit <<= 20;\n        elseif (strpos($max, 'G')) $limit <<= 30;\n        while ($next <= $limit) {\n            // Select the closest, larger value (in case the\n            // current value is between two)\n            $sizes[$next] = Format::file_size($next);\n            $next *= 2;\n        }\n        // Add extra option if top-limit in php.ini doesn't fall\n        // at a power of two\n        if ($next < $limit * 2)\n            $sizes[$limit] = Format::file_size($limit);\n\n        $types = array();\n        foreach (self::getFileTypes() as $type=>$info) {\n            $types[$type] = $info['description'];\n        }\n\n        global $cfg;\n        return array(\n            'size' => new ChoiceField(array(\n                'label'=>__('Maximum File Size'),\n                'hint'=>__('Choose maximum size of a single file uploaded to this field'),\n                'default'=>$cfg->getMaxFileSize(),\n                'choices'=>$sizes\n            )),\n            'mimetypes' => new ChoiceField(array(\n                'label'=>__('Restrict by File Type'),\n                'hint'=>__('Optionally, choose acceptable file types.'),\n                'required'=>false,\n                'choices'=>$types,\n                'configuration'=>array('multiselect'=>true,'prompt'=>__('No restrictions'))\n            )),\n            'extensions' => new TextareaField(array(\n                'label'=>__('Additional File Type Filters'),\n                'hint'=>__('Optionally, enter comma-separated list of additional file types, by extension. (e.g .doc, .pdf).'),\n                'configuration'=>array('html'=>false, 'rows'=>2),\n            )),\n            'max' => new TextboxField(array(\n                'label'=>__('Maximum Files'),\n                'hint'=>__('Users cannot upload more than this many files.'),\n                'default'=>false,\n                'required'=>false,\n                'validator'=>'number',\n                'configuration'=>array('size'=>8, 'length'=>4, 'placeholder'=>__('No limit')),\n            ))\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    /**\n     * Called from the ajax handler for async uploads via web clients.\n     */\n    function ajaxUpload($bypass=false) {\n        $config = $this->getConfiguration();\n\n        $files = AttachmentFile::format($_FILES['upload'],\n            // For numeric fields assume configuration exists\n            !is_numeric($this->get('id')));\n        if (count($files) != 1)\n            Http::response(400, 'Send one file at a time');\n        $file = array_shift($files);\n        $file['name'] = urldecode($file['name']);\n\n        if (!$this->isValidFile($file))\n            Http::response(413, 'Invalid File');\n\n        if (!$bypass && !$this->isValidFileType($file['name'], $file['type']))\n            Http::response(415, 'File type is not allowed');\n\n        $config = $this->getConfiguration();\n        if (!$bypass && $file['size'] > $config['size'])\n            Http::response(413, 'File is too large');\n\n        if (!($F = AttachmentFile::upload($file)))\n            Http::response(500, 'Unable to store file: '. $file['error']);\n\n        $id = $F->getId();\n\n        // This file is allowed for attachment in this session\n        $_SESSION[':uploadedFiles'][$id] = 1;\n\n        return $id;\n    }\n\n    /**\n     * Called from FileUploadWidget::getValue() when manual upload is used\n     * for browsers which do not support the HTML5 way of uploading async.\n     */\n    function uploadFile($file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!$this->isValidFile($file))\n             throw new FileUploadError(__('Invalid File'));\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        return AttachmentFile::upload($file);\n    }\n\n    /**\n     * Called from API and email routines and such to handle attachments\n     * sent other than via web upload\n     */\n    function uploadAttachment(&$file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (is_callable($file['data']))\n            $file['data'] = $file['data']();\n        if (!isset($file['size'])) {\n            // bootstrap.php include a compat version of mb_strlen\n            if (extension_loaded('mbstring'))\n                $file['size'] = mb_strlen($file['data'], '8bit');\n            else\n                $file['size'] = strlen($file['data']);\n        }\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        if (!$F = AttachmentFile::create($file))\n            throw new FileUploadError(__('Unable to save file'));\n\n        return $F;\n    }\n\n    function isValidFile($file) {\n\n        // Check invalid image hacks\n        if ($file['tmp_name']\n                && stripos($file['type'], 'image/') === 0\n                && function_exists('exif_imagetype')\n                && !exif_imagetype($file['tmp_name']))\n            return false;\n\n        return true;\n    }\n\n    function isValidFileType($name, $type=false) {\n        $config = $this->getConfiguration();\n\n        // Check MIME type - file ext. shouldn't be solely trusted.\n        if ($type && $config['__mimetypes']\n                && in_array($type, $config['__mimetypes'], true))\n            return true;\n\n        // Return true if all file types are allowed (.*)\n        if (!$config['__extensions'] || in_array('.*', $config['__extensions']))\n            return true;\n\n        $allowed = $config['__extensions'];\n        $ext = strtolower(pathinfo($name, PATHINFO_EXTENSION));\n\n        return ($ext && is_array($allowed) && in_array(\".$ext\", $allowed));\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments) && ($a = $this->getAnswer())\n            && ($e = $a->getEntry()) && ($e->get('id'))\n        ) {\n            $this->attachments = GenericAttachments::forIdAndType(\n                // Combine the field and entry ids to make the key\n                sprintf('%u', abs(crc32('E'.$this->get('id').$e->get('id')))),\n                'E');\n        }\n        return $this->attachments ?: array();\n    }\n\n    function setAttachments(GenericAttachments $att) {\n        $this->attachments = $att;\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            foreach ($this->getAttachments() as $a) {\n                if ($a && ($f=$a->getFile()))\n                    $files[] = $f;\n            }\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n\n    function getConfiguration() {\n        $config = parent::getConfiguration();\n        $_types = self::getFileTypes();\n        $mimetypes = array();\n        $extensions = array();\n        if (isset($config['mimetypes']) && is_array($config['mimetypes'])) {\n            foreach ($config['mimetypes'] as $type=>$desc) {\n                foreach ($_types[$type]['types'] as $mime=>$exts) {\n                    $mimetypes[$mime] = true;\n                    if (is_array($exts))\n                        foreach ($exts as $ext)\n                            $extensions['.'.$ext] = true;\n                }\n            }\n        }\n        if (strpos($config['extensions'], '.*') !== false)\n            $config['extensions'] = '';\n\n        if (is_string($config['extensions'])) {\n            foreach (preg_split('/\\s+/', str_replace(',',' ', $config['extensions'])) as $ext) {\n                if (!$ext) {\n                    continue;\n                }\n                elseif (strpos($ext, '/')) {\n                    $mimetypes[$ext] = true;\n                }\n                else {\n                    if ($ext[0] != '.')\n                        $ext = '.' . $ext;\n\n                    // Ensure that the extension is lower-cased for comparison latr\n                    $ext = strtolower($ext);\n\n                    // Add this to the MIME types list so it can be exported to\n                    // the @accept attribute\n                    if (!isset($extensions[$ext]))\n                        $mimetypes[$ext] = true;\n\n                    $extensions[$ext] = true;\n                }\n            }\n            $config['__extensions'] = array_keys($extensions);\n        }\n        elseif (is_array($config['extensions'])) {\n            $config['__extensions'] = $config['extensions'];\n        }\n\n        // 'mimetypes' is the array represented from the user interface,\n        // '__mimetypes' is a complete list of supported MIME types.\n        $config['__mimetypes'] = array_keys($mimetypes);\n        return $config;\n    }\n\n    // When the field is saved to database, encode the ID listing as a json\n    // array. Then, inspect the difference between the files actually\n    // attached to this field\n    function to_database($value) {\n        $this->getAttachments();\n        if (isset($this->attachments) && $this->attachments) {\n            $this->attachments->keepOnlyFileIds($value);\n        }\n        return JsonDataEncoder::encode($value);\n    }\n\n    function parse($value) {\n        // Values in the database should be integer file-ids\n        return array_map(function($e) { return (int) $e; },\n            $value ?: array());\n    }\n\n    function to_php($value) {\n        return is_array($value) ? $value : JsonDataParser::decode($value);\n    }\n\n    function display($value) {\n        $links = array();\n        foreach ($this->getAttachments() as $a) {\n            $links[] = sprintf('<a class=\"no-pjax\" href=\"%s\">%s</a>',\n                Format::htmlchars($a->file->getDownloadUrl()),\n                Format::htmlchars($a->getFilename()));\n        }\n        return implode('<br/>', $links);\n    }\n\n    function toString($value) {\n        $files = array();\n        foreach ($this->getFiles() as $f) {\n            $files[] = $f->name;\n        }\n        return implode(', ', $files);\n    }\n\n    function db_cleanup($field=false) {\n        if ($this->getAttachments()) {\n            $this->attachments->deleteAll();\n        }\n    }\n\n    function asVar($value, $id=false) {\n        if (($attachments = $this->getAttachments()))\n            $attachments = $attachments->all();\n\n        return new FileFieldAttachments($attachments ?: array());\n    }\n    function asVarType() {\n        return 'FileFieldAttachments';\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = Format::htmlchars(array_keys($added));\n        $deleted = Format::htmlchars(array_keys($deleted));\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n}\n\nclass FileFieldAttachments {\n    var $attachments;\n\n    function __construct($attachments) {\n        $this->attachments = $attachments;\n    }\n\n    function __toString() {\n        $files = array();\n        foreach ($this->getAttachments() as $a) {\n            $files[] = $a->getFilename();\n        }\n        return implode(', ', $files);\n    }\n\n    function getAttachments() {\n        return $this->attachments ?: array();\n    }\n\n    function getVar($tag) {\n        switch ($tag) {\n        case 'names':\n            return $this->__toString();\n        case 'files':\n            throw new OOBContent(OOBContent::FILES, $this->getAttachments());\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of file names'),\n            'files' => __('Attached files'),\n        );\n    }\n}\n\nclass InlineFormData extends ArrayObject {\n    var $_form;\n\n    function __construct($form, array $data=array()) {\n        parent::__construct($data);\n        $this->_form = $form;\n    }\n\n    function getVar($tag) {\n        foreach ($this->_form->getFields() as $f) {\n            if ($f->get('name') == $tag)\n                return $this[$f->get('id')];\n        }\n    }\n}\n\n\nclass InlineFormField extends FormField {\n    static $widget = 'InlineFormWidget';\n\n    var $_iform = null;\n\n    function validateEntry($value) {\n        if (!$this->getInlineForm()->isValid()) {\n            $this->_errors[] = __('Correct any errors below and try again.');\n        }\n    }\n\n    function parse($value) {\n        // The InlineFieldWidget returns an array of cleaned data\n        return $value;\n    }\n\n    function to_database($value) {\n        return JsonDataEncoder::encode($value);\n    }\n\n    function to_php($value) {\n        $data = JsonDataParser::decode($value);\n        // The InlineFormData helps with the variable replacer API\n        return new InlineFormData($this->getInlineForm(), $data);\n    }\n\n    function display($data) {\n        $form = $this->getInlineForm();\n        ob_start(); ?>\n        <div><?php\n        foreach ($form->getFields() as $field) { ?>\n            <span style=\"display:inline-block;padding:0 5px;vertical-align:top\">\n                <strong><?php echo Format::htmlchars($field->get('label')); ?></strong>\n                <div><?php\n                    $value = $data[$field->get('id')];\n                    echo $field->display($value); ?></div>\n            </span><?php\n        } ?>\n        </div><?php\n        return ob_get_clean();\n    }\n\n    function getInlineForm($data=false) {\n        $form = $this->get('form');\n        if (is_array($form)) {\n            $form = new SimpleForm($form, $data ?: $this->value ?: $this->getSource());\n        }\n        return $form;\n    }\n}\n\nclass InlineDynamicFormField extends FormField {\n    function getInlineForm($data=false) {\n        if (!isset($this->_iform) || $data) {\n            $config = $this->getConfiguration();\n            $this->_iform = DynamicForm::lookup($config['form']);\n            if ($data)\n                $this->_iform = $this->_iform->getForm($data);\n        }\n        return $this->_iform;\n    }\n\n    function getConfigurationOptions() {\n        $forms = DynamicForm::objects()->filter(array('type'=>'G'))\n            ->values_flat('id', 'title');\n        $choices = array();\n        foreach ($forms as $row) {\n            list($id, $title) = $row;\n            $choices[$id] = $title;\n        }\n        return array(\n            'form' => new ChoiceField(array(\n                'id'=>2, 'label'=>'Inline Form', 'required'=>true,\n                'default'=>'', 'choices'=>$choices\n            )),\n        );\n    }\n}\n\nclass InlineFormWidget extends Widget {\n    function render($mode=false) {\n        $form = $this->field->getInlineForm();\n        if (!$form)\n            return;\n        // Handle first-step edits -- load data from $this->value\n        if ($form instanceof DynamicForm && !$form->getSource())\n            $form = $form->getForm($this->value);\n        $inc = ($mode == 'client') ? CLIENTINC_DIR : STAFFINC_DIR;\n        include $inc . 'templates/inline-form.tmpl.php';\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (!$data)\n            return null;\n        $form = $this->field->getInlineForm($data);\n        if (!$form)\n            return null;\n        return $form->getClean();\n    }\n}\n\nclass Widget {\n    static $media = null;\n\n    function __construct($field) {\n        $this->field = $field;\n        $this->name = $field->getFormName();\n        $this->id = '_' . $this->name;\n    }\n\n    function parseValue() {\n        $this->value = $this->getValue();\n        if (!isset($this->value) && is_object($this->field->getAnswer()))\n            $this->value = $this->field->getAnswer()->getValue();\n        if (!isset($this->value) && isset($this->field->value))\n            $this->value = $this->field->value;\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        // Search for HTML form name first\n        if (isset($data[$this->name]))\n            return $data[$this->name];\n        elseif (isset($data[$this->field->get('name')]))\n            return $data[$this->field->get('name')];\n        elseif (isset($data[$this->field->get('id')]))\n            return $data[$this->field->get('id')];\n        return null;\n    }\n\n    /**\n     * getJsValueGetter\n     *\n     * Used with the dependent fields feature, this function should return a\n     * single javascript expression which can be used in a larger expression\n     * (<> == true, where <> is the result of this function). The %s token\n     * will be replaced with a jQuery variable representing this widget.\n     */\n    function getJsValueGetter() {\n        return '%s.val()';\n    }\n}\n\nclass TextboxWidget extends Widget {\n    static $input_type = 'text';\n\n    function render($options=array(), $extraConfig=false) {\n        $config = $this->field->getConfiguration();\n        if (is_array($extraConfig)) {\n            foreach ($extraConfig as $k=>$v)\n                if (!isset($config[$k]) || !$config[$k])\n                    $config[$k] = $v;\n        }\n        if (isset($config['size']))\n            $size = \"size=\\\"{$config['size']}\\\"\";\n        if (isset($config['length']) && $config['length'])\n            $maxlength = \"maxlength=\\\"{$config['length']}\\\"\";\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        if (isset($config['autocomplete']))\n            $autocomplete = 'autocomplete=\"'.($config['autocomplete']?'on':'off').'\"';\n        if (isset($config['autofocus']))\n            $autofocus = 'autofocus';\n        if (isset($config['disabled']))\n            $disabled = 'disabled=\"disabled\"';\n        if (isset($config['translatable']) && $config['translatable'])\n            $translatable = 'data-translate-tag=\"'.$config['translatable'].'\"';\n        $type = static::$input_type;\n        $types = array(\n            'email' => 'email',\n            'phone' => 'tel',\n        );\n        if ($type == 'text' && isset($types[$config['validator']]))\n            $type = $types[$config['validator']];\n        $placeholder = sprintf('placeholder=\"%s\"', $this->field->getLocal('placeholder',\n            $config['placeholder']));\n        ?>\n        <input type=\"<?php echo $type; ?>\"\n            id=\"<?php echo $this->id; ?>\"\n            <?php echo implode(' ', array_filter(array(\n                $size, $maxlength, $classes, $autocomplete, $disabled,\n                $translatable, $placeholder, $autofocus))); ?>\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value); ?>\"/>\n        <?php\n    }\n}\n\n\nclass TextboxSelectionWidget extends TextboxWidget {\n    //TODO: Support multi-input e.g comma separated inputs\n    function render($options=array(), $extraConfig=array()) {\n\n        if ($this->value && is_array($this->value))\n            $this->value = current($this->value);\n\n        parent::render($options);\n    }\n\n    function getValue() {\n\n        $value = parent::getValue();\n        if ($value && ($item=$this->field->lookupChoice((string) $value)))\n            $value = $item;\n\n        return $value;\n    }\n}\n\nclass PasswordWidget extends TextboxWidget {\n    static $input_type = 'password';\n\n    function render($mode=false, $extra=false) {\n        $extra = array();\n        if ($this->field->value) {\n            $extra['placeholder'] = '\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022';\n        }\n        return parent::render($mode, $extra);\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        // Show empty box unless failed POST\n        if ($_SERVER['REQUEST_METHOD'] != 'POST'\n                || !$this->field->getForm()->isValid())\n            $this->value = '';\n    }\n}\n\nclass TextareaWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $cols = $rows = $maxlength = \"\";\n        $attrs = array();\n        if (isset($config['rows']))\n            $rows = \"rows=\\\"{$config['rows']}\\\"\";\n        if (isset($config['cols']))\n            $cols = \"cols=\\\"{$config['cols']}\\\"\";\n        if (isset($config['length']) && $config['length'])\n            $maxlength = \"maxlength=\\\"{$config['length']}\\\"\";\n        if (isset($config['html']) && $config['html']) {\n            $class = array('richtext', 'no-bar');\n            $class[] = @$config['size'] ?: 'small';\n            $class = sprintf('class=\"%s\"', implode(' ', $class));\n            $this->value = Format::viewableImages($this->value);\n        }\n        if (isset($config['context']))\n            $attrs['data-root-context'] = '\"'.$config['context'].'\"';\n        ?>\n        <span style=\"display:inline-block;width:100%\">\n        <textarea <?php echo $rows.\" \".$cols.\" \".$maxlength.\" \".$class\n                .' '.Format::array_implode('=', ' ', $attrs)\n                .' placeholder=\"'.$config['placeholder'].'\"'; ?>\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"><?php\n                echo Format::htmlchars($this->value);\n            ?></textarea>\n        </span>\n        <?php\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim empty spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass PhoneNumberWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $this->value);\n        ?>\n        <input id=\"<?php echo $this->id; ?>\" type=\"tel\" name=\"<?php echo $this->name; ?>\" value=\"<?php\n        echo Format::htmlchars($phone); ?>\"/><?php\n        // Allow display of extension field even if disabled if the phone\n        // number being edited has an extension\n        if ($ext || $config['ext']) { ?> <?php echo __('Ext'); ?>:\n            <input type=\"text\" name=\"<?php\n            echo $this->name; ?>-ext\" value=\"<?php echo Format::htmlchars($ext);\n                ?>\" size=\"5\"/>\n        <?php }\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        $base = parent::getValue();\n        if ($base === null)\n            return $base;\n        $ext = $data[\"{$this->name}-ext\"];\n        // NOTE: 'X' is significant. Don't change it\n        if ($ext) $ext = 'X'.$ext;\n        return $base . $ext;\n    }\n}\n\nclass ChoicesWidget extends Widget {\n    function render($options=array()) {\n\n        $mode = null;\n        if (isset($options['mode']))\n            $mode = $options['mode'];\n        elseif (isset($this->field->options['render_mode']))\n            $mode = $this->field->options['render_mode'];\n\n        if ($mode == 'view') {\n            if (!($val = (string) $this->field))\n                $val = sprintf('<span class=\"faded\">%s</span>', __('None'));\n\n            echo $val;\n            return;\n        }\n\n        $config = $this->field->getConfiguration();\n        if ($mode == 'search') {\n            $config['multiselect'] = true;\n        }\n\n        // Determine the value for the default (the one listed if nothing is\n        // selected)\n        $choices = $this->field->getChoices(true);\n        $prompt = ($config['prompt'])\n            ? $this->field->getLocal('prompt', $config['prompt'])\n            : __('Select'\n            /* Used as a default prompt for a custom drop-down list */);\n\n        $have_def = false;\n        // We don't consider the 'default' when rendering in 'search' mode\n        if (!strcasecmp($mode, 'search')) {\n            $def_val = $prompt;\n        } else {\n            $def_key = $this->field->get('default');\n            if (!$def_key && $config['default'])\n                $def_key = $config['default'];\n            if (is_array($def_key))\n                $def_key = key($def_key);\n            $have_def = isset($choices[$def_key]);\n            $def_val = $have_def ? $choices[$def_key] : $prompt;\n        }\n\n        $values = $this->value;\n        if (!is_array($values) && isset($values)) {\n            $values = array($values => $this->field->getChoice($values));\n        }\n\n        if (!is_array($values))\n            $values = $have_def ? array($def_key => $choices[$def_key]) : array();\n\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        ?>\n        <select name=\"<?php echo $this->name; ?>[]\"\n            <?php echo implode(' ', array_filter(array($classes))); ?>\n            id=\"<?php echo $this->id; ?>\"\n            <?php if (isset($config['data']))\n              foreach ($config['data'] as $D=>$V)\n                echo ' data-'.$D.'=\"'.Format::htmlchars($V).'\"';\n            ?>\n            data-placeholder=\"<?php echo $prompt; ?>\"\n            <?php if ($config['multiselect'])\n                echo ' multiple=\"multiple\"'; ?>>\n            <?php if (!$have_def && !$config['multiselect']) { ?>\n            <option value=\"<?php echo $def_key; ?>\">&mdash; <?php\n                echo $def_val; ?> &mdash;</option>\n<?php\n        }\n        $this->emitChoices($choices, $values, $have_def, $def_key); ?>\n        </select>\n        <?php\n        if ($config['multiselect']) {\n         ?>\n        <script type=\"text/javascript\">\n        $(function() {\n            $(\"#<?php echo $this->id; ?>\")\n            .select2({'minimumResultsForSearch':10, 'width': '350px'});\n        });\n        </script>\n       <?php\n        }\n    }\n\n    function emitChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        reset($choices);\n        if (is_array(current($choices)) || current($choices) instanceof Traversable)\n            return $this->emitComplexChoices($choices, $values, $have_def, $def_key);\n\n        foreach ($choices as $key => $name) {\n            if (!$have_def && $key == $def_key)\n                continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n        <?php\n        }\n    }\n\n    function emitComplexChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        foreach ($choices as $label => $group) {\n            if (!count($group)) continue;\n            ?>\n            <optgroup label=\"<?php echo $label; ?>\"><?php\n            foreach ($group as $key => $name) {\n                if (!$have_def && $key == $def_key)\n                    continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n<?php       } ?>\n            </optgroup><?php\n        }\n    }\n\n    function getValue() {\n\n        if (!($value = parent::getValue()))\n            return null;\n\n        if ($value && !is_array($value))\n            $value = array($value);\n\n        // Assume multiselect\n        $values = array();\n        $choices = $this->field->getChoices();\n\n        if ($choices && is_array($value)) {\n            // Complex choices\n            if (is_array(current($choices))\n                    || current($choices) instanceof Traversable) {\n                foreach ($choices as $label => $group) {\n                     foreach ($group as $k => $v)\n                        if (in_array($k, $value))\n                            $values[$k] = $v;\n                }\n            } else {\n                foreach($value as $k => $v) {\n                    if (isset($choices[$v]))\n                        $values[$v] = $choices[$v];\n                    elseif (($i=$this->field->lookupChoice($v)))\n                        $values += $i;\n                }\n            }\n        }\n\n        return $values;\n    }\n\n    function getJsValueGetter() {\n        return '%s.find(\":selected\").val()';\n    }\n}\n\n/**\n * A widget for the ChoiceField which will render a list of radio boxes or\n * checkboxes depending on the value of $config['multiple']. Complex choices\n * are also supported and will be rendered as divs.\n */\nclass BoxChoicesWidget extends Widget {\n    function render($options=array()) {\n        $this->emitChoices($this->field->getChoices());\n    }\n\n    function emitChoices($choices) {\n      static $uid = 1;\n\n      if (!isset($this->value))\n          $this->value = $this->field->get('default');\n      $config = $this->field->getConfiguration();\n      $type = $config['multiple'] ? 'checkbox' : 'radio';\n\n      $classes = array('checkbox');\n      if (isset($config['classes']))\n          $classes = array_merge($classes, (array) $config['classes']);\n\n      foreach ($choices as $k => $v) {\n          if (is_array($v)) {\n              $this->renderSectionBreak($k);\n              $this->emitChoices($v);\n              continue;\n          }\n          $id = sprintf(\"%s-%s\", $this->id, $uid++);\n?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\"\n            for=\"<?php echo $id; ?>\">\n        <input id=\"<?php echo $id; ?>\" type=\"<?php echo $type; ?>\"\n            name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value[$k]) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo Format::htmlchars($k); ?>\"/>\n        <?php\n        if ($v) {\n            echo Format::viewableImages($v);\n        } ?>\n        </label>\n<?php   }\n    }\n\n    function renderSectionBreak($label) { ?>\n        <div><?php echo Format::htmlchars($label); ?></div>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return array();\n            return $this->collectValues($data[$this->name], $this->field->getChoices());\n        }\n        return parent::getValue();\n    }\n\n    function collectValues($data, $choices) {\n        $value = array();\n        foreach ($choices as $k => $v) {\n            if (is_array($v))\n                $value = array_merge($value, $this->collectValues($data, $v));\n            elseif (@in_array($k, $data))\n                $value[$k] = $v;\n        }\n        return $value;\n    }\n}\n\n/**\n * An extension to the BoxChoicesWidget which will render complex choices in\n * tabs.\n */\nclass TabbedBoxChoicesWidget extends BoxChoicesWidget {\n    function render($options=array()) {\n        $tabs = array();\n        foreach ($this->field->getChoices() as $label=>$group) {\n            if (is_array($group)) {\n                $tabs[$label] = $group;\n            }\n            else {\n                $this->emitChoices(array($label=>$group));\n            }\n        }\n        if ($tabs) {\n            ?>\n            <div>\n            <ul class=\"alt tabs\">\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $active = $i++ == 0; ?>\n                <li <?php if ($active) echo 'class=\"active\"';\n                  ?>><a href=\"#<?php echo sprintf('%s-%s', $this->name, Format::slugify($label));\n                  ?>\"><?php echo Format::htmlchars($label); ?></a></li>\n<?php       } ?>\n            </ul>\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $first = $i++ == 0; ?>\n                <div class=\"tab_content <?php if (!$first) echo 'hidden'; ?>\" id=\"<?php\n                  echo sprintf('%s-%s', $this->name, Format::slugify($label));?>\">\n<?php           $this->emitChoices($group); ?>\n                </div>\n<?php       } ?>\n            </div>\n<?php   }\n    }\n}\n\n/**\n* TimezoneWidget extends ChoicesWidget to add auto-detect and select2 search\n* options\n*\n**/\nclass TimezoneWidget extends ChoicesWidget {\n\n    function render($options=array()) {\n        parent::render($options);\n        $config = $this->field->getConfiguration();\n        if (@$config['autodetect']) {\n        ?>\n        <button type=\"button\" class=\"action-button\" onclick=\"javascript:\n            $('head').append($('<script>').attr('src', '<?php\n            echo ROOT_PATH; ?>js/jstz.min.js'));\n            var recheck = setInterval(function() {\n                if (window.jstz !== undefined) {\n                    clearInterval(recheck);\n                    var zone = jstz.determine();\n                    $('#<?php echo $this->id; ?>').val(zone.name()).trigger('change');\n\n                }\n            }, 100);\n            return false;\"\n            style=\"vertical-align:middle\">\n            <i class=\"icon-map-marker\"></i> <?php echo __('Auto Detect'); ?>\n        </button>\n        <?php\n        } ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('#<?php echo $this->id; ?>').select2({\n                    allowClear: true,\n                    width: '300px'\n                });\n            });\n        </script>\n      <?php\n    }\n}\n\nclass CheckboxWidget extends Widget {\n    function __construct($field) {\n        parent::__construct($field);\n        $this->name = '_field-checkboxes';\n    }\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value))\n            $this->value = $this->field->get('default');\n        $classes = array('checkbox');\n        if (isset($config['classes']))\n            $classes = array_merge($classes, (array) $config['classes']);\n        ?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\">\n        <input id=\"<?php echo $this->id; ?>\"\n            type=\"checkbox\" name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo $this->field->get('id'); ?>\"/>\n        <?php\n        if ($config['desc']) {\n            echo Format::viewableImages($config['desc']);\n        } ?>\n        </label>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return false;\n            return @in_array($this->field->get('id'), $data[$this->name]);\n        }\n        return parent::getValue();\n    }\n\n    function getJsValueGetter() {\n        return '%s.is(\":checked\")';\n    }\n}\n\nclass DatetimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        global $cfg;\n\n        $config = $this->field->getConfiguration();\n        $timezone = $this->field->getTimezone();\n        if ($this->value) {\n\n            if (is_int($this->value))\n                // Assuming UTC timezone.\n                $datetime = DateTime::createFromFormat('U', $this->value);\n            else {\n                $datetime = Format::parseDateTime($this->value);\n            }\n\n            if ($config['time']) {\n                // Convert to user's timezone for update.\n                $datetime->setTimezone($timezone);\n            }\n\n            $this->value = Format::date($datetime->getTimestamp(), false,\n                    false, $timezone ? $timezone->getName() : 'UTC');\n        } else {\n            $datetime = new DateTime('now');\n            $datetime->setTimezone($timezone);\n        }\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo Format::htmlchars($this->value ?: ''); ?>\" size=\"12\"\n            autocomplete=\"off\" class=\"dp\" />\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').datepicker({\n                    <?php\n                    if ($dt=$this->field->getMinDateTime())\n                        echo sprintf(\"minDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    if ($dt=$this->field->getMaxDateTime())\n                        echo sprintf(\"maxDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    elseif (!$config['future'])\n                        echo \"maxDate: new Date().getTime(),\\n\";\n                    ?>\n                    numberOfMonths: 2,\n                    showButtonPanel: true,\n                    buttonImage: './images/cal.png',\n                    showOn:'both',\n                    dateFormat: $.translate_format('<?php echo $cfg->getDateFormat(true); ?>')\n                });\n            });\n        </script>\n        <?php\n        if ($config['time']) {\n            list($hr, $min) = explode(':', $datetime ?\n                    $datetime->format('H:i') : '');\n            // TODO: Add time picker -- requires time picker or selection with\n            //       Misc::timeDropdown\n            echo '&nbsp;' . Misc::timeDropdown($hr, $min, $this->name . ':time');\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n    }\n\n    /**\n     * Function: getValue\n     * Combines the datepicker date value and the time dropdown selected\n     * time value into a single date and time string value in DateTime::W3C\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            // Effective timezone for the selection\n            $timezone = $this->field->getTimezone();\n            // See if we have time\n            $data = $this->field->getSource();\n            if ($value && isset($data[$this->name . ':time']))\n                $value .=' '.$data[$this->name . ':time'];\n\n            $dt = new DateTime($value, $timezone);\n            $value = $dt->format('Y-m-d H:i:s T');\n        }\n\n        return $value;\n    }\n}\n\nclass SectionBreakWidget extends Widget {\n    function render($options=array()) {\n        ?><div class=\"form-header section-break\"><h3><?php\n        echo Format::htmlchars($this->field->getLocal('label'));\n        ?></h3><em><?php echo Format::display($this->field->getLocal('hint'));\n        ?></em></div>\n        <?php\n    }\n}\n\nclass ThreadEntryWidget extends Widget {\n    function render($options=array()) {\n\n        $config = $this->field->getConfiguration();\n        $object_id = false;\n        if ($options['client']) {\n            $namespace = $options['draft-namespace']\n                ?: 'ticket.client';\n             $object_id = substr(session_id(), -12);\n        } else {\n            $namespace = $options['draft-namespace'] ?: 'ticket.staff';\n        }\n\n        list($draft, $attrs) = Draft::getDraftAndDataAttrs($namespace, $object_id, $this->value);\n        ?>\n        <textarea style=\"width:100%;\" name=\"<?php echo $this->field->get('name'); ?>\"\n            placeholder=\"<?php echo Format::htmlchars($this->field->get('placeholder')); ?>\"\n            class=\"<?php if ($config['html']) echo 'richtext';\n                ?> draft draft-delete\" <?php echo $attrs; ?>\n            cols=\"21\" rows=\"8\" style=\"width:80%;\"><?php echo\n            Format::htmlchars($this->value) ?: $draft; ?></textarea>\n    <?php\n        if (!$config['attachments'])\n            return;\n\n        $attachments = $this->getAttachments($config);\n        print $attachments->render($options);\n        foreach ($attachments->getMedia() as $type=>$urls) {\n            foreach ($urls as $url)\n                Form::emitMedia($url, $type);\n        }\n    }\n\n    function getAttachments($config=false) {\n        if (!$config)\n            $config = $this->field->getConfiguration();\n\n        $field = new FileUploadField(array(\n            'id'=>'attach',\n            'name'=>'attach:' . $this->field->get('id'),\n            'configuration'=>$config)\n        );\n        $field->setForm($this->field->getForm());\n        return $field;\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass FileUploadWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            '/css/filedrop.css',\n        ),\n    );\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $name = $this->field->getFormName();\n        $id = substr(md5(spl_object_hash($this)), 10);\n        $mimetypes = array_filter($config['__mimetypes'],\n            function($t) { return strpos($t, '/') !== false; }\n        );\n        $maxfilesize = ($config['size'] ?: 1048576) / 1048576;\n        $files = array();\n        $new = array_fill_keys($this->field->getClean(), 1);\n        foreach ($this->field->getAttachments() as $att) {\n            unset($new[$att->file_id]);\n            $files[] = array(\n                'id' => $att->file->getId(),\n                'name' => $att->getFilename(),\n                'type' => $att->file->getType(),\n                'size' => $att->file->getSize(),\n                'download_url' => $att->file->getDownloadUrl(),\n            );\n        }\n\n        // Add in newly added files not yet saved (if redisplaying after an\n        // error)\n        if ($new) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($new)))\n                ->all();\n            foreach ($F as $f) {\n                $f->tmp_name = $new[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n        ?><div id=\"<?php echo $id;\n            ?>\" class=\"filedrop\"><div class=\"files\"></div>\n            <div class=\"dropzone\"><i class=\"icon-upload\"></i>\n            <?php echo sprintf(\n                __('Drop files here or %s choose them %s'),\n                '<a href=\"#\" class=\"manual\">', '</a>'); ?>\n        <input type=\"file\" multiple=\"multiple\"\n            id=\"file-<?php echo $id; ?>\" style=\"display:none;\"\n            accept=\"<?php echo implode(',', $config['__mimetypes']); ?>\"/>\n        </div></div>\n        <script type=\"text/javascript\">\n        $(function(){$('#<?php echo $id; ?> .dropzone').filedropbox({\n          url: 'ajax.php/form/upload/<?php echo $this->field->get('id') ?>',\n          link: $('#<?php echo $id; ?>').find('a.manual'),\n          paramname: 'upload[]',\n          fallback_id: 'file-<?php echo $id; ?>',\n          allowedfileextensions: <?php echo JsonDataEncoder::encode(\n            $config['__extensions'] ?: array()); ?>,\n          allowedfiletypes: <?php echo JsonDataEncoder::encode(\n            $mimetypes); ?>,\n          maxfiles: <?php echo $config['max'] ?: 20; ?>,\n          maxfilesize: <?php echo str_replace(',', '.', $maxfilesize); ?>,\n          name: '<?php echo $name; ?>[]',\n          files: <?php echo JsonDataEncoder::encode($files); ?>\n        });});\n        </script>\n<?php\n    }\n\n    function getValue() {\n        $ids = array();\n        // Handle manual uploads (IE<10)\n        if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES[$this->name])) {\n            foreach (AttachmentFile::format($_FILES[$this->name]) as $file) {\n                try {\n                    $F = $this->field->uploadFile($file);\n                    $ids[] = $F->getId();\n                }\n                catch (FileUploadError $ex) {}\n            }\n            return $ids;\n        }\n\n        // Files uploaded here MUST have been uploaded by this user and\n        // identified in the session\n        //\n        // If no value was sent, assume an empty list\n        if (!($files = parent::getValue()))\n            return array();\n\n        $allowed = array();\n        // Files already attached to the field are allowed\n        foreach ($this->field->getFiles() as $F) {\n            // FIXME: This will need special porting in v1.10\n            $allowed[$F->id] = 1;\n        }\n\n        // New files uploaded in this session are allowed\n        if (isset($_SESSION[':uploadedFiles']))\n            $allowed += $_SESSION[':uploadedFiles'];\n\n        // Canned attachments initiated by this session\n        if (isset($_SESSION[':cannedFiles']))\n           $allowed += $_SESSION[':cannedFiles'];\n\n        // Parse the files and make sure it's allowed.\n        foreach ($files as $info) {\n            @list($id, $name) = explode(',', $info, 2);\n            if (!isset($allowed[$id]))\n                continue;\n\n            // Keep the values as the IDs\n            if ($name)\n                $ids[$name] = $id;\n            else\n                $ids[] = $id;\n        }\n\n        return $ids;\n    }\n}\n\nclass FileUploadError extends Exception {}\n\nclass FreeTextField extends FormField {\n    static $widget = 'FreeTextWidget';\n    protected $attachments;\n\n    function getConfigurationOptions() {\n        return array(\n            'content' => new TextareaField(array(\n                'configuration' => array('html' => true, 'size'=>'large'),\n                'label'=>__('Content'), 'required'=>true, 'default'=>'',\n                'hint'=>__('Free text shown in the form, such as a disclaimer'),\n            )),\n            'attachments' => new FileUploadField(array(\n                'id'=>'attach',\n                'label' => __('Attachments'),\n                'name'=>'files',\n                'configuration' => array('extensions'=>'')\n            )),\n        );\n    }\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    /* utils */\n\n    function to_config($config) {\n        if ($config && isset($config['attachments']))\n            $keepers = $config['attachments'] = array_values($config['attachments']);\n        $this->getAttachments()->keepOnlyFileIds($keepers);\n\n        return $config;\n    }\n\n    function db_cleanup($field=false) {\n\n        if ($field && $this->getFiles())\n            $this->getAttachments()->deleteAll();\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments))\n            $this->attachments = GenericAttachments::forIdAndType($this->get('id'), 'I');\n\n        return $this->attachments ?: array();\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            if (($attachments=$this->getAttachments()))\n                foreach ($attachments->all() as $a)\n                    $files[] = $a->getFile();\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n}\n\nclass FreeTextWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $config['classes'] ?: 'thread-body bleed';\n        ?><div class=\"<?php echo $class; ?>\"><?php\n        if ($label = $this->field->getLocal('label')) { ?>\n            <h3><?php\n            echo Format::htmlchars($label);\n        ?></h3><?php\n        }\n        if ($hint = $this->field->getLocal('hint')) { ?>\n        <em><?php\n            echo Format::htmlchars($hint);\n        ?></em><?php\n        } ?>\n        <div><?php\n            echo Format::viewableImages($config['content']); ?></div>\n        </div>\n        <?php\n        if (($attachments = $this->field->getAttachments()) && count($attachments)) { ?>\n            <section class=\"freetext-files\">\n            <div class=\"title\"><?php echo __('Related Resources'); ?></div>\n            <?php foreach ($attachments->all() as $attach) { ?>\n                <div class=\"file\">\n                <a href=\"<?php echo $attach->file->getDownloadUrl(); ?>\"\n                    target=\"_blank\" download=\"<?php echo $attach->file->getDownloadUrl();\n                    ?>\" class=\"truncate no-pjax\">\n                    <i class=\"icon-file\"></i>\n                    <?php echo Format::htmlchars($attach->getFilename()); ?>\n                </a>\n                </div>\n            <?php } ?>\n        </section>\n        <?php }\n    }\n}\n\nclass VisibilityConstraint {\n    static $operators = array(\n        'eq' => 1,\n    );\n\n    const HIDDEN =      0x0001;\n    const VISIBLE =     0x0002;\n\n    var $initial;\n    var $constraint;\n\n    function __construct($constraint, $initial=self::VISIBLE) {\n        $this->constraint = $constraint;\n        $this->initial = $initial;\n    }\n\n    function emitJavascript($field) {\n\n        if (!$this->constraint->constraints)\n            return;\n\n        $func = 'recheck';\n        $form = $field->getForm();\n?>\n    <script type=\"text/javascript\">\n      !(function() {\n        var <?php echo $func; ?> = function() {\n          var target = $('#field<?php echo $field->getWidget()->id; ?>');\n\n<?php   $fields = $this->getAllFields($this->constraint);\n        foreach ($fields as $f) {\n            $field = $form->getField($f);\n            echo sprintf('var %1$s = $(\"#%1$s\");',\n                $field->getWidget()->id);\n        }\n        $expression = $this->compileQ($this->constraint, $form);\n?>\n          if (<?php echo $expression; ?>)\n            target.slideDown('fast', function (){\n                $(this).trigger('show');\n                });\n          else\n            target.slideUp('fast', function (){\n                $(this).trigger('hide');\n                });\n        };\n\n<?php   foreach ($fields as $f) {\n            $w = $form->getField($f)->getWidget();\n?>\n        $('#<?php echo $w->id; ?>').on('change', <?php echo $func; ?>);\n        $('#field<?php echo $w->id; ?>').on('show hide', <?php\n                echo $func; ?>);\n<?php   } ?>\n      })();\n    </script><?php\n    }\n\n    /**\n     * Determines if the field was visible when the form was submitted\n     */\n    function isVisible($field) {\n\n        // Assume initial visibility if constraint is not provided.\n        if (!$this->constraint->constraints)\n            return $this->initial == self::VISIBLE;\n\n\n        return $this->compileQPhp($this->constraint, $field);\n    }\n\n    static function splitFieldAndOp($field) {\n        if (false !== ($last = strrpos($field, '__'))) {\n            $op = substr($field, $last + 2);\n            if (isset(static::$operators[$op]))\n                $field = substr($field, 0, strrpos($field, '__'));\n        }\n        return array($field, $op);\n    }\n\n    function compileQPhp(Q $Q, $field) {\n        if (!($form = $field->getForm())) {\n            return $this->initial == self::VISIBLE;\n        }\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQPhp($value, $field);\n            }\n            else {\n                @list($f, $op) = self::splitFieldAndOp($c);\n                $field = $form->getField($f);\n                $wval = $field->getClean();\n                switch ($op) {\n                case 'eq':\n                case null:\n                    $expr[] = ($wval == $value && $field->isVisible());\n                }\n            }\n        }\n        $glue = $Q->isOred()\n            ? function($a, $b) { return $a || $b; }\n            : function($a, $b) { return $a && $b; };\n        $initial = !$Q->isOred();\n        $expression = array_reduce($expr, $glue, $initial);\n        if ($Q->isNegated)\n            $expression = !$expression;\n        return $expression;\n    }\n\n    function getAllFields(Q $Q, &$fields=array()) {\n        foreach ($Q->constraints as $c=>$value) {\n            if ($c instanceof Q) {\n                $this->getAllFields($c, $fields);\n            }\n            else {\n                @list($f) = self::splitFieldAndOp($c);\n                $fields[$f] = true;\n            }\n        }\n        return array_keys($fields);\n    }\n\n    function compileQ($Q, $form) {\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQ($value, $form);\n            }\n            else {\n                list($f, $op) = self::splitFieldAndOp($c);\n                $widget = $form->getField($f)->getWidget();\n                $id = $widget->id;\n                switch ($op) {\n                case 'eq':\n                case null:\n                    $expr[] = sprintf('(%s.is(\":visible\") && %s)',\n                            $id,\n                            sprintf('%s == %s',\n                                sprintf($widget->getJsValueGetter(), $id),\n                                JsonDataEncoder::encode($value))\n                            );\n                }\n            }\n        }\n        $glue = $Q->isOred() ? ' || ' : ' && ';\n        $expression = implode($glue, $expr);\n        if (count($expr) > 1)\n            $expression = '('.$expression.')';\n        if ($Q->isNegated)\n            $expression = '!'.$expression;\n        return $expression;\n    }\n}\n\nclass AssignmentForm extends Form {\n\n    static $id = 'assign';\n    var $_assignee = null;\n    var $_assignees = null;\n\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'assignee' => new AssigneeField(array(\n                    'id'=>1,\n                    'label' => __('Assignee'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Assignee selection required'),\n                    'configuration' => array(\n                        'criteria' => array(\n                            'available' => true,\n                            ),\n                       ),\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 2,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        if (isset($this->_assignees))\n            $fields['assignee']->setChoices($this->_assignees);\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('assignee')))\n            return false;\n\n        // Do additional assignment validation\n        if (!($assignee = $this->getAssignee())) {\n            $f->addError(__('Unknown assignee'));\n        } elseif ($assignee instanceof Staff) {\n            // Make sure the agent is available\n            if (!$assignee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        } elseif ($assignee instanceof Team) {\n            // Make sure the team is active and has members\n            if (!$assignee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$assignee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setAssignees($assignees) {\n        $this->_assignees = $assignees;\n        $this->_fields = array();\n    }\n\n    function getAssignees() {\n        return $this->_assignees;\n    }\n\n    function getAssignee() {\n\n        if (!isset($this->_assignee))\n            $this->_assignee = $this->getField('assignee')->getClean();\n\n        return $this->_assignee;\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass ClaimForm extends AssignmentForm {\n\n    var $_fields;\n\n    function setFields($fields) {\n        $this->_fields = $fields;\n        parent::setFields($fields);\n    }\n\n    function getFields() {\n\n        if ($this->_fields)\n            return $this->_fields;\n\n        $fields = parent::getFields();\n\n        // Disable && hide assignee field selection\n        if (isset($fields['assignee'])) {\n            $visibility = new VisibilityConstraint(\n                    new Q(array()), VisibilityConstraint::HIDDEN);\n\n            $fields['assignee']->set('visibility', $visibility);\n        }\n\n        // Change coments placeholder to reflect claim\n        if (isset($fields['comments'])) {\n            $fields['comments']->configure('placeholder',\n                    __('Optional reason for the claim'));\n        }\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n}\n\nclass TransferForm extends Form {\n\n    static $id = 'transfer';\n    var $_dept = null;\n\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n    }\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'dept' => new DepartmentField(array(\n                    'id'=>1,\n                    'label' => __('Department'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Department selection is required'),\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 2,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the transfer'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include))\n            return false;\n\n        // Do additional validations\n        if (!($dept = $this->getDept()))\n            $this->getField('dept')->addError(\n                    __('Unknown department'));\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        get_class(), $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n\n    }\n\n    function getDept() {\n\n        if (!isset($this->_dept)) {\n            if (($id = $this->getField('dept')->getClean()))\n                $this->_dept = Dept::lookup($id);\n        }\n\n        return $this->_dept;\n    }\n}\n\n/**\n * FieldUnchanged\n *\n * Thrown in the to_database() method to indicate the value should not be\n * saved in the database (it wasn't changed in the request)\n */\nclass FieldUnchanged extends Exception {}\n?>\n", "<?php\n/*********************************************************************\n    class.user.php\n\n    External end-user identification for osTicket\n\n    Peter Rotich <peter@osticket.com>\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once INCLUDE_DIR . 'class.orm.php';\nrequire_once INCLUDE_DIR . 'class.util.php';\nrequire_once INCLUDE_DIR . 'class.organization.php';\nrequire_once INCLUDE_DIR . 'class.variable.php';\n\nclass UserEmailModel extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_EMAIL_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'user' => array(\n                'constraint' => array('user_id' => 'UserModel.id')\n            )\n        )\n    );\n\n    function __toString() {\n        return (string) $this->address;\n    }\n}\n\nclass UserModel extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_TABLE,\n        'pk' => array('id'),\n        'select_related' => array('default_email', 'org', 'account'),\n        'joins' => array(\n            'emails' => array(\n                'reverse' => 'UserEmailModel.user',\n            ),\n            'tickets' => array(\n                'null' => true,\n                'reverse' => 'TicketModel.user',\n            ),\n            'account' => array(\n                'list' => false,\n                'null' => true,\n                'reverse' => 'ClientAccount.user',\n            ),\n            'org' => array(\n                'null' => true,\n                'constraint' => array('org_id' => 'Organization.id')\n            ),\n            'default_email' => array(\n                'null' => true,\n                'constraint' => array('default_email_id' => 'UserEmailModel.id')\n            ),\n            'cdata' => array(\n                'constraint' => array('id' => 'UserCdata.user_id'),\n                'null' => true,\n            ),\n            'cdata_entry' => array(\n                'constraint' => array(\n                    'id' => 'DynamicFormEntry.object_id',\n                    \"'U'\" => 'DynamicFormEntry.object_type',\n                ),\n                'null' => true,\n            ),\n        )\n    );\n\n    const PRIMARY_ORG_CONTACT   = 0x0001;\n\n    const PERM_CREATE =     'user.create';\n    const PERM_EDIT =       'user.edit';\n    const PERM_DELETE =     'user.delete';\n    const PERM_MANAGE =     'user.manage';\n    const PERM_DIRECTORY =  'user.dir';\n\n    static protected $perms = array(\n        self::PERM_CREATE => array(\n            'title' => /* @trans */ 'Create',\n            'desc' => /* @trans */ 'Ability to add new users',\n            'primary' => true,\n        ),\n        self::PERM_EDIT => array(\n            'title' => /* @trans */ 'Edit',\n            'desc' => /* @trans */ 'Ability to manage user information',\n            'primary' => true,\n        ),\n        self::PERM_DELETE => array(\n            'title' => /* @trans */ 'Delete',\n            'desc' => /* @trans */ 'Ability to delete users',\n            'primary' => true,\n        ),\n        self::PERM_MANAGE => array(\n            'title' => /* @trans */ 'Manage Account',\n            'desc' => /* @trans */ 'Ability to manage active user accounts',\n            'primary' => true,\n        ),\n        self::PERM_DIRECTORY => array(\n            'title' => /* @trans */ 'User Directory',\n            'desc' => /* @trans */ 'Ability to access the user directory',\n            'primary' => true,\n        ),\n    );\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getDefaultEmailAddress() {\n        return $this->getDefaultEmail()->address;\n    }\n\n    function getDefaultEmail() {\n        return $this->default_email;\n    }\n\n    function hasAccount() {\n        return !is_null($this->account);\n    }\n    function getAccount() {\n        return $this->account;\n    }\n\n    function getOrgId() {\n         return $this->get('org_id');\n    }\n\n    function getOrganization() {\n        return $this->org;\n    }\n\n    function setOrganization($org, $save=true) {\n\n        $this->set('org', $org);\n\n        if ($save)\n            $this->save();\n\n        return true;\n    }\n\n    protected function hasStatus($flag) {\n        return $this->get('status') & $flag !== 0;\n    }\n\n    protected function clearStatus($flag) {\n        return $this->set('status', $this->get('status') & ~$flag);\n    }\n\n    protected function setStatus($flag) {\n        return $this->set('status', $this->get('status') | $flag);\n    }\n\n    function isPrimaryContact() {\n        return $this->hasStatus(User::PRIMARY_ORG_CONTACT);\n    }\n\n    function setPrimaryContact($flag) {\n        if ($flag)\n            $this->setStatus(User::PRIMARY_ORG_CONTACT);\n        else\n            $this->clearStatus(User::PRIMARY_ORG_CONTACT);\n    }\n\n    static function getPermissions() {\n        return self::$perms;\n    }\n}\ninclude_once INCLUDE_DIR.'class.role.php';\nRolePermission::register(/* @trans */ 'Users', UserModel::getPermissions());\n\nclass UserCdata extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_CDATA_TABLE,\n        'pk' => array('user_id'),\n        'joins' => array(\n            'user' => array(\n                'constraint' => array('user_id' => 'UserModel.id'),\n            ),\n        ),\n    );\n}\n\nclass User extends UserModel\nimplements TemplateVariable {\n\n    var $_entries;\n    var $_forms;\n\n    static function fromVars($vars, $create=true, $update=false) {\n        // Try and lookup by email address\n        $user = static::lookupByEmail($vars['email']);\n        if (!$user && $create) {\n            $name = $vars['name'];\n            if (is_array($name))\n                $name = implode(', ', $name);\n            elseif (!$name)\n                list($name) = explode('@', $vars['email'], 2);\n\n            $user = new User(array(\n                'name' => Format::htmldecode(Format::sanitize($name, false)),\n                'created' => new SqlFunction('NOW'),\n                'updated' => new SqlFunction('NOW'),\n                //XXX: Do plain create once the cause\n                // of the detached emails is fixed.\n                'default_email' => UserEmail::ensure($vars['email'])\n            ));\n            // Is there an organization registered for this domain\n            list($mailbox, $domain) = explode('@', $vars['email'], 2);\n            if (isset($vars['org_id']))\n                $user->set('org_id', $vars['org_id']);\n            elseif ($org = Organization::forDomain($domain))\n                $user->setOrganization($org, false);\n\n            try {\n                $user->save(true);\n                $user->emails->add($user->default_email);\n                // Attach initial custom fields\n                $user->addDynamicData($vars);\n            }\n            catch (OrmException $e) {\n                return null;\n            }\n            Signal::send('user.created', $user);\n        }\n        elseif ($update) {\n            $errors = array();\n            $user->updateInfo($vars, $errors, true);\n        }\n\n        return $user;\n    }\n\n    static function fromForm($form, $create=true) {\n        global $thisstaff;\n\n        if(!$form) return null;\n\n        //Validate the form\n        $valid = true;\n        $filter = function($f) use ($thisstaff) {\n            return !isset($thisstaff) || $f->isRequiredForStaff();\n        };\n        if (!$form->isValid($filter))\n            $valid  = false;\n\n        //Make sure the email is not in-use\n        if (($field=$form->getField('email'))\n                && $field->getClean()\n                && User::lookup(array('emails__address'=>$field->getClean()))) {\n            $field->addError(__('Email is assigned to another user'));\n            $valid = false;\n        }\n\n        return $valid ? self::fromVars($form->getClean(), $create) : null;\n    }\n\n    function getEmail() {\n        return new EmailAddress($this->default_email->address);\n    }\n\n    function getAvatar() {\n        global $cfg;\n        $source = $cfg->getClientAvatarSource();\n        return $source->getAvatar($this);\n    }\n\n    function getFullName() {\n        return $this->name;\n    }\n\n    function getPhoneNumber() {\n        foreach ($this->getDynamicData() as $e)\n            if ($a = $e->getAnswer('phone'))\n                return $a;\n    }\n\n    function getName() {\n        if (!$this->name)\n            list($name) = explode('@', $this->getDefaultEmailAddress(), 2);\n        else\n            $name = $this->name;\n        return new UsersName($name);\n    }\n\n    function getUpdateDate() {\n        return $this->updated;\n    }\n\n    function getCreateDate() {\n        return $this->created;\n    }\n\n    function getTimezone() {\n        global $cfg;\n\n        if (($acct = $this->getAccount()) && ($tz = $acct->getTimezone())) {\n            return $tz;\n        }\n        return $cfg->getDefaultTimezone();\n    }\n\n    function addForm($form, $sort=1, $data=null) {\n        $entry = $form->instanciate($sort, $data);\n        $entry->set('object_type', 'U');\n        $entry->set('object_id', $this->getId());\n        $entry->save();\n        return $entry;\n    }\n\n    function getLanguage($flags=false) {\n        if ($acct = $this->getAccount())\n            return $acct->getLanguage($flags);\n    }\n\n    function to_json() {\n\n        $info = array(\n                'id'  => $this->getId(),\n                'name' => Format::htmlchars($this->getName()),\n                'email' => (string) $this->getEmail(),\n                'phone' => (string) $this->getPhoneNumber());\n\n        return JsonDataEncoder::encode($info);\n    }\n\n    function __toString() {\n        return $this->asVar();\n    }\n\n    function asVar() {\n        return (string) $this->getName();\n    }\n\n    function getVar($tag) {\n        $tag = mb_strtolower($tag);\n        foreach ($this->getDynamicData() as $e)\n            if ($a = $e->getAnswer($tag))\n                return $a;\n    }\n\n    static function getVarScope() {\n        $base = array(\n            'email' => array(\n                'class' => 'EmailAddress', 'desc' => __('Default email address')\n            ),\n            'name' => array(\n                'class' => 'PersonsName', 'desc' => 'User name, default format'\n            ),\n            'organization' => array('class' => 'Organization', 'desc' => __('Organization')),\n        );\n        $extra = VariableReplacer::compileFormScope(UserForm::getInstance());\n        return $base + $extra;\n    }\n\n    function addDynamicData($data) {\n        return $this->addForm(UserForm::objects()->one(), 1, $data);\n    }\n\n    function getDynamicData($create=true) {\n        if (!isset($this->_entries)) {\n            $this->_entries = DynamicFormEntry::forObject($this->id, 'U')->all();\n            if (!$this->_entries && $create) {\n                $g = UserForm::getNewInstance();\n                $g->setClientId($this->id);\n                $g->save();\n                $this->_entries[] = $g;\n            }\n        }\n\n        return $this->_entries ?: array();\n    }\n\n    function getFilterData() {\n        $vars = array();\n        foreach ($this->getDynamicData() as $entry) {\n            if ($entry->getDynamicForm()->get('type') != 'U')\n                continue;\n            $vars += $entry->getFilterData();\n            // Add in special `name` and `email` fields\n            foreach (array('name', 'email') as $name) {\n                if ($f = $entry->getField($name))\n                    $vars['field.'.$f->get('id')] =\n                        $name == 'name' ? $this->getName() : $this->getEmail();\n            }\n        }\n        return $vars;\n    }\n\n    function getForms($data=null) {\n\n        if (!isset($this->_forms)) {\n            $this->_forms = array();\n            foreach ($this->getDynamicData() as $entry) {\n                $entry->addMissingFields();\n                if(!$data\n                        && ($form = $entry->getDynamicForm())\n                        && $form->get('type') == 'U' ) {\n                    foreach ($entry->getFields() as $f) {\n                        if ($f->get('name') == 'name')\n                            $f->value = $this->getFullName();\n                        elseif ($f->get('name') == 'email')\n                            $f->value = $this->getEmail();\n                    }\n                }\n\n                $this->_forms[] = $entry;\n            }\n        }\n\n        return $this->_forms;\n    }\n\n    function getAccountStatus() {\n\n        if (!($account=$this->getAccount()))\n            return __('Guest');\n\n        return (string) $account->getStatus();\n    }\n\n    function canSeeOrgTickets() {\n        return $this->org && (\n                $this->org->shareWithEverybody()\n            || ($this->isPrimaryContact() && $this->org->shareWithPrimaryContacts()));\n    }\n\n    function register($vars, &$errors) {\n\n        // user already registered?\n        if ($this->getAccount())\n            return true;\n\n        return UserAccount::register($this, $vars, $errors);\n    }\n\n    static function importCsv($stream, $defaults=array()) {\n        require_once INCLUDE_DIR . 'class.import.php';\n\n        $importer = new CsvImporter($stream);\n        $imported = 0;\n        try {\n            db_autocommit(false);\n            $records = $importer->importCsv(UserForm::getUserForm()->getFields(), $defaults);\n            foreach ($records as $data) {\n                if (!Validator::is_email($data['email']) || empty($data['name']))\n                    throw new ImportError('Both `name` and `email` fields are required');\n                if (!($user = static::fromVars($data, true, true)))\n                    throw new ImportError(sprintf(__('Unable to import user: %s'),\n                        print_r(Format::htmlchars($data), true)));\n                $imported++;\n            }\n            db_autocommit(true);\n        }\n        catch (Exception $ex) {\n            db_rollback();\n            return $ex->getMessage();\n        }\n        return $imported;\n    }\n\n    function importFromPost($stream, $extra=array()) {\n        return User::importCsv($stream, $extra);\n    }\n\n    function updateInfo($vars, &$errors, $staff=false) {\n\n        $valid = true;\n        $forms = $this->getForms($vars);\n        foreach ($forms as $entry) {\n            $entry->setSource($vars);\n            if ($staff && !$entry->isValidForStaff())\n                $valid = false;\n            elseif (!$staff && !$entry->isValidForClient())\n                $valid = false;\n            elseif ($entry->getDynamicForm()->get('type') == 'U'\n                    && ($f=$entry->getField('email'))\n                    &&  $f->getClean()\n                    && ($u=User::lookup(array('emails__address'=>$f->getClean())))\n                    && $u->id != $this->getId()) {\n                $valid = false;\n                $f->addError(__('Email is assigned to another user'));\n            }\n\n            if (!$valid)\n                $errors = array_merge($errors, $entry->errors());\n        }\n\n\n        if (!$valid)\n            return false;\n\n        // Save the entries\n        foreach ($forms as $entry) {\n            if ($entry->getDynamicForm()->get('type') == 'U') {\n                //  Name field\n                if (($name = $entry->getField('name'))) {\n                    $name = $name->getClean();\n                    if (is_array($name))\n                        $name = implode(', ', $name);\n                    $this->name = $name;\n                }\n\n                // Email address field\n                if (($email = $entry->getField('email'))) {\n                    $this->default_email->address = $email->getClean();\n                    $this->default_email->save();\n                }\n            }\n\n            // DynamicFormEntry::save returns the number of answers updated\n            if ($entry->save()) {\n                $this->updated = SqlFunction::NOW();\n            }\n        }\n\n        return $this->save();\n    }\n\n\n    function save($refetch=false) {\n        // Drop commas and reorganize the name without them\n        $parts = array_map('trim', explode(',', $this->name));\n        switch (count($parts)) {\n            case 2:\n                // Assume last, first --or-- last suff., first\n                $this->name = $parts[1].' '.$parts[0];\n                // XXX: Consider last, first suff.\n                break;\n            case 3:\n                // Assume last, first, suffix, write 'first last suffix'\n                $this->name = $parts[1].' '.$parts[0].' '.$parts[2];\n                break;\n        }\n\n        // Handle email addresses -- use the box name\n        if (Validator::is_email($this->name)) {\n            list($box, $domain) = explode('@', $this->name, 2);\n            if (strpos($box, '.') !== false)\n                $this->name = str_replace('.', ' ', $box);\n            else\n                $this->name = $box;\n            $this->name = mb_convert_case($this->name, MB_CASE_TITLE);\n        }\n\n        if (count($this->dirty)) //XXX: doesn't work??\n            $this->set('updated', new SqlFunction('NOW'));\n        return parent::save($refetch);\n    }\n\n    function delete() {\n\n        // Refuse to delete a user with tickets\n        if ($this->tickets->count())\n            return false;\n\n        // Delete account record (if any)\n        if ($this->getAccount())\n            $this->getAccount()->delete();\n\n        // Delete emails.\n        $this->emails->expunge();\n\n        // Drop dynamic data\n        foreach ($this->getDynamicData() as $entry) {\n            $entry->delete();\n        }\n\n        // Delete user\n        return parent::delete();\n    }\n\n    function deleteAllTickets() {\n        $deleted = TicketStatus::lookup(array('state' => 'deleted'));\n        foreach($this->tickets as $ticket) {\n            if (!$T = Ticket::lookup($ticket->getId()))\n                continue;\n            if (!$T->setStatus($deleted))\n                return false;\n        }\n        $this->tickets->reset();\n        return true;\n    }\n\n    static function lookupByEmail($email) {\n        return static::lookup(array('emails__address'=>$email));\n    }\n\n    static function getNameById($id) {\n        if ($user = static::lookup($id))\n            return $user->getName();\n    }\n}\n\nclass EmailAddress\nimplements TemplateVariable {\n    var $address;\n\n    function __construct($address) {\n        $this->address = $address;\n    }\n\n    function __toString() {\n        return (string) $this->address;\n    }\n\n    function getVar($what) {\n        require_once PEAR_DIR . 'Mail/RFC822.php';\n        require_once PEAR_DIR . 'PEAR.php';\n        if (!($mails = Mail_RFC822::parseAddressList($this->address)) || PEAR::isError($mails))\n            return '';\n\n        if (count($mails) > 1)\n            return '';\n\n        $info = $mails[0];\n        switch ($what) {\n        case 'domain':\n            return $info->host;\n        case 'personal':\n            return trim($info->personal, '\"');\n        case 'mailbox':\n            return $info->mailbox;\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'domain' => __('Domain'),\n            'mailbox' => __('Mailbox'),\n            'personal' => __('Personal name'),\n        );\n    }\n}\n\nclass PersonsName\nimplements TemplateVariable {\n    var $format;\n    var $parts;\n    var $name;\n\n    static $formats = array(\n        'first' => array(     /*@trans*/ \"First\", 'getFirst'),\n        'last' => array(      /*@trans*/ \"Last\", 'getLast'),\n        'full' => array(      /*@trans*/ \"First Last\", 'getFull'),\n        'legal' => array(     /*@trans*/ \"First M. Last\", 'getLegal'),\n        'lastfirst' => array( /*@trans*/ \"Last, First\", 'getLastFirst'),\n        'formal' => array(    /*@trans*/ \"Mr. Last\", 'getFormal'),\n        'short' => array(     /*@trans*/ \"First L.\", 'getShort'),\n        'shortformal' => array(/*@trans*/ \"F. Last\", 'getShortFormal'),\n        'complete' => array(  /*@trans*/ \"Mr. First M. Last Sr.\", 'getComplete'),\n        'original' => array(  /*@trans*/ '-- As Entered --', 'getOriginal'),\n    );\n\n    function __construct($name, $format=null) {\n        global $cfg;\n\n        if ($format && isset(static::$formats[$format]))\n            $this->format = $format;\n        else\n            $this->format = 'original';\n\n        if (!is_array($name)) {\n            $this->parts = static::splitName($name);\n            $this->name = $name;\n        }\n        else {\n            $this->parts = $name;\n            $this->name = implode(' ', $name);\n        }\n    }\n\n    function getFirst() {\n        return $this->parts['first'];\n    }\n\n    function getLast() {\n        return $this->parts['last'];\n    }\n\n    function getMiddle() {\n        return $this->parts['middle'];\n    }\n\n    function getMiddleInitial() {\n        return mb_substr($this->parts['middle'],0,1).'.';\n    }\n\n    function getFormal() {\n        return trim($this->parts['salutation'].' '.$this->parts['last']);\n    }\n\n    function getFull() {\n        return trim($this->parts['first'].' '.$this->parts['last']);\n    }\n\n    function getLegal() {\n        $parts = array(\n            $this->parts['first'],\n            mb_substr($this->parts['middle'],0,1),\n            $this->parts['last'],\n        );\n        if ($parts[1]) $parts[1] .= '.';\n        return implode(' ', array_filter($parts));\n    }\n\n    function getComplete() {\n        $parts = array(\n            $this->parts['salutation'],\n            $this->parts['first'],\n            mb_substr($this->parts['middle'],0,1),\n            $this->parts['last'],\n            $this->parts['suffix']\n        );\n        if ($parts[2]) $parts[2] .= '.';\n        return implode(' ', array_filter($parts));\n    }\n\n    function getLastFirst() {\n        $name = $this->parts['last'].', '.$this->parts['first'];\n        if ($this->parts['suffix'])\n            $name .= ', '.$this->parts['suffix'];\n        return $name;\n    }\n\n    function getShort() {\n        return $this->parts['first'].' '.mb_substr($this->parts['last'],0,1).'.';\n    }\n\n    function getShortFormal() {\n        return mb_substr($this->parts['first'],0,1).'. '.$this->parts['last'];\n    }\n\n    function getOriginal() {\n        return $this->name;\n    }\n\n    function getInitials() {\n        $names = array($this->parts['first']);\n        $names = array_merge($names, explode(' ', $this->parts['middle']));\n        $names[] = $this->parts['last'];\n        $initials = '';\n        foreach (array_filter($names) as $n)\n            $initials .= mb_substr($n,0,1);\n        return mb_convert_case($initials, MB_CASE_UPPER);\n    }\n\n    function getName() {\n        return $this;\n    }\n\n    function asVar() {\n        return $this->__toString();\n    }\n\n    static function getVarScope() {\n        $formats = array();\n        foreach (static::$formats as $name=>$info) {\n            if (in_array($name, array('original', 'complete')))\n                continue;\n            $formats[$name] = $info[0];\n        }\n        return $formats;\n    }\n\n    function __toString() {\n\n        @list(, $func) = static::$formats[$this->format];\n        if (!$func) $func = 'getFull';\n\n        return (string) call_user_func(array($this, $func));\n    }\n\n    static function allFormats() {\n        return static::$formats;\n    }\n\n    /**\n     * Thanks, http://stackoverflow.com/a/14420217\n     */\n    static function splitName($name) {\n        $results = array();\n\n        $r = explode(' ', $name);\n        $size = count($r);\n\n        //check if name is bad format (ex: J.Everybody), and fix them\n        if($size==1 && mb_strpos($r[0], '.') !== false)\n        {\n            $r = explode('.', $name);\n            $size = count($r);\n        }\n\n        //check first for period, assume salutation if so\n        if (mb_strpos($r[0], '.') === false)\n        {\n            $results['salutation'] = '';\n            $results['first'] = $r[0];\n        }\n        else\n        {\n            $results['salutation'] = $r[0];\n            $results['first'] = $r[1];\n        }\n\n        //check last for period, assume suffix if so\n        if (mb_strpos($r[$size - 1], '.') === false)\n        {\n            $results['suffix'] = '';\n        }\n        else\n        {\n            $results['suffix'] = $r[$size - 1];\n        }\n\n        //combine remains into last\n        $start = ($results['salutation']) ? 2 : 1;\n        $end = ($results['suffix']) ? $size - 2 : $size - 1;\n\n        $middle = array();\n        for ($i = $start; $i <= $end; $i++)\n        {\n            $middle[] = $r[$i];\n        }\n        if (count($middle) > 1) {\n            $results['last'] = array_pop($middle);\n            $results['middle'] = implode(' ', $middle);\n        }\n        else {\n            $results['last'] = $middle[0];\n            $results['middle'] = '';\n        }\n\n        return $results;\n    }\n\n}\n\nclass AgentsName extends PersonsName {\n    function __construct($name, $format=null) {\n        global $cfg;\n\n        if (!$format && $cfg)\n            $format = $cfg->getAgentNameFormat();\n\n        parent::__construct($name, $format);\n    }\n}\n\nclass UsersName extends PersonsName {\n    function __construct($name, $format=null) {\n        global $cfg;\n        if (!$format && $cfg)\n            $format = $cfg->getClientNameFormat();\n\n        parent::__construct($name, $format);\n    }\n}\n\n\nclass UserEmail extends UserEmailModel {\n    static function ensure($address) {\n        $email = static::lookup(array('address'=>$address));\n        if (!$email) {\n            $email = new static(array('address'=>$address));\n            $email->save();\n        }\n        return $email;\n    }\n}\n\n\nclass UserAccount extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_ACCOUNT_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'user' => array(\n                'null' => false,\n                'constraint' => array('user_id' => 'User.id')\n            ),\n        ),\n    );\n\n    const LANG_MAILOUTS = 1;            // Language preference for mailouts\n\n    var $_status;\n    var $_extra;\n\n    function getStatus() {\n        if (!isset($this->_status))\n            $this->_status = new UserAccountStatus($this->get('status'));\n        return $this->_status;\n    }\n\n    protected function hasStatus($flag) {\n        return $this->getStatus()->check($flag);\n    }\n\n    protected function clearStatus($flag) {\n        return $this->set('status', $this->get('status') & ~$flag);\n    }\n\n    protected function setStatus($flag) {\n        return $this->set('status', $this->get('status') | $flag);\n    }\n\n    function confirm() {\n        $this->setStatus(UserAccountStatus::CONFIRMED);\n        return $this->save();\n    }\n\n    function isConfirmed() {\n        return $this->getStatus()->isConfirmed();\n    }\n\n    function lock() {\n        $this->setStatus(UserAccountStatus::LOCKED);\n        return $this->save();\n    }\n\n    function unlock() {\n        $this->clearStatus(UserAccountStatus::LOCKED);\n        return $this->save();\n    }\n\n    function isLocked() {\n        return $this->getStatus()->isLocked();\n    }\n\n    function forcePasswdReset() {\n        $this->setStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n        return $this->save();\n    }\n\n    function isPasswdResetForced() {\n        return $this->hasStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n    }\n\n    function isPasswdResetEnabled() {\n        return !$this->hasStatus(UserAccountStatus::FORBID_PASSWD_RESET);\n    }\n\n    function getInfo() {\n        return $this->ht;\n    }\n\n    function getId() {\n        return $this->get('id');\n    }\n\n    function getUserId() {\n        return $this->get('user_id');\n    }\n\n    function getUser() {\n        return $this->user;\n    }\n\n    function getExtraAttr($attr=false, $default=null) {\n        if (!isset($this->_extra))\n            $this->_extra = JsonDataParser::decode($this->get('extra', ''));\n\n        return $attr ? (@$this->_extra[$attr] ?: $default) : $this->_extra;\n    }\n\n    function setExtraAttr($attr, $value) {\n        $this->getExtraAttr();\n        $this->_extra[$attr] = $value;\n    }\n\n    /**\n     * Function: getLanguage\n     *\n     * Returns the language preference for the user or false if no\n     * preference is defined. False indicates the browser indicated\n     * preference should be used. For requests apart from browser requests,\n     * the last language preference of the browser is set in the\n     * 'browser_lang' extra attribute upon logins. Send the LANG_MAILOUTS\n     * flag to also consider this saved value. Such is useful when sending\n     * the user a message (such as an email), and the user's browser\n     * preference is not available in the HTTP request.\n     *\n     * Parameters:\n     * $flags - (int) Send UserAccount::LANG_MAILOUTS if the user's\n     *      last-known browser preference should be considered. Normally\n     *      only the user's saved language preference is considered.\n     *\n     * Returns:\n     * Current or last-known language preference or false if no language\n     * preference is currently set or known.\n     */\n    function getLanguage($flags=false) {\n        $lang = $this->get('lang', false);\n        if (!$lang && ($flags & UserAccount::LANG_MAILOUTS))\n            $lang = $this->getExtraAttr('browser_lang', false);\n\n        return $lang;\n    }\n\n    function getTimezone() {\n        return $this->timezone;\n    }\n\n    function save($refetch=false) {\n        // Serialize the extra column on demand\n        if (isset($this->_extra)) {\n            $this->extra = JsonDataEncoder::encode($this->_extra);\n        }\n        return parent::save($refetch);\n    }\n\n    function hasPassword() {\n        return (bool) $this->get('passwd');\n    }\n\n    function sendResetEmail() {\n        return static::sendUnlockEmail('pwreset-client') === true;\n    }\n\n    function sendConfirmEmail() {\n        return static::sendUnlockEmail('registration-client') === true;\n    }\n\n    function setPassword($new) {\n        $this->set('passwd', Passwd::hash($new));\n        // Clean sessions\n        Signal::send('auth.clean', $this->getUser());\n    }\n\n    protected function sendUnlockEmail($template) {\n        global $ost, $cfg;\n\n        $token = Misc::randCode(48); // 290-bits\n\n        $email = $cfg->getDefaultEmail();\n        $content = Page::lookupByType($template);\n\n        if (!$email ||  !$content)\n            return new BaseError(sprintf(_S('%s: Unable to retrieve template'),\n                $template));\n\n        $vars = array(\n            'url' => $ost->getConfig()->getBaseUrl(),\n            'token' => $token,\n            'user' => $this->getUser(),\n            'recipient' => $this->getUser(),\n            'link' => sprintf(\n                \"%s/pwreset.php?token=%s\",\n                $ost->getConfig()->getBaseUrl(),\n                $token),\n        );\n        $vars['reset_link'] = &$vars['link'];\n\n        $info = array('email' => $email, 'vars' => &$vars, 'log'=>true);\n        Signal::send('auth.pwreset.email', $this->getUser(), $info);\n\n        $lang = $this->getLanguage(UserAccount::LANG_MAILOUTS);\n        $msg = $ost->replaceTemplateVariables(array(\n            'subj' => $content->getLocalName($lang),\n            'body' => $content->getLocalBody($lang),\n        ), $vars);\n\n        $_config = new Config('pwreset');\n        $_config->set($vars['token'], 'c'.$this->getUser()->getId());\n\n        $email->send($this->getUser()->getEmail(),\n            Format::striptags($msg['subj']), $msg['body']);\n\n        return true;\n    }\n\n    function __toString() {\n        return (string) $this->getStatus();\n    }\n\n    /*\n     * This assumes the staff is doing the update\n     */\n    function update($vars, &$errors) {\n        global $thisstaff;\n\n\n        if (!$thisstaff) {\n            $errors['err'] = __('Access denied');\n            return false;\n        }\n\n        // TODO: Make sure the username is unique\n\n        // Timezone selection is not required. System default is a valid\n        // fallback\n\n        // Changing password?\n        if ($vars['passwd1'] || $vars['passwd2']) {\n            if (!$vars['passwd1'])\n                $errors['passwd1'] = __('New password is required');\n            elseif ($vars['passwd1'] && strlen($vars['passwd1'])<6)\n                $errors['passwd1'] = __('Must be at least 6 characters');\n            elseif ($vars['passwd1'] && strcmp($vars['passwd1'], $vars['passwd2']))\n                $errors['passwd2'] = __('Passwords do not match');\n        }\n\n        // Make sure the username is not an email.\n        if ($vars['username'] && Validator::is_email($vars['username']))\n            $errors['username'] =\n                __('Users can always sign in with their email address');\n\n        if ($errors) return false;\n\n        $this->set('timezone', $vars['timezone']);\n        $this->set('username', $vars['username']);\n\n        if ($vars['passwd1']) {\n            $this->setPassword($vars['passwd1']);\n            $this->setStatus(UserAccountStatus::CONFIRMED);\n        }\n\n        // Set flags\n        foreach (array(\n                'pwreset-flag' => UserAccountStatus::REQUIRE_PASSWD_RESET,\n                'locked-flag' => UserAccountStatus::LOCKED,\n                'forbid-pwchange-flag' => UserAccountStatus::FORBID_PASSWD_RESET\n        ) as $ck=>$flag) {\n            if ($vars[$ck])\n                $this->setStatus($flag);\n            else\n                $this->clearStatus($flag);\n        }\n\n        return $this->save(true);\n    }\n\n    static function createForUser($user, $defaults=false) {\n        $acct = new static(array('user_id'=>$user->getId()));\n        if ($defaults && is_array($defaults)) {\n            foreach ($defaults as $k => $v)\n                $acct->set($k, $v);\n        }\n        return $acct;\n    }\n\n    static function lookupByUsername($username) {\n        if (strpos($username, '@') !== false)\n            $user = static::lookup(array('user__emails__address'=>$username));\n        else\n            $user = static::lookup(array('username'=>$username));\n\n        return $user;\n    }\n\n    static function register($user, $vars, &$errors) {\n\n        if (!$user || !$vars)\n            return false;\n\n        //Require temp password.\n        if ((!$vars['backend'] || $vars['backend'] != 'client')\n                && !isset($vars['sendemail'])) {\n            if (!$vars['passwd1'])\n                $errors['passwd1'] = 'Temporary password required';\n            elseif ($vars['passwd1'] && strlen($vars['passwd1'])<6)\n                $errors['passwd1'] = 'Must be at least 6 characters';\n            elseif ($vars['passwd1'] && strcmp($vars['passwd1'], $vars['passwd2']))\n                $errors['passwd2'] = 'Passwords do not match';\n        }\n\n        if ($errors) return false;\n\n        $account = new UserAccount(array(\n            'user_id' => $user->getId(),\n            'timezone' => $vars['timezone'],\n            'backend' => $vars['backend'],\n        ));\n\n        if ($vars['username'] && strcasecmp($vars['username'], $user->getEmail()))\n            $account->set('username', $vars['username']);\n\n        if ($vars['passwd1'] && !$vars['sendemail']) {\n            $account->set('passwd', Passwd::hash($vars['passwd1']));\n            $account->setStatus(UserAccountStatus::CONFIRMED);\n            if ($vars['pwreset-flag'])\n                $account->setStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n            if ($vars['forbid-pwreset-flag'])\n                $account->setStatus(UserAccountStatus::FORBID_PASSWD_RESET);\n        }\n        elseif ($vars['backend'] && $vars['backend'] != 'client') {\n            // Auto confirm remote accounts\n            $account->setStatus(UserAccountStatus::CONFIRMED);\n        }\n\n        $account->save(true);\n\n        if (!$account->isConfirmed() && $vars['sendemail'])\n            $account->sendConfirmEmail();\n\n        return $account;\n    }\n\n}\n\nclass UserAccountStatus {\n\n    var $flag;\n\n    const CONFIRMED             = 0x0001;\n    const LOCKED                = 0x0002;\n    const REQUIRE_PASSWD_RESET  = 0x0004;\n    const FORBID_PASSWD_RESET   = 0x0008;\n\n    function __construct($flag) {\n        $this->flag = $flag;\n    }\n\n    function check($flag) {\n        return 0 !== ($this->flag & $flag);\n    }\n\n    function isLocked() {\n        return $this->check(self::LOCKED);\n    }\n\n    function isConfirmed() {\n        return $this->check(self::CONFIRMED);\n    }\n\n    function __toString() {\n\n        if ($this->isLocked())\n            return __('Locked (Administrative)');\n\n        if (!$this->isConfirmed())\n            return __('Locked (Pending Activation)');\n\n        // ... Other flags here (password reset, etc).\n\n        return __('Active (Registered)');\n    }\n}\n\n\n/*\n *  Generic user list.\n */\nclass UserList extends ListObject\nimplements TemplateVariable {\n\n    function __toString() {\n        return $this->getNames();\n    }\n\n    function getNames() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list [] = $user->getName();\n        }\n        return $list ? implode(', ', $list) : '';\n    }\n\n    function getFull() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list[] = sprintf(\"%s <%s>\", $user->getName(), $user->getEmail());\n        }\n\n        return $list ? implode(', ', $list) : '';\n    }\n\n    function getEmails() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list[] = $user->getEmail();\n        }\n        return $list ? implode(', ', $list) : '';\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of names'),\n            'emails' => __('List of email addresses'),\n            'full' => __('List of names and email addresses'),\n        );\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    class.validator.php\n\n    Input validation helper. This class contains collection of functions used for data validation.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass Validator {\n\n    var $input=array();\n    var $fields=array();\n    var $errors=array();\n\n    function __construct($fields=null) {\n        $this->setFields($fields);\n    }\n    function setFields(&$fields){\n\n        if($fields && is_array($fields)):\n            $this->fields=$fields;\n            return (true);\n        endif;\n\n        return (false);\n    }\n\n\n    function validate($source,$userinput=true){\n        $this->errors=array();\n        //Check the input and make sure the fields are specified.\n        if(!$source || !is_array($source))\n            $this->errors['err']=__('Invalid input');\n        elseif(!$this->fields || !is_array($this->fields))\n            $this->errors['err']=__('No fields set up');\n        //Abort on error\n        if($this->errors)\n            return false;\n\n        //if magic quotes are enabled - then try cleaning up inputs before validation...\n        if($userinput && function_exists('get_magic_quotes_gpc') && get_magic_quotes_gpc())\n            $source=Format::strip_slashes($source);\n\n\n        $this->input=$source;\n\n        //Do the do.\n        foreach($this->fields as $k=>$field){\n            if(!$field['required'] && !$this->input[$k]) //NOT required...and no data provided...\n                continue;\n\n            if($field['required'] && !isset($this->input[$k]) || (!$this->input[$k] && $field['type']!='int')){ //Required...and no data provided...\n                $this->errors[$k]=$field['error'];\n                continue;\n            }\n\n            //We don't care about the type.\n            if ($field['type'] == '*') continue;\n\n            //Do the actual validation based on the type.\n            switch(strtolower($field['type'])):\n            case 'integer':\n            case 'int':\n                if(!is_numeric($this->input[$k]))\n                     $this->errors[$k]=$field['error'];\n                elseif ($field['min'] && $this->input[$k] < $field['min'])\n                     $this->errors[$k]=$field['error'];\n                break;\n            case 'double':\n                if(!is_numeric($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'text':\n            case 'string':\n                if(!is_string($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'array':\n                if(!$this->input[$k] || !is_array($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'radio':\n                if(!isset($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'date': //TODO...make sure it is really in GNU date format..\n                if(strtotime($this->input[$k])===false)\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'time': //TODO...make sure it is really in GNU time format..\n                break;\n            case 'phone':\n            case 'fax':\n                if(!self::is_phone($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'email':\n                if(!self::is_email($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'url':\n                if(!self::is_url($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'password':\n                if(strlen($this->input[$k])<5)\n                    $this->errors[$k]=$field['error'].' '.__('(Five characters min)');\n                break;\n            case 'username':\n                $error = '';\n                if (!self::is_username($this->input[$k], $error))\n                    $this->errors[$k]=$field['error'].\": $error\";\n                break;\n            case 'zipcode':\n                if(!is_numeric($this->input[$k]) || (strlen($this->input[$k])!=5))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'cs-domain': // Comma separated list of domains\n                if($values=explode(',', $this->input[$k]))\n                    foreach($values as $v)\n                        if(!preg_match_all(\n                                '/^(https?:\\/\\/)?((\\*\\.|\\w+\\.)?[\\w-]+(\\.[a-zA-Z]+)?(:([0-9]+|\\*))?)+$/',\n                                ltrim($v)))\n                            $this->errors[$k]=$field['error'];\n                break;\n            default://If param type is not set...or handle..error out...\n                $this->errors[$k]=$field['error'].' '.__('(type not set)');\n            endswitch;\n        }\n        return ($this->errors)?(FALSE):(TRUE);\n    }\n\n    function iserror(){\n        return $this->errors?true:false;\n    }\n\n    function errors(){\n        return $this->errors;\n    }\n\n    /*** Functions below can be called directly without class instance.\n         Validator::func(var..);  (nolint) ***/\n    static function is_email($email, $list=false, $verify=false) {\n        require_once PEAR_DIR . 'Mail/RFC822.php';\n        require_once PEAR_DIR . 'PEAR.php';\n        $rfc822 = new Mail_RFC822();\n        if (!($mails = $rfc822->parseAddressList($email)) || PEAR::isError($mails))\n            return false;\n\n        if (!$list && count($mails) > 1)\n            return false;\n\n        foreach ($mails as $m) {\n            if (!$m->mailbox)\n                return false;\n            if ($m->host == 'localhost')\n                return false;\n        }\n\n        // According to RFC2821, the domain (A record) can be treated as an\n        // MX if no MX records exist for the domain. Also, include a\n        // full-stop trailing char so that the default domain of the server\n        // is not added automatically\n        if ($verify and !count(dns_get_record($m->host.'.', DNS_MX)))\n            return 0 < count(dns_get_record($m->host.'.', DNS_A|DNS_AAAA));\n\n        return true;\n    }\n\n    static function is_valid_email($email) {\n        global $cfg;\n        // Default to FALSE for installation\n        return self::is_email($email, false, $cfg && $cfg->verifyEmailAddrs());\n    }\n\n    static function is_phone($phone) {\n        /* We're not really validating the phone number but just making sure it doesn't contain illegal chars and of acceptable len */\n        $stripped=preg_replace(\"(\\(|\\)|\\-|\\.|\\+|[  ]+)\",\"\",$phone);\n        return (!is_numeric($stripped) || ((strlen($stripped)<7) || (strlen($stripped)>16)))?false:true;\n    }\n\n    static function is_url($url) {\n        //XXX: parse_url is not ideal for validating urls but it's ideal for basic checks.\n        return ($url && ($info=parse_url($url)) && $info['host']);\n    }\n\n    static function is_ip($ip) {\n        return filter_var(trim($ip), FILTER_VALIDATE_IP) !== false;\n    }\n\n    static function is_username($username, &$error='') {\n        if (strlen($username)<2)\n            $error = __('Username must have at least two (2) characters');\n        elseif (!preg_match('/^[\\p{L}\\d._-]+$/u', $username))\n            $error = __('Username contains invalid characters');\n        return $error == '';\n    }\n\n\n    /*\n     * check_ip\n     * Checks if an IP (IPv4 or IPv6) address is contained in the list of given IPs or subnets.\n     *\n     * @credit - borrowed from Symfony project\n     *\n     */\n    public static function check_ip($ip, $ips) {\n\n        if (!Validator::is_ip($ip))\n            return false;\n\n        $method = substr_count($ip, ':') > 1 ? 'check_ipv6' : 'check_ipv4';\n        $ips = is_array($ips) ? $ips : array($ips);\n        foreach ($ips as $_ip) {\n            if (self::$method($ip, $_ip)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * check_ipv4\n     * Compares two IPv4 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @credit - borrowed from Symfony project\n     */\n    public static function check_ipv4($ip, $cidr) {\n\n        if (false !== strpos($cidr, '/')) {\n            list($address, $netmask) = explode('/', $cidr, 2);\n\n            if ($netmask === '0')\n                return filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4);\n\n            if ($netmask < 0 || $netmask > 32)\n                return false;\n\n        } else {\n            $address = $cidr;\n            $netmask = 32;\n        }\n\n        return 0 === substr_compare(\n                sprintf('%032b', ip2long($ip)),\n                sprintf('%032b', ip2long($address)),\n                0, $netmask);\n    }\n\n    /**\n     * Compares two IPv6 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @credit - borrowed from Symfony project\n     * @author David Soria Parra <dsp at php dot net>\n     *\n     * @see https://github.com/dsp/v6tools\n     *\n     */\n    public static function check_ipv6($ip, $cidr) {\n\n        if (!((extension_loaded('sockets') && defined('AF_INET6')) || @inet_pton('::1')))\n            return false;\n\n        if (false !== strpos($cidr, '/')) {\n            list($address, $netmask) = explode('/', $cidr, 2);\n            if ($netmask < 1 || $netmask > 128)\n                return false;\n        } else {\n            $address = $cidr;\n            $netmask = 128;\n        }\n\n        $bytesAddr = unpack('n*', @inet_pton($address));\n        $bytesTest = unpack('n*', @inet_pton($ip));\n        if (!$bytesAddr || !$bytesTest)\n            return false;\n\n        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {\n            $left = $netmask - 16 * ($i - 1);\n            $left = ($left <= 16) ? $left : 16;\n            $mask = ~(0xffff >> $left) & 0xffff;\n            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function process($fields,$vars,&$errors){\n\n        $val = new Validator();\n        $val->setFields($fields);\n        if(!$val->validate($vars))\n            $errors=array_merge($errors,$val->errors());\n\n        return (!$errors);\n    }\n}\n?>\n"], "fixing_code": ["<?php\n/*************************************************************************\n    class.export.php\n\n    Exports stuff (details to follow)\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass Export {\n\n    // XXX: This may need to be moved to a print-specific class\n    static $paper_sizes = array(\n        /* @trans */ 'Letter',\n        /* @trans */ 'Legal',\n        'A4',\n        'A3',\n    );\n\n    static function dumpQuery($sql, $headers, $how='csv', $options=array()) {\n        $exporters = array(\n            'csv' => CsvResultsExporter,\n            'json' => JsonResultsExporter\n        );\n        $exp = new $exporters[$how]($sql, $headers, $options);\n        return $exp->dump();\n    }\n\n    # XXX: Think about facilitated exporting. For instance, we might have a\n    #      TicketExporter, which will know how to formulate or lookup a\n    #      format query (SQL), and cooperate with the output process to add\n    #      extra (recursive) information. In this funciton, the top-level\n    #      SQL is exported, but for something like tickets, we will need to\n    #      export attached messages, reponses, and notes, as well as\n    #      attachments associated with each, ...\n    static function dumpTickets($sql, $how='csv') {\n        // Add custom fields to the $sql statement\n        $cdata = $fields = array();\n        foreach (TicketForm::getInstance()->getFields() as $f) {\n            // Ignore core fields\n            if (in_array($f->get('name'), array('priority')))\n                continue;\n            // Ignore non-data fields\n            elseif (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata.'.$name;\n            $fields[$key] = $f;\n            $cdata[$key] = $f->getLocal('label');\n        }\n        // Reset the $sql query\n        $tickets = $sql->models()\n            ->select_related('user', 'user__default_email', 'dept', 'staff',\n                'team', 'staff', 'cdata', 'topic', 'status', 'cdata__:priority')\n            ->options(QuerySet::OPT_NOCACHE)\n            ->annotate(array(\n                'collab_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('collaborators__id'))),\n                'attachment_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->filter(array('entries__attachments__inline' => 0))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('entries__attachments__id'))),\n                'thread_count' => TicketThread::objects()\n                    ->filter(array('ticket__ticket_id' => new SqlField('ticket_id', 1)))\n                    ->exclude(array('entries__flags__hasbit' => ThreadEntry::FLAG_HIDDEN))\n                    ->aggregate(array('count' => SqlAggregate::COUNT('entries__id'))),\n            ));\n\n        // Fetch staff information\n        // FIXME: Adjust Staff model so it doesn't do extra queries\n        foreach (Staff::objects() as $S)\n            $S->get('junk');\n\n        return self::dumpQuery($tickets,\n            array(\n                'number' =>         __('Ticket Number'),\n                'created' =>        __('Date Created'),\n                'cdata.subject' =>  __('Subject'),\n                'user.name' =>      __('From'),\n                'user.default_email.address' => __('From Email'),\n                'cdata.:priority.priority_desc' => __('Priority'),\n                'dept::getLocalName' => __('Department'),\n                'topic::getName' => __('Help Topic'),\n                'source' =>         __('Source'),\n                'status::getName' =>__('Current Status'),\n                'lastupdate' =>     __('Last Updated'),\n                'est_duedate' =>    __('Due Date'),\n                'isoverdue' =>      __('Overdue'),\n                'isanswered' =>     __('Answered'),\n                'staff::getName' => __('Agent Assigned'),\n                'team::getName' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'attachment_count' => __('Attachment Count'),\n            ) + $cdata,\n            $how,\n            array('modify' => function(&$record, $keys) use ($fields) {\n                foreach ($fields as $k=>$f) {\n                    if (($i = array_search($k, $keys)) !== false) {\n                        $record[$i] = $f->export($f->to_php($record[$i]));\n                    }\n                }\n                return $record;\n            })\n            );\n    }\n\n    static  function saveTickets($sql, $filename, $how='csv') {\n        Http::download($filename, \"text/$how\");\n        self::dumpTickets($sql, $how);\n        exit;\n    }\n\n\n    static function dumpTasks($sql, $how='csv') {\n        // Add custom fields to the $sql statement\n        $cdata = $fields = array();\n        foreach (TaskForm::getInstance()->getFields() as $f) {\n            // Ignore non-data fields\n            if (!$f->hasData() || $f->isPresentationOnly())\n                continue;\n\n            $name = $f->get('name') ?: 'field_'.$f->get('id');\n            $key = 'cdata.'.$name;\n            $fields[$key] = $f;\n            $cdata[$key] = $f->getLocal('label');\n        }\n        // Reset the $sql query\n        $tasks = $sql->models()\n            ->select_related('dept', 'staff', 'team', 'cdata')\n            ->annotate(array(\n            'collab_count' => SqlAggregate::COUNT('thread__collaborators'),\n            'attachment_count' => SqlAggregate::COUNT('thread__entries__attachments'),\n            'thread_count' => SqlAggregate::COUNT('thread__entries'),\n        ));\n\n        return self::dumpQuery($tasks,\n            array(\n                'number' =>         __('Task Number'),\n                'created' =>        __('Date Created'),\n                'cdata.title' =>    __('Title'),\n                'dept::getLocalName' => __('Department'),\n                '::getStatus' =>    __('Current Status'),\n                'duedate' =>        __('Due Date'),\n                'staff::getName' => __('Agent Assigned'),\n                'team::getName' =>  __('Team Assigned'),\n                'thread_count' =>   __('Thread Count'),\n                'attachment_count' => __('Attachment Count'),\n            ) + $cdata,\n            $how,\n            array('modify' => function(&$record, $keys) use ($fields) {\n                foreach ($fields as $k=>$f) {\n                    if (($i = array_search($k, $keys)) !== false) {\n                        $record[$i] = $f->export($f->to_php($record[$i]));\n                    }\n                }\n                return $record;\n            })\n            );\n    }\n\n\n    static function saveTasks($sql, $filename, $how='csv') {\n\n        ob_start();\n        self::dumpTasks($sql, $how);\n        $stuff = ob_get_contents();\n        ob_end_clean();\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n    static function saveUsers($sql, $filename, $how='csv') {\n\n        $exclude = array('name', 'email');\n        $form = UserForm::getUserForm();\n        $fields = $form->getExportableFields($exclude, 'cdata.');\n\n        $cdata = array_combine(array_keys($fields),\n                array_values(array_map(\n                        function ($f) { return $f->getLocal('label'); }, $fields)));\n\n        $users = $sql->models()\n            ->select_related('org', 'cdata');\n\n        ob_start();\n        echo self::dumpQuery($users,\n                array(\n                    'name'  =>          __('Name'),\n                    'org' =>   __('Organization'),\n                    '::getEmail' =>          __('Email'),\n                    ) + $cdata,\n                $how,\n                array('modify' => function(&$record, $keys) use ($fields) {\n                    foreach ($fields as $k=>$f) {\n                        if ($f && ($i = array_search($k, $keys)) !== false) {\n                            $record[$i] = $f->export($f->to_php($record[$i]));\n                        }\n                    }\n                    return $record;\n                    })\n                );\n        $stuff = ob_get_contents();\n        ob_end_clean();\n\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n    static function saveOrganizations($sql, $filename, $how='csv') {\n\n        $exclude = array('name');\n        $form = OrganizationForm::getDefaultForm();\n        $fields = $form->getExportableFields($exclude, 'cdata.');\n        $cdata = array_combine(array_keys($fields),\n                array_values(array_map(\n                        function ($f) { return $f->getLocal('label'); }, $fields)));\n\n        $cdata += array(\n                '::getNumUsers' => 'Users',\n                '::getAccountManager' => 'Account Manager',\n                );\n\n        $orgs = $sql->models();\n        ob_start();\n        echo self::dumpQuery($orgs,\n                array(\n                    'name'  =>  'Name',\n                    ) + $cdata,\n                $how,\n                array('modify' => function(&$record, $keys) use ($fields) {\n                    foreach ($fields as $k=>$f) {\n                        if ($f && ($i = array_search($k, $keys)) !== false) {\n                            $record[$i] = $f->export($f->to_php($record[$i]));\n                        }\n                    }\n                    return $record;\n                    })\n                );\n        $stuff = ob_get_contents();\n        ob_end_clean();\n\n        if ($stuff)\n            Http::download($filename, \"text/$how\", $stuff);\n\n        return false;\n    }\n\n}\n\nclass ResultSetExporter {\n    var $output;\n\n    function __construct($sql, $headers, $options=array()) {\n        $this->headers = array_values($headers);\n        // Remove limit and offset\n        $sql->limit(null)->offset(null);\n        # TODO: If $filter, add different LIMIT clause to query\n        $this->options = $options;\n        $this->output = $options['output'] ?: fopen('php://output', 'w');\n\n        $this->headers = array();\n        $this->keys = array();\n        foreach ($headers as $field=>$name) {\n            $this->headers[] = $name;\n            $this->keys[] = $field;\n        }\n        $this->_res = $sql->getIterator();\n        if ($this->_res instanceof IteratorAggregate)\n            $this->_res = $this->_res->getIterator();\n        $this->_res->rewind();\n    }\n\n    function getHeaders() {\n        return $this->headers;\n    }\n\n    function next() {\n        if (!$this->_res->valid())\n            return false;\n\n        $object = $this->_res->current();\n        $this->_res->next();\n\n        $record = array();\n\n        foreach ($this->keys as $field) {\n            list($field, $func) = explode('::', $field);\n            $path = explode('.', $field);\n            $current = $object;\n            // Evaluate dotted ORM path\n            if ($field) {\n                foreach ($path as $P) {\n                    $current = $current->{$P};\n                }\n            }\n            // Evalutate :: function call on target current\n            if ($func && (method_exists($current, $func) || method_exists($current, '__call'))) {\n                $current = $current->{$func}();\n            }\n            $record[] = (string) $current;\n        }\n\n        if (isset($this->options['modify']) && is_callable($this->options['modify']))\n            $record = $this->options['modify']($record, $this->keys);\n\n        return $record;\n    }\n\n    function nextArray() {\n        if (!($row = $this->next()))\n            return false;\n        return array_combine($this->keys, $row);\n    }\n\n    function dump() {\n        # Useful for debug output\n        while ($row=$this->nextArray()) {\n            var_dump($row); //nolint\n        }\n    }\n}\n\nclass CsvResultsExporter extends ResultSetExporter {\n\n    function dump() {\n\n        if (!$this->output)\n             $this->output = fopen('php://output', 'w');\n\n        // Detect delimeter from the current locale settings. For locales\n        // which use comma (,) as the decimal separator, the semicolon (;)\n        // should be used as the field separator\n        $delimiter = ',';\n        if (class_exists('NumberFormatter')) {\n            $nf = NumberFormatter::create(Internationalization::getCurrentLocale(),\n                NumberFormatter::DECIMAL);\n            $s = $nf->getSymbol(NumberFormatter::DECIMAL_SEPARATOR_SYMBOL);\n            if ($s == ',')\n                $delimiter = ';';\n        }\n\n        // Output a UTF-8 BOM (byte order mark)\n        fputs($this->output, chr(0xEF) . chr(0xBB) . chr(0xBF));\n        fputcsv($this->output, $this->getHeaders(), $delimiter);\n        while ($row=$this->next())\n            fputcsv($this->output, array_map(\n                function($v){\n                    if (preg_match('/^[=\\-+@].*/', $v))\n                        return \"'\".$v;\n                    return $v;\n                }, $row),\n            $delimiter);\n\n        fclose($this->output);\n    }\n}\n\nclass JsonResultsExporter extends ResultSetExporter {\n    function dump() {\n        require_once(INCLUDE_DIR.'class.json.php');\n        $exp = new JsonDataEncoder();\n        $rows = array();\n        while ($row=$this->nextArray()) {\n            $rows[] = $row;\n        }\n        echo $exp->encode($rows);\n    }\n}\n\nrequire_once INCLUDE_DIR . 'class.json.php';\nrequire_once INCLUDE_DIR . 'class.migrater.php';\nrequire_once INCLUDE_DIR . 'class.signal.php';\n\ndefine('OSTICKET_BACKUP_SIGNATURE', 'osTicket-Backup');\ndefine('OSTICKET_BACKUP_VERSION', 'B');\n\nclass DatabaseExporter {\n\n    var $stream;\n    var $options;\n    var $tables = array(CONFIG_TABLE, SYSLOG_TABLE, FILE_TABLE,\n        FILE_CHUNK_TABLE, STAFF_TABLE, DEPT_TABLE, TOPIC_TABLE, GROUP_TABLE,\n        STAFF_DEPT_TABLE, TEAM_TABLE, TEAM_MEMBER_TABLE, FAQ_TABLE,\n        FAQ_TOPIC_TABLE, FAQ_CATEGORY_TABLE, DRAFT_TABLE,\n        CANNED_TABLE, TICKET_TABLE, ATTACHMENT_TABLE,\n        THREAD_TABLE, THREAD_ENTRY_TABLE, THREAD_ENTRY_EMAIL_TABLE,\n        LOCK_TABLE, THREAD_EVENT_TABLE, TICKET_PRIORITY_TABLE,\n        EMAIL_TABLE, EMAIL_TEMPLATE_TABLE, EMAIL_TEMPLATE_GRP_TABLE,\n        FILTER_TABLE, FILTER_RULE_TABLE, SLA_TABLE, API_KEY_TABLE,\n        TIMEZONE_TABLE, SESSION_TABLE, PAGE_TABLE,\n        FORM_SEC_TABLE, FORM_FIELD_TABLE, LIST_TABLE, LIST_ITEM_TABLE,\n        FORM_ENTRY_TABLE, FORM_ANSWER_TABLE, USER_TABLE, USER_EMAIL_TABLE,\n        PLUGIN_TABLE, THREAD_COLLABORATOR_TABLE, TRANSLATION_TABLE,\n        USER_ACCOUNT_TABLE, ORGANIZATION_TABLE, NOTE_TABLE\n    );\n\n    function __construct($stream, $options=array()) {\n        $this->stream = $stream;\n        $this->options = $options;\n    }\n\n    function write_block($what) {\n        fwrite($this->stream, JsonDataEncoder::encode($what));\n        fwrite($this->stream, \"\\n\");\n    }\n\n    function dump_header() {\n        $header = array(\n            array(OSTICKET_BACKUP_SIGNATURE, OSTICKET_BACKUP_VERSION),\n            array(\n                'version'=>THIS_VERSION,\n                'table_prefix'=>TABLE_PREFIX,\n                'salt'=>SECRET_SALT,\n                'dbtype'=>DBTYPE,\n                'streams'=>DatabaseMigrater::getUpgradeStreams(\n                    UPGRADE_DIR . 'streams/'),\n            ),\n        );\n        $this->write_block($header);\n    }\n\n    function dump($error_stream) {\n        // Allow plugins to change the tables exported\n        Signal::send('export.tables', $this, $this->tables);\n        $this->dump_header();\n\n        foreach ($this->tables as $t) {\n            if ($error_stream) $error_stream->write(\"$t\\n\");\n\n            // Inspect schema\n            $table = array();\n            $res = db_query(\"select column_name from information_schema.columns\n                where table_schema=DATABASE() and table_name='$t'\");\n            while (list($field) = db_fetch_row($res))\n                $table[] = $field;\n\n            if (!$table) {\n                if ($error_stream) $error_stream->write(\n                    sprintf(__(\"%s: Cannot export table with no fields\\n\"), $t));\n                die();\n            }\n            $this->write_block(\n                array('table', substr($t, strlen(TABLE_PREFIX)), $table));\n\n            db_query(\"select * from $t\");\n\n            // Dump row data\n            while ($row = db_fetch_row($res))\n                $this->write_block($row);\n\n            $this->write_block(array('end-table'));\n        }\n    }\n\n    function transfer($destination, $query, $callback=false, $options=array()) {\n        $header_out = false;\n        $res = db_query($query, true, false);\n        $i = 0;\n        while ($row = db_fetch_array($res)) {\n            if (is_callable($callback))\n                $callback($row);\n            if (!$header_out) {\n                $fields = array_keys($row);\n                $this->write_block(\n                    array('table', $destination, $fields, $options));\n                $header_out = true;\n\n            }\n            $this->write_block(array_values($row));\n        }\n        $this->write_block(array('end-table'));\n    }\n\n    function transfer_array($destination, $array, $keys, $options=array()) {\n        $this->write_block(\n            array('table', $destination, $keys, $options));\n        foreach ($array as $row) {\n            $this->write_block(array_values($row));\n        }\n        $this->write_block(array('end-table'));\n    }\n}\n", "<?php\n/*********************************************************************\n    class.forms.php\n\n    osTicket forms framework\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\n/**\n * Form template, used for designing the custom form and for entering custom\n * data for a ticket\n */\nclass Form {\n    static $renderer = 'GridFluidLayout';\n    static $id = 0;\n\n    var $options = array();\n    var $fields = array();\n    var $title = '';\n    var $instructions = '';\n\n    var $validators = array();\n\n    var $_errors = null;\n    var $_source = false;\n\n    function __construct($source=null, $options=array()) {\n\n        $this->options = $options;\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        if (isset($options['id']))\n            $this->id = $options['id'];\n\n        // Use POST data if source was not specified\n        $this->_source = ($source) ? $source : $_POST;\n    }\n\n    function getId() {\n        return static::$id;\n    }\n\n    function data($source) {\n        foreach ($this->fields as $name=>$f)\n            if (isset($source[$name]))\n                $f->value = $source[$name];\n    }\n\n    function setFields($fields) {\n\n        if (!is_array($fields) && !$fields instanceof Traversable)\n            return;\n\n        $this->fields = $fields;\n        foreach ($fields as $k=>$f) {\n            $f->setForm($this);\n            if (!$f->get('name') && $k && !is_numeric($k))\n                $f->set('name', $k);\n        }\n    }\n\n    function getFields() {\n        return $this->fields;\n    }\n\n    function getField($name) {\n        $fields = $this->getFields();\n        foreach($fields as $f)\n            if(!strcasecmp($f->get('name'), $name))\n                return $f;\n        if (isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function hasField($name) {\n        return $this->getField($name);\n    }\n\n    function getTitle() { return $this->title; }\n    function getInstructions() { return $this->instructions; }\n    function getSource() { return $this->_source; }\n    function setSource($source) { $this->_source = $source; }\n\n    /**\n     * Validate the form and indicate if there no errors.\n     *\n     * Parameters:\n     * $filter - (callback) function to receive each field and return\n     *      boolean true if the field's errors are significant\n     */\n    function isValid($include=false) {\n        if (!isset($this->_errors)) {\n            $this->_errors = array();\n            $this->validate($this->getClean());\n            foreach ($this->getFields() as $field)\n                if ($field->errors() && (!$include || $include($field)))\n                    $this->_errors[$field->get('id')] = $field->errors();\n        }\n        return !$this->_errors;\n    }\n\n    function validate($clean_data) {\n        // Validate the whole form so that errors can be added to the\n        // individual fields and collected below.\n        foreach ($this->validators as $V) {\n            $V($this);\n        }\n    }\n\n    function getClean() {\n        if (!$this->_clean) {\n            $this->_clean = array();\n            foreach ($this->getFields() as $key=>$field) {\n                if (!$field->hasData())\n                    continue;\n\n                // Prefer indexing by field.id if indexing numerically\n                if (is_int($key) && $field->get('id'))\n                    $key = $field->get('id');\n                $this->_clean[$key] = $this->_clean[$field->get('name')]\n                    = $field->getClean();\n            }\n            unset($this->_clean[\"\"]);\n        }\n        return $this->_clean;\n    }\n\n    function errors($formOnly=false) {\n        return ($formOnly) ? $this->_errors['form'] : $this->_errors;\n    }\n\n    function addError($message, $index=false) {\n\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors['form'][] = $message;\n    }\n\n    function addErrors($errors=array()) {\n        foreach ($errors as $k => $v) {\n            if (($f=$this->getField($k)))\n                $f->addError($v);\n            else\n                $this->addError($v, $k);\n        }\n    }\n\n    function addValidator($function) {\n        if (!is_callable($function))\n            throw new Exception('Form validator must be callable');\n        $this->validators[] = $function;\n    }\n\n    function render($options=array()) {\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        $form = $this;\n        $template = $options['template'] ?: 'dynamic-form.tmpl.php';\n        if (isset($options['staff']) && $options['staff'])\n            include(STAFFINC_DIR . 'templates/' . $template);\n        else\n            include(CLIENTINC_DIR . 'templates/' . $template);\n        echo $this->getMedia();\n    }\n\n    function getLayout($title=false, $options=array()) {\n        $rc = @$options['renderer'] ?: static::$renderer;\n        return new $rc($title, $options);\n    }\n\n    function asTable($title=false, $options=array()) {\n        return $this->getLayout($title, $options)->asTable($this);\n        // XXX: Media can't go in a table\n        echo $this->getMedia();\n    }\n\n    function getMedia() {\n        static $dedup = array();\n\n        foreach ($this->getFields() as $f) {\n            if (($M = $f->getMedia()) && is_array($M)) {\n                foreach ($M as $type=>$files) {\n                    foreach ($files as $url) {\n                        $key = strtolower($type.$url);\n                        if (isset($dedup[$key]))\n                            continue;\n\n                        self::emitMedia($url, $type);\n\n                        $dedup[$key] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    function emitJavascript($options=array()) {\n\n        // Check if we need to emit javascript\n        if (!($fid=$this->getId()))\n            return;\n        ?>\n        <script type=\"text/javascript\">\n          $(function() {\n            <?php\n            //XXX: We ONLY want to watch field on this form. We'll only\n            // watch form inputs if form_id is specified. Current FORM API\n            // doesn't generate the entire form  (just fields)\n            if ($fid) {\n                ?>\n                $(document).off('change.<?php echo $fid; ?>');\n                $(document).on('change.<?php echo $fid; ?>',\n                    'form#<?php echo $fid; ?> :input',\n                    function() {\n                        //Clear any current errors...\n                        var errors = $('#field'+$(this).attr('id')+'_error');\n                        if (errors.length)\n                            errors.slideUp('fast', function (){\n                                $(this).remove();\n                                });\n                        //TODO: Validation input inplace or via ajax call\n                        // and set any new errors AND visibilty changes\n                    }\n                   );\n            <?php\n            }\n            ?>\n            });\n        </script>\n        <?php\n    }\n\n    static function emitMedia($url, $type) {\n        if ($url[0] == '/')\n            $url = ROOT_PATH . substr($url, 1);\n\n        switch (strtolower($type)) {\n        case 'css': ?>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"<?php echo $url; ?>\"/><?php\n            break;\n        case 'js': ?>\n        <script type=\"text/javascript\" src=\"<?php echo $url; ?>\"></script><?php\n            break;\n        }\n    }\n\n    /**\n     * getState\n     *\n     * Retrieves an array of information which can be passed to the\n     * ::loadState method later to recreate the current state of the form\n     * fields and values.\n     */\n    function getState() {\n        $info = array();\n        foreach ($this->getFields() as $f) {\n            // Skip invisible fields\n            if (!$f->isVisible())\n                continue;\n\n            // Skip fields set to default values\n            $v = $f->getClean();\n            $d = $f->get('default');\n            if ($v == $d)\n                continue;\n\n            // Skip empty values\n            if (!$v)\n                continue;\n\n            $info[$f->get('name') ?: $f->get('id')] = $f->to_database($v);\n        }\n        return $info;\n    }\n\n    /**\n     * loadState\n     *\n     * Reset this form to the state previously recorded by the ::getState()\n     * method\n     */\n    function loadState($state) {\n        foreach ($this->getFields() as $f) {\n            $name = $f->get('name');\n            $f->reset();\n            if (isset($state[$name])) {\n                $f->value = $f->to_php($state[$name]);\n            }\n        }\n    }\n\n    /*\n     * Initialize a generic static form\n     */\n    static function instantiate() {\n        $r = new ReflectionClass(get_called_class());\n        return $r->newInstanceArgs(func_get_args());\n    }\n}\n\n/**\n * SimpleForm\n * Wrapper for inline/static forms.\n *\n */\nclass SimpleForm extends Form {\n    function __construct($fields=array(), $source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($fields);\n    }\n}\n\nclass CustomForm extends SimpleForm {\n\n    function getFields() {\n        global $thisstaff, $thisclient;\n\n        $options = $this->options;\n        $user = $options['user'] ?: $thisstaff ?: $thisclient;\n        $isedit = ($options['mode'] == 'edit');\n        $fields = array();\n        foreach (parent::getFields() as $field) {\n            if ($isedit && !$field->isEditable($user))\n                continue;\n\n            $fields[] = $field;\n        }\n\n        return $fields;\n    }\n}\n\nabstract class AbstractForm extends Form {\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($this->buildFields());\n    }\n    /**\n     * Fetch the fields defined for this form. This method is only called\n     * once.\n     */\n    abstract function buildFields();\n}\n\n/**\n * Container class to represent the connection between the form fields and the\n * rendered state of the form.\n */\ninterface FormRenderer {\n    // Render the form fields into a table\n    function asTable($form);\n    // Render the form fields into divs\n    function asBlock($form);\n}\n\nabstract class FormLayout {\n    static $default_cell_layout = 'Cell';\n\n    var $title;\n    var $options;\n\n    function __construct($title=false, $options=array()) {\n        $this->title = $title;\n        $this->options = $options;\n    }\n\n    function getLayout($field) {\n        $layout = $field->get('layout') ?: static::$default_cell_layout;\n        if (is_string($layout))\n            $layout = new $layout();\n        return $layout;\n    }\n}\n\nclass GridFluidLayout\nextends FormLayout\nimplements FormRenderer {\n    function asTable($form) {\n      ob_start();\n?>\n      <table class=\"<?php echo 'grid form' ?>\">\n          <caption><?php echo Format::htmlchars($this->title ?: $form->getTitle()); ?>\n                  <div><small><?php echo Format::viewableImages($form->getInstructions()); ?></small></div>\n          </caption>\n          <tbody><tr><?php for ($i=0; $i<12; $i++) echo '<td style=\"width:8.3333%\"/>'; ?></tr></tbody>\n<?php\n      $row_size = 12;\n      $cols = $row = 0;\n\n      //Layout and rendering options\n      $options = $this->options;\n\n      foreach ($form->getFields() as $f) {\n          $layout = $this->getLayout($f);\n          $size = $layout->getWidth() ?: 12;\n          if ($offs = $layout->getOffset()) {\n              $size += $offs;\n          }\n          if ($cols < $size || $layout->isBreakForced()) {\n              if ($row) echo '</tr>';\n              echo '<tr>';\n              $cols = $row_size;\n              $row++;\n          }\n          // Render the cell\n          $cols -= $size;\n          $attrs = array('colspan' => $size, 'rowspan' => $layout->getHeight(),\n              'style' => '\"'.$layout->getOption('style').'\"');\n          if ($offs) { ?>\n              <td colspan=\"<?php echo $offs; ?>\"></td> <?php\n          }\n          ?>\n          <td class=\"cell\" <?php echo Format::array_implode('=', ' ', array_filter($attrs)); ?>\n              data-field-id=\"<?php echo $f->get('id'); ?>\">\n              <fieldset class=\"field <?php if (!$f->isVisible()) echo 'hidden'; ?>\"\n                id=\"field<?php echo $f->getWidget()->id; ?>\"\n                data-field-id=\"<?php echo $f->get('id'); ?>\">\n<?php         if ($label = $f->get('label')) { ?>\n              <label class=\"<?php if ($f->isRequired()) echo 'required'; ?>\"\n                  for=\"<?php echo $f->getWidget()->id; ?>\">\n                  <?php echo Format::htmlchars($label); ?>:\n                <?php if ($f->isRequired()) { ?>\n                <span class=\"error\">*</span>\n                <?php\n                }?>\n              </label>\n<?php         }\n              if ($f->get('hint')) { ?>\n                  <div class=\"field-hint-text\">\n                      <?php echo Format::htmlchars($f->get('hint')); ?>\n                  </div>\n<?php         }\n              $f->render($options);\n              if ($f->errors())\n                  foreach ($f->errors() as $e)\n                      echo sprintf('<div class=\"error\">%s</div>', Format::htmlchars($e));\n?>\n              </fieldset>\n          </td>\n      <?php\n      }\n      if ($row)\n        echo  '</tr>';\n\n      echo '</tbody></table>';\n\n      return ob_get_clean();\n    }\n\n    function asBlock($form) {}\n}\n\n/**\n * Basic container for field and form layouts. By default every cell takes\n * a whole output row and does not imply any sort of width.\n */\nclass Cell {\n    function isBreakForced()  { return true; }\n    function getWidth()       { return false; }\n    function getHeight()      { return 1; }\n    function getOffset()      { return 0; }\n    function getOption($prop) { return false; }\n}\n\n/**\n * Fluid grid layout, meaning each cell renders to the right of the previous\n * cell (for left-to-right layouts). A width in columns can be specified for\n * each cell along with an offset from the previous cell. A height of columns\n * along with an optional break is supported.\n */\nclass GridFluidCell\nextends Cell {\n    var $span;\n    var $options;\n\n    function __construct($span, $options=array()) {\n        $this->span = $span;\n        $this->options = $options + array(\n            'rows' => 1,        # rowspan\n            'offset' => 0,      # skip some columns\n            'break' => false,   # start on a new row\n        );\n    }\n\n    function isBreakForced()  { return $this->options['break']; }\n    function getWidth()       { return $this->span; }\n    function getHeight()      { return $this->options['rows']; }\n    function getOffset()      { return $this->options['offset']; }\n    function getOption($prop) { return $this->options[$prop]; }\n}\n\nrequire_once(INCLUDE_DIR . \"class.json.php\");\n\nclass FormField {\n    static $widget = false;\n\n    var $ht = array(\n        'label' => false,\n        'required' => false,\n        'default' => false,\n        'configuration' => array(),\n    );\n\n    var $_form;\n    var $_cform;\n    var $_clean;\n    var $_errors = array();\n    var $_widget;\n    var $answer;\n    var $parent;\n    var $presentation_only = false;\n\n    static $types = array(\n        /* @trans */ 'Basic Fields' => array(\n            'text'  => array(   /* @trans */ 'Short Answer', 'TextboxField'),\n            'memo' => array(    /* @trans */ 'Long Answer', 'TextareaField'),\n            'thread' => array(  /* @trans */ 'Thread Entry', 'ThreadEntryField', false),\n            'datetime' => array(/* @trans */ 'Date and Time', 'DatetimeField'),\n            'timezone' => array(/* @trans */ 'Timezone', 'TimezoneField'),\n            'phone' => array(   /* @trans */ 'Phone Number', 'PhoneField'),\n            'bool' => array(    /* @trans */ 'Checkbox', 'BooleanField'),\n            'choices' => array( /* @trans */ 'Choices', 'ChoiceField'),\n            'files' => array(   /* @trans */ 'File Upload', 'FileUploadField'),\n            'break' => array(   /* @trans */ 'Section Break', 'SectionBreakField'),\n            'info' => array(    /* @trans */ 'Information', 'FreeTextField'),\n        ),\n    );\n    static $more_types = array();\n    static $uid = null;\n\n    function _uid() {\n        return ++self::$uid;\n    }\n\n    function __construct($options=array()) {\n        $this->ht = array_merge($this->ht, $options);\n        if (!isset($this->ht['id']))\n            $this->ht['id'] = self::_uid();\n    }\n\n    function __clone() {\n        $this->_widget = null;\n        $this->ht['id'] = self::_uid();\n    }\n\n    static function addFieldTypes($group, $callable) {\n        static::$more_types[$group][] = $callable;\n    }\n\n    static function allTypes() {\n        if (static::$more_types) {\n            foreach (static::$more_types as $group => $entries)\n                foreach ($entries as $c)\n                    static::$types[$group] = array_merge(\n                            static::$types[$group] ?: array(), call_user_func($c));\n\n            static::$more_types = array();\n        }\n        return static::$types;\n    }\n\n    static function getFieldType($type) {\n        foreach (static::allTypes() as $group=>$types)\n            if (isset($types[$type]))\n                return $types[$type];\n    }\n\n    function get($what, $default=null) {\n        return array_key_exists($what, $this->ht)\n            ? $this->ht[$what]\n            : $default;\n    }\n    function set($field, $value) {\n        $this->ht[$field] = $value;\n    }\n\n    function getId() {\n        return $this->ht['id'];\n    }\n\n    /**\n     * getClean\n     *\n     * Validates and cleans inputs from POST request. This is performed on a\n     * field instance, after a DynamicFormSet / DynamicFormSection is\n     * submitted via POST, in order to kick off parsing and validation of\n     * user-entered data.\n     */\n    function getClean() {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                // XXX: The widget value may be parsed already if this is\n                //      linked to dynamic data via ::getAnswer()\n                ? $this->value : $this->parse($this->getWidget()->value);\n\n            if ($vs = $this->get('cleaners')) {\n                if (is_array($vs)) {\n                    foreach ($vs as $cleaner)\n                        if (is_callable($cleaner))\n                            $this->_clean = call_user_func_array(\n                                    $cleaner, array($this, $this->_clean));\n                }\n                elseif (is_callable($vs))\n                    $this->_clean = call_user_func_array(\n                            $vs, array($this, $this->_clean));\n            }\n\n            if (!isset($this->_clean) && ($d = $this->get('default')))\n                $this->_clean = $d;\n\n            if ($this->isVisible())\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n    function reset() {\n        $this->value = $this->_clean = $this->_widget = null;\n    }\n\n    function getValue() {\n        return $this->getWidget()->getValue();\n    }\n\n    function errors() {\n        return $this->_errors;\n    }\n    function addError($message, $index=false) {\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors[] = $message;\n\n        // Update parent form errors for the field\n        if ($this->_form)\n            $this->_form->addError($this->errors(), $this->get('id'));\n    }\n\n    function isValidEntry() {\n        $this->validateEntry();\n        return count($this->_errors) == 0;\n    }\n\n    /**\n     * validateEntry\n     *\n     * Validates user entry on an instance of the field on a dynamic form.\n     * This is called when an instance of this field (like a TextboxField)\n     * receives data from the user and that value should be validated.\n     *\n     * Parameters:\n     * $value - (string) input from the user\n     */\n    function validateEntry($value) {\n        if (!$value && count($this->_errors))\n            return;\n\n        # Validates a user-input into an instance of this field on a dynamic\n        # form\n        if ($this->get('required') && !$value && $this->hasData())\n            $this->_errors[] = $this->getLabel()\n                ? sprintf(__('%s is a required field'), $this->getLabel())\n                : __('This is a required field');\n\n        # Perform declared validators for the field\n        if ($vs = $this->get('validators')) {\n            if (is_array($vs)) {\n                foreach ($vs as $validator)\n                    if (is_callable($validator))\n                        $validator($this, $value);\n            }\n            elseif (is_callable($vs))\n                $vs($this, $value);\n        }\n    }\n\n    /**\n     * isVisible\n     *\n     * If this field has visibility configuration, then it will parse the\n     * constraints with the visibility configuration to determine if the\n     * field is visible and should be considered for validation\n     */\n    function isVisible() {\n        if ($this->get('visibility') instanceof VisibilityConstraint) {\n            return $this->get('visibility')->isVisible($this);\n        }\n        return true;\n    }\n\n    /**\n     * Check if the user has edit rights\n     *\n     */\n\n    function isEditable($user=null) {\n\n        // Internal editable flag used by internal forms e.g internal lists\n        if (!$user && isset($this->ht['editable']))\n            return $this->ht['editable'];\n\n        if ($user instanceof Staff)\n            $flag = DynamicFormField::FLAG_AGENT_EDIT;\n        else\n            $flag = DynamicFormField::FLAG_CLIENT_EDIT;\n\n        return (($this->get('flags') & $flag) != 0);\n    }\n\n\n    /**\n     * isStorable\n     *\n     * Indicate if this field data is storable locally (default).Some field's data\n     * might beed to be stored elsewhere for optimization reasons at the\n     * application level.\n     *\n     */\n\n    function isStorable() {\n        return (($this->get('flags') & DynamicFormField::FLAG_EXT_STORED) == 0);\n    }\n\n    function isRequired() {\n        return $this->get('required');\n    }\n\n    /**\n     * parse\n     *\n     * Used to transform user-submitted data to a PHP value. This value is\n     * not yet considered valid. The ::validateEntry() method will be called\n     * on the value to determine if the entry is valid. Therefore, if the\n     * data is clearly invalid, return something like NULL that can easily\n     * be deemed invalid in ::validateEntry(), however, can still produce a\n     * useful error message indicating what is wrong with the input.\n     */\n    function parse($value) {\n        return is_string($value) ? trim($value) : $value;\n    }\n\n    /**\n     * to_php\n     *\n     * Transforms the data from the value stored in the database to a PHP\n     * value. The ::to_database() method is used to produce the database\n     * valse, so this method is the compliment to ::to_database().\n     *\n     * Parameters:\n     * $value - (string or null) database representation of the field's\n     *      content\n     */\n    function to_php($value) {\n        return $value;\n    }\n\n    /**\n     * to_config\n     *\n     * Transform the data from the value to config form (as determined by\n     * field). to_php is used for each field returned from\n     * ::getConfigurationOptions(), and when the whole configuration is\n     * built, to_config() is called and receives the config array. The array\n     * should be returned, perhaps with modifications, and will be JSON\n     * encoded and stashed in the database.\n     */\n    function to_config($value) {\n        return $value;\n    }\n\n    /**\n     * to_database\n     *\n     * Determines the value to be stored in the database. The database\n     * backend for all fields is a text field, so this method should return\n     * a text value or NULL to represent the value of the field. The\n     * ::to_php() method will convert this value back to PHP.\n     *\n     * Paremeters:\n     * $value - PHP value of the field's content\n     */\n    function to_database($value) {\n        return $value;\n    }\n\n    /**\n     * toString\n     *\n     * Converts the PHP value created in ::parse() or ::to_php() to a\n     * pretty-printed value to show to the user. This is especially useful\n     * for something like dates which are stored considerably different in\n     * the database from their respective human-friendly versions.\n     * Furthermore, this method allows for internationalization and\n     * localization.\n     *\n     * Parametes:\n     * $value - PHP value of the field's content\n     */\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function __toString() {\n        return $this->toString($this->value);\n    }\n\n    /**\n     * When data for this field is deleted permanently from some storage\n     * backend (like a database), other associated data may need to be\n     * cleaned as well. This hook allows fields to participate when the data\n     * for a field is cleaned up.\n     */\n    function db_cleanup($field=false) {\n    }\n\n    /**\n     * Returns an HTML friendly value for the data in the field.\n     */\n    function display($value) {\n        return Format::htmlchars($this->toString($value));\n    }\n\n    /**\n     * Returns a value suitable for exporting to a foreign system. Mostly\n     * useful for things like dates and phone numbers which should be\n     * formatted using a standard when exported\n     */\n    function export($value) {\n        return $this->toString($value);\n    }\n\n    /**\n     * Fetch a value suitable for embedding the value of this field in an\n     * email template. Reference implementation uses ::to_php();\n     */\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    /**\n     * Fetch the var type used with the email templating system's typeahead\n     * feature. This helps with variable expansion if supported by this\n     * field's ::asVar() method. This method should return a valid classname\n     * which implements the `TemplateVariable` interface.\n     */\n    function asVarType() {\n        return false;\n    }\n\n    /**\n     * Describe the difference between the to two values. Note that the\n     * values should be passed through ::parse() or to_php() before\n     * utilizing this method.\n     */\n    function whatChanged($before, $after) {\n        if ($before)\n            $desc = __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>');\n        else\n            $desc = __('set to <strong>%2$s</strong>');\n        return sprintf($desc, $this->display($before), $this->display($after));\n    }\n\n    /**\n     * Convert the field data to something matchable by filtering. The\n     * primary use of this is for ticket filtering.\n     */\n    function getFilterData() {\n        return $this->toString($this->getClean());\n    }\n\n    /**\n     * Fetches a value that represents this content in a consistent,\n     * searchable format. This is used by the search engine system and\n     * backend.\n     */\n    function searchable($value) {\n        return Format::searchable($this->toString($value));\n    }\n\n    function getKeys($value) {\n        return $this->to_database($value);\n    }\n\n    /**\n     * Fetches a list of options for searching. The values returned from\n     * this method are passed to the widget's `::render()` method so that\n     * the widget can be affected by this setting. For instance, date fields\n     * might have a 'between' search option which should trigger rendering\n     * of two date widgets for search results.\n     */\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('is'),\n            'nequal' =>     __('is not'),\n            'contains' =>   __('contains'),\n            'match' =>      __('matches'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('TextboxField', array()),\n            'nequal' => array('TextboxField', array()),\n            'contains' => array('TextboxField', array()),\n            'match' => array('TextboxField', array(\n                'placeholder' => __('Valid regular expression'),\n                'configuration' => array('size'=>30),\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' ')\n                        && false === @preg_match(\"/$v/\", ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n        );\n    }\n\n    /**\n     * This is used by the searching system to build a query for the search\n     * engine. The function should return a criteria listing to match\n     * content saved by the field by the `::to_database()` function.\n     */\n    function getSearchQ($method, $value, $name=false) {\n        $criteria = array();\n        $Q = new Q();\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n            case 'nset':\n                $Q->negate();\n            case 'set':\n                $criteria[$name . '__isnull'] = false;\n                break;\n\n            case 'nequal':\n                $Q->negate();\n            case 'equal':\n                $criteria[$name] = $value;\n                break;\n\n            case 'contains':\n                $criteria[$name . '__contains'] = $value;\n                break;\n\n            case 'match':\n                $criteria[$name . '__regex'] = $value;\n                break;\n        }\n        return $Q->add($criteria);\n    }\n\n    function getSearchWidget($method) {\n        $methods = $this->getSearchMethodWidgets();\n        $info = $methods[$method];\n        if (is_array($info)) {\n            $class = $info[0];\n            return new $class($info[1]);\n        }\n        return $info;\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'set':\n            return __('%s has a value');\n        case 'nset':\n            return __('%s does not have a value');\n        case 'equal':\n            return __('%s is %s' /* describes an equality */);\n        case 'nequal':\n            return __('%s is not %s' /* describes an inequality */);\n        case 'contains':\n            return __('%s contains \"%s\"');\n        case 'match':\n            return __('%s matches pattern %s');\n        case 'includes':\n            return __('%s in (%s)');\n        case '!includes':\n            return __('%s not in (%s)');\n        }\n    }\n    function describeSearch($method, $value, $name=false) {\n        $desc = $this->describeSearchMethod($method);\n        $value = $this->toString($value);\n        return sprintf($desc, $name, $value);\n    }\n\n    function getLabel() { return $this->get('label'); }\n\n    /**\n     * getImpl\n     *\n     * Magic method that will return an implementation instance of this\n     * field based on the simple text value of the 'type' value of this\n     * field instance. The list of registered fields is determined by the\n     * global get_dynamic_field_types() function. The data from this model\n     * will be used to initialize the returned instance.\n     *\n     * For instance, if the value of this field is 'text', a TextField\n     * instance will be returned.\n     */\n    function getImpl($parent=null) {\n        // Allow registration with ::addFieldTypes and delayed calling\n        $type = static::getFieldType($this->get('type'));\n        $clazz = $type[1];\n        $inst = new $clazz($this->ht);\n        $inst->parent = $parent;\n        $inst->setForm($this->_form);\n        return $inst;\n    }\n\n    function __call($what, $args) {\n        // XXX: Throw exception if $this->parent is not set\n        if (!$this->parent)\n            throw new Exception(sprintf(__('%s: Call to undefined function'),\n                $what));\n        // BEWARE: DynamicFormField has a __call() which will create a new\n        //      FormField instance and invoke __call() on it or bounce\n        //      immediately back\n        return call_user_func_array(\n            array($this->parent, $what), $args);\n    }\n\n    function getAnswer() { return $this->answer; }\n    function setAnswer($ans) { $this->answer = $ans; }\n\n    function setValue($value) {\n        $this->reset();\n        $this->getWidget()->value = $value;\n    }\n\n    function getFormName() {\n        if (is_numeric($this->get('id')))\n            return substr(md5(\n                session_id() . '-field-id-'.$this->get('id')), -16);\n        else\n            return $this->get('name') ?: $this->get('id');\n    }\n\n    function setForm($form) {\n        $this->_form = $form;\n    }\n    function getForm() {\n        return $this->_form;\n    }\n    /**\n     * Returns the data source for this field. If created from a form, the\n     * data source from the form is returned. Otherwise, if the request is a\n     * POST, then _POST is returned.\n     */\n    function getSource() {\n        if ($this->_form)\n            return $this->_form->getSource();\n        elseif ($_SERVER['REQUEST_METHOD'] == 'POST')\n            return $_POST;\n        else\n            return array();\n    }\n\n    function render($options=array()) {\n        $rv = $this->getWidget()->render($options);\n        if ($v = $this->get('visibility')) {\n            $v->emitJavascript($this);\n        }\n        return $rv;\n    }\n\n    function renderExtras($options=array()) {\n        return;\n    }\n\n    function getMedia() {\n        $widget = $this->getWidget();\n        return $widget::$media;\n    }\n\n    function getConfigurationOptions() {\n        return array();\n    }\n\n    /**\n     * getConfiguration\n     *\n     * Loads configuration information from database into hashtable format.\n     * Also, the defaults from ::getConfigurationOptions() are integrated\n     * into the database-backed options, so that if options have not yet\n     * been set or a new option has been added and not saved for this field,\n     * the default value will be reflected in the returned configuration.\n     */\n    function getConfiguration() {\n        if (!$this->_config) {\n            $this->_config = $this->get('configuration');\n            if (is_string($this->_config))\n                $this->_config = JsonDataParser::parse($this->_config);\n            elseif (!$this->_config)\n                $this->_config = array();\n            foreach ($this->getConfigurationOptions() as $name=>$field)\n                if (!isset($this->_config[$name]))\n                    $this->_config[$name] = $field->get('default');\n        }\n        return $this->_config;\n    }\n\n    /**\n     * If the [Config] button should be shown to allow for the configuration\n     * of this field\n     */\n    function isConfigurable() {\n        return true;\n    }\n\n    /**\n     * Field type is changeable in the admin interface\n     */\n    function isChangeable() {\n        return true;\n    }\n\n    /**\n     * Field does not contain data that should be saved to the database. Ie.\n     * non data fields like section headers\n     */\n    function hasData() {\n        return true;\n    }\n\n    /**\n     * Returns true if the field/widget should be rendered as an entire\n     * block in the target form.\n     */\n    function isBlockLevel() {\n        return false;\n    }\n\n    /**\n     * Fields should not be saved with the dynamic data. It is assumed that\n     * some static processing will store the data elsewhere.\n     */\n    function isPresentationOnly() {\n        return $this->presentation_only;\n    }\n\n    /**\n     * Indicates if the field places data in the `value_id` column. This\n     * is currently used by the materialized view system\n     */\n    function hasIdValue() {\n        return false;\n    }\n\n    /**\n     * Indicates if the field has subfields accessible via getSubFields()\n     * method. Useful for filter integration. Should connect with\n     * getFilterData()\n     */\n    function hasSubFields() {\n        return false;\n    }\n    function getSubFields() {\n        return null;\n    }\n\n    /**\n     * Indicates if the field provides for searching for something other\n     * than keywords. For instance, textbox fields can have hits by keyword\n     * searches alone, but selection fields should provide the option to\n     * match a specific value or set of values and therefore need to\n     * participate on any search builder.\n     */\n    function hasSpecialSearch() {\n        return true;\n    }\n\n    function getConfigurationForm($source=null) {\n        if (!$this->_cform) {\n            $type = static::getFieldType($this->get('type'));\n            $clazz = $type[1];\n            $T = new $clazz($this->ht);\n            $config = $this->getConfiguration();\n            $this->_cform = new SimpleForm($T->getConfigurationOptions(), $source);\n            if (!$source) {\n                foreach ($this->_cform->getFields() as $name=>$f) {\n                    if ($config && isset($config[$name]))\n                        $f->value = $config[$name];\n                    elseif ($f->get('default'))\n                        $f->value = $f->get('default');\n                }\n            }\n        }\n        return $this->_cform;\n    }\n\n    function configure($prop, $value) {\n        $this->getConfiguration();\n        $this->_config[$prop] = $value;\n    }\n\n    function getWidget($widgetClass=false) {\n        if (!static::$widget)\n            throw new Exception(__('Widget not defined for this field'));\n        if (!isset($this->_widget)) {\n            $wc = $widgetClass ?: $this->get('widget') ?: static::$widget;\n            $this->_widget = new $wc($this);\n            $this->_widget->parseValue();\n        }\n        return $this->_widget;\n    }\n\n    function getSelectName() {\n        $name = $this->get('name') ?: 'field_'.$this->get('id');\n        if ($this->hasIdValue())\n            $name .= '_id';\n\n        return $name;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('field.%s.%s%s', $subtag, $this->get('id'),\n            $this->get('form_id') ? '' : '*internal*'));\n    }\n    function getLocal($subtag, $default=false) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : ($default ?: $this->get($subtag));\n    }\n}\n\nclass TextboxField extends FormField {\n    static $widget = 'TextboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'size'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Size'), 'required'=>false, 'default'=>16,\n                    'validator' => 'number')),\n            'length' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Max Length'), 'required'=>false, 'default'=>30,\n                    'validator' => 'number')),\n            'validator' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Validator'), 'required'=>false, 'default'=>'',\n                'choices' => array('phone'=>__('Phone Number'),'email'=>__('Email Address'),\n                    'ip'=>__('IP Address'), 'number'=>__('Number'),\n                    'regex'=>__('Custom (Regular Expression)'), ''=>__('None')))),\n            'regex' => new TextboxField(array(\n                'id'=>6, 'label'=>__('Regular Expression'), 'required'=>true,\n                'configuration'=>array('size'=>40, 'length'=>100),\n                'visibility' => new VisibilityConstraint(\n                    new Q(array('validator__eq'=>'regex')),\n                    VisibilityConstraint::HIDDEN\n                ),\n                'cleaners' => function ($self, $value) {\n                    $wrapped = \"/\".$value.\"/iu\";\n                    if (false === @preg_match($value, ' ')\n                            && false !== @preg_match($wrapped, ' ')) {\n                        $value = $wrapped;\n                    }\n                    if ($value == '//iu')\n                        return '';\n\n                    return $value;\n                },\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n            'validator-error' => new TextboxField(array(\n                'id'=>4, 'label'=>__('Validation Error'), 'default'=>'',\n                'configuration'=>array('size'=>40, 'length'=>60,\n                    'translatable'=>$this->getTranslateTag('validator-error')\n                ),\n                'hint'=>__('Message shown to user if the input does not match the validator'))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')\n                ),\n            )),\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' =>       array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n            'email' =>  array(array('Validator', 'is_valid_email'),\n                __('Enter a valid email address')),\n            'phone' =>  array(array('Validator', 'is_phone'),\n                __('Enter a valid phone number')),\n            'ip' =>     array(array('Validator', 'is_ip'),\n                __('Enter a valid IP address')),\n            'number' => array('is_numeric', __('Enter a number')),\n            'regex' => array(\n                function($v) use ($config) {\n                    $regex = $config['regex'];\n                    return @preg_match($regex, $v);\n                }, __('Value does not match required pattern')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        $valid = $this->get('validator');\n        if (!$valid) {\n            $valid = $config['validator'];\n        }\n        if (!$value || !isset($validators[$valid]))\n            return;\n        $func = $validators[$valid];\n        $error = $func[1];\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func($func[0], $value))\n                $this->_errors[] = $error;\n    }\n\n    function parse($value) {\n        return Format::striptags($value);\n    }\n}\n\nclass PasswordField extends TextboxField {\n    static $widget = 'PasswordWidget';\n\n    function parse($value) {\n        // Don't trim the value\n        return $value;\n    }\n\n    function to_database($value) {\n        // If not set in UI, don't save the empty value\n        if (!$value)\n            throw new FieldUnchanged();\n        return Crypto::encrypt($value, SECRET_SALT, 'pwfield');\n    }\n\n    function to_php($value) {\n        return Crypto::decrypt($value, SECRET_SALT, 'pwfield');\n    }\n}\n\nclass TextareaField extends FormField {\n    static $widget = 'TextareaWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'cols'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Width').' '.__('(chars)'), 'required'=>true, 'default'=>40)),\n            'rows'  =>  new TextboxField(array(\n                'id'=>2, 'label'=>__('Height').' '.__('(rows)'), 'required'=>false, 'default'=>4)),\n            'length' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Max Length'), 'required'=>false, 'default'=>0)),\n            'html' => new BooleanField(array(\n                'id'=>4, 'label'=>__('HTML'), 'required'=>false, 'default'=>true,\n                'configuration'=>array('desc'=>__('Allow HTML input in this box')))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        if (!$value)\n            return;\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' =>       array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        if (!($valid = $this->get('validator')) && isset($config['validator']))\n            $valid = $config['validator'];\n        if (!isset($validators[$valid]))\n            return;\n        $func = $validators[$valid];\n        $error = $func[1];\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func($func[0], $value))\n                $this->_errors[] = $error;\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function display($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::safe_html($value);\n        else\n            return nl2br(Format::htmlchars($value));\n    }\n\n    function searchable($value) {\n        $body = new HtmlThreadEntryBody($value);\n        return $body->getSearchable();\n    }\n\n    function export($value) {\n        return (!$value) ? $value : Format::html2text($value);\n    }\n\n    function parse($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::sanitize($value);\n        else\n            return $value;\n    }\n\n}\n\nclass PhoneField extends FormField {\n    static $widget = 'PhoneNumberWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'ext' => new BooleanField(array(\n                'label'=>__('Extension'), 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add a separate field for the extension'),\n                ),\n            )),\n            'digits' => new TextboxField(array(\n                'label'=>__('Minimum length'), 'default'=>7,\n                'hint'=>__('Fewest digits allowed in a valid phone number'),\n                'configuration'=>array('validator'=>'number', 'size'=>5),\n            )),\n            'format' => new ChoiceField(array(\n                'label'=>__('Display format'), 'default'=>'us',\n                'choices'=>array(''=>'-- '.__('Unformatted').' --',\n                    'us'=>__('United States')),\n            )),\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        # Run validator against $this->value for email type\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        if ($phone && (\n                !is_numeric($phone) ||\n                strlen($phone) < $config['digits']))\n            $this->_errors[] = __(\"Enter a valid phone number\");\n        if ($ext && $config['ext']) {\n            if (!is_numeric($ext))\n                $this->_errors[] = __(\"Enter a valid phone extension\");\n            elseif (!$phone)\n                $this->_errors[] = __(\"Enter a phone number for the extension\");\n        }\n    }\n\n    function parse($value) {\n        // NOTE: Value may have a legitimate 'X' to separate the number and\n        // extension parts. Don't remove the 'X'\n        $val = preg_replace('/[^\\dX]/', '', $value);\n        // Pass completely-incorrect string for validation error\n        return $val ?: $value;\n    }\n\n    function toString($value) {\n        $config = $this->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        switch ($config['format']) {\n        case 'us':\n            $phone = Format::phone($phone);\n            break;\n        }\n        if ($ext)\n            $phone.=\" x$ext\";\n        return $phone;\n    }\n}\n\nclass BooleanField extends FormField {\n    static $widget = 'CheckboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'desc' => new TextareaField(array(\n                'id'=>1, 'label'=>__('Description'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown inline with the widget'),\n                'configuration'=>array('rows'=>2)))\n        );\n    }\n\n    function to_database($value) {\n        return ($value) ? '1' : '0';\n    }\n\n    function parse($value) {\n        return $this->to_php($value);\n    }\n    function to_php($value) {\n        return $value ? true : false;\n    }\n\n    function toString($value) {\n        return ($value) ? __('Yes') : __('No');\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('checked'),\n            'nset' =>    __('unchecked'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case 'set':\n            return new Q(array($name => '1'));\n        case 'nset':\n            return new Q(array($name => '0'));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n}\n\nclass ChoiceField extends FormField {\n    static $widget = 'ChoicesWidget';\n    var $_choices;\n\n    function getConfigurationOptions() {\n        return array(\n            'choices'  =>  new TextareaField(array(\n                'id'=>1, 'label'=>__('Choices'), 'required'=>false, 'default'=>'',\n                'hint'=>__('List choices, one per line. To protect against spelling changes, specify key:value names to preserve entries if the list item names change'),\n                'configuration'=>array('html'=>false)\n            )),\n            'default' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'hint'=>__('(Enter a key). Value selected from the list initially'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('prompt'),\n                ),\n            )),\n            'multiselect' => new BooleanField(array(\n                'id'=>1, 'label'=>'Multiselect', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>'Allow multiple selections')\n            )),\n        );\n    }\n\n    function parse($value) {\n        return $this->to_php($value ?: null);\n    }\n\n    function to_database($value) {\n        if (!is_array($value)) {\n            $choices = $this->getChoices();\n            if (isset($choices[$value]))\n                $value = array($value => $choices[$value]);\n        }\n        if (is_array($value))\n            $value = JsonDataEncoder::encode($value);\n\n        return $value;\n    }\n\n    function to_php($value) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        // CDATA table may be built with comma-separated key,value,key,value\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            $choices = $this->getChoices();\n            $vals = explode(',', $value);\n            foreach ($vals as $V) {\n                if (isset($choices[$V]))\n                    $values[$V] = $choices[$V];\n            }\n            if (array_filter($values))\n                $value = $values;\n            elseif($vals)\n                list($value) = $vals;\n\n        }\n        $config = $this->getConfiguration();\n        if (!$config['multiselect'] && is_array($value) && count($value) < 2) {\n            reset($value);\n            $value = key($value);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getKeys($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', array_keys($value));\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $value = $this->to_php($value);\n        return $this->toString($this->getChoice($value));\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = array_map(array($this, 'display'), $added);\n        $deleted = array_map(array($this, 'display'), $deleted);\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n\n    /*\n     Return criteria to which the choice should be filtered by\n     */\n    function getCriteria() {\n        $config = $this->getConfiguration();\n        $criteria = array();\n        if (isset($config['criteria']))\n            $criteria = $config['criteria'];\n\n        return $criteria;\n    }\n\n    function getChoice($value) {\n\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value]))\n            $selection[] = $choices[$value];\n        elseif ($this->get('default'))\n            $selection[] = $choices[$this->get('default')];\n\n        return $selection;\n    }\n\n    function getChoices($verbose=false) {\n        if ($this->_choices === null || $verbose) {\n            // Allow choices to be set in this->ht (for configurationOptions)\n            $this->_choices = $this->get('choices');\n            if (!$this->_choices) {\n                $this->_choices = array();\n                $config = $this->getConfiguration();\n                $choices = explode(\"\\n\", $config['choices']);\n                foreach ($choices as $choice) {\n                    // Allow choices to be key: value\n                    list($key, $val) = explode(':', $choice);\n                    if ($val == null)\n                        $val = $key;\n                    $this->_choices[trim($key)] = trim($val);\n                }\n                // Add old selections if nolonger available\n                // This is necessary so choices made previously can be\n                // retained\n                $values = ($a=$this->getAnswer()) ? $a->getValue() : array();\n                if ($values && is_array($values)) {\n                    foreach ($values as $k => $v) {\n                        if (!isset($this->_choices[$k])) {\n                            if ($verbose) $v .= ' (retired)';\n                            $this->_choices[$k] = $v;\n                        }\n                    }\n                }\n            }\n        }\n        return $this->_choices;\n    }\n\n    function lookupChoice($value) {\n        return null;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>     __('does not have a value'),\n            'includes' =>   __('includes'),\n            '!includes' =>  __('does not include'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n            '!includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case '!includes':\n            return Q::not(array(\"{$name}__in\" => array_keys($value)));\n        case 'includes':\n            return new Q(array(\"{$name}__in\" => array_keys($value)));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'includes':\n            return __('%s includes %s' /* includes -> if a list includes a selection */);\n        case 'includes':\n            return __('%s does not include %s' /* includes -> if a list includes a selection */);\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n}\n\nclass DatetimeField extends FormField {\n    static $widget = 'DatetimePickerWidget';\n\n    var $min = null;\n    var $max = null;\n\n    // Get php DatateTime object of the field  - null if value is empty\n    function getDateTime($value=null) {\n        return Format::parseDateTime($value ?: $this->value);\n    }\n\n    // Get effective timezone for the field\n    function getTimeZone() {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        $timezone = new DateTimeZone($config['timezone'] ?:\n                $cfg->getTimezone());\n\n        return $timezone;\n    }\n\n    function getMinDateTime() {\n\n        if (!isset($this->min)) {\n            $config = $this->getConfiguration();\n            $this->min = $config['min']\n                ? Format::parseDateTime($config['min']) : false;\n        }\n\n        return $this->min;\n    }\n\n    function getMaxDateTime() {\n\n        if (!isset($this->max)) {\n            $config = $this->getConfiguration();\n            $this->max = $config['max']\n                ? Format::parseDateTime($config['max']) : false;\n        }\n\n        return $this->max;\n    }\n\n    function to_database($value) {\n        // Store time in format given by Date Picker (DateTime::W3C)\n        return $value;\n    }\n\n    function to_php($value) {\n\n        if (strtotime($value) <= 0)\n            return 0;\n\n        return $value;\n    }\n\n    function display($value) {\n        global $cfg;\n\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['gmt'])\n            return $this->format((int) $datetime->format('U'));\n\n        // Force timezone if field has one.\n        if ($config['timezone']) {\n            $timezone = new DateTimezone($config['timezone']);\n            $datetime->setTimezone($timezone);\n        }\n\n        $value = $this->format($datetime->format('U'),\n                $datetime->getTimezone()->getName());\n\n        // No need to show timezone\n        if (!$config['time'])\n            return $value;\n\n        // Display is NOT timezone aware show entry's timezone.\n        return sprintf('%s (%s)',\n                $value, $datetime->format('T'));\n    }\n\n    function format($timestamp, $timezone=false) {\n\n        if (!$timestamp || $timestamp <= 0)\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['time'])\n            $formatted = Format::datetime($timestamp, false, $timezone);\n        else\n            $formatted = Format::date($timestamp, false, false, $timezone);\n\n        return $formatted;\n    }\n\n    function toString($value) {\n\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        if ($timestamp <= 0)\n            return '';\n\n        return $this->format($timestamp);\n    }\n\n    function asVar($value, $id=false) {\n        global $cfg;\n\n        if (!$value)\n            return null;\n\n        $datetime = $this->getDateTime($value);\n        $config = $this->getConfiguration();\n        if (!$config['gmt'] || !$config['time'])\n            $timezone  = $datetime->getTimezone()->getName();\n        else\n            $timezone  = false;\n\n        return  new FormattedDate($value, array(\n                    'timezone'  =>  $timezone,\n                    'format'    =>  $config['time'] ? 'long' : 'short'\n                    )\n                );\n    }\n\n    function asVarType() {\n        return 'FormattedDate';\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'time' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Time'), 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>__('Show time selection with date picker')))),\n            'timezone' => new TimezoneField(array(\n                'id'=>2, 'label'=>__('Timezone'), 'required'=>false,\n                'hint'=>__('Timezone of the date time selection'),\n                'configuration' => array('autodetect'=>false,\n                    'prompt' => __(\"User's timezone\")),\n               'visibility' => new VisibilityConstraint(\n                    new Q(array('time__eq'=> true)),\n                    VisibilityConstraint::HIDDEN\n                ),\n                )),\n            'gmt' => new BooleanField(array(\n                'id'=>3, 'label'=>__('Timezone Aware'), 'required'=>false,\n                'configuration'=>array(\n                    'desc'=>__(\"Show date/time relative to user's timezone\")))),\n            'min' => new DatetimeField(array(\n                'id'=>4, 'label'=>__('Earliest'), 'required'=>false,\n                'hint'=>__('Earliest date selectable'))),\n            'max' => new DatetimeField(array(\n                'id'=>5, 'label'=>__('Latest'), 'required'=>false,\n                'default'=>null, 'hint'=>__('Latest date selectable'))),\n            'future' => new BooleanField(array(\n                'id'=>6, 'label'=>__('Allow Future Dates'), 'required'=>false,\n                'default'=>true, 'configuration'=>array(\n                    'desc'=>__('Allow entries into the future' /* Used in the date field */)),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        parent::validateEntry($value);\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return;\n\n        // Parse value to DateTime object\n        $val = Format::parseDateTime($value);\n        // Get configured min/max (if any)\n        $min = $this->getMinDateTime();\n        $max = $this->getMaxDateTime();\n\n        if (!$val) {\n            $this->_errors[] = __('Enter a valid date');\n        } elseif ($min and $val < $min) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is earlier than permitted'),\n                     Format::date($min->getTimestamp(), false, false,\n                         $min->getTimezone()->getName() ?: 'UTC')\n                     );\n        } elseif ($max and $val > $max) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is later than permitted'),\n                    Format::date($max->getTimestamp(), false, false,\n                        $max->getTimezone()->getName() ?: 'UTC')\n                    );\n        }\n    }\n\n    // SearchableField interface ------------------------------\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('on'),\n            'nequal' =>     __('not on'),\n            'before' =>     __('before'),\n            'after' =>      __('after'),\n            'between' =>    __('between'),\n            'ndaysago' =>   __('in the last n days'),\n            'ndays' =>      __('in the next n days'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        $config_notime = $config = $this->getConfiguration();\n        $config_notime['time'] = false;\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'nequal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'before' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'after' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'between' => array('InlineformField', array(\n                'form' => array(\n                    'left' => new DatetimeField(),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'and'))\n                    ),\n                    'right' => new DatetimeField(),\n                ),\n            )),\n            'ndaysago' => array('InlineformField', array(\n                'form' => array(\n                    'until' => new TextboxField(array(\n                        'configuration' => array('validator'=>'number', 'size'=>4))\n                    ),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'days'))\n                    ),\n                ),\n            )),\n            'ndays' => array('InlineformField', array(\n                'form' => array(\n                    'until' => new TextboxField(array(\n                        'configuration' => array('validator'=>'number', 'size'=>4))\n                    ),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => 'days'))\n                    ),\n                ),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $config = $this->getConfiguration();\n        $value = is_int($value)\n            ? DateTime::createFromFormat('U', !$config['gmt'] ? Misc::gmtime($value) : $value) ?: $value\n            : $value;\n        switch ($method) {\n        case 'equal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return new Q(array(\n                \"{$name}__gte\" => $l,\n                \"{$name}__lt\" => $r\n            ));\n        case 'nequal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return Q::any(array(\n                \"{$name}__lt\" => $l,\n                \"{$name}__gte\" => $r,\n            ));\n        case 'after':\n            return new Q(array(\"{$name}__gte\" => $value));\n        case 'before':\n            return new Q(array(\"{$name}__lt\" => $value));\n        case 'between':\n            foreach (array('left', 'right') as $side) {\n                $value[$side] = is_int($value[$side])\n                    ? DateTime::createFromFormat('U', !$config['gmt']\n                        ? Misc::gmtime($value[$side]) : $value[$side]) ?: $value[$side]\n                    : $value[$side];\n            }\n            return new Q(array(\n                \"{$name}__gte\" => $value['left'],\n                \"{$name}__lte\" => $value['right'],\n            ));\n        case 'ndaysago':\n            $now = Misc::gmtime();\n            return new Q(array(\n                \"{$name}__lt\" => $now,\n                \"{$name}__gte\" => SqlExpression::minus($now, SqlInterval::DAY($value['until'])),\n            ));\n        case 'ndays':\n            $now = Misc::gmtime();\n            return new Q(array(\n                \"{$name}__gt\" => $now,\n                \"{$name}__lte\" => SqlExpression::plus($now, SqlInterval::DAY($value['until'])),\n            ));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'before':\n            return __('%1$s before %2$s' /* occurs before a date and time */);\n        case 'after':\n            return __('%1$s after %2$s' /* occurs after a date and time */);\n        case 'ndays':\n            return __('%1$s in the next %2$s' /* occurs within a window (like 3 days) */);\n        case 'ndaysago':\n            return __('%1$s in the last %2$s' /* occurs within a recent window (like 3 days) */);\n        case 'between':\n            return __('%1$s between %2$s and %3$s');\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n        if ($method === 'between') {\n            $l = $this->toString($value['left']);\n            $r = $this->toString($value['right']);\n            $desc = $this->describeSearchMethod($method);\n            return sprintf($desc, $name, $l, $r);\n        }\n        return parent::describeSearch($method, $value, $name);\n    }\n}\n\n/**\n * This is kind-of a special field that doesn't have any data. It's used as\n * a field to provide a horizontal section break in the display of a form\n */\nclass SectionBreakField extends FormField {\n    static $widget = 'SectionBreakWidget';\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n}\n\nclass ThreadEntryField extends FormField {\n    static $widget = 'ThreadEntryWidget';\n\n    function isChangeable() {\n        return false;\n    }\n    function isBlockLevel() {\n        return true;\n    }\n    function isPresentationOnly() {\n        return true;\n    }\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    function getMedia() {\n        $config = $this->getConfiguration();\n        $media = parent::getMedia() ?: array();\n        if ($config['attachments'])\n            $media = array_merge_recursive($media, FileUploadWidget::$media);\n        return $media;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n        $config = parent::getConfiguration();\n        $config['html'] = (bool) ($cfg && $cfg->isRichTextEnabled());\n        return $config;\n    }\n\n    function getConfigurationOptions() {\n        global $cfg;\n\n        $attachments = new FileUploadField();\n        $fileupload_config = $attachments->getConfigurationOptions();\n        if ($cfg->getAllowedFileTypes())\n            $fileupload_config['extensions']->set('default', $cfg->getAllowedFileTypes());\n\n        foreach ($fileupload_config as $C) {\n            $C->set('visibility', new VisibilityConstraint(new Q(array(\n                'attachments__eq'=>true,\n            )), VisibilityConstraint::HIDDEN));\n        }\n        return array(\n            'attachments' => new BooleanField(array(\n                'label'=>__('Enable Attachments'),\n                'default'=>$cfg->allowAttachments(),\n                'configuration'=>array(\n                    'desc'=>__('Enables attachments, regardless of channel'),\n                ),\n                'validators' => function($self, $value) {\n                    if (!ini_get('file_uploads'))\n                        $self->addError(__('The \"file_uploads\" directive is disabled in php.ini'));\n                }\n            )),\n        )\n        + $fileupload_config;\n    }\n\n    function isAttachmentsEnabled() {\n        $config = $this->getConfiguration();\n        return $config['attachments'];\n    }\n\n    function getWidget($widgetClass=false) {\n        if ($hint = $this->getLocal('hint'))\n            $this->set('placeholder', $hint);\n        $this->set('hint', null);\n        $widget = parent::getWidget($widgetClass);\n        return $widget;\n    }\n}\n\nclass PriorityField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Priority)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        $sql = 'SELECT priority_id, priority_desc FROM '.PRIORITY_TABLE\n              .' ORDER BY priority_urgency DESC';\n        $choices = array('' => '\u2014 '.__('Default').' \u2014');\n        if (!($res = db_query($sql)))\n            return $choices;\n\n        while ($row = db_fetch_row($res))\n            $choices[$row[0]] = $row[1];\n        return $choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Priority)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n        if ($id)\n            return Priority::lookup($id);\n    }\n\n    function to_database($prio) {\n        return ($prio instanceof Priority)\n            ? array($prio->getDesc(), $prio->getId())\n            : $prio;\n    }\n\n    function display($prio) {\n        if (!$prio instanceof Priority)\n            return parent::display($prio);\n        return sprintf('<span style=\"padding: 2px; background-color: %s\">%s</span>',\n            $prio->getColor(), Format::htmlchars($prio->getDesc()));\n    }\n\n    function toString($value) {\n        return ($value instanceof Priority) ? $value->getDesc() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return FormField::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        // Priority isn't searchable this way\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Priority) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfigurationOptions() {\n        $choices = $this->getChoices();\n        $choices[''] = __('System Default');\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n            'default' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'choices' => $choices,\n                'hint'=>__('Default selection for this field'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n        );\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultPriorityId();\n        return $config;\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'priority' => array(__('Priority Level'), 'PriorityField'),\n    );\n});\n\n\nclass TimezoneField extends ChoiceField {\n    static $widget = 'TimezoneWidget';\n\n    function hasIdValue() {\n        return false;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        $choices = array();\n        foreach (DateTimeZone::listIdentifiers() as $zone)\n            $choices[$zone] =  str_replace('/',' / ',$zone);\n\n        return $choices;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'autodetect' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Auto Detect'), 'required'=>false, 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add Auto Detect Button'))\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\n\nclass DepartmentField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Dept)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        $choices = array();\n        if (($depts = Dept::getDepartments()))\n            foreach ($depts as $id => $name)\n                $choices[$id] = $name;\n\n        return $choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        return $id;\n    }\n\n    function to_database($dept) {\n        return ($dept instanceof Dept)\n            ? array($dept->getName(), $dept->getId())\n            : $dept;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'department' => array(__('Department'), 'DepartmentField'),\n    );\n});\n\n\nclass AssigneeField extends ChoiceField {\n    var $_choices = null;\n    var $_criteria = null;\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if (is_object($widget->value))\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function getCriteria() {\n\n        if (!isset($this->_criteria)) {\n            $this->_criteria = array('available' => true);\n            if (($c=parent::getCriteria()))\n                $this->_criteria = array_merge($this->_criteria, $c);\n        }\n\n        return $this->_criteria;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function setChoices($choices) {\n        $this->_choices = $choices;\n    }\n\n    function getChoices($verbose=false) {\n        global $cfg;\n\n        if (!isset($this->_choices)) {\n            $config = $this->getConfiguration();\n            $choices = array(\n                    __('Agents') => new ArrayObject(),\n                    __('Teams') => new ArrayObject());\n            $A = current($choices);\n            $criteria = $this->getCriteria();\n            $agents = array();\n            if (($dept=$config['dept']) && $dept->assignMembersOnly()) {\n                if (($members = $dept->getAvailableMembers()))\n                    foreach ($members as $member)\n                        $agents[$member->getId()] = $member;\n            } else {\n                $agents = Staff::getStaffMembers($criteria);\n            }\n\n            foreach ($agents as $id => $name)\n                $A['s'.$id] = $name;\n\n            next($choices);\n            $T = current($choices);\n            if (($teams = Team::getActiveTeams()))\n                foreach ($teams as $id => $name)\n                    $T['t'.$id] = $name;\n\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function getValue() {\n\n        if (($value = parent::getValue()) && ($id=$this->getClean()))\n           return $value[$id];\n    }\n\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n\n        if ($id[0] == 's')\n            return Staff::lookup(substr($id, 1));\n        elseif ($id[0] == 't')\n            return Team::lookup(substr($id, 1));\n\n        return $id;\n    }\n\n\n    function to_database($value) {\n        return (is_object($value))\n            ? array($value->getName(), $value->getId())\n            : $value;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'assignee' => array(__('Assignee'), 'AssigneeField'),\n    );\n});\n\n\nclass TicketStateField extends ChoiceField {\n\n    static $_states = array(\n            'open' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Open',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Open'\n                ),\n            'closed' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Closed',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Close'\n                )\n            );\n    // Private states\n    static $_privatestates = array(\n            'archived' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Archived',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Archive'\n                ),\n            'deleted'  => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Deleted',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Delete'\n                )\n            );\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return false;\n    }\n\n    function getChoices($verbose=false) {\n        static $_choices;\n\n        $states = static::$_states;\n        if ($this->options['private_too'])\n            $states += static::$_privatestates;\n\n        if (!isset($_choices)) {\n            // Translate and cache the choices\n            foreach ($states as $k => $v)\n                $_choices[$k] =  _P('ticket state name', $v['name']);\n\n            $this->ht['default'] =  '';\n        }\n\n        return $_choices;\n    }\n\n    function getChoice($state) {\n\n        if ($state && is_array($state))\n            $state = key($state);\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state name', static::$_states[$state]['name']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state name', static::$_privatestates[$state]['name']);\n\n        return $state;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=> __('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=> __('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n\n    static function getVerb($state) {\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state action', static::$_states[$state]['verb']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state action', static::$_privatestates[$state]['verb']);\n    }\n}\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'state' => array('Ticket State', 'TicketStateField', false),\n    );\n});\n\nclass TicketFlagField extends ChoiceField {\n\n    // Supported flags (TODO: move to configurable custom list)\n    static $_flags = array(\n            'onhold' => array(\n                'flag' => 1,\n                'name' => 'Onhold',\n                'states' => array('open'),\n                ),\n            'overdue' => array(\n                'flag' => 2,\n                'name' => 'Overdue',\n                'states' => array('open'),\n                ),\n            'answered' => array(\n                'flag' => 4,\n                'name' => 'Answered',\n                'states' => array('open'),\n                )\n            );\n\n    var $_choices;\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return true;\n    }\n\n    function getChoices($verbose=false) {\n        $this->ht['default'] =  '';\n\n        if (!$this->_choices) {\n            foreach (static::$_flags as $k => $v)\n                $this->_choices[$k] = $v['name'];\n        }\n\n        return $this->_choices;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>'Prompt', 'required'=>false, 'default'=>'',\n                'hint'=>'Leading text shown before a value is selected',\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'flags' => array('Ticket Flags', 'TicketFlagField', false),\n    );\n});\n\nclass FileUploadField extends FormField {\n    static $widget = 'FileUploadWidget';\n\n    protected $attachments;\n    protected $files;\n\n    static function getFileTypes() {\n        static $filetypes;\n\n        if (!isset($filetypes)) {\n            if (function_exists('apcu_fetch')) {\n                $key = md5(SECRET_SALT . GIT_VERSION . 'filetypes');\n                $filetypes = apcu_fetch($key);\n            }\n            if (!$filetypes)\n                $filetypes = YamlDataParser::load(INCLUDE_DIR . '/config/filetype.yaml');\n            if ($key)\n                apcu_store($key, $filetypes, 7200);\n        }\n        return $filetypes;\n    }\n\n    function getConfigurationOptions() {\n        // Compute size selections\n        $sizes = array('262144' => '\u2014 '.__('Small').' \u2014');\n        $next = 512 << 10;\n        $max = strtoupper(ini_get('upload_max_filesize'));\n        $limit = (int) $max;\n        if (!$limit) $limit = 2 << 20; # 2M default value\n        elseif (strpos($max, 'K')) $limit <<= 10;\n        elseif (strpos($max, 'M')) $limit <<= 20;\n        elseif (strpos($max, 'G')) $limit <<= 30;\n        while ($next <= $limit) {\n            // Select the closest, larger value (in case the\n            // current value is between two)\n            $sizes[$next] = Format::file_size($next);\n            $next *= 2;\n        }\n        // Add extra option if top-limit in php.ini doesn't fall\n        // at a power of two\n        if ($next < $limit * 2)\n            $sizes[$limit] = Format::file_size($limit);\n\n        $types = array();\n        foreach (self::getFileTypes() as $type=>$info) {\n            $types[$type] = $info['description'];\n        }\n\n        global $cfg;\n        return array(\n            'size' => new ChoiceField(array(\n                'label'=>__('Maximum File Size'),\n                'hint'=>__('Choose maximum size of a single file uploaded to this field'),\n                'default'=>$cfg->getMaxFileSize(),\n                'choices'=>$sizes\n            )),\n            'mimetypes' => new ChoiceField(array(\n                'label'=>__('Restrict by File Type'),\n                'hint'=>__('Optionally, choose acceptable file types.'),\n                'required'=>false,\n                'choices'=>$types,\n                'configuration'=>array('multiselect'=>true,'prompt'=>__('No restrictions'))\n            )),\n            'extensions' => new TextareaField(array(\n                'label'=>__('Additional File Type Filters'),\n                'hint'=>__('Optionally, enter comma-separated list of additional file types, by extension. (e.g .doc, .pdf).'),\n                'configuration'=>array('html'=>false, 'rows'=>2),\n            )),\n            'max' => new TextboxField(array(\n                'label'=>__('Maximum Files'),\n                'hint'=>__('Users cannot upload more than this many files.'),\n                'default'=>false,\n                'required'=>false,\n                'validator'=>'number',\n                'configuration'=>array('size'=>8, 'length'=>4, 'placeholder'=>__('No limit')),\n            ))\n        );\n    }\n\n    function hasSpecialSearch() {\n        return false;\n    }\n\n    /**\n     * Called from the ajax handler for async uploads via web clients.\n     */\n    function ajaxUpload($bypass=false) {\n        $config = $this->getConfiguration();\n\n        $files = AttachmentFile::format($_FILES['upload'],\n            // For numeric fields assume configuration exists\n            !is_numeric($this->get('id')));\n        if (count($files) != 1)\n            Http::response(400, 'Send one file at a time');\n        $file = array_shift($files);\n        $file['name'] = urldecode($file['name']);\n\n        if (!$this->isValidFile($file))\n            Http::response(413, 'Invalid File');\n\n        if (!$bypass && !$this->isValidFileType($file['name'], $file['type']))\n            Http::response(415, 'File type is not allowed');\n\n        $config = $this->getConfiguration();\n        if (!$bypass && $file['size'] > $config['size'])\n            Http::response(413, 'File is too large');\n\n        if (!($F = AttachmentFile::upload($file)))\n            Http::response(500, 'Unable to store file: '. $file['error']);\n\n        $id = $F->getId();\n\n        // This file is allowed for attachment in this session\n        $_SESSION[':uploadedFiles'][$id] = 1;\n\n        return $id;\n    }\n\n    /**\n     * Called from FileUploadWidget::getValue() when manual upload is used\n     * for browsers which do not support the HTML5 way of uploading async.\n     */\n    function uploadFile($file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!$this->isValidFile($file))\n             throw new FileUploadError(__('Invalid File'));\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        return AttachmentFile::upload($file);\n    }\n\n    /**\n     * Called from API and email routines and such to handle attachments\n     * sent other than via web upload\n     */\n    function uploadAttachment(&$file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (is_callable($file['data']))\n            $file['data'] = $file['data']();\n        if (!isset($file['size'])) {\n            // bootstrap.php include a compat version of mb_strlen\n            if (extension_loaded('mbstring'))\n                $file['size'] = mb_strlen($file['data'], '8bit');\n            else\n                $file['size'] = strlen($file['data']);\n        }\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        if (!$F = AttachmentFile::create($file))\n            throw new FileUploadError(__('Unable to save file'));\n\n        return $F;\n    }\n\n    function isValidFile($file) {\n\n        // Check invalid image hacks\n        if ($file['tmp_name']\n                && stripos($file['type'], 'image/') === 0\n                && function_exists('exif_imagetype')\n                && !exif_imagetype($file['tmp_name']))\n            return false;\n\n        return true;\n    }\n\n    function isValidFileType($name, $type=false) {\n        $config = $this->getConfiguration();\n\n        // Check MIME type - file ext. shouldn't be solely trusted.\n        if ($type && $config['__mimetypes']\n                && in_array($type, $config['__mimetypes'], true))\n            return true;\n\n        // Return true if all file types are allowed (.*)\n        if (!$config['__extensions'] || in_array('.*', $config['__extensions']))\n            return true;\n\n        $allowed = $config['__extensions'];\n        $ext = strtolower(pathinfo($name, PATHINFO_EXTENSION));\n\n        return ($ext && is_array($allowed) && in_array(\".$ext\", $allowed));\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments) && ($a = $this->getAnswer())\n            && ($e = $a->getEntry()) && ($e->get('id'))\n        ) {\n            $this->attachments = GenericAttachments::forIdAndType(\n                // Combine the field and entry ids to make the key\n                sprintf('%u', abs(crc32('E'.$this->get('id').$e->get('id')))),\n                'E');\n        }\n        return $this->attachments ?: array();\n    }\n\n    function setAttachments(GenericAttachments $att) {\n        $this->attachments = $att;\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            foreach ($this->getAttachments() as $a) {\n                if ($a && ($f=$a->getFile()))\n                    $files[] = $f;\n            }\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n\n    function getConfiguration() {\n        $config = parent::getConfiguration();\n        $_types = self::getFileTypes();\n        $mimetypes = array();\n        $extensions = array();\n        if (isset($config['mimetypes']) && is_array($config['mimetypes'])) {\n            foreach ($config['mimetypes'] as $type=>$desc) {\n                foreach ($_types[$type]['types'] as $mime=>$exts) {\n                    $mimetypes[$mime] = true;\n                    if (is_array($exts))\n                        foreach ($exts as $ext)\n                            $extensions['.'.$ext] = true;\n                }\n            }\n        }\n        if (strpos($config['extensions'], '.*') !== false)\n            $config['extensions'] = '';\n\n        if (is_string($config['extensions'])) {\n            foreach (preg_split('/\\s+/', str_replace(',',' ', $config['extensions'])) as $ext) {\n                if (!$ext) {\n                    continue;\n                }\n                elseif (strpos($ext, '/')) {\n                    $mimetypes[$ext] = true;\n                }\n                else {\n                    if ($ext[0] != '.')\n                        $ext = '.' . $ext;\n\n                    // Ensure that the extension is lower-cased for comparison latr\n                    $ext = strtolower($ext);\n\n                    // Add this to the MIME types list so it can be exported to\n                    // the @accept attribute\n                    if (!isset($extensions[$ext]))\n                        $mimetypes[$ext] = true;\n\n                    $extensions[$ext] = true;\n                }\n            }\n            $config['__extensions'] = array_keys($extensions);\n        }\n        elseif (is_array($config['extensions'])) {\n            $config['__extensions'] = $config['extensions'];\n        }\n\n        // 'mimetypes' is the array represented from the user interface,\n        // '__mimetypes' is a complete list of supported MIME types.\n        $config['__mimetypes'] = array_keys($mimetypes);\n        return $config;\n    }\n\n    // When the field is saved to database, encode the ID listing as a json\n    // array. Then, inspect the difference between the files actually\n    // attached to this field\n    function to_database($value) {\n        $this->getAttachments();\n        if (isset($this->attachments) && $this->attachments) {\n            $this->attachments->keepOnlyFileIds($value);\n        }\n        return JsonDataEncoder::encode($value);\n    }\n\n    function parse($value) {\n        // Values in the database should be integer file-ids\n        return array_map(function($e) { return (int) $e; },\n            $value ?: array());\n    }\n\n    function to_php($value) {\n        return is_array($value) ? $value : JsonDataParser::decode($value);\n    }\n\n    function display($value) {\n        $links = array();\n        foreach ($this->getAttachments() as $a) {\n            $links[] = sprintf('<a class=\"no-pjax\" href=\"%s\">%s</a>',\n                Format::htmlchars($a->file->getDownloadUrl()),\n                Format::htmlchars($a->getFilename()));\n        }\n        return implode('<br/>', $links);\n    }\n\n    function toString($value) {\n        $files = array();\n        foreach ($this->getFiles() as $f) {\n            $files[] = $f->name;\n        }\n        return implode(', ', $files);\n    }\n\n    function db_cleanup($field=false) {\n        if ($this->getAttachments()) {\n            $this->attachments->deleteAll();\n        }\n    }\n\n    function asVar($value, $id=false) {\n        if (($attachments = $this->getAttachments()))\n            $attachments = $attachments->all();\n\n        return new FileFieldAttachments($attachments ?: array());\n    }\n    function asVarType() {\n        return 'FileFieldAttachments';\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = Format::htmlchars(array_keys($added));\n        $deleted = Format::htmlchars(array_keys($deleted));\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n}\n\nclass FileFieldAttachments {\n    var $attachments;\n\n    function __construct($attachments) {\n        $this->attachments = $attachments;\n    }\n\n    function __toString() {\n        $files = array();\n        foreach ($this->getAttachments() as $a) {\n            $files[] = $a->getFilename();\n        }\n        return implode(', ', $files);\n    }\n\n    function getAttachments() {\n        return $this->attachments ?: array();\n    }\n\n    function getVar($tag) {\n        switch ($tag) {\n        case 'names':\n            return $this->__toString();\n        case 'files':\n            throw new OOBContent(OOBContent::FILES, $this->getAttachments());\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of file names'),\n            'files' => __('Attached files'),\n        );\n    }\n}\n\nclass InlineFormData extends ArrayObject {\n    var $_form;\n\n    function __construct($form, array $data=array()) {\n        parent::__construct($data);\n        $this->_form = $form;\n    }\n\n    function getVar($tag) {\n        foreach ($this->_form->getFields() as $f) {\n            if ($f->get('name') == $tag)\n                return $this[$f->get('id')];\n        }\n    }\n}\n\n\nclass InlineFormField extends FormField {\n    static $widget = 'InlineFormWidget';\n\n    var $_iform = null;\n\n    function validateEntry($value) {\n        if (!$this->getInlineForm()->isValid()) {\n            $this->_errors[] = __('Correct any errors below and try again.');\n        }\n    }\n\n    function parse($value) {\n        // The InlineFieldWidget returns an array of cleaned data\n        return $value;\n    }\n\n    function to_database($value) {\n        return JsonDataEncoder::encode($value);\n    }\n\n    function to_php($value) {\n        $data = JsonDataParser::decode($value);\n        // The InlineFormData helps with the variable replacer API\n        return new InlineFormData($this->getInlineForm(), $data);\n    }\n\n    function display($data) {\n        $form = $this->getInlineForm();\n        ob_start(); ?>\n        <div><?php\n        foreach ($form->getFields() as $field) { ?>\n            <span style=\"display:inline-block;padding:0 5px;vertical-align:top\">\n                <strong><?php echo Format::htmlchars($field->get('label')); ?></strong>\n                <div><?php\n                    $value = $data[$field->get('id')];\n                    echo $field->display($value); ?></div>\n            </span><?php\n        } ?>\n        </div><?php\n        return ob_get_clean();\n    }\n\n    function getInlineForm($data=false) {\n        $form = $this->get('form');\n        if (is_array($form)) {\n            $form = new SimpleForm($form, $data ?: $this->value ?: $this->getSource());\n        }\n        return $form;\n    }\n}\n\nclass InlineDynamicFormField extends FormField {\n    function getInlineForm($data=false) {\n        if (!isset($this->_iform) || $data) {\n            $config = $this->getConfiguration();\n            $this->_iform = DynamicForm::lookup($config['form']);\n            if ($data)\n                $this->_iform = $this->_iform->getForm($data);\n        }\n        return $this->_iform;\n    }\n\n    function getConfigurationOptions() {\n        $forms = DynamicForm::objects()->filter(array('type'=>'G'))\n            ->values_flat('id', 'title');\n        $choices = array();\n        foreach ($forms as $row) {\n            list($id, $title) = $row;\n            $choices[$id] = $title;\n        }\n        return array(\n            'form' => new ChoiceField(array(\n                'id'=>2, 'label'=>'Inline Form', 'required'=>true,\n                'default'=>'', 'choices'=>$choices\n            )),\n        );\n    }\n}\n\nclass InlineFormWidget extends Widget {\n    function render($mode=false) {\n        $form = $this->field->getInlineForm();\n        if (!$form)\n            return;\n        // Handle first-step edits -- load data from $this->value\n        if ($form instanceof DynamicForm && !$form->getSource())\n            $form = $form->getForm($this->value);\n        $inc = ($mode == 'client') ? CLIENTINC_DIR : STAFFINC_DIR;\n        include $inc . 'templates/inline-form.tmpl.php';\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (!$data)\n            return null;\n        $form = $this->field->getInlineForm($data);\n        if (!$form)\n            return null;\n        return $form->getClean();\n    }\n}\n\nclass Widget {\n    static $media = null;\n\n    function __construct($field) {\n        $this->field = $field;\n        $this->name = $field->getFormName();\n        $this->id = '_' . $this->name;\n    }\n\n    function parseValue() {\n        $this->value = $this->getValue();\n        if (!isset($this->value) && is_object($this->field->getAnswer()))\n            $this->value = $this->field->getAnswer()->getValue();\n        if (!isset($this->value) && isset($this->field->value))\n            $this->value = $this->field->value;\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        // Search for HTML form name first\n        if (isset($data[$this->name]))\n            return $data[$this->name];\n        elseif (isset($data[$this->field->get('name')]))\n            return $data[$this->field->get('name')];\n        elseif (isset($data[$this->field->get('id')]))\n            return $data[$this->field->get('id')];\n        return null;\n    }\n\n    /**\n     * getJsValueGetter\n     *\n     * Used with the dependent fields feature, this function should return a\n     * single javascript expression which can be used in a larger expression\n     * (<> == true, where <> is the result of this function). The %s token\n     * will be replaced with a jQuery variable representing this widget.\n     */\n    function getJsValueGetter() {\n        return '%s.val()';\n    }\n}\n\nclass TextboxWidget extends Widget {\n    static $input_type = 'text';\n\n    function render($options=array(), $extraConfig=false) {\n        $config = $this->field->getConfiguration();\n        if (is_array($extraConfig)) {\n            foreach ($extraConfig as $k=>$v)\n                if (!isset($config[$k]) || !$config[$k])\n                    $config[$k] = $v;\n        }\n        if (isset($config['size']))\n            $size = \"size=\\\"{$config['size']}\\\"\";\n        if (isset($config['length']) && $config['length'])\n            $maxlength = \"maxlength=\\\"{$config['length']}\\\"\";\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        if (isset($config['autocomplete']))\n            $autocomplete = 'autocomplete=\"'.($config['autocomplete']?'on':'off').'\"';\n        if (isset($config['autofocus']))\n            $autofocus = 'autofocus';\n        if (isset($config['disabled']))\n            $disabled = 'disabled=\"disabled\"';\n        if (isset($config['translatable']) && $config['translatable'])\n            $translatable = 'data-translate-tag=\"'.$config['translatable'].'\"';\n        $type = static::$input_type;\n        $types = array(\n            'email' => 'email',\n            'phone' => 'tel',\n        );\n        if ($type == 'text' && isset($types[$config['validator']]))\n            $type = $types[$config['validator']];\n        $placeholder = sprintf('placeholder=\"%s\"', $this->field->getLocal('placeholder',\n            $config['placeholder']));\n        ?>\n        <input type=\"<?php echo $type; ?>\"\n            id=\"<?php echo $this->id; ?>\"\n            <?php echo implode(' ', array_filter(array(\n                $size, $maxlength, $classes, $autocomplete, $disabled,\n                $translatable, $placeholder, $autofocus))); ?>\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value); ?>\"/>\n        <?php\n    }\n}\n\n\nclass TextboxSelectionWidget extends TextboxWidget {\n    //TODO: Support multi-input e.g comma separated inputs\n    function render($options=array(), $extraConfig=array()) {\n\n        if ($this->value && is_array($this->value))\n            $this->value = current($this->value);\n\n        parent::render($options);\n    }\n\n    function getValue() {\n\n        $value = parent::getValue();\n        if ($value && ($item=$this->field->lookupChoice((string) $value)))\n            $value = $item;\n\n        return $value;\n    }\n}\n\nclass PasswordWidget extends TextboxWidget {\n    static $input_type = 'password';\n\n    function render($mode=false, $extra=false) {\n        $extra = array();\n        if ($this->field->value) {\n            $extra['placeholder'] = '\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022';\n        }\n        return parent::render($mode, $extra);\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        // Show empty box unless failed POST\n        if ($_SERVER['REQUEST_METHOD'] != 'POST'\n                || !$this->field->getForm()->isValid())\n            $this->value = '';\n    }\n}\n\nclass TextareaWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $cols = $rows = $maxlength = \"\";\n        $attrs = array();\n        if (isset($config['rows']))\n            $rows = \"rows=\\\"{$config['rows']}\\\"\";\n        if (isset($config['cols']))\n            $cols = \"cols=\\\"{$config['cols']}\\\"\";\n        if (isset($config['length']) && $config['length'])\n            $maxlength = \"maxlength=\\\"{$config['length']}\\\"\";\n        if (isset($config['html']) && $config['html']) {\n            $class = array('richtext', 'no-bar');\n            $class[] = @$config['size'] ?: 'small';\n            $class = sprintf('class=\"%s\"', implode(' ', $class));\n            $this->value = Format::viewableImages($this->value);\n        }\n        if (isset($config['context']))\n            $attrs['data-root-context'] = '\"'.$config['context'].'\"';\n        ?>\n        <span style=\"display:inline-block;width:100%\">\n        <textarea <?php echo $rows.\" \".$cols.\" \".$maxlength.\" \".$class\n                .' '.Format::array_implode('=', ' ', $attrs)\n                .' placeholder=\"'.$config['placeholder'].'\"'; ?>\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"><?php\n                echo Format::htmlchars($this->value);\n            ?></textarea>\n        </span>\n        <?php\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim empty spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass PhoneNumberWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $this->value);\n        ?>\n        <input id=\"<?php echo $this->id; ?>\" type=\"tel\" name=\"<?php echo $this->name; ?>\" value=\"<?php\n        echo Format::htmlchars($phone); ?>\"/><?php\n        // Allow display of extension field even if disabled if the phone\n        // number being edited has an extension\n        if ($ext || $config['ext']) { ?> <?php echo __('Ext'); ?>:\n            <input type=\"text\" name=\"<?php\n            echo $this->name; ?>-ext\" value=\"<?php echo Format::htmlchars($ext);\n                ?>\" size=\"5\"/>\n        <?php }\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        $base = parent::getValue();\n        if ($base === null)\n            return $base;\n        $ext = $data[\"{$this->name}-ext\"];\n        // NOTE: 'X' is significant. Don't change it\n        if ($ext) $ext = 'X'.$ext;\n        return $base . $ext;\n    }\n}\n\nclass ChoicesWidget extends Widget {\n    function render($options=array()) {\n\n        $mode = null;\n        if (isset($options['mode']))\n            $mode = $options['mode'];\n        elseif (isset($this->field->options['render_mode']))\n            $mode = $this->field->options['render_mode'];\n\n        if ($mode == 'view') {\n            if (!($val = (string) $this->field))\n                $val = sprintf('<span class=\"faded\">%s</span>', __('None'));\n\n            echo $val;\n            return;\n        }\n\n        $config = $this->field->getConfiguration();\n        if ($mode == 'search') {\n            $config['multiselect'] = true;\n        }\n\n        // Determine the value for the default (the one listed if nothing is\n        // selected)\n        $choices = $this->field->getChoices(true);\n        $prompt = ($config['prompt'])\n            ? $this->field->getLocal('prompt', $config['prompt'])\n            : __('Select'\n            /* Used as a default prompt for a custom drop-down list */);\n\n        $have_def = false;\n        // We don't consider the 'default' when rendering in 'search' mode\n        if (!strcasecmp($mode, 'search')) {\n            $def_val = $prompt;\n        } else {\n            $def_key = $this->field->get('default');\n            if (!$def_key && $config['default'])\n                $def_key = $config['default'];\n            if (is_array($def_key))\n                $def_key = key($def_key);\n            $have_def = isset($choices[$def_key]);\n            $def_val = $have_def ? $choices[$def_key] : $prompt;\n        }\n\n        $values = $this->value;\n        if (!is_array($values) && isset($values)) {\n            $values = array($values => $this->field->getChoice($values));\n        }\n\n        if (!is_array($values))\n            $values = $have_def ? array($def_key => $choices[$def_key]) : array();\n\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        ?>\n        <select name=\"<?php echo $this->name; ?>[]\"\n            <?php echo implode(' ', array_filter(array($classes))); ?>\n            id=\"<?php echo $this->id; ?>\"\n            <?php if (isset($config['data']))\n              foreach ($config['data'] as $D=>$V)\n                echo ' data-'.$D.'=\"'.Format::htmlchars($V).'\"';\n            ?>\n            data-placeholder=\"<?php echo $prompt; ?>\"\n            <?php if ($config['multiselect'])\n                echo ' multiple=\"multiple\"'; ?>>\n            <?php if (!$have_def && !$config['multiselect']) { ?>\n            <option value=\"<?php echo $def_key; ?>\">&mdash; <?php\n                echo $def_val; ?> &mdash;</option>\n<?php\n        }\n        $this->emitChoices($choices, $values, $have_def, $def_key); ?>\n        </select>\n        <?php\n        if ($config['multiselect']) {\n         ?>\n        <script type=\"text/javascript\">\n        $(function() {\n            $(\"#<?php echo $this->id; ?>\")\n            .select2({'minimumResultsForSearch':10, 'width': '350px'});\n        });\n        </script>\n       <?php\n        }\n    }\n\n    function emitChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        reset($choices);\n        if (is_array(current($choices)) || current($choices) instanceof Traversable)\n            return $this->emitComplexChoices($choices, $values, $have_def, $def_key);\n\n        foreach ($choices as $key => $name) {\n            if (!$have_def && $key == $def_key)\n                continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n        <?php\n        }\n    }\n\n    function emitComplexChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        foreach ($choices as $label => $group) {\n            if (!count($group)) continue;\n            ?>\n            <optgroup label=\"<?php echo $label; ?>\"><?php\n            foreach ($group as $key => $name) {\n                if (!$have_def && $key == $def_key)\n                    continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n<?php       } ?>\n            </optgroup><?php\n        }\n    }\n\n    function getValue() {\n\n        if (!($value = parent::getValue()))\n            return null;\n\n        if ($value && !is_array($value))\n            $value = array($value);\n\n        // Assume multiselect\n        $values = array();\n        $choices = $this->field->getChoices();\n\n        if ($choices && is_array($value)) {\n            // Complex choices\n            if (is_array(current($choices))\n                    || current($choices) instanceof Traversable) {\n                foreach ($choices as $label => $group) {\n                     foreach ($group as $k => $v)\n                        if (in_array($k, $value))\n                            $values[$k] = $v;\n                }\n            } else {\n                foreach($value as $k => $v) {\n                    if (isset($choices[$v]))\n                        $values[$v] = $choices[$v];\n                    elseif (($i=$this->field->lookupChoice($v)))\n                        $values += $i;\n                }\n            }\n        }\n\n        return $values;\n    }\n\n    function getJsValueGetter() {\n        return '%s.find(\":selected\").val()';\n    }\n}\n\n/**\n * A widget for the ChoiceField which will render a list of radio boxes or\n * checkboxes depending on the value of $config['multiple']. Complex choices\n * are also supported and will be rendered as divs.\n */\nclass BoxChoicesWidget extends Widget {\n    function render($options=array()) {\n        $this->emitChoices($this->field->getChoices());\n    }\n\n    function emitChoices($choices) {\n      static $uid = 1;\n\n      if (!isset($this->value))\n          $this->value = $this->field->get('default');\n      $config = $this->field->getConfiguration();\n      $type = $config['multiple'] ? 'checkbox' : 'radio';\n\n      $classes = array('checkbox');\n      if (isset($config['classes']))\n          $classes = array_merge($classes, (array) $config['classes']);\n\n      foreach ($choices as $k => $v) {\n          if (is_array($v)) {\n              $this->renderSectionBreak($k);\n              $this->emitChoices($v);\n              continue;\n          }\n          $id = sprintf(\"%s-%s\", $this->id, $uid++);\n?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\"\n            for=\"<?php echo $id; ?>\">\n        <input id=\"<?php echo $id; ?>\" type=\"<?php echo $type; ?>\"\n            name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value[$k]) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo Format::htmlchars($k); ?>\"/>\n        <?php\n        if ($v) {\n            echo Format::viewableImages($v);\n        } ?>\n        </label>\n<?php   }\n    }\n\n    function renderSectionBreak($label) { ?>\n        <div><?php echo Format::htmlchars($label); ?></div>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return array();\n            return $this->collectValues($data[$this->name], $this->field->getChoices());\n        }\n        return parent::getValue();\n    }\n\n    function collectValues($data, $choices) {\n        $value = array();\n        foreach ($choices as $k => $v) {\n            if (is_array($v))\n                $value = array_merge($value, $this->collectValues($data, $v));\n            elseif (@in_array($k, $data))\n                $value[$k] = $v;\n        }\n        return $value;\n    }\n}\n\n/**\n * An extension to the BoxChoicesWidget which will render complex choices in\n * tabs.\n */\nclass TabbedBoxChoicesWidget extends BoxChoicesWidget {\n    function render($options=array()) {\n        $tabs = array();\n        foreach ($this->field->getChoices() as $label=>$group) {\n            if (is_array($group)) {\n                $tabs[$label] = $group;\n            }\n            else {\n                $this->emitChoices(array($label=>$group));\n            }\n        }\n        if ($tabs) {\n            ?>\n            <div>\n            <ul class=\"alt tabs\">\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $active = $i++ == 0; ?>\n                <li <?php if ($active) echo 'class=\"active\"';\n                  ?>><a href=\"#<?php echo sprintf('%s-%s', $this->name, Format::slugify($label));\n                  ?>\"><?php echo Format::htmlchars($label); ?></a></li>\n<?php       } ?>\n            </ul>\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $first = $i++ == 0; ?>\n                <div class=\"tab_content <?php if (!$first) echo 'hidden'; ?>\" id=\"<?php\n                  echo sprintf('%s-%s', $this->name, Format::slugify($label));?>\">\n<?php           $this->emitChoices($group); ?>\n                </div>\n<?php       } ?>\n            </div>\n<?php   }\n    }\n}\n\n/**\n* TimezoneWidget extends ChoicesWidget to add auto-detect and select2 search\n* options\n*\n**/\nclass TimezoneWidget extends ChoicesWidget {\n\n    function render($options=array()) {\n        parent::render($options);\n        $config = $this->field->getConfiguration();\n        if (@$config['autodetect']) {\n        ?>\n        <button type=\"button\" class=\"action-button\" onclick=\"javascript:\n            $('head').append($('<script>').attr('src', '<?php\n            echo ROOT_PATH; ?>js/jstz.min.js'));\n            var recheck = setInterval(function() {\n                if (window.jstz !== undefined) {\n                    clearInterval(recheck);\n                    var zone = jstz.determine();\n                    $('#<?php echo $this->id; ?>').val(zone.name()).trigger('change');\n\n                }\n            }, 100);\n            return false;\"\n            style=\"vertical-align:middle\">\n            <i class=\"icon-map-marker\"></i> <?php echo __('Auto Detect'); ?>\n        </button>\n        <?php\n        } ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('#<?php echo $this->id; ?>').select2({\n                    allowClear: true,\n                    width: '300px'\n                });\n            });\n        </script>\n      <?php\n    }\n}\n\nclass CheckboxWidget extends Widget {\n    function __construct($field) {\n        parent::__construct($field);\n        $this->name = '_field-checkboxes';\n    }\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value))\n            $this->value = $this->field->get('default');\n        $classes = array('checkbox');\n        if (isset($config['classes']))\n            $classes = array_merge($classes, (array) $config['classes']);\n        ?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\">\n        <input id=\"<?php echo $this->id; ?>\"\n            type=\"checkbox\" name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo $this->field->get('id'); ?>\"/>\n        <?php\n        if ($config['desc']) {\n            echo Format::viewableImages($config['desc']);\n        } ?>\n        </label>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return false;\n            return @in_array($this->field->get('id'), $data[$this->name]);\n        }\n        return parent::getValue();\n    }\n\n    function getJsValueGetter() {\n        return '%s.is(\":checked\")';\n    }\n}\n\nclass DatetimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        global $cfg;\n\n        $config = $this->field->getConfiguration();\n        $timezone = $this->field->getTimezone();\n        if ($this->value) {\n\n            if (is_int($this->value))\n                // Assuming UTC timezone.\n                $datetime = DateTime::createFromFormat('U', $this->value);\n            else {\n                $datetime = Format::parseDateTime($this->value);\n            }\n\n            if ($config['time']) {\n                // Convert to user's timezone for update.\n                $datetime->setTimezone($timezone);\n            }\n\n            $this->value = Format::date($datetime->getTimestamp(), false,\n                    false, $timezone ? $timezone->getName() : 'UTC');\n        } else {\n            $datetime = new DateTime('now');\n            $datetime->setTimezone($timezone);\n        }\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo Format::htmlchars($this->value ?: ''); ?>\" size=\"12\"\n            autocomplete=\"off\" class=\"dp\" />\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').datepicker({\n                    <?php\n                    if ($dt=$this->field->getMinDateTime())\n                        echo sprintf(\"minDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    if ($dt=$this->field->getMaxDateTime())\n                        echo sprintf(\"maxDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    elseif (!$config['future'])\n                        echo \"maxDate: new Date().getTime(),\\n\";\n                    ?>\n                    numberOfMonths: 2,\n                    showButtonPanel: true,\n                    buttonImage: './images/cal.png',\n                    showOn:'both',\n                    dateFormat: $.translate_format('<?php echo $cfg->getDateFormat(true); ?>')\n                });\n            });\n        </script>\n        <?php\n        if ($config['time']) {\n            list($hr, $min) = explode(':', $datetime ?\n                    $datetime->format('H:i') : '');\n            // TODO: Add time picker -- requires time picker or selection with\n            //       Misc::timeDropdown\n            echo '&nbsp;' . Misc::timeDropdown($hr, $min, $this->name . ':time');\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n    }\n\n    /**\n     * Function: getValue\n     * Combines the datepicker date value and the time dropdown selected\n     * time value into a single date and time string value in DateTime::W3C\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            // Effective timezone for the selection\n            $timezone = $this->field->getTimezone();\n            // See if we have time\n            $data = $this->field->getSource();\n            if ($value && isset($data[$this->name . ':time']))\n                $value .=' '.$data[$this->name . ':time'];\n\n            $dt = new DateTime($value, $timezone);\n            $value = $dt->format('Y-m-d H:i:s T');\n        }\n\n        return $value;\n    }\n}\n\nclass SectionBreakWidget extends Widget {\n    function render($options=array()) {\n        ?><div class=\"form-header section-break\"><h3><?php\n        echo Format::htmlchars($this->field->getLocal('label'));\n        ?></h3><em><?php echo Format::display($this->field->getLocal('hint'));\n        ?></em></div>\n        <?php\n    }\n}\n\nclass ThreadEntryWidget extends Widget {\n    function render($options=array()) {\n\n        $config = $this->field->getConfiguration();\n        $object_id = false;\n        if ($options['client']) {\n            $namespace = $options['draft-namespace']\n                ?: 'ticket.client';\n             $object_id = substr(session_id(), -12);\n        } else {\n            $namespace = $options['draft-namespace'] ?: 'ticket.staff';\n        }\n\n        list($draft, $attrs) = Draft::getDraftAndDataAttrs($namespace, $object_id, $this->value);\n        ?>\n        <textarea style=\"width:100%;\" name=\"<?php echo $this->field->get('name'); ?>\"\n            placeholder=\"<?php echo Format::htmlchars($this->field->get('placeholder')); ?>\"\n            class=\"<?php if ($config['html']) echo 'richtext';\n                ?> draft draft-delete\" <?php echo $attrs; ?>\n            cols=\"21\" rows=\"8\" style=\"width:80%;\"><?php echo\n            Format::htmlchars($this->value) ?: $draft; ?></textarea>\n    <?php\n        if (!$config['attachments'])\n            return;\n\n        $attachments = $this->getAttachments($config);\n        print $attachments->render($options);\n        foreach ($attachments->getMedia() as $type=>$urls) {\n            foreach ($urls as $url)\n                Form::emitMedia($url, $type);\n        }\n    }\n\n    function getAttachments($config=false) {\n        if (!$config)\n            $config = $this->field->getConfiguration();\n\n        $field = new FileUploadField(array(\n            'id'=>'attach',\n            'name'=>'attach:' . $this->field->get('id'),\n            'configuration'=>$config)\n        );\n        $field->setForm($this->field->getForm());\n        return $field;\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass FileUploadWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            '/css/filedrop.css',\n        ),\n    );\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $name = $this->field->getFormName();\n        $id = substr(md5(spl_object_hash($this)), 10);\n        $mimetypes = array_filter($config['__mimetypes'],\n            function($t) { return strpos($t, '/') !== false; }\n        );\n        $maxfilesize = ($config['size'] ?: 1048576) / 1048576;\n        $files = array();\n        $new = array_fill_keys($this->field->getClean(), 1);\n        foreach ($this->field->getAttachments() as $att) {\n            unset($new[$att->file_id]);\n            $files[] = array(\n                'id' => $att->file->getId(),\n                'name' => $att->getFilename(),\n                'type' => $att->file->getType(),\n                'size' => $att->file->getSize(),\n                'download_url' => $att->file->getDownloadUrl(),\n            );\n        }\n\n        // Add in newly added files not yet saved (if redisplaying after an\n        // error)\n        if ($new) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($new)))\n                ->all();\n            foreach ($F as $f) {\n                $f->tmp_name = $new[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n        ?><div id=\"<?php echo $id;\n            ?>\" class=\"filedrop\"><div class=\"files\"></div>\n            <div class=\"dropzone\"><i class=\"icon-upload\"></i>\n            <?php echo sprintf(\n                __('Drop files here or %s choose them %s'),\n                '<a href=\"#\" class=\"manual\">', '</a>'); ?>\n        <input type=\"file\" multiple=\"multiple\"\n            id=\"file-<?php echo $id; ?>\" style=\"display:none;\"\n            accept=\"<?php echo implode(',', $config['__mimetypes']); ?>\"/>\n        </div></div>\n        <script type=\"text/javascript\">\n        $(function(){$('#<?php echo $id; ?> .dropzone').filedropbox({\n          url: 'ajax.php/form/upload/<?php echo $this->field->get('id') ?>',\n          link: $('#<?php echo $id; ?>').find('a.manual'),\n          paramname: 'upload[]',\n          fallback_id: 'file-<?php echo $id; ?>',\n          allowedfileextensions: <?php echo JsonDataEncoder::encode(\n            $config['__extensions'] ?: array()); ?>,\n          allowedfiletypes: <?php echo JsonDataEncoder::encode(\n            $mimetypes); ?>,\n          maxfiles: <?php echo $config['max'] ?: 20; ?>,\n          maxfilesize: <?php echo str_replace(',', '.', $maxfilesize); ?>,\n          name: '<?php echo $name; ?>[]',\n          files: <?php echo JsonDataEncoder::encode($files); ?>\n        });});\n        </script>\n<?php\n    }\n\n    function getValue() {\n        $ids = array();\n        // Handle manual uploads (IE<10)\n        if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES[$this->name])) {\n            foreach (AttachmentFile::format($_FILES[$this->name]) as $file) {\n                try {\n                    $F = $this->field->uploadFile($file);\n                    $ids[] = $F->getId();\n                }\n                catch (FileUploadError $ex) {}\n            }\n            return $ids;\n        }\n\n        // Files uploaded here MUST have been uploaded by this user and\n        // identified in the session\n        //\n        // If no value was sent, assume an empty list\n        if (!($files = parent::getValue()))\n            return array();\n\n        $allowed = array();\n        // Files already attached to the field are allowed\n        foreach ($this->field->getFiles() as $F) {\n            // FIXME: This will need special porting in v1.10\n            $allowed[$F->id] = 1;\n        }\n\n        // New files uploaded in this session are allowed\n        if (isset($_SESSION[':uploadedFiles']))\n            $allowed += $_SESSION[':uploadedFiles'];\n\n        // Canned attachments initiated by this session\n        if (isset($_SESSION[':cannedFiles']))\n           $allowed += $_SESSION[':cannedFiles'];\n\n        // Parse the files and make sure it's allowed.\n        foreach ($files as $info) {\n            @list($id, $name) = explode(',', $info, 2);\n            if (!isset($allowed[$id]))\n                continue;\n\n            // Keep the values as the IDs\n            if ($name)\n                $ids[$name] = $id;\n            else\n                $ids[] = $id;\n        }\n\n        return $ids;\n    }\n}\n\nclass FileUploadError extends Exception {}\n\nclass FreeTextField extends FormField {\n    static $widget = 'FreeTextWidget';\n    protected $attachments;\n\n    function getConfigurationOptions() {\n        return array(\n            'content' => new TextareaField(array(\n                'configuration' => array('html' => true, 'size'=>'large'),\n                'label'=>__('Content'), 'required'=>true, 'default'=>'',\n                'hint'=>__('Free text shown in the form, such as a disclaimer'),\n            )),\n            'attachments' => new FileUploadField(array(\n                'id'=>'attach',\n                'label' => __('Attachments'),\n                'name'=>'files',\n                'configuration' => array('extensions'=>'')\n            )),\n        );\n    }\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    /* utils */\n\n    function to_config($config) {\n        if ($config && isset($config['attachments']))\n            $keepers = $config['attachments'] = array_values($config['attachments']);\n        $this->getAttachments()->keepOnlyFileIds($keepers);\n\n        return $config;\n    }\n\n    function db_cleanup($field=false) {\n\n        if ($field && $this->getFiles())\n            $this->getAttachments()->deleteAll();\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments))\n            $this->attachments = GenericAttachments::forIdAndType($this->get('id'), 'I');\n\n        return $this->attachments ?: array();\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            if (($attachments=$this->getAttachments()))\n                foreach ($attachments->all() as $a)\n                    $files[] = $a->getFile();\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n}\n\nclass FreeTextWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $config['classes'] ?: 'thread-body bleed';\n        ?><div class=\"<?php echo $class; ?>\"><?php\n        if ($label = $this->field->getLocal('label')) { ?>\n            <h3><?php\n            echo Format::htmlchars($label);\n        ?></h3><?php\n        }\n        if ($hint = $this->field->getLocal('hint')) { ?>\n        <em><?php\n            echo Format::htmlchars($hint);\n        ?></em><?php\n        } ?>\n        <div><?php\n            echo Format::viewableImages($config['content']); ?></div>\n        </div>\n        <?php\n        if (($attachments = $this->field->getAttachments()) && count($attachments)) { ?>\n            <section class=\"freetext-files\">\n            <div class=\"title\"><?php echo __('Related Resources'); ?></div>\n            <?php foreach ($attachments->all() as $attach) { ?>\n                <div class=\"file\">\n                <a href=\"<?php echo $attach->file->getDownloadUrl(); ?>\"\n                    target=\"_blank\" download=\"<?php echo $attach->file->getDownloadUrl();\n                    ?>\" class=\"truncate no-pjax\">\n                    <i class=\"icon-file\"></i>\n                    <?php echo Format::htmlchars($attach->getFilename()); ?>\n                </a>\n                </div>\n            <?php } ?>\n        </section>\n        <?php }\n    }\n}\n\nclass VisibilityConstraint {\n    static $operators = array(\n        'eq' => 1,\n    );\n\n    const HIDDEN =      0x0001;\n    const VISIBLE =     0x0002;\n\n    var $initial;\n    var $constraint;\n\n    function __construct($constraint, $initial=self::VISIBLE) {\n        $this->constraint = $constraint;\n        $this->initial = $initial;\n    }\n\n    function emitJavascript($field) {\n\n        if (!$this->constraint->constraints)\n            return;\n\n        $func = 'recheck';\n        $form = $field->getForm();\n?>\n    <script type=\"text/javascript\">\n      !(function() {\n        var <?php echo $func; ?> = function() {\n          var target = $('#field<?php echo $field->getWidget()->id; ?>');\n\n<?php   $fields = $this->getAllFields($this->constraint);\n        foreach ($fields as $f) {\n            $field = $form->getField($f);\n            echo sprintf('var %1$s = $(\"#%1$s\");',\n                $field->getWidget()->id);\n        }\n        $expression = $this->compileQ($this->constraint, $form);\n?>\n          if (<?php echo $expression; ?>)\n            target.slideDown('fast', function (){\n                $(this).trigger('show');\n                });\n          else\n            target.slideUp('fast', function (){\n                $(this).trigger('hide');\n                });\n        };\n\n<?php   foreach ($fields as $f) {\n            $w = $form->getField($f)->getWidget();\n?>\n        $('#<?php echo $w->id; ?>').on('change', <?php echo $func; ?>);\n        $('#field<?php echo $w->id; ?>').on('show hide', <?php\n                echo $func; ?>);\n<?php   } ?>\n      })();\n    </script><?php\n    }\n\n    /**\n     * Determines if the field was visible when the form was submitted\n     */\n    function isVisible($field) {\n\n        // Assume initial visibility if constraint is not provided.\n        if (!$this->constraint->constraints)\n            return $this->initial == self::VISIBLE;\n\n\n        return $this->compileQPhp($this->constraint, $field);\n    }\n\n    static function splitFieldAndOp($field) {\n        if (false !== ($last = strrpos($field, '__'))) {\n            $op = substr($field, $last + 2);\n            if (isset(static::$operators[$op]))\n                $field = substr($field, 0, strrpos($field, '__'));\n        }\n        return array($field, $op);\n    }\n\n    function compileQPhp(Q $Q, $field) {\n        if (!($form = $field->getForm())) {\n            return $this->initial == self::VISIBLE;\n        }\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQPhp($value, $field);\n            }\n            else {\n                @list($f, $op) = self::splitFieldAndOp($c);\n                $field = $form->getField($f);\n                $wval = $field->getClean();\n                switch ($op) {\n                case 'eq':\n                case null:\n                    $expr[] = ($wval == $value && $field->isVisible());\n                }\n            }\n        }\n        $glue = $Q->isOred()\n            ? function($a, $b) { return $a || $b; }\n            : function($a, $b) { return $a && $b; };\n        $initial = !$Q->isOred();\n        $expression = array_reduce($expr, $glue, $initial);\n        if ($Q->isNegated)\n            $expression = !$expression;\n        return $expression;\n    }\n\n    function getAllFields(Q $Q, &$fields=array()) {\n        foreach ($Q->constraints as $c=>$value) {\n            if ($c instanceof Q) {\n                $this->getAllFields($c, $fields);\n            }\n            else {\n                @list($f) = self::splitFieldAndOp($c);\n                $fields[$f] = true;\n            }\n        }\n        return array_keys($fields);\n    }\n\n    function compileQ($Q, $form) {\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQ($value, $form);\n            }\n            else {\n                list($f, $op) = self::splitFieldAndOp($c);\n                $widget = $form->getField($f)->getWidget();\n                $id = $widget->id;\n                switch ($op) {\n                case 'eq':\n                case null:\n                    $expr[] = sprintf('(%s.is(\":visible\") && %s)',\n                            $id,\n                            sprintf('%s == %s',\n                                sprintf($widget->getJsValueGetter(), $id),\n                                JsonDataEncoder::encode($value))\n                            );\n                }\n            }\n        }\n        $glue = $Q->isOred() ? ' || ' : ' && ';\n        $expression = implode($glue, $expr);\n        if (count($expr) > 1)\n            $expression = '('.$expression.')';\n        if ($Q->isNegated)\n            $expression = '!'.$expression;\n        return $expression;\n    }\n}\n\nclass AssignmentForm extends Form {\n\n    static $id = 'assign';\n    var $_assignee = null;\n    var $_assignees = null;\n\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'assignee' => new AssigneeField(array(\n                    'id'=>1,\n                    'label' => __('Assignee'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Assignee selection required'),\n                    'configuration' => array(\n                        'criteria' => array(\n                            'available' => true,\n                            ),\n                       ),\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 2,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        if (isset($this->_assignees))\n            $fields['assignee']->setChoices($this->_assignees);\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('assignee')))\n            return false;\n\n        // Do additional assignment validation\n        if (!($assignee = $this->getAssignee())) {\n            $f->addError(__('Unknown assignee'));\n        } elseif ($assignee instanceof Staff) {\n            // Make sure the agent is available\n            if (!$assignee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        } elseif ($assignee instanceof Team) {\n            // Make sure the team is active and has members\n            if (!$assignee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$assignee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setAssignees($assignees) {\n        $this->_assignees = $assignees;\n        $this->_fields = array();\n    }\n\n    function getAssignees() {\n        return $this->_assignees;\n    }\n\n    function getAssignee() {\n\n        if (!isset($this->_assignee))\n            $this->_assignee = $this->getField('assignee')->getClean();\n\n        return $this->_assignee;\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass ClaimForm extends AssignmentForm {\n\n    var $_fields;\n\n    function setFields($fields) {\n        $this->_fields = $fields;\n        parent::setFields($fields);\n    }\n\n    function getFields() {\n\n        if ($this->_fields)\n            return $this->_fields;\n\n        $fields = parent::getFields();\n\n        // Disable && hide assignee field selection\n        if (isset($fields['assignee'])) {\n            $visibility = new VisibilityConstraint(\n                    new Q(array()), VisibilityConstraint::HIDDEN);\n\n            $fields['assignee']->set('visibility', $visibility);\n        }\n\n        // Change coments placeholder to reflect claim\n        if (isset($fields['comments'])) {\n            $fields['comments']->configure('placeholder',\n                    __('Optional reason for the claim'));\n        }\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n}\n\nclass TransferForm extends Form {\n\n    static $id = 'transfer';\n    var $_dept = null;\n\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n    }\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'dept' => new DepartmentField(array(\n                    'id'=>1,\n                    'label' => __('Department'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Department selection is required'),\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 2,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the transfer'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include))\n            return false;\n\n        // Do additional validations\n        if (!($dept = $this->getDept()))\n            $this->getField('dept')->addError(\n                    __('Unknown department'));\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        get_class(), $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n\n    }\n\n    function getDept() {\n\n        if (!isset($this->_dept)) {\n            if (($id = $this->getField('dept')->getClean()))\n                $this->_dept = Dept::lookup($id);\n        }\n\n        return $this->_dept;\n    }\n}\n\n/**\n * FieldUnchanged\n *\n * Thrown in the to_database() method to indicate the value should not be\n * saved in the database (it wasn't changed in the request)\n */\nclass FieldUnchanged extends Exception {}\n?>\n", "<?php\n/*********************************************************************\n    class.user.php\n\n    External end-user identification for osTicket\n\n    Peter Rotich <peter@osticket.com>\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once INCLUDE_DIR . 'class.orm.php';\nrequire_once INCLUDE_DIR . 'class.util.php';\nrequire_once INCLUDE_DIR . 'class.organization.php';\nrequire_once INCLUDE_DIR . 'class.variable.php';\n\nclass UserEmailModel extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_EMAIL_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'user' => array(\n                'constraint' => array('user_id' => 'UserModel.id')\n            )\n        )\n    );\n\n    function __toString() {\n        return (string) $this->address;\n    }\n}\n\nclass UserModel extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_TABLE,\n        'pk' => array('id'),\n        'select_related' => array('default_email', 'org', 'account'),\n        'joins' => array(\n            'emails' => array(\n                'reverse' => 'UserEmailModel.user',\n            ),\n            'tickets' => array(\n                'null' => true,\n                'reverse' => 'TicketModel.user',\n            ),\n            'account' => array(\n                'list' => false,\n                'null' => true,\n                'reverse' => 'ClientAccount.user',\n            ),\n            'org' => array(\n                'null' => true,\n                'constraint' => array('org_id' => 'Organization.id')\n            ),\n            'default_email' => array(\n                'null' => true,\n                'constraint' => array('default_email_id' => 'UserEmailModel.id')\n            ),\n            'cdata' => array(\n                'constraint' => array('id' => 'UserCdata.user_id'),\n                'null' => true,\n            ),\n            'cdata_entry' => array(\n                'constraint' => array(\n                    'id' => 'DynamicFormEntry.object_id',\n                    \"'U'\" => 'DynamicFormEntry.object_type',\n                ),\n                'null' => true,\n            ),\n        )\n    );\n\n    const PRIMARY_ORG_CONTACT   = 0x0001;\n\n    const PERM_CREATE =     'user.create';\n    const PERM_EDIT =       'user.edit';\n    const PERM_DELETE =     'user.delete';\n    const PERM_MANAGE =     'user.manage';\n    const PERM_DIRECTORY =  'user.dir';\n\n    static protected $perms = array(\n        self::PERM_CREATE => array(\n            'title' => /* @trans */ 'Create',\n            'desc' => /* @trans */ 'Ability to add new users',\n            'primary' => true,\n        ),\n        self::PERM_EDIT => array(\n            'title' => /* @trans */ 'Edit',\n            'desc' => /* @trans */ 'Ability to manage user information',\n            'primary' => true,\n        ),\n        self::PERM_DELETE => array(\n            'title' => /* @trans */ 'Delete',\n            'desc' => /* @trans */ 'Ability to delete users',\n            'primary' => true,\n        ),\n        self::PERM_MANAGE => array(\n            'title' => /* @trans */ 'Manage Account',\n            'desc' => /* @trans */ 'Ability to manage active user accounts',\n            'primary' => true,\n        ),\n        self::PERM_DIRECTORY => array(\n            'title' => /* @trans */ 'User Directory',\n            'desc' => /* @trans */ 'Ability to access the user directory',\n            'primary' => true,\n        ),\n    );\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getDefaultEmailAddress() {\n        return $this->getDefaultEmail()->address;\n    }\n\n    function getDefaultEmail() {\n        return $this->default_email;\n    }\n\n    function hasAccount() {\n        return !is_null($this->account);\n    }\n    function getAccount() {\n        return $this->account;\n    }\n\n    function getOrgId() {\n         return $this->get('org_id');\n    }\n\n    function getOrganization() {\n        return $this->org;\n    }\n\n    function setOrganization($org, $save=true) {\n\n        $this->set('org', $org);\n\n        if ($save)\n            $this->save();\n\n        return true;\n    }\n\n    protected function hasStatus($flag) {\n        return $this->get('status') & $flag !== 0;\n    }\n\n    protected function clearStatus($flag) {\n        return $this->set('status', $this->get('status') & ~$flag);\n    }\n\n    protected function setStatus($flag) {\n        return $this->set('status', $this->get('status') | $flag);\n    }\n\n    function isPrimaryContact() {\n        return $this->hasStatus(User::PRIMARY_ORG_CONTACT);\n    }\n\n    function setPrimaryContact($flag) {\n        if ($flag)\n            $this->setStatus(User::PRIMARY_ORG_CONTACT);\n        else\n            $this->clearStatus(User::PRIMARY_ORG_CONTACT);\n    }\n\n    static function getPermissions() {\n        return self::$perms;\n    }\n}\ninclude_once INCLUDE_DIR.'class.role.php';\nRolePermission::register(/* @trans */ 'Users', UserModel::getPermissions());\n\nclass UserCdata extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_CDATA_TABLE,\n        'pk' => array('user_id'),\n        'joins' => array(\n            'user' => array(\n                'constraint' => array('user_id' => 'UserModel.id'),\n            ),\n        ),\n    );\n}\n\nclass User extends UserModel\nimplements TemplateVariable {\n\n    var $_entries;\n    var $_forms;\n\n    static function fromVars($vars, $create=true, $update=false) {\n        // Try and lookup by email address\n        $user = static::lookupByEmail($vars['email']);\n        if (!$user && $create) {\n            $name = $vars['name'];\n            if (is_array($name))\n                $name = implode(', ', $name);\n            elseif (!$name)\n                list($name) = explode('@', $vars['email'], 2);\n\n            $user = new User(array(\n                'name' => Format::htmldecode(Format::sanitize($name, false)),\n                'created' => new SqlFunction('NOW'),\n                'updated' => new SqlFunction('NOW'),\n                //XXX: Do plain create once the cause\n                // of the detached emails is fixed.\n                'default_email' => UserEmail::ensure($vars['email'])\n            ));\n            // Is there an organization registered for this domain\n            list($mailbox, $domain) = explode('@', $vars['email'], 2);\n            if (isset($vars['org_id']))\n                $user->set('org_id', $vars['org_id']);\n            elseif ($org = Organization::forDomain($domain))\n                $user->setOrganization($org, false);\n\n            try {\n                $user->save(true);\n                $user->emails->add($user->default_email);\n                // Attach initial custom fields\n                $user->addDynamicData($vars);\n            }\n            catch (OrmException $e) {\n                return null;\n            }\n            Signal::send('user.created', $user);\n        }\n        elseif ($update) {\n            $errors = array();\n            $user->updateInfo($vars, $errors, true);\n        }\n\n        return $user;\n    }\n\n    static function fromForm($form, $create=true) {\n        global $thisstaff;\n\n        if(!$form) return null;\n\n        //Validate the form\n        $valid = true;\n        $filter = function($f) use ($thisstaff) {\n            return !isset($thisstaff) || $f->isRequiredForStaff() || $f->isVisibleToStaff();\n        };\n        if (!$form->isValid($filter))\n            $valid  = false;\n\n        //Make sure the email is not in-use\n        if (($field=$form->getField('email'))\n                && $field->getClean()\n                && User::lookup(array('emails__address'=>$field->getClean()))) {\n            $field->addError(__('Email is assigned to another user'));\n            $valid = false;\n        }\n\n        return $valid ? self::fromVars($form->getClean(), $create) : null;\n    }\n\n    function getEmail() {\n        return new EmailAddress($this->default_email->address);\n    }\n\n    function getAvatar() {\n        global $cfg;\n        $source = $cfg->getClientAvatarSource();\n        return $source->getAvatar($this);\n    }\n\n    function getFullName() {\n        return $this->name;\n    }\n\n    function getPhoneNumber() {\n        foreach ($this->getDynamicData() as $e)\n            if ($a = $e->getAnswer('phone'))\n                return $a;\n    }\n\n    function getName() {\n        if (!$this->name)\n            list($name) = explode('@', $this->getDefaultEmailAddress(), 2);\n        else\n            $name = $this->name;\n        return new UsersName($name);\n    }\n\n    function getUpdateDate() {\n        return $this->updated;\n    }\n\n    function getCreateDate() {\n        return $this->created;\n    }\n\n    function getTimezone() {\n        global $cfg;\n\n        if (($acct = $this->getAccount()) && ($tz = $acct->getTimezone())) {\n            return $tz;\n        }\n        return $cfg->getDefaultTimezone();\n    }\n\n    function addForm($form, $sort=1, $data=null) {\n        $entry = $form->instanciate($sort, $data);\n        $entry->set('object_type', 'U');\n        $entry->set('object_id', $this->getId());\n        $entry->save();\n        return $entry;\n    }\n\n    function getLanguage($flags=false) {\n        if ($acct = $this->getAccount())\n            return $acct->getLanguage($flags);\n    }\n\n    function to_json() {\n\n        $info = array(\n                'id'  => $this->getId(),\n                'name' => Format::htmlchars($this->getName()),\n                'email' => (string) $this->getEmail(),\n                'phone' => (string) $this->getPhoneNumber());\n\n        return JsonDataEncoder::encode($info);\n    }\n\n    function __toString() {\n        return $this->asVar();\n    }\n\n    function asVar() {\n        return (string) $this->getName();\n    }\n\n    function getVar($tag) {\n        $tag = mb_strtolower($tag);\n        foreach ($this->getDynamicData() as $e)\n            if ($a = $e->getAnswer($tag))\n                return $a;\n    }\n\n    static function getVarScope() {\n        $base = array(\n            'email' => array(\n                'class' => 'EmailAddress', 'desc' => __('Default email address')\n            ),\n            'name' => array(\n                'class' => 'PersonsName', 'desc' => 'User name, default format'\n            ),\n            'organization' => array('class' => 'Organization', 'desc' => __('Organization')),\n        );\n        $extra = VariableReplacer::compileFormScope(UserForm::getInstance());\n        return $base + $extra;\n    }\n\n    function addDynamicData($data) {\n        return $this->addForm(UserForm::objects()->one(), 1, $data);\n    }\n\n    function getDynamicData($create=true) {\n        if (!isset($this->_entries)) {\n            $this->_entries = DynamicFormEntry::forObject($this->id, 'U')->all();\n            if (!$this->_entries && $create) {\n                $g = UserForm::getNewInstance();\n                $g->setClientId($this->id);\n                $g->save();\n                $this->_entries[] = $g;\n            }\n        }\n\n        return $this->_entries ?: array();\n    }\n\n    function getFilterData() {\n        $vars = array();\n        foreach ($this->getDynamicData() as $entry) {\n            if ($entry->getDynamicForm()->get('type') != 'U')\n                continue;\n            $vars += $entry->getFilterData();\n            // Add in special `name` and `email` fields\n            foreach (array('name', 'email') as $name) {\n                if ($f = $entry->getField($name))\n                    $vars['field.'.$f->get('id')] =\n                        $name == 'name' ? $this->getName() : $this->getEmail();\n            }\n        }\n        return $vars;\n    }\n\n    function getForms($data=null) {\n\n        if (!isset($this->_forms)) {\n            $this->_forms = array();\n            foreach ($this->getDynamicData() as $entry) {\n                $entry->addMissingFields();\n                if(!$data\n                        && ($form = $entry->getDynamicForm())\n                        && $form->get('type') == 'U' ) {\n                    foreach ($entry->getFields() as $f) {\n                        if ($f->get('name') == 'name')\n                            $f->value = $this->getFullName();\n                        elseif ($f->get('name') == 'email')\n                            $f->value = $this->getEmail();\n                    }\n                }\n\n                $this->_forms[] = $entry;\n            }\n        }\n\n        return $this->_forms;\n    }\n\n    function getAccountStatus() {\n\n        if (!($account=$this->getAccount()))\n            return __('Guest');\n\n        return (string) $account->getStatus();\n    }\n\n    function canSeeOrgTickets() {\n        return $this->org && (\n                $this->org->shareWithEverybody()\n            || ($this->isPrimaryContact() && $this->org->shareWithPrimaryContacts()));\n    }\n\n    function register($vars, &$errors) {\n\n        // user already registered?\n        if ($this->getAccount())\n            return true;\n\n        return UserAccount::register($this, $vars, $errors);\n    }\n\n    static function importCsv($stream, $defaults=array()) {\n        require_once INCLUDE_DIR . 'class.import.php';\n\n        $importer = new CsvImporter($stream);\n        $imported = 0;\n        try {\n            db_autocommit(false);\n            $records = $importer->importCsv(UserForm::getUserForm()->getFields(), $defaults);\n            foreach ($records as $data) {\n                if (!Validator::is_email($data['email']) || empty($data['name']))\n                    throw new ImportError('Both `name` and `email` fields are required');\n                if (!($user = static::fromVars($data, true, true)))\n                    throw new ImportError(sprintf(__('Unable to import user: %s'),\n                        print_r(Format::htmlchars($data), true)));\n                $imported++;\n            }\n            db_autocommit(true);\n        }\n        catch (Exception $ex) {\n            db_rollback();\n            return $ex->getMessage();\n        }\n        return $imported;\n    }\n\n    function importFromPost($stream, $extra=array()) {\n        return User::importCsv($stream, $extra);\n    }\n\n    function updateInfo($vars, &$errors, $staff=false) {\n\n        $valid = true;\n        $forms = $this->getForms($vars);\n        foreach ($forms as $entry) {\n            $entry->setSource($vars);\n            if ($staff && !$entry->isValidForStaff())\n                $valid = false;\n            elseif (!$staff && !$entry->isValidForClient())\n                $valid = false;\n            elseif ($entry->getDynamicForm()->get('type') == 'U'\n                    && ($f=$entry->getField('email'))\n                    &&  $f->getClean()\n                    && ($u=User::lookup(array('emails__address'=>$f->getClean())))\n                    && $u->id != $this->getId()) {\n                $valid = false;\n                $f->addError(__('Email is assigned to another user'));\n            }\n\n            if (!$valid)\n                $errors = array_merge($errors, $entry->errors());\n        }\n\n\n        if (!$valid)\n            return false;\n\n        // Save the entries\n        foreach ($forms as $entry) {\n            if ($entry->getDynamicForm()->get('type') == 'U') {\n                //  Name field\n                if (($name = $entry->getField('name'))) {\n                    $name = $name->getClean();\n                    if (is_array($name))\n                        $name = implode(', ', $name);\n                    $this->name = $name;\n                }\n\n                // Email address field\n                if (($email = $entry->getField('email'))) {\n                    $this->default_email->address = $email->getClean();\n                    $this->default_email->save();\n                }\n            }\n\n            // DynamicFormEntry::save returns the number of answers updated\n            if ($entry->save()) {\n                $this->updated = SqlFunction::NOW();\n            }\n        }\n\n        return $this->save();\n    }\n\n\n    function save($refetch=false) {\n        // Drop commas and reorganize the name without them\n        $parts = array_map('trim', explode(',', $this->name));\n        switch (count($parts)) {\n            case 2:\n                // Assume last, first --or-- last suff., first\n                $this->name = $parts[1].' '.$parts[0];\n                // XXX: Consider last, first suff.\n                break;\n            case 3:\n                // Assume last, first, suffix, write 'first last suffix'\n                $this->name = $parts[1].' '.$parts[0].' '.$parts[2];\n                break;\n        }\n\n        // Handle email addresses -- use the box name\n        if (Validator::is_email($this->name)) {\n            list($box, $domain) = explode('@', $this->name, 2);\n            if (strpos($box, '.') !== false)\n                $this->name = str_replace('.', ' ', $box);\n            else\n                $this->name = $box;\n            $this->name = mb_convert_case($this->name, MB_CASE_TITLE);\n        }\n\n        if (count($this->dirty)) //XXX: doesn't work??\n            $this->set('updated', new SqlFunction('NOW'));\n        return parent::save($refetch);\n    }\n\n    function delete() {\n\n        // Refuse to delete a user with tickets\n        if ($this->tickets->count())\n            return false;\n\n        // Delete account record (if any)\n        if ($this->getAccount())\n            $this->getAccount()->delete();\n\n        // Delete emails.\n        $this->emails->expunge();\n\n        // Drop dynamic data\n        foreach ($this->getDynamicData() as $entry) {\n            $entry->delete();\n        }\n\n        // Delete user\n        return parent::delete();\n    }\n\n    function deleteAllTickets() {\n        $deleted = TicketStatus::lookup(array('state' => 'deleted'));\n        foreach($this->tickets as $ticket) {\n            if (!$T = Ticket::lookup($ticket->getId()))\n                continue;\n            if (!$T->setStatus($deleted))\n                return false;\n        }\n        $this->tickets->reset();\n        return true;\n    }\n\n    static function lookupByEmail($email) {\n        return static::lookup(array('emails__address'=>$email));\n    }\n\n    static function getNameById($id) {\n        if ($user = static::lookup($id))\n            return $user->getName();\n    }\n}\n\nclass EmailAddress\nimplements TemplateVariable {\n    var $address;\n\n    function __construct($address) {\n        $this->address = $address;\n    }\n\n    function __toString() {\n        return (string) $this->address;\n    }\n\n    function getVar($what) {\n        require_once PEAR_DIR . 'Mail/RFC822.php';\n        require_once PEAR_DIR . 'PEAR.php';\n        if (!($mails = Mail_RFC822::parseAddressList($this->address)) || PEAR::isError($mails))\n            return '';\n\n        if (count($mails) > 1)\n            return '';\n\n        $info = $mails[0];\n        switch ($what) {\n        case 'domain':\n            return $info->host;\n        case 'personal':\n            return trim($info->personal, '\"');\n        case 'mailbox':\n            return $info->mailbox;\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'domain' => __('Domain'),\n            'mailbox' => __('Mailbox'),\n            'personal' => __('Personal name'),\n        );\n    }\n}\n\nclass PersonsName\nimplements TemplateVariable {\n    var $format;\n    var $parts;\n    var $name;\n\n    static $formats = array(\n        'first' => array(     /*@trans*/ \"First\", 'getFirst'),\n        'last' => array(      /*@trans*/ \"Last\", 'getLast'),\n        'full' => array(      /*@trans*/ \"First Last\", 'getFull'),\n        'legal' => array(     /*@trans*/ \"First M. Last\", 'getLegal'),\n        'lastfirst' => array( /*@trans*/ \"Last, First\", 'getLastFirst'),\n        'formal' => array(    /*@trans*/ \"Mr. Last\", 'getFormal'),\n        'short' => array(     /*@trans*/ \"First L.\", 'getShort'),\n        'shortformal' => array(/*@trans*/ \"F. Last\", 'getShortFormal'),\n        'complete' => array(  /*@trans*/ \"Mr. First M. Last Sr.\", 'getComplete'),\n        'original' => array(  /*@trans*/ '-- As Entered --', 'getOriginal'),\n    );\n\n    function __construct($name, $format=null) {\n        global $cfg;\n\n        if ($format && isset(static::$formats[$format]))\n            $this->format = $format;\n        else\n            $this->format = 'original';\n\n        if (!is_array($name)) {\n            $this->parts = static::splitName($name);\n            $this->name = $name;\n        }\n        else {\n            $this->parts = $name;\n            $this->name = implode(' ', $name);\n        }\n    }\n\n    function getFirst() {\n        return $this->parts['first'];\n    }\n\n    function getLast() {\n        return $this->parts['last'];\n    }\n\n    function getMiddle() {\n        return $this->parts['middle'];\n    }\n\n    function getMiddleInitial() {\n        return mb_substr($this->parts['middle'],0,1).'.';\n    }\n\n    function getFormal() {\n        return trim($this->parts['salutation'].' '.$this->parts['last']);\n    }\n\n    function getFull() {\n        return trim($this->parts['first'].' '.$this->parts['last']);\n    }\n\n    function getLegal() {\n        $parts = array(\n            $this->parts['first'],\n            mb_substr($this->parts['middle'],0,1),\n            $this->parts['last'],\n        );\n        if ($parts[1]) $parts[1] .= '.';\n        return implode(' ', array_filter($parts));\n    }\n\n    function getComplete() {\n        $parts = array(\n            $this->parts['salutation'],\n            $this->parts['first'],\n            mb_substr($this->parts['middle'],0,1),\n            $this->parts['last'],\n            $this->parts['suffix']\n        );\n        if ($parts[2]) $parts[2] .= '.';\n        return implode(' ', array_filter($parts));\n    }\n\n    function getLastFirst() {\n        $name = $this->parts['last'].', '.$this->parts['first'];\n        if ($this->parts['suffix'])\n            $name .= ', '.$this->parts['suffix'];\n        return $name;\n    }\n\n    function getShort() {\n        return $this->parts['first'].' '.mb_substr($this->parts['last'],0,1).'.';\n    }\n\n    function getShortFormal() {\n        return mb_substr($this->parts['first'],0,1).'. '.$this->parts['last'];\n    }\n\n    function getOriginal() {\n        return $this->name;\n    }\n\n    function getInitials() {\n        $names = array($this->parts['first']);\n        $names = array_merge($names, explode(' ', $this->parts['middle']));\n        $names[] = $this->parts['last'];\n        $initials = '';\n        foreach (array_filter($names) as $n)\n            $initials .= mb_substr($n,0,1);\n        return mb_convert_case($initials, MB_CASE_UPPER);\n    }\n\n    function getName() {\n        return $this;\n    }\n\n    function asVar() {\n        return $this->__toString();\n    }\n\n    static function getVarScope() {\n        $formats = array();\n        foreach (static::$formats as $name=>$info) {\n            if (in_array($name, array('original', 'complete')))\n                continue;\n            $formats[$name] = $info[0];\n        }\n        return $formats;\n    }\n\n    function __toString() {\n\n        @list(, $func) = static::$formats[$this->format];\n        if (!$func) $func = 'getFull';\n\n        return (string) call_user_func(array($this, $func));\n    }\n\n    static function allFormats() {\n        return static::$formats;\n    }\n\n    /**\n     * Thanks, http://stackoverflow.com/a/14420217\n     */\n    static function splitName($name) {\n        $results = array();\n\n        $r = explode(' ', $name);\n        $size = count($r);\n\n        //check if name is bad format (ex: J.Everybody), and fix them\n        if($size==1 && mb_strpos($r[0], '.') !== false)\n        {\n            $r = explode('.', $name);\n            $size = count($r);\n        }\n\n        //check first for period, assume salutation if so\n        if (mb_strpos($r[0], '.') === false)\n        {\n            $results['salutation'] = '';\n            $results['first'] = $r[0];\n        }\n        else\n        {\n            $results['salutation'] = $r[0];\n            $results['first'] = $r[1];\n        }\n\n        //check last for period, assume suffix if so\n        if (mb_strpos($r[$size - 1], '.') === false)\n        {\n            $results['suffix'] = '';\n        }\n        else\n        {\n            $results['suffix'] = $r[$size - 1];\n        }\n\n        //combine remains into last\n        $start = ($results['salutation']) ? 2 : 1;\n        $end = ($results['suffix']) ? $size - 2 : $size - 1;\n\n        $middle = array();\n        for ($i = $start; $i <= $end; $i++)\n        {\n            $middle[] = $r[$i];\n        }\n        if (count($middle) > 1) {\n            $results['last'] = array_pop($middle);\n            $results['middle'] = implode(' ', $middle);\n        }\n        else {\n            $results['last'] = $middle[0];\n            $results['middle'] = '';\n        }\n\n        return $results;\n    }\n\n}\n\nclass AgentsName extends PersonsName {\n    function __construct($name, $format=null) {\n        global $cfg;\n\n        if (!$format && $cfg)\n            $format = $cfg->getAgentNameFormat();\n\n        parent::__construct($name, $format);\n    }\n}\n\nclass UsersName extends PersonsName {\n    function __construct($name, $format=null) {\n        global $cfg;\n        if (!$format && $cfg)\n            $format = $cfg->getClientNameFormat();\n\n        parent::__construct($name, $format);\n    }\n}\n\n\nclass UserEmail extends UserEmailModel {\n    static function ensure($address) {\n        $email = static::lookup(array('address'=>$address));\n        if (!$email) {\n            $email = new static(array('address'=>$address));\n            $email->save();\n        }\n        return $email;\n    }\n}\n\n\nclass UserAccount extends VerySimpleModel {\n    static $meta = array(\n        'table' => USER_ACCOUNT_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'user' => array(\n                'null' => false,\n                'constraint' => array('user_id' => 'User.id')\n            ),\n        ),\n    );\n\n    const LANG_MAILOUTS = 1;            // Language preference for mailouts\n\n    var $_status;\n    var $_extra;\n\n    function getStatus() {\n        if (!isset($this->_status))\n            $this->_status = new UserAccountStatus($this->get('status'));\n        return $this->_status;\n    }\n\n    protected function hasStatus($flag) {\n        return $this->getStatus()->check($flag);\n    }\n\n    protected function clearStatus($flag) {\n        return $this->set('status', $this->get('status') & ~$flag);\n    }\n\n    protected function setStatus($flag) {\n        return $this->set('status', $this->get('status') | $flag);\n    }\n\n    function confirm() {\n        $this->setStatus(UserAccountStatus::CONFIRMED);\n        return $this->save();\n    }\n\n    function isConfirmed() {\n        return $this->getStatus()->isConfirmed();\n    }\n\n    function lock() {\n        $this->setStatus(UserAccountStatus::LOCKED);\n        return $this->save();\n    }\n\n    function unlock() {\n        $this->clearStatus(UserAccountStatus::LOCKED);\n        return $this->save();\n    }\n\n    function isLocked() {\n        return $this->getStatus()->isLocked();\n    }\n\n    function forcePasswdReset() {\n        $this->setStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n        return $this->save();\n    }\n\n    function isPasswdResetForced() {\n        return $this->hasStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n    }\n\n    function isPasswdResetEnabled() {\n        return !$this->hasStatus(UserAccountStatus::FORBID_PASSWD_RESET);\n    }\n\n    function getInfo() {\n        return $this->ht;\n    }\n\n    function getId() {\n        return $this->get('id');\n    }\n\n    function getUserId() {\n        return $this->get('user_id');\n    }\n\n    function getUser() {\n        return $this->user;\n    }\n\n    function getExtraAttr($attr=false, $default=null) {\n        if (!isset($this->_extra))\n            $this->_extra = JsonDataParser::decode($this->get('extra', ''));\n\n        return $attr ? (@$this->_extra[$attr] ?: $default) : $this->_extra;\n    }\n\n    function setExtraAttr($attr, $value) {\n        $this->getExtraAttr();\n        $this->_extra[$attr] = $value;\n    }\n\n    /**\n     * Function: getLanguage\n     *\n     * Returns the language preference for the user or false if no\n     * preference is defined. False indicates the browser indicated\n     * preference should be used. For requests apart from browser requests,\n     * the last language preference of the browser is set in the\n     * 'browser_lang' extra attribute upon logins. Send the LANG_MAILOUTS\n     * flag to also consider this saved value. Such is useful when sending\n     * the user a message (such as an email), and the user's browser\n     * preference is not available in the HTTP request.\n     *\n     * Parameters:\n     * $flags - (int) Send UserAccount::LANG_MAILOUTS if the user's\n     *      last-known browser preference should be considered. Normally\n     *      only the user's saved language preference is considered.\n     *\n     * Returns:\n     * Current or last-known language preference or false if no language\n     * preference is currently set or known.\n     */\n    function getLanguage($flags=false) {\n        $lang = $this->get('lang', false);\n        if (!$lang && ($flags & UserAccount::LANG_MAILOUTS))\n            $lang = $this->getExtraAttr('browser_lang', false);\n\n        return $lang;\n    }\n\n    function getTimezone() {\n        return $this->timezone;\n    }\n\n    function save($refetch=false) {\n        // Serialize the extra column on demand\n        if (isset($this->_extra)) {\n            $this->extra = JsonDataEncoder::encode($this->_extra);\n        }\n        return parent::save($refetch);\n    }\n\n    function hasPassword() {\n        return (bool) $this->get('passwd');\n    }\n\n    function sendResetEmail() {\n        return static::sendUnlockEmail('pwreset-client') === true;\n    }\n\n    function sendConfirmEmail() {\n        return static::sendUnlockEmail('registration-client') === true;\n    }\n\n    function setPassword($new) {\n        $this->set('passwd', Passwd::hash($new));\n        // Clean sessions\n        Signal::send('auth.clean', $this->getUser());\n    }\n\n    protected function sendUnlockEmail($template) {\n        global $ost, $cfg;\n\n        $token = Misc::randCode(48); // 290-bits\n\n        $email = $cfg->getDefaultEmail();\n        $content = Page::lookupByType($template);\n\n        if (!$email ||  !$content)\n            return new BaseError(sprintf(_S('%s: Unable to retrieve template'),\n                $template));\n\n        $vars = array(\n            'url' => $ost->getConfig()->getBaseUrl(),\n            'token' => $token,\n            'user' => $this->getUser(),\n            'recipient' => $this->getUser(),\n            'link' => sprintf(\n                \"%s/pwreset.php?token=%s\",\n                $ost->getConfig()->getBaseUrl(),\n                $token),\n        );\n        $vars['reset_link'] = &$vars['link'];\n\n        $info = array('email' => $email, 'vars' => &$vars, 'log'=>true);\n        Signal::send('auth.pwreset.email', $this->getUser(), $info);\n\n        $lang = $this->getLanguage(UserAccount::LANG_MAILOUTS);\n        $msg = $ost->replaceTemplateVariables(array(\n            'subj' => $content->getLocalName($lang),\n            'body' => $content->getLocalBody($lang),\n        ), $vars);\n\n        $_config = new Config('pwreset');\n        $_config->set($vars['token'], 'c'.$this->getUser()->getId());\n\n        $email->send($this->getUser()->getEmail(),\n            Format::striptags($msg['subj']), $msg['body']);\n\n        return true;\n    }\n\n    function __toString() {\n        return (string) $this->getStatus();\n    }\n\n    /*\n     * This assumes the staff is doing the update\n     */\n    function update($vars, &$errors) {\n        global $thisstaff;\n\n\n        if (!$thisstaff) {\n            $errors['err'] = __('Access denied');\n            return false;\n        }\n\n        // TODO: Make sure the username is unique\n\n        // Timezone selection is not required. System default is a valid\n        // fallback\n\n        // Changing password?\n        if ($vars['passwd1'] || $vars['passwd2']) {\n            if (!$vars['passwd1'])\n                $errors['passwd1'] = __('New password is required');\n            elseif ($vars['passwd1'] && strlen($vars['passwd1'])<6)\n                $errors['passwd1'] = __('Must be at least 6 characters');\n            elseif ($vars['passwd1'] && strcmp($vars['passwd1'], $vars['passwd2']))\n                $errors['passwd2'] = __('Passwords do not match');\n        }\n\n        // Make sure the username is not an email.\n        if ($vars['username'] && Validator::is_email($vars['username']))\n            $errors['username'] =\n                __('Users can always sign in with their email address');\n\n        if ($errors) return false;\n\n        $this->set('timezone', $vars['timezone']);\n        $this->set('username', $vars['username']);\n\n        if ($vars['passwd1']) {\n            $this->setPassword($vars['passwd1']);\n            $this->setStatus(UserAccountStatus::CONFIRMED);\n        }\n\n        // Set flags\n        foreach (array(\n                'pwreset-flag' => UserAccountStatus::REQUIRE_PASSWD_RESET,\n                'locked-flag' => UserAccountStatus::LOCKED,\n                'forbid-pwchange-flag' => UserAccountStatus::FORBID_PASSWD_RESET\n        ) as $ck=>$flag) {\n            if ($vars[$ck])\n                $this->setStatus($flag);\n            else\n                $this->clearStatus($flag);\n        }\n\n        return $this->save(true);\n    }\n\n    static function createForUser($user, $defaults=false) {\n        $acct = new static(array('user_id'=>$user->getId()));\n        if ($defaults && is_array($defaults)) {\n            foreach ($defaults as $k => $v)\n                $acct->set($k, $v);\n        }\n        return $acct;\n    }\n\n    static function lookupByUsername($username) {\n        if (strpos($username, '@') !== false)\n            $user = static::lookup(array('user__emails__address'=>$username));\n        else\n            $user = static::lookup(array('username'=>$username));\n\n        return $user;\n    }\n\n    static function register($user, $vars, &$errors) {\n\n        if (!$user || !$vars)\n            return false;\n\n        //Require temp password.\n        if ((!$vars['backend'] || $vars['backend'] != 'client')\n                && !isset($vars['sendemail'])) {\n            if (!$vars['passwd1'])\n                $errors['passwd1'] = 'Temporary password required';\n            elseif ($vars['passwd1'] && strlen($vars['passwd1'])<6)\n                $errors['passwd1'] = 'Must be at least 6 characters';\n            elseif ($vars['passwd1'] && strcmp($vars['passwd1'], $vars['passwd2']))\n                $errors['passwd2'] = 'Passwords do not match';\n        }\n\n        if ($errors) return false;\n\n        $account = new UserAccount(array(\n            'user_id' => $user->getId(),\n            'timezone' => $vars['timezone'],\n            'backend' => $vars['backend'],\n        ));\n\n        if ($vars['username'] && strcasecmp($vars['username'], $user->getEmail()))\n            $account->set('username', $vars['username']);\n\n        if ($vars['passwd1'] && !$vars['sendemail']) {\n            $account->set('passwd', Passwd::hash($vars['passwd1']));\n            $account->setStatus(UserAccountStatus::CONFIRMED);\n            if ($vars['pwreset-flag'])\n                $account->setStatus(UserAccountStatus::REQUIRE_PASSWD_RESET);\n            if ($vars['forbid-pwreset-flag'])\n                $account->setStatus(UserAccountStatus::FORBID_PASSWD_RESET);\n        }\n        elseif ($vars['backend'] && $vars['backend'] != 'client') {\n            // Auto confirm remote accounts\n            $account->setStatus(UserAccountStatus::CONFIRMED);\n        }\n\n        $account->save(true);\n\n        if (!$account->isConfirmed() && $vars['sendemail'])\n            $account->sendConfirmEmail();\n\n        return $account;\n    }\n\n}\n\nclass UserAccountStatus {\n\n    var $flag;\n\n    const CONFIRMED             = 0x0001;\n    const LOCKED                = 0x0002;\n    const REQUIRE_PASSWD_RESET  = 0x0004;\n    const FORBID_PASSWD_RESET   = 0x0008;\n\n    function __construct($flag) {\n        $this->flag = $flag;\n    }\n\n    function check($flag) {\n        return 0 !== ($this->flag & $flag);\n    }\n\n    function isLocked() {\n        return $this->check(self::LOCKED);\n    }\n\n    function isConfirmed() {\n        return $this->check(self::CONFIRMED);\n    }\n\n    function __toString() {\n\n        if ($this->isLocked())\n            return __('Locked (Administrative)');\n\n        if (!$this->isConfirmed())\n            return __('Locked (Pending Activation)');\n\n        // ... Other flags here (password reset, etc).\n\n        return __('Active (Registered)');\n    }\n}\n\n\n/*\n *  Generic user list.\n */\nclass UserList extends ListObject\nimplements TemplateVariable {\n\n    function __toString() {\n        return $this->getNames();\n    }\n\n    function getNames() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list [] = $user->getName();\n        }\n        return $list ? implode(', ', $list) : '';\n    }\n\n    function getFull() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list[] = sprintf(\"%s <%s>\", $user->getName(), $user->getEmail());\n        }\n\n        return $list ? implode(', ', $list) : '';\n    }\n\n    function getEmails() {\n        $list = array();\n        foreach($this->storage as $user) {\n            if (is_object($user))\n                $list[] = $user->getEmail();\n        }\n        return $list ? implode(', ', $list) : '';\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of names'),\n            'emails' => __('List of email addresses'),\n            'full' => __('List of names and email addresses'),\n        );\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    class.validator.php\n\n    Input validation helper. This class contains collection of functions used for data validation.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nclass Validator {\n\n    var $input=array();\n    var $fields=array();\n    var $errors=array();\n\n    function __construct($fields=null) {\n        $this->setFields($fields);\n    }\n    function setFields(&$fields){\n\n        if($fields && is_array($fields)):\n            $this->fields=$fields;\n            return (true);\n        endif;\n\n        return (false);\n    }\n\n\n    function validate($source,$userinput=true){\n        $this->errors=array();\n        //Check the input and make sure the fields are specified.\n        if(!$source || !is_array($source))\n            $this->errors['err']=__('Invalid input');\n        elseif(!$this->fields || !is_array($this->fields))\n            $this->errors['err']=__('No fields set up');\n        //Abort on error\n        if($this->errors)\n            return false;\n\n        //if magic quotes are enabled - then try cleaning up inputs before validation...\n        if($userinput && function_exists('get_magic_quotes_gpc') && get_magic_quotes_gpc())\n            $source=Format::strip_slashes($source);\n\n\n        $this->input=$source;\n\n        //Do the do.\n        foreach($this->fields as $k=>$field){\n            if(!$field['required'] && !$this->input[$k]) //NOT required...and no data provided...\n                continue;\n\n            if($field['required'] && !isset($this->input[$k]) || (!$this->input[$k] && $field['type']!='int')){ //Required...and no data provided...\n                $this->errors[$k]=$field['error'];\n                continue;\n            }\n\n            //We don't care about the type.\n            if ($field['type'] == '*') continue;\n\n            //Do the actual validation based on the type.\n            switch(strtolower($field['type'])):\n            case 'integer':\n            case 'int':\n                if(!is_numeric($this->input[$k]))\n                     $this->errors[$k]=$field['error'];\n                elseif ($field['min'] && $this->input[$k] < $field['min'])\n                     $this->errors[$k]=$field['error'];\n                break;\n            case 'double':\n                if(!is_numeric($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'text':\n            case 'string':\n                if(!is_string($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'array':\n                if(!$this->input[$k] || !is_array($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'radio':\n                if(!isset($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'date': //TODO...make sure it is really in GNU date format..\n                if(strtotime($this->input[$k])===false)\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'time': //TODO...make sure it is really in GNU time format..\n                break;\n            case 'phone':\n            case 'fax':\n                if(!self::is_phone($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'email':\n                if(!self::is_email($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'url':\n                if(!self::is_url($this->input[$k]))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'password':\n                if(strlen($this->input[$k])<5)\n                    $this->errors[$k]=$field['error'].' '.__('(Five characters min)');\n                break;\n            case 'username':\n                $error = '';\n                if (!self::is_username($this->input[$k], $error))\n                    $this->errors[$k]=$field['error'].\": $error\";\n                break;\n            case 'zipcode':\n                if(!is_numeric($this->input[$k]) || (strlen($this->input[$k])!=5))\n                    $this->errors[$k]=$field['error'];\n                break;\n            case 'cs-domain': // Comma separated list of domains\n                if($values=explode(',', $this->input[$k]))\n                    foreach($values as $v)\n                        if(!preg_match_all(\n                                '/^(https?:\\/\\/)?((\\*\\.|\\w+\\.)?[\\w-]+(\\.[a-zA-Z]+)?(:([0-9]+|\\*))?)+$/',\n                                ltrim($v)))\n                            $this->errors[$k]=$field['error'];\n                break;\n            default://If param type is not set...or handle..error out...\n                $this->errors[$k]=$field['error'].' '.__('(type not set)');\n            endswitch;\n        }\n        return ($this->errors)?(FALSE):(TRUE);\n    }\n\n    function iserror(){\n        return $this->errors?true:false;\n    }\n\n    function errors(){\n        return $this->errors;\n    }\n\n    /*** Functions below can be called directly without class instance.\n         Validator::func(var..);  (nolint) ***/\n    static function is_email($email, $list=false, $verify=false) {\n        require_once PEAR_DIR . 'Mail/RFC822.php';\n        require_once PEAR_DIR . 'PEAR.php';\n        $rfc822 = new Mail_RFC822();\n        if (!($mails = $rfc822->parseAddressList($email)) || PEAR::isError($mails))\n            return false;\n\n        if (!$list && count($mails) > 1)\n            return false;\n\n        foreach ($mails as $m) {\n            if (!$m->mailbox)\n                return false;\n            if ($m->host == 'localhost')\n                return false;\n        }\n\n        // According to RFC2821, the domain (A record) can be treated as an\n        // MX if no MX records exist for the domain. Also, include a\n        // full-stop trailing char so that the default domain of the server\n        // is not added automatically\n        if ($verify and !count(dns_get_record($m->host.'.', DNS_MX)))\n            return 0 < count(dns_get_record($m->host.'.', DNS_A|DNS_AAAA));\n\n        return true;\n    }\n\n    static function is_valid_email($email) {\n        global $cfg;\n        // Default to FALSE for installation\n        return self::is_email($email, false, $cfg && $cfg->verifyEmailAddrs());\n    }\n\n    static function is_phone($phone) {\n        /* We're not really validating the phone number but just making sure it doesn't contain illegal chars and of acceptable len */\n        $stripped=preg_replace(\"(\\(|\\)|\\-|\\.|\\+|[  ]+)\",\"\",$phone);\n        return (!is_numeric($stripped) || ((strlen($stripped)<7) || (strlen($stripped)>16)))?false:true;\n    }\n\n    static function is_url($url) {\n        //XXX: parse_url is not ideal for validating urls but it's ideal for basic checks.\n        return ($url && ($info=parse_url($url)) && $info['host']);\n    }\n\n    static function is_ip($ip) {\n        return filter_var(trim($ip), FILTER_VALIDATE_IP) !== false;\n    }\n\n    static function is_username($username, &$error='') {\n        if (strlen($username)<2)\n            $error = __('Username must have at least two (2) characters');\n        elseif (!preg_match('/^[\\p{L}\\d._-]+$/u', $username))\n            $error = __('Username contains invalid characters');\n        return $error == '';\n    }\n\n    static function is_formula($text, &$error='') {\n        if (!preg_match('/^[^=\\+@-].*$/', $text))\n            $error = __('Content cannot start with the following characters: = - + @');\n        return $error == '';\n    }\n\n    /*\n     * check_ip\n     * Checks if an IP (IPv4 or IPv6) address is contained in the list of given IPs or subnets.\n     *\n     * @credit - borrowed from Symfony project\n     *\n     */\n    public static function check_ip($ip, $ips) {\n\n        if (!Validator::is_ip($ip))\n            return false;\n\n        $method = substr_count($ip, ':') > 1 ? 'check_ipv6' : 'check_ipv4';\n        $ips = is_array($ips) ? $ips : array($ips);\n        foreach ($ips as $_ip) {\n            if (self::$method($ip, $_ip)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * check_ipv4\n     * Compares two IPv4 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @credit - borrowed from Symfony project\n     */\n    public static function check_ipv4($ip, $cidr) {\n\n        if (false !== strpos($cidr, '/')) {\n            list($address, $netmask) = explode('/', $cidr, 2);\n\n            if ($netmask === '0')\n                return filter_var($address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4);\n\n            if ($netmask < 0 || $netmask > 32)\n                return false;\n\n        } else {\n            $address = $cidr;\n            $netmask = 32;\n        }\n\n        return 0 === substr_compare(\n                sprintf('%032b', ip2long($ip)),\n                sprintf('%032b', ip2long($address)),\n                0, $netmask);\n    }\n\n    /**\n     * Compares two IPv6 addresses.\n     * In case a subnet is given, it checks if it contains the request IP.\n     *\n     * @credit - borrowed from Symfony project\n     * @author David Soria Parra <dsp at php dot net>\n     *\n     * @see https://github.com/dsp/v6tools\n     *\n     */\n    public static function check_ipv6($ip, $cidr) {\n\n        if (!((extension_loaded('sockets') && defined('AF_INET6')) || @inet_pton('::1')))\n            return false;\n\n        if (false !== strpos($cidr, '/')) {\n            list($address, $netmask) = explode('/', $cidr, 2);\n            if ($netmask < 1 || $netmask > 128)\n                return false;\n        } else {\n            $address = $cidr;\n            $netmask = 128;\n        }\n\n        $bytesAddr = unpack('n*', @inet_pton($address));\n        $bytesTest = unpack('n*', @inet_pton($ip));\n        if (!$bytesAddr || !$bytesTest)\n            return false;\n\n        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {\n            $left = $netmask - 16 * ($i - 1);\n            $left = ($left <= 16) ? $left : 16;\n            $mask = ~(0xffff >> $left) & 0xffff;\n            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function process($fields,$vars,&$errors){\n\n        $val = new Validator();\n        $val->setFields($fields);\n        if(!$val->validate($vars))\n            $errors=array_merge($errors,$val->errors());\n\n        return (!$errors);\n    }\n}\n?>\n"], "filenames": ["include/class.export.php", "include/class.forms.php", "include/class.user.php", "include/class.validator.php"], "buggy_code_start_loc": [359, 1303, 251, 206], "buggy_code_end_loc": [360, 1379, 252, 206], "fixing_code_start_loc": [359, 1303, 251, 207], "fixing_code_end_loc": [366, 1404, 252, 212], "type": "CWE-1236", "message": "An issue was discovered in osTicket before 1.10.7 and 1.12.x before 1.12.1. CSV (aka Formula) injection exists in the export spreadsheets functionality. These spreadsheets are generated dynamically from unvalidated or unfiltered user input in the Name and Internal Notes fields in the Users tab, and the Issue Summary field in the tickets tab. This allows other agents to download data in a .csv file format or .xls file format. This is used as input for spreadsheet applications such as Excel and OpenOffice Calc, resulting in a situation where cells in the spreadsheets can contain input from an untrusted source. As a result, the end user who is accessing the exported spreadsheet can be affected.", "other": {"cve": {"id": "CVE-2019-14749", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-07T17:15:12.480", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in osTicket before 1.10.7 and 1.12.x before 1.12.1. CSV (aka Formula) injection exists in the export spreadsheets functionality. These spreadsheets are generated dynamically from unvalidated or unfiltered user input in the Name and Internal Notes fields in the Users tab, and the Issue Summary field in the tickets tab. This allows other agents to download data in a .csv file format or .xls file format. This is used as input for spreadsheet applications such as Excel and OpenOffice Calc, resulting in a situation where cells in the spreadsheets can contain input from an untrusted source. As a result, the end user who is accessing the exported spreadsheet can be affected."}, {"lang": "es", "value": "Se detect\u00f3 un problema en osTicket versiones anteriores a 1.10.7 y versiones 1.12.x anteriores a 1.12.1. Una inyecci\u00f3n CSV (tambi\u00e9n se conoce como Formula) se presenta en la funcionalidad export spreadsheets. Estas hojas de c\u00e1lculo se generan din\u00e1micamente a partir de la entrada de usuario no comprobada o no filtrada en los campos Name y Internal Notes de la pesta\u00f1a Users y el campo Issue Summary de la pesta\u00f1a Tickets. Esto permite a otros agentes descargar datos en formato de archivo .csv o .xls. Esto es usado como entrada para aplicaciones de hoja de c\u00e1lculo como Excel y OpenOffice Calc, lo que resulta en una situaci\u00f3n en la que las celdas de las hojas de c\u00e1lculo pueden contener entradas de una fuente no confiable. Como resultado, el usuario final que accede a la hoja de c\u00e1lculo exportada puede estar afectado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osticket:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.7", "matchCriteriaId": "2D6B0B54-FE0E-41EB-953D-6A72FFB7B724"}, {"vulnerable": true, "criteria": "cpe:2.3:a:osticket:osticket:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.12", "versionEndExcluding": "1.12.1", "matchCriteriaId": "4874A3A8-A938-4E25-B01A-5366E34B2A28"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/154004/osTicket-1.12-Formula-Injection.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/osTicket/osTicket/commit/99818486c5b1d8aa445cee232825418d6834f249", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/osTicket/osTicket/releases/tag/v1.10.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/osTicket/osTicket/releases/tag/v1.12.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/47225", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/osTicket/osTicket/commit/99818486c5b1d8aa445cee232825418d6834f249"}}