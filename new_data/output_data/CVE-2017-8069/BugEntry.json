{"buggy_code": ["/*\n *  Copyright (c) 2002 Petko Manolov (petkan@users.sourceforge.net)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n */\n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/uaccess.h>\n\n/* Version Information */\n#define DRIVER_VERSION \"v0.6.2 (2004/08/27)\"\n#define DRIVER_AUTHOR \"Petko Manolov <petkan@users.sourceforge.net>\"\n#define DRIVER_DESC \"rtl8150 based usb-ethernet driver\"\n\n#define\tIDR\t\t\t0x0120\n#define\tMAR\t\t\t0x0126\n#define\tCR\t\t\t0x012e\n#define\tTCR\t\t\t0x012f\n#define\tRCR\t\t\t0x0130\n#define\tTSR\t\t\t0x0132\n#define\tRSR\t\t\t0x0133\n#define\tCON0\t\t\t0x0135\n#define\tCON1\t\t\t0x0136\n#define\tMSR\t\t\t0x0137\n#define\tPHYADD\t\t\t0x0138\n#define\tPHYDAT\t\t\t0x0139\n#define\tPHYCNT\t\t\t0x013b\n#define\tGPPC\t\t\t0x013d\n#define\tBMCR\t\t\t0x0140\n#define\tBMSR\t\t\t0x0142\n#define\tANAR\t\t\t0x0144\n#define\tANLP\t\t\t0x0146\n#define\tAER\t\t\t0x0148\n#define CSCR\t\t\t0x014C  /* This one has the link status */\n#define CSCR_LINK_STATUS\t(1 << 3)\n\n#define\tIDR_EEPROM\t\t0x1202\n\n#define\tPHY_READ\t\t0\n#define\tPHY_WRITE\t\t0x20\n#define\tPHY_GO\t\t\t0x40\n\n#define\tMII_TIMEOUT\t\t10\n#define\tINTBUFSIZE\t\t8\n\n#define\tRTL8150_REQT_READ\t0xc0\n#define\tRTL8150_REQT_WRITE\t0x40\n#define\tRTL8150_REQ_GET_REGS\t0x05\n#define\tRTL8150_REQ_SET_REGS\t0x05\n\n\n/* Transmit status register errors */\n#define TSR_ECOL\t\t(1<<5)\n#define TSR_LCOL\t\t(1<<4)\n#define TSR_LOSS_CRS\t\t(1<<3)\n#define TSR_JBR\t\t\t(1<<2)\n#define TSR_ERRORS\t\t(TSR_ECOL | TSR_LCOL | TSR_LOSS_CRS | TSR_JBR)\n/* Receive status register errors */\n#define RSR_CRC\t\t\t(1<<2)\n#define RSR_FAE\t\t\t(1<<1)\n#define RSR_ERRORS\t\t(RSR_CRC | RSR_FAE)\n\n/* Media status register definitions */\n#define MSR_DUPLEX\t\t(1<<4)\n#define MSR_SPEED\t\t(1<<3)\n#define MSR_LINK\t\t(1<<2)\n\n/* Interrupt pipe data */\n#define INT_TSR\t\t\t0x00\n#define INT_RSR\t\t\t0x01\n#define INT_MSR\t\t\t0x02\n#define INT_WAKSR\t\t0x03\n#define INT_TXOK_CNT\t\t0x04\n#define INT_RXLOST_CNT\t\t0x05\n#define INT_CRERR_CNT\t\t0x06\n#define INT_COL_CNT\t\t0x07\n\n\n#define\tRTL8150_MTU\t\t1540\n#define\tRTL8150_TX_TIMEOUT\t(HZ)\n#define\tRX_SKB_POOL_SIZE\t4\n\n/* rtl8150 flags */\n#define\tRTL8150_HW_CRC\t\t0\n#define\tRX_REG_SET\t\t1\n#define\tRTL8150_UNPLUG\t\t2\n#define\tRX_URB_FAIL\t\t3\n\n/* Define these values to match your device */\n#define\tVENDOR_ID_REALTEK\t\t0x0bda\n#define\tVENDOR_ID_MELCO\t\t\t0x0411\n#define\tVENDOR_ID_MICRONET\t\t0x3980\n#define\tVENDOR_ID_LONGSHINE\t\t0x07b8\n#define\tVENDOR_ID_OQO\t\t\t0x1557\n#define\tVENDOR_ID_ZYXEL\t\t\t0x0586\n\n#define PRODUCT_ID_RTL8150\t\t0x8150\n#define\tPRODUCT_ID_LUAKTX\t\t0x0012\n#define\tPRODUCT_ID_LCS8138TX\t\t0x401a\n#define PRODUCT_ID_SP128AR\t\t0x0003\n#define\tPRODUCT_ID_PRESTIGE\t\t0x401a\n\n#undef\tEEPROM_WRITE\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id rtl8150_table[] = {\n\t{USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_MELCO, PRODUCT_ID_LUAKTX)},\n\t{USB_DEVICE(VENDOR_ID_MICRONET, PRODUCT_ID_SP128AR)},\n\t{USB_DEVICE(VENDOR_ID_LONGSHINE, PRODUCT_ID_LCS8138TX)},\n\t{USB_DEVICE(VENDOR_ID_OQO, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_ZYXEL, PRODUCT_ID_PRESTIGE)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl8150_table);\n\nstruct rtl8150 {\n\tunsigned long flags;\n\tstruct usb_device *udev;\n\tstruct tasklet_struct tl;\n\tstruct net_device *netdev;\n\tstruct urb *rx_urb, *tx_urb, *intr_urb;\n\tstruct sk_buff *tx_skb, *rx_skb;\n\tstruct sk_buff *rx_skb_pool[RX_SKB_POOL_SIZE];\n\tspinlock_t rx_pool_lock;\n\tstruct usb_ctrlrequest dr;\n\tint intr_interval;\n\tu8 *intr_buff;\n\tu8 phy;\n};\n\ntypedef struct rtl8150 rtl8150_t;\n\nstruct async_req {\n\tstruct usb_ctrlrequest dr;\n\tu16 rx_creg;\n};\n\nstatic const char driver_name [] = \"rtl8150\";\n\n/*\n**\n**\tdevice related part of the code\n**\n*/\nstatic int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}\n\nstatic int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}\n\nstatic void async_set_reg_cb(struct urb *urb)\n{\n\tstruct async_req *req = (struct async_req *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int async_set_registers(rtl8150_t *dev, u16 indx, u16 size, u16 reg)\n{\n\tint res = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct async_req *req;\n\n\treq = kmalloc(sizeof(struct async_req), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn res;\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn res;\n\t}\n\treq->rx_creg = cpu_to_le16(reg);\n\treq->dr.bRequestType = RTL8150_REQT_WRITE;\n\treq->dr.bRequest = RTL8150_REQ_SET_REGS;\n\treq->dr.wIndex = 0;\n\treq->dr.wValue = cpu_to_le16(indx);\n\treq->dr.wLength = cpu_to_le16(size);\n\tusb_fill_control_urb(async_urb, dev->udev,\n\t                     usb_sndctrlpipe(dev->udev, 0), (void *)&req->dr,\n\t\t\t     &req->rx_creg, size, async_set_reg_cb, req);\n\tres = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (res) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_err(&dev->udev->dev, \"%s failed with %d\\n\", __func__, res);\n\t}\n\treturn res;\n}\n\nstatic int read_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 * reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = data[2] = 0;\n\ttmp = indx | PHY_READ | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT) {\n\t\tget_registers(dev, PHYDAT, 2, data);\n\t\t*reg = data[0] | (data[1] << 8);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nstatic int write_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = reg & 0xff;\n\tdata[2] = (reg >> 8) & 0xff;\n\ttmp = indx | PHY_WRITE | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic inline void set_ethernet_addr(rtl8150_t * dev)\n{\n\tu8 node_id[6];\n\n\tget_registers(dev, IDR, sizeof(node_id), node_id);\n\tmemcpy(dev->netdev->dev_addr, node_id, sizeof(node_id));\n}\n\nstatic int rtl8150_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\n\tnetdev_dbg(netdev, \"Setting MAC address to %pM\\n\", netdev->dev_addr);\n\t/* Set the IDR registers. */\n\tset_registers(dev, IDR, netdev->addr_len, netdev->dev_addr);\n#ifdef EEPROM_WRITE\n\t{\n\tint i;\n\tu8 cr;\n\t/* Get the CR contents. */\n\tget_registers(dev, CR, 1, &cr);\n\t/* Set the WEPROM bit (eeprom write enable). */\n\tcr |= 0x20;\n\tset_registers(dev, CR, 1, &cr);\n\t/* Write the MAC address into eeprom. Eeprom writes must be word-sized,\n\t   so we need to split them up. */\n\tfor (i = 0; i * 2 < netdev->addr_len; i++) {\n\t\tset_registers(dev, IDR_EEPROM + (i * 2), 2,\n\t\tnetdev->dev_addr + (i * 2));\n\t}\n\t/* Clear the WEPROM bit (preventing accidental eeprom writes). */\n\tcr &= 0xdf;\n\tset_registers(dev, CR, 1, &cr);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int rtl8150_reset(rtl8150_t * dev)\n{\n\tu8 data = 0x10;\n\tint i = HZ;\n\n\tset_registers(dev, CR, 1, &data);\n\tdo {\n\t\tget_registers(dev, CR, 1, &data);\n\t} while ((data & 0x10) && --i);\n\n\treturn (i > 0) ? 1 : 0;\n}\n\nstatic int alloc_all_urbs(rtl8150_t * dev)\n{\n\tdev->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->rx_urb)\n\t\treturn 0;\n\tdev->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->tx_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\treturn 0;\n\t}\n\tdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->intr_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\tusb_free_urb(dev->tx_urb);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_all_urbs(rtl8150_t * dev)\n{\n\tusb_free_urb(dev->rx_urb);\n\tusb_free_urb(dev->tx_urb);\n\tusb_free_urb(dev->intr_urb);\n}\n\nstatic void unlink_all_urbs(rtl8150_t * dev)\n{\n\tusb_kill_urb(dev->rx_urb);\n\tusb_kill_urb(dev->tx_urb);\n\tusb_kill_urb(dev->intr_urb);\n}\n\nstatic inline struct sk_buff *pull_skb(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i]) {\n\t\t\tskb = dev->rx_skb_pool[i];\n\t\t\tdev->rx_skb_pool[i] = NULL;\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tunsigned pkt_len, res;\n\tstruct sk_buff *skb;\n\tstruct net_device *netdev;\n\tu16 rx_stat;\n\tint status = urb->status;\n\tint result;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tif (test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\treturn;\n\tnetdev = dev->netdev;\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\t\treturn;\t/* the urb is in unlink state */\n\tcase -ETIME:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"may be reset is needed?..\\n\");\n\t\tgoto goon;\n\tdefault:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"Rx status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (!dev->rx_skb)\n\t\tgoto resched;\n\t/* protect against short packets (tell me why we got some?!?) */\n\tif (urb->actual_length < 4)\n\t\tgoto goon;\n\n\tres = urb->actual_length;\n\trx_stat = le16_to_cpu(*(__le16 *)(urb->transfer_buffer + res - 4));\n\tpkt_len = res - 4;\n\n\tskb_put(dev->rx_skb, pkt_len);\n\tdev->rx_skb->protocol = eth_type_trans(dev->rx_skb, netdev);\n\tnetif_rx(dev->rx_skb);\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += pkt_len;\n\n\tspin_lock(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock(&dev->rx_pool_lock);\n\tif (!skb)\n\t\tgoto resched;\n\n\tdev->rx_skb = skb;\ngoon:\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tresult = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (result == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (result) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto resched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\nresched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tdev_kfree_skb_irq(dev->tx_skb);\n\tif (!netif_device_present(dev->netdev))\n\t\treturn;\n\tif (status)\n\t\tdev_info(&urb->dev->dev, \"%s: Tx status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\tnetif_trans_update(dev->netdev);\n\tnetif_wake_queue(dev->netdev);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\t__u8 *d;\n\tint status = urb->status;\n\tint res;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tdev_info(&urb->dev->dev, \"%s: intr status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (d[0] & TSR_ERRORS) {\n\t\tdev->netdev->stats.tx_errors++;\n\t\tif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\n\t\t\tdev->netdev->stats.tx_aborted_errors++;\n\t\tif (d[INT_TSR] & TSR_LCOL)\n\t\t\tdev->netdev->stats.tx_window_errors++;\n\t\tif (d[INT_TSR] & TSR_LOSS_CRS)\n\t\t\tdev->netdev->stats.tx_carrier_errors++;\n\t}\n\t/* Report link status changes to the network stack */\n\tif ((d[INT_MSR] & MSR_LINK) == 0) {\n\t\tif (netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_off(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK LOST\\n\", __func__);\n\t\t}\n\t} else {\n\t\tif (!netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_on(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK CAME BACK\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (res)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"can't resubmit intr, %s-%s/input0, status %d\\n\",\n\t\t\tdev->udev->bus->bus_name, dev->udev->devpath, res);\n}\n\nstatic int rtl8150_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_detach(dev->netdev);\n\n\tif (netif_running(dev->netdev)) {\n\t\tusb_kill_urb(dev->rx_urb);\n\t\tusb_kill_urb(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int rtl8150_resume(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_attach(dev->netdev);\n\tif (netif_running(dev->netdev)) {\n\t\tdev->rx_urb->status = 0;\n\t\tdev->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(dev->rx_urb);\n\n\t\tdev->intr_urb->status = 0;\n\t\tdev->intr_urb->actual_length = 0;\n\t\tintr_callback(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\n/*\n**\n**\tnetwork related part of the code\n**\n*/\n\nstatic void fill_skb_pool(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i])\n\t\t\tcontinue;\n\t\tskb = dev_alloc_skb(RTL8150_MTU + 2);\n\t\tif (!skb) {\n\t\t\treturn;\n\t\t}\n\t\tskb_reserve(skb, 2);\n\t\tdev->rx_skb_pool[i] = skb;\n\t}\n}\n\nstatic void free_skb_pool(rtl8150_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++)\n\t\tif (dev->rx_skb_pool[i])\n\t\t\tdev_kfree_skb(dev->rx_skb_pool[i]);\n}\n\nstatic void rx_fixup(unsigned long data)\n{\n\tstruct rtl8150 *dev = (struct rtl8150 *)data;\n\tstruct sk_buff *skb;\n\tint status;\n\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tfill_skb_pool(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (test_bit(RX_URB_FAIL, &dev->flags))\n\t\tif (dev->rx_skb)\n\t\t\tgoto try_again;\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (skb == NULL)\n\t\tgoto tlsched;\n\tdev->rx_skb = skb;\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\ntry_again:\n\tstatus = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV) {\n\t\tnetif_device_detach(dev->netdev);\n\t} else if (status) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto tlsched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\ntlsched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic int enable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr, tcr, rcr, msr;\n\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_warn(&dev->udev->dev, \"device reset failed\\n\");\n\t}\n\t/* RCR bit7=1 attach Rx info at the end;  =0 HW CRC (which is broken) */\n\trcr = 0x9e;\n\ttcr = 0xd8;\n\tcr = 0x0c;\n\tif (!(rcr & 0x80))\n\t\tset_bit(RTL8150_HW_CRC, &dev->flags);\n\tset_registers(dev, RCR, 1, &rcr);\n\tset_registers(dev, TCR, 1, &tcr);\n\tset_registers(dev, CR, 1, &cr);\n\tget_registers(dev, MSR, 1, &msr);\n\n\treturn 0;\n}\n\nstatic void disable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr;\n\n\tget_registers(dev, CR, 1, &cr);\n\tcr &= 0xf3;\n\tset_registers(dev, CR, 1, &cr);\n}\n\nstatic void rtl8150_tx_timeout(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tdev_warn(&netdev->dev, \"Tx timeout.\\n\");\n\tusb_unlink_urb(dev->tx_urb);\n\tnetdev->stats.tx_errors++;\n}\n\nstatic void rtl8150_set_multicast(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 rx_creg = 0x9e;\n\n\tnetif_stop_queue(netdev);\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trx_creg |= 0x0001;\n\t\tdev_info(&netdev->dev, \"%s: promiscuous mode\\n\", netdev->name);\n\t} else if (!netdev_mc_empty(netdev) ||\n\t\t   (netdev->flags & IFF_ALLMULTI)) {\n\t\trx_creg &= 0xfffe;\n\t\trx_creg |= 0x0002;\n\t\tdev_info(&netdev->dev, \"%s: allmulti set\\n\", netdev->name);\n\t} else {\n\t\t/* ~RX_MULTICAST, ~RX_PROMISCUOUS */\n\t\trx_creg &= 0x00fc;\n\t}\n\tasync_set_registers(dev, RCR, sizeof(rx_creg), rx_creg);\n\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_tx_t rtl8150_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint count, res;\n\n\tnetif_stop_queue(netdev);\n\tcount = (skb->len < 60) ? 60 : skb->len;\n\tcount = (count & 0x3f) ? count : count + 1;\n\tdev->tx_skb = skb;\n\tusb_fill_bulk_urb(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t      skb->data, count, write_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->tx_urb, GFP_ATOMIC))) {\n\t\t/* Can we get/handle EPIPE here? */\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\telse {\n\t\t\tdev_warn(&netdev->dev, \"failed tx_urb %d\\n\", res);\n\t\t\tnetdev->stats.tx_errors++;\n\t\t\tnetif_start_queue(netdev);\n\t\t}\n\t} else {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += skb->len;\n\t\tnetif_trans_update(netdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic void set_carrier(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort tmp;\n\n\tget_registers(dev, CSCR, 2, &tmp);\n\tif (tmp & CSCR_LINK_STATUS)\n\t\tnetif_carrier_on(netdev);\n\telse\n\t\tnetif_carrier_off(netdev);\n}\n\nstatic int rtl8150_open(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint res;\n\n\tif (dev->rx_skb == NULL)\n\t\tdev->rx_skb = pull_skb(dev);\n\tif (!dev->rx_skb)\n\t\treturn -ENOMEM;\n\n\tset_registers(dev, IDR, 6, netdev->dev_addr);\n\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"rx_urb submit failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\tusb_fill_int_urb(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev, 3),\n\t\t     dev->intr_buff, INTBUFSIZE, intr_callback,\n\t\t     dev, dev->intr_interval);\n\tif ((res = usb_submit_urb(dev->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"intr_urb submit failed: %d\\n\", res);\n\t\tusb_kill_urb(dev->rx_urb);\n\t\treturn res;\n\t}\n\tenable_net_traffic(dev);\n\tset_carrier(netdev);\n\tnetif_start_queue(netdev);\n\n\treturn res;\n}\n\nstatic int rtl8150_close(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\tif (!test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\tdisable_net_traffic(dev);\n\tunlink_all_urbs(dev);\n\n\treturn 0;\n}\n\nstatic void rtl8150_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int rtl8150_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort lpa, bmcr;\n\n\tecmd->supported = (SUPPORTED_10baseT_Half |\n\t\t\t  SUPPORTED_10baseT_Full |\n\t\t\t  SUPPORTED_100baseT_Half |\n\t\t\t  SUPPORTED_100baseT_Full |\n\t\t\t  SUPPORTED_Autoneg |\n\t\t\t  SUPPORTED_TP | SUPPORTED_MII);\n\tecmd->port = PORT_TP;\n\tecmd->transceiver = XCVR_INTERNAL;\n\tecmd->phy_address = dev->phy;\n\tget_registers(dev, BMCR, 2, &bmcr);\n\tget_registers(dev, ANLP, 2, &lpa);\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tu32 speed = ((lpa & (LPA_100HALF | LPA_100FULL)) ?\n\t\t\t     SPEED_100 : SPEED_10);\n\t\tethtool_cmd_speed_set(ecmd, speed);\n\t\tecmd->autoneg = AUTONEG_ENABLE;\n\t\tif (speed == SPEED_100)\n\t\t\tecmd->duplex = (lpa & LPA_100FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t\telse\n\t\t\tecmd->duplex = (lpa & LPA_10FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tecmd->autoneg = AUTONEG_DISABLE;\n\t\tethtool_cmd_speed_set(ecmd, ((bmcr & BMCR_SPEED100) ?\n\t\t\t\t\t     SPEED_100 : SPEED_10));\n\t\tecmd->duplex = (bmcr & BMCR_FULLDPLX) ?\n\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = rtl8150_get_drvinfo,\n\t.get_settings = rtl8150_get_settings,\n\t.get_link = ethtool_op_get_link\n};\n\nstatic int rtl8150_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 *data = (u16 *) & rq->ifr_ifru;\n\tint res = 0;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = dev->phy;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tread_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(dev, dev->phy, (data[1] & 0x1f), data[2]);\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\n\treturn res;\n}\n\nstatic const struct net_device_ops rtl8150_netdev_ops = {\n\t.ndo_open\t\t= rtl8150_open,\n\t.ndo_stop\t\t= rtl8150_close,\n\t.ndo_do_ioctl\t\t= rtl8150_ioctl,\n\t.ndo_start_xmit\t\t= rtl8150_start_xmit,\n\t.ndo_tx_timeout\t\t= rtl8150_tx_timeout,\n\t.ndo_set_rx_mode\t= rtl8150_set_multicast,\n\t.ndo_set_mac_address\t= rtl8150_set_mac_address,\n\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int rtl8150_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\trtl8150_t *dev;\n\tstruct net_device *netdev;\n\n\tnetdev = alloc_etherdev(sizeof(rtl8150_t));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tdev = netdev_priv(netdev);\n\n\tdev->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\n\tif (!dev->intr_buff) {\n\t\tfree_netdev(netdev);\n\t\treturn -ENOMEM;\n\t}\n\n\ttasklet_init(&dev->tl, rx_fixup, (unsigned long)dev);\n\tspin_lock_init(&dev->rx_pool_lock);\n\n\tdev->udev = udev;\n\tdev->netdev = netdev;\n\tnetdev->netdev_ops = &rtl8150_netdev_ops;\n\tnetdev->watchdog_timeo = RTL8150_TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\tdev->intr_interval = 100;\t/* 100ms */\n\n\tif (!alloc_all_urbs(dev)) {\n\t\tdev_err(&intf->dev, \"out of memory\\n\");\n\t\tgoto out;\n\t}\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_err(&intf->dev, \"couldn't reset the device\\n\");\n\t\tgoto out1;\n\t}\n\tfill_skb_pool(dev);\n\tset_ethernet_addr(dev);\n\n\tusb_set_intfdata(intf, dev);\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tif (register_netdev(netdev) != 0) {\n\t\tdev_err(&intf->dev, \"couldn't register the device\\n\");\n\t\tgoto out2;\n\t}\n\n\tdev_info(&intf->dev, \"%s: rtl8150 is detected\\n\", netdev->name);\n\n\treturn 0;\n\nout2:\n\tusb_set_intfdata(intf, NULL);\n\tfree_skb_pool(dev);\nout1:\n\tfree_all_urbs(dev);\nout:\n\tkfree(dev->intr_buff);\n\tfree_netdev(netdev);\n\treturn -EIO;\n}\n\nstatic void rtl8150_disconnect(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (dev) {\n\t\tset_bit(RTL8150_UNPLUG, &dev->flags);\n\t\ttasklet_kill(&dev->tl);\n\t\tunregister_netdev(dev->netdev);\n\t\tunlink_all_urbs(dev);\n\t\tfree_all_urbs(dev);\n\t\tfree_skb_pool(dev);\n\t\tif (dev->rx_skb)\n\t\t\tdev_kfree_skb(dev->rx_skb);\n\t\tkfree(dev->intr_buff);\n\t\tfree_netdev(dev->netdev);\n\t}\n}\n\nstatic struct usb_driver rtl8150_driver = {\n\t.name\t\t= driver_name,\n\t.probe\t\t= rtl8150_probe,\n\t.disconnect\t= rtl8150_disconnect,\n\t.id_table\t= rtl8150_table,\n\t.suspend\t= rtl8150_suspend,\n\t.resume\t\t= rtl8150_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rtl8150_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n *  Copyright (c) 2002 Petko Manolov (petkan@users.sourceforge.net)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n */\n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/uaccess.h>\n\n/* Version Information */\n#define DRIVER_VERSION \"v0.6.2 (2004/08/27)\"\n#define DRIVER_AUTHOR \"Petko Manolov <petkan@users.sourceforge.net>\"\n#define DRIVER_DESC \"rtl8150 based usb-ethernet driver\"\n\n#define\tIDR\t\t\t0x0120\n#define\tMAR\t\t\t0x0126\n#define\tCR\t\t\t0x012e\n#define\tTCR\t\t\t0x012f\n#define\tRCR\t\t\t0x0130\n#define\tTSR\t\t\t0x0132\n#define\tRSR\t\t\t0x0133\n#define\tCON0\t\t\t0x0135\n#define\tCON1\t\t\t0x0136\n#define\tMSR\t\t\t0x0137\n#define\tPHYADD\t\t\t0x0138\n#define\tPHYDAT\t\t\t0x0139\n#define\tPHYCNT\t\t\t0x013b\n#define\tGPPC\t\t\t0x013d\n#define\tBMCR\t\t\t0x0140\n#define\tBMSR\t\t\t0x0142\n#define\tANAR\t\t\t0x0144\n#define\tANLP\t\t\t0x0146\n#define\tAER\t\t\t0x0148\n#define CSCR\t\t\t0x014C  /* This one has the link status */\n#define CSCR_LINK_STATUS\t(1 << 3)\n\n#define\tIDR_EEPROM\t\t0x1202\n\n#define\tPHY_READ\t\t0\n#define\tPHY_WRITE\t\t0x20\n#define\tPHY_GO\t\t\t0x40\n\n#define\tMII_TIMEOUT\t\t10\n#define\tINTBUFSIZE\t\t8\n\n#define\tRTL8150_REQT_READ\t0xc0\n#define\tRTL8150_REQT_WRITE\t0x40\n#define\tRTL8150_REQ_GET_REGS\t0x05\n#define\tRTL8150_REQ_SET_REGS\t0x05\n\n\n/* Transmit status register errors */\n#define TSR_ECOL\t\t(1<<5)\n#define TSR_LCOL\t\t(1<<4)\n#define TSR_LOSS_CRS\t\t(1<<3)\n#define TSR_JBR\t\t\t(1<<2)\n#define TSR_ERRORS\t\t(TSR_ECOL | TSR_LCOL | TSR_LOSS_CRS | TSR_JBR)\n/* Receive status register errors */\n#define RSR_CRC\t\t\t(1<<2)\n#define RSR_FAE\t\t\t(1<<1)\n#define RSR_ERRORS\t\t(RSR_CRC | RSR_FAE)\n\n/* Media status register definitions */\n#define MSR_DUPLEX\t\t(1<<4)\n#define MSR_SPEED\t\t(1<<3)\n#define MSR_LINK\t\t(1<<2)\n\n/* Interrupt pipe data */\n#define INT_TSR\t\t\t0x00\n#define INT_RSR\t\t\t0x01\n#define INT_MSR\t\t\t0x02\n#define INT_WAKSR\t\t0x03\n#define INT_TXOK_CNT\t\t0x04\n#define INT_RXLOST_CNT\t\t0x05\n#define INT_CRERR_CNT\t\t0x06\n#define INT_COL_CNT\t\t0x07\n\n\n#define\tRTL8150_MTU\t\t1540\n#define\tRTL8150_TX_TIMEOUT\t(HZ)\n#define\tRX_SKB_POOL_SIZE\t4\n\n/* rtl8150 flags */\n#define\tRTL8150_HW_CRC\t\t0\n#define\tRX_REG_SET\t\t1\n#define\tRTL8150_UNPLUG\t\t2\n#define\tRX_URB_FAIL\t\t3\n\n/* Define these values to match your device */\n#define\tVENDOR_ID_REALTEK\t\t0x0bda\n#define\tVENDOR_ID_MELCO\t\t\t0x0411\n#define\tVENDOR_ID_MICRONET\t\t0x3980\n#define\tVENDOR_ID_LONGSHINE\t\t0x07b8\n#define\tVENDOR_ID_OQO\t\t\t0x1557\n#define\tVENDOR_ID_ZYXEL\t\t\t0x0586\n\n#define PRODUCT_ID_RTL8150\t\t0x8150\n#define\tPRODUCT_ID_LUAKTX\t\t0x0012\n#define\tPRODUCT_ID_LCS8138TX\t\t0x401a\n#define PRODUCT_ID_SP128AR\t\t0x0003\n#define\tPRODUCT_ID_PRESTIGE\t\t0x401a\n\n#undef\tEEPROM_WRITE\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id rtl8150_table[] = {\n\t{USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_MELCO, PRODUCT_ID_LUAKTX)},\n\t{USB_DEVICE(VENDOR_ID_MICRONET, PRODUCT_ID_SP128AR)},\n\t{USB_DEVICE(VENDOR_ID_LONGSHINE, PRODUCT_ID_LCS8138TX)},\n\t{USB_DEVICE(VENDOR_ID_OQO, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_ZYXEL, PRODUCT_ID_PRESTIGE)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl8150_table);\n\nstruct rtl8150 {\n\tunsigned long flags;\n\tstruct usb_device *udev;\n\tstruct tasklet_struct tl;\n\tstruct net_device *netdev;\n\tstruct urb *rx_urb, *tx_urb, *intr_urb;\n\tstruct sk_buff *tx_skb, *rx_skb;\n\tstruct sk_buff *rx_skb_pool[RX_SKB_POOL_SIZE];\n\tspinlock_t rx_pool_lock;\n\tstruct usb_ctrlrequest dr;\n\tint intr_interval;\n\tu8 *intr_buff;\n\tu8 phy;\n};\n\ntypedef struct rtl8150 rtl8150_t;\n\nstruct async_req {\n\tstruct usb_ctrlrequest dr;\n\tu16 rx_creg;\n};\n\nstatic const char driver_name [] = \"rtl8150\";\n\n/*\n**\n**\tdevice related part of the code\n**\n*/\nstatic int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t      indx, 0, buf, size, 500);\n\tif (ret > 0 && ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t      indx, 0, buf, size, 500);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void async_set_reg_cb(struct urb *urb)\n{\n\tstruct async_req *req = (struct async_req *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int async_set_registers(rtl8150_t *dev, u16 indx, u16 size, u16 reg)\n{\n\tint res = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct async_req *req;\n\n\treq = kmalloc(sizeof(struct async_req), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn res;\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn res;\n\t}\n\treq->rx_creg = cpu_to_le16(reg);\n\treq->dr.bRequestType = RTL8150_REQT_WRITE;\n\treq->dr.bRequest = RTL8150_REQ_SET_REGS;\n\treq->dr.wIndex = 0;\n\treq->dr.wValue = cpu_to_le16(indx);\n\treq->dr.wLength = cpu_to_le16(size);\n\tusb_fill_control_urb(async_urb, dev->udev,\n\t                     usb_sndctrlpipe(dev->udev, 0), (void *)&req->dr,\n\t\t\t     &req->rx_creg, size, async_set_reg_cb, req);\n\tres = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (res) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_err(&dev->udev->dev, \"%s failed with %d\\n\", __func__, res);\n\t}\n\treturn res;\n}\n\nstatic int read_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 * reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = data[2] = 0;\n\ttmp = indx | PHY_READ | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT) {\n\t\tget_registers(dev, PHYDAT, 2, data);\n\t\t*reg = data[0] | (data[1] << 8);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nstatic int write_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = reg & 0xff;\n\tdata[2] = (reg >> 8) & 0xff;\n\ttmp = indx | PHY_WRITE | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic inline void set_ethernet_addr(rtl8150_t * dev)\n{\n\tu8 node_id[6];\n\n\tget_registers(dev, IDR, sizeof(node_id), node_id);\n\tmemcpy(dev->netdev->dev_addr, node_id, sizeof(node_id));\n}\n\nstatic int rtl8150_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\n\tnetdev_dbg(netdev, \"Setting MAC address to %pM\\n\", netdev->dev_addr);\n\t/* Set the IDR registers. */\n\tset_registers(dev, IDR, netdev->addr_len, netdev->dev_addr);\n#ifdef EEPROM_WRITE\n\t{\n\tint i;\n\tu8 cr;\n\t/* Get the CR contents. */\n\tget_registers(dev, CR, 1, &cr);\n\t/* Set the WEPROM bit (eeprom write enable). */\n\tcr |= 0x20;\n\tset_registers(dev, CR, 1, &cr);\n\t/* Write the MAC address into eeprom. Eeprom writes must be word-sized,\n\t   so we need to split them up. */\n\tfor (i = 0; i * 2 < netdev->addr_len; i++) {\n\t\tset_registers(dev, IDR_EEPROM + (i * 2), 2,\n\t\tnetdev->dev_addr + (i * 2));\n\t}\n\t/* Clear the WEPROM bit (preventing accidental eeprom writes). */\n\tcr &= 0xdf;\n\tset_registers(dev, CR, 1, &cr);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int rtl8150_reset(rtl8150_t * dev)\n{\n\tu8 data = 0x10;\n\tint i = HZ;\n\n\tset_registers(dev, CR, 1, &data);\n\tdo {\n\t\tget_registers(dev, CR, 1, &data);\n\t} while ((data & 0x10) && --i);\n\n\treturn (i > 0) ? 1 : 0;\n}\n\nstatic int alloc_all_urbs(rtl8150_t * dev)\n{\n\tdev->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->rx_urb)\n\t\treturn 0;\n\tdev->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->tx_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\treturn 0;\n\t}\n\tdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->intr_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\tusb_free_urb(dev->tx_urb);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_all_urbs(rtl8150_t * dev)\n{\n\tusb_free_urb(dev->rx_urb);\n\tusb_free_urb(dev->tx_urb);\n\tusb_free_urb(dev->intr_urb);\n}\n\nstatic void unlink_all_urbs(rtl8150_t * dev)\n{\n\tusb_kill_urb(dev->rx_urb);\n\tusb_kill_urb(dev->tx_urb);\n\tusb_kill_urb(dev->intr_urb);\n}\n\nstatic inline struct sk_buff *pull_skb(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i]) {\n\t\t\tskb = dev->rx_skb_pool[i];\n\t\t\tdev->rx_skb_pool[i] = NULL;\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tunsigned pkt_len, res;\n\tstruct sk_buff *skb;\n\tstruct net_device *netdev;\n\tu16 rx_stat;\n\tint status = urb->status;\n\tint result;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tif (test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\treturn;\n\tnetdev = dev->netdev;\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\t\treturn;\t/* the urb is in unlink state */\n\tcase -ETIME:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"may be reset is needed?..\\n\");\n\t\tgoto goon;\n\tdefault:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"Rx status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (!dev->rx_skb)\n\t\tgoto resched;\n\t/* protect against short packets (tell me why we got some?!?) */\n\tif (urb->actual_length < 4)\n\t\tgoto goon;\n\n\tres = urb->actual_length;\n\trx_stat = le16_to_cpu(*(__le16 *)(urb->transfer_buffer + res - 4));\n\tpkt_len = res - 4;\n\n\tskb_put(dev->rx_skb, pkt_len);\n\tdev->rx_skb->protocol = eth_type_trans(dev->rx_skb, netdev);\n\tnetif_rx(dev->rx_skb);\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += pkt_len;\n\n\tspin_lock(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock(&dev->rx_pool_lock);\n\tif (!skb)\n\t\tgoto resched;\n\n\tdev->rx_skb = skb;\ngoon:\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tresult = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (result == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (result) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto resched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\nresched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tdev_kfree_skb_irq(dev->tx_skb);\n\tif (!netif_device_present(dev->netdev))\n\t\treturn;\n\tif (status)\n\t\tdev_info(&urb->dev->dev, \"%s: Tx status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\tnetif_trans_update(dev->netdev);\n\tnetif_wake_queue(dev->netdev);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\t__u8 *d;\n\tint status = urb->status;\n\tint res;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tdev_info(&urb->dev->dev, \"%s: intr status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (d[0] & TSR_ERRORS) {\n\t\tdev->netdev->stats.tx_errors++;\n\t\tif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\n\t\t\tdev->netdev->stats.tx_aborted_errors++;\n\t\tif (d[INT_TSR] & TSR_LCOL)\n\t\t\tdev->netdev->stats.tx_window_errors++;\n\t\tif (d[INT_TSR] & TSR_LOSS_CRS)\n\t\t\tdev->netdev->stats.tx_carrier_errors++;\n\t}\n\t/* Report link status changes to the network stack */\n\tif ((d[INT_MSR] & MSR_LINK) == 0) {\n\t\tif (netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_off(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK LOST\\n\", __func__);\n\t\t}\n\t} else {\n\t\tif (!netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_on(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK CAME BACK\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (res)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"can't resubmit intr, %s-%s/input0, status %d\\n\",\n\t\t\tdev->udev->bus->bus_name, dev->udev->devpath, res);\n}\n\nstatic int rtl8150_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_detach(dev->netdev);\n\n\tif (netif_running(dev->netdev)) {\n\t\tusb_kill_urb(dev->rx_urb);\n\t\tusb_kill_urb(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int rtl8150_resume(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_attach(dev->netdev);\n\tif (netif_running(dev->netdev)) {\n\t\tdev->rx_urb->status = 0;\n\t\tdev->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(dev->rx_urb);\n\n\t\tdev->intr_urb->status = 0;\n\t\tdev->intr_urb->actual_length = 0;\n\t\tintr_callback(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\n/*\n**\n**\tnetwork related part of the code\n**\n*/\n\nstatic void fill_skb_pool(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i])\n\t\t\tcontinue;\n\t\tskb = dev_alloc_skb(RTL8150_MTU + 2);\n\t\tif (!skb) {\n\t\t\treturn;\n\t\t}\n\t\tskb_reserve(skb, 2);\n\t\tdev->rx_skb_pool[i] = skb;\n\t}\n}\n\nstatic void free_skb_pool(rtl8150_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++)\n\t\tif (dev->rx_skb_pool[i])\n\t\t\tdev_kfree_skb(dev->rx_skb_pool[i]);\n}\n\nstatic void rx_fixup(unsigned long data)\n{\n\tstruct rtl8150 *dev = (struct rtl8150 *)data;\n\tstruct sk_buff *skb;\n\tint status;\n\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tfill_skb_pool(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (test_bit(RX_URB_FAIL, &dev->flags))\n\t\tif (dev->rx_skb)\n\t\t\tgoto try_again;\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (skb == NULL)\n\t\tgoto tlsched;\n\tdev->rx_skb = skb;\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\ntry_again:\n\tstatus = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV) {\n\t\tnetif_device_detach(dev->netdev);\n\t} else if (status) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto tlsched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\ntlsched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic int enable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr, tcr, rcr, msr;\n\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_warn(&dev->udev->dev, \"device reset failed\\n\");\n\t}\n\t/* RCR bit7=1 attach Rx info at the end;  =0 HW CRC (which is broken) */\n\trcr = 0x9e;\n\ttcr = 0xd8;\n\tcr = 0x0c;\n\tif (!(rcr & 0x80))\n\t\tset_bit(RTL8150_HW_CRC, &dev->flags);\n\tset_registers(dev, RCR, 1, &rcr);\n\tset_registers(dev, TCR, 1, &tcr);\n\tset_registers(dev, CR, 1, &cr);\n\tget_registers(dev, MSR, 1, &msr);\n\n\treturn 0;\n}\n\nstatic void disable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr;\n\n\tget_registers(dev, CR, 1, &cr);\n\tcr &= 0xf3;\n\tset_registers(dev, CR, 1, &cr);\n}\n\nstatic void rtl8150_tx_timeout(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tdev_warn(&netdev->dev, \"Tx timeout.\\n\");\n\tusb_unlink_urb(dev->tx_urb);\n\tnetdev->stats.tx_errors++;\n}\n\nstatic void rtl8150_set_multicast(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 rx_creg = 0x9e;\n\n\tnetif_stop_queue(netdev);\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trx_creg |= 0x0001;\n\t\tdev_info(&netdev->dev, \"%s: promiscuous mode\\n\", netdev->name);\n\t} else if (!netdev_mc_empty(netdev) ||\n\t\t   (netdev->flags & IFF_ALLMULTI)) {\n\t\trx_creg &= 0xfffe;\n\t\trx_creg |= 0x0002;\n\t\tdev_info(&netdev->dev, \"%s: allmulti set\\n\", netdev->name);\n\t} else {\n\t\t/* ~RX_MULTICAST, ~RX_PROMISCUOUS */\n\t\trx_creg &= 0x00fc;\n\t}\n\tasync_set_registers(dev, RCR, sizeof(rx_creg), rx_creg);\n\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_tx_t rtl8150_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint count, res;\n\n\tnetif_stop_queue(netdev);\n\tcount = (skb->len < 60) ? 60 : skb->len;\n\tcount = (count & 0x3f) ? count : count + 1;\n\tdev->tx_skb = skb;\n\tusb_fill_bulk_urb(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t      skb->data, count, write_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->tx_urb, GFP_ATOMIC))) {\n\t\t/* Can we get/handle EPIPE here? */\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\telse {\n\t\t\tdev_warn(&netdev->dev, \"failed tx_urb %d\\n\", res);\n\t\t\tnetdev->stats.tx_errors++;\n\t\t\tnetif_start_queue(netdev);\n\t\t}\n\t} else {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += skb->len;\n\t\tnetif_trans_update(netdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic void set_carrier(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort tmp;\n\n\tget_registers(dev, CSCR, 2, &tmp);\n\tif (tmp & CSCR_LINK_STATUS)\n\t\tnetif_carrier_on(netdev);\n\telse\n\t\tnetif_carrier_off(netdev);\n}\n\nstatic int rtl8150_open(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint res;\n\n\tif (dev->rx_skb == NULL)\n\t\tdev->rx_skb = pull_skb(dev);\n\tif (!dev->rx_skb)\n\t\treturn -ENOMEM;\n\n\tset_registers(dev, IDR, 6, netdev->dev_addr);\n\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"rx_urb submit failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\tusb_fill_int_urb(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev, 3),\n\t\t     dev->intr_buff, INTBUFSIZE, intr_callback,\n\t\t     dev, dev->intr_interval);\n\tif ((res = usb_submit_urb(dev->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"intr_urb submit failed: %d\\n\", res);\n\t\tusb_kill_urb(dev->rx_urb);\n\t\treturn res;\n\t}\n\tenable_net_traffic(dev);\n\tset_carrier(netdev);\n\tnetif_start_queue(netdev);\n\n\treturn res;\n}\n\nstatic int rtl8150_close(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\tif (!test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\tdisable_net_traffic(dev);\n\tunlink_all_urbs(dev);\n\n\treturn 0;\n}\n\nstatic void rtl8150_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tstrlcpy(info->driver, driver_name, sizeof(info->driver));\n\tstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int rtl8150_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort lpa, bmcr;\n\n\tecmd->supported = (SUPPORTED_10baseT_Half |\n\t\t\t  SUPPORTED_10baseT_Full |\n\t\t\t  SUPPORTED_100baseT_Half |\n\t\t\t  SUPPORTED_100baseT_Full |\n\t\t\t  SUPPORTED_Autoneg |\n\t\t\t  SUPPORTED_TP | SUPPORTED_MII);\n\tecmd->port = PORT_TP;\n\tecmd->transceiver = XCVR_INTERNAL;\n\tecmd->phy_address = dev->phy;\n\tget_registers(dev, BMCR, 2, &bmcr);\n\tget_registers(dev, ANLP, 2, &lpa);\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tu32 speed = ((lpa & (LPA_100HALF | LPA_100FULL)) ?\n\t\t\t     SPEED_100 : SPEED_10);\n\t\tethtool_cmd_speed_set(ecmd, speed);\n\t\tecmd->autoneg = AUTONEG_ENABLE;\n\t\tif (speed == SPEED_100)\n\t\t\tecmd->duplex = (lpa & LPA_100FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t\telse\n\t\t\tecmd->duplex = (lpa & LPA_10FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tecmd->autoneg = AUTONEG_DISABLE;\n\t\tethtool_cmd_speed_set(ecmd, ((bmcr & BMCR_SPEED100) ?\n\t\t\t\t\t     SPEED_100 : SPEED_10));\n\t\tecmd->duplex = (bmcr & BMCR_FULLDPLX) ?\n\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = rtl8150_get_drvinfo,\n\t.get_settings = rtl8150_get_settings,\n\t.get_link = ethtool_op_get_link\n};\n\nstatic int rtl8150_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 *data = (u16 *) & rq->ifr_ifru;\n\tint res = 0;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = dev->phy;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tread_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(dev, dev->phy, (data[1] & 0x1f), data[2]);\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\n\treturn res;\n}\n\nstatic const struct net_device_ops rtl8150_netdev_ops = {\n\t.ndo_open\t\t= rtl8150_open,\n\t.ndo_stop\t\t= rtl8150_close,\n\t.ndo_do_ioctl\t\t= rtl8150_ioctl,\n\t.ndo_start_xmit\t\t= rtl8150_start_xmit,\n\t.ndo_tx_timeout\t\t= rtl8150_tx_timeout,\n\t.ndo_set_rx_mode\t= rtl8150_set_multicast,\n\t.ndo_set_mac_address\t= rtl8150_set_mac_address,\n\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int rtl8150_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\trtl8150_t *dev;\n\tstruct net_device *netdev;\n\n\tnetdev = alloc_etherdev(sizeof(rtl8150_t));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tdev = netdev_priv(netdev);\n\n\tdev->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\n\tif (!dev->intr_buff) {\n\t\tfree_netdev(netdev);\n\t\treturn -ENOMEM;\n\t}\n\n\ttasklet_init(&dev->tl, rx_fixup, (unsigned long)dev);\n\tspin_lock_init(&dev->rx_pool_lock);\n\n\tdev->udev = udev;\n\tdev->netdev = netdev;\n\tnetdev->netdev_ops = &rtl8150_netdev_ops;\n\tnetdev->watchdog_timeo = RTL8150_TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\tdev->intr_interval = 100;\t/* 100ms */\n\n\tif (!alloc_all_urbs(dev)) {\n\t\tdev_err(&intf->dev, \"out of memory\\n\");\n\t\tgoto out;\n\t}\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_err(&intf->dev, \"couldn't reset the device\\n\");\n\t\tgoto out1;\n\t}\n\tfill_skb_pool(dev);\n\tset_ethernet_addr(dev);\n\n\tusb_set_intfdata(intf, dev);\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tif (register_netdev(netdev) != 0) {\n\t\tdev_err(&intf->dev, \"couldn't register the device\\n\");\n\t\tgoto out2;\n\t}\n\n\tdev_info(&intf->dev, \"%s: rtl8150 is detected\\n\", netdev->name);\n\n\treturn 0;\n\nout2:\n\tusb_set_intfdata(intf, NULL);\n\tfree_skb_pool(dev);\nout1:\n\tfree_all_urbs(dev);\nout:\n\tkfree(dev->intr_buff);\n\tfree_netdev(netdev);\n\treturn -EIO;\n}\n\nstatic void rtl8150_disconnect(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (dev) {\n\t\tset_bit(RTL8150_UNPLUG, &dev->flags);\n\t\ttasklet_kill(&dev->tl);\n\t\tunregister_netdev(dev->netdev);\n\t\tunlink_all_urbs(dev);\n\t\tfree_all_urbs(dev);\n\t\tfree_skb_pool(dev);\n\t\tif (dev->rx_skb)\n\t\t\tdev_kfree_skb(dev->rx_skb);\n\t\tkfree(dev->intr_buff);\n\t\tfree_netdev(dev->netdev);\n\t}\n}\n\nstatic struct usb_driver rtl8150_driver = {\n\t.name\t\t= driver_name,\n\t.probe\t\t= rtl8150_probe,\n\t.disconnect\t= rtl8150_disconnect,\n\t.id_table\t= rtl8150_table,\n\t.suspend\t= rtl8150_suspend,\n\t.resume\t\t= rtl8150_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rtl8150_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/net/usb/rtl8150.c"], "buggy_code_start_loc": [158], "buggy_code_end_loc": [168], "fixing_code_start_loc": [158], "fixing_code_end_loc": [188], "type": "CWE-119", "message": "drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8069", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.507", "lastModified": "2017-04-27T18:13:29.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/net/usb/rtl8150.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.11 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.11", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7926aff5c57b577ab0f43364ff0c59d968f6a414", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414"}}