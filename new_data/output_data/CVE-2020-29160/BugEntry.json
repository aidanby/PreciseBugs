{"buggy_code": ["# Copyright (C) 2012-2016 Zammad Foundation, http://zammad-foundation.org/\n\nclass TicketArticlesController < ApplicationController\n  include CreatesTicketArticles\n  include ClonesTicketArticleAttachments\n\n  prepend_before_action -> { authorize! }, only: %i[index import_example import_start]\n  prepend_before_action :authentication_check\n\n  # GET /articles\n  def index\n    model_index_render(Ticket::Article, params)\n  end\n\n  # GET /articles/1\n  def show\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full\n      return\n    end\n\n    render json: article.attributes_with_association_names\n  end\n\n  # GET /ticket_articles/by_ticket/1\n  def index_by_ticket\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :show?)\n\n    articles = []\n\n    if response_expand?\n      ticket.articles.each do |article|\n        next if !authorized?(article, :show?)\n\n        result = article.attributes_with_association_names\n        articles.push result\n      end\n\n      render json: articles, status: :ok\n      return\n    end\n\n    if response_full?\n      assets = {}\n      record_ids = []\n      ticket.articles.each do |article|\n        next if !authorized?(article, :show?)\n\n        record_ids.push article.id\n        assets = article.assets({})\n      end\n      render json: {\n        record_ids: record_ids,\n        assets:     assets,\n      }, status: :ok\n      return\n    end\n\n    ticket.articles.each do |article|\n      next if !authorized?(article, :show?)\n\n      articles.push article.attributes_with_association_names\n    end\n    render json: articles, status: :ok\n  end\n\n  # POST /articles\n  def create\n    ticket = Ticket.find(params[:ticket_id])\n    authorize!(ticket)\n    article = article_create(ticket, params)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :created\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full, status: :created\n      return\n    end\n\n    render json: article.attributes_with_association_names, status: :created\n  end\n\n  # PUT /articles/1\n  def update\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n\n    clean_params = Ticket::Article.association_name_to_id_convert(params)\n    clean_params = Ticket::Article.param_cleanup(clean_params, true)\n\n    # only apply preferences changes (keep not updated keys/values)\n    clean_params = article.param_preferences_merge(clean_params)\n\n    article.update!(clean_params)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full, status: :ok\n      return\n    end\n\n    render json: article.attributes_with_association_names, status: :ok\n  end\n\n  # DELETE /api/v1/ticket_articles/:id\n  def destroy\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n    article.destroy!\n    render json: {}, status: :ok\n  end\n\n  # POST /ticket_attachment_upload_clone_by_article\n  def ticket_attachment_upload_clone_by_article\n    article = Ticket::Article.find(params[:article_id])\n    authorize!(article.ticket, :show?)\n\n    render json: {\n      attachments: article_attachments_clone(article),\n    }\n  end\n\n  # GET /ticket_attachment/:ticket_id/:article_id/:id\n  def attachment\n    ticket = Ticket.lookup(id: params[:ticket_id])\n    authorize!(ticket, :show?)\n\n    article = Ticket::Article.find(params[:article_id])\n    if ticket.id != article.ticket_id\n\n      # check if requested ticket got merged\n      if ticket.state.state_type.name != 'merged'\n        raise Exceptions::NotAuthorized, 'No access, article_id/ticket_id is not matching.'\n      end\n\n      ticket = article.ticket\n      authorize!(ticket, :show?)\n    end\n\n    list = article.attachments || []\n    access = false\n    list.each do |item|\n      if item.id.to_i == params[:id].to_i\n        access = true\n      end\n    end\n    raise Exceptions::NotAuthorized, 'Requested file id is not linked with article_id.' if !access\n\n    # find file\n    file = Store.find(params[:id])\n\n    disposition = sanitized_disposition\n\n    content = nil\n    if params[:view].present? && file.preferences[:resizable] == true\n      if file.preferences[:content_inline] == true && params[:view] == 'inline'\n        content = file.content_inline\n      elsif file.preferences[:content_preview] == true && params[:view] == 'preview'\n        content = file.content_preview\n      end\n    end\n\n    if content.blank?\n      content = file.content\n    end\n\n    send_data(\n      content,\n      filename:    file.filename,\n      type:        file.preferences['Content-Type'] || file.preferences['Mime-Type'] || 'application/octet-stream',\n      disposition: disposition\n    )\n  end\n\n  # GET /ticket_article_plain/1\n  def article_plain\n    article = Ticket::Article.find(params[:id])\n    authorize!(article, :show?)\n\n    file = article.as_raw\n\n    # find file\n    return if !file\n\n    send_data(\n      file.content,\n      filename:    file.filename,\n      type:        'message/rfc822',\n      disposition: 'inline'\n    )\n  end\n\n  # @path    [GET] /ticket_articles/import_example\n  #\n  # @summary          Download of example CSV file.\n  # @notes            The requester have 'admin' permissions to be able to download it.\n  # @example          curl -u 'me@example.com:test' http://localhost:3000/api/v1/ticket_articles/import_example\n  #\n  # @response_message 200 File download.\n  # @response_message 401 Invalid session.\n  def import_example\n    csv_string = Ticket::Article.csv_example(\n      col_sep: ',',\n    )\n    send_data(\n      csv_string,\n      filename:    'example.csv',\n      type:        'text/csv',\n      disposition: 'attachment'\n    )\n\n  end\n\n  # @path    [POST] /ticket_articles/import\n  #\n  # @summary          Starts import.\n  # @notes            The requester have 'admin' permissions to be create a new import.\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/ticket_articles.csv' 'https://your.zammad/api/v1/ticket_articles/import?try=true'\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/ticket_articles.csv' 'https://your.zammad/api/v1/ticket_articles/import'\n  #\n  # @response_message 201 Import started.\n  # @response_message 401 Invalid session.\n  def import_start\n    if Setting.get('import_mode') != true\n      raise 'Only can import tickets if system is in import mode.'\n    end\n\n    string = params[:data]\n    if string.blank? && params[:file].present?\n      string = params[:file].read.force_encoding('utf-8')\n    end\n    raise Exceptions::UnprocessableEntity, 'No source data submitted!' if string.blank?\n\n    result = Ticket::Article.csv_import(\n      string:       string,\n      parse_params: {\n        col_sep: ';',\n      },\n      try:          params[:try],\n    )\n    render json: result, status: :ok\n  end\n\n  def retry_security_process\n    article = Ticket::Article.find(params[:id])\n    authorize!(article, :update?)\n\n    result = SecureMailing.retry(article)\n\n    render json: result\n  end\n\n  private\n\n  def sanitized_disposition\n    disposition = params.fetch(:disposition, 'inline')\n    valid_disposition = %w[inline attachment]\n    return disposition if valid_disposition.include?(disposition)\n\n    raise Exceptions::NotAuthorized, \"Invalid disposition #{disposition} requested. Only #{valid_disposition.join(', ')} are valid.\"\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket Article API endpoints', type: :request do\n\n  let(:admin) do\n    create(:admin, groups: Group.all)\n  end\n  let!(:group) { create(:group) }\n\n  let(:agent) do\n    create(:agent, groups: Group.all)\n  end\n  let(:customer) do\n    create(:customer)\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent and articles' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body: 'some body',\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n\n      params = {\n        ticket_id:    json_response['id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(2)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/html', # or text/html\n        body:         'some body <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\nAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" />',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).not_to match(/some body <img src=\"cid:.+?/)\n      expect(json_response['body']).to match(%r{some body <img src=\"/api/v1/ticket_attachment/.+?\" alt=\"Red dot\"})\n      expect(json_response['content_type']).to eq('text/html')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      expect(ticket.articles.count).to eq(3)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(1)\n      expect(ticket.articles[2].attachments[0]['id']).to be_truthy\n      expect(ticket.articles[2].attachments[0]['filename']).to eq('image1.png')\n      expect(ticket.articles[2].attachments[0]['size']).to eq('21')\n      expect(ticket.articles[2].attachments[0]['preferences']['Mime-Type']).to eq('image/png')\n      expect(ticket.articles[2].attachments[0]['preferences']['Content-Disposition']).to eq('inline')\n      expect(ticket.articles[2].attachments[0]['preferences']['Content-ID']).to match(/@zammad.example.com/)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/html', # or text/html\n        body:         'some body',\n        type:         'note',\n        attachments:  [\n          { 'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain' },\n        ],\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/html')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      expect(ticket.articles.count).to eq(4)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(1)\n      expect(ticket.articles[3].attachments.count).to eq(1)\n\n      get \"/api/v1/ticket_articles/#{json_response['id']}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments'].count).to eq(1)\n      expect(json_response['attachments'][0]['id']).to be_truthy\n      expect(json_response['attachments'][0]['filename']).to eq('some_file.txt')\n      expect(json_response['attachments'][0]['size']).to eq('8')\n      expect(json_response['attachments'][0]['preferences']['Mime-Type']).to eq('text/plain')\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain',\n        body:         'some body',\n        type:         'note',\n        preferences:  {\n          some_key1: 123,\n        },\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(ticket.articles.count).to eq(5)\n\n      params = {\n        body:        'some body 2',\n        preferences: {\n          some_key2: 'abc',\n        },\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body 2')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).to eq('abc')\n\n    end\n\n    it 'does ticket create with customer and articles' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'Users',\n        article: {\n          body: 'some body',\n        }\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n\n      params = {\n        ticket_id:    json_response['id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(2)\n      expect(ticket.articles[1].sender.name).to eq('Customer')\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        sender:       'Agent',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(3)\n      expect(ticket.articles[2].sender.name).to eq('Customer')\n      expect(ticket.articles[2].internal).to eq(false)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body 2',\n        sender:       'Agent',\n        type:         'note',\n        internal:     true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body 2')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(4)\n      expect(ticket.articles[3].sender.name).to eq('Customer')\n      expect(ticket.articles[3].internal).to eq(false)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n      expect(ticket.articles[3].attachments.count).to eq(0)\n\n      # add internal article\n      article = create(\n        :ticket_article,\n        ticket_id: ticket.id,\n        internal:  true,\n        sender:    Ticket::Article::Sender.find_by(name: 'Agent'),\n        type:      Ticket::Article::Type.find_by(name: 'note'),\n      )\n      expect(ticket.articles.count).to eq(5)\n      expect(ticket.articles[4].sender.name).to eq('Agent')\n      expect(ticket.articles[4].updated_by_id).to eq(1)\n      expect(ticket.articles[4].created_by_id).to eq(1)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n      expect(ticket.articles[3].attachments.count).to eq(0)\n      expect(ticket.articles[4].attachments.count).to eq(0)\n\n      get \"/api/v1/ticket_articles/#{article.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_articles/#{article.id}\", params: { internal: false }, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n    end\n\n    it 'does create phone ticket for customer and expected origin_by_id' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body:   'some body',\n          sender: 'Customer',\n          type:   'phone',\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['title']).to eq('a new ticket #1')\n\n      expect(Ticket::Article.where(ticket_id: json_response['id']).count).to eq(2) # original + auto responder\n\n      article = Ticket::Article.where(ticket_id: json_response['id']).first\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.from).to eq(\"#{customer.firstname} #{customer.lastname} <#{customer.email}>\")\n    end\n\n    it 'does create phone ticket by customer and manipulate origin_by_id' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body:         'some body',\n          sender:       'Customer',\n          type:         'phone',\n          origin_by_id: 1,\n        }\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      expect(Ticket::Article.where(ticket_id: json_response['id']).count).to eq(1) # ony original\n\n      article = Ticket::Article.where(ticket_id: json_response['id']).first\n      expect(article.origin_by_id).to eq(customer.id)\n    end\n\n    it 'does ticket split with html - check attachments' do\n      ticket = create(:ticket, group: group)\n      article = create(\n        :ticket_article,\n        ticket_id:    ticket.id,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      params = {\n        form_id: 'new_form_id123',\n      }\n      authenticated_as(agent)\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n    end\n\n    it 'does ticket split with plain - check attachments' do\n      ticket = create(\n        :ticket,\n        group:         group,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        ticket_id:     ticket.id,\n        type:          Ticket::Article::Type.lookup(name: 'note'),\n        sender:        Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:          '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type:  'text/plain',\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      params = {\n        form_id: 'new_form_id123',\n      }\n      authenticated_as(agent)\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n    end\n  end\n\n  describe 'DELETE /api/v1/ticket_articles/:id', authenticated_as: -> { user } do\n    let(:other_agent) { create(:agent, groups: [Group.first]) }\n\n    let(:ticket) do\n      create(:ticket, group: Group.first)\n    end\n\n    let(:article_communication) do\n      create(:ticket_article,\n             sender_name: 'Agent', type_name: 'email', ticket: ticket,\n             updated_by_id: agent.id, created_by_id: agent.id )\n    end\n\n    let(:article_note_self) do\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note', ticket: ticket,\n             updated_by_id: user.id, created_by_id: user.id )\n    end\n\n    let(:article_note_other) do\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note', ticket: ticket,\n             updated_by_id: other_agent.id, created_by_id: other_agent.id )\n    end\n\n    let(:article_note_customer) do\n      create(:ticket_article,\n             sender_name: 'Customer', internal: false, type_name: 'note', ticket: ticket,\n             updated_by_id: customer.id, created_by_id: customer.id )\n    end\n\n    let(:article_note_communication_self) do\n      create(:ticket_article_type, name: 'note_communication', communication: true)\n\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note_communication', ticket: ticket,\n             updated_by_id: user.id, created_by_id: user.id )\n    end\n\n    let(:article_note_communication_other) do\n      create(:ticket_article_type, name: 'note_communication', communication: true)\n\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note_communication', ticket: ticket,\n             updated_by_id: other_agent.id, created_by_id: other_agent.id )\n    end\n\n    def delete_article_via_rest(article)\n      delete \"/api/v1/ticket_articles/#{article.id}\", params: {}, as: :json\n    end\n\n    shared_examples 'succeeds' do\n      it 'succeeds' do\n        expect { delete_article_via_rest(article) }.to change { Ticket::Article.exists?(id: article.id) }\n      end\n    end\n\n    shared_examples 'fails' do\n      it 'fails' do\n        expect { delete_article_via_rest(article) }.not_to change { Ticket::Article.exists?(id: article.id) }\n      end\n    end\n\n    shared_examples 'deleting' do |item:, now:, later:, much_later:|\n      context \"deleting #{item}\" do\n        let(:article) { send(item) }\n\n        include_examples now ? 'succeeds' : 'fails'\n\n        context '8 minutes later' do\n          before { article && travel(8.minutes) }\n\n          include_examples later ? 'succeeds' : 'fails'\n        end\n\n        context '11 minutes later' do\n          before { article && travel(11.minutes) }\n\n          include_examples much_later ? 'succeeds' : 'fails'\n        end\n      end\n    end\n\n    context 'as admin' do\n      let(:user) { admin }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_self',\n                       now: true, later: true, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n    end\n\n    context 'as agent' do\n      let(:user) { agent }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_self',\n                       now: true, later: true, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n    end\n\n    context 'as customer' do\n      let(:user) { customer }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n\n    end\n\n    context 'with custom timeframe' do\n      before { Setting.set 'ui_ticket_zoom_article_delete_timeframe', 6000 }\n\n      let(:article) { article_note_self }\n\n      context 'as admin' do\n        let(:user) { admin }\n\n        context 'deleting before timeframe' do\n          before { article && travel(5000.seconds) }\n\n          include_examples 'succeeds'\n        end\n\n        context 'deleting after timeframe' do\n          before { article && travel(8000.seconds) }\n\n          include_examples 'fails'\n        end\n      end\n\n      context 'as agent' do\n        let(:user) { agent }\n\n        context 'deleting before timeframe' do\n          before { article && travel(5000.seconds) }\n\n          include_examples 'succeeds'\n        end\n\n        context 'deleting after timeframe' do\n          before { article && travel(8000.seconds) }\n\n          include_examples 'fails'\n        end\n      end\n    end\n\n    context 'with timeframe as 0' do\n      before { Setting.set 'ui_ticket_zoom_article_delete_timeframe', 0 }\n\n      let(:article) { article_note_self }\n\n      context 'as agent' do\n        let(:user) { agent }\n\n        context 'deleting long after' do\n          before { article && travel(99.days) }\n\n          include_examples 'succeeds'\n        end\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket', type: :request do\n\n  let!(:ticket_group) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let!(:ticket_group_without_create) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let(:admin) do\n    create(:admin, groups: Group.all, firstname: 'Tickets', lastname: 'Admin')\n  end\n  let!(:agent) do\n    create(:agent, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n  end\n  let!(:agent_change_only) do\n    user = create(:agent, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n    user.group_names_access_map = {\n      ticket_group_without_create.name => %w[read change],\n    }\n    user\n  end\n  let!(:customer) do\n    create(\n      :customer,\n      login:     'tickets-customer1@example.com',\n      firstname: 'Tickets',\n      lastname:  'Customer1',\n      email:     'tickets-customer1@example.com',\n    )\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent - missing group (01.01)' do\n      params = {\n        title:   'a new ticket #1',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error_human']).to eq('Group can\\'t be blank')\n    end\n\n    it 'does ticket create with agent - wrong group (01.02)' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'not_existing',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('No lookup value found for \\'group\\': \"not_existing\"')\n    end\n\n    it 'does ticket create with agent - valid group but no create permissions (01.02a)' do\n      params = {\n        title:       'a new ticket #1',\n        group:       ticket_group_without_create.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_change_only)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket create with agent - missing article.body (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {},\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article and customer.email (01.04)' do\n      params = {\n        title:    'a new ticket #3',\n        group:    ticket_group.name,\n        priority: '2 normal',\n        state:    'new',\n        customer: customer.email,\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 0 (01.05)' do\n      params = {\n        title:       'a new ticket #4',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    0,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 0')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - \"\" (01.06)' do\n      params = {\n        title:       'a new ticket #5',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    '',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #5')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 99999 (01.07)' do\n      params = {\n        title:       'a new ticket #6',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    99_999,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 99999')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - nil (01.08)' do\n      params = {\n        title:       'a new ticket #7',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    nil,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #7')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.09)' do\n      params = {\n        title:       'a new ticket #9',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #9')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.10)' do\n      params = {\n        title:       'a new ticket #10',\n        group:       ticket_group.name,\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #10')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash (01.11)' do\n      params = {\n        title:    'a new ticket #11',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.1')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.2',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.2')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.3',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Agent',\n          from:      'somebody',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.3')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.4',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: customer.login,\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.4')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with missing body - with customer.id (01.12)' do\n      params = {\n        title:       'a new ticket #12',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.13)' do\n      params = {\n        title:       'a new ticket #13',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #13')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.14)' do\n      params = {\n        title:       'a new ticket #14',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            {\n              'filename'  => 'some_file1.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain',\n            },\n            {\n              'filename'  => 'some_file2.txt',\n              'data'      => 'w6TDtsO8w58=',\n              'mime-type' => 'text/plain',\n            },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #14')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file1.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and simple invalid base64 attachment with customer (01.15)' do\n      params = {\n        title:       'a new ticket #15',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'ABC_INVALID_BASE64',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and large invalid base64 attachment with customer (01.15a)' do\n      params = {\n        title:       'a new ticket #15a',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => \"LARGE_INVALID_BASE64_#{'#' * 20_000_000}\",\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 with linebreaks attachment with customer (01.15b)' do\n      params = {\n        title:       'a new ticket #15b',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => Base64.encode64('a' * 1_000),\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15b')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 without linebreaks attachment with customer (01.15c)' do\n      params = {\n        title:       'a new ticket #15c',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => Base64.strict_encode64('a' * 1_000),\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15c')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and attachment invalid base64 with customer (01.16)' do\n      params = {\n        title:       'a new ticket #16',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename' => 'some_file.txt',\n              'data'     => 'dGVzdCAxMjM=' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Attachment needs \\'mime-type\\' param for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.17)' do\n      params = {\n        title:       'a new ticket #17',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n  AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n  9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /> <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\">',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #17')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('d3c1e09bdefb92b6a06b791a24ca9599')\n      expect(file.filename).to eq('image1.png')\n      expect(file.preferences['Mime-Type']).to eq('image/png')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image2.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.18)' do\n      params = {\n        title:       'a new ticket #18',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\"\n  >',\n          attachments:  [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #18')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image1.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to be_truthy\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('39d0d586a701e199389d954f2d592720')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent (02.02)' do\n      params = {\n        title:    'a new ticket #1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: 'tickets-customer1@example.com',\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n        },\n        links:    {\n          Ticket: {\n            parent: [1],\n          }\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #1')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      links = Link.list(\n        link_object:       'Ticket',\n        link_object_value: json_response['id'],\n      )\n      expect(links[0]['link_type']).to eq('child')\n      expect(links[0]['link_object']).to eq('Ticket')\n      expect(links[0]['link_object_value']).to eq(1)\n    end\n\n    it 'does ticket with wrong ticket id (02.03)' do\n      group = create(:group)\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group_id:    group.id,\n        customer_id: customer.id,\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (02.04)' do\n      title = \"ticket with corret ticket id testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer.id,\n        preferences: {\n          some_key1: 123,\n        },\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent.id,\n        preferences: {\n          some_key2: 'abc',\n        },\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(agent.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).to eq('abc')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Agent')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['internal']).to eq(false)\n      expect(article_json_response['created_by_id']).to eq(agent.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  false,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['internal']).to eq(false)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (communication articles cannot be deleted)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket with correct ticket id (02.05)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with corret ticket id',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      authenticated_as(admin)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id')\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       'ticket with corret ticket id - 2',\n        customer_id: agent.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id - 2')\n      expect(json_response['customer_id']).to eq(agent.id)\n      expect(json_response['updated_by_id']).to eq(admin.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      params = {\n        subject:  'new subject',\n        internal: true,\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Admin via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n    end\n\n    it 'does ticket pagination (02.05)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n      tickets = []\n      (1..20).each do |count|\n        ticket = create(\n          :ticket,\n          title:       \"#{title} - #{count}\",\n          group:       ticket_group,\n          customer_id: customer.id,\n        )\n        create(\n          :ticket_article,\n          type:      Ticket::Article::Type.lookup(name: 'note'),\n          sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n          ticket_id: ticket.id,\n        )\n        tickets.push ticket\n        travel 2.seconds\n      end\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][19]).to eq(tickets[0].id)\n      expect(json_response['tickets_count']).to eq(20)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=10\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][9]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(10)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=1&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][4]).to eq(tickets[15].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=2&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[14].id)\n      expect(json_response['tickets'][4]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=1&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(5)\n      expect(json_response[0]['id']).to eq(tickets[0].id)\n      expect(json_response[4]['id']).to eq(tickets[4].id)\n      expect(json_response.count).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=2&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(10)\n      expect(json_response[0]['id']).to eq(tickets[5].id)\n      expect(json_response[4]['id']).to eq(tickets[9].id)\n      expect(json_response.count).to eq(5)\n\n    end\n\n    it 'does ticket create with customer minimal (03.01)' do\n      params = {\n        title:    'a new ticket #c1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        article:  {\n          body: 'some body',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket create with customer with wrong customer (03.02)' do\n      params = {\n        title:       'a new ticket #c2',\n        state:       'new',\n        priority:    '2 normal',\n        group:       ticket_group.name,\n        customer_id: agent.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket create with customer with wrong customer hash (03.03)' do\n      params = {\n        title:    'a new ticket #c2',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: {\n          firstname: agent.firstname,\n          lastname:  agent.lastname,\n          email:     agent.email,\n        },\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket with wrong ticket id (03.04)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group:       ticket_group,\n        customer_id: agent.id,\n      )\n      authenticated_as(customer)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (03.05)' do\n      title = \"ticket with corret ticket id testme#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      authenticated_as(customer)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Customer1')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['created_by_id']).to eq(customer.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (agent permission required)!')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        sender:    'Agent',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['created_by_id']).to eq(customer.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (agent permission required)!')\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'web',\n        sender:    'Agent',\n        internal:  true,\n      }\n\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1 <tickets-customer1@example.com>')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'web').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (ticket.agent or admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer)\n      params = {\n        title:    'a new ticket #3.6',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: agent.login,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer.id)\n      expect(article.created_by_id).to eq(customer.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer)\n      params = {\n        title:    'a new ticket #3.6.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:       'Agent',\n          body:         'some test 123',\n          origin_by_id: agent.id,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6.1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer.id)\n      expect(article.created_by_id).to eq(customer.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket show and response format (04.01)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['owner']).to eq(ticket.owner.login)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket index and response format (04.02)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      authenticated_as(agent)\n      get '/api/v1/tickets', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?expand=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['group']).to eq(ticket.group.name)\n      expect(json_response[1]['priority']).to eq(ticket.priority.name)\n      expect(json_response[1]['owner']).to eq(ticket.owner.login)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?expand=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?full=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['record_ids'].class).to eq(Array)\n      expect(json_response['record_ids'][0]).to eq(1)\n      expect(json_response['record_ids'][1]).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      get '/api/v1/tickets?full=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create and response format (04.03)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      params = {\n        title:       title,\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        state:       'new',\n        priority:    '2 normal',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      post '/api/v1/tickets?expand=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      post '/api/v1/tickets?full=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n    end\n\n    it 'does ticket update and response formats (04.04)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n\n      params = {\n        title: 'a update ticket #1',\n      }\n      authenticated_as(agent)\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq('a update ticket #1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      params = {\n        title: 'a update ticket #2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?expand=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq('a update ticket #2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      params = {\n        title: 'a update ticket #3',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #3')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      # it should be not possible to modify the ticket number\n      expected_ticket_number = ticket.number\n      params = {\n        title:  'a update ticket #4',\n        number: '77777',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #4')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['number']).to eq(expected_ticket_number)\n    end\n\n    it 'does ticket split with html - check attachments (05.01)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket split with plain - check attachments (05.02)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type: 'text/plain',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket merge (07.01)' do\n      group_no_permission = create(:group)\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      ticket3 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_no_permission,\n        customer_id: customer.id,\n      )\n\n      authenticated_as(customer)\n      put \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent)\n      put \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('failed')\n      expect(json_response['message']).to eq('No such master ticket number!')\n\n      put \"/api/v1/ticket_merge/#{ticket3.id}/#{ticket1.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket3.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket merge - change permission (07.02)' do\n      group_change_permission = Group.create!(\n        name:          'GroupWithChangePermission',\n        active:        true,\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       group_change_permission,\n        customer_id: customer.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_change_permission,\n        customer_id: customer.id,\n      )\n\n      agent.group_names_access_map = { group_change_permission.name => %w[read change] }\n\n      authenticated_as(agent)\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket search sorted (08.01)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n\n      ticket1 = create(\n        :ticket,\n        title:       \"#{title} A\",\n        group:       ticket_group,\n        customer_id: customer.id,\n        created_at:  '2018-02-05 17:42:00',\n        updated_at:  '2018-02-05 20:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      ticket2 = create(\n        :ticket,\n        title:       \"#{title} B\",\n        group:       ticket_group,\n        customer_id: customer.id,\n        state:       Ticket::State.lookup(name: 'new'),\n        priority:    Ticket::Priority.lookup(name: '3 hoch'),\n        created_at:  '2018-02-05 19:42:00',\n        updated_at:  '2018-02-05 19:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket2.id,\n      )\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'created_at', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'desc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[asc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[desc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n    end\n\n    it 'does ticket history ' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['history'].class).to eq(Array)\n      expect(json_response['assets'].class).to eq(Hash)\n      expect(json_response['assets']['User'][customer.id.to_s]).not_to be_nil\n      expect(json_response['assets']['Ticket'][ticket1.id.to_s]).not_to be_nil\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket related' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket recent' do\n      authenticated_as(agent)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n  end\n\n  describe 'stats' do\n    let(:ticket1) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket2) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket3) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:customer) { create(:customer, organization: organization) }\n    let(:organization) { create(:organization, shared: false) }\n\n    before do\n      authenticated_as(admin)\n\n      ticket1\n      travel 2.minutes\n      ticket2\n      travel 2.minutes\n      ticket3\n      travel 2.minutes\n      ticket2.touch\n    end\n\n    # https://github.com/zammad/zammad/issues/2296\n    it 'orders tickets by created_at desc (#2296)' do\n      get '/api/v1/ticket_stats', params: { organization_id: organization.id, user_id: customer.id }, as: :json\n\n      expect(response).to have_http_status(:ok)\n      expect(json_response)\n        .to be_a_kind_of(Hash)\n        .and include('user' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n        .and include('organization' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n    end\n\n  end\n\n  describe '/api/v1/tickets' do\n    subject(:ticket) { create(:ticket, state_name: 'closed') }\n\n    let(:admin) { create(:admin, groups: [ticket.group]) }\n    let(:agent) { create(:agent, groups: [ticket.group]) }\n    let(:customer) { ticket.customer }\n\n    describe 'reopening a ticket' do\n      shared_examples 'successfully reopen a ticket' do\n        it 'succeeds' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:ok)\n          expect(json_response).to include('state_id' => Ticket::State.find_by(name: 'open').id)\n        end\n      end\n\n      shared_examples 'fail to reopen a ticket' do\n        it 'fails' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:unprocessable_entity)\n          expect(json_response).to include('error' => 'Cannot follow-up on a closed ticket. Please create a new ticket.')\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"yes\"' do\n        before { ticket.group.update(follow_up_possible: 'yes') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'successfully reopen a ticket'\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"new_ticket\"' do\n        before { ticket.group.update(follow_up_possible: 'new_ticket') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'fail to reopen a ticket'\n        end\n      end\n    end\n  end\n\n  describe 'GET /api/v1/ticket_customer' do\n\n    subject(:ticket) { create(:ticket, customer: customer_authorized) }\n\n    let(:organization_authorized) { create(:organization) }\n    let(:customer_authorized) { create(:customer, organization: organization_authorized) }\n\n    let(:organization_unauthorized) { create(:organization) }\n    let(:customer_unauthorized) { create(:customer, organization: organization_unauthorized) }\n\n    let(:agent) { create(:agent, groups: [ticket.group]) }\n\n    describe 'listing information' do\n\n      before do\n        ticket\n      end\n\n      shared_examples 'has access' do\n        it 'succeeds' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to include(ticket.id)\n          expect(json_response['ticket_ids_closed']).to be_blank\n        end\n      end\n\n      shared_examples 'has no access' do\n        it 'fails' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to be_blank\n          expect(json_response['ticket_ids_closed']).to be_blank\n          expect(json_response['assets']).to be_blank\n        end\n      end\n\n      context 'as agent', authenticated_as: -> { agent } do\n        include_examples 'has access'\n      end\n\n      context 'as authorized customer', authenticated_as: -> { customer_authorized } do\n        include_examples 'has no access'\n      end\n\n      context 'as unauthorized customer', authenticated_as: -> { customer_unauthorized } do\n        include_examples 'has no access'\n      end\n    end\n  end\nend\n"], "fixing_code": ["# Copyright (C) 2012-2016 Zammad Foundation, http://zammad-foundation.org/\n\nclass TicketArticlesController < ApplicationController\n  include CreatesTicketArticles\n  include ClonesTicketArticleAttachments\n\n  prepend_before_action -> { authorize! }, only: %i[index import_example import_start]\n  prepend_before_action :authentication_check\n\n  # GET /articles\n  def index\n    model_index_render(Ticket::Article, params)\n  end\n\n  # GET /articles/1\n  def show\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full\n      return\n    end\n\n    render json: article.attributes_with_association_names\n  end\n\n  # GET /ticket_articles/by_ticket/1\n  def index_by_ticket\n    ticket = Ticket.find(params[:id])\n    authorize!(ticket, :show?)\n\n    articles = []\n\n    if response_expand?\n      ticket.articles.each do |article|\n        next if !authorized?(article, :show?)\n\n        result = article.attributes_with_association_names\n        articles.push result\n      end\n\n      render json: articles, status: :ok\n      return\n    end\n\n    if response_full?\n      assets = {}\n      record_ids = []\n      ticket.articles.each do |article|\n        next if !authorized?(article, :show?)\n\n        record_ids.push article.id\n        assets = article.assets({})\n      end\n      render json: {\n        record_ids: record_ids,\n        assets:     assets,\n      }, status: :ok\n      return\n    end\n\n    ticket.articles.each do |article|\n      next if !authorized?(article, :show?)\n\n      articles.push article.attributes_with_association_names\n    end\n    render json: articles, status: :ok\n  end\n\n  # POST /articles\n  def create\n    ticket = Ticket.find(params[:ticket_id])\n    authorize!(ticket)\n    article = article_create(ticket, params)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :created\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full, status: :created\n      return\n    end\n\n    render json: article.attributes_with_association_names, status: :created\n  end\n\n  # PUT /articles/1\n  def update\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n\n    # only update internal and highlight info\n    clean_params = {}\n    if !params[:internal].nil?\n      clean_params[:internal] = params[:internal]\n    end\n    if params.dig(:preferences, :highlight).present?\n      clean_params = article.param_preferences_merge(clean_params.merge(\n                                                       preferences: {\n                                                         highlight: params[:preferences][:highlight].to_s\n                                                       }\n                                                     ))\n    end\n\n    article.update!(clean_params)\n\n    if response_expand?\n      result = article.attributes_with_association_names\n      render json: result, status: :ok\n      return\n    end\n\n    if response_full?\n      full = Ticket::Article.full(params[:id])\n      render json: full, status: :ok\n      return\n    end\n\n    render json: article.attributes_with_association_names, status: :ok\n  end\n\n  # DELETE /api/v1/ticket_articles/:id\n  def destroy\n    article = Ticket::Article.find(params[:id])\n    authorize!(article)\n    article.destroy!\n    render json: {}, status: :ok\n  end\n\n  # POST /ticket_attachment_upload_clone_by_article\n  def ticket_attachment_upload_clone_by_article\n    article = Ticket::Article.find(params[:article_id])\n    authorize!(article.ticket, :show?)\n\n    render json: {\n      attachments: article_attachments_clone(article),\n    }\n  end\n\n  # GET /ticket_attachment/:ticket_id/:article_id/:id\n  def attachment\n    ticket = Ticket.lookup(id: params[:ticket_id])\n    authorize!(ticket, :show?)\n\n    article = Ticket::Article.find(params[:article_id])\n    if ticket.id != article.ticket_id\n\n      # check if requested ticket got merged\n      if ticket.state.state_type.name != 'merged'\n        raise Exceptions::NotAuthorized, 'No access, article_id/ticket_id is not matching.'\n      end\n\n      ticket = article.ticket\n      authorize!(ticket, :show?)\n    end\n\n    list = article.attachments || []\n    access = false\n    list.each do |item|\n      if item.id.to_i == params[:id].to_i\n        access = true\n      end\n    end\n    raise Exceptions::NotAuthorized, 'Requested file id is not linked with article_id.' if !access\n\n    # find file\n    file = Store.find(params[:id])\n\n    disposition = sanitized_disposition\n\n    content = nil\n    if params[:view].present? && file.preferences[:resizable] == true\n      if file.preferences[:content_inline] == true && params[:view] == 'inline'\n        content = file.content_inline\n      elsif file.preferences[:content_preview] == true && params[:view] == 'preview'\n        content = file.content_preview\n      end\n    end\n\n    if content.blank?\n      content = file.content\n    end\n\n    send_data(\n      content,\n      filename:    file.filename,\n      type:        file.preferences['Content-Type'] || file.preferences['Mime-Type'] || 'application/octet-stream',\n      disposition: disposition\n    )\n  end\n\n  # GET /ticket_article_plain/1\n  def article_plain\n    article = Ticket::Article.find(params[:id])\n    authorize!(article, :show?)\n\n    file = article.as_raw\n\n    # find file\n    return if !file\n\n    send_data(\n      file.content,\n      filename:    file.filename,\n      type:        'message/rfc822',\n      disposition: 'inline'\n    )\n  end\n\n  # @path    [GET] /ticket_articles/import_example\n  #\n  # @summary          Download of example CSV file.\n  # @notes            The requester have 'admin' permissions to be able to download it.\n  # @example          curl -u 'me@example.com:test' http://localhost:3000/api/v1/ticket_articles/import_example\n  #\n  # @response_message 200 File download.\n  # @response_message 401 Invalid session.\n  def import_example\n    csv_string = Ticket::Article.csv_example(\n      col_sep: ',',\n    )\n    send_data(\n      csv_string,\n      filename:    'example.csv',\n      type:        'text/csv',\n      disposition: 'attachment'\n    )\n\n  end\n\n  # @path    [POST] /ticket_articles/import\n  #\n  # @summary          Starts import.\n  # @notes            The requester have 'admin' permissions to be create a new import.\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/ticket_articles.csv' 'https://your.zammad/api/v1/ticket_articles/import?try=true'\n  # @example          curl -u 'me@example.com:test' -F 'file=@/path/to/file/ticket_articles.csv' 'https://your.zammad/api/v1/ticket_articles/import'\n  #\n  # @response_message 201 Import started.\n  # @response_message 401 Invalid session.\n  def import_start\n    if Setting.get('import_mode') != true\n      raise 'Only can import tickets if system is in import mode.'\n    end\n\n    string = params[:data]\n    if string.blank? && params[:file].present?\n      string = params[:file].read.force_encoding('utf-8')\n    end\n    raise Exceptions::UnprocessableEntity, 'No source data submitted!' if string.blank?\n\n    result = Ticket::Article.csv_import(\n      string:       string,\n      parse_params: {\n        col_sep: ';',\n      },\n      try:          params[:try],\n    )\n    render json: result, status: :ok\n  end\n\n  def retry_security_process\n    article = Ticket::Article.find(params[:id])\n    authorize!(article, :update?)\n\n    result = SecureMailing.retry(article)\n\n    render json: result\n  end\n\n  private\n\n  def sanitized_disposition\n    disposition = params.fetch(:disposition, 'inline')\n    valid_disposition = %w[inline attachment]\n    return disposition if valid_disposition.include?(disposition)\n\n    raise Exceptions::NotAuthorized, \"Invalid disposition #{disposition} requested. Only #{valid_disposition.join(', ')} are valid.\"\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket Article API endpoints', type: :request do\n\n  let(:admin) do\n    create(:admin, groups: Group.all)\n  end\n  let!(:group) { create(:group) }\n\n  let(:agent) do\n    create(:agent, groups: Group.all)\n  end\n  let(:customer) do\n    create(:customer)\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent and articles' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body: 'some body',\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n\n      params = {\n        ticket_id:    json_response['id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(2)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/html', # or text/html\n        body:         'some body <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\nAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" />',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).not_to match(/some body <img src=\"cid:.+?/)\n      expect(json_response['body']).to match(%r{some body <img src=\"/api/v1/ticket_attachment/.+?\" alt=\"Red dot\"})\n      expect(json_response['content_type']).to eq('text/html')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      expect(ticket.articles.count).to eq(3)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(1)\n      expect(ticket.articles[2].attachments[0]['id']).to be_truthy\n      expect(ticket.articles[2].attachments[0]['filename']).to eq('image1.png')\n      expect(ticket.articles[2].attachments[0]['size']).to eq('21')\n      expect(ticket.articles[2].attachments[0]['preferences']['Mime-Type']).to eq('image/png')\n      expect(ticket.articles[2].attachments[0]['preferences']['Content-Disposition']).to eq('inline')\n      expect(ticket.articles[2].attachments[0]['preferences']['Content-ID']).to match(/@zammad.example.com/)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/html', # or text/html\n        body:         'some body',\n        type:         'note',\n        attachments:  [\n          { 'filename'  => 'some_file.txt',\n            'data'      => 'dGVzdCAxMjM=',\n            'mime-type' => 'text/plain' },\n        ],\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/html')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      expect(ticket.articles.count).to eq(4)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(1)\n      expect(ticket.articles[3].attachments.count).to eq(1)\n\n      get \"/api/v1/ticket_articles/#{json_response['id']}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments'].count).to eq(1)\n      expect(json_response['attachments'][0]['id']).to be_truthy\n      expect(json_response['attachments'][0]['filename']).to eq('some_file.txt')\n      expect(json_response['attachments'][0]['size']).to eq('8')\n      expect(json_response['attachments'][0]['preferences']['Mime-Type']).to eq('text/plain')\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain',\n        body:         'some body',\n        type:         'note',\n        internal:     false,\n        preferences:  {\n          some_key1: 123,\n          highlight: '123',\n        },\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['highlight']).to eq('123')\n      expect(ticket.articles.count).to eq(5)\n\n      params = {\n        body:        'some body 2',\n        internal:    true,\n        preferences: {\n          some_key2: 'abc',\n          highlight: '234',\n        },\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).not_to eq('some body 2')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).not_to eq('abc')\n      expect(json_response['preferences']['highlight']).to eq('234')\n\n    end\n\n    it 'does ticket create with customer and articles' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'Users',\n        article: {\n          body: 'some body',\n        }\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n\n      params = {\n        ticket_id:    json_response['id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(2)\n      expect(ticket.articles[1].sender.name).to eq('Customer')\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body',\n        sender:       'Agent',\n        type:         'note',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(3)\n      expect(ticket.articles[2].sender.name).to eq('Customer')\n      expect(ticket.articles[2].internal).to eq(false)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n\n      params = {\n        ticket_id:    json_response['ticket_id'],\n        content_type: 'text/plain', # or text/html\n        body:         'some body 2',\n        sender:       'Agent',\n        type:         'note',\n        internal:     true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['subject']).to be_nil\n      expect(json_response['body']).to eq('some body 2')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n\n      ticket = Ticket.find(json_response['ticket_id'])\n      expect(ticket.articles.count).to eq(4)\n      expect(ticket.articles[3].sender.name).to eq('Customer')\n      expect(ticket.articles[3].internal).to eq(false)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n      expect(ticket.articles[3].attachments.count).to eq(0)\n\n      # add internal article\n      article = create(\n        :ticket_article,\n        ticket_id: ticket.id,\n        internal:  true,\n        sender:    Ticket::Article::Sender.find_by(name: 'Agent'),\n        type:      Ticket::Article::Type.find_by(name: 'note'),\n      )\n      expect(ticket.articles.count).to eq(5)\n      expect(ticket.articles[4].sender.name).to eq('Agent')\n      expect(ticket.articles[4].updated_by_id).to eq(1)\n      expect(ticket.articles[4].created_by_id).to eq(1)\n      expect(ticket.articles[0].attachments.count).to eq(0)\n      expect(ticket.articles[1].attachments.count).to eq(0)\n      expect(ticket.articles[2].attachments.count).to eq(0)\n      expect(ticket.articles[3].attachments.count).to eq(0)\n      expect(ticket.articles[4].attachments.count).to eq(0)\n\n      get \"/api/v1/ticket_articles/#{article.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_articles/#{article.id}\", params: { internal: false }, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n    end\n\n    it 'does create phone ticket for customer and expected origin_by_id' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body:   'some body',\n          sender: 'Customer',\n          type:   'phone',\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['title']).to eq('a new ticket #1')\n\n      expect(Ticket::Article.where(ticket_id: json_response['id']).count).to eq(2) # original + auto responder\n\n      article = Ticket::Article.where(ticket_id: json_response['id']).first\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.from).to eq(\"#{customer.firstname} #{customer.lastname} <#{customer.email}>\")\n    end\n\n    it 'does create phone ticket by customer and manipulate origin_by_id' do\n      params = {\n        title:       'a new ticket #1',\n        group:       'Users',\n        customer_id: customer.id,\n        article:     {\n          body:         'some body',\n          sender:       'Customer',\n          type:         'phone',\n          origin_by_id: 1,\n        }\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      expect(Ticket::Article.where(ticket_id: json_response['id']).count).to eq(1) # ony original\n\n      article = Ticket::Article.where(ticket_id: json_response['id']).first\n      expect(article.origin_by_id).to eq(customer.id)\n    end\n\n    it 'does ticket split with html - check attachments' do\n      ticket = create(:ticket, group: group)\n      article = create(\n        :ticket_article,\n        ticket_id:    ticket.id,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      params = {\n        form_id: 'new_form_id123',\n      }\n      authenticated_as(agent)\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n    end\n\n    it 'does ticket split with plain - check attachments' do\n      ticket = create(\n        :ticket,\n        group:         group,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        ticket_id:     ticket.id,\n        type:          Ticket::Article::Type.lookup(name: 'note'),\n        sender:        Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:          '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type:  'text/plain',\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      params = {\n        form_id: 'new_form_id123',\n      }\n      authenticated_as(agent)\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      post \"/api/v1/ticket_attachment_upload_clone_by_article/#{article.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n    end\n  end\n\n  describe 'DELETE /api/v1/ticket_articles/:id', authenticated_as: -> { user } do\n    let(:other_agent) { create(:agent, groups: [Group.first]) }\n\n    let(:ticket) do\n      create(:ticket, group: Group.first)\n    end\n\n    let(:article_communication) do\n      create(:ticket_article,\n             sender_name: 'Agent', type_name: 'email', ticket: ticket,\n             updated_by_id: agent.id, created_by_id: agent.id )\n    end\n\n    let(:article_note_self) do\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note', ticket: ticket,\n             updated_by_id: user.id, created_by_id: user.id )\n    end\n\n    let(:article_note_other) do\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note', ticket: ticket,\n             updated_by_id: other_agent.id, created_by_id: other_agent.id )\n    end\n\n    let(:article_note_customer) do\n      create(:ticket_article,\n             sender_name: 'Customer', internal: false, type_name: 'note', ticket: ticket,\n             updated_by_id: customer.id, created_by_id: customer.id )\n    end\n\n    let(:article_note_communication_self) do\n      create(:ticket_article_type, name: 'note_communication', communication: true)\n\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note_communication', ticket: ticket,\n             updated_by_id: user.id, created_by_id: user.id )\n    end\n\n    let(:article_note_communication_other) do\n      create(:ticket_article_type, name: 'note_communication', communication: true)\n\n      create(:ticket_article,\n             sender_name: 'Agent', internal: true, type_name: 'note_communication', ticket: ticket,\n             updated_by_id: other_agent.id, created_by_id: other_agent.id )\n    end\n\n    def delete_article_via_rest(article)\n      delete \"/api/v1/ticket_articles/#{article.id}\", params: {}, as: :json\n    end\n\n    shared_examples 'succeeds' do\n      it 'succeeds' do\n        expect { delete_article_via_rest(article) }.to change { Ticket::Article.exists?(id: article.id) }\n      end\n    end\n\n    shared_examples 'fails' do\n      it 'fails' do\n        expect { delete_article_via_rest(article) }.not_to change { Ticket::Article.exists?(id: article.id) }\n      end\n    end\n\n    shared_examples 'deleting' do |item:, now:, later:, much_later:|\n      context \"deleting #{item}\" do\n        let(:article) { send(item) }\n\n        include_examples now ? 'succeeds' : 'fails'\n\n        context '8 minutes later' do\n          before { article && travel(8.minutes) }\n\n          include_examples later ? 'succeeds' : 'fails'\n        end\n\n        context '11 minutes later' do\n          before { article && travel(11.minutes) }\n\n          include_examples much_later ? 'succeeds' : 'fails'\n        end\n      end\n    end\n\n    context 'as admin' do\n      let(:user) { admin }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_self',\n                       now: true, later: true, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n    end\n\n    context 'as agent' do\n      let(:user) { agent }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_self',\n                       now: true, later: true, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n    end\n\n    context 'as customer' do\n      let(:user) { customer }\n\n      include_examples 'deleting',\n                       item: 'article_communication',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_other',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_customer',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_self',\n                       now: false, later: false, much_later: false\n\n      include_examples 'deleting',\n                       item: 'article_note_communication_other',\n                       now: false, later: false, much_later: false\n\n    end\n\n    context 'with custom timeframe' do\n      before { Setting.set 'ui_ticket_zoom_article_delete_timeframe', 6000 }\n\n      let(:article) { article_note_self }\n\n      context 'as admin' do\n        let(:user) { admin }\n\n        context 'deleting before timeframe' do\n          before { article && travel(5000.seconds) }\n\n          include_examples 'succeeds'\n        end\n\n        context 'deleting after timeframe' do\n          before { article && travel(8000.seconds) }\n\n          include_examples 'fails'\n        end\n      end\n\n      context 'as agent' do\n        let(:user) { agent }\n\n        context 'deleting before timeframe' do\n          before { article && travel(5000.seconds) }\n\n          include_examples 'succeeds'\n        end\n\n        context 'deleting after timeframe' do\n          before { article && travel(8000.seconds) }\n\n          include_examples 'fails'\n        end\n      end\n    end\n\n    context 'with timeframe as 0' do\n      before { Setting.set 'ui_ticket_zoom_article_delete_timeframe', 0 }\n\n      let(:article) { article_note_self }\n\n      context 'as agent' do\n        let(:user) { agent }\n\n        context 'deleting long after' do\n          before { article && travel(99.days) }\n\n          include_examples 'succeeds'\n        end\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Ticket', type: :request do\n\n  let!(:ticket_group) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let!(:ticket_group_without_create) do\n    create(:group, email_address: create(:email_address) )\n  end\n  let(:admin) do\n    create(:admin, groups: Group.all, firstname: 'Tickets', lastname: 'Admin')\n  end\n  let!(:agent) do\n    create(:agent, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n  end\n  let!(:agent_change_only) do\n    user = create(:agent, groups: Group.all, firstname: 'Tickets', lastname: 'Agent')\n    user.group_names_access_map = {\n      ticket_group_without_create.name => %w[read change],\n    }\n    user\n  end\n  let!(:customer) do\n    create(\n      :customer,\n      login:     'tickets-customer1@example.com',\n      firstname: 'Tickets',\n      lastname:  'Customer1',\n      email:     'tickets-customer1@example.com',\n    )\n  end\n\n  describe 'request handling' do\n\n    it 'does ticket create with agent - missing group (01.01)' do\n      params = {\n        title:   'a new ticket #1',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error_human']).to eq('Group can\\'t be blank')\n    end\n\n    it 'does ticket create with agent - wrong group (01.02)' do\n      params = {\n        title:   'a new ticket #2',\n        group:   'not_existing',\n        article: {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('No lookup value found for \\'group\\': \"not_existing\"')\n    end\n\n    it 'does ticket create with agent - valid group but no create permissions (01.02a)' do\n      params = {\n        title:       'a new ticket #1',\n        group:       ticket_group_without_create.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'Customer',\n          type:         'note',\n        },\n      }\n      authenticated_as(agent_change_only)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket create with agent - missing article.body (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {},\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article (01.03)' do\n      params = {\n        title:       'a new ticket #3',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article and customer.email (01.04)' do\n      params = {\n        title:    'a new ticket #3',\n        group:    ticket_group.name,\n        priority: '2 normal',\n        state:    'new',\n        customer: customer.email,\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 0 (01.05)' do\n      params = {\n        title:       'a new ticket #4',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    0,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 0')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - \"\" (01.06)' do\n      params = {\n        title:       'a new ticket #5',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    '',\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #5')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - wrong owner_id - 99999 (01.07)' do\n      params = {\n        title:       'a new ticket #6',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    99_999,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid value for param \\'owner_id\\': 99999')\n    end\n\n    it 'does ticket create with agent - wrong owner_id - nil (01.08)' do\n      params = {\n        title:       'a new ticket #7',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        owner_id:    nil,\n        state:       'new',\n        customer_id: customer.id,\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #7')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.09)' do\n      params = {\n        title:       'a new ticket #9',\n        group:       ticket_group.name,\n        priority:    '2 normal',\n        state:       'new',\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #9')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with guess customer (01.10)' do\n      params = {\n        title:       'a new ticket #10',\n        group:       ticket_group.name,\n        customer_id: 'guess:some_new_customer@example.com',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #10')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash (01.11)' do\n      params = {\n        title:    'a new ticket #11',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.1')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.2',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.2')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.3',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Agent',\n          from:      'somebody',\n          body:      'some test 123',\n          origin_by: 'some_new_customer@example.com',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.3')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('some firstname some lastname')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (01.11)' do\n      params = {\n        title:    'a new ticket #11.4',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:    'Customer',\n          body:      'some test 123',\n          origin_by: customer.login,\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #11.4')\n      expect(json_response['customer_id']).to eq(User.lookup(email: 'some_new_customer@example.com').id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(agent.id)\n      expect(article.created_by_id).to eq(agent.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with missing body - with customer.id (01.12)' do\n      params = {\n        title:       'a new ticket #12',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Need at least article: { body: \"some text\" }')\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.13)' do\n      params = {\n        title:       'a new ticket #13',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #13')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and attachment with customer (01.14)' do\n      params = {\n        title:       'a new ticket #14',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            {\n              'filename'  => 'some_file1.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain',\n            },\n            {\n              'filename'  => 'some_file2.txt',\n              'data'      => 'w6TDtsO8w58=',\n              'mime-type' => 'text/plain',\n            },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #14')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('test 123')\n      expect(file.filename).to eq('some_file1.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent - minimal article and simple invalid base64 attachment with customer (01.15)' do\n      params = {\n        title:       'a new ticket #15',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'ABC_INVALID_BASE64',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and large invalid base64 attachment with customer (01.15a)' do\n      params = {\n        title:       'a new ticket #15a',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => \"LARGE_INVALID_BASE64_#{'#' * 20_000_000}\",\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Invalid base64 for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 with linebreaks attachment with customer (01.15b)' do\n      params = {\n        title:       'a new ticket #15b',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => Base64.encode64('a' * 1_000),\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15b')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and valid multiline base64 without linebreaks attachment with customer (01.15c)' do\n      params = {\n        title:       'a new ticket #15c',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename'  => 'some_file.txt',\n              'data'      => Base64.strict_encode64('a' * 1_000),\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['title']).to eq('a new ticket #15c')\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(1)\n      file = ticket.articles.first.attachments.first\n      expect(file.content).to eq('a' * 1_000)\n    end\n\n    it 'does ticket create with agent - minimal article and attachment invalid base64 with customer (01.16)' do\n      params = {\n        title:       'a new ticket #16',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          subject:     'some test 123',\n          body:        'some test 123',\n          attachments: [\n            { 'filename' => 'some_file.txt',\n              'data'     => 'dGVzdCAxMjM=' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:unprocessable_entity)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Attachment needs \\'mime-type\\' param for attachment with index \\'0\\'')\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.17)' do\n      params = {\n        title:       'a new ticket #17',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n  AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n  9TXL0Y4OHwAAAABJRU5ErkJggg==\" alt=\"Red dot\" /> <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\">',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #17')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('d3c1e09bdefb92b6a06b791a24ca9599')\n      expect(file.filename).to eq('image1.png')\n      expect(file.preferences['Mime-Type']).to eq('image/png')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image2.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      expect(file.preferences['Content-ID']).to be_truthy\n    end\n\n    it 'does ticket create with agent - minimal article and inline attachments with customer (01.18)' do\n      params = {\n        title:       'a new ticket #18',\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        article:     {\n          content_type: 'text/html',\n          subject:      'some test 123',\n          body:         'some test 123 <img src=\"data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAJAAD/4QMtaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzJCOTE2NzlGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzJCOTE2N0FGQUEwMTFFNjg0M0NGQjU0OUU4MTFEOEIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDMkI5MTY3N0ZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDMkI5MTY3OEZBQTAxMUU2ODQzQ0ZCNTQ5RTgxMUQ4QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEABQRERoTGioZGSo1KCEoNTEpKCgpMUE4ODg4OEFEREREREREREREREREREREREREREREREREREREREREREREREQBFhoaIh0iKRoaKTkpIik5RDktLTlEREREOERERERERERERERERERERERERERERERERERERERERERERERERERERP/AABEIABAADAMBIgACEQEDEQH/xABbAAEBAAAAAAAAAAAAAAAAAAAEBQEBAQAAAAAAAAAAAAAAAAAABAUQAAEEAgMAAAAAAAAAAAAAAAABAhIDESIxBAURAAICAwAAAAAAAAAAAAAAAAESABNRoQP/2gAMAwEAAhEDEQA/AJDq1rfF3Imeg/1+lFy2oR564DKWWWbweV+Buf/Z\"\n  >',\n          attachments:  [\n            { 'filename'  => 'some_file.txt',\n              'data'      => 'dGVzdCAxMjM=',\n              'mime-type' => 'text/plain' },\n          ],\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #18')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(ticket.articles.count).to eq(1)\n      expect(ticket.articles.first.attachments.count).to eq(2)\n      file = ticket.articles.first.attachments[0]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('006a2ca3793b550c8fe444acdeb39252')\n      expect(file.filename).to eq('image1.jpeg')\n      expect(file.preferences['Mime-Type']).to eq('image/jpeg')\n      expect(file.preferences['Content-ID']).to be_truthy\n      expect(file.preferences['Content-ID']).to match(/#{ticket.id}\\..+?@zammad.example.com/)\n      file = ticket.articles.first.attachments[1]\n      expect(Digest::MD5.hexdigest(file.content)).to eq('39d0d586a701e199389d954f2d592720')\n      expect(file.filename).to eq('some_file.txt')\n      expect(file.preferences['Mime-Type']).to eq('text/plain')\n      expect(file.preferences['Content-ID']).to be_falsey\n    end\n\n    it 'does ticket create with agent (02.02)' do\n      params = {\n        title:    'a new ticket #1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: 'tickets-customer1@example.com',\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n        },\n        links:    {\n          Ticket: {\n            parent: [1],\n          }\n        }\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #1')\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      links = Link.list(\n        link_object:       'Ticket',\n        link_object_value: json_response['id'],\n      )\n      expect(links[0]['link_type']).to eq('child')\n      expect(links[0]['link_object']).to eq('Ticket')\n      expect(links[0]['link_object_value']).to eq(1)\n    end\n\n    it 'does ticket with wrong ticket id (02.03)' do\n      group = create(:group)\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group_id:    group.id,\n        customer_id: customer.id,\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (02.04)' do\n      title = \"ticket with corret ticket id testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer.id,\n        preferences: {\n          some_key1: 123,\n        },\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent.id,\n        preferences: {\n          some_key2: 'abc',\n        },\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(agent.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(1)\n      expect(json_response['preferences']['some_key1']).to eq(123)\n      expect(json_response['preferences']['some_key2']).to eq('abc')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Agent')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['internal']).to eq(false)\n      expect(article_json_response['created_by_id']).to eq(agent.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  true,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Agent via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).not_to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(agent.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        internal:  false,\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response['internal']).to eq(false)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (communication articles cannot be deleted)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket with correct ticket id (02.05)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with corret ticket id',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      authenticated_as(admin)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id')\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       'ticket with corret ticket id - 2',\n        customer_id: agent.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq('ticket with corret ticket id - 2')\n      expect(json_response['customer_id']).to eq(agent.id)\n      expect(json_response['updated_by_id']).to eq(admin.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      params = {\n        subject:  'new subject',\n        internal: true,\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Admin')\n      expect(json_response['subject']).not_to eq('new subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(true)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq(%(\"Tickets Admin via #{ticket_group.email_address.realname}\" <#{ticket_group.email_address.email}>))\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(admin.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n    end\n\n    it 'does ticket pagination (02.05)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n      tickets = []\n      (1..20).each do |count|\n        ticket = create(\n          :ticket,\n          title:       \"#{title} - #{count}\",\n          group:       ticket_group,\n          customer_id: customer.id,\n        )\n        create(\n          :ticket_article,\n          type:      Ticket::Article::Type.lookup(name: 'note'),\n          sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n          ticket_id: ticket.id,\n        )\n        tickets.push ticket\n        travel 2.seconds\n      end\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][19]).to eq(tickets[0].id)\n      expect(json_response['tickets_count']).to eq(20)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=10\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][9]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(10)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=1&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[19].id)\n      expect(json_response['tickets'][4]).to eq(tickets[15].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40&page=2&per_page=5\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(tickets[14].id)\n      expect(json_response['tickets'][4]).to eq(tickets[10].id)\n      expect(json_response['tickets_count']).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=1&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(5)\n      expect(json_response[0]['id']).to eq(tickets[0].id)\n      expect(json_response[4]['id']).to eq(tickets[4].id)\n      expect(json_response.count).to eq(5)\n\n      get '/api/v1/tickets?limit=40&page=2&per_page=5', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      tickets = Ticket.order(:id).limit(10)\n      expect(json_response[0]['id']).to eq(tickets[5].id)\n      expect(json_response[4]['id']).to eq(tickets[9].id)\n      expect(json_response.count).to eq(5)\n\n    end\n\n    it 'does ticket create with customer minimal (03.01)' do\n      params = {\n        title:    'a new ticket #c1',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        article:  {\n          body: 'some body',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket create with customer with wrong customer (03.02)' do\n      params = {\n        title:       'a new ticket #c2',\n        state:       'new',\n        priority:    '2 normal',\n        group:       ticket_group.name,\n        customer_id: agent.id,\n        article:     {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket create with customer with wrong customer hash (03.03)' do\n      params = {\n        title:    'a new ticket #c2',\n        state:    'new',\n        priority: '2 normal',\n        group:    ticket_group.name,\n        customer: {\n          firstname: agent.firstname,\n          lastname:  agent.lastname,\n          email:     agent.email,\n        },\n        article:  {\n          content_type: 'text/plain', # or text/html\n          body:         'some body',\n          sender:       'System',\n        },\n      }\n      authenticated_as(customer)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #c2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n    end\n\n    it 'does ticket with wrong ticket id (03.04)' do\n      ticket = create(\n        :ticket,\n        title:       'ticket with wrong ticket id',\n        group:       ticket_group,\n        customer_id: agent.id,\n      )\n      authenticated_as(customer)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      params = {\n        title: 'ticket with wrong ticket id - 2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n    end\n\n    it 'does ticket with correct ticket id (03.05)' do\n      title = \"ticket with corret ticket id testme#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:       title,\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      authenticated_as(customer)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(1)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        title:       \"#{title} - 2\",\n        customer_id: agent.id,\n      }\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(\"#{title} - 2\")\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(1)\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      article_json_response = json_response\n      expect(article_json_response).to be_a_kind_of(Hash)\n      expect(article_json_response['ticket_id']).to eq(ticket.id)\n      expect(article_json_response['from']).to eq('Tickets Customer1')\n      expect(article_json_response['subject']).to eq('some subject')\n      expect(article_json_response['body']).to eq('some body')\n      expect(article_json_response['content_type']).to eq('text/plain')\n      expect(article_json_response['created_by_id']).to eq(customer.id)\n      expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      Scheduler.worker(true)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      params = {\n        condition: {\n          'ticket.title' => {\n            operator: 'contains',\n            value:    title,\n          },\n        },\n      }\n      post '/api/v1/tickets/search', params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets'][0]).to eq(ticket.id)\n      expect(json_response['tickets_count']).to eq(1)\n\n      delete \"/api/v1/ticket_articles/#{article_json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (agent permission required)!')\n\n      params = {\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'email',\n        sender:    'Agent',\n      }\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['created_by_id']).to eq(customer.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id)\n\n      delete \"/api/v1/ticket_articles/#{json_response['id']}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (agent permission required)!')\n\n      params = {\n        from:      'something which should not be changed on server side',\n        ticket_id: ticket.id,\n        subject:   'some subject',\n        body:      'some body',\n        type:      'web',\n        sender:    'Agent',\n        internal:  true,\n      }\n\n      post '/api/v1/ticket_articles', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['ticket_id']).to eq(ticket.id)\n      expect(json_response['from']).to eq('Tickets Customer1 <tickets-customer1@example.com>')\n      expect(json_response['subject']).to eq('some subject')\n      expect(json_response['body']).to eq('some body')\n      expect(json_response['content_type']).to eq('text/plain')\n      expect(json_response['internal']).to eq(false)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Customer').id)\n      expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'web').id)\n\n      params = {\n        subject: 'new subject',\n      }\n      put \"/api/v1/ticket_articles/#{json_response['id']}\", params: params, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (ticket.agent or admin permission required)!')\n\n      delete \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized (admin permission required)!')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer)\n      params = {\n        title:    'a new ticket #3.6',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          body:      'some test 123',\n          origin_by: agent.login,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer.id)\n      expect(article.created_by_id).to eq(customer.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket create with agent - minimal article with customer hash with article.origin_by (03.6)' do\n      authenticated_as(customer)\n      params = {\n        title:    'a new ticket #3.6.1',\n        group:    ticket_group.name,\n        customer: {\n          firstname: 'some firstname',\n          lastname:  'some lastname',\n          email:     'some_new_customer@example.com',\n        },\n        article:  {\n          sender:       'Agent',\n          body:         'some test 123',\n          origin_by_id: agent.id,\n        },\n      }\n\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['state_id']).to eq(Ticket::State.lookup(name: 'new').id)\n      expect(json_response['title']).to eq('a new ticket #3.6.1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(customer.id)\n      expect(json_response['created_by_id']).to eq(customer.id)\n      ticket = Ticket.find(json_response['id'])\n      article = ticket.articles.first\n      expect(article.updated_by_id).to eq(customer.id)\n      expect(article.created_by_id).to eq(customer.id)\n      expect(article.origin_by_id).to eq(customer.id)\n      expect(article.sender.name).to eq('Customer')\n      expect(article.type.name).to eq('note')\n      expect(article.from).to eq('Tickets Customer1')\n    end\n\n    it 'does ticket show and response format (04.01)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      authenticated_as(agent)\n      get \"/api/v1/tickets/#{ticket.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['owner']).to eq(ticket.owner.login)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?expand=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=true\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      get \"/api/v1/tickets/#{ticket.id}?full=false\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['id']).to eq(ticket.id)\n      expect(json_response['title']).to eq(ticket.title)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['owner']).to be_falsey\n      expect(json_response['customer_id']).to eq(ticket.customer_id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket index and response format (04.02)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      authenticated_as(agent)\n      get '/api/v1/tickets', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?expand=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['group']).to eq(ticket.group.name)\n      expect(json_response[1]['priority']).to eq(ticket.priority.name)\n      expect(json_response[1]['owner']).to eq(ticket.owner.login)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?expand=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n\n      get '/api/v1/tickets?full=true', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['record_ids'].class).to eq(Array)\n      expect(json_response['record_ids'][0]).to eq(1)\n      expect(json_response['record_ids'][1]).to eq(ticket.id)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(ticket.title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      get '/api/v1/tickets?full=false', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Array)\n      expect(json_response[0]).to be_a_kind_of(Hash)\n      expect(json_response[0]['id']).to eq(1)\n      expect(json_response[1]['id']).to eq(ticket.id)\n      expect(json_response[1]['title']).to eq(ticket.title)\n      expect(json_response[1]['group']).to be_falsey\n      expect(json_response[1]['priority']).to be_falsey\n      expect(json_response[1]['owner']).to be_falsey\n      expect(json_response[1]['customer_id']).to eq(ticket.customer_id)\n      expect(json_response[1]['updated_by_id']).to eq(agent.id)\n      expect(json_response[1]['created_by_id']).to eq(agent.id)\n    end\n\n    it 'does ticket create and response format (04.03)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      params = {\n        title:       title,\n        group:       ticket_group.name,\n        customer_id: customer.id,\n        state:       'new',\n        priority:    '2 normal',\n        article:     {\n          body: 'some test 123',\n        },\n      }\n      authenticated_as(agent)\n      post '/api/v1/tickets', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      post '/api/v1/tickets?expand=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq(title)\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      post '/api/v1/tickets?full=true', params: params, as: :json\n      expect(response).to have_http_status(:created)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq(title)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n    end\n\n    it 'does ticket update and response formats (04.04)' do\n      title = \"ticket testagent#{rand(999_999_999)}\"\n      ticket = create(\n        :ticket,\n        title:         title,\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n\n      params = {\n        title: 'a update ticket #1',\n      }\n      authenticated_as(agent)\n      put \"/api/v1/tickets/#{ticket.id}\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to be_falsey\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to be_falsey\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to be_falsey\n      expect(json_response['title']).to eq('a update ticket #1')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      params = {\n        title: 'a update ticket #2',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?expand=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['state_id']).to eq(ticket.state_id)\n      expect(json_response['state']).to eq(ticket.state.name)\n      expect(json_response['priority_id']).to eq(ticket.priority_id)\n      expect(json_response['priority']).to eq(ticket.priority.name)\n      expect(json_response['group_id']).to eq(ticket.group_id)\n      expect(json_response['group']).to eq(ticket.group.name)\n      expect(json_response['title']).to eq('a update ticket #2')\n      expect(json_response['customer_id']).to eq(customer.id)\n      expect(json_response['updated_by_id']).to eq(agent.id)\n      expect(json_response['created_by_id']).to eq(agent.id)\n\n      params = {\n        title: 'a update ticket #3',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['id']).to eq(ticket.id)\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #3')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['customer_id']).to eq(ticket.customer_id)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][agent.id.to_s]['id']).to eq(agent.id)\n      expect(json_response['assets']['User'][agent.id.to_s]['firstname']).to eq(agent.firstname)\n      expect(json_response['assets']['User'][agent.id.to_s]['lastname']).to eq(agent.lastname)\n\n      expect(json_response['assets']['User']).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]).to be_truthy\n      expect(json_response['assets']['User'][customer.id.to_s]['id']).to eq(customer.id)\n      expect(json_response['assets']['User'][customer.id.to_s]['firstname']).to eq(customer.firstname)\n      expect(json_response['assets']['User'][customer.id.to_s]['lastname']).to eq(customer.lastname)\n\n      # it should be not possible to modify the ticket number\n      expected_ticket_number = ticket.number\n      params = {\n        title:  'a update ticket #4',\n        number: '77777',\n      }\n      put \"/api/v1/tickets/#{ticket.id}?full=true\", params: params, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n\n      ticket = Ticket.find(json_response['id'])\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['title']).to eq('a update ticket #4')\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]['number']).to eq(expected_ticket_number)\n    end\n\n    it 'does ticket split with html - check attachments (05.01)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@ZAMMAD.example.com\"/> test <img src=\"cid:15.274327094.140938.3@ZAMMAD.example.com\"/>',\n        content_type: 'text/html',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file2_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file3_normally_should_be_an_image',\n        filename:      'some_file3.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.3@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file4_normally_should_be_an_image',\n        filename:      'some_file4.jpg',\n        preferences:   {\n          'Content-Type' => 'image/jpeg',\n          'Mime-Type'    => 'image/jpeg',\n          'Content-ID'   => '15.274327094.140938.4@zammad.example.com',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket split with plain - check attachments (05.02)' do\n      ticket = create(\n        :ticket,\n        title:         'some title',\n        group:         ticket_group,\n        customer_id:   customer.id,\n        updated_by_id: agent.id,\n        created_by_id: agent.id,\n      )\n      article = create(\n        :ticket_article,\n        type:         Ticket::Article::Type.lookup(name: 'note'),\n        sender:       Ticket::Article::Sender.lookup(name: 'Customer'),\n        body:         '<b>test</b> <img src=\"cid:15.274327094.140938@zammad.example.com\"/>',\n        content_type: 'text/plain',\n        ticket_id:    ticket.id,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file1.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_image',\n        filename:      'some_file2.jpg',\n        preferences:   {\n          'Content-Type'        => 'image/jpeg',\n          'Mime-Type'           => 'image/jpeg',\n          'Content-ID'          => '15.274327094.140938.2@zammad.example.com',\n          'Content-Disposition' => 'inline',\n        },\n        created_by_id: 1,\n      )\n      Store.add(\n        object:        'Ticket::Article',\n        o_id:          article.id,\n        data:          'content_file1_normally_should_be_an_pdf',\n        filename:      'Rechnung_RE-2018-200.pdf',\n        preferences:   {\n          'Content-Type'        => 'application/octet-stream; name=\"Rechnung_RE-2018-200.pdf\"',\n          'Mime-Type'           => 'application/octet-stream',\n          'Content-ID'          => '8AB0BEC88984EE4EBEF643C79C8E0346@zammad.example.com',\n          'Content-Description' => 'Rechnung_RE-2018-200.pdf',\n          'Content-Disposition' => 'attachment',\n        },\n        created_by_id: 1,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(3)\n\n      get \"/api/v1/ticket_split?ticket_id=#{ticket.id}&article_id=#{article.id}&form_id=new_form_id123\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['assets']).to be_truthy\n      expect(json_response['assets']['Ticket']).to be_truthy\n      expect(json_response['assets']['Ticket'][ticket.id.to_s]).to be_truthy\n      expect(json_response['assets']['TicketArticle'][article.id.to_s]).to be_truthy\n      expect(json_response['attachments']).to be_truthy\n      expect(json_response['attachments'].count).to eq(0)\n\n    end\n\n    it 'does ticket merge (07.01)' do\n      group_no_permission = create(:group)\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      ticket3 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_no_permission,\n        customer_id: customer.id,\n      )\n\n      authenticated_as(customer)\n      put \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n\n      authenticated_as(agent)\n      put \"/api/v1/ticket_merge/#{ticket2.id}/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('failed')\n      expect(json_response['message']).to eq('No such master ticket number!')\n\n      put \"/api/v1/ticket_merge/#{ticket3.id}/#{ticket1.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket3.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['error']).to eq('Not authorized')\n      expect(json_response['error_human']).to eq('Not authorized')\n\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket merge - change permission (07.02)' do\n      group_change_permission = Group.create!(\n        name:          'GroupWithChangePermission',\n        active:        true,\n        updated_by_id: 1,\n        created_by_id: 1,\n      )\n      ticket1 = create(\n        :ticket,\n        title:       'ticket merge1',\n        group:       group_change_permission,\n        customer_id: customer.id,\n      )\n      ticket2 = create(\n        :ticket,\n        title:       'ticket merge2',\n        group:       group_change_permission,\n        customer_id: customer.id,\n      )\n\n      agent.group_names_access_map = { group_change_permission.name => %w[read change] }\n\n      authenticated_as(agent)\n      put \"/api/v1/ticket_merge/#{ticket1.id}/#{ticket2.number}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['result']).to eq('success')\n      expect(json_response['master_ticket']['id']).to eq(ticket2.id)\n    end\n\n    it 'does ticket search sorted (08.01)' do\n      title = \"ticket pagination #{rand(999_999_999)}\"\n\n      ticket1 = create(\n        :ticket,\n        title:       \"#{title} A\",\n        group:       ticket_group,\n        customer_id: customer.id,\n        created_at:  '2018-02-05 17:42:00',\n        updated_at:  '2018-02-05 20:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      ticket2 = create(\n        :ticket,\n        title:       \"#{title} B\",\n        group:       ticket_group,\n        customer_id: customer.id,\n        state:       Ticket::State.lookup(name: 'new'),\n        priority:    Ticket::Priority.lookup(name: '3 hoch'),\n        created_at:  '2018-02-05 19:42:00',\n        updated_at:  '2018-02-05 19:42:00',\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket2.id,\n      )\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'created_at', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'asc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: 'title', order_by: 'desc' }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[asc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket1.id, ticket2.id])\n\n      authenticated_as(admin)\n      get \"/api/v1/tickets/search?query=#{CGI.escape(title)}&limit=40\", params: { sort_by: %w[created_at updated_at], order_by: %w[desc asc] }, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['tickets']).to eq([ticket2.id, ticket1.id])\n    end\n\n    it 'does ticket history ' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n      create(\n        :ticket_article,\n        type:      Ticket::Article::Type.lookup(name: 'note'),\n        sender:    Ticket::Article::Sender.lookup(name: 'Customer'),\n        ticket_id: ticket1.id,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n      expect(json_response).to be_a_kind_of(Hash)\n      expect(json_response['history'].class).to eq(Array)\n      expect(json_response['assets'].class).to eq(Hash)\n      expect(json_response['assets']['User'][customer.id.to_s]).not_to be_nil\n      expect(json_response['assets']['Ticket'][ticket1.id.to_s]).not_to be_nil\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_history/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket related' do\n      ticket1 = create(\n        :ticket,\n        title:       'some title',\n        group:       ticket_group,\n        customer_id: customer.id,\n      )\n\n      authenticated_as(agent)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer)\n      get \"/api/v1/ticket_related/#{ticket1.id}\", params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n    it 'does ticket recent' do\n      authenticated_as(agent)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:ok)\n\n      authenticated_as(customer)\n      get '/api/v1/ticket_recent', params: {}, as: :json\n      expect(response).to have_http_status(:unauthorized)\n    end\n\n  end\n\n  describe 'stats' do\n    let(:ticket1) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket2) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:ticket3) { create(:ticket, customer: customer, organization: organization, group: ticket_group) }\n    let(:customer) { create(:customer, organization: organization) }\n    let(:organization) { create(:organization, shared: false) }\n\n    before do\n      authenticated_as(admin)\n\n      ticket1\n      travel 2.minutes\n      ticket2\n      travel 2.minutes\n      ticket3\n      travel 2.minutes\n      ticket2.touch\n    end\n\n    # https://github.com/zammad/zammad/issues/2296\n    it 'orders tickets by created_at desc (#2296)' do\n      get '/api/v1/ticket_stats', params: { organization_id: organization.id, user_id: customer.id }, as: :json\n\n      expect(response).to have_http_status(:ok)\n      expect(json_response)\n        .to be_a_kind_of(Hash)\n        .and include('user' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n        .and include('organization' => hash_including('open_ids' => [ticket3.id, ticket2.id, ticket1.id]))\n    end\n\n  end\n\n  describe '/api/v1/tickets' do\n    subject(:ticket) { create(:ticket, state_name: 'closed') }\n\n    let(:admin) { create(:admin, groups: [ticket.group]) }\n    let(:agent) { create(:agent, groups: [ticket.group]) }\n    let(:customer) { ticket.customer }\n\n    describe 'reopening a ticket' do\n      shared_examples 'successfully reopen a ticket' do\n        it 'succeeds' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:ok)\n          expect(json_response).to include('state_id' => Ticket::State.find_by(name: 'open').id)\n        end\n      end\n\n      shared_examples 'fail to reopen a ticket' do\n        it 'fails' do\n          put \"/api/v1/tickets/#{ticket.id}\",\n              params: { state_id: Ticket::State.find_by(name: 'open').id },\n              as:     :json\n\n          expect(response).to have_http_status(:unprocessable_entity)\n          expect(json_response).to include('error' => 'Cannot follow-up on a closed ticket. Please create a new ticket.')\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"yes\"' do\n        before { ticket.group.update(follow_up_possible: 'yes') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'successfully reopen a ticket'\n        end\n      end\n\n      context 'when ticket.group.follow_up_possible = \"new_ticket\"' do\n        before { ticket.group.update(follow_up_possible: 'new_ticket') }\n\n        context 'as admin', authenticated_as: -> { admin } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as agent', authenticated_as: -> { agent } do\n          include_examples 'successfully reopen a ticket'\n        end\n\n        context 'as customer', authenticated_as: -> { customer } do\n          include_examples 'fail to reopen a ticket'\n        end\n      end\n    end\n  end\n\n  describe 'GET /api/v1/ticket_customer' do\n\n    subject(:ticket) { create(:ticket, customer: customer_authorized) }\n\n    let(:organization_authorized) { create(:organization) }\n    let(:customer_authorized) { create(:customer, organization: organization_authorized) }\n\n    let(:organization_unauthorized) { create(:organization) }\n    let(:customer_unauthorized) { create(:customer, organization: organization_unauthorized) }\n\n    let(:agent) { create(:agent, groups: [ticket.group]) }\n\n    describe 'listing information' do\n\n      before do\n        ticket\n      end\n\n      shared_examples 'has access' do\n        it 'succeeds' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to include(ticket.id)\n          expect(json_response['ticket_ids_closed']).to be_blank\n        end\n      end\n\n      shared_examples 'has no access' do\n        it 'fails' do\n          get '/api/v1/ticket_customer',\n              params: { customer_id: customer_authorized.id },\n              as:     :json\n\n          expect(json_response['ticket_ids_open']).to be_blank\n          expect(json_response['ticket_ids_closed']).to be_blank\n          expect(json_response['assets']).to be_blank\n        end\n      end\n\n      context 'as agent', authenticated_as: -> { agent } do\n        include_examples 'has access'\n      end\n\n      context 'as authorized customer', authenticated_as: -> { customer_authorized } do\n        include_examples 'has no access'\n      end\n\n      context 'as unauthorized customer', authenticated_as: -> { customer_unauthorized } do\n        include_examples 'has no access'\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/ticket_articles_controller.rb", "spec/requests/ticket/article_spec.rb", "spec/requests/ticket_spec.rb"], "buggy_code_start_loc": [104, 120, 905], "buggy_code_end_loc": [109, 152, 995], "fixing_code_start_loc": [104, 121, 905], "fixing_code_end_loc": [116, 160, 995], "type": "CWE-862", "message": "An issue was discovered in Zammad before 3.5.1. A REST API call allows an attacker to change Ticket Article data in a way that defeats auditing.", "other": {"cve": {"id": "CVE-2020-29160", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-28T08:15:11.617", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Zammad before 3.5.1. A REST API call allows an attacker to change Ticket Article data in a way that defeats auditing."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Zammad versiones anteriores a 3.5.1.&#xa0;Una llamada a la API REST permite a un atacante cambiar los datos de Ticket Article en una manera que anula la auditor\u00eda"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zammad:zammad:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.5.1", "matchCriteriaId": "E145AE87-39C7-4B83-B785-46FF419E2B9D"}]}]}], "references": [{"url": "https://github.com/zammad/zammad/commit/28944de180a88698509a656f61558bf9d7f810f4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://zammad.com/en/advisories/zaa-2020-24", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zammad/zammad/commit/28944de180a88698509a656f61558bf9d7f810f4"}}