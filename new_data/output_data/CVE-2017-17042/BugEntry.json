{"buggy_code": ["# frozen_string_literal: true\nrequire 'fileutils'\n\nclass File\n  RELATIVE_PARENTDIR = '..'\n  RELATIVE_SAMEDIR = '.'\n\n  # @group Manipulating Paths\n\n  # Turns a path +to+ into a relative path from starting\n  # point +from+. The argument +from+ is assumed to be\n  # a filename. To treat it as a directory, make sure it\n  # ends in +File::SEPARATOR+ ('/' on UNIX filesystems).\n  #\n  # @param [String] from the starting filename\n  #   (or directory with +from_isdir+ set to +true+).\n  # @param [String] to the final path that should be made relative.\n  # @return [String] the relative path from +from+ to +to+.\n  def self.relative_path(from, to)\n    from = expand_path(from).split(SEPARATOR)\n    to = expand_path(to).split(SEPARATOR)\n    from.length.times do\n      break if from[0] != to[0]\n      from.shift; to.shift\n    end\n    from.pop\n    join(*(from.map { RELATIVE_PARENTDIR } + to))\n  end\n\n  # Cleans a path by removing extraneous '..', '.' and '/' characters\n  #\n  # @example Clean a path\n  #   File.cleanpath('a/b//./c/../e') # => \"a/b/e\"\n  # @param [String] path the path to clean\n  # @return [String] the sanitized path\n  def self.cleanpath(path)\n    path = path.split(SEPARATOR)\n    path = path.inject([]) do |acc, comp|\n      next acc if comp == RELATIVE_SAMEDIR\n      if comp == RELATIVE_PARENTDIR && !acc.empty? && acc.last != RELATIVE_PARENTDIR\n        acc.pop\n        next acc\n      end\n      acc << comp\n    end\n    File.join(*path)\n  end\n\n  # @group Reading Files\n\n  # Forces opening a file (for writing) by first creating the file's directory\n  # @param [String] file the filename to open\n  # @since 0.5.2\n  def self.open!(file, *args, &block)\n    dir = dirname(file)\n    FileUtils.mkdir_p(dir) unless directory?(dir)\n    open(file, *args, &block)\n  end\n\n  # Reads a file with binary encoding\n  # @return [String] the ascii-8bit encoded data\n  # @since 0.5.3\n  def self.read_binary(file)\n    File.open(file, 'rb', &:read)\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe File do\n  describe \".relative_path\" do\n    it \"returns the relative path between two files\" do\n      expect(File.relative_path('a/b/c/d.html', 'a/b/d/q.html')).to eq '../d/q.html'\n    end\n\n    it \"returns the relative path between two directories\" do\n      expect(File.relative_path('a/b/c/d/', 'a/b/d/')).to eq '../d'\n    end\n\n    it \"returns only the to file if from file is in the same directory as the to file\" do\n      expect(File.relative_path('a/b/c/d', 'a/b/c/e')).to eq 'e'\n    end\n\n    it \"handles non-normalized paths\" do\n      expect(File.relative_path('Hello/./I/Am/Fred', 'Hello/Fred')).to eq '../../Fred'\n      expect(File.relative_path('A//B/C', 'Q/X')).to eq '../../Q/X'\n    end\n  end\n\n  describe \".cleanpath\" do\n    it \"cleans double brackets\" do\n      expect(File.cleanpath('A//B/C')).to eq \"A/B/C\"\n    end\n\n    it \"cleans a path with .\" do\n      expect(File.cleanpath('Hello/./I/.Am/Fred')).to eq \"Hello/I/.Am/Fred\"\n    end\n\n    it \"cleans a path with ..\" do\n      expect(File.cleanpath('Hello/../World')).to eq \"World\"\n    end\n\n    it \"cleans a path with multiple ..\" do\n      expect(File.cleanpath('A/B/C/../../D')).to eq \"A/D\"\n    end\n\n    it \"cleans a path ending in ..\" do\n      expect(File.cleanpath('A/B/C/D/..')).to eq \"A/B/C\"\n    end\n\n    it \"passes the initial directory\" do\n      expect(File.cleanpath('C/../../D')).to eq \"../D\"\n    end\n\n    it \"does not remove multiple '../' at the beginning\" do\n      expect(File.cleanpath('../../A/B')).to eq '../../A/B'\n    end\n  end\n\n  describe \".open!\" do\n    it \"creates the path before opening\" do\n      expect(File).to receive(:directory?).with('/path/to').and_return(false)\n      expect(FileUtils).to receive(:mkdir_p).with('/path/to')\n      expect(File).to receive(:open).with('/path/to/file', 'w')\n      File.open!('/path/to/file', 'w')\n    end\n\n    it \"just opens the file if the path exists\" do\n      expect(File).to receive(:directory?).with('/path/to').and_return(true)\n      expect(FileUtils).not_to receive(:mkdir_p)\n      expect(File).to receive(:open).with('/path/to/file', 'w')\n      File.open!('/path/to/file', 'w')\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\nrequire 'fileutils'\n\nclass File\n  RELATIVE_PARENTDIR = '..'\n  RELATIVE_SAMEDIR = '.'\n\n  # @group Manipulating Paths\n\n  # Turns a path +to+ into a relative path from starting\n  # point +from+. The argument +from+ is assumed to be\n  # a filename. To treat it as a directory, make sure it\n  # ends in +File::SEPARATOR+ ('/' on UNIX filesystems).\n  #\n  # @param [String] from the starting filename\n  #   (or directory with +from_isdir+ set to +true+).\n  # @param [String] to the final path that should be made relative.\n  # @return [String] the relative path from +from+ to +to+.\n  def self.relative_path(from, to)\n    from = expand_path(from).split(SEPARATOR)\n    to = expand_path(to).split(SEPARATOR)\n    from.length.times do\n      break if from[0] != to[0]\n      from.shift; to.shift\n    end\n    from.pop\n    join(*(from.map { RELATIVE_PARENTDIR } + to))\n  end\n\n  # Cleans a path by removing extraneous '..', '.' and '/' characters\n  #\n  # @example Clean a path\n  #   File.cleanpath('a/b//./c/../e') # => \"a/b/e\"\n  # @param [String] path the path to clean\n  # @return [String] the sanitized path\n  def self.cleanpath(path)\n    path = path.split(SEPARATOR)\n    path = path.inject([]) do |acc, comp|\n      next acc if comp == RELATIVE_SAMEDIR\n      if comp == RELATIVE_PARENTDIR && !acc.empty? && acc.last != RELATIVE_PARENTDIR\n        acc.pop\n        next acc\n      elsif comp == RELATIVE_PARENTDIR && acc.empty?\n        next acc\n      end\n      acc << comp\n    end\n    File.join(*path)\n  end\n\n  # @group Reading Files\n\n  # Forces opening a file (for writing) by first creating the file's directory\n  # @param [String] file the filename to open\n  # @since 0.5.2\n  def self.open!(file, *args, &block)\n    dir = dirname(file)\n    FileUtils.mkdir_p(dir) unless directory?(dir)\n    open(file, *args, &block)\n  end\n\n  # Reads a file with binary encoding\n  # @return [String] the ascii-8bit encoded data\n  # @since 0.5.3\n  def self.read_binary(file)\n    File.open(file, 'rb', &:read)\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe File do\n  describe \".relative_path\" do\n    it \"returns the relative path between two files\" do\n      expect(File.relative_path('a/b/c/d.html', 'a/b/d/q.html')).to eq '../d/q.html'\n    end\n\n    it \"returns the relative path between two directories\" do\n      expect(File.relative_path('a/b/c/d/', 'a/b/d/')).to eq '../d'\n    end\n\n    it \"returns only the to file if from file is in the same directory as the to file\" do\n      expect(File.relative_path('a/b/c/d', 'a/b/c/e')).to eq 'e'\n    end\n\n    it \"handles non-normalized paths\" do\n      expect(File.relative_path('Hello/./I/Am/Fred', 'Hello/Fred')).to eq '../../Fred'\n      expect(File.relative_path('A//B/C', 'Q/X')).to eq '../../Q/X'\n    end\n  end\n\n  describe \".cleanpath\" do\n    it \"cleans double brackets\" do\n      expect(File.cleanpath('A//B/C')).to eq \"A/B/C\"\n    end\n\n    it \"cleans a path with .\" do\n      expect(File.cleanpath('Hello/./I/.Am/Fred')).to eq \"Hello/I/.Am/Fred\"\n    end\n\n    it \"cleans a path with ..\" do\n      expect(File.cleanpath('Hello/../World')).to eq \"World\"\n    end\n\n    it \"cleans a path with multiple ..\" do\n      expect(File.cleanpath('A/B/C/../../D')).to eq \"A/D\"\n    end\n\n    it \"cleans a path ending in ..\" do\n      expect(File.cleanpath('A/B/C/D/..')).to eq \"A/B/C\"\n    end\n\n    it \"does not allow relative path above root\" do\n      expect(File.cleanpath('A/../../../../../D')).to eq \"D\"\n    end\n\n    it \"does not remove multiple '../' at the beginning\" do\n      expect(File.cleanpath('../../A/B')).to eq 'A/B'\n    end\n  end\n\n  describe \".open!\" do\n    it \"creates the path before opening\" do\n      expect(File).to receive(:directory?).with('/path/to').and_return(false)\n      expect(FileUtils).to receive(:mkdir_p).with('/path/to')\n      expect(File).to receive(:open).with('/path/to/file', 'w')\n      File.open!('/path/to/file', 'w')\n    end\n\n    it \"just opens the file if the path exists\" do\n      expect(File).to receive(:directory?).with('/path/to').and_return(true)\n      expect(FileUtils).not_to receive(:mkdir_p)\n      expect(File).to receive(:open).with('/path/to/file', 'w')\n      File.open!('/path/to/file', 'w')\n    end\n  end\nend\n"], "filenames": ["lib/yard/core_ext/file.rb", "spec/core_ext/file_spec.rb"], "buggy_code_start_loc": [42, 44], "buggy_code_end_loc": [42, 50], "fixing_code_start_loc": [43, 44], "fixing_code_end_loc": [45, 50], "type": "CWE-22", "message": "lib/yard/core_ext/file.rb in the server in YARD before 0.9.11 does not block relative paths with an initial ../ sequence, which allows attackers to conduct directory traversal attacks and read arbitrary files.", "other": {"cve": {"id": "CVE-2017-17042", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-28T20:29:00.337", "lastModified": "2017-12-20T20:58:34.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/yard/core_ext/file.rb in the server in YARD before 0.9.11 does not block relative paths with an initial ../ sequence, which allows attackers to conduct directory traversal attacks and read arbitrary files."}, {"lang": "es", "value": "lib/yard/core_ext/file.rb en el servidor en YARD en versiones anteriores a la 0.9.11 no bloquea las rutas relativas con una secuencia ../ inicial. Esto permite que atacantes lleven a cabo ataques de salto de directorio y lean archivos arbitrarios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yardoc:yard:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.11", "matchCriteriaId": "FEC09169-9EA2-4AA0-A45D-D989DEBACD04"}]}]}], "references": [{"url": "https://github.com/lsegal/yard/commit/b0217b3e30dc53d057b1682506333335975e62b4", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/lsegal/yard/commit/b0217b3e30dc53d057b1682506333335975e62b4"}}