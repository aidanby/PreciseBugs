{"buggy_code": ["= Mechanize CHANGELOG\n\n=== Unreleased\n\n* New Features\n  * Support for Ruby 3.0 by adding `webrick` as a runtime dependency. (#557) @pvalena\n\n* Bug fix\n  * Ignore input fields with blank names (#542, #536)\n\n=== 2.7.6\n\n* New Features\n  * Mechanize#set_proxy accepts an HTTP URL/URI. (#513)\n\n* Bug fix\n  * Fix element(s)_with(search: selector) methods not working for forms, form fields and frames. (#444)\n  * Improve the filename parser for the `Content-Disposition` header. (#496, #517)\n  * Accept `Content-Encoding: identity`. (#515)\n  * Mechanize::Page#title no longer picks a title in an embeded SVG/RDF element. (#503)\n  * Make Mechanize::Form#has_field? boolean. (#501)\n\n=== 2.7.5\n\n* New Features\n  * All 4xx responses and RedirectLimitReachedError when fetching robots.txt are treated as full allow just like Googlebot does.\n  * Enable support for mime-types > 3.\n\n* Bug fix\n  * Don't cause infinite loop when `GET /robots.txt` redirects. (#457)\n  * Fix basic authentication for a realm that contains uppercase characters. (#458, #459)\n  * Fix encoding error when uploading a file which name is non-ASCII. (#333)\n\n=== 2.7.4\n\n* New Features\n  * Accept array-like and hash-like values as query/parameter value.\n    A new utility method Mechanize::Util.each_parameter is added, and Mechanize::Util.build_query_string is enhanced\n    for this feature.\n  * Allow passing a `Form::FileUpload` instance to `#post`. #350 by Sam\n    Rawlins.\n  * Capture link when scheme is unsupported. #362 by Jon Rowe.\n  * Pre-defined User-Agent stings are updated to those of more recent versions, and new aliases for IE 10/11 and Edge are added.\n  * Support for mime-types 1.x is restored while keeping compatible with mime-types 2.x.\n  * Mechanize::Page now responds to #xpath, #css, #at_xpath, #at_css, and #%.\n  * element(s)_with methods now accept :xpath and :css options for doing xpath/css\n    selector searching.\n  * Pass URI information to Nokogiri where applicable. #405 @lulalala\n\n* Bug fix\n  * Don't raise an exception if a connection has set a {read,open}_timeout and\n    a `file://` request is made. (#397)\n  * Fix whitespace bug in WWW-Authenticate. #451, #450, by Rasmus Bergholdt\n  * Don't allow redirect from a non-file URL to a file URL for security reasons. (#455)\n\n=== 2.7.3\n\n* New Features\n  * Allow net-http-persistent instance to be named. #324, John Weir.\n  * #save and #save! return filename #340\n  * Updated mime-types requirement to 2.x versions.  #348 by Jeff Nyman.\n\n* Bug fix\n  * Ensure Download#save! defaults back to original filename if\n    none is provided (#300)\n\n=== 2.7.2\n\n* Bug fix\n  * API compatibility issues with Mechanize::CookieJar cookies has been\n    addressed.  https://github.com/sparklemotion/http-cookie/issues/2 #326\n\n=== 2.7.1\n\n* Bug fix\n  * Ensure images with no \"src\" attribute still return correct URLs. #317\n  * Fixes Mechanize::Parser#extract_filename where an empty string filename\n    in the response caused unhandled exception. #318\n\n=== 2.7.0\n\n* New Features\n  * Mechanize::Agent#response_read will now raise a\n    Mechanize::ResponseReadError instead of an EOFError and avoid losing\n    requested content. #296.\n  * Depend on http-cookie, add backwards compatible deprecations.\n    #257 Akinori MUSHA.\n  * Added `Download#save!` for overwriting existing files. #300 Sean Kim.\n\n* Bug fix\n  * Ensure page URLs with whitespace in them are escaped #313 @pacop.\n  * Added a workaround for a bug of URI#+ that led to failure in resolving a relative path containing double slash like \"/../http://.../\". #304\n\n=== 2.6.0\n\n* New Features\n  * Mechanize#start and Mechanize#shutdown (Thanks, Damian Janowski!)\n  * Added Mechanize::Agent#allowed_error_codes for setting an Array\n    of status codes which should not raise an error. #248 Laurence Rowe.\n  * Added `File.save!` for overwriting existing files #219.\n  * DirectorySaver::save_to now accepts an option to decode filename. #262\n  * element(s)_with methods now accept a :search option for doing xpath/css\n    selector searching. #287 Philippe Bourgau\n  * Added httponly option for Mechanize::Cookie #242 by Paolo Perego.\n  * Added Mechanize::XmlFile as a default pluggable parser for handling\n    XML responses. #289\n\n* Minor enhancements\n  * Added Mechanize::Download#save_as as an alias to #save. #246\n  * Fix documentation for `Mechanize::Page` element matchers. #269\n  * Added Mechanize::Form::Field#raw_value for fetching a fields value\n    before it's sent through Mechanize::Util.html_unescape. #283\n  * Added iPad and Android user agents.  #277 by sambit, #278 by seansay.\n\n* Bug fix\n  * Mechanize#cert and Mechanize#key now return the values set by\n    #cert= and #key=. #244, #245 (Thanks, Robert Gogolok!)\n  * Mechanize no longer submits disabled form fields.  #276 by Bogdan Gusiev,\n    #279 by Ricardo Valeriano.\n  * Mechanize::File#save now behaves like Mechanize::Download#save in\n    that it will create the parent directory before saving.\n    #272, #280 by Ryan Kowalick\n  * Ensure `application/xml` is registered as an XML parser in\n    `PluggableParser`, not just `text/xml`. #266 James Gregory\n  * Mechanize now writes cookiestxt with a prefixed dot for wildcard domain\n    handling. #295 by Mike Morearty.\n\n=== 2.5.2\n\n* New Features\n  * Mechanize::CookieJar#save_as takes a keyword option \"session\" to say\n    that session cookies should be saved.  Based on #230 by Jim Jones.\n\n* Minor enhancements\n  * Added Mechanize#follow_redirect= as an alias to redirect_ok=.\n\n* Bug fix\n  * Fixed casing of the Mac Firefox user-agent alias to match Linux Firefox.\n    In mechanize 3 the old \"Mac FireFox\" user-agent alias will be removed.\n    Pull request #231 by Gavin Miller.\n  * Mechanize now authenticates using the raw challenge, not a reconstructed\n    one, to avoid dealing with quoting rules of RFC 2617.  Fixes failures in\n    #231 due to net-http-digest_auth 1.2.1\n  * Fixed Content-Disposition parameter parser to be case insensitive. #233\n  * Fixed redirection counting in following meta refresh. #240\n\n=== 2.5.1\n\n* Bug fix\n  * Mechanize no longer copies POST requests during a redirect which was\n    introduced by #215.  Pull request #229 by Godfrey Chan.\n\n=== 2.5\n\n* Minor enhancements\n  * Added Mechanize#ignore_bad_chunking for working around servers that don't\n    terminate chunked transfer-encoding properly.  Enabling this may cause\n    data loss.  Issue #116\n  * Removed content-type check from Mechanize::Page allowing forced parsing\n    of incorrect or missing content-types.  Issue #221 by GarthSnyder\n* Bug fixes\n  * Fixed typos in EXAMPLES and GUIDES.  Pull Request #213 by Erkan Yilmaz.\n  * Fixed handling of a quoted content-disposition size.  Pull Request #220 by\n    Jason Rust\n  * Mechanize now ignores a missing gzip footer like browsers do.  Issue #224\n    by afhbl\n  * Mechanize handles saving of files with the same name better now.  Pull\n    Request #223 by Godfrey Chan, Issue #219 by Jon Hart\n  * Mechanize now sends headers across redirects.  Issue #215 by Chris Gahan\n  * Mechanize now raises Mechanize::ResponseReadError when the server does not\n    terminate chunked transfer-encoding properly.  Issue #116\n  * Mechanize no longer raises an exception when multiple identical\n    radiobuttons are checked.  Issue #214 by Matthias Guenther\n  * Fixed documentation for pre_connect_hooks and post_connect_hooks.  Issue\n    #226 by Robert Poor\n  * Worked around ruby 1.8 run with -Ku and ISO-8859-1 encoded characters in\n    URIs.  Issue #228 by Stanislav O.Pogrebnyak\n\n=== 2.4\n\n* Security fix:\n\n  Mechanize#auth and Mechanize#basic_auth allowed disclosure of passwords to\n  malicious servers and have been deprecated.\n\n  In prior versions of mechanize only one set of HTTP authentication\n  credentials were allowed for all connections.  If a mechanize instance\n  connected to more than one server then a malicious server detecting\n  mechanize could ask for HTTP Basic authentication.  This would expose the\n  username and password intended only for one server.\n\n  Mechanize#auth and Mechanize#basic_auth now warn when used.\n\n  To fix the warning switch to Mechanize#add_auth which requires the URI\n  the credentials are intended for, the username and the password.\n  Optionally an HTTP authentication realm or NTLM domain may be provided.\n\n* Minor enhancement\n  * Improved exception messages for 401 Unauthorized responses.  Mechanize now\n    tells you if you were missing credentials, had an incorrect password, etc.\n\n=== 2.3 / 2012-02-20\n\n* Minor enhancements\n  * Add support for the Max-Age attribute in the Set-Cookie header.\n  * Added Mechanize::Download#body for compatibility with Mechanize::File when\n    using Mechanize#get_file with Mechanize::Image or other Download-based\n    pluggable parser.  Issue #202 by angas\n  * Mechanize#max_file_buffer may be set to nil to disable creation of\n    Tempfiles.\n\n* Bug fixes\n  * Applied Mechanize#max_file_buffer to the Content-Encoding handlers as well\n    to prevent extra Tempfiles for small gzip or deflate response\n  * Increased the default Mechanize#max_file_buffer to 100,000 bytes.  This\n    gives ~5MB of response bodies in memory with the default history setting\n    of 50 pages (depending on GC behavior).\n  * Ignore empty path/domain attributes.\n  * Cookies with an empty Expires attribute value were stored as session\n    cookies but cookies without the Expires attribute were not.  Issue #78\n\n=== 2.2.1 / 2012-02-13\n\n* Bug fixes\n  * Add missing file to the gem, ensure that missing files won't cause\n    failures again.  Issue #201 by Alex\n  * Fix minor grammar issue in README.  Issue #200 by Shane Becker.\n\n=== 2.2 / 2012-02-12\n\n* API changes\n  * MetaRefresh#href is not normalized to an absolute URL, but set to the\n    original value and resolved later.  It is even set to nil when the\n    Refresh URL is unspecified or empty.\n\n* Minor enhancements\n  * Expose ssl_version from net-http-persistent.  Patch by astera.\n  * SSL parameters and proxy may now be set at any time.  Issue #194 by\n    dsisnero.\n  * Improved Mechanize::Page with #image_with and #images_with and\n    Mechanize::Page::Image various img element attribute accessors, #caption,\n    #extname, #mime_type and #fetch.  Pull request #173 by kitamomonga\n  * Added MIME type parsing for content-types in Mechanize::PluggableParser\n    for fine-grained parser choices.  Parsers will be chosen based on exact\n    match, simplified type or media type in that order.  See\n    Mechanize::PluggableParser#[]=.\n  * Added Mechanize#download which downloads a response body to an IO-like or\n    filename.\n  * Added Mechanize::DirectorySaver which saves responses in a single\n    directory.  Issue #187 by yoshie902a.\n  * Added Mechanize::Page::Link#noreferrer?\n  * The documentation for Mechanize::Page#search and #at now show that both\n    XPath and CSS expressions are allowed.  Issue #199 by Shane Becker.\n\n* Bug fixes\n  * Fixed handling of a HEAD request with Accept-Encoding: gzip.  Issue #198\n    by Oleg Dashevskii\n  * Use #resolve for resolving a Location header value.  fixes #197\n  * A Refresh value can have whitespaces around the semicolon and equal sign.\n  * MetaRefresh#click no longer sends out Referer.\n  * A link with an empty href is now resolved correctly where previously the\n    query part was dropped.\n\n=== 2.1.1 / 2012-02-03\n\n* Bug fixes\n  * Set missing idle_timeout default.  Issue #196\n  * Meta refresh URIs are now escaped (excluding %).  Issue #177\n  * Fix charset name extraction.  Issue #180\n  * A Referer URI sent on request no longer includes user information\n    or fragment part.\n  * Tempfiles for storing response bodies are unlinked upon creation to avoid\n    possible lack of finalization.  Issue #183\n  * The default maximum history size is now 50 pages to avoid filling up a\n    disk with tempfiles accidentally.  Related to Issue #183\n  * Errors in bodies with deflate and gzip responses now result in a\n    Mechanize::Error instead of silently being ignored and causing future\n    errors.  Issue #185\n  * Mechanize now raises an UnauthorizedError instead of crashing when a 403\n    response does not contain a www-authenticate header.  Issue #181\n  * Mechanize gives a useful exception when attempting to click buttons across\n    pages.  Issue #186\n  * Added note to Mechanize#cert_store describing how to add certificates in\n    case your system does not come with a default set.  Issue #179\n  * Invalid content-disposition headers are now ignored.  Issue #191\n  * Fix NTLM by recognizing the \"Negotiation\" challenge instead of endlessly\n    looping.  Issue #192\n  * Allow specification of the NTLM domain through Mechanize#auth.  Issue #193\n  * Documented how to convert a Mechanize::ResponseReadError into a File or\n    Page, along with a new method #force_parse.  Issue #176\n\n=== 2.1 / 2011-12-20\n\n* Deprecations\n  * Mechanize#get no longer accepts an options hash.\n  * Mechanize::Util::to_native_charset has been removed.\n\n* Minor enhancements\n  * Mechanize now depends on net-http-persistent 2.3+.  This new version\n    brings idle timeouts to help with the dreaded \"too many connection resets\"\n    issue when POSTing to a closed connection.  Issue #123\n  * SSL connections will be verified against the system certificate store by\n    default.\n  * Added Mechanize#retry_change_requests to allow mechanize to retry POST and\n    other non-idempotent requests when you know it is safe to do so.  Issue\n    #123\n  * Mechanize can now stream files directly to disk without loading them into\n    memory first through Mechanize::Download, a pluggable parser for\n    downloading files.\n\n    All responses larger than Mechanize#max_file_buffer are downloaded to a\n    Tempfile.  For backwards compatibility Mechanize::File subclasses still\n    load the response body into memory.\n\n    To force all unknown content types to download to disk instead of memory\n    set:\n\n      agent.pluggable_parser.default = Mechanize::Download\n  * Added Mechanize#content_encoding_hooks which allow handling of\n    non-standard content encodings like \"agzip\".  Patch #125 by kitamomonga\n  * Added dom_class to elements and the element matcher like dom_id.  Patch\n    #156 by Dan Hansen.\n  * Added support for the HTML5 keygen form element.  See\n    http://dev.w3.org/html5/spec/Overview.html#the-keygen-element  Patch #157\n    by Victor Costan.\n  * Mechanize no longer follows meta refreshes that have no \"url=\" in the\n    content attribute to avoid infinite loops.  To follow a meta refresh to\n    the same page set Mechanize#follow_meta_refresh_self to true.  Issue #134\n    by Jo Hund.\n  * Updated 'Mac Safari' User-Agent alias to Safari 5.1.1.  'Mac Safari 4' can\n    be used for the old 'Mac Safari' alias.\n  * When given multiple HTTP authentication options mechanize now picks the\n    strongest method.\n  * Improvements to HTTP authorization:\n    * mechanize raises Mechanize::UnathorizedError for 401 responses which is\n      a sublcass of Mechanize::ResponseCodeError.\n    * Added support for NTLM authentication, but this has not been tested.\n  * Mechanize::Cookie.new accepts attributes in a hash.\n  * Mechanize::CookieJar#<<(cookie) (alias: add!) is added.  Issue #139\n  * Different mechanize instances may now have different loggers.  Issue #122\n  * Mechanize now accepts a proxy port as a service name or number string.\n    Issue #167\n\n* Bug fixes\n  * Mechanize now handles cookies just as most modern browsers do,\n    roughly based on RFC 6265.\n    * domain=.example.com (which is invalid) is considered identical to\n      domain=example.com.\n    * A cookie with domain=example.com is sent to host.sub.example.com\n      as well as host.example.com and example.com.\n    * A cookie with domain=TLD (no dots) is accepted and sent if the\n      host name is TLD, and rejected otherwise.  To retain compatibility\n      and convention, host/domain names starting with \"local\" are exempt\n      from this rule.\n    * A cookie with no domain attribute is only sent to the original\n      host.\n    * A cookie with an Effective TLD is rejected based on the public\n      suffix list. (cf. http://publicsuffix.org/)\n    * \"Secure\" cookies are not sent via non-https connection.\n    * Subdomain match is not performed against an IP address.\n    * It is recommended that you clear out existing cookie jars for\n      regeneration because previously saved cookies may not have been\n      parsed correctly.\n  * Mechanize takes more care to avoid saving files with certain unsafe names.\n    You should still take care not to use mechanize to save files directly\n    into your home directory ($HOME).  Issue #163.\n  * Mechanize#cookie_jar= works again.  Issue #126\n  * The original Referer value persists on redirection.  Issue #150\n  * Do not send a referer on a Refresh header based redirection.\n  * Fixed encoding error in tests when LANG=C.  Patch #142 by jinschoi.\n  * The order of items in a form submission now match the DOM order.  Patch\n    #129 by kitamomonga\n  * Fixed proxy example in EXAMPLE.  Issue #146 by NielsKSchjoedt\n\n=== 2.0.1 / 2011-06-28\n\nMechanize now uses minitest to avoid 1.9 vs 1.8 assertion availability in\ntest/unit\n\n* Bug Fixes\n  * Restored Mechanize#set_proxy.  Issue #117, #118, #119\n  * Mechanize::CookieJar#load now lazy-loads YAML.  Issue #118\n  * Mechanize#keep_alive_time no longer crashes but does nothing as\n    net-http-persistent does not support HTTP/1.0 keep-alive extensions.\n\n=== 2.0 / 2011-06-27\n\nMechanize is now under the MIT license\n\n* API changes\n  * WWW::Mechanize has been removed.  Use Mechanize.\n  * Pre connect hooks are now called with the agent and the request.  See\n    Mechanize#pre_connect_hooks.\n  * Post connect hooks are now called with the agent and the response.  See\n    Mechanize#post_connect_hooks.\n  * Mechanize::Chain is gone, as an internal API this should cause no problems.\n  * Mechanize#fetch_page no longer accepts an options Hash.\n  * Mechanize#put now accepts headers instead of an options Hash as the last\n    argument\n  * Mechanize#delete now accepts headers instead of an options Hash as the\n    last argument\n  * Mechanize#request_with_entity now accepts headers instead of an options\n    Hash as the last argument\n  * Mechanize no longer raises RuntimeError directly, Mechanize::Error or\n    ArgumentError are raised instead.\n  * The User-Agent header has changed.  It no longer includes the WWW- prefix\n    and now includes the ruby version.  The URL has been updated as well.\n  * Mechanize now requires ruby 1.8.7 or newer.\n  * Hpricot support has been removed as webrobots requires nokogiri.\n  * Mechanize#get no longer accepts the referer as the second argument.\n  * Mechanize#get no longer allows the HTTP method to be changed (:verb\n    option).\n  * Mechanize::Page::Meta is now Mechanize::Page::MetaRefresh to accurately\n    depict its responsibilities.\n  * Mechanize::Page#meta is now Mechanize::Page#meta_refresh as it only\n    contains meta elements with http-equiv of \"refresh\"\n  * Mechanize::Page#charset is now Mechanize::Page::charset.  GH #112, patch\n    by Godfrey Chan.\n\n* Deprecations\n  * Mechanize#get with an options hash is deprecated and will be removed after\n    October, 2011.\n  * Mechanize::Util::to_native_charset is deprecated as it is no longer used\n    by Mechanize.\n\n* New Features\n\n  * Add header reference methods to Mechanize::File so that a reponse\n    object gets compatible with Net::HTTPResponse.\n  * Mechanize#click accepts a regexp or string to click a button/link in the\n    current page. It works as expected when not passed a string or regexp.\n  * Provide a way to only follow permanent redirects (301)\n    automatically: <tt>agent.redirect_ok = :permanent</tt>  GH #73\n  * Mechanize now supports HTML5 meta charset.  GH #113\n  * Documented various Mechanize accessors.  GH #66\n  * Mechanize now uses net-http-digest_auth.  GH #31\n  * Mechanize now implements session cookies.  GH #78\n  * Mechanize now implements deflate decoding.  GH #40\n  * Mechanize now allows a certificate and key to be passed directly.  GH #71\n  * Mechanize::Form::MultiSelectList now implements #option_with and\n    #options_with.  GH #42\n  * Add Mechanize::Page::Link#rel and #rel?(kind) to read and test the rel\n    attribute.\n  * Add Mechanize::Page#canonical_uri to read a </tt><link\n    rel=\"canonical\"></tt> tag.\n  * Add support for Robots Exclusion Protocol (i.e. robots.txt) and\n    nofollow/noindex in meta tags and the rel attribute.  Automatic\n    exclusion can be turned on by setting:\n      agent.robots = true\n  * Manual robots.txt test can be performed with\n    Mechanize#robots_allowed? and #robots_disallowed?.\n  * Mechanize::Form now supports the accept-charset attribute.  GH #96\n  * Mechanize::ResponseReadError is raised if there is an exception while\n    reading the response body.  This allows recovery from broken HTTP servers\n    (or connections).  GH #90\n  * Mechanize#follow_meta_refresh set to :anywhere will follow meta refresh\n    found outside of a document's head.  GH #99\n  * Add support for HTML5's rel=\"noreferrer\" attribute which indicates\n    no \"Referer\" information should be sent when following the link.\n  * A frame will now load its content when #content is called.  GH #111\n  * Added Mechanize#default_encoding to provide a default for pages with no\n    encoding specified.  GH #104\n  * Added Mechanize#force_default_encoding which only uses\n    Mechanize#default_encoding for parsing HTML.  GH #104\n\n* Bug Fixes:\n\n  * Fixed a bug where Referer is not sent when accessing a relative\n    URI starting with \"http\".\n  * Fix handling of Meta Refresh with relative paths.  GH #39\n  * Mechanize::CookieJar now supports RFC 2109 correctly.  GH #85\n  * Fixed typo in EXAMPLES.rdoc.  GH #74\n  * The base element is now handled correctly for images.  GH #72\n  * Image buttons with no name attribute are now included in the form's button\n    list.  GH#56\n  * Improved handling of non ASCII-7bit compatible characters in links (only\n    an issue on ruby 1.8).  GH #36, GH #75\n  * Loading cookies.txt is faster.  GH #38\n  * Mechanize no longer sends cookies for a.b.example to axb.example.  GH #41\n  * Mechanize no longer sends the button name as a form field for image\n    buttons.  GH #45\n  * Blank cookie values are now skipped.  GH #80\n  * Mechanize now adds a '.' to cookie domains if no '.' was sent.  This is\n    not allowed by RFC 2109 but does appear in RFC 2965.  GH #86\n  * file URIs are now read in binary mode.  GH #83\n  * Content-Encoding: x-gzip is now treated like gzip per RFC 2616.\n  * Mechanize now unescapes URIs for meta refresh.  GH #68\n  * Mechanize now has more robust HTML charset detection.  GH #43\n  * Mechanize::Form::Textarea is now created from a textarea element.  GH #94\n  * A meta content-type now overrides the HTTP content type.  GH #114\n  * Mechanize::Page::Link#uri now handles both escaped and unescaped hrefs.\n    GH #107\n\n=== 1.0.0\n\n* New Features:\n\n  * An optional verb may be passed to Mechanize#get GH #26\n  * The WWW constant is deprecated. Switch to the top level constant Mechanize\n  * SelectList#option_with and options_with for finding options\n\n* Bug Fixes:\n\n  * Rescue errors from bogus encodings\n  * 7bit content-encoding support.  Thanks sporkmonger! GH #2\n  * Fixed a bug with iconv conversion. Thanks awesomeman! GH #9\n  * meta redirects outside the head are not followed. GH #13\n  * Form submissions work with nil page encodings. GH #25\n  * Fixing default values with serialized cookies. GH #3\n  * Checkboxes and fields are sorted by page appearance before submitting. #11\n\n=== 0.9.3\n\n* Bug Fixes:\n\n  * Do not apply encoding if encoding equals 'none' Thanks Akinori MUSHA!\n  * Fixed Page#encoding= when changing the value from or to nil.  Made\n    it return the assigned value while at it. (Akinori MUSHA)\n  * Custom request headers may be supplied WWW::Mechanize#request_headers\n    RF #24516\n  * HTML Parser may be set on a per instance level WWW::Mechanize#html_parser\n    RF #24693\n  * Fixed string encoding in ruby 1.9.  RF #2433\n  * Rescuing Zlib::DataErrors (Thanks Kelley Reynolds)\n  * Fixing a problem with frozen SSL objects.  RF #24950\n  * Do not send a referer on meta refresh. RF #24945\n  * Fixed a bug with double semi-colons in Content-Disposition headers\n  * Properly handling cookies that specify a path.  RF #25259\n\n=== 0.9.2 / 2009/03/05\n\n* New Features:\n  * Mechanize#submit and Form#submit take arbitrary headers(thanks penguincoder)\n\n* Bug Fixes:\n  * Fixed a bug with bad cookie parsing\n  * Form::RadioButton#click unchecks other buttons (RF #24159)\n  * Fixed problems with Iconv (RF #24190, RF #24192, RF #24043)\n  * POST parameters should be CGI escaped\n  * Made Content-Type match case insensitive (Thanks Kelly Reynolds)\n  * Non-string form parameters work\n\n=== 0.9.1 2009/02/23\n\n* New Features:\n  * Encoding may be specified for a page: Page#encoding=\n\n* Bug Fixes:\n  * m17n fixes. \u3042\u308a\u304c\u3068\u3046 konn!\n  * Fixed a problem with base tags.  \u3042\u308a\u304c\u3068\u3046 Keisuke\n  * HEAD requests do not record in the history\n  * Default encoding to ISO-8859-1 instead of ASCII\n  * Requests with URI instances should not be polluted RF #23472\n  * Nonce count fixed for digest auth requests.  Thanks Adrian Slapa!\n  * Fixed a referer issue with requests using a uri.  RF #23472\n  * WAP content types will now be parsed\n  * Rescued poorly formatted cookies.  Thanks Kelley Reynolds!\n\n=== 0.9.0\n\n* Deprecations\n  * WWW::Mechanize::List is gone!\n  * Mechanize uses Nokogiri as it's HTML parser but you may switch to\n    Hpricot by using WWW::Mechanize.html_parser = Hpricot\n\n* Bug Fixes:\n  * Nil check on page when base tag is used #23021\n\n=== 0.8.5\n\n* Deprecations\n  * WWW::Mechanize::List will be deprecated in 0.9.0, and warnings have\n    been added to help you upgrade.\n\n* Bug Fixes:\n  * Stopped raising EOF exceptions on HEAD requests. \u3042\u308a\u304c\u3068\u3046\uff1aHIRAKU Kuroda\n  * Fixed exceptions when a logger is set and file:// requests are made.\n  * Made Mechanize 1.9 compatible\n  * Not setting the port in the host header for SSL sites.\n  * Following refresh headers.  Thanks Tim Connor!\n  * Cookie Jar handles cookie domains containing ports, like\n    'mydomain.com:443' (Thanks Michal Ochman!)\n  * Fixing strange uri escaping problems [#22604]\n  * Making content-type determintation more robust.  (thanks Han Holl!)\n  * Dealing with links that are query string only.  [#22402]\n  * Nokogiri may be dropped in as a replacement.\n      WWW::Mechanize.html_parser = Nokogiri::HTML\n  * Making sure the correct page is added to the history on meta refresh.\n    [#22708]\n  * Mechanize#get requests no longer send a referer unless they are relative\n    requests.\n\n=== 0.8.4\n\n* Bug Fixes:\n  * Setting the port number on the host header.\n  * Fixing Authorization headers for picky servers\n\n=== 0.8.3\n\n* Bug Fixes:\n  * Making sure logger is set during SSL connections.\n\n=== 0.8.2\n\n* Bug Fixes:\n  * Doh!  I was accidentally setting headers twice.\n\n=== 0.8.1\n\n* Bug Fixes:\n  * Fixed problem with nil pointer when logger is set\n\n=== 0.8.0\n\n* New Features:\n  * Lifecycle hooks.  Mechanize#pre_connect_hooks, Mechanize#post_connect_hooks\n  * file:/// urls are now supported\n  * Added Mechanize::Page#link_with, frame_with for searching for links using\n    +criteria+.\n  * Implementing PUT, DELETE, and HEAD requests\n\n* Bug Fixes:\n  * Fixed an infinite loop when content-length and body length don't match.\n  * Only setting headers once\n  * Adding IIS authentication support\n\n=== 0.7.8\n\n* Bug Fixes:\n  * Fixed bug when receiving a 304 response (HTTPNotModified) on a page not\n    cached in history.\n  * #21428 Default to HTML parser for 'application/xhtml+xml' content-type.\n  * Fixed an issue where redirects were resending posted data\n\n=== 0.7.7\n\n* New Features:\n  * Page#form_with takes a +criteria+ hash.\n  * Page#form is changed to Page#form_with\n  * Mechanize#get takes custom http headers.  Thanks Mike Dalessio!\n  * Form#click_button submits a form defaulting to the current button.\n  * Form#set_fields now takes a hash.  Thanks Tobi!\n  * Mechanize#redirection_limit= for setting the max number of redirects.\n\n* Bug Fixes:\n  * Added more examples.  Thanks Robert Jackson.\n  * #20480 Making sure the Host header is set.\n  * #20672 Making sure cookies with weird semicolons work.\n  * Fixed bug with percent signs in urls.\n    http://d.hatena.ne.jp/kitamomonga/20080410/ruby_mechanize_percent_url_bug\n  * #21132 Not checking for EOF errors on redirect\n  * Fixed a weird gzipping error.\n  * #21233 Smarter multipart boundry. Thanks Todd Willey!\n  * #20097 Supporting meta tag cookies.\n\n=== 0.7.6\n\n* New Features:\n  * Added support for reading Mozilla cookie jars.  Thanks Chris Riddoch!\n  * Moving text, password, hidden, int to default.  Thanks Tim Harper!\n  * Mechanize#history_added callback for page loads. Thanks Tobi Reif!\n  * Mechanize#scheme_handlers callbacks for handling unsupported schemes on\n    links.\n\n* Bug Fixes:\n  * Ignoring scheme case\n    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=470642\n  * Not encoding tildes in uris. Thanks Bruno.  [#19380]\n  * Resetting request bodys when retrying form posts.  Thanks Bruno. [#19379]\n  * Throwing away keep alive connections on EPIPE and ECONNRESET.\n  * Duplicating request headers when retrying a 401. Thanks Hiroshi Ichikawa.\n  * Simulating an EOF error when a response length is bad.  Thanks Tobias Gruetzmacher.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19178&group_id=1453&atid=5711\n  * Defaulting option tags to the inner text.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19976&group_id=1453&atid=5709\n  * Supporting blank strings for option values.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19975&group_id=1453&atid=5709\n\n=== 0.7.5\n\n* Fixed a bug when fetching files and not pages.  Thanks Mat Schaffer!\n\n=== 0.7.4\n\n* doh!\n\n=== 0.7.3\n\n* Pages are now yielded to a blocks given to WWW::Mechanize#get\n* WWW::Mechanize#get now takes hash arguments for uri parameters.\n* WWW::Mechanize#post takes an IO object as a parameter and posts correctly.\n* Fixing a strange zlib inflate problem on windows\n\n=== 0.7.2\n\n* Handling gzipped responses with no Content-Length header\n\n=== 0.7.1\n\n* Added iPhone to the user agent aliases. [#17572]\n* Fixed a bug with EOF errors in net/http.  [#17570]\n* Handling 0 length gzipped responses. [#17471]\n\n=== 0.7.0\n\n* Removed Ruby 1.8.2 support\n* Changed parser to lazily parse links\n* Lazily parsing document\n* Adding verify_callback for SSL requests.  Thanks Mike Dalessio!\n* Fixed a bug with Accept-Language header.  Thanks Bill Siggelkow.\n\n=== 0.6.11\n\n* Detecting single quotes in meta redirects.\n* Adding pretty inspect for ruby versions > 1.8.4 (Thanks Joel Kociolek)\n  http://rubyforge.org/tracker/index.php?func=detail&aid=13150&group_id=1453&atid=5709\n* Fixed bug with file name in multipart posts\n  http://rubyforge.org/tracker/?func=detail&aid=15594&group_id=1453&atid=5709\n* Posting forms relative to the originating page. Thanks Mortee.\n* Added a FAQ\n  http://rubyforge.org/tracker/?func=detail&aid=15772&group_id=1453&atid=5709\n\n=== 0.6.10\n\n* Made digest authentication work with POSTs.\n* Made sure page was HTML before following meta refreshes.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12260&group_id=1453&atid=5709\n* Made sure that URLS with a host and no path would default to '/' for history\n  purposes.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12368&group_id=1453&atid=5709\n* Avoiding memory leaks with transact.  Thanks Tobias Gruetzmacher!\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12057&group_id=1453&atid=5711\n* Fixing a problem with # signs in the file name.  Thanks Tobias Gruetzmacher!\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12510&group_id=1453&atid=5711\n* Made sure that blank form values are submitted.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12505&group_id=1453&atid=5709\n* Mechanize now respects the base tag.  Thanks Stephan Dale.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12468&group_id=1453&atid=5709\n* Aliasing inspect to pretty_inspect.  Thanks Eric Promislow.\n  http://rubyforge.org/pipermail/mechanize-users/2007-July/000157.html\n\n=== 0.6.9\n\n* Updating UTF-8 support for urls\n* Adding AREA tags to the links list.\n  http://rubyforge.org/pipermail/mechanize-users/2007-May/000140.html\n* WWW::Mechanize#follow_meta_refresh will allow you to automatically follow\n  meta refresh tags. [#10032]\n* Adding x-gzip to accepted content-encoding.  Thanks Simon Strandgaard\n  http://rubyforge.org/tracker/index.php?func=detail&aid=11167&group_id=1453&atid=5711\n* Added Digest Authentication support.  Thanks to Ryan Davis and Eric Hodel,\n  you get a gold star!\n\n=== 0.6.8\n\n* Keep alive can be shut off now with WWW::Mechanize#keep_alive\n* Conditional requests can be shut off with WWW::Mechanize#conditional_requests\n* Monkey patched Net::HTTP#keep_alive?\n* [#9877] Moved last request time.  Thanks Max Stepanov\n* Added WWW::Mechanize::File#save\n* Defaulting file name to URI or Content-Disposition\n* Updating compatability with hpricot\n* Added more unit tests\n\n=== 0.6.7\n\n* Fixed a bug with keep-alive requests\n* [#9549] fixed problem with cookie paths\n\n=== 0.6.6\n\n* Removing hpricot overrides\n* Fixed a bug where alt text can be nil.  Thanks Yannick!\n* Unparseable expiration dates in cookies are now treated as session cookies\n* Caching connections\n* Requests now default to keep alive\n* [#9434] Fixed bug where html entities weren't decoded\n* [#9150] Updated mechanize history to deal with redirects\n\n=== 0.6.5\n\n* Copying headers to a hash to prevent memory leaks\n* Speeding up page parsing\n* Aliased fields to elements\n* Adding If-Modified-Since header\n* Added delete_field! to form.  Thanks to Sava Chankov\n* Updated uri escaping to support high order characters.  Thanks to Henrik Nyh.\n* Better handling relative URIs.  Thanks to Henrik Nyh\n* Now handles pipes in URLs\n  http://rubyforge.org/tracker/?func=detail&aid=7140&group_id=1453&atid=5709\n* Now escaping html entities in form fields.\n  http://rubyforge.org/tracker/?func=detail&aid=7563&group_id=1453&atid=5709\n* Added MSIE 7.0 user agent string\n\n=== 0.6.4\n\n* Adding the \"redirect_ok\" method to Mechanize to stop mechanize from\n  following redirects.\n\thttp://rubyforge.org/tracker/index.php?func=detail&aid=6571&group_id=1453&atid=5712\n* Added protected method Mechanize#set_headers so that subclasses can set\n  custom headers.\n  http://rubyforge.org/tracker/?func=detail&aid=7208&group_id=1453&atid=5712\n* Aliased Page#referer to Page#page\n* Fixed a bug when clicking relative urls\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000035.html\n* Fixing a bug when bad version or max age is passed to Cookie::parse\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000033.html\n* Fixing a bug with response codes. [#6526]\n* Fixed bug [#6548].  Input type of 'button' was not being added as a button.\n* Fixed bug [#7139]. REXML parser calls hpricot parser by accident\n\n=== 0.6.3\n\n* Added keys and values methods to Form\n* Added has_value? to Form\n* Added a has_field? method to Form\n* The add_field! method on Form now creates a field for you on the form.\n  Thanks to Mat Schaffer for the patch.\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000025.html\n* Fixed a bug when form actions have html ecoded entities in them.\n  http://rubyforge.org/pipermail/mechanize-users/2006-October/000019.html\n* Fixed a bug when links or frame sources have html encoded entities in the\n  href or src.\n* Fixed a bug where '#' symbols are encoded\n  http://rubyforge.org/forum/message.php?msg_id=14747\n\n=== 0.6.2\n\n* Added a yield to Page#form so that dealing with forms can be more DSL like.\n* Added the parsed page to the ResponseCodeError so that the parsed results\n  can be accessed even in the event of an error.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000007.html\n* Updated documentation (Thanks to Paul Smith)\n\n=== 0.6.1\n\n* Added a method to Form called \"submit\".  Now forms can be submitted by\n  calling a method on the form.\n* Added a click method to links\n* Added an REXML pluggable parser for backwards compatability.  To use it,\n  just do this:\n   agent.pluggable_parser.html = WWW::Mechanize::REXMLPage\n* Fixed a bug with referrers by adding a page attribute to forms and links.\n* Fixed a bug where domain names were case sensitive.\n  http://tenderlovemaking.com/2006/09/04/road-to-ruby-mechanize-060/#comment-53\n* Fixed a bug with URI escaped links.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000002.html\n* Fixed a bug when options in select lists don't have a value. Thanks Dan Higham\n  [#5837] Code in lib/mechanize/form_elements.rb is incorrect.\n* Fixed a bug with loading text in to links.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000000.html\n\n=== 0.6.0\n\n* Changed main parser to use hpricot\n* Made WWW::Mechanize::Page class searchable like hpricot\n* Updated WWW::Mechanize#click to support hpricot links like this:\n  @agent.click (page/\"a\").first\n* Clicking a Frame is now possible:\n  @agent.click (page/\"frame\").first\n* Removed deprecated attr_finder\n* Removed REXML helper methods since the main parser is now hpricot\n* Overhauled cookie parser to use WEBrick::Cookie\n\n=== 0.5.4\n\n* Added WWW::Mechanize#trasact for saving history state between in a\n  transaction.  See the EXAMPLES file.  Thanks Johan Kiviniemi.\n* Added support for gzip compressed pages\n* Forms can now be accessed like a hash.  For example, to set the value\n  of an input field named 'name' to \"Aaron\", you can do this:\n   form['name'] = \"Aaron\"\n  Or to get the value of a field named 'name', do this:\n   puts form['name']\n* File uploads will now read the file specified in FileUpload#file_name\n* FileUpload can use an IO object in FileUpload#file_data\n* Fixed a bug with saving files on windows\n* Fixed a bug with the filename being set in forms\n\n=== 0.5.3\n\n* Mechanize#click will now act on the first element of an array.  So if an\n  array of links is passed to WWW::Mechanize#click, the first link is clicked.\n  That means the syntax for clicking links is shortened and still supports\n  selecting a link.  The following are equivalent:\n   agent.click page.links.first\n   agent.click page.links\n* Fixed a bug with spaces in href's and get's\n* Added a tick, untick, and click method to radio buttons so that\n  radiobuttons can be \"clicked\"\n* Added a tick, untick, and click method to check boxes so that\n  checkboxes can be \"clicked\"\n* Options on Select lists can now be \"tick\"ed, and \"untick\"ed.\n* Fixed a potential bug conflicting with rails.  Thanks Eric Kolve\n* Updated log4r support for a speed increase.  Thanks Yinon Bentor\n* Added inspect methods and pretty printing\n\n=== 0.5.2\n\n* Fixed a bug with input names that are nil\n* Added a warning when using attr_finder because attr_finder will be deprecated\n  in 0.6.0 in favor of method calls.  So this syntax:\n    @agent.links(:text => 'foo')\n  should be changed to this:\n    @agent.links.text('foo')\n* Added support for selecting multiple options in select tags that support\n  multiple options.  See WWW::Mechanize::MultiSelectList.\n* New select list methods have been added, select_all, select_none.\n* Options for select lists can now be \"clicked\" which toggles their selection,\n  they can be \"selected\" and \"unselected\".  See WWW::Mechanize::Option\n* Added a method to set multiple fields at the same time,\n  WWW::Mechanize::Form#set_fields.  Which can be used like so:\n   form.set_fields( :foo => 'bar', :name => 'Aaron' )\n\n=== 0.5.1\n\n* Fixed bug with file uploads\n* Added performance tweaks to the cookie class\n\n=== 0.5.0\n\n* Added pluggable parsers. (Thanks to Eric Kolve for the idea)\n* Changed namespace so all classes are under WWW::Mechanize.\n* Updating Forms so that fields can be used as accessors (Thanks Gregory Brown)\n* Added WWW::Mechanize::File as default object used for unknown content types.\n* Added 'save_as' method to Mechanize::File, so any page can be saved.\n* Adding 'save_as' and 'load' to CookieJar so that cookies can be saved\n  between sessions.\n* Added WWW::Mechanize::FileSaver pluggable parser to automatically save files.\n* Added WWW::Mechanize::Page#title for page titles\n* Added OpenSSL certificate support (Thanks Mike Dalessio)\n* Removed support for body filters in favor of pluggable parsers.\n* Fixed cookie bug adding a '/' when the url is missing one (Thanks Nick Dainty)\n\n=== 0.4.7\n\n* Fixed bug with no action in forms.  Thanks to Adam Wiggins\n* Setting a default user-agent string\n* Added house cleaning to the cookie jar so expired cookies don't stick around.\n* Added new method WWW::Form#field to find the first field with a given name.\n  (thanks to Gregory Brown)\n* Added WWW::Mechanize#get_file for fetching non text/html files\n\n=== 0.4.6\n\n* Added support for proxies\n* Added a uri field to WWW::Link\n* Added a error class WWW::Mechanize::ContentTypeError\n* Added image alt text to link text\n* Added an visited? method to WWW::Mechanize\n* Added Array#value= which will set the first value to the argument.  That\n  allows syntax as such:    form.fields.name('q').value = 'xyz'\n  Before it was like this:  form.fields.name('q').first.value = 'xyz'\n\n=== 0.4.5\n\n* Added support for multiple values of the same name\n* Updated build_query_string to take an array of arrays (Thanks Michal Janeczek)\n* Added WWW::Mechanize#body_filter= so that response bodies can be preprocessed\n* Added WWW::Page#body_filter= so that response bodies can be preprocessed\n* Added support for more date formats in the cookie parser\n* Fixed a bug with empty select lists\n* Fixing a problem with cookies not handling no spaces after semicolons\n\n=== 0.4.4\n\n* Fixed error in method signature, basic_authetication is now basic_auth\n* Fixed bug with encoding names in file uploads (Big thanks to Alex Young)\n* Added options to the select list\n\n=== 0.4.3\n\n* Added syntactic sugar for finding things\n* Fixed bug with HttpOnly option in cookies\n* Fixed a bug with cookie date parsing\n* Defaulted dropdown lists to the first element\n* Added unit tests\n\n=== 0.4.2\n\n* Added support for iframes\n* Made mechanize dependant on ruby-web rather than narf\n* Added unit tests\n* Fixed a bunch of warnings\n\n=== 0.4.1\n\n* Added support for file uploading\n* Added support for frames (Thanks Gabriel[mailto:leerbag@googlemail.com])\n* Added more unit tests\n* Fixed some bugs\n\n=== 0.4.0\n\n* Added more unit tests\n* Added a cookie jar with better cookie support, included expiration of cookies\n  and general cookie security.\n* Updated mechanize to use built in net/http if ruby version is new enough.\n* Added support for meta refresh tags\n* Defaulted form actions to 'GET'\n* Fixed various bugs\n* Added more unit tests\n* Added a response code exception\n* Thanks to Brian Ellin (brianellin@gmail.com) for:\n  Added support for CA files, and support for 301 response codes\n\n", "require 'mechanize/version'\nrequire 'fileutils'\nrequire 'forwardable'\nrequire 'mutex_m'\nrequire 'net/http/digest_auth'\nrequire 'net/http/persistent'\nrequire 'nokogiri'\nrequire 'openssl'\nrequire 'pp'\nrequire 'stringio'\nrequire 'uri'\nrequire 'webrick/httputils'\nrequire 'zlib'\n\n##\n# The Mechanize library is used for automating interactions with a website.  It\n# can follow links and submit forms.  Form fields can be populated and\n# submitted.  A history of URLs is maintained and can be queried.\n#\n# == Example\n#\n#   require 'mechanize'\n#   require 'logger'\n#\n#   agent = Mechanize.new\n#   agent.log = Logger.new \"mech.log\"\n#   agent.user_agent_alias = 'Mac Safari'\n#\n#   page = agent.get \"http://www.google.com/\"\n#   search_form = page.form_with :name => \"f\"\n#   search_form.field_with(:name => \"q\").value = \"Hello\"\n#\n#   search_results = agent.submit search_form\n#   puts search_results.body\n#\n# == Issues with mechanize\n#\n# If you think you have a bug with mechanize, but aren't sure, please file a\n# ticket at https://github.com/sparklemotion/mechanize/issues\n#\n# Here are some common problems you may experience with mechanize\n#\n# === Problems connecting to SSL sites\n#\n# Mechanize defaults to validating SSL certificates using the default CA\n# certificates for your platform.  At this time, Windows users do not have\n# integration between the OS default CA certificates and OpenSSL.  #cert_store\n# explains how to download and use Mozilla's CA certificates to allow SSL\n# sites to work.\n#\n# === Problems with content-length\n#\n# Some sites return an incorrect content-length value.  Unlike a browser,\n# mechanize raises an error when the content-length header does not match the\n# response length since it does not know if there was a connection problem or\n# if the mismatch is a server bug.\n#\n# The error raised, Mechanize::ResponseReadError, can be converted to a parsed\n# Page, File, etc. depending upon the content-type:\n#\n#   agent = Mechanize.new\n#   uri = URI 'http://example/invalid_content_length'\n#\n#   begin\n#     page = agent.get uri\n#   rescue Mechanize::ResponseReadError => e\n#     page = e.force_parse\n#   end\n\nclass Mechanize\n\n  ##\n  # Base mechanize error class\n\n  class Error < RuntimeError\n  end\n\n  ruby_version = if RUBY_PATCHLEVEL >= 0 then\n                   \"#{RUBY_VERSION}p#{RUBY_PATCHLEVEL}\"\n                 else\n                   \"#{RUBY_VERSION}dev#{RUBY_REVISION}\"\n                 end\n\n  ##\n  # Supported User-Agent aliases for use with user_agent_alias=.  The\n  # description in parenthesis is for informative purposes and is not part of\n  # the alias name.\n  #\n  # * Linux Firefox (43.0 on Ubuntu Linux)\n  # * Linux Konqueror (3)\n  # * Linux Mozilla\n  # * Mac Firefox (43.0)\n  # * Mac Mozilla\n  # * Mac Safari (9.0 on OS X 10.11.2)\n  # * Mac Safari 4\n  # * Mechanize (default)\n  # * Windows IE 6\n  # * Windows IE 7\n  # * Windows IE 8\n  # * Windows IE 9\n  # * Windows IE 10 (Windows 8 64bit)\n  # * Windows IE 11 (Windows 8.1 64bit)\n  # * Windows Edge\n  # * Windows Mozilla\n  # * Windows Firefox (43.0)\n  # * iPhone (iOS 9.1)\n  # * iPad (iOS 9.1)\n  # * Android (5.1.1)\n  #\n  # Example:\n  #\n  #   agent = Mechanize.new\n  #   agent.user_agent_alias = 'Mac Safari'\n\n  AGENT_ALIASES = {\n    'Mechanize' => \"Mechanize/#{VERSION} Ruby/#{ruby_version} (http://github.com/sparklemotion/mechanize/)\",\n    'Linux Firefox' => 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'Linux Konqueror' => 'Mozilla/5.0 (compatible; Konqueror/3; Linux)',\n    'Linux Mozilla' => 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.4) Gecko/20030624',\n    'Mac Firefox' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'Mac Mozilla' => 'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.4a) Gecko/20030401',\n    'Mac Safari 4' => 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; de-at) AppleWebKit/531.21.8 (KHTML, like Gecko) Version/4.0.4 Safari/531.21.10',\n    'Mac Safari' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9',\n    'Windows Chrome' => 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.125 Safari/537.36',\n    'Windows IE 6' => 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n    'Windows IE 7' => 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',\n    'Windows IE 8' => 'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',\n    'Windows IE 9' => 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)',\n    'Windows IE 10' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)',\n    'Windows IE 11' => 'Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko',\n    'Windows Edge' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586',\n    'Windows Mozilla' => 'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.4b) Gecko/20030516 Mozilla Firebird/0.6',\n    'Windows Firefox' => 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'iPhone' => 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B5110e Safari/601.1',\n    'iPad' => 'Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1',\n    'Android' => 'Mozilla/5.0 (Linux; Android 5.1.1; Nexus 7 Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.76 Safari/537.36',\n  }\n\n  AGENT_ALIASES.default_proc = proc { |hash, key|\n    case key\n    when /FireFox/\n      if ua = hash[nkey = key.sub(/FireFox/, 'Firefox')]\n        warn \"Mechanize#user_agent_alias: #{key.inspect} should be spelled as #{nkey.inspect}\"\n        ua\n      end\n    end\n  }\n\n  def self.inherited(child) # :nodoc:\n    child.html_parser = html_parser\n    child.log = log\n    super\n  end\n\n  ##\n  # Creates a new Mechanize instance and yields it to the given block.\n  #\n  # After the block executes, the instance is cleaned up. This includes\n  # closing all open connections.\n  #\n  #   Mechanize.start do |m|\n  #     m.get(\"http://example.com\")\n  #   end\n\n  def self.start\n    instance = new\n    yield(instance)\n  ensure\n    instance.shutdown\n  end\n\n  ##\n  # Creates a new mechanize instance.  If a block is given, the created\n  # instance is yielded to the block for setting up pre-connection state such\n  # as SSL parameters or proxies:\n  #\n  #   agent = Mechanize.new do |a|\n  #     a.proxy_addr = 'proxy.example'\n  #     a.proxy_port = 8080\n  #   end\n  #\n  # If you need segregated SSL connections give each agent a unique\n  # name.  Otherwise the connections will be shared.  This is\n  # particularly important if you are using certifcates.\n  #\n  #    agent_1 = Mechanize.new 'conn1'\n  #    agent_2 = Mechanize.new 'conn2'\n  #\n\n  def initialize(connection_name = 'mechanize')\n    @agent = Mechanize::HTTP::Agent.new(connection_name)\n    @agent.context = self\n    @log = nil\n\n    # attr_accessors\n    @agent.user_agent = AGENT_ALIASES['Mechanize']\n    @watch_for_set    = nil\n    @history_added    = nil\n\n    # attr_readers\n    @pluggable_parser = PluggableParser.new\n\n    @keep_alive_time  = 0\n\n    # Proxy\n    @proxy_addr = nil\n    @proxy_port = nil\n    @proxy_user = nil\n    @proxy_pass = nil\n\n    @html_parser = self.class.html_parser\n\n    @default_encoding = nil\n    @force_default_encoding = false\n\n    # defaults\n    @agent.max_history = 50\n\n    yield self if block_given?\n\n    @agent.set_proxy @proxy_addr, @proxy_port, @proxy_user, @proxy_pass\n  end\n\n  # :section: History\n  #\n  # Methods for navigating and controlling history\n\n  ##\n  # Equivalent to the browser back button.  Returns the previous page visited.\n\n  def back\n    @agent.history.pop\n  end\n\n  ##\n  # Returns the latest page loaded by Mechanize\n\n  def current_page\n    @agent.current_page\n  end\n\n  alias page current_page\n\n  ##\n  # The history of this mechanize run\n\n  def history\n    @agent.history\n  end\n\n  ##\n  # Maximum number of items allowed in the history.  The default setting is 50\n  # pages.  Note that the size of the history multiplied by the maximum\n  # response body size\n\n  def max_history\n    @agent.history.max_size\n  end\n\n  ##\n  # Sets the maximum number of items allowed in the history to +length+.\n  #\n  # Setting the maximum history length to nil will make the history size\n  # unlimited.  Take care when doing this, mechanize stores response bodies in\n  # memory for pages and in the temporary files directory for other responses.\n  # For a long-running mechanize program this can be quite large.\n  #\n  # See also the discussion under #max_file_buffer=\n\n  def max_history= length\n    @agent.history.max_size = length\n  end\n\n  ##\n  # Returns a visited page for the +url+ passed in, otherwise nil\n\n  def visited? url\n    url = url.href if url.respond_to? :href\n\n    @agent.visited_page url\n  end\n\n  ##\n  # Returns whether or not a url has been visited\n\n  alias visited_page visited?\n\n  # :section: Hooks\n  #\n  # Hooks into the operation of mechanize\n\n  ##\n  # A list of hooks to call before reading response header 'content-encoding'.\n  #\n  # The hook is called with the agent making the request, the URI of the\n  # request, the response an IO containing the response body.\n\n  def content_encoding_hooks\n    @agent.content_encoding_hooks\n  end\n\n  ##\n  # Callback which is invoked with the page that was added to history.\n\n  attr_accessor :history_added\n\n  ##\n  # A list of hooks to call after retrieving a response. Hooks are called with\n  # the agent, the URI, the response, and the response body.\n\n  def post_connect_hooks\n    @agent.post_connect_hooks\n  end\n\n  ##\n  # A list of hooks to call before retrieving a response. Hooks are called\n  # with the agent, the URI, the response, and the response body.\n\n  def pre_connect_hooks\n    @agent.pre_connect_hooks\n  end\n\n  # :section: Requests\n  #\n  # Methods for making HTTP requests\n\n  ##\n  # If the parameter is a string, finds the button or link with the\n  # value of the string on the current page and clicks it.  Otherwise, clicks\n  # the Mechanize::Page::Link object passed in.  Returns the page fetched.\n\n  def click link\n    case link\n    when Page::Link then\n      referer = link.page || current_page()\n      if @agent.robots\n        if (referer.is_a?(Page) and referer.parser.nofollow?) or\n           link.rel?('nofollow') then\n          raise RobotsDisallowedError.new(link.href)\n        end\n      end\n      if link.noreferrer?\n        href = @agent.resolve(link.href, link.page || current_page)\n        referer = Page.new\n      else\n        href = link.href\n      end\n      get href, [], referer\n    when String, Regexp then\n      if real_link = page.link_with(:text => link)\n        click real_link\n      else\n        button = nil\n        # Note that this will not work if we have since navigated to a different page.\n        # Should rather make each button aware of its parent form.\n        form = page.forms.find do |f|\n          button = f.button_with(:value => link)\n          button.is_a? Form::Submit\n        end\n        submit form, button if form\n      end\n    when Form::Submit, Form::ImageButton then\n      # Note that this will not work if we have since navigated to a different page.\n      # Should rather make each button aware of its parent form.\n      form = page.forms.find do |f|\n        f.buttons.include?(link)\n      end\n      submit form, link if form\n    else\n      referer = current_page()\n      href = link.respond_to?(:href) ? link.href :\n        (link['href'] || link['src'])\n      get href, [], referer\n    end\n  end\n\n  ##\n  # GETs +uri+ and writes it to +io_or_filename+ without recording the request\n  # in the history.  If +io_or_filename+ does not respond to #write it will be\n  # used as a file name.  +parameters+, +referer+ and +headers+ are used as in\n  # #get.\n  #\n  # By default, if the Content-type of the response matches a Mechanize::File\n  # or Mechanize::Page parser, the response body will be loaded into memory\n  # before being saved.  See #pluggable_parser for details on changing this\n  # default.\n  #\n  # For alternate ways of downloading files see Mechanize::FileSaver and\n  # Mechanize::DirectorySaver.\n\n  def download uri, io_or_filename, parameters = [], referer = nil, headers = {}\n    page = transact do\n      get uri, parameters, referer, headers\n    end\n\n    io = if io_or_filename.respond_to? :write then\n           io_or_filename\n         else\n           open io_or_filename, 'wb'\n         end\n\n    case page\n    when Mechanize::File then\n      io.write page.body\n    else\n      body_io = page.body_io\n\n      until body_io.eof? do\n        io.write body_io.read 16384\n      end\n    end\n\n    page\n  ensure\n    io.close if io and not io_or_filename.respond_to? :write\n  end\n\n  ##\n  # DELETE +uri+ with +query_params+, and setting +headers+:\n  #\n  # +query_params+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  #   delete('http://example/', {'q' => 'foo'}, {})\n\n  def delete(uri, query_params = {}, headers = {})\n    page = @agent.fetch(uri, :delete, headers, query_params)\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # GET the +uri+ with the given request +parameters+, +referer+ and\n  # +headers+.\n  #\n  # The +referer+ may be a URI or a page.\n  #\n  # +parameters+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n\n  def get(uri, parameters = [], referer = nil, headers = {})\n    method = :get\n\n    referer ||=\n      if uri.to_s =~ %r{\\Ahttps?://}\n        Page.new\n      else\n        current_page || Page.new\n      end\n\n    # FIXME: Huge hack so that using a URI as a referer works.  I need to\n    # refactor everything to pass around URIs but still support\n    # Mechanize::Page#base\n    unless Mechanize::Parser === referer then\n      referer = if referer.is_a?(String) then\n                  Page.new URI(referer)\n                else\n                  Page.new referer\n                end\n    end\n\n    # fetch the page\n    headers ||= {}\n    page = @agent.fetch uri, method, headers, parameters, referer\n    add_to_history(page)\n    yield page if block_given?\n    page\n  end\n\n  ##\n  # GET +url+ and return only its contents\n\n  def get_file(url)\n    get(url).body\n  end\n\n  ##\n  # HEAD +uri+ with +query_params+ and +headers+:\n  #\n  # +query_params+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  #   head('http://example/', {'q' => 'foo'}, {})\n\n  def head(uri, query_params = {}, headers = {})\n    page = @agent.fetch uri, :head, headers, query_params\n\n    yield page if block_given?\n\n    page\n  end\n\n  ##\n  # POST to the given +uri+ with the given +query+.\n  #\n  # +query+ is processed using Mechanize::Util.each_parameter (which\n  # see), and then encoded into an entity body.  If any IO/FileUpload\n  # object is specified as a field value the \"enctype\" will be\n  # multipart/form-data, or application/x-www-form-urlencoded\n  # otherwise.\n  #\n  # Examples:\n  #   agent.post 'http://example.com/', \"foo\" => \"bar\"\n  #\n  #   agent.post 'http://example.com/', [%w[foo bar]]\n  #\n  #   agent.post('http://example.com/', \"<message>hello</message>\",\n  #              'Content-Type' => 'application/xml')\n\n  def post(uri, query = {}, headers = {})\n    return request_with_entity(:post, uri, query, headers) if String === query\n\n    node = {}\n    # Create a fake form\n    class << node\n      def search(*args); []; end\n    end\n    node['method'] = 'POST'\n    node['enctype'] = 'application/x-www-form-urlencoded'\n\n    form = Form.new(node)\n\n    Mechanize::Util.each_parameter(query) { |k, v|\n      if v.is_a?(IO)\n        form.enctype = 'multipart/form-data'\n        ul = Form::FileUpload.new({'name' => k.to_s},::File.basename(v.path))\n        ul.file_data = v.read\n        form.file_uploads << ul\n      elsif v.is_a?(Form::FileUpload)\n        form.enctype = 'multipart/form-data'\n        form.file_uploads << v\n      else\n        form.fields << Form::Field.new({'name' => k.to_s},v)\n      end\n    }\n    post_form(uri, form, headers)\n  end\n\n  ##\n  # PUT to +uri+ with +entity+, and setting +headers+:\n  #\n  #   put('http://example/', 'new content', {'Content-Type' => 'text/plain'})\n\n  def put(uri, entity, headers = {})\n    request_with_entity(:put, uri, entity, headers)\n  end\n\n  ##\n  # Makes an HTTP request to +url+ using HTTP method +verb+.  +entity+ is used\n  # as the request body, if allowed.\n\n  def request_with_entity(verb, uri, entity, headers = {})\n    cur_page = current_page || Page.new\n\n    log.debug(\"query: #{ entity.inspect }\") if log\n\n    headers = {\n      'Content-Type' => 'application/octet-stream',\n      'Content-Length' => entity.size.to_s,\n    }.update headers\n\n    page = @agent.fetch uri, verb, headers, [entity], cur_page\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # Submits +form+ with an optional +button+.\n  #\n  # Without a button:\n  #\n  #   page = agent.get('http://example.com')\n  #   agent.submit(page.forms.first)\n  #\n  # With a button:\n  #\n  #   agent.submit(page.forms.first, page.forms.first.buttons.first)\n\n  def submit(form, button = nil, headers = {})\n    form.add_button_to_query(button) if button\n\n    case form.method.upcase\n    when 'POST'\n      post_form(form.action, form, headers)\n    when 'GET'\n      get(form.action.gsub(/\\?[^\\?]*$/, ''),\n          form.build_query,\n          form.page,\n          headers)\n    else\n      raise ArgumentError, \"unsupported method: #{form.method.upcase}\"\n    end\n  end\n\n  ##\n  # Runs given block, then resets the page history as it was before. self is\n  # given as a parameter to the block.  Returns the value of the block.\n\n  def transact\n    history_backup = @agent.history.dup\n    begin\n      yield self\n    ensure\n      @agent.history = history_backup\n    end\n  end\n\n  # :section: Settings\n  #\n  # Settings that adjust how mechanize makes HTTP requests including timeouts,\n  # keep-alives, compression, redirects and headers.\n\n  @html_parser = Nokogiri::HTML\n  @log = nil\n\n  class << self\n\n    ##\n    # Default HTML parser for all mechanize instances\n    #\n    #   Mechanize.html_parser = Nokogiri::XML\n\n    attr_accessor :html_parser\n\n    ##\n    # Default logger for all mechanize instances\n    #\n    #   Mechanize.log = Logger.new $stderr\n\n    attr_accessor :log\n\n  end\n\n  ##\n  # A default encoding name used when parsing HTML parsing.  When set it is\n  # used after any other encoding.  The default is nil.\n\n  attr_accessor :default_encoding\n\n  ##\n  # Overrides the encodings given by the HTTP server and the HTML page with\n  # the default_encoding when set to true.\n\n  attr_accessor :force_default_encoding\n\n  ##\n  # The HTML parser to be used when parsing documents\n\n  attr_accessor :html_parser\n\n  ##\n  # HTTP/1.0 keep-alive time.  This is no longer supported by mechanize as it\n  # now uses net-http-persistent which only supports HTTP/1.1 persistent\n  # connections\n\n  attr_accessor :keep_alive_time\n\n  ##\n  # The pluggable parser maps a response Content-Type to a parser class.  The\n  # registered Content-Type may be either a full content type like 'image/png'\n  # or a media type 'text'.  See Mechanize::PluggableParser for further\n  # details.\n  #\n  # Example:\n  #\n  #   agent.pluggable_parser['application/octet-stream'] = Mechanize::Download\n\n  attr_reader :pluggable_parser\n\n  ##\n  # The HTTP proxy address\n\n  attr_reader :proxy_addr\n\n  ##\n  # The HTTP proxy password\n\n  attr_reader :proxy_pass\n\n  ##\n  # The HTTP proxy port\n\n  attr_reader :proxy_port\n\n  ##\n  # The HTTP proxy username\n\n  attr_reader :proxy_user\n\n  ##\n  # *NOTE*: These credentials will be used as a default for any challenge\n  # exposing your password to disclosure to malicious servers.  Use of this\n  # method will warn.  This method is deprecated and will be removed in\n  # mechanize 3.\n  #\n  # Sets the +user+ and +password+ as the default credentials to be used for\n  # HTTP authentication for any server.  The +domain+ is used for NTLM\n  # authentication.\n\n  def auth user, password, domain = nil\n    caller.first =~ /(.*?):(\\d+).*?$/\n\n    warn <<-WARNING\nAt #{$1} line #{$2}\n\nUse of #auth and #basic_auth are deprecated due to a security vulnerability.\n\n    WARNING\n\n    @agent.add_default_auth user, password, domain\n  end\n\n  alias basic_auth auth\n\n  ##\n  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the\n  # credentials are used only for that realm.  If +realm+ is not set the\n  # credentials become the default for any realm on that URI.\n  #\n  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If\n  # +domain+ is given it is only used for NTLM authentication.\n\n  def add_auth uri, user, password, realm = nil, domain = nil\n    @agent.add_auth uri, user, password, realm, domain\n  end\n\n  ##\n  # Are If-Modified-Since conditional requests enabled?\n\n  def conditional_requests\n    @agent.conditional_requests\n  end\n\n  ##\n  # Disables If-Modified-Since conditional requests (enabled by default)\n\n  def conditional_requests= enabled\n    @agent.conditional_requests = enabled\n  end\n\n  ##\n  # A Mechanize::CookieJar which stores cookies\n\n  def cookie_jar\n    @agent.cookie_jar\n  end\n\n  ##\n  # Replaces the cookie jar with +cookie_jar+\n\n  def cookie_jar= cookie_jar\n    @agent.cookie_jar = cookie_jar\n  end\n\n  ##\n  # Returns a list of cookies stored in the cookie jar.\n\n  def cookies\n    @agent.cookie_jar.to_a\n  end\n\n  ##\n  # Follow HTML meta refresh and HTTP Refresh headers.  If set to +:anywhere+\n  # meta refresh tags outside of the head element will be followed.\n\n  def follow_meta_refresh\n    @agent.follow_meta_refresh\n  end\n\n  ##\n  # Controls following of HTML meta refresh and HTTP Refresh headers in\n  # responses.\n\n  def follow_meta_refresh= follow\n    @agent.follow_meta_refresh = follow\n  end\n\n  ##\n  # Follow an HTML meta refresh and HTTP Refresh headers that have no \"url=\"\n  # in the content attribute.\n  #\n  # Defaults to false to prevent infinite refresh loops.\n\n  def follow_meta_refresh_self\n    @agent.follow_meta_refresh_self\n  end\n\n  ##\n  # Alters the following of HTML meta refresh and HTTP Refresh headers that\n  # point to the same page.\n\n  def follow_meta_refresh_self= follow\n    @agent.follow_meta_refresh_self = follow\n  end\n\n  ##\n  # Is gzip compression of responses enabled?\n\n  def gzip_enabled\n    @agent.gzip_enabled\n  end\n\n  ##\n  # Disables HTTP/1.1 gzip compression (enabled by default)\n\n  def gzip_enabled=enabled\n    @agent.gzip_enabled = enabled\n  end\n\n  ##\n  # Connections that have not been used in this many seconds will be reset.\n\n  def idle_timeout\n    @agent.idle_timeout\n  end\n\n  # Sets the idle timeout to +idle_timeout+.  The default timeout is 5\n  # seconds.  If you experience \"too many connection resets\", reducing this\n  # value may help.\n\n  def idle_timeout= idle_timeout\n    @agent.idle_timeout = idle_timeout\n  end\n\n  ##\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding so long as at least one byte was received.  Be careful when\n  # enabling this as it may cause data loss.\n  #\n  # Net::HTTP does not inform mechanize of where in the chunked stream the EOF\n  # occurred.  Usually it is after the last-chunk but before the terminating\n  # CRLF (invalid termination) but it may occur earlier.  In the second case\n  # your response body may be incomplete.\n\n  def ignore_bad_chunking\n    @agent.ignore_bad_chunking\n  end\n\n  ##\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding.  See ignore_bad_chunking for further details\n\n  def ignore_bad_chunking= ignore_bad_chunking\n    @agent.ignore_bad_chunking = ignore_bad_chunking\n  end\n\n  ##\n  # Are HTTP/1.1 keep-alive connections enabled?\n\n  def keep_alive\n    @agent.keep_alive\n  end\n\n  ##\n  # Disable HTTP/1.1 keep-alive connections if +enable+ is set to false.  If\n  # you are experiencing \"too many connection resets\" errors setting this to\n  # false will eliminate them.\n  #\n  # You should first investigate reducing idle_timeout.\n\n  def keep_alive= enable\n    @agent.keep_alive = enable\n  end\n\n  ##\n  # The current logger.  If no logger has been set Mechanize.log is used.\n\n  def log\n    @log || Mechanize.log\n  end\n\n  ##\n  # Sets the +logger+ used by this instance of mechanize\n\n  def log= logger\n    @log = logger\n  end\n\n  ##\n  # Responses larger than this will be written to a Tempfile instead of stored\n  # in memory.  The default is 100,000 bytes.\n  #\n  # A value of nil disables creation of Tempfiles.\n\n  def max_file_buffer\n    @agent.max_file_buffer\n  end\n\n  ##\n  # Sets the maximum size of a response body that will be stored in memory to\n  # +bytes+.  A value of nil causes all response bodies to be stored in\n  # memory.\n  #\n  # Note that for Mechanize::Download subclasses, the maximum buffer size\n  # multiplied by the number of pages stored in history (controlled by\n  # #max_history) is an approximate upper limit on the amount of memory\n  # Mechanize will use.  By default, Mechanize can use up to ~5MB to store\n  # response bodies for non-File and non-Page (HTML) responses.\n  #\n  # See also the discussion under #max_history=\n\n  def max_file_buffer= bytes\n    @agent.max_file_buffer = bytes\n  end\n\n  ##\n  # Length of time to wait until a connection is opened in seconds\n\n  def open_timeout\n    @agent.open_timeout\n  end\n\n  ##\n  # Sets the connection open timeout to +open_timeout+\n\n  def open_timeout= open_timeout\n    @agent.open_timeout = open_timeout\n  end\n\n  ##\n  # Length of time to wait for data from the server\n\n  def read_timeout\n    @agent.read_timeout\n  end\n\n  ##\n  # Sets the timeout for each chunk of data read from the server to\n  # +read_timeout+.  A single request may read many chunks of data.\n\n  def read_timeout= read_timeout\n    @agent.read_timeout = read_timeout\n  end\n\n  ##\n  # Controls how mechanize deals with redirects.  The following values are\n  # allowed:\n  #\n  # :all, true:: All 3xx redirects are followed (default)\n  # :permanent:: Only 301 Moved Permanantly redirects are followed\n  # false:: No redirects are followed\n\n  def redirect_ok\n    @agent.redirect_ok\n  end\n\n  alias follow_redirect? redirect_ok\n\n  ##\n  # Sets the mechanize redirect handling policy.  See redirect_ok for allowed\n  # values\n\n  def redirect_ok= follow\n    @agent.redirect_ok = follow\n  end\n\n  alias follow_redirect= redirect_ok=\n\n  ##\n  # Maximum number of redirections to follow\n\n  def redirection_limit\n    @agent.redirection_limit\n  end\n\n  ##\n  # Sets the maximum number of redirections to follow to +limit+\n\n  def redirection_limit= limit\n    @agent.redirection_limit = limit\n  end\n\n  ##\n  # Resolve the full path of a link / uri\n  def resolve link\n    @agent.resolve link\n  end\n\n  ##\n  # A hash of custom request headers that will be sent on every request\n\n  def request_headers\n    @agent.request_headers\n  end\n\n  ##\n  # Replaces the custom request headers that will be sent on every request\n  # with +request_headers+\n\n  def request_headers= request_headers\n    @agent.request_headers = request_headers\n  end\n\n  ##\n  # Retry POST and other non-idempotent requests.  See RFC 2616 9.1.2.\n\n  def retry_change_requests\n    @agent.retry_change_requests\n  end\n\n  ##\n  # When setting +retry_change_requests+ to true you are stating that, for all\n  # the URLs you access with mechanize, making POST and other non-idempotent\n  # requests is safe and will not cause data duplication or other harmful\n  # results.\n  #\n  # If you are experiencing \"too many connection resets\" errors you should\n  # instead investigate reducing the idle_timeout or disabling keep_alive\n  # connections.\n\n  def retry_change_requests= retry_change_requests\n    @agent.retry_change_requests = retry_change_requests\n  end\n\n  ##\n  # Will <code>/robots.txt</code> files be obeyed?\n\n  def robots\n    @agent.robots\n  end\n\n  ##\n  # When +enabled+ mechanize will retrieve and obey <code>robots.txt</code>\n  # files\n\n  def robots= enabled\n    @agent.robots = enabled\n  end\n\n  ##\n  # The handlers for HTTP and other URI protocols.\n\n  def scheme_handlers\n    @agent.scheme_handlers\n  end\n\n  ##\n  # Replaces the URI scheme handler table with +scheme_handlers+\n\n  def scheme_handlers= scheme_handlers\n    @agent.scheme_handlers = scheme_handlers\n  end\n\n  ##\n  # The identification string for the client initiating a web request\n\n  def user_agent\n    @agent.user_agent\n  end\n\n  ##\n  # Sets the User-Agent used by mechanize to +user_agent+.  See also\n  # user_agent_alias\n\n  def user_agent= user_agent\n    @agent.user_agent = user_agent\n  end\n\n  ##\n  # Set the user agent for the Mechanize object based on the given +name+.\n  #\n  # See also AGENT_ALIASES\n\n  def user_agent_alias= name\n    self.user_agent = AGENT_ALIASES[name] ||\n      raise(ArgumentError, \"unknown agent alias #{name.inspect}\")\n  end\n\n  ##\n  # The value of watch_for_set is passed to pluggable parsers for retrieved\n  # content\n\n  attr_accessor :watch_for_set\n\n  # :section: SSL\n  #\n  # SSL settings for mechanize.  These must be set in the block given to\n  # Mechanize.new\n\n  ##\n  # Path to an OpenSSL server certificate file\n\n  def ca_file\n    @agent.ca_file\n  end\n\n  ##\n  # Sets the certificate file used for SSL connections\n\n  def ca_file= ca_file\n    @agent.ca_file = ca_file\n  end\n\n  ##\n  # An OpenSSL client certificate or the path to a certificate file.\n\n  def cert\n    @agent.certificate\n  end\n\n  ##\n  # Sets the OpenSSL client certificate +cert+ to the given path or\n  # certificate instance\n\n  def cert= cert\n    @agent.certificate = cert\n  end\n\n  ##\n  # An OpenSSL certificate store for verifying server certificates.  This\n  # defaults to the default certificate store for your system.\n  #\n  # If your system does not ship with a default set of certificates you can\n  # retrieve a copy of the set from Mozilla here:\n  # http://curl.haxx.se/docs/caextract.html\n  #\n  # (Note that this set does not have an HTTPS download option so you may\n  # wish to use the firefox-db2pem.sh script to extract the certificates\n  # from a local install to avoid man-in-the-middle attacks.)\n  #\n  # After downloading or generating a cacert.pem from the above link you\n  # can create a certificate store from the pem file like this:\n  #\n  #   cert_store = OpenSSL::X509::Store.new\n  #   cert_store.add_file 'cacert.pem'\n  #\n  # And have mechanize use it with:\n  #\n  #   agent.cert_store = cert_store\n\n  def cert_store\n    @agent.cert_store\n  end\n\n  ##\n  # Sets the OpenSSL certificate store to +store+.\n  #\n  # See also #cert_store\n\n  def cert_store= cert_store\n    @agent.cert_store = cert_store\n  end\n\n  ##\n  # What is this?\n  #\n  # Why is it different from #cert?\n\n  def certificate # :nodoc:\n    @agent.certificate\n  end\n\n  ##\n  # An OpenSSL private key or the path to a private key\n\n  def key\n    @agent.private_key\n  end\n\n  ##\n  # Sets the OpenSSL client +key+ to the given path or key instance.  If a\n  # path is given, the path must contain an RSA key file.\n\n  def key= key\n    @agent.private_key = key\n  end\n\n  ##\n  # OpenSSL client key password\n\n  def pass\n    @agent.pass\n  end\n\n  ##\n  # Sets the client key password to +pass+\n\n  def pass= pass\n    @agent.pass = pass\n  end\n\n  ##\n  # SSL version to use.\n\n  def ssl_version\n    @agent.ssl_version\n  end\n\n  ##\n  # Sets the SSL version to use to +version+ without client/server\n  # negotiation.\n\n  def ssl_version= ssl_version\n    @agent.ssl_version = ssl_version\n  end\n\n  ##\n  # A callback for additional certificate verification.  See\n  # OpenSSL::SSL::SSLContext#verify_callback\n  #\n  # The callback can be used for debugging or to ignore errors by always\n  # returning +true+.  Specifying nil uses the default method that was valid\n  # when the SSLContext was created\n\n  def verify_callback\n    @agent.verify_callback\n  end\n\n  ##\n  # Sets the OpenSSL certificate verification callback\n\n  def verify_callback= verify_callback\n    @agent.verify_callback = verify_callback\n  end\n\n  ##\n  # the OpenSSL server certificate verification method.  The default is\n  # OpenSSL::SSL::VERIFY_PEER and certificate verification uses the default\n  # system certificates.  See also cert_store\n\n  def verify_mode\n    @agent.verify_mode\n  end\n\n  ##\n  # Sets the OpenSSL server certificate verification method.\n\n  def verify_mode= verify_mode\n    @agent.verify_mode = verify_mode\n  end\n\n  # :section: Utilities\n\n  attr_reader :agent # :nodoc:\n\n  ##\n  # Parses the +body+ of the +response+ from +uri+ using the pluggable parser\n  # that matches its content type\n\n  def parse uri, response, body\n    content_type = nil\n\n    unless response['Content-Type'].nil?\n      data, = response['Content-Type'].split ';', 2\n      content_type, = data.downcase.split ',', 2 unless data.nil?\n    end\n\n    parser_klass = @pluggable_parser.parser content_type\n\n    unless parser_klass <= Mechanize::Download then\n      body = case body\n             when IO, Tempfile, StringIO then\n               body.read\n             else\n               body\n             end\n    end\n\n    parser_klass.new uri, response, body, response.code do |parser|\n      parser.mech = self if parser.respond_to? :mech=\n\n      parser.watch_for_set = @watch_for_set if\n        @watch_for_set and parser.respond_to?(:watch_for_set=)\n    end\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.object_group(self) {\n      q.breakable\n      q.pp cookie_jar\n      q.breakable\n      q.pp current_page\n    }\n  end\n\n  ##\n  # Sets the proxy +address+ at +port+ with an optional +user+ and +password+\n\n  def set_proxy address, port, user = nil, password = nil\n    @proxy_addr = address\n    @proxy_port = port\n    @proxy_user = user\n    @proxy_pass = password\n\n    @agent.set_proxy address, port, user, password\n  end\n\n  ##\n  # Clears history and cookies.\n\n  def reset\n    @agent.reset\n  end\n\n  ##\n  # Shuts down this session by clearing browsing state and closing all\n  # persistent connections.\n\n  def shutdown\n    reset\n    @agent.shutdown\n  end\n\n  private\n\n  ##\n  # Posts +form+ to +uri+\n\n  def post_form(uri, form, headers = {})\n    cur_page = form.page || current_page ||\n      Page.new\n\n    request_data = form.request_data\n\n    log.debug(\"query: #{ request_data.inspect }\") if log\n\n    headers = {\n      'Content-Type'    => form.enctype,\n      'Content-Length'  => request_data.size.to_s,\n    }.merge headers\n\n    # fetch the page\n    page = @agent.fetch uri, :post, headers, [request_data], cur_page\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # Adds +page+ to the history\n\n  def add_to_history(page)\n    @agent.history.push(page, @agent.resolve(page.uri))\n    @history_added.call(page) if @history_added\n  end\n\nend\n\nrequire 'mechanize/element_not_found_error'\nrequire 'mechanize/response_read_error'\nrequire 'mechanize/chunked_termination_error'\nrequire 'mechanize/content_type_error'\nrequire 'mechanize/cookie'\nrequire 'mechanize/cookie_jar'\nrequire 'mechanize/parser'\nrequire 'mechanize/download'\nrequire 'mechanize/directory_saver'\nrequire 'mechanize/file'\nrequire 'mechanize/file_connection'\nrequire 'mechanize/file_request'\nrequire 'mechanize/file_response'\nrequire 'mechanize/form'\nrequire 'mechanize/history'\nrequire 'mechanize/http'\nrequire 'mechanize/http/agent'\nrequire 'mechanize/http/auth_challenge'\nrequire 'mechanize/http/auth_realm'\nrequire 'mechanize/http/content_disposition_parser'\nrequire 'mechanize/http/www_authenticate_parser'\nrequire 'mechanize/image'\nrequire 'mechanize/page'\nrequire 'mechanize/pluggable_parsers'\nrequire 'mechanize/redirect_limit_reached_error'\nrequire 'mechanize/redirect_not_get_or_head_error'\nrequire 'mechanize/response_code_error'\nrequire 'mechanize/robots_disallowed_error'\nrequire 'mechanize/unauthorized_error'\nrequire 'mechanize/unsupported_scheme_error'\nrequire 'mechanize/util'\n\n", "warn 'mechanize/cookie_jar will be deprecated.  Please migrate to the http-cookie APIs.' if $VERBOSE\n\nrequire 'http/cookie_jar'\nrequire 'http/cookie_jar/yaml_saver'\nrequire 'mechanize/cookie'\n\nclass Mechanize\n  module CookieJarIMethods\n    include CookieDeprecated\n\n    def add(arg1, arg2 = nil)\n      if arg2\n        __deprecated__ 'add and origin='\n        super arg2.dup.tap { |ncookie|\n          begin\n            ncookie.origin = arg1\n          rescue\n            return nil\n          end\n        }\n      else\n        super arg1\n      end\n    end\n\n    # See HTTP::CookieJar#add.\n    def add!(cookie)\n      __deprecated__ :add\n      cookie.domain.nil? and raise NoMethodError, 'raised for compatibility'\n      @store.add(cookie)\n      self\n    end\n\n    # See HTTP::CookieJar#save.\n    def save_as(filename, *options)\n      __deprecated__ :save\n      save(filename, *options)\n    end\n\n    # See HTTP::CookieJar#clear.\n    def clear!\n      __deprecated__ :clear\n      clear\n    end\n\n    # See HTTP::CookieJar#store.\n    def jar\n      __deprecated__ :store\n      @store.instance_variable_get(:@jar)\n    end\n\n    # See HTTP::CookieJar#load.\n    def load_cookiestxt(io)\n      __deprecated__ :load\n      load(io, :cookiestxt)\n    end\n\n    # See HTTP::CookieJar#save.\n    def dump_cookiestxt(io)\n      __deprecated__ :save\n      save(io, :cookiestxt)\n    end\n  end\n\n  class CookieJar < ::HTTP::CookieJar\n    def save(output, *options)\n      output.respond_to?(:write) or\n        return open(output, 'w') { |io| save(io, *options) }\n\n      opthash = {\n        :format => :yaml,\n        :session => false,\n      }\n      case options.size\n      when 0\n      when 1\n        case options = options.first\n        when Symbol\n          opthash[:format] = options\n        else\n          opthash.update(options) if options\n        end\n      when 2\n        opthash[:format], options = options\n        opthash.update(options) if options\n      else\n        raise ArgumentError, 'wrong number of arguments (%d for 1-3)' % (1 + options.size)\n      end\n\n      return super(output, opthash) if opthash[:format] != :yaml\n\n      session = opthash[:session]\n      nstore = HashStore.new\n\n      each { |cookie|\n        next if !session && cookie.session?\n\n        if cookie.max_age\n          cookie = cookie.dup\n          cookie.expires = cookie.expires # convert max_age to expires\n        end\n        nstore.add(cookie)\n      }\n\n      yaml = YAML.dump(nstore.instance_variable_get(:@jar))\n\n      # a gross hack\n      yaml.gsub!(%r{^(    [^ ].*: !ruby/object:)HTTP::Cookie$}) {\n        $1 + 'Mechanize::Cookie'\n      }\n      yaml.gsub!(%r{^(      expires: )(?:|!!null|(.+?)) *$}) {\n        $1 + ($2 ? Time.parse($2).httpdate : '')\n      }\n\n      output.write yaml\n\n      self\n    end\n\n    def load(input, *options)\n      input.respond_to?(:write) or\n        return open(input, 'r') { |io| load(io, *options) }\n\n      opthash = {\n        :format => :yaml,\n        :session => false,\n      }\n      case options.size\n      when 0\n      when 1\n        case options = options.first\n        when Symbol\n          opthash[:format] = options\n        else\n          if hash = Hash.try_convert(options)\n            opthash.update(hash)\n          end\n        end\n      when 2\n        opthash[:format], options = options\n        if hash = Hash.try_convert(options)\n          opthash.update(hash)\n        end\n      else\n        raise ArgumentError, 'wrong number of arguments (%d for 1-3)' % (1 + options.size)\n      end\n\n      return super(input, opthash) if opthash[:format] != :yaml\n\n      begin\n        data = YAML.load(input)\n      rescue ArgumentError\n        @logger.warn \"unloadable YAML cookie data discarded\" if @logger\n        return self\n      end\n\n      case data\n      when Array\n        # Forward compatibility\n        data.each { |cookie|\n          add(cookie)\n        }\n      when Hash\n        data.each { |domain, paths|\n          paths.each { |path, names|\n            names.each { |cookie_name, cookie|\n              add(cookie)\n            }\n          }\n        }\n      else\n        @logger.warn \"incompatible YAML cookie data discarded\" if @logger\n        return self\n      end\n    end\n  end\n\n  # Compatibility for Ruby 1.8/1.9\n  unless ::HTTP::CookieJar.respond_to?(:prepend, true)\n    require 'mechanize/prependable'\n\n    class ::HTTP::CookieJar\n      extend Prependable\n    end\n  end\n\n  class ::HTTP::CookieJar\n    prepend CookieJarIMethods\n  end\nend\n", "##\n# Download is a pluggable parser for downloading files without loading them\n# into memory first.  You may subclass this class to handle content types you\n# do not wish to load into memory first.\n#\n# See Mechanize::PluggableParser for instructions on using this class.\n\nclass Mechanize::Download\n\n  include Mechanize::Parser\n\n  ##\n  # The filename for this file based on the content-disposition of the\n  # response or the basename of the URL\n\n  attr_accessor :filename\n\n  ##\n  # Accessor for the IO-like that contains the body\n\n  attr_reader :body_io\n\n  alias content body_io\n\n  ##\n  # Creates a new download retrieved from the given +uri+ and +response+\n  # object.  The +body_io+ is an IO-like containing the HTTP response body and\n  # +code+ is the HTTP status.\n\n  def initialize uri = nil, response = nil, body_io = nil, code = nil\n    @uri      = uri\n    @body_io  = body_io\n    @code     = code\n\n    @full_path = false unless defined? @full_path\n\n    fill_header response\n    extract_filename\n\n    yield self if block_given?\n  end\n\n  ##\n  # The body of this response as a String.\n  #\n  # Take care, this may use lots of memory if the response body is large.\n\n  def body\n    @body_io.read.tap { @body_io.rewind }\n  end\n\n  ##\n  # Saves a copy of the body_io to +filename+\n  # returns the filename\n\n  def save filename = nil\n    filename = find_free_name filename\n    save! filename\n  end\n\n  alias save_as save\n\n  ##\n  # Use this method to save the content of body_io to +filename+.\n  # This method will overwrite any existing filename that exists with the\n  # same name.\n  # returns the filename\n\n  def save! filename = nil\n    filename ||= @filename\n    dirname = File.dirname filename\n    FileUtils.mkdir_p dirname\n\n    open filename, 'wb' do |io|\n      until @body_io.eof? do\n        io.write @body_io.read 16384\n      end\n    end\n\n    filename\n  end\n\nend\n\n", "##\n# This is the base class for the Pluggable Parsers.  If Mechanize cannot find\n# an appropriate class to use for the content type, this class will be used.\n# For example, if you download an image/jpeg, Mechanize will not know how to\n# parse it, so this class will be instantiated.\n#\n# This is a good class to use as the base class for building your own\n# pluggable parsers.\n#\n# == Example\n#\n#   require 'mechanize'\n#\n#   agent = Mechanize.new\n#   agent.get('http://example.com/foo.jpg').class  #=> Mechanize::File\n\nclass Mechanize::File\n\n  include Mechanize::Parser\n\n  ##\n  # The HTTP response body, the raw file contents\n\n  attr_accessor :body\n\n  ##\n  # The filename for this file based on the content-disposition of the\n  # response or the basename of the URL\n\n  attr_accessor :filename\n\n  alias content body\n\n  ##\n  # Creates a new file retrieved from the given +uri+ and +response+ object.\n  # The +body+ is the HTTP response body and +code+ is the HTTP status.\n\n  def initialize uri = nil, response = nil, body = nil, code = nil\n    @uri  = uri\n    @body = body\n    @code = code\n\n    @full_path = false unless defined? @full_path\n\n    fill_header response\n    extract_filename\n\n    yield self if block_given?\n  end\n\n  ##\n  # Use this method to save the content of this object to +filename+.\n  # returns the filename\n  #\n  #   file.save 'index.html'\n  #   file.save 'index.html' # saves to index.html.1\n  #\n  #   uri = URI 'http://localhost/test.html'\n  #   file = Mechanize::File.new uri, nil, ''\n  #   filename = file.save  # saves to test.html\n  #   puts filename         # test.html\n\n  def save filename = nil\n    filename = find_free_name filename\n    save! filename\n  end\n\n  alias save_as save\n\n  ##\n  # Use this method to save the content of this object to +filename+.\n  # This method will overwrite any existing filename that exists with the\n  # same name.\n  # returns the filename\n  #\n  #   file.save 'index.html'\n  #   file.save! 'index.html' # overwrite original file\n  #   filename = file.save! 'index.html' # overwrite original file with filename 'index.html'\n\n  def save! filename = nil\n    filename ||= @filename\n    dirname = File.dirname filename\n    FileUtils.mkdir_p dirname\n\n    open filename, 'wb' do |f|\n      f.write body\n    end\n\n    filename\n  end\n\nend\n\n", "##\n# Fake response for dealing with file:/// requests\n\nclass Mechanize::FileResponse\n\n  def initialize(file_path)\n    @file_path = file_path\n    @uri       = nil\n  end\n\n  def read_body\n    raise Mechanize::ResponseCodeError.new(self) unless\n      File.exist? @file_path\n\n    if directory?\n      yield dir_body\n    else\n      open @file_path, 'rb' do |io|\n        yield io.read\n      end\n    end\n  end\n\n  def code\n    File.exist?(@file_path) ? 200 : 404\n  end\n\n  def content_length\n    return dir_body.length if directory?\n    File.exist?(@file_path) ? File.stat(@file_path).size : 0\n  end\n\n  def each_header; end\n\n  def [](key)\n    return nil if key.casecmp('Content-Type') != 0\n    return 'text/html' if directory?\n    return 'text/html' if ['.html', '.xhtml'].any? { |extn|\n      @file_path.end_with?(extn)\n    }\n    nil\n  end\n\n  def each\n  end\n\n  def get_fields(key)\n    []\n  end\n\n  def http_version\n    '0'\n  end\n\n  def message\n    File.exist?(@file_path) ? 'OK' : 'Not Found'\n  end\n\n  def uri\n    @uri ||= URI \"file://#{@file_path}\"\n  end\n\n  private\n\n  def dir_body\n    body = %w[<html><body>]\n    body.concat Dir[File.join(@file_path, '*')].map { |f|\n      \"<a href=\\\"file://#{f}\\\">#{File.basename(f)}</a>\"\n    }\n    body << %w[</body></html>]\n\n    body.join(\"\\n\").force_encoding(Encoding::BINARY)\n  end\n\n  def directory?\n    File.directory?(@file_path)\n  end\n\nend\n\n", "require 'mechanize'\nrequire 'logger'\nrequire 'tempfile'\nrequire 'tmpdir'\nrequire 'webrick'\nrequire 'zlib'\n\nrequire 'rubygems'\n\nbegin\n  gem 'minitest'\nrescue Gem::LoadError\nend\n\nrequire 'minitest/autorun'\n\nbegin\n  require 'minitest/pride'\nrescue LoadError\nend\n\n##\n# A generic test case for testing mechanize.  Using a subclass of\n# Mechanize::TestCase for your tests will create an isolated mechanize\n# instance that won't pollute your filesystem or other tests.\n#\n# Once Mechanize::TestCase is loaded no HTTP requests will be made outside\n# mechanize itself.  All requests are handled via WEBrick servlets.\n#\n# Mechanize uses WEBrick servlets to test some functionality.  You can run\n# other HTTP clients against the servlets using:\n#\n#   ruby -rmechanize/test_case/server -e0\n#\n# Which will launch a test server at http://localhost:8000\n\nclass Mechanize::TestCase < Minitest::Test\n\n  TEST_DIR = File.expand_path '../../../test', __FILE__\n  REQUESTS = []\n\n  ##\n  # Creates a clean mechanize instance +@mech+ for use in tests.\n\n  def setup\n    super\n\n    REQUESTS.clear\n    @mech = Mechanize.new\n    @ssl_private_key = nil\n    @ssl_certificate = nil\n  end\n\n  ##\n  # Creates a fake page with URI http://fake.example and an empty, submittable\n  # form.\n\n  def fake_page agent = @mech\n    uri = URI 'http://fake.example/'\n    html = <<-END\n<html>\n<body>\n<form><input type=\"submit\" value=\"submit\" /></form>\n</body>\n</html>\n    END\n\n    Mechanize::Page.new uri, nil, html, 200, agent\n  end\n\n  ##\n  # Is the Encoding constant defined?\n\n  def have_encoding?\n    Object.const_defined? :Encoding\n  end\n\n  ##\n  # Creates a Mechanize::Page with the given +body+\n\n  def html_page body\n    uri = URI 'http://example/'\n    Mechanize::Page.new uri, nil, body, 200, @mech\n  end\n\n  ##\n  # Creates a Mechanize::CookieJar by parsing the given +str+\n\n  def cookie_jar str, uri = URI('http://example')\n    jar = Mechanize::CookieJar.new\n\n    jar.parse str, uri\n\n    jar\n  end\n\n  ##\n  # Runs the block inside a temporary directory\n\n  def in_tmpdir\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        yield\n      end\n    end\n  end\n\n  ##\n  # Creates a Nokogiri Node +element+ with the given +attributes+\n\n  def node element, attributes = {}\n    doc = Nokogiri::HTML::Document.new\n\n    node = Nokogiri::XML::Node.new element, doc\n\n    attributes.each do |name, value|\n      node[name] = value\n    end\n\n    node\n  end\n\n  ##\n  # Creates a Mechanize::Page for the given +uri+ with the given\n  # +content_type+, response +body+ and HTTP status +code+\n\n  def page uri, content_type = 'text/html', body = '', code = 200\n    uri = URI uri unless URI::Generic === uri\n\n    Mechanize::Page.new(uri, { 'content-type' => content_type }, body, code,\n                        @mech)\n  end\n\n  ##\n  # Requests made during this tests\n\n  def requests\n    REQUESTS\n  end\n\n  ##\n  # An SSL private key.  This key is the same across all test runs\n\n  def ssl_private_key\n    @ssl_private_key ||= OpenSSL::PKey::RSA.new <<-KEY\n-----BEGIN RSA PRIVATE KEY-----\nMIG7AgEAAkEA8pmEfmP0Ibir91x6pbts4JmmsVZd3xvD5p347EFvBCbhBW1nv1Gs\nbCBEFlSiT1q2qvxGb5IlbrfdhdgyqdTXUQIBAQIBAQIhAPumXslvf6YasXa1hni3\np80joKOug2UUgqOLD2GUSO//AiEA9ssY6AFxjHWuwo/+/rkLmkfO2s1Lz3OeUEWq\n6DiHOK8CAQECAQECIQDt8bc4vS6wh9VXApNSKIpVygtxSFe/IwLeX26n77j6Qg==\n-----END RSA PRIVATE KEY-----\n    KEY\n  end\n\n  ##\n  # An X509 certificate.  This certificate is the same across all test runs\n\n  def ssl_certificate\n    @ssl_certificate ||= OpenSSL::X509::Certificate.new <<-CERT\n-----BEGIN CERTIFICATE-----\nMIIBQjCB7aADAgECAgEAMA0GCSqGSIb3DQEBBQUAMCoxDzANBgNVBAMMBm5vYm9k\neTEXMBUGCgmSJomT8ixkARkWB2V4YW1wbGUwIBcNMTExMTAzMjEwODU5WhgPOTk5\nOTEyMzExMjU5NTlaMCoxDzANBgNVBAMMBm5vYm9keTEXMBUGCgmSJomT8ixkARkW\nB2V4YW1wbGUwWjANBgkqhkiG9w0BAQEFAANJADBGAkEA8pmEfmP0Ibir91x6pbts\n4JmmsVZd3xvD5p347EFvBCbhBW1nv1GsbCBEFlSiT1q2qvxGb5IlbrfdhdgyqdTX\nUQIBATANBgkqhkiG9w0BAQUFAANBAAAB////////////////////////////////\n//8AMCEwCQYFKw4DAhoFAAQUePiv+QrJxyjtEJNnH5pB9OTWIqA=\n-----END CERTIFICATE-----\n    CERT\n  end\n\n  ##\n  # Creates a Tempfile with +content+ that is immediately unlinked\n\n  def tempfile content\n    body_io = Tempfile.new @NAME\n    body_io.unlink\n    body_io.write content\n    body_io.flush\n    body_io.rewind\n\n    body_io\n  end\n\nend\n\nrequire 'mechanize/test_case/servlets'\n\nmodule Net # :nodoc:\nend\n\nclass Net::HTTP # :nodoc:\n  alias :old_do_start :do_start\n\n  def do_start\n    @started = true\n  end\n\n  PAGE_CACHE = {}\n\n  alias :old_request :request\n\n  def request(req, *data, &block)\n    url = URI.parse(req.path)\n    path = WEBrick::HTTPUtils.unescape(url.path)\n\n    path = '/index.html' if path == '/'\n\n    res = ::Response.new\n    res.query_params = url.query\n\n    req.query = if 'POST' != req.method && url.query then\n                  WEBrick::HTTPUtils.parse_query url.query\n                elsif req['content-type'] =~ /www-form-urlencoded/ then\n                  WEBrick::HTTPUtils.parse_query req.body\n                elsif req['content-type'] =~ /boundary=(.+)/ then\n                  boundary = WEBrick::HTTPUtils.dequote $1\n                  WEBrick::HTTPUtils.parse_form_data req.body, boundary\n                else\n                  {}\n                end\n\n    req.cookies = WEBrick::Cookie.parse(req['Cookie'])\n\n    Mechanize::TestCase::REQUESTS << req\n\n    if servlet_klass = MECHANIZE_TEST_CASE_SERVLETS[path]\n      servlet = servlet_klass.new({})\n      servlet.send \"do_#{req.method}\", req, res\n    else\n      filename = \"htdocs#{path.gsub(/[^\\/\\\\.\\w\\s]/, '_')}\"\n      unless PAGE_CACHE[filename]\n        open(\"#{Mechanize::TestCase::TEST_DIR}/#{filename}\", 'rb') { |io|\n          PAGE_CACHE[filename] = io.read\n        }\n      end\n\n      res.body = PAGE_CACHE[filename]\n      case filename\n      when /\\.txt$/\n        res['Content-Type'] = 'text/plain'\n      when /\\.jpg$/\n        res['Content-Type'] = 'image/jpeg'\n      end\n    end\n\n    res['Content-Type'] ||= 'text/html'\n    res.code ||= \"200\"\n\n    response_klass = Net::HTTPResponse::CODE_TO_OBJ[res.code.to_s]\n    response = response_klass.new res.http_version, res.code, res.message\n\n    res.header.each do |k,v|\n      v = v.first if v.length == 1\n      response[k] = v\n    end\n\n    res.cookies.each do |cookie|\n      response.add_field 'Set-Cookie', cookie.to_s\n    end\n\n    response['Content-Type'] ||= 'text/html'\n    response['Content-Length'] = res['Content-Length'] || res.body.length.to_s\n\n    io = StringIO.new(res.body)\n    response.instance_variable_set :@socket, io\n    def io.read clen, dest = nil, _ = nil\n      if dest then\n        dest << super(clen)\n      else\n        super clen\n      end\n    end\n\n    body_exist = req.response_body_permitted? &&\n      response_klass.body_permitted?\n\n    response.instance_variable_set :@body_exist, body_exist\n\n    yield response if block_given?\n\n    response\n  end\nend\n\nclass Net::HTTPRequest # :nodoc:\n  attr_accessor :query, :body, :cookies, :user\n\n  def host\n    'example'\n  end\n\n  def port\n    80\n  end\nend\n\nclass Response # :nodoc:\n  include Net::HTTPHeader\n\n  attr_reader :code\n  attr_accessor :body, :query, :cookies\n  attr_accessor :query_params, :http_version\n  attr_accessor :header\n\n  def code=(c)\n    @code = c.to_s\n  end\n\n  alias :status :code\n  alias :status= :code=\n\n    def initialize\n      @header = {}\n      @body = ''\n      @code = nil\n      @query = nil\n      @cookies = []\n      @http_version = '1.1'\n    end\n\n  def read_body\n    yield body\n  end\n\n  def message\n    ''\n  end\nend\n\n", "require 'stringio'\nrequire 'zlib'\n\nclass GzipServlet < WEBrick::HTTPServlet::AbstractServlet\n\n  TEST_DIR = File.expand_path '../../../../test', __FILE__\n\n  def do_GET(req, res)\n    if req['Accept-Encoding'] !~ /gzip/ then\n      res.code = 400\n      res.body = 'Content-Encoding: gzip is not supported by your user-agent'\n      return\n    end\n\n    if name = req.query['file'] then\n      open \"#{TEST_DIR}/htdocs/#{name}\" do |io|\n        string = String.new\n        zipped = StringIO.new string, 'w'\n        Zlib::GzipWriter.wrap zipped do |gz|\n          gz.write io.read\n        end\n        res.body = string\n      end\n    else\n      res.body = String.new\n    end\n\n    res['Content-Encoding'] = req['X-ResponseContentEncoding'] || 'gzip'\n    res['Content-Type'] = \"text/html\"\n  end\nend\n\n", "class VerbServlet < WEBrick::HTTPServlet::AbstractServlet\n  %w[HEAD GET POST PUT DELETE].each do |verb|\n    eval <<-METHOD\n      def do_#{verb}(req, res)\n        res.header['X-Request-Method'] = #{verb.dump}\n        res.body = #{verb.dump}\n      end\n    METHOD\n  end\nend\n\n", "# coding: utf-8\n\nrequire 'mechanize/test_case'\n\nclass TestMechanize < Mechanize::TestCase\n\n  def setup\n    super\n\n    @uri = URI 'http://example/'\n    @req = Net::HTTP::Get.new '/'\n\n    @res = Net::HTTPOK.allocate\n    @res.instance_variable_set :@code, 200\n    @res.instance_variable_set :@header, {}\n  end\n\n  def test_back\n    0.upto(5) do |i|\n      assert_equal(i, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n    @mech.get(\"http://localhost/form_test.html\")\n\n    assert_equal(\"http://localhost/form_test.html\",\n      @mech.history.last.uri.to_s)\n    assert_equal(\"http://localhost/\",\n      @mech.history[-2].uri.to_s)\n\n    assert_equal(7, @mech.history.size)\n    @mech.back\n    assert_equal(6, @mech.history.size)\n    assert_equal(\"http://localhost/\",\n      @mech.history.last.uri.to_s)\n  end\n\n  def test_basic_auth\n    _, err = capture_io do\n      @mech.basic_auth 'user', 'pass' # warns\n    end\n\n    line = __LINE__ - 3\n    file = File.basename __FILE__\n\n    assert_match \"#{file} line #{line}\", err\n\n    page = @mech.get @uri + '/basic_auth'\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_cert_key_file\n    in_tmpdir do\n      open 'key.pem', 'w'  do |io| io.write ssl_private_key.to_pem end\n      open 'cert.pem', 'w' do |io| io.write ssl_certificate.to_pem end\n\n      mech = Mechanize.new do |a|\n        a.cert = 'cert.pem'\n        a.key  = 'key.pem'\n      end\n\n      # Certificate#== seems broken\n      assert_equal ssl_certificate.to_pem, mech.certificate.to_pem\n    end\n  end\n\n  def test_cert_key_object\n    mech = Mechanize.new do |a|\n      a.cert = ssl_certificate\n      a.key  = ssl_private_key\n    end\n\n    assert_equal ssl_certificate, mech.certificate\n    assert_equal ssl_certificate, mech.cert\n    assert_equal ssl_private_key, mech.key\n  end\n\n  def test_cert_store\n    assert_nil @mech.cert_store\n\n    store = OpenSSL::X509::Store.new\n    @mech.cert_store = store\n\n    assert_equal store, @mech.cert_store\n  end\n\n  def test_click\n    @mech.user_agent_alias = 'Mac Safari'\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = page.link_with(:text => \"Form Test\")\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end unless RUBY_ENGINE == 'jruby'  # NekoHTML does not parse body of NOFRAMES\n\n  def test_click_bogus_link_with_cookies\n    @mech.cookie_jar = cookie_jar(\"a=b\")\n\n    page = html_page <<-BODY\n<a href=\"http:///index.html\">yes really</a>\n    BODY\n\n    page.links[0].click\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_image_button\n    page = @mech.get(\"http://localhost/form_test.html\")\n    get_form = page.forms.find { |f| f.name == \"get_form1\" }\n    image_button = get_form.buttons.first\n    new_page = @mech.click(image_button)\n    assert_equal \"http://localhost/form_post?first_name=&button.x=0&button.y=0\", new_page.uri.to_s\n  end\n\n  def test_click_submit_button\n    page = @mech.get(\"http://localhost/form_test.html\")\n    get_form = page.forms.find { |f| f.name == \"get_form1\" }\n    submit_button = get_form.submits.first\n    new_page = @mech.click(submit_button)\n    assert_equal \"http://localhost/form_post?first_name=\", new_page.uri.to_s\n  end\n\n  def test_click_frame\n    frame = node 'frame', 'src' => '/index.html'\n    frame = Mechanize::Page::Frame.new frame, @mech, fake_page\n\n    @mech.click frame\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_frame_hpricot_style\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = (page/\"//frame[@name='frame2']\").first\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end\n\n  def test_click_hpricot_style # HACK move to test_divide in Page\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = (page/\"//a[@class='bar']\").first\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end unless RUBY_ENGINE == 'jruby'  # NekoHTML does not parse body of NOFRAMES\n\n  def test_click_link\n    link = node 'a', 'href' => '/index.html'\n    link = Mechanize::Page::Link.new link, @mech, fake_page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n    assert_equal 'http://fake.example/', requests.first['Referer']\n  end\n\n  def test_click_link_nofollow\n    page = html_page <<-BODY\n<meta name=\"ROBOTS\" content=\"nofollow\">\n\n<p>Do not follow <a href=\"/index.html\">this</a> or <a href=\"/\">this</a>!\n    BODY\n\n    page.links[0].click\n    page.links[1].click\n\n    @mech.robots = true\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[0].click\n    end\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[1].click\n    end\n  end\n\n  def test_click_link_noreferrer\n    link = node 'a', 'href' => '/index.html', 'rel' => 'noreferrer'\n    link = Mechanize::Page::Link.new link, @mech, fake_page\n\n    @mech.click link\n\n    assert_nil requests.first['referer']\n  end\n\n  def test_click_link_rel_nofollow\n    page = html_page <<-BODY\n<p>You can follow <a href=\"/index.html\">this link</a>\nbut not <a href=\"/\" rel=\"me nofollow\">this</a>!\n    BODY\n\n    page.links[0].click\n    page.links[1].click\n\n    @mech.robots = true\n\n    page.links[0].click\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[1].click\n    end\n  end\n\n  def test_click_link_parent\n    page = page URI 'http://example/a/index.html'\n    link = node 'a', 'href' => '../index.html'\n    link = Mechanize::Page::Link.new link, @mech, page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_link_parent_extra\n    page = page URI 'http://example/a/index.html'\n    link = node 'a', 'href' => '../../index.html'\n    link = Mechanize::Page::Link.new link, @mech, page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_link_hpricot_style # HACK move to test_search in Page\n    page = @mech.get(\"http://localhost/tc_encoded_links.html\")\n\n    page = @mech.click(page.search('a').first)\n\n    assert_equal(\"http://localhost/form_post?a=b&b=c\", page.uri.to_s)\n  end\n\n  def test_click_link_query\n    page = @mech.get(\"http://localhost/tc_encoded_links.html\")\n    link = page.links.first\n    assert_equal('/form_post?a=b&b=c', link.href)\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_post?a=b&b=c\", page.uri.to_s)\n  end\n\n  def test_click_link_space\n    page = @mech.get(\"http://localhost/tc_bad_links.html\")\n\n    @mech.click page.links.first\n\n    assert_match(/alt_text.html$/, @mech.history.last.uri.to_s)\n    assert_equal(2, @mech.history.length)\n  end\n\n  def test_click_more\n    @mech.get 'http://localhost/test_click.html'\n    @mech.click 'A Button'\n    assert_equal 'http://localhost/frame_test.html?words=nil',\n      @mech.page.uri.to_s\n    @mech.back\n    @mech.click 'A Link'\n    assert_equal 'http://localhost/index.html',\n      @mech.page.uri.to_s\n    @mech.back\n    @mech.click @mech.page.link_with(:text => 'A Link')\n    assert_equal 'http://localhost/index.html',\n      @mech.page.uri.to_s\n  end\n\n  def test_cookies\n    uri = URI 'http://example'\n    jar = HTTP::CookieJar.new\n    jar.parse 'a=b', uri\n\n    @mech.cookie_jar = jar\n\n    refute_empty @mech.cookies\n  end\n\n  def test_cookie_jar\n    assert_kind_of Mechanize::CookieJar, @mech.cookie_jar\n\n    jar = HTTP::CookieJar.new\n\n    @mech.cookie_jar = jar\n\n    assert_equal jar, @mech.cookie_jar\n  end\n\n  def test_delete\n    page = @mech.delete('http://localhost/verb', { 'q' => 'foo' })\n    assert_equal 1, @mech.history.length\n    assert_equal 'DELETE', page.header['X-Request-Method']\n  end\n\n  def test_delete_redirect\n    page = @mech.delete('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_download\n    page = nil\n\n    in_tmpdir do\n      open 'download', 'w' do |io|\n        page = @mech.download 'http://example', io\n\n        refute io.closed?\n      end\n\n      assert_operator 1, :<=, File.stat('download').size\n    end\n\n    assert_empty @mech.history\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_download_filename\n    page = nil\n\n    in_tmpdir do\n      page = @mech.download 'http://example', 'download'\n\n      assert_operator 1, :<=, File.stat('download').size\n    end\n\n    assert_empty @mech.history\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_download_filename_error\n    in_tmpdir do\n      assert_raises Mechanize::UnauthorizedError do\n        @mech.download 'http://example/digest_auth', 'download'\n      end\n\n      refute File.exist? 'download'\n    end\n  end\n\n  def test_get\n    uri = URI 'http://localhost'\n\n    page = @mech.get uri, { :q => 'h' }, 'http://example', { 'X-H' => 'v' }\n\n    assert_equal URI('http://localhost/?q=h'), page.uri\n    assert_equal URI('http://localhost'), uri\n  end\n\n  def test_get_HTTP\n    page = @mech.get('HTTP://localhost/', { :q => 'hello' })\n\n    assert_kind_of URI::HTTP, page.uri\n    assert_equal 'localhost', page.uri.host\n    assert_equal 80,          page.uri.port\n    assert_equal '/?q=hello', page.uri.request_uri\n  end\n\n  def test_get_anchor\n    page = @mech.get('http://localhost/?foo=bar&#34;')\n    assert_equal('http://localhost/?foo=bar%22', page.uri.to_s)\n  end\n\n  def test_get_bad_url\n    assert_raises ArgumentError do\n      @mech.get '/foo.html'\n    end\n  end\n\n  def test_get_auth\n    @mech.add_auth @uri, 'user', 'pass'\n\n    page = @mech.get @uri + '/basic_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_auth_bad\n    @mech.add_auth(@uri, 'aaron', 'aaron')\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @mech.get(@uri + '/basic_auth')\n    end\n\n    assert_equal(\"401\", e.response_code)\n  end\n\n  def test_get_auth_none\n    e = assert_raises Mechanize::UnauthorizedError do\n      @mech.get(@uri + '/basic_auth')\n    end\n\n    assert_equal(\"401\", e.response_code)\n  end\n\n  def test_get_auth_realm\n    @mech.add_auth @uri, 'user', 'pass', 'Blah'\n\n    page = @mech.get @uri + '/basic_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_conditional\n    assert_empty @mech.history\n\n    page = @mech.get 'http://localhost/if_modified_since'\n    assert_match(/You did not send/, page.body)\n\n    assert_equal 1, @mech.history.length\n    page2 = @mech.get 'http://localhost/if_modified_since'\n\n    assert_equal 2, @mech.history.length\n    assert_equal page.object_id, page2.object_id\n  end\n\n  def test_get_digest_auth\n    @mech.add_auth @uri, 'user', 'pass'\n\n    page = @mech.get @uri + '/digest_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_follow_meta_refresh\n    @mech.follow_meta_refresh = true\n\n    page = @mech.get('http://localhost/tc_follow_meta.html')\n\n    assert_equal(2, @mech.history.length)\n\n    assert_equal('http://localhost/tc_follow_meta.html',\n                 @mech.history.first.uri.to_s)\n    assert_equal('http://localhost/index.html', page.uri.to_s)\n    assert_equal('http://localhost/index.html', @mech.history.last.uri.to_s)\n\n    [5, 6].each { |limit|\n      @mech.redirection_limit = limit\n      begin\n        @mech.get('http://localhost/tc_follow_meta_loop_1.html')\n      rescue => e\n        assert_instance_of Mechanize::RedirectLimitReachedError, e\n        assert_equal limit, e.redirects\n        if limit % 2 == 0\n          assert_equal '/tc_follow_meta_loop_1.html', e.page.uri.path\n        else\n          assert_equal '/tc_follow_meta_loop_2.html', e.page.uri.path\n        end\n      end\n    }\n  end\n\n  def test_get_follow_meta_refresh_anywhere\n    @mech.follow_meta_refresh = :anywhere\n\n    @mech.get('http://localhost/tc_meta_in_body.html')\n    assert_equal 2, requests.length\n  end\n\n  def test_get_follow_meta_refresh_disabled\n    page = @mech.get('http://localhost/tc_follow_meta.html')\n    assert_equal('http://localhost/tc_follow_meta.html', page.uri.to_s)\n    assert_equal(1, page.meta_refresh.length)\n  end\n\n  def test_get_follow_meta_refresh_empty_url\n    @mech.follow_meta_refresh = true\n    @mech.follow_meta_refresh_self = true\n\n    page = @mech.get('http://example/refresh_with_empty_url')\n\n    assert_equal(3, @mech.history.length)\n    assert_equal('http://example/refresh_with_empty_url',\n                 @mech.history[0].uri.to_s)\n    assert_equal('http://example/refresh_with_empty_url',\n                 @mech.history[1].uri.to_s)\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal('http://example/', @mech.history.last.uri.to_s)\n  end\n\n  def test_get_follow_meta_refresh_in_body\n    @mech.follow_meta_refresh = true\n\n    @mech.get('http://localhost/tc_meta_in_body.html')\n    assert_equal 1, requests.length\n  end\n\n  def test_get_follow_meta_refresh_no_url\n    @mech.follow_meta_refresh = true\n    @mech.follow_meta_refresh_self = true\n\n    page = @mech.get('http://example/refresh_without_url')\n\n    assert_equal(3, @mech.history.length)\n    assert_equal('http://example/refresh_without_url',\n                 @mech.history[0].uri.to_s)\n    assert_equal('http://example/refresh_without_url',\n                 @mech.history[1].uri.to_s)\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal('http://example/', @mech.history.last.uri.to_s)\n  end\n\n  def test_get_follow_meta_refresh_referer_not_sent\n    @mech.follow_meta_refresh = true\n\n    @mech.get('http://localhost/tc_follow_meta.html')\n\n    assert_equal 2, @mech.history.length\n    assert_nil requests.last['referer']\n  end\n\n  def test_get_referer_download\n    download = Mechanize::Download.new URI 'http://example/prev'\n\n    uri = URI 'http://example'\n\n    page = @mech.get uri, { :q => 'h' }, download, { 'X-H' => 'v' }\n\n    assert_equal URI('http://example/?q=h'), page.uri\n    assert_equal URI('http://example'), uri\n\n    assert_equal 'http://example/prev', requests.first['referer']\n  end\n\n  def test_get_robots\n    @mech.robots = true\n\n    assert_equal \"Page Title\", @mech.get(\"http://localhost/index.html\").title\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @mech.get \"http://localhost/norobots.html\"\n    end\n  end\n\n  def test_follow_meta_refresh_self\n    refute @mech.agent.follow_meta_refresh_self\n\n    @mech.follow_meta_refresh_self = true\n\n    assert @mech.agent.follow_meta_refresh_self\n  end\n\n  def test_get_gzip\n    page = @mech.get(\"http://localhost/gzip?file=index.html\")\n\n    assert_kind_of(Mechanize::Page, page)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def test_content_encoding_hooks_header\n    h = {'X-ResponseContentEncoding' => 'agzip'}\n\n    # test of X-ResponseContentEncoding feature\n    assert_raises(Mechanize::Error, 'Unsupported Content-Encoding: agzip') do\n      @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n    end\n\n    @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      response['content-encoding'] = 'gzip' if response['content-encoding'] == 'agzip'}\n\n    page = @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def external_cmd(io); Zlib::GzipReader.new(io).read; end\n\n  def test_content_encoding_hooks_body_io\n    h = {'X-ResponseContentEncoding' => 'unsupported_content_encoding'}\n\n   @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      if response['content-encoding'] == 'unsupported_content_encoding'\n        response['content-encoding'] = 'none'\n        response_body_io.string = external_cmd(response_body_io)\n      end}\n\n    page = @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def test_get_http_refresh\n    @mech.follow_meta_refresh = true\n\n    page = @mech.get('http://example/http_refresh?refresh_time=0')\n\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal(2, @mech.history.length)\n    assert_nil requests.last['referer']\n  end\n\n  def test_get_http_refresh_delay\n    @mech.follow_meta_refresh = true\n    class << @mech.agent\n      attr_accessor :slept\n      def sleep *args\n        @slept = args\n      end\n    end\n\n    @mech.get('http://localhost/http_refresh?refresh_time=1')\n    assert_equal [1], @mech.agent.slept\n  end\n\n  def test_get_http_refresh_disabled\n    page = @mech.get('http://localhost/http_refresh?refresh_time=0')\n    assert_equal('http://localhost/http_refresh?refresh_time=0', page.uri.to_s)\n  end\n\n  def test_get_query\n    page = @mech.get('http://localhost/', { :q => 'hello' })\n    assert_equal('http://localhost/?q=hello', page.uri.to_s)\n\n    page = @mech.get('http://localhost/', { :q => %w[hello world]})\n    assert_equal('http://localhost/?q=hello&q=world', page.uri.to_s)\n\n    page = @mech.get('http://localhost/', { :paging => { start: 1, limit: 25 } })\n    assert_equal('http://localhost/?paging%5Bstart%5D=1&paging%5Blimit%5D=25', page.uri.to_s)\n  end\n\n  def test_get_redirect\n    page = @mech.get('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_get_redirect_found\n    page = @mech.get('http://localhost/response_code?code=302&ct=test/xml')\n\n    assert_equal('http://localhost/index.html', page.uri.to_s)\n\n    assert_equal(2, @mech.history.length)\n  end\n\n  def test_get_redirect_infinite\n    assert_raises(Mechanize::RedirectLimitReachedError) {\n      @mech.get('http://localhost/infinite_refresh')\n    }\n  end\n\n  def test_get_referer\n    request = nil\n    @mech.pre_connect_hooks << lambda { |_, req|\n      request = req\n    }\n\n    @mech.get('http://localhost/', [], 'http://tenderlovemaking.com/')\n    assert_equal 'http://tenderlovemaking.com/', request['Referer']\n  end\n\n  def test_get_referer_file\n    uri = URI 'http://tenderlovemaking.com/crossdomain.xml'\n    file = Mechanize::File.new uri\n\n    @mech.get('http://localhost', [], file)\n\n    # HACK no assertion of behavior\n  end\n\n  def test_get_referer_none\n    @mech.get('http://localhost/')\n    @mech.get('http://localhost/')\n    assert_equal(2, requests.length)\n    requests.each do |request|\n      assert_nil request['referer']\n    end\n  end\n\n  def test_get_scheme_unsupported\n    assert_raises Mechanize::UnsupportedSchemeError do\n      begin\n        @mech.get('ftp://server.com/foo.html')\n      rescue Mechanize::UnsupportedSchemeError => error\n        assert_equal 'ftp', error.scheme\n        assert_equal 'ftp://server.com/foo.html', error.uri.to_s\n        raise\n      end\n    end\n  end\n\n  def test_get_space\n    @mech.get(\"http://localhost/tc_bad_links.html \")\n\n    assert_match(/tc_bad_links.html$/, @mech.history.last.uri.to_s)\n\n    assert_equal(1, @mech.history.length)\n  end\n\n  def test_get_tilde\n    page = @mech.get('http://localhost/?foo=~2')\n\n    assert_equal('http://localhost/?foo=~2', page.uri.to_s)\n  end\n\n  def test_get_weird\n    @mech.get('http://localhost/?action=bing&bang=boom=1|a=|b=|c=')\n    @mech.get('http://localhost/?a=b&#038;b=c&#038;c=d')\n    @mech.get(\"http://localhost/?a=#{[0xd6].pack('U')}\")\n\n    # HACK no assertion of behavior\n  end\n\n  def test_get_yield\n    pages = nil\n\n    @mech.get(\"http://localhost/file_upload.html\") { |page|\n      pages = page\n    }\n\n    assert pages\n    assert_equal('File Upload Form', pages.title)\n  end\n\n  def test_get_file\n    body = @mech.get_file 'http://localhost/frame_test.html'\n\n    assert_kind_of String, body\n    refute_empty body\n  end\n\n  def test_get_file_download\n    # non-Mechanize::File\n    body = @mech.get_file 'http://localhost/button.jpg'\n\n    assert_kind_of String, body\n    refute_empty body\n  end\n\n  def test_head\n    page = @mech.head('http://localhost/verb', { 'q' => 'foo' })\n    assert_equal 0, @mech.history.length\n    assert_equal 'HEAD', page.header['X-Request-Method']\n  end\n\n  def test_head_redirect\n    page = @mech.head('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'HEAD', page.header['X-Request-Method']\n  end\n\n  def test_history\n    2.times do |i|\n      assert_equal(i, @mech.history.size)\n\n      @mech.get(\"http://localhost/\")\n    end\n\n    page = @mech.get(\"http://localhost/form_test.html\")\n\n    assert_equal(\"http://localhost/form_test.html\",\n      @mech.history.last.uri.to_s)\n    assert_equal(\"http://localhost/\",\n      @mech.history[-2].uri.to_s)\n\n    assert @mech.visited?(\"http://localhost/\")\n    assert @mech.visited?(\"/form_test.html\"), 'relative'\n    assert !@mech.visited?(\"http://google.com/\")\n    assert @mech.visited?(page.links.first)\n  end\n\n  def test_history_added_gets_called\n    added_page = nil\n\n    @mech.history_added = lambda { |page|\n      added_page = page\n    }\n\n    assert_equal @mech.get('http://localhost/tc_blank_form.html'), added_page\n  end\n\n  def test_history_order\n    @mech.max_history = 2\n    assert_equal(0, @mech.history.length)\n\n    @mech.get('http://localhost/form_test.html')\n    assert_equal(1, @mech.history.length)\n\n    @mech.get('http://localhost/empty_form.html')\n    assert_equal(2, @mech.history.length)\n\n    @mech.get('http://localhost/tc_checkboxes.html')\n    assert_equal(2, @mech.history.length)\n    assert_equal('http://localhost/empty_form.html', @mech.history[0].uri.to_s)\n    assert_equal('http://localhost/tc_checkboxes.html',\n                 @mech.history[1].uri.to_s)\n  end\n\n  def test_initialize\n    mech = Mechanize.new\n\n    assert_equal 50, mech.max_history\n  end\n\n  def test_html_parser_equals\n    @mech.html_parser = {}\n    assert_raises(NoMethodError) {\n      @mech.get('http://localhost/?foo=~2').links\n    }\n  end\n\n  def test_idle_timeout_default\n    assert_equal 5, Mechanize.new.idle_timeout\n  end\n\n  def test_idle_timeout_equals\n    @mech.idle_timeout = 15\n\n    assert_equal 15, @mech.idle_timeout\n  end\n\n  def test_keep_alive_equals\n    assert @mech.keep_alive\n\n    @mech.keep_alive = false\n\n    refute @mech.keep_alive\n  end\n\n  def test_keep_alive_time\n    assert_equal 0, @mech.keep_alive_time\n\n    @mech.keep_alive_time = 1\n\n    assert_equal 1, @mech.keep_alive_time\n  end\n\n  def test_log\n    assert_nil @mech.log\n  end\n\n  def test_log_equals\n    @mech.log = Logger.new $stderr\n\n    refute_nil @mech.log\n    assert_nil Mechanize.log\n  end\n\n  def test_max_file_buffer_equals\n    @mech.max_file_buffer = 1024\n\n    assert_equal 1024, @mech.agent.max_file_buffer\n  end\n\n  def test_max_history_equals\n    @mech.max_history = 10\n    0.upto(10) do |i|\n      assert_equal(i, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n\n    0.upto(10) do |i|\n      assert_equal(10, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n  end\n\n  def test_open_timeout_equals\n    @mech.open_timeout = 5\n\n    assert_equal 5, @mech.open_timeout\n  end\n\n  def test_parse_download\n    @mech.pluggable_parser['application/octet-stream'] = Mechanize::Download\n\n    response = Net::HTTPOK.allocate\n    response.instance_variable_set(:@header,\n                                   'content-type' =>\n                                     ['application/octet-stream'])\n\n    download = @mech.parse @uri, response, StringIO.new('raw')\n\n    assert_kind_of Mechanize::Download, download\n    assert_kind_of StringIO, download.content\n  end\n\n  def test_parse_html\n    response = Net::HTTPOK.allocate\n    response.instance_variable_set :@header, 'content-type' => ['text/html']\n\n    page = @mech.parse URI('http://example/'), response, ''\n\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_post\n    @mech.post \"http://example\", 'gender' => 'female'\n\n    assert_equal \"gender=female\", requests.first.body\n  end\n\n  def test_post_auth\n    requests = []\n\n    @mech.pre_connect_hooks << proc { |agent, request|\n      requests << request.class\n    }\n\n    @mech.add_auth(@uri, 'user', 'pass')\n    page = @mech.post(@uri + '/basic_auth')\n    assert_equal('You are authenticated', page.body)\n    assert_equal(2, requests.length)\n    r1 = requests[0]\n    r2 = requests[1]\n    assert_equal(r1, r2)\n  end\n\n  def test_post_entity\n    @mech.post \"http://localhost/form_post\", 'json' => '[\"&quot;\"]'\n\n    assert_equal \"json=%5B%22%22%22%5D\", requests.first.body\n  end\n\n  def test_post_multiple_values\n    @mech.post \"http://localhost/form_post\",\n                      [%w[gender female], %w[gender male]]\n\n    assert_equal \"gender=female&gender=male\", requests.first.body\n  end\n\n  def test_post_multipart\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => File.open(__FILE__)\n    })\n\n    name = File.basename __FILE__\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\",\n      page.body\n    )\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_file_upload_nonascii\n    name = '\u30e6\u30fc\u30b6\u30d5\u30a1\u30a4\u30eb1'\n    file_upload = Mechanize::Form::FileUpload.new({'name' => 'userfile1'}, name)\n    file_upload.file_data = File.read(__FILE__)\n    file_upload.mime_type = 'application/zip'\n\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => file_upload\n    })\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\".force_encoding(Encoding::ASCII_8BIT),\n      page.body\n    )\n    assert_match(\"Content-Type: application/zip\", page.body)\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_file_upload\n    name = File.basename(__FILE__)\n    file_upload = Mechanize::Form::FileUpload.new({'name' => 'userfile1'}, name)\n    file_upload.file_data = File.read(__FILE__)\n    file_upload.mime_type = 'application/zip'\n\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => file_upload\n    })\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\",\n      page.body\n    )\n    assert_match(\"Content-Type: application/zip\", page.body)\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_redirect\n    page = @mech.post('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_put\n    page = @mech.put('http://localhost/verb', 'foo')\n    assert_equal 1, @mech.history.length\n    assert_equal 'PUT', page.header['X-Request-Method']\n  end\n\n  def test_put_redirect\n    page = @mech.put('http://localhost/redirect', 'foo')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_read_timeout_equals\n    @mech.read_timeout = 5\n\n    assert_equal 5, @mech.read_timeout\n  end\n\n  def test_timeouts_for_file_connection\n    uri = URI.parse \"file://#{File.expand_path __FILE__}\"\n    @mech.read_timeout = 5\n    @mech.open_timeout = 5\n    assert @mech.get(uri)\n  end\n\n  def test_referer\n    host_path = \"localhost/tc_referer.html?t=1\"\n    ['http', 'https'].each { |proto|\n      referer = \"#{proto}://#{host_path}\"\n      [\n        \"\",\n\t\"@\",\n\t\"user1@\",\n\t\":@\",\n\t\"user1:@\",\n\t\":password1@\",\n\t\"user1:password1@\",\n      ].each { |userinfo|\n        url = \"#{proto}://#{userinfo}#{host_path}\"\n        [url, url + \"#foo\"].each { |furl|\n          [\n            ['relative',\t\ttrue],\n            ['insecure',\t\tproto == 'http'],\n            ['secure',\t\t\ttrue],\n            ['relative noreferrer',\tfalse],\n            ['insecure noreferrer',\tfalse],\n            ['secure noreferrer',\tfalse],\n          ].each_with_index { |(type, bool), i|\n            rpage = @mech.get(furl)\n            page = rpage.links[i].click\n            assert_equal bool ? referer : '', page.body, \"%s link from %s\" % [type, furl]\n          }\n\n          rpage = @mech.get(furl)\n          page = rpage.forms.first.submit\n          assert_equal referer, page.body, \"post from %s\" % furl\n        }\n      }\n    }\n  end\n\n  def test_retry_change_requests_equals\n    unless Gem::Requirement.new(\"< 4.0.0\").satisfied_by?(Gem::Version.new(Net::HTTP::Persistent::VERSION))\n      # see https://github.com/drbrain/net-http-persistent/pull/100\n      skip(\"net-http-persistent 4.0.0 and later does not support retry_change_requests\")\n    end\n\n    refute @mech.retry_change_requests\n\n    @mech.retry_change_requests = true\n\n    assert @mech.retry_change_requests\n  end\n\n  def test_set_proxy\n    http = @mech.agent.http\n\n    @mech.set_proxy 'localhost', 8080, 'user', 'pass'\n\n    assert_equal 'localhost', @mech.proxy_addr\n    assert_equal 8080,        @mech.proxy_port\n    assert_equal 'user',      @mech.proxy_user\n    assert_equal 'pass',      @mech.proxy_pass\n\n    assert_equal URI('http://user:pass@localhost:8080'), http.proxy_uri\n  end\n\n  def test_shutdown\n    uri = URI 'http://localhost'\n    jar = HTTP::CookieJar.new\n    jar.parse 'a=b', uri\n\n    @mech.cookie_jar = jar\n\n    @mech.get(\"http://localhost/\")\n\n    assert_match(/Hello World/, @mech.current_page.body)\n    refute_empty @mech.cookies\n\n    @mech.shutdown\n\n    assert_empty @mech.history\n    assert_empty @mech.cookies\n  end\n\n  def test_start\n    body = nil\n\n    Mechanize.start do |m|\n      body = m.get(\"http://localhost/\").body\n    end\n\n    assert_match(/Hello World/, body)\n  end\n\n  def test_submit_bad_form_method\n    page = @mech.get(\"http://localhost/bad_form_test.html\")\n    assert_raises ArgumentError do\n      @mech.submit(page.forms.first)\n    end\n  end\n\n  def test_submit_check_one\n    page = @mech.get('http://localhost/tc_checkboxes.html')\n    form = page.forms.first\n    form.checkboxes_with(:name => 'green')[1].check\n\n    page = @mech.submit(form)\n\n    assert_equal(1, page.links.length)\n    assert_equal('green:on', page.links.first.text)\n  end\n\n  def test_submit_check_two\n    page = @mech.get('http://localhost/tc_checkboxes.html')\n    form = page.forms.first\n    form.checkboxes_with(:name => 'green')[0].check\n    form.checkboxes_with(:name => 'green')[1].check\n\n    page = @mech.submit(form)\n\n    assert_equal(2, page.links.length)\n    assert_equal('green:on', page.links[0].text)\n    assert_equal('green:on', page.links[1].text)\n  end\n\n  def test_submit_enctype\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[0].enctype)\n\n    form = page.forms.first\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.mime_type = \"text/plain\"\n    form.file_uploads.first.file_data = \"Hello World\\n\\n\"\n\n    page = @mech.submit(form)\n\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"name\\\"\",\n      page.body\n    )\n    assert_match('Content-Type: text/plain', page.body)\n    assert_match('Hello World', page.body)\n    assert_match('foo[aaron]', page.body)\n  end\n\n  def test_submit_file_data\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.file_data = File.read __FILE__\n\n    page = @mech.submit(form)\n\n    contents = File.binread __FILE__\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n\n    assert_match(contents, page.body)\n  end\n\n  def test_submit_file_name\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n\n    page = @mech.submit(form)\n\n    contents = File.binread __FILE__\n    basename = File.basename __FILE__\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n    assert_match(contents, page.body)\n  end\n\n  def test_submit_get\n    form = node 'form', 'method' => 'GET', 'action' => '/?a=b'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/', requests.first.path\n  end\n\n  def test_submit_headers\n    page = @mech.get 'http://localhost:2000/form_no_action.html'\n\n    assert form = page.forms.first\n    form.action = '/http_headers'\n\n    page = @mech.submit form, nil, 'foo' => 'bar'\n\n    headers = page.body.split(\"\\n\").map { |x| x.split('|', 2) }.flatten\n    headers = Hash[*headers]\n\n    assert_equal 'bar', headers['foo']\n  end\n\n  def test_submit_multipart\n    page = @mech.get(\"http://localhost/file_upload.html\")\n\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.mime_type = \"text/plain\"\n    form.file_uploads.first.file_data = \"Hello World\\n\\n\"\n\n    page = @mech.submit(form)\n\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n  end\n\n  def test_submit_no_file\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    form = page.forms.first\n    form.field_with(:name => 'name').value = 'Aaron'\n    @page = @mech.submit(form)\n    assert_match('Aaron', @page.body)\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"\\\"\",\n      @page.body\n    )\n  end\n\n  def test_submit_post\n    form = node 'form', 'method' => 'POST', 'action' => '/?a=b'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/?a=b', requests.first.path\n  end\n\n  def test_submit_post_pound\n    form = node 'form', 'method' => 'POST', 'action' => '/#1'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/', requests.first.path\n  end\n\n  def test_submit_too_many_radiobuttons\n    page = @mech.get(\"http://localhost/form_test.html\")\n    form = page.form_with(:name => 'post_form1')\n    form.radiobuttons.each { |r| r.checked = true }\n\n    assert_raises Mechanize::Error do\n      @mech.submit(form)\n    end\n  end\n\n  def test_transact\n    @mech.get(\"http://localhost/frame_test.html\")\n    assert_equal(1, @mech.history.length)\n    @mech.transact { |a|\n      5.times {\n        @mech.get(\"http://localhost/frame_test.html\")\n      }\n      assert_equal(6, @mech.history.length)\n    }\n    assert_equal(1, @mech.history.length)\n  end\n\n  def test_user_agent_alias_equals_unknown\n    assert_raises ArgumentError do\n      @mech.user_agent_alias = \"Aaron's Browser\"\n    end\n  end\n\n  def test_verify_mode\n    assert_equal OpenSSL::SSL::VERIFY_PEER, @mech.verify_mode\n\n    @mech.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n    assert_equal OpenSSL::SSL::VERIFY_NONE, @mech.verify_mode\n  end\n\n  def test_visited_eh\n    @mech.get(\"http://localhost/content_type_test?ct=application/pdf\")\n\n    assert \\\n      @mech.visited?(\"http://localhost/content_type_test?ct=application/pdf\")\n    assert \\\n      !@mech.visited?(\"http://localhost/content_type_test\")\n    assert \\\n      !@mech.visited?(\"http://localhost/content_type_test?ct=text/html\")\n  end\n\n  def test_visited_eh_link\n    @mech.get(\"http://example/index.html\")\n\n    page = page URI 'http://example'\n    link = node 'a', 'href' => '/index.html'\n    link = Mechanize::Page::Link.new link, page, @mech\n\n    assert @mech.visited? link\n  end\n\n  def test_visited_eh_redirect\n    @mech.get(\"http://localhost/response_code?code=302\")\n\n    assert_equal(\"http://localhost/index.html\", @mech.current_page.uri.to_s)\n\n    assert @mech.visited?('http://localhost/response_code?code=302')\n  end\n\n  def test_no_frames_exists\n    page = @mech.get(\"http://localhost/empty_form.html\");\n    assert_nil page.frame_with(:name => 'noframe')\n    assert_raises Mechanize::ElementNotFoundError do\n      page.frame_with!(:name => 'noframe')\n    end\n  end\n\n  def assert_header(page, header)\n    headers = {}\n\n    page.body.split(/[\\r\\n]+/).each do |page_header|\n      headers.[]=(*page_header.chomp.split(/\\|/))\n    end\n\n    header.each do |key, value|\n      assert(headers.has_key?(key))\n      assert_equal(value, headers[key])\n    end\n  end\nend\n", "require 'mechanize/test_case'\n\nclass TestMechanizeCookieJar < Mechanize::TestCase\n\n  def setup\n    super\n\n    @jar = Mechanize::CookieJar.new\n\n    @jar.extend Minitest::Assertions\n\n    def @jar.add(*args)\n      capture_io { super }\n    end\n\n    def @jar.jar(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n\n    def @jar.save_as(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n\n    def @jar.clear!(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n  end\n\n  def cookie_values(options = {})\n    {\n      :name     => 'Foo',\n      :value    => 'Bar',\n      :path     => '/',\n      :expires  => Time.now + (10 * 86400),\n      :for_domain => true,\n      :domain   => 'rubygems.org'\n   }.merge(options)\n  end\n\n  def test_two_cookies_same_domain_and_name_different_paths\n    url = URI 'http://rubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:path => '/onetwo')))\n\n    assert_equal(1, @jar.cookies(url).length)\n    assert_equal 2, @jar.cookies(URI('http://rubygems.org/onetwo')).length\n  end\n\n  def test_domain_case\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:domain => 'rubygems.Org', :name   => 'aaron')))\n\n    assert_equal(2, @jar.cookies(url).length)\n\n    url2 = URI 'http://rubygems.oRg/'\n    assert_equal(2, @jar.cookies(url2).length)\n  end\n\n  def test_host_only\n    url = URI.parse('http://rubygems.org/')\n\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:domain => 'rubygems.org', :for_domain => false)))\n\n    assert_equal(1, @jar.cookies(url).length)\n\n    assert_equal(1, @jar.cookies(URI('http://rubygems.org/')).length)\n\n    assert_equal(1, @jar.cookies(URI('https://rubygems.org/')).length)\n\n    assert_equal(0, @jar.cookies(URI('http://www.rubygems.org/')).length)\n  end\n\n  def test_empty_value\n    values = cookie_values(:value => \"\")\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    @jar.add url, Mechanize::Cookie.new(values.merge(:domain => 'rubygems.Org',\n                                                     :name   => 'aaron'))\n\n    assert_equal(2, @jar.cookies(url).length)\n\n    url2 = URI 'http://rubygems.oRg/'\n    assert_equal(2, @jar.cookies(url2).length)\n  end\n\n  def test_add_future_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add the same cookie, and we should still only have one\n    @jar.add(url, Mechanize::Cookie.new(cookie_values))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(1, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Make sure we can't get the cookie from different domains\n    assert_equal(0, @jar.cookies(URI('http://google.com/')).length)\n  end\n\n  def test_add_multiple_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add the same cookie, and we should still only have one\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Make sure we can't get the cookie from different domains\n    assert_equal(0, @jar.cookies(URI('http://google.com/')).length)\n  end\n\n  def test_add_rejects_cookies_that_do_not_contain_an_embedded_dot\n    url = URI 'http://rubygems.org/'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.org'))\n    @jar.add(url, tld_cookie)\n    # single dot domain is now treated as no domain\n    # single_dot_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.'))\n    # @jar.add(url, single_dot_cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_fall_back_rules_for_local_domains\n    url = URI 'http://www.example.local'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.local'))\n    @jar.add(url, tld_cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n\n    sld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.example.local'))\n    @jar.add(url, sld_cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_makes_exception_for_localhost\n    url = URI 'http://localhost'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => 'localhost'))\n    @jar.add(url, tld_cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_cookie_for_the_parent_domain\n    url = URI 'http://x.foo.com'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.foo.com'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_does_not_reject_cookies_from_a_nested_subdomain\n    url = URI 'http://y.x.foo.com'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.foo.com'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookie_without_leading_dot_does_not_cause_substring_match\n    url = URI 'http://arubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => 'rubygems.org'))\n    @jar.add(url, cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_without_leading_dot_matches_subdomains\n    url = URI 'http://admin.rubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => 'rubygems.org'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_subdomains\n    url = URI 'http://admin.rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_parent_domains\n    url = URI 'http://rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_parent_domains_exactly\n    url = URI 'http://arubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv4_address_matches_the_exact_ipaddress\n    url = URI 'http://192.168.0.1/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '192.168.0.1'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv4_address_does_not_cause_subdomain_match\n    url = URI 'http://192.168.0.1/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.0.1'))\n    @jar.add(url, cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv6_address_matches_the_exact_ipaddress\n    url = URI 'http://[fe80::0123:4567:89ab:cdef]/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '[fe80::0123:4567:89ab:cdef]'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_dot\n    url = URI 'http://www.host.example/'\n\n    @jar.add(url,\n             Mechanize::Cookie.new(cookie_values(:domain => 'www.host.example')))\n\n    url = URI 'http://wwwxhost.example/'\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_clear_bang\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    @jar.clear!\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_save_cookies_yaml\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      value = @jar.save_as(\"cookies.yml\")\n      assert_same @jar, value\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.yml\")\n      assert_equal(2, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n  def test_save_session_cookies_yaml\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.yml\", :format => :yaml, :session => true)\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.yml\")\n      assert_equal(3, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n\n  def test_save_cookies_cookiestxt\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n\n      assert_match(/\\A# (?:Netscape )?HTTP Cookie File$/, File.read(\"cookies.txt\"))\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt)\n      assert_equal(2, jar.cookies(url).length)\n    end\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt, :session => true)\n\n      assert_match(/\\A# (?:Netscape )?HTTP Cookie File$/, File.read(\"cookies.txt\"))\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt)\n      assert_equal(3, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n  def test_expire_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values( :name => 'Baz', :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_session_cookies\n    values = cookie_values(:expires => nil)\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge(:expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        values.merge(:name => 'Baz', :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n\n    # When given a URI with a blank path, CookieJar#cookies should return\n    # cookies with the path '/':\n    url = URI 'http://rubygems.org'\n    assert_equal '', url.path\n    assert_equal(0, @jar.cookies(url).length)\n    # Now add a cookie with the path set to '/':\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'has_root_path',\n                                          :path => '/')))\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_paths\n    values = cookie_values(:path => \"/login\", :expires => nil)\n    url = URI 'http://rubygems.org/login'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'Baz' )))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we don't get the cookie in a different path\n    assert_equal(0, @jar.cookies(URI('http://rubygems.org/hello')).length)\n    assert_equal(0, @jar.cookies(URI('http://rubygems.org/')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'Baz',\n                                          :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_save_and_read_cookiestxt\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n      @jar.clear!\n\n      @jar.load(\"cookies.txt\", :cookiestxt)\n    end\n\n    assert_equal(2, @jar.cookies(url).length)\n  end\n\n  def test_save_and_read_cookiestxt_with_session_cookies\n    url = URI 'http://rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:expires => nil)))\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n      @jar.clear!\n\n      @jar.load(\"cookies.txt\", :cookiestxt)\n    end\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_save_and_read_expired_cookies\n    url = URI 'http://rubygems.org/'\n\n    @jar.jar['rubygems.org'] = {}\n\n\n    @jar.add url, Mechanize::Cookie.new(cookie_values)\n\n    # HACK no asertion\n  end\n\n  def test_ssl_cookies\n    # thanks to michal \"ocher\" ochman for reporting the bug responsible for this test.\n    values = cookie_values(:expires => nil)\n    values_ssl = values.merge(:name => 'Baz', :domain => \"#{values[:domain]}:443\")\n    url = URI 'https://rubygems.org/login'\n\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length, \"did not handle SSL cookie\")\n\n    cookie = Mechanize::Cookie.new(values_ssl)\n    @jar.add(url, cookie)\n    assert_equal(2, @jar.cookies(url).length, \"did not handle SSL cookie with :443\")\n  end\n\n  def test_secure_cookie\n    nurl = URI 'http://rubygems.org/login'\n    surl = URI 'https://rubygems.org/login'\n\n    ncookie = Mechanize::Cookie.new(cookie_values(:name => 'Foo1'))\n    scookie = Mechanize::Cookie.new(cookie_values(:name => 'Foo2', :secure => true))\n\n    @jar.add(nurl, ncookie)\n    @jar.add(nurl, scookie)\n    @jar.add(surl, ncookie)\n    @jar.add(surl, scookie)\n\n    assert_equal('Foo1',      @jar.cookies(nurl).map { |c| c.name }.sort.join(' ') )\n    assert_equal('Foo1 Foo2', @jar.cookies(surl).map { |c| c.name }.sort.join(' ') )\n  end\n\n  def test_save_cookies_cookiestxt_subdomain\n    top_url = URI 'http://rubygems.org/'\n    subdomain_url = URI 'http://admin.rubygems.org/'\n\n    # cookie1 is for *.rubygems.org; cookie2 is only for rubygems.org, no subdomains\n    cookie1 = Mechanize::Cookie.new(cookie_values)\n    cookie2 = Mechanize::Cookie.new(cookie_values(:name => 'Boo', :for_domain => false))\n\n    @jar.add(top_url, cookie1)\n    @jar.add(top_url, cookie2)\n\n    assert_equal(2, @jar.cookies(top_url).length)\n    assert_equal(1, @jar.cookies(subdomain_url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt) # HACK test the format\n      assert_equal(2, jar.cookies(top_url).length)\n      assert_equal(1, jar.cookies(subdomain_url).length)\n\n      # Check that we actually wrote the file correctly (not just that we were\n      # able to read what we wrote):\n      #\n      # * Cookies that only match exactly the domain specified must not have a\n      #   leading dot, and must have FALSE as the second field.\n      # * Cookies that match subdomains may have a leading dot, and must have\n      #   TRUE as the second field.\n      cookies_txt = File.readlines(\"cookies.txt\")\n      assert_equal(1, cookies_txt.grep( /^rubygems\\.org\\tFALSE/ ).length)\n      assert_equal(1, cookies_txt.grep( /^\\.rubygems\\.org\\tTRUE/ ).length)\n    end\n\n    assert_equal(2, @jar.cookies(top_url).length)\n    assert_equal(1, @jar.cookies(subdomain_url).length)\n  end\nend\n", "require 'mechanize/test_case'\n\nclass TestMechanizeDownload < Mechanize::TestCase\n\n  def setup\n    super\n\n    @parser = Mechanize::Download\n  end\n\n  def test_body\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    assert_equal '0123456789', download.body\n    assert_equal 0, download.body_io.pos\n  end\n\n  def test_save_string_io\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    in_tmpdir do\n      filename = download.save\n\n      assert File.exist? 'foo.html'\n      assert_equal \"foo.html\", filename\n    end\n  end\n\n  def test_save_bang\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    in_tmpdir do\n      filename = download.save!\n\n      assert File.exist? 'foo.html'\n      assert_equal \"foo.html\", filename\n    end\n  end\n\n  def test_save_tempfile\n    uri = URI.parse 'http://example/foo.html'\n    Tempfile.open @NAME do |body_io|\n      body_io.unlink\n      body_io.write '0123456789'\n\n      body_io.flush\n      body_io.rewind\n\n      download = @parser.new uri, nil, body_io\n\n      in_tmpdir do\n        filename = download.save\n\n        assert File.exist? 'foo.html'\n        assert_equal \"foo.html\", filename\n\n        filename = download.save\n\n        assert File.exist? 'foo.html.1'\n        assert_equal \"foo.html.1\", filename\n\n        filename = download.save\n\n        assert File.exist? 'foo.html.2'\n        assert_equal \"foo.html.2\", filename\n      end\n    end\n  end\n\n  def test_filename\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    assert_equal \"foo.html\", download.filename\n  end\n\nend\n\n", "require 'mechanize/test_case'\n\nclass TestMechanizeFile < Mechanize::TestCase\n\n  def setup\n    super\n\n    @parser = Mechanize::File\n  end\n\n  def test_save\n    uri = URI 'http://example/name.html'\n    page = Mechanize::File.new uri, nil, '0123456789'\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html'\n        assert_equal '0123456789', File.read('test.html')\n        assert_equal \"test.html\", filename\n\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html.1'\n        assert_equal '0123456789', File.read('test.html.1')\n        assert_equal \"test.html.1\", filename\n\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html.2'\n        assert_equal '0123456789', File.read('test.html.2')\n        assert_equal \"test.html.2\", filename\n      end\n    end\n  end\n\n  def test_save_default\n    uri = URI 'http://example/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save\n\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save\n\n        assert File.exist? 'test.html.1'\n        assert_equal \"test.html.1\", filename\n\n        filename = page.save\n\n        assert File.exist? 'test.html.2'\n        assert_equal \"test.html.2\", filename\n      end\n    end\n  end\n\n  def test_save_default_dots\n    uri = URI 'http://localhost/../test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save\n        assert File.exist? 'test.html.1'\n        assert_equal \"test.html.1\", filename\n      end\n    end\n  end\n\n  def test_filename\n    uri = URI 'http://localhost/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    assert_equal \"test.html\", page.filename\n  end\n\n  def test_save_overwrite\n    uri = URI 'http://example/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save! 'test.html'\n\n        assert File.exist? 'test.html'\n        refute File.exist? 'test.html.1'\n        assert_equal \"test.html\", filename\n      end\n    end\n  end\n\nend\n\n", "require 'mechanize/test_case'\n\nclass TestMechanizeFileResponse < Mechanize::TestCase\n\n  def test_content_type\n    Tempfile.open %w[pi .nothtml] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_nil res['content-type']\n    end\n\n    Tempfile.open %w[pi .xhtml] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_equal 'text/html', res['content-type']\n    end\n\n    Tempfile.open %w[pi .html] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_equal 'text/html', res['Content-Type']\n    end\n  end\n\nend\n\n"], "fixing_code": ["= Mechanize CHANGELOG\n\n=== Unreleased\n\n* Security\n\n  Mechanize `>= v2.0`, `< v2.7.7` allows for OS commands to be injected into several classes'\n  methods via implicit use of Ruby's `Kernel.open` method. Exploitation is possible only if\n  untrusted input is used as a local filename and passed to any of these calls:\n\n  - `Mechanize::CookieJar#load`: since v2.0 (see 208e3ed)\n  - `Mechanize::CookieJar#save_as`: since v2.0 (see 5b776a4)\n  - `Mechanize#download`: since v2.2 (see dc91667)\n  - `Mechanize::Download#save` and `#save!` since v2.1 (see 98b2f51, bd62ff0)\n  - `Mechanize::File#save` and `#save_as`: since v2.1 (see 2bf7519)\n  - `Mechanize::FileResponse#read_body`: since v2.0 (see 01039f5)\n\n  See https://github.com/sparklemotion/mechanize/security/advisories/GHSA-qrqm-fpv6-6r8g for more\n  information.\n\n* New Features\n  * Support for Ruby 3.0 by adding `webrick` as a runtime dependency. (#557) @pvalena\n\n* Bug fix\n  * Ignore input fields with blank names (#542, #536)\n\n=== 2.7.6\n\n* New Features\n  * Mechanize#set_proxy accepts an HTTP URL/URI. (#513)\n\n* Bug fix\n  * Fix element(s)_with(search: selector) methods not working for forms, form fields and frames. (#444)\n  * Improve the filename parser for the `Content-Disposition` header. (#496, #517)\n  * Accept `Content-Encoding: identity`. (#515)\n  * Mechanize::Page#title no longer picks a title in an embeded SVG/RDF element. (#503)\n  * Make Mechanize::Form#has_field? boolean. (#501)\n\n=== 2.7.5\n\n* New Features\n  * All 4xx responses and RedirectLimitReachedError when fetching robots.txt are treated as full allow just like Googlebot does.\n  * Enable support for mime-types > 3.\n\n* Bug fix\n  * Don't cause infinite loop when `GET /robots.txt` redirects. (#457)\n  * Fix basic authentication for a realm that contains uppercase characters. (#458, #459)\n  * Fix encoding error when uploading a file which name is non-ASCII. (#333)\n\n=== 2.7.4\n\n* New Features\n  * Accept array-like and hash-like values as query/parameter value.\n    A new utility method Mechanize::Util.each_parameter is added, and Mechanize::Util.build_query_string is enhanced\n    for this feature.\n  * Allow passing a `Form::FileUpload` instance to `#post`. #350 by Sam\n    Rawlins.\n  * Capture link when scheme is unsupported. #362 by Jon Rowe.\n  * Pre-defined User-Agent stings are updated to those of more recent versions, and new aliases for IE 10/11 and Edge are added.\n  * Support for mime-types 1.x is restored while keeping compatible with mime-types 2.x.\n  * Mechanize::Page now responds to #xpath, #css, #at_xpath, #at_css, and #%.\n  * element(s)_with methods now accept :xpath and :css options for doing xpath/css\n    selector searching.\n  * Pass URI information to Nokogiri where applicable. #405 @lulalala\n\n* Bug fix\n  * Don't raise an exception if a connection has set a {read,open}_timeout and\n    a `file://` request is made. (#397)\n  * Fix whitespace bug in WWW-Authenticate. #451, #450, by Rasmus Bergholdt\n  * Don't allow redirect from a non-file URL to a file URL for security reasons. (#455)\n\n=== 2.7.3\n\n* New Features\n  * Allow net-http-persistent instance to be named. #324, John Weir.\n  * #save and #save! return filename #340\n  * Updated mime-types requirement to 2.x versions.  #348 by Jeff Nyman.\n\n* Bug fix\n  * Ensure Download#save! defaults back to original filename if\n    none is provided (#300)\n\n=== 2.7.2\n\n* Bug fix\n  * API compatibility issues with Mechanize::CookieJar cookies has been\n    addressed.  https://github.com/sparklemotion/http-cookie/issues/2 #326\n\n=== 2.7.1\n\n* Bug fix\n  * Ensure images with no \"src\" attribute still return correct URLs. #317\n  * Fixes Mechanize::Parser#extract_filename where an empty string filename\n    in the response caused unhandled exception. #318\n\n=== 2.7.0\n\n* New Features\n  * Mechanize::Agent#response_read will now raise a\n    Mechanize::ResponseReadError instead of an EOFError and avoid losing\n    requested content. #296.\n  * Depend on http-cookie, add backwards compatible deprecations.\n    #257 Akinori MUSHA.\n  * Added `Download#save!` for overwriting existing files. #300 Sean Kim.\n\n* Bug fix\n  * Ensure page URLs with whitespace in them are escaped #313 @pacop.\n  * Added a workaround for a bug of URI#+ that led to failure in resolving a relative path containing double slash like \"/../http://.../\". #304\n\n=== 2.6.0\n\n* New Features\n  * Mechanize#start and Mechanize#shutdown (Thanks, Damian Janowski!)\n  * Added Mechanize::Agent#allowed_error_codes for setting an Array\n    of status codes which should not raise an error. #248 Laurence Rowe.\n  * Added `File.save!` for overwriting existing files #219.\n  * DirectorySaver::save_to now accepts an option to decode filename. #262\n  * element(s)_with methods now accept a :search option for doing xpath/css\n    selector searching. #287 Philippe Bourgau\n  * Added httponly option for Mechanize::Cookie #242 by Paolo Perego.\n  * Added Mechanize::XmlFile as a default pluggable parser for handling\n    XML responses. #289\n\n* Minor enhancements\n  * Added Mechanize::Download#save_as as an alias to #save. #246\n  * Fix documentation for `Mechanize::Page` element matchers. #269\n  * Added Mechanize::Form::Field#raw_value for fetching a fields value\n    before it's sent through Mechanize::Util.html_unescape. #283\n  * Added iPad and Android user agents.  #277 by sambit, #278 by seansay.\n\n* Bug fix\n  * Mechanize#cert and Mechanize#key now return the values set by\n    #cert= and #key=. #244, #245 (Thanks, Robert Gogolok!)\n  * Mechanize no longer submits disabled form fields.  #276 by Bogdan Gusiev,\n    #279 by Ricardo Valeriano.\n  * Mechanize::File#save now behaves like Mechanize::Download#save in\n    that it will create the parent directory before saving.\n    #272, #280 by Ryan Kowalick\n  * Ensure `application/xml` is registered as an XML parser in\n    `PluggableParser`, not just `text/xml`. #266 James Gregory\n  * Mechanize now writes cookiestxt with a prefixed dot for wildcard domain\n    handling. #295 by Mike Morearty.\n\n=== 2.5.2\n\n* New Features\n  * Mechanize::CookieJar#save_as takes a keyword option \"session\" to say\n    that session cookies should be saved.  Based on #230 by Jim Jones.\n\n* Minor enhancements\n  * Added Mechanize#follow_redirect= as an alias to redirect_ok=.\n\n* Bug fix\n  * Fixed casing of the Mac Firefox user-agent alias to match Linux Firefox.\n    In mechanize 3 the old \"Mac FireFox\" user-agent alias will be removed.\n    Pull request #231 by Gavin Miller.\n  * Mechanize now authenticates using the raw challenge, not a reconstructed\n    one, to avoid dealing with quoting rules of RFC 2617.  Fixes failures in\n    #231 due to net-http-digest_auth 1.2.1\n  * Fixed Content-Disposition parameter parser to be case insensitive. #233\n  * Fixed redirection counting in following meta refresh. #240\n\n=== 2.5.1\n\n* Bug fix\n  * Mechanize no longer copies POST requests during a redirect which was\n    introduced by #215.  Pull request #229 by Godfrey Chan.\n\n=== 2.5\n\n* Minor enhancements\n  * Added Mechanize#ignore_bad_chunking for working around servers that don't\n    terminate chunked transfer-encoding properly.  Enabling this may cause\n    data loss.  Issue #116\n  * Removed content-type check from Mechanize::Page allowing forced parsing\n    of incorrect or missing content-types.  Issue #221 by GarthSnyder\n* Bug fixes\n  * Fixed typos in EXAMPLES and GUIDES.  Pull Request #213 by Erkan Yilmaz.\n  * Fixed handling of a quoted content-disposition size.  Pull Request #220 by\n    Jason Rust\n  * Mechanize now ignores a missing gzip footer like browsers do.  Issue #224\n    by afhbl\n  * Mechanize handles saving of files with the same name better now.  Pull\n    Request #223 by Godfrey Chan, Issue #219 by Jon Hart\n  * Mechanize now sends headers across redirects.  Issue #215 by Chris Gahan\n  * Mechanize now raises Mechanize::ResponseReadError when the server does not\n    terminate chunked transfer-encoding properly.  Issue #116\n  * Mechanize no longer raises an exception when multiple identical\n    radiobuttons are checked.  Issue #214 by Matthias Guenther\n  * Fixed documentation for pre_connect_hooks and post_connect_hooks.  Issue\n    #226 by Robert Poor\n  * Worked around ruby 1.8 run with -Ku and ISO-8859-1 encoded characters in\n    URIs.  Issue #228 by Stanislav O.Pogrebnyak\n\n=== 2.4\n\n* Security fix:\n\n  Mechanize#auth and Mechanize#basic_auth allowed disclosure of passwords to\n  malicious servers and have been deprecated.\n\n  In prior versions of mechanize only one set of HTTP authentication\n  credentials were allowed for all connections.  If a mechanize instance\n  connected to more than one server then a malicious server detecting\n  mechanize could ask for HTTP Basic authentication.  This would expose the\n  username and password intended only for one server.\n\n  Mechanize#auth and Mechanize#basic_auth now warn when used.\n\n  To fix the warning switch to Mechanize#add_auth which requires the URI\n  the credentials are intended for, the username and the password.\n  Optionally an HTTP authentication realm or NTLM domain may be provided.\n\n* Minor enhancement\n  * Improved exception messages for 401 Unauthorized responses.  Mechanize now\n    tells you if you were missing credentials, had an incorrect password, etc.\n\n=== 2.3 / 2012-02-20\n\n* Minor enhancements\n  * Add support for the Max-Age attribute in the Set-Cookie header.\n  * Added Mechanize::Download#body for compatibility with Mechanize::File when\n    using Mechanize#get_file with Mechanize::Image or other Download-based\n    pluggable parser.  Issue #202 by angas\n  * Mechanize#max_file_buffer may be set to nil to disable creation of\n    Tempfiles.\n\n* Bug fixes\n  * Applied Mechanize#max_file_buffer to the Content-Encoding handlers as well\n    to prevent extra Tempfiles for small gzip or deflate response\n  * Increased the default Mechanize#max_file_buffer to 100,000 bytes.  This\n    gives ~5MB of response bodies in memory with the default history setting\n    of 50 pages (depending on GC behavior).\n  * Ignore empty path/domain attributes.\n  * Cookies with an empty Expires attribute value were stored as session\n    cookies but cookies without the Expires attribute were not.  Issue #78\n\n=== 2.2.1 / 2012-02-13\n\n* Bug fixes\n  * Add missing file to the gem, ensure that missing files won't cause\n    failures again.  Issue #201 by Alex\n  * Fix minor grammar issue in README.  Issue #200 by Shane Becker.\n\n=== 2.2 / 2012-02-12\n\n* API changes\n  * MetaRefresh#href is not normalized to an absolute URL, but set to the\n    original value and resolved later.  It is even set to nil when the\n    Refresh URL is unspecified or empty.\n\n* Minor enhancements\n  * Expose ssl_version from net-http-persistent.  Patch by astera.\n  * SSL parameters and proxy may now be set at any time.  Issue #194 by\n    dsisnero.\n  * Improved Mechanize::Page with #image_with and #images_with and\n    Mechanize::Page::Image various img element attribute accessors, #caption,\n    #extname, #mime_type and #fetch.  Pull request #173 by kitamomonga\n  * Added MIME type parsing for content-types in Mechanize::PluggableParser\n    for fine-grained parser choices.  Parsers will be chosen based on exact\n    match, simplified type or media type in that order.  See\n    Mechanize::PluggableParser#[]=.\n  * Added Mechanize#download which downloads a response body to an IO-like or\n    filename.\n  * Added Mechanize::DirectorySaver which saves responses in a single\n    directory.  Issue #187 by yoshie902a.\n  * Added Mechanize::Page::Link#noreferrer?\n  * The documentation for Mechanize::Page#search and #at now show that both\n    XPath and CSS expressions are allowed.  Issue #199 by Shane Becker.\n\n* Bug fixes\n  * Fixed handling of a HEAD request with Accept-Encoding: gzip.  Issue #198\n    by Oleg Dashevskii\n  * Use #resolve for resolving a Location header value.  fixes #197\n  * A Refresh value can have whitespaces around the semicolon and equal sign.\n  * MetaRefresh#click no longer sends out Referer.\n  * A link with an empty href is now resolved correctly where previously the\n    query part was dropped.\n\n=== 2.1.1 / 2012-02-03\n\n* Bug fixes\n  * Set missing idle_timeout default.  Issue #196\n  * Meta refresh URIs are now escaped (excluding %).  Issue #177\n  * Fix charset name extraction.  Issue #180\n  * A Referer URI sent on request no longer includes user information\n    or fragment part.\n  * Tempfiles for storing response bodies are unlinked upon creation to avoid\n    possible lack of finalization.  Issue #183\n  * The default maximum history size is now 50 pages to avoid filling up a\n    disk with tempfiles accidentally.  Related to Issue #183\n  * Errors in bodies with deflate and gzip responses now result in a\n    Mechanize::Error instead of silently being ignored and causing future\n    errors.  Issue #185\n  * Mechanize now raises an UnauthorizedError instead of crashing when a 403\n    response does not contain a www-authenticate header.  Issue #181\n  * Mechanize gives a useful exception when attempting to click buttons across\n    pages.  Issue #186\n  * Added note to Mechanize#cert_store describing how to add certificates in\n    case your system does not come with a default set.  Issue #179\n  * Invalid content-disposition headers are now ignored.  Issue #191\n  * Fix NTLM by recognizing the \"Negotiation\" challenge instead of endlessly\n    looping.  Issue #192\n  * Allow specification of the NTLM domain through Mechanize#auth.  Issue #193\n  * Documented how to convert a Mechanize::ResponseReadError into a File or\n    Page, along with a new method #force_parse.  Issue #176\n\n=== 2.1 / 2011-12-20\n\n* Deprecations\n  * Mechanize#get no longer accepts an options hash.\n  * Mechanize::Util::to_native_charset has been removed.\n\n* Minor enhancements\n  * Mechanize now depends on net-http-persistent 2.3+.  This new version\n    brings idle timeouts to help with the dreaded \"too many connection resets\"\n    issue when POSTing to a closed connection.  Issue #123\n  * SSL connections will be verified against the system certificate store by\n    default.\n  * Added Mechanize#retry_change_requests to allow mechanize to retry POST and\n    other non-idempotent requests when you know it is safe to do so.  Issue\n    #123\n  * Mechanize can now stream files directly to disk without loading them into\n    memory first through Mechanize::Download, a pluggable parser for\n    downloading files.\n\n    All responses larger than Mechanize#max_file_buffer are downloaded to a\n    Tempfile.  For backwards compatibility Mechanize::File subclasses still\n    load the response body into memory.\n\n    To force all unknown content types to download to disk instead of memory\n    set:\n\n      agent.pluggable_parser.default = Mechanize::Download\n  * Added Mechanize#content_encoding_hooks which allow handling of\n    non-standard content encodings like \"agzip\".  Patch #125 by kitamomonga\n  * Added dom_class to elements and the element matcher like dom_id.  Patch\n    #156 by Dan Hansen.\n  * Added support for the HTML5 keygen form element.  See\n    http://dev.w3.org/html5/spec/Overview.html#the-keygen-element  Patch #157\n    by Victor Costan.\n  * Mechanize no longer follows meta refreshes that have no \"url=\" in the\n    content attribute to avoid infinite loops.  To follow a meta refresh to\n    the same page set Mechanize#follow_meta_refresh_self to true.  Issue #134\n    by Jo Hund.\n  * Updated 'Mac Safari' User-Agent alias to Safari 5.1.1.  'Mac Safari 4' can\n    be used for the old 'Mac Safari' alias.\n  * When given multiple HTTP authentication options mechanize now picks the\n    strongest method.\n  * Improvements to HTTP authorization:\n    * mechanize raises Mechanize::UnathorizedError for 401 responses which is\n      a sublcass of Mechanize::ResponseCodeError.\n    * Added support for NTLM authentication, but this has not been tested.\n  * Mechanize::Cookie.new accepts attributes in a hash.\n  * Mechanize::CookieJar#<<(cookie) (alias: add!) is added.  Issue #139\n  * Different mechanize instances may now have different loggers.  Issue #122\n  * Mechanize now accepts a proxy port as a service name or number string.\n    Issue #167\n\n* Bug fixes\n  * Mechanize now handles cookies just as most modern browsers do,\n    roughly based on RFC 6265.\n    * domain=.example.com (which is invalid) is considered identical to\n      domain=example.com.\n    * A cookie with domain=example.com is sent to host.sub.example.com\n      as well as host.example.com and example.com.\n    * A cookie with domain=TLD (no dots) is accepted and sent if the\n      host name is TLD, and rejected otherwise.  To retain compatibility\n      and convention, host/domain names starting with \"local\" are exempt\n      from this rule.\n    * A cookie with no domain attribute is only sent to the original\n      host.\n    * A cookie with an Effective TLD is rejected based on the public\n      suffix list. (cf. http://publicsuffix.org/)\n    * \"Secure\" cookies are not sent via non-https connection.\n    * Subdomain match is not performed against an IP address.\n    * It is recommended that you clear out existing cookie jars for\n      regeneration because previously saved cookies may not have been\n      parsed correctly.\n  * Mechanize takes more care to avoid saving files with certain unsafe names.\n    You should still take care not to use mechanize to save files directly\n    into your home directory ($HOME).  Issue #163.\n  * Mechanize#cookie_jar= works again.  Issue #126\n  * The original Referer value persists on redirection.  Issue #150\n  * Do not send a referer on a Refresh header based redirection.\n  * Fixed encoding error in tests when LANG=C.  Patch #142 by jinschoi.\n  * The order of items in a form submission now match the DOM order.  Patch\n    #129 by kitamomonga\n  * Fixed proxy example in EXAMPLE.  Issue #146 by NielsKSchjoedt\n\n=== 2.0.1 / 2011-06-28\n\nMechanize now uses minitest to avoid 1.9 vs 1.8 assertion availability in\ntest/unit\n\n* Bug Fixes\n  * Restored Mechanize#set_proxy.  Issue #117, #118, #119\n  * Mechanize::CookieJar#load now lazy-loads YAML.  Issue #118\n  * Mechanize#keep_alive_time no longer crashes but does nothing as\n    net-http-persistent does not support HTTP/1.0 keep-alive extensions.\n\n=== 2.0 / 2011-06-27\n\nMechanize is now under the MIT license\n\n* API changes\n  * WWW::Mechanize has been removed.  Use Mechanize.\n  * Pre connect hooks are now called with the agent and the request.  See\n    Mechanize#pre_connect_hooks.\n  * Post connect hooks are now called with the agent and the response.  See\n    Mechanize#post_connect_hooks.\n  * Mechanize::Chain is gone, as an internal API this should cause no problems.\n  * Mechanize#fetch_page no longer accepts an options Hash.\n  * Mechanize#put now accepts headers instead of an options Hash as the last\n    argument\n  * Mechanize#delete now accepts headers instead of an options Hash as the\n    last argument\n  * Mechanize#request_with_entity now accepts headers instead of an options\n    Hash as the last argument\n  * Mechanize no longer raises RuntimeError directly, Mechanize::Error or\n    ArgumentError are raised instead.\n  * The User-Agent header has changed.  It no longer includes the WWW- prefix\n    and now includes the ruby version.  The URL has been updated as well.\n  * Mechanize now requires ruby 1.8.7 or newer.\n  * Hpricot support has been removed as webrobots requires nokogiri.\n  * Mechanize#get no longer accepts the referer as the second argument.\n  * Mechanize#get no longer allows the HTTP method to be changed (:verb\n    option).\n  * Mechanize::Page::Meta is now Mechanize::Page::MetaRefresh to accurately\n    depict its responsibilities.\n  * Mechanize::Page#meta is now Mechanize::Page#meta_refresh as it only\n    contains meta elements with http-equiv of \"refresh\"\n  * Mechanize::Page#charset is now Mechanize::Page::charset.  GH #112, patch\n    by Godfrey Chan.\n\n* Deprecations\n  * Mechanize#get with an options hash is deprecated and will be removed after\n    October, 2011.\n  * Mechanize::Util::to_native_charset is deprecated as it is no longer used\n    by Mechanize.\n\n* New Features\n\n  * Add header reference methods to Mechanize::File so that a reponse\n    object gets compatible with Net::HTTPResponse.\n  * Mechanize#click accepts a regexp or string to click a button/link in the\n    current page. It works as expected when not passed a string or regexp.\n  * Provide a way to only follow permanent redirects (301)\n    automatically: <tt>agent.redirect_ok = :permanent</tt>  GH #73\n  * Mechanize now supports HTML5 meta charset.  GH #113\n  * Documented various Mechanize accessors.  GH #66\n  * Mechanize now uses net-http-digest_auth.  GH #31\n  * Mechanize now implements session cookies.  GH #78\n  * Mechanize now implements deflate decoding.  GH #40\n  * Mechanize now allows a certificate and key to be passed directly.  GH #71\n  * Mechanize::Form::MultiSelectList now implements #option_with and\n    #options_with.  GH #42\n  * Add Mechanize::Page::Link#rel and #rel?(kind) to read and test the rel\n    attribute.\n  * Add Mechanize::Page#canonical_uri to read a </tt><link\n    rel=\"canonical\"></tt> tag.\n  * Add support for Robots Exclusion Protocol (i.e. robots.txt) and\n    nofollow/noindex in meta tags and the rel attribute.  Automatic\n    exclusion can be turned on by setting:\n      agent.robots = true\n  * Manual robots.txt test can be performed with\n    Mechanize#robots_allowed? and #robots_disallowed?.\n  * Mechanize::Form now supports the accept-charset attribute.  GH #96\n  * Mechanize::ResponseReadError is raised if there is an exception while\n    reading the response body.  This allows recovery from broken HTTP servers\n    (or connections).  GH #90\n  * Mechanize#follow_meta_refresh set to :anywhere will follow meta refresh\n    found outside of a document's head.  GH #99\n  * Add support for HTML5's rel=\"noreferrer\" attribute which indicates\n    no \"Referer\" information should be sent when following the link.\n  * A frame will now load its content when #content is called.  GH #111\n  * Added Mechanize#default_encoding to provide a default for pages with no\n    encoding specified.  GH #104\n  * Added Mechanize#force_default_encoding which only uses\n    Mechanize#default_encoding for parsing HTML.  GH #104\n\n* Bug Fixes:\n\n  * Fixed a bug where Referer is not sent when accessing a relative\n    URI starting with \"http\".\n  * Fix handling of Meta Refresh with relative paths.  GH #39\n  * Mechanize::CookieJar now supports RFC 2109 correctly.  GH #85\n  * Fixed typo in EXAMPLES.rdoc.  GH #74\n  * The base element is now handled correctly for images.  GH #72\n  * Image buttons with no name attribute are now included in the form's button\n    list.  GH#56\n  * Improved handling of non ASCII-7bit compatible characters in links (only\n    an issue on ruby 1.8).  GH #36, GH #75\n  * Loading cookies.txt is faster.  GH #38\n  * Mechanize no longer sends cookies for a.b.example to axb.example.  GH #41\n  * Mechanize no longer sends the button name as a form field for image\n    buttons.  GH #45\n  * Blank cookie values are now skipped.  GH #80\n  * Mechanize now adds a '.' to cookie domains if no '.' was sent.  This is\n    not allowed by RFC 2109 but does appear in RFC 2965.  GH #86\n  * file URIs are now read in binary mode.  GH #83\n  * Content-Encoding: x-gzip is now treated like gzip per RFC 2616.\n  * Mechanize now unescapes URIs for meta refresh.  GH #68\n  * Mechanize now has more robust HTML charset detection.  GH #43\n  * Mechanize::Form::Textarea is now created from a textarea element.  GH #94\n  * A meta content-type now overrides the HTTP content type.  GH #114\n  * Mechanize::Page::Link#uri now handles both escaped and unescaped hrefs.\n    GH #107\n\n=== 1.0.0\n\n* New Features:\n\n  * An optional verb may be passed to Mechanize#get GH #26\n  * The WWW constant is deprecated. Switch to the top level constant Mechanize\n  * SelectList#option_with and options_with for finding options\n\n* Bug Fixes:\n\n  * Rescue errors from bogus encodings\n  * 7bit content-encoding support.  Thanks sporkmonger! GH #2\n  * Fixed a bug with iconv conversion. Thanks awesomeman! GH #9\n  * meta redirects outside the head are not followed. GH #13\n  * Form submissions work with nil page encodings. GH #25\n  * Fixing default values with serialized cookies. GH #3\n  * Checkboxes and fields are sorted by page appearance before submitting. #11\n\n=== 0.9.3\n\n* Bug Fixes:\n\n  * Do not apply encoding if encoding equals 'none' Thanks Akinori MUSHA!\n  * Fixed Page#encoding= when changing the value from or to nil.  Made\n    it return the assigned value while at it. (Akinori MUSHA)\n  * Custom request headers may be supplied WWW::Mechanize#request_headers\n    RF #24516\n  * HTML Parser may be set on a per instance level WWW::Mechanize#html_parser\n    RF #24693\n  * Fixed string encoding in ruby 1.9.  RF #2433\n  * Rescuing Zlib::DataErrors (Thanks Kelley Reynolds)\n  * Fixing a problem with frozen SSL objects.  RF #24950\n  * Do not send a referer on meta refresh. RF #24945\n  * Fixed a bug with double semi-colons in Content-Disposition headers\n  * Properly handling cookies that specify a path.  RF #25259\n\n=== 0.9.2 / 2009/03/05\n\n* New Features:\n  * Mechanize#submit and Form#submit take arbitrary headers(thanks penguincoder)\n\n* Bug Fixes:\n  * Fixed a bug with bad cookie parsing\n  * Form::RadioButton#click unchecks other buttons (RF #24159)\n  * Fixed problems with Iconv (RF #24190, RF #24192, RF #24043)\n  * POST parameters should be CGI escaped\n  * Made Content-Type match case insensitive (Thanks Kelly Reynolds)\n  * Non-string form parameters work\n\n=== 0.9.1 2009/02/23\n\n* New Features:\n  * Encoding may be specified for a page: Page#encoding=\n\n* Bug Fixes:\n  * m17n fixes. \u3042\u308a\u304c\u3068\u3046 konn!\n  * Fixed a problem with base tags.  \u3042\u308a\u304c\u3068\u3046 Keisuke\n  * HEAD requests do not record in the history\n  * Default encoding to ISO-8859-1 instead of ASCII\n  * Requests with URI instances should not be polluted RF #23472\n  * Nonce count fixed for digest auth requests.  Thanks Adrian Slapa!\n  * Fixed a referer issue with requests using a uri.  RF #23472\n  * WAP content types will now be parsed\n  * Rescued poorly formatted cookies.  Thanks Kelley Reynolds!\n\n=== 0.9.0\n\n* Deprecations\n  * WWW::Mechanize::List is gone!\n  * Mechanize uses Nokogiri as it's HTML parser but you may switch to\n    Hpricot by using WWW::Mechanize.html_parser = Hpricot\n\n* Bug Fixes:\n  * Nil check on page when base tag is used #23021\n\n=== 0.8.5\n\n* Deprecations\n  * WWW::Mechanize::List will be deprecated in 0.9.0, and warnings have\n    been added to help you upgrade.\n\n* Bug Fixes:\n  * Stopped raising EOF exceptions on HEAD requests. \u3042\u308a\u304c\u3068\u3046\uff1aHIRAKU Kuroda\n  * Fixed exceptions when a logger is set and file:// requests are made.\n  * Made Mechanize 1.9 compatible\n  * Not setting the port in the host header for SSL sites.\n  * Following refresh headers.  Thanks Tim Connor!\n  * Cookie Jar handles cookie domains containing ports, like\n    'mydomain.com:443' (Thanks Michal Ochman!)\n  * Fixing strange uri escaping problems [#22604]\n  * Making content-type determintation more robust.  (thanks Han Holl!)\n  * Dealing with links that are query string only.  [#22402]\n  * Nokogiri may be dropped in as a replacement.\n      WWW::Mechanize.html_parser = Nokogiri::HTML\n  * Making sure the correct page is added to the history on meta refresh.\n    [#22708]\n  * Mechanize#get requests no longer send a referer unless they are relative\n    requests.\n\n=== 0.8.4\n\n* Bug Fixes:\n  * Setting the port number on the host header.\n  * Fixing Authorization headers for picky servers\n\n=== 0.8.3\n\n* Bug Fixes:\n  * Making sure logger is set during SSL connections.\n\n=== 0.8.2\n\n* Bug Fixes:\n  * Doh!  I was accidentally setting headers twice.\n\n=== 0.8.1\n\n* Bug Fixes:\n  * Fixed problem with nil pointer when logger is set\n\n=== 0.8.0\n\n* New Features:\n  * Lifecycle hooks.  Mechanize#pre_connect_hooks, Mechanize#post_connect_hooks\n  * file:/// urls are now supported\n  * Added Mechanize::Page#link_with, frame_with for searching for links using\n    +criteria+.\n  * Implementing PUT, DELETE, and HEAD requests\n\n* Bug Fixes:\n  * Fixed an infinite loop when content-length and body length don't match.\n  * Only setting headers once\n  * Adding IIS authentication support\n\n=== 0.7.8\n\n* Bug Fixes:\n  * Fixed bug when receiving a 304 response (HTTPNotModified) on a page not\n    cached in history.\n  * #21428 Default to HTML parser for 'application/xhtml+xml' content-type.\n  * Fixed an issue where redirects were resending posted data\n\n=== 0.7.7\n\n* New Features:\n  * Page#form_with takes a +criteria+ hash.\n  * Page#form is changed to Page#form_with\n  * Mechanize#get takes custom http headers.  Thanks Mike Dalessio!\n  * Form#click_button submits a form defaulting to the current button.\n  * Form#set_fields now takes a hash.  Thanks Tobi!\n  * Mechanize#redirection_limit= for setting the max number of redirects.\n\n* Bug Fixes:\n  * Added more examples.  Thanks Robert Jackson.\n  * #20480 Making sure the Host header is set.\n  * #20672 Making sure cookies with weird semicolons work.\n  * Fixed bug with percent signs in urls.\n    http://d.hatena.ne.jp/kitamomonga/20080410/ruby_mechanize_percent_url_bug\n  * #21132 Not checking for EOF errors on redirect\n  * Fixed a weird gzipping error.\n  * #21233 Smarter multipart boundry. Thanks Todd Willey!\n  * #20097 Supporting meta tag cookies.\n\n=== 0.7.6\n\n* New Features:\n  * Added support for reading Mozilla cookie jars.  Thanks Chris Riddoch!\n  * Moving text, password, hidden, int to default.  Thanks Tim Harper!\n  * Mechanize#history_added callback for page loads. Thanks Tobi Reif!\n  * Mechanize#scheme_handlers callbacks for handling unsupported schemes on\n    links.\n\n* Bug Fixes:\n  * Ignoring scheme case\n    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=470642\n  * Not encoding tildes in uris. Thanks Bruno.  [#19380]\n  * Resetting request bodys when retrying form posts.  Thanks Bruno. [#19379]\n  * Throwing away keep alive connections on EPIPE and ECONNRESET.\n  * Duplicating request headers when retrying a 401. Thanks Hiroshi Ichikawa.\n  * Simulating an EOF error when a response length is bad.  Thanks Tobias Gruetzmacher.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19178&group_id=1453&atid=5711\n  * Defaulting option tags to the inner text.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19976&group_id=1453&atid=5709\n  * Supporting blank strings for option values.\n    http://rubyforge.org/tracker/index.php?func=detail&aid=19975&group_id=1453&atid=5709\n\n=== 0.7.5\n\n* Fixed a bug when fetching files and not pages.  Thanks Mat Schaffer!\n\n=== 0.7.4\n\n* doh!\n\n=== 0.7.3\n\n* Pages are now yielded to a blocks given to WWW::Mechanize#get\n* WWW::Mechanize#get now takes hash arguments for uri parameters.\n* WWW::Mechanize#post takes an IO object as a parameter and posts correctly.\n* Fixing a strange zlib inflate problem on windows\n\n=== 0.7.2\n\n* Handling gzipped responses with no Content-Length header\n\n=== 0.7.1\n\n* Added iPhone to the user agent aliases. [#17572]\n* Fixed a bug with EOF errors in net/http.  [#17570]\n* Handling 0 length gzipped responses. [#17471]\n\n=== 0.7.0\n\n* Removed Ruby 1.8.2 support\n* Changed parser to lazily parse links\n* Lazily parsing document\n* Adding verify_callback for SSL requests.  Thanks Mike Dalessio!\n* Fixed a bug with Accept-Language header.  Thanks Bill Siggelkow.\n\n=== 0.6.11\n\n* Detecting single quotes in meta redirects.\n* Adding pretty inspect for ruby versions > 1.8.4 (Thanks Joel Kociolek)\n  http://rubyforge.org/tracker/index.php?func=detail&aid=13150&group_id=1453&atid=5709\n* Fixed bug with file name in multipart posts\n  http://rubyforge.org/tracker/?func=detail&aid=15594&group_id=1453&atid=5709\n* Posting forms relative to the originating page. Thanks Mortee.\n* Added a FAQ\n  http://rubyforge.org/tracker/?func=detail&aid=15772&group_id=1453&atid=5709\n\n=== 0.6.10\n\n* Made digest authentication work with POSTs.\n* Made sure page was HTML before following meta refreshes.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12260&group_id=1453&atid=5709\n* Made sure that URLS with a host and no path would default to '/' for history\n  purposes.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12368&group_id=1453&atid=5709\n* Avoiding memory leaks with transact.  Thanks Tobias Gruetzmacher!\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12057&group_id=1453&atid=5711\n* Fixing a problem with # signs in the file name.  Thanks Tobias Gruetzmacher!\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12510&group_id=1453&atid=5711\n* Made sure that blank form values are submitted.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12505&group_id=1453&atid=5709\n* Mechanize now respects the base tag.  Thanks Stephan Dale.\n  http://rubyforge.org/tracker/index.php?func=detail&aid=12468&group_id=1453&atid=5709\n* Aliasing inspect to pretty_inspect.  Thanks Eric Promislow.\n  http://rubyforge.org/pipermail/mechanize-users/2007-July/000157.html\n\n=== 0.6.9\n\n* Updating UTF-8 support for urls\n* Adding AREA tags to the links list.\n  http://rubyforge.org/pipermail/mechanize-users/2007-May/000140.html\n* WWW::Mechanize#follow_meta_refresh will allow you to automatically follow\n  meta refresh tags. [#10032]\n* Adding x-gzip to accepted content-encoding.  Thanks Simon Strandgaard\n  http://rubyforge.org/tracker/index.php?func=detail&aid=11167&group_id=1453&atid=5711\n* Added Digest Authentication support.  Thanks to Ryan Davis and Eric Hodel,\n  you get a gold star!\n\n=== 0.6.8\n\n* Keep alive can be shut off now with WWW::Mechanize#keep_alive\n* Conditional requests can be shut off with WWW::Mechanize#conditional_requests\n* Monkey patched Net::HTTP#keep_alive?\n* [#9877] Moved last request time.  Thanks Max Stepanov\n* Added WWW::Mechanize::File#save\n* Defaulting file name to URI or Content-Disposition\n* Updating compatability with hpricot\n* Added more unit tests\n\n=== 0.6.7\n\n* Fixed a bug with keep-alive requests\n* [#9549] fixed problem with cookie paths\n\n=== 0.6.6\n\n* Removing hpricot overrides\n* Fixed a bug where alt text can be nil.  Thanks Yannick!\n* Unparseable expiration dates in cookies are now treated as session cookies\n* Caching connections\n* Requests now default to keep alive\n* [#9434] Fixed bug where html entities weren't decoded\n* [#9150] Updated mechanize history to deal with redirects\n\n=== 0.6.5\n\n* Copying headers to a hash to prevent memory leaks\n* Speeding up page parsing\n* Aliased fields to elements\n* Adding If-Modified-Since header\n* Added delete_field! to form.  Thanks to Sava Chankov\n* Updated uri escaping to support high order characters.  Thanks to Henrik Nyh.\n* Better handling relative URIs.  Thanks to Henrik Nyh\n* Now handles pipes in URLs\n  http://rubyforge.org/tracker/?func=detail&aid=7140&group_id=1453&atid=5709\n* Now escaping html entities in form fields.\n  http://rubyforge.org/tracker/?func=detail&aid=7563&group_id=1453&atid=5709\n* Added MSIE 7.0 user agent string\n\n=== 0.6.4\n\n* Adding the \"redirect_ok\" method to Mechanize to stop mechanize from\n  following redirects.\n\thttp://rubyforge.org/tracker/index.php?func=detail&aid=6571&group_id=1453&atid=5712\n* Added protected method Mechanize#set_headers so that subclasses can set\n  custom headers.\n  http://rubyforge.org/tracker/?func=detail&aid=7208&group_id=1453&atid=5712\n* Aliased Page#referer to Page#page\n* Fixed a bug when clicking relative urls\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000035.html\n* Fixing a bug when bad version or max age is passed to Cookie::parse\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000033.html\n* Fixing a bug with response codes. [#6526]\n* Fixed bug [#6548].  Input type of 'button' was not being added as a button.\n* Fixed bug [#7139]. REXML parser calls hpricot parser by accident\n\n=== 0.6.3\n\n* Added keys and values methods to Form\n* Added has_value? to Form\n* Added a has_field? method to Form\n* The add_field! method on Form now creates a field for you on the form.\n  Thanks to Mat Schaffer for the patch.\n  http://rubyforge.org/pipermail/mechanize-users/2006-November/000025.html\n* Fixed a bug when form actions have html ecoded entities in them.\n  http://rubyforge.org/pipermail/mechanize-users/2006-October/000019.html\n* Fixed a bug when links or frame sources have html encoded entities in the\n  href or src.\n* Fixed a bug where '#' symbols are encoded\n  http://rubyforge.org/forum/message.php?msg_id=14747\n\n=== 0.6.2\n\n* Added a yield to Page#form so that dealing with forms can be more DSL like.\n* Added the parsed page to the ResponseCodeError so that the parsed results\n  can be accessed even in the event of an error.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000007.html\n* Updated documentation (Thanks to Paul Smith)\n\n=== 0.6.1\n\n* Added a method to Form called \"submit\".  Now forms can be submitted by\n  calling a method on the form.\n* Added a click method to links\n* Added an REXML pluggable parser for backwards compatability.  To use it,\n  just do this:\n   agent.pluggable_parser.html = WWW::Mechanize::REXMLPage\n* Fixed a bug with referrers by adding a page attribute to forms and links.\n* Fixed a bug where domain names were case sensitive.\n  http://tenderlovemaking.com/2006/09/04/road-to-ruby-mechanize-060/#comment-53\n* Fixed a bug with URI escaped links.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000002.html\n* Fixed a bug when options in select lists don't have a value. Thanks Dan Higham\n  [#5837] Code in lib/mechanize/form_elements.rb is incorrect.\n* Fixed a bug with loading text in to links.\n  http://rubyforge.org/pipermail/mechanize-users/2006-September/000000.html\n\n=== 0.6.0\n\n* Changed main parser to use hpricot\n* Made WWW::Mechanize::Page class searchable like hpricot\n* Updated WWW::Mechanize#click to support hpricot links like this:\n  @agent.click (page/\"a\").first\n* Clicking a Frame is now possible:\n  @agent.click (page/\"frame\").first\n* Removed deprecated attr_finder\n* Removed REXML helper methods since the main parser is now hpricot\n* Overhauled cookie parser to use WEBrick::Cookie\n\n=== 0.5.4\n\n* Added WWW::Mechanize#trasact for saving history state between in a\n  transaction.  See the EXAMPLES file.  Thanks Johan Kiviniemi.\n* Added support for gzip compressed pages\n* Forms can now be accessed like a hash.  For example, to set the value\n  of an input field named 'name' to \"Aaron\", you can do this:\n   form['name'] = \"Aaron\"\n  Or to get the value of a field named 'name', do this:\n   puts form['name']\n* File uploads will now read the file specified in FileUpload#file_name\n* FileUpload can use an IO object in FileUpload#file_data\n* Fixed a bug with saving files on windows\n* Fixed a bug with the filename being set in forms\n\n=== 0.5.3\n\n* Mechanize#click will now act on the first element of an array.  So if an\n  array of links is passed to WWW::Mechanize#click, the first link is clicked.\n  That means the syntax for clicking links is shortened and still supports\n  selecting a link.  The following are equivalent:\n   agent.click page.links.first\n   agent.click page.links\n* Fixed a bug with spaces in href's and get's\n* Added a tick, untick, and click method to radio buttons so that\n  radiobuttons can be \"clicked\"\n* Added a tick, untick, and click method to check boxes so that\n  checkboxes can be \"clicked\"\n* Options on Select lists can now be \"tick\"ed, and \"untick\"ed.\n* Fixed a potential bug conflicting with rails.  Thanks Eric Kolve\n* Updated log4r support for a speed increase.  Thanks Yinon Bentor\n* Added inspect methods and pretty printing\n\n=== 0.5.2\n\n* Fixed a bug with input names that are nil\n* Added a warning when using attr_finder because attr_finder will be deprecated\n  in 0.6.0 in favor of method calls.  So this syntax:\n    @agent.links(:text => 'foo')\n  should be changed to this:\n    @agent.links.text('foo')\n* Added support for selecting multiple options in select tags that support\n  multiple options.  See WWW::Mechanize::MultiSelectList.\n* New select list methods have been added, select_all, select_none.\n* Options for select lists can now be \"clicked\" which toggles their selection,\n  they can be \"selected\" and \"unselected\".  See WWW::Mechanize::Option\n* Added a method to set multiple fields at the same time,\n  WWW::Mechanize::Form#set_fields.  Which can be used like so:\n   form.set_fields( :foo => 'bar', :name => 'Aaron' )\n\n=== 0.5.1\n\n* Fixed bug with file uploads\n* Added performance tweaks to the cookie class\n\n=== 0.5.0\n\n* Added pluggable parsers. (Thanks to Eric Kolve for the idea)\n* Changed namespace so all classes are under WWW::Mechanize.\n* Updating Forms so that fields can be used as accessors (Thanks Gregory Brown)\n* Added WWW::Mechanize::File as default object used for unknown content types.\n* Added 'save_as' method to Mechanize::File, so any page can be saved.\n* Adding 'save_as' and 'load' to CookieJar so that cookies can be saved\n  between sessions.\n* Added WWW::Mechanize::FileSaver pluggable parser to automatically save files.\n* Added WWW::Mechanize::Page#title for page titles\n* Added OpenSSL certificate support (Thanks Mike Dalessio)\n* Removed support for body filters in favor of pluggable parsers.\n* Fixed cookie bug adding a '/' when the url is missing one (Thanks Nick Dainty)\n\n=== 0.4.7\n\n* Fixed bug with no action in forms.  Thanks to Adam Wiggins\n* Setting a default user-agent string\n* Added house cleaning to the cookie jar so expired cookies don't stick around.\n* Added new method WWW::Form#field to find the first field with a given name.\n  (thanks to Gregory Brown)\n* Added WWW::Mechanize#get_file for fetching non text/html files\n\n=== 0.4.6\n\n* Added support for proxies\n* Added a uri field to WWW::Link\n* Added a error class WWW::Mechanize::ContentTypeError\n* Added image alt text to link text\n* Added an visited? method to WWW::Mechanize\n* Added Array#value= which will set the first value to the argument.  That\n  allows syntax as such:    form.fields.name('q').value = 'xyz'\n  Before it was like this:  form.fields.name('q').first.value = 'xyz'\n\n=== 0.4.5\n\n* Added support for multiple values of the same name\n* Updated build_query_string to take an array of arrays (Thanks Michal Janeczek)\n* Added WWW::Mechanize#body_filter= so that response bodies can be preprocessed\n* Added WWW::Page#body_filter= so that response bodies can be preprocessed\n* Added support for more date formats in the cookie parser\n* Fixed a bug with empty select lists\n* Fixing a problem with cookies not handling no spaces after semicolons\n\n=== 0.4.4\n\n* Fixed error in method signature, basic_authetication is now basic_auth\n* Fixed bug with encoding names in file uploads (Big thanks to Alex Young)\n* Added options to the select list\n\n=== 0.4.3\n\n* Added syntactic sugar for finding things\n* Fixed bug with HttpOnly option in cookies\n* Fixed a bug with cookie date parsing\n* Defaulted dropdown lists to the first element\n* Added unit tests\n\n=== 0.4.2\n\n* Added support for iframes\n* Made mechanize dependant on ruby-web rather than narf\n* Added unit tests\n* Fixed a bunch of warnings\n\n=== 0.4.1\n\n* Added support for file uploading\n* Added support for frames (Thanks Gabriel[mailto:leerbag@googlemail.com])\n* Added more unit tests\n* Fixed some bugs\n\n=== 0.4.0\n\n* Added more unit tests\n* Added a cookie jar with better cookie support, included expiration of cookies\n  and general cookie security.\n* Updated mechanize to use built in net/http if ruby version is new enough.\n* Added support for meta refresh tags\n* Defaulted form actions to 'GET'\n* Fixed various bugs\n* Added more unit tests\n* Added a response code exception\n* Thanks to Brian Ellin (brianellin@gmail.com) for:\n  Added support for CA files, and support for 301 response codes\n\n", "require 'mechanize/version'\nrequire 'fileutils'\nrequire 'forwardable'\nrequire 'mutex_m'\nrequire 'net/http/digest_auth'\nrequire 'net/http/persistent'\nrequire 'nokogiri'\nrequire 'openssl'\nrequire 'pp'\nrequire 'stringio'\nrequire 'uri'\nrequire 'webrick/httputils'\nrequire 'zlib'\n\n##\n# The Mechanize library is used for automating interactions with a website.  It\n# can follow links and submit forms.  Form fields can be populated and\n# submitted.  A history of URLs is maintained and can be queried.\n#\n# == Example\n#\n#   require 'mechanize'\n#   require 'logger'\n#\n#   agent = Mechanize.new\n#   agent.log = Logger.new \"mech.log\"\n#   agent.user_agent_alias = 'Mac Safari'\n#\n#   page = agent.get \"http://www.google.com/\"\n#   search_form = page.form_with :name => \"f\"\n#   search_form.field_with(:name => \"q\").value = \"Hello\"\n#\n#   search_results = agent.submit search_form\n#   puts search_results.body\n#\n# == Issues with mechanize\n#\n# If you think you have a bug with mechanize, but aren't sure, please file a\n# ticket at https://github.com/sparklemotion/mechanize/issues\n#\n# Here are some common problems you may experience with mechanize\n#\n# === Problems connecting to SSL sites\n#\n# Mechanize defaults to validating SSL certificates using the default CA\n# certificates for your platform.  At this time, Windows users do not have\n# integration between the OS default CA certificates and OpenSSL.  #cert_store\n# explains how to download and use Mozilla's CA certificates to allow SSL\n# sites to work.\n#\n# === Problems with content-length\n#\n# Some sites return an incorrect content-length value.  Unlike a browser,\n# mechanize raises an error when the content-length header does not match the\n# response length since it does not know if there was a connection problem or\n# if the mismatch is a server bug.\n#\n# The error raised, Mechanize::ResponseReadError, can be converted to a parsed\n# Page, File, etc. depending upon the content-type:\n#\n#   agent = Mechanize.new\n#   uri = URI 'http://example/invalid_content_length'\n#\n#   begin\n#     page = agent.get uri\n#   rescue Mechanize::ResponseReadError => e\n#     page = e.force_parse\n#   end\n\nclass Mechanize\n\n  ##\n  # Base mechanize error class\n\n  class Error < RuntimeError\n  end\n\n  ruby_version = if RUBY_PATCHLEVEL >= 0 then\n                   \"#{RUBY_VERSION}p#{RUBY_PATCHLEVEL}\"\n                 else\n                   \"#{RUBY_VERSION}dev#{RUBY_REVISION}\"\n                 end\n\n  ##\n  # Supported User-Agent aliases for use with user_agent_alias=.  The\n  # description in parenthesis is for informative purposes and is not part of\n  # the alias name.\n  #\n  # * Linux Firefox (43.0 on Ubuntu Linux)\n  # * Linux Konqueror (3)\n  # * Linux Mozilla\n  # * Mac Firefox (43.0)\n  # * Mac Mozilla\n  # * Mac Safari (9.0 on OS X 10.11.2)\n  # * Mac Safari 4\n  # * Mechanize (default)\n  # * Windows IE 6\n  # * Windows IE 7\n  # * Windows IE 8\n  # * Windows IE 9\n  # * Windows IE 10 (Windows 8 64bit)\n  # * Windows IE 11 (Windows 8.1 64bit)\n  # * Windows Edge\n  # * Windows Mozilla\n  # * Windows Firefox (43.0)\n  # * iPhone (iOS 9.1)\n  # * iPad (iOS 9.1)\n  # * Android (5.1.1)\n  #\n  # Example:\n  #\n  #   agent = Mechanize.new\n  #   agent.user_agent_alias = 'Mac Safari'\n\n  AGENT_ALIASES = {\n    'Mechanize' => \"Mechanize/#{VERSION} Ruby/#{ruby_version} (http://github.com/sparklemotion/mechanize/)\",\n    'Linux Firefox' => 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'Linux Konqueror' => 'Mozilla/5.0 (compatible; Konqueror/3; Linux)',\n    'Linux Mozilla' => 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.4) Gecko/20030624',\n    'Mac Firefox' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'Mac Mozilla' => 'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.4a) Gecko/20030401',\n    'Mac Safari 4' => 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; de-at) AppleWebKit/531.21.8 (KHTML, like Gecko) Version/4.0.4 Safari/531.21.10',\n    'Mac Safari' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9',\n    'Windows Chrome' => 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.125 Safari/537.36',\n    'Windows IE 6' => 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',\n    'Windows IE 7' => 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',\n    'Windows IE 8' => 'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',\n    'Windows IE 9' => 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)',\n    'Windows IE 10' => 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)',\n    'Windows IE 11' => 'Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko',\n    'Windows Edge' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586',\n    'Windows Mozilla' => 'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.4b) Gecko/20030516 Mozilla Firebird/0.6',\n    'Windows Firefox' => 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0',\n    'iPhone' => 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B5110e Safari/601.1',\n    'iPad' => 'Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1',\n    'Android' => 'Mozilla/5.0 (Linux; Android 5.1.1; Nexus 7 Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.76 Safari/537.36',\n  }\n\n  AGENT_ALIASES.default_proc = proc { |hash, key|\n    case key\n    when /FireFox/\n      if ua = hash[nkey = key.sub(/FireFox/, 'Firefox')]\n        warn \"Mechanize#user_agent_alias: #{key.inspect} should be spelled as #{nkey.inspect}\"\n        ua\n      end\n    end\n  }\n\n  def self.inherited(child) # :nodoc:\n    child.html_parser = html_parser\n    child.log = log\n    super\n  end\n\n  ##\n  # Creates a new Mechanize instance and yields it to the given block.\n  #\n  # After the block executes, the instance is cleaned up. This includes\n  # closing all open connections.\n  #\n  #   Mechanize.start do |m|\n  #     m.get(\"http://example.com\")\n  #   end\n\n  def self.start\n    instance = new\n    yield(instance)\n  ensure\n    instance.shutdown\n  end\n\n  ##\n  # Creates a new mechanize instance.  If a block is given, the created\n  # instance is yielded to the block for setting up pre-connection state such\n  # as SSL parameters or proxies:\n  #\n  #   agent = Mechanize.new do |a|\n  #     a.proxy_addr = 'proxy.example'\n  #     a.proxy_port = 8080\n  #   end\n  #\n  # If you need segregated SSL connections give each agent a unique\n  # name.  Otherwise the connections will be shared.  This is\n  # particularly important if you are using certifcates.\n  #\n  #    agent_1 = Mechanize.new 'conn1'\n  #    agent_2 = Mechanize.new 'conn2'\n  #\n\n  def initialize(connection_name = 'mechanize')\n    @agent = Mechanize::HTTP::Agent.new(connection_name)\n    @agent.context = self\n    @log = nil\n\n    # attr_accessors\n    @agent.user_agent = AGENT_ALIASES['Mechanize']\n    @watch_for_set    = nil\n    @history_added    = nil\n\n    # attr_readers\n    @pluggable_parser = PluggableParser.new\n\n    @keep_alive_time  = 0\n\n    # Proxy\n    @proxy_addr = nil\n    @proxy_port = nil\n    @proxy_user = nil\n    @proxy_pass = nil\n\n    @html_parser = self.class.html_parser\n\n    @default_encoding = nil\n    @force_default_encoding = false\n\n    # defaults\n    @agent.max_history = 50\n\n    yield self if block_given?\n\n    @agent.set_proxy @proxy_addr, @proxy_port, @proxy_user, @proxy_pass\n  end\n\n  # :section: History\n  #\n  # Methods for navigating and controlling history\n\n  ##\n  # Equivalent to the browser back button.  Returns the previous page visited.\n\n  def back\n    @agent.history.pop\n  end\n\n  ##\n  # Returns the latest page loaded by Mechanize\n\n  def current_page\n    @agent.current_page\n  end\n\n  alias page current_page\n\n  ##\n  # The history of this mechanize run\n\n  def history\n    @agent.history\n  end\n\n  ##\n  # Maximum number of items allowed in the history.  The default setting is 50\n  # pages.  Note that the size of the history multiplied by the maximum\n  # response body size\n\n  def max_history\n    @agent.history.max_size\n  end\n\n  ##\n  # Sets the maximum number of items allowed in the history to +length+.\n  #\n  # Setting the maximum history length to nil will make the history size\n  # unlimited.  Take care when doing this, mechanize stores response bodies in\n  # memory for pages and in the temporary files directory for other responses.\n  # For a long-running mechanize program this can be quite large.\n  #\n  # See also the discussion under #max_file_buffer=\n\n  def max_history= length\n    @agent.history.max_size = length\n  end\n\n  ##\n  # Returns a visited page for the +url+ passed in, otherwise nil\n\n  def visited? url\n    url = url.href if url.respond_to? :href\n\n    @agent.visited_page url\n  end\n\n  ##\n  # Returns whether or not a url has been visited\n\n  alias visited_page visited?\n\n  # :section: Hooks\n  #\n  # Hooks into the operation of mechanize\n\n  ##\n  # A list of hooks to call before reading response header 'content-encoding'.\n  #\n  # The hook is called with the agent making the request, the URI of the\n  # request, the response an IO containing the response body.\n\n  def content_encoding_hooks\n    @agent.content_encoding_hooks\n  end\n\n  ##\n  # Callback which is invoked with the page that was added to history.\n\n  attr_accessor :history_added\n\n  ##\n  # A list of hooks to call after retrieving a response. Hooks are called with\n  # the agent, the URI, the response, and the response body.\n\n  def post_connect_hooks\n    @agent.post_connect_hooks\n  end\n\n  ##\n  # A list of hooks to call before retrieving a response. Hooks are called\n  # with the agent, the URI, the response, and the response body.\n\n  def pre_connect_hooks\n    @agent.pre_connect_hooks\n  end\n\n  # :section: Requests\n  #\n  # Methods for making HTTP requests\n\n  ##\n  # If the parameter is a string, finds the button or link with the\n  # value of the string on the current page and clicks it.  Otherwise, clicks\n  # the Mechanize::Page::Link object passed in.  Returns the page fetched.\n\n  def click link\n    case link\n    when Page::Link then\n      referer = link.page || current_page()\n      if @agent.robots\n        if (referer.is_a?(Page) and referer.parser.nofollow?) or\n           link.rel?('nofollow') then\n          raise RobotsDisallowedError.new(link.href)\n        end\n      end\n      if link.noreferrer?\n        href = @agent.resolve(link.href, link.page || current_page)\n        referer = Page.new\n      else\n        href = link.href\n      end\n      get href, [], referer\n    when String, Regexp then\n      if real_link = page.link_with(:text => link)\n        click real_link\n      else\n        button = nil\n        # Note that this will not work if we have since navigated to a different page.\n        # Should rather make each button aware of its parent form.\n        form = page.forms.find do |f|\n          button = f.button_with(:value => link)\n          button.is_a? Form::Submit\n        end\n        submit form, button if form\n      end\n    when Form::Submit, Form::ImageButton then\n      # Note that this will not work if we have since navigated to a different page.\n      # Should rather make each button aware of its parent form.\n      form = page.forms.find do |f|\n        f.buttons.include?(link)\n      end\n      submit form, link if form\n    else\n      referer = current_page()\n      href = link.respond_to?(:href) ? link.href :\n        (link['href'] || link['src'])\n      get href, [], referer\n    end\n  end\n\n  ##\n  # GETs +uri+ and writes it to +io_or_filename+ without recording the request\n  # in the history.  If +io_or_filename+ does not respond to #write it will be\n  # used as a file name.  +parameters+, +referer+ and +headers+ are used as in\n  # #get.\n  #\n  # By default, if the Content-type of the response matches a Mechanize::File\n  # or Mechanize::Page parser, the response body will be loaded into memory\n  # before being saved.  See #pluggable_parser for details on changing this\n  # default.\n  #\n  # For alternate ways of downloading files see Mechanize::FileSaver and\n  # Mechanize::DirectorySaver.\n\n  def download uri, io_or_filename, parameters = [], referer = nil, headers = {}\n    page = transact do\n      get uri, parameters, referer, headers\n    end\n\n    io = if io_or_filename.respond_to? :write then\n           io_or_filename\n         else\n           ::File.open(io_or_filename, 'wb')\n         end\n\n    case page\n    when Mechanize::File then\n      io.write page.body\n    else\n      body_io = page.body_io\n\n      until body_io.eof? do\n        io.write body_io.read 16384\n      end\n    end\n\n    page\n  ensure\n    io.close if io and not io_or_filename.respond_to? :write\n  end\n\n  ##\n  # DELETE +uri+ with +query_params+, and setting +headers+:\n  #\n  # +query_params+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  #   delete('http://example/', {'q' => 'foo'}, {})\n\n  def delete(uri, query_params = {}, headers = {})\n    page = @agent.fetch(uri, :delete, headers, query_params)\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # GET the +uri+ with the given request +parameters+, +referer+ and\n  # +headers+.\n  #\n  # The +referer+ may be a URI or a page.\n  #\n  # +parameters+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n\n  def get(uri, parameters = [], referer = nil, headers = {})\n    method = :get\n\n    referer ||=\n      if uri.to_s =~ %r{\\Ahttps?://}\n        Page.new\n      else\n        current_page || Page.new\n      end\n\n    # FIXME: Huge hack so that using a URI as a referer works.  I need to\n    # refactor everything to pass around URIs but still support\n    # Mechanize::Page#base\n    unless Mechanize::Parser === referer then\n      referer = if referer.is_a?(String) then\n                  Page.new URI(referer)\n                else\n                  Page.new referer\n                end\n    end\n\n    # fetch the page\n    headers ||= {}\n    page = @agent.fetch uri, method, headers, parameters, referer\n    add_to_history(page)\n    yield page if block_given?\n    page\n  end\n\n  ##\n  # GET +url+ and return only its contents\n\n  def get_file(url)\n    get(url).body\n  end\n\n  ##\n  # HEAD +uri+ with +query_params+ and +headers+:\n  #\n  # +query_params+ is formatted into a query string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  #   head('http://example/', {'q' => 'foo'}, {})\n\n  def head(uri, query_params = {}, headers = {})\n    page = @agent.fetch uri, :head, headers, query_params\n\n    yield page if block_given?\n\n    page\n  end\n\n  ##\n  # POST to the given +uri+ with the given +query+.\n  #\n  # +query+ is processed using Mechanize::Util.each_parameter (which\n  # see), and then encoded into an entity body.  If any IO/FileUpload\n  # object is specified as a field value the \"enctype\" will be\n  # multipart/form-data, or application/x-www-form-urlencoded\n  # otherwise.\n  #\n  # Examples:\n  #   agent.post 'http://example.com/', \"foo\" => \"bar\"\n  #\n  #   agent.post 'http://example.com/', [%w[foo bar]]\n  #\n  #   agent.post('http://example.com/', \"<message>hello</message>\",\n  #              'Content-Type' => 'application/xml')\n\n  def post(uri, query = {}, headers = {})\n    return request_with_entity(:post, uri, query, headers) if String === query\n\n    node = {}\n    # Create a fake form\n    class << node\n      def search(*args); []; end\n    end\n    node['method'] = 'POST'\n    node['enctype'] = 'application/x-www-form-urlencoded'\n\n    form = Form.new(node)\n\n    Mechanize::Util.each_parameter(query) { |k, v|\n      if v.is_a?(IO)\n        form.enctype = 'multipart/form-data'\n        ul = Form::FileUpload.new({'name' => k.to_s},::File.basename(v.path))\n        ul.file_data = v.read\n        form.file_uploads << ul\n      elsif v.is_a?(Form::FileUpload)\n        form.enctype = 'multipart/form-data'\n        form.file_uploads << v\n      else\n        form.fields << Form::Field.new({'name' => k.to_s},v)\n      end\n    }\n    post_form(uri, form, headers)\n  end\n\n  ##\n  # PUT to +uri+ with +entity+, and setting +headers+:\n  #\n  #   put('http://example/', 'new content', {'Content-Type' => 'text/plain'})\n\n  def put(uri, entity, headers = {})\n    request_with_entity(:put, uri, entity, headers)\n  end\n\n  ##\n  # Makes an HTTP request to +url+ using HTTP method +verb+.  +entity+ is used\n  # as the request body, if allowed.\n\n  def request_with_entity(verb, uri, entity, headers = {})\n    cur_page = current_page || Page.new\n\n    log.debug(\"query: #{ entity.inspect }\") if log\n\n    headers = {\n      'Content-Type' => 'application/octet-stream',\n      'Content-Length' => entity.size.to_s,\n    }.update headers\n\n    page = @agent.fetch uri, verb, headers, [entity], cur_page\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # Submits +form+ with an optional +button+.\n  #\n  # Without a button:\n  #\n  #   page = agent.get('http://example.com')\n  #   agent.submit(page.forms.first)\n  #\n  # With a button:\n  #\n  #   agent.submit(page.forms.first, page.forms.first.buttons.first)\n\n  def submit(form, button = nil, headers = {})\n    form.add_button_to_query(button) if button\n\n    case form.method.upcase\n    when 'POST'\n      post_form(form.action, form, headers)\n    when 'GET'\n      get(form.action.gsub(/\\?[^\\?]*$/, ''),\n          form.build_query,\n          form.page,\n          headers)\n    else\n      raise ArgumentError, \"unsupported method: #{form.method.upcase}\"\n    end\n  end\n\n  ##\n  # Runs given block, then resets the page history as it was before. self is\n  # given as a parameter to the block.  Returns the value of the block.\n\n  def transact\n    history_backup = @agent.history.dup\n    begin\n      yield self\n    ensure\n      @agent.history = history_backup\n    end\n  end\n\n  # :section: Settings\n  #\n  # Settings that adjust how mechanize makes HTTP requests including timeouts,\n  # keep-alives, compression, redirects and headers.\n\n  @html_parser = Nokogiri::HTML\n  @log = nil\n\n  class << self\n\n    ##\n    # Default HTML parser for all mechanize instances\n    #\n    #   Mechanize.html_parser = Nokogiri::XML\n\n    attr_accessor :html_parser\n\n    ##\n    # Default logger for all mechanize instances\n    #\n    #   Mechanize.log = Logger.new $stderr\n\n    attr_accessor :log\n\n  end\n\n  ##\n  # A default encoding name used when parsing HTML parsing.  When set it is\n  # used after any other encoding.  The default is nil.\n\n  attr_accessor :default_encoding\n\n  ##\n  # Overrides the encodings given by the HTTP server and the HTML page with\n  # the default_encoding when set to true.\n\n  attr_accessor :force_default_encoding\n\n  ##\n  # The HTML parser to be used when parsing documents\n\n  attr_accessor :html_parser\n\n  ##\n  # HTTP/1.0 keep-alive time.  This is no longer supported by mechanize as it\n  # now uses net-http-persistent which only supports HTTP/1.1 persistent\n  # connections\n\n  attr_accessor :keep_alive_time\n\n  ##\n  # The pluggable parser maps a response Content-Type to a parser class.  The\n  # registered Content-Type may be either a full content type like 'image/png'\n  # or a media type 'text'.  See Mechanize::PluggableParser for further\n  # details.\n  #\n  # Example:\n  #\n  #   agent.pluggable_parser['application/octet-stream'] = Mechanize::Download\n\n  attr_reader :pluggable_parser\n\n  ##\n  # The HTTP proxy address\n\n  attr_reader :proxy_addr\n\n  ##\n  # The HTTP proxy password\n\n  attr_reader :proxy_pass\n\n  ##\n  # The HTTP proxy port\n\n  attr_reader :proxy_port\n\n  ##\n  # The HTTP proxy username\n\n  attr_reader :proxy_user\n\n  ##\n  # *NOTE*: These credentials will be used as a default for any challenge\n  # exposing your password to disclosure to malicious servers.  Use of this\n  # method will warn.  This method is deprecated and will be removed in\n  # mechanize 3.\n  #\n  # Sets the +user+ and +password+ as the default credentials to be used for\n  # HTTP authentication for any server.  The +domain+ is used for NTLM\n  # authentication.\n\n  def auth user, password, domain = nil\n    caller.first =~ /(.*?):(\\d+).*?$/\n\n    warn <<-WARNING\nAt #{$1} line #{$2}\n\nUse of #auth and #basic_auth are deprecated due to a security vulnerability.\n\n    WARNING\n\n    @agent.add_default_auth user, password, domain\n  end\n\n  alias basic_auth auth\n\n  ##\n  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the\n  # credentials are used only for that realm.  If +realm+ is not set the\n  # credentials become the default for any realm on that URI.\n  #\n  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If\n  # +domain+ is given it is only used for NTLM authentication.\n\n  def add_auth uri, user, password, realm = nil, domain = nil\n    @agent.add_auth uri, user, password, realm, domain\n  end\n\n  ##\n  # Are If-Modified-Since conditional requests enabled?\n\n  def conditional_requests\n    @agent.conditional_requests\n  end\n\n  ##\n  # Disables If-Modified-Since conditional requests (enabled by default)\n\n  def conditional_requests= enabled\n    @agent.conditional_requests = enabled\n  end\n\n  ##\n  # A Mechanize::CookieJar which stores cookies\n\n  def cookie_jar\n    @agent.cookie_jar\n  end\n\n  ##\n  # Replaces the cookie jar with +cookie_jar+\n\n  def cookie_jar= cookie_jar\n    @agent.cookie_jar = cookie_jar\n  end\n\n  ##\n  # Returns a list of cookies stored in the cookie jar.\n\n  def cookies\n    @agent.cookie_jar.to_a\n  end\n\n  ##\n  # Follow HTML meta refresh and HTTP Refresh headers.  If set to +:anywhere+\n  # meta refresh tags outside of the head element will be followed.\n\n  def follow_meta_refresh\n    @agent.follow_meta_refresh\n  end\n\n  ##\n  # Controls following of HTML meta refresh and HTTP Refresh headers in\n  # responses.\n\n  def follow_meta_refresh= follow\n    @agent.follow_meta_refresh = follow\n  end\n\n  ##\n  # Follow an HTML meta refresh and HTTP Refresh headers that have no \"url=\"\n  # in the content attribute.\n  #\n  # Defaults to false to prevent infinite refresh loops.\n\n  def follow_meta_refresh_self\n    @agent.follow_meta_refresh_self\n  end\n\n  ##\n  # Alters the following of HTML meta refresh and HTTP Refresh headers that\n  # point to the same page.\n\n  def follow_meta_refresh_self= follow\n    @agent.follow_meta_refresh_self = follow\n  end\n\n  ##\n  # Is gzip compression of responses enabled?\n\n  def gzip_enabled\n    @agent.gzip_enabled\n  end\n\n  ##\n  # Disables HTTP/1.1 gzip compression (enabled by default)\n\n  def gzip_enabled=enabled\n    @agent.gzip_enabled = enabled\n  end\n\n  ##\n  # Connections that have not been used in this many seconds will be reset.\n\n  def idle_timeout\n    @agent.idle_timeout\n  end\n\n  # Sets the idle timeout to +idle_timeout+.  The default timeout is 5\n  # seconds.  If you experience \"too many connection resets\", reducing this\n  # value may help.\n\n  def idle_timeout= idle_timeout\n    @agent.idle_timeout = idle_timeout\n  end\n\n  ##\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding so long as at least one byte was received.  Be careful when\n  # enabling this as it may cause data loss.\n  #\n  # Net::HTTP does not inform mechanize of where in the chunked stream the EOF\n  # occurred.  Usually it is after the last-chunk but before the terminating\n  # CRLF (invalid termination) but it may occur earlier.  In the second case\n  # your response body may be incomplete.\n\n  def ignore_bad_chunking\n    @agent.ignore_bad_chunking\n  end\n\n  ##\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding.  See ignore_bad_chunking for further details\n\n  def ignore_bad_chunking= ignore_bad_chunking\n    @agent.ignore_bad_chunking = ignore_bad_chunking\n  end\n\n  ##\n  # Are HTTP/1.1 keep-alive connections enabled?\n\n  def keep_alive\n    @agent.keep_alive\n  end\n\n  ##\n  # Disable HTTP/1.1 keep-alive connections if +enable+ is set to false.  If\n  # you are experiencing \"too many connection resets\" errors setting this to\n  # false will eliminate them.\n  #\n  # You should first investigate reducing idle_timeout.\n\n  def keep_alive= enable\n    @agent.keep_alive = enable\n  end\n\n  ##\n  # The current logger.  If no logger has been set Mechanize.log is used.\n\n  def log\n    @log || Mechanize.log\n  end\n\n  ##\n  # Sets the +logger+ used by this instance of mechanize\n\n  def log= logger\n    @log = logger\n  end\n\n  ##\n  # Responses larger than this will be written to a Tempfile instead of stored\n  # in memory.  The default is 100,000 bytes.\n  #\n  # A value of nil disables creation of Tempfiles.\n\n  def max_file_buffer\n    @agent.max_file_buffer\n  end\n\n  ##\n  # Sets the maximum size of a response body that will be stored in memory to\n  # +bytes+.  A value of nil causes all response bodies to be stored in\n  # memory.\n  #\n  # Note that for Mechanize::Download subclasses, the maximum buffer size\n  # multiplied by the number of pages stored in history (controlled by\n  # #max_history) is an approximate upper limit on the amount of memory\n  # Mechanize will use.  By default, Mechanize can use up to ~5MB to store\n  # response bodies for non-File and non-Page (HTML) responses.\n  #\n  # See also the discussion under #max_history=\n\n  def max_file_buffer= bytes\n    @agent.max_file_buffer = bytes\n  end\n\n  ##\n  # Length of time to wait until a connection is opened in seconds\n\n  def open_timeout\n    @agent.open_timeout\n  end\n\n  ##\n  # Sets the connection open timeout to +open_timeout+\n\n  def open_timeout= open_timeout\n    @agent.open_timeout = open_timeout\n  end\n\n  ##\n  # Length of time to wait for data from the server\n\n  def read_timeout\n    @agent.read_timeout\n  end\n\n  ##\n  # Sets the timeout for each chunk of data read from the server to\n  # +read_timeout+.  A single request may read many chunks of data.\n\n  def read_timeout= read_timeout\n    @agent.read_timeout = read_timeout\n  end\n\n  ##\n  # Controls how mechanize deals with redirects.  The following values are\n  # allowed:\n  #\n  # :all, true:: All 3xx redirects are followed (default)\n  # :permanent:: Only 301 Moved Permanantly redirects are followed\n  # false:: No redirects are followed\n\n  def redirect_ok\n    @agent.redirect_ok\n  end\n\n  alias follow_redirect? redirect_ok\n\n  ##\n  # Sets the mechanize redirect handling policy.  See redirect_ok for allowed\n  # values\n\n  def redirect_ok= follow\n    @agent.redirect_ok = follow\n  end\n\n  alias follow_redirect= redirect_ok=\n\n  ##\n  # Maximum number of redirections to follow\n\n  def redirection_limit\n    @agent.redirection_limit\n  end\n\n  ##\n  # Sets the maximum number of redirections to follow to +limit+\n\n  def redirection_limit= limit\n    @agent.redirection_limit = limit\n  end\n\n  ##\n  # Resolve the full path of a link / uri\n  def resolve link\n    @agent.resolve link\n  end\n\n  ##\n  # A hash of custom request headers that will be sent on every request\n\n  def request_headers\n    @agent.request_headers\n  end\n\n  ##\n  # Replaces the custom request headers that will be sent on every request\n  # with +request_headers+\n\n  def request_headers= request_headers\n    @agent.request_headers = request_headers\n  end\n\n  ##\n  # Retry POST and other non-idempotent requests.  See RFC 2616 9.1.2.\n\n  def retry_change_requests\n    @agent.retry_change_requests\n  end\n\n  ##\n  # When setting +retry_change_requests+ to true you are stating that, for all\n  # the URLs you access with mechanize, making POST and other non-idempotent\n  # requests is safe and will not cause data duplication or other harmful\n  # results.\n  #\n  # If you are experiencing \"too many connection resets\" errors you should\n  # instead investigate reducing the idle_timeout or disabling keep_alive\n  # connections.\n\n  def retry_change_requests= retry_change_requests\n    @agent.retry_change_requests = retry_change_requests\n  end\n\n  ##\n  # Will <code>/robots.txt</code> files be obeyed?\n\n  def robots\n    @agent.robots\n  end\n\n  ##\n  # When +enabled+ mechanize will retrieve and obey <code>robots.txt</code>\n  # files\n\n  def robots= enabled\n    @agent.robots = enabled\n  end\n\n  ##\n  # The handlers for HTTP and other URI protocols.\n\n  def scheme_handlers\n    @agent.scheme_handlers\n  end\n\n  ##\n  # Replaces the URI scheme handler table with +scheme_handlers+\n\n  def scheme_handlers= scheme_handlers\n    @agent.scheme_handlers = scheme_handlers\n  end\n\n  ##\n  # The identification string for the client initiating a web request\n\n  def user_agent\n    @agent.user_agent\n  end\n\n  ##\n  # Sets the User-Agent used by mechanize to +user_agent+.  See also\n  # user_agent_alias\n\n  def user_agent= user_agent\n    @agent.user_agent = user_agent\n  end\n\n  ##\n  # Set the user agent for the Mechanize object based on the given +name+.\n  #\n  # See also AGENT_ALIASES\n\n  def user_agent_alias= name\n    self.user_agent = AGENT_ALIASES[name] ||\n      raise(ArgumentError, \"unknown agent alias #{name.inspect}\")\n  end\n\n  ##\n  # The value of watch_for_set is passed to pluggable parsers for retrieved\n  # content\n\n  attr_accessor :watch_for_set\n\n  # :section: SSL\n  #\n  # SSL settings for mechanize.  These must be set in the block given to\n  # Mechanize.new\n\n  ##\n  # Path to an OpenSSL server certificate file\n\n  def ca_file\n    @agent.ca_file\n  end\n\n  ##\n  # Sets the certificate file used for SSL connections\n\n  def ca_file= ca_file\n    @agent.ca_file = ca_file\n  end\n\n  ##\n  # An OpenSSL client certificate or the path to a certificate file.\n\n  def cert\n    @agent.certificate\n  end\n\n  ##\n  # Sets the OpenSSL client certificate +cert+ to the given path or\n  # certificate instance\n\n  def cert= cert\n    @agent.certificate = cert\n  end\n\n  ##\n  # An OpenSSL certificate store for verifying server certificates.  This\n  # defaults to the default certificate store for your system.\n  #\n  # If your system does not ship with a default set of certificates you can\n  # retrieve a copy of the set from Mozilla here:\n  # http://curl.haxx.se/docs/caextract.html\n  #\n  # (Note that this set does not have an HTTPS download option so you may\n  # wish to use the firefox-db2pem.sh script to extract the certificates\n  # from a local install to avoid man-in-the-middle attacks.)\n  #\n  # After downloading or generating a cacert.pem from the above link you\n  # can create a certificate store from the pem file like this:\n  #\n  #   cert_store = OpenSSL::X509::Store.new\n  #   cert_store.add_file 'cacert.pem'\n  #\n  # And have mechanize use it with:\n  #\n  #   agent.cert_store = cert_store\n\n  def cert_store\n    @agent.cert_store\n  end\n\n  ##\n  # Sets the OpenSSL certificate store to +store+.\n  #\n  # See also #cert_store\n\n  def cert_store= cert_store\n    @agent.cert_store = cert_store\n  end\n\n  ##\n  # What is this?\n  #\n  # Why is it different from #cert?\n\n  def certificate # :nodoc:\n    @agent.certificate\n  end\n\n  ##\n  # An OpenSSL private key or the path to a private key\n\n  def key\n    @agent.private_key\n  end\n\n  ##\n  # Sets the OpenSSL client +key+ to the given path or key instance.  If a\n  # path is given, the path must contain an RSA key file.\n\n  def key= key\n    @agent.private_key = key\n  end\n\n  ##\n  # OpenSSL client key password\n\n  def pass\n    @agent.pass\n  end\n\n  ##\n  # Sets the client key password to +pass+\n\n  def pass= pass\n    @agent.pass = pass\n  end\n\n  ##\n  # SSL version to use.\n\n  def ssl_version\n    @agent.ssl_version\n  end\n\n  ##\n  # Sets the SSL version to use to +version+ without client/server\n  # negotiation.\n\n  def ssl_version= ssl_version\n    @agent.ssl_version = ssl_version\n  end\n\n  ##\n  # A callback for additional certificate verification.  See\n  # OpenSSL::SSL::SSLContext#verify_callback\n  #\n  # The callback can be used for debugging or to ignore errors by always\n  # returning +true+.  Specifying nil uses the default method that was valid\n  # when the SSLContext was created\n\n  def verify_callback\n    @agent.verify_callback\n  end\n\n  ##\n  # Sets the OpenSSL certificate verification callback\n\n  def verify_callback= verify_callback\n    @agent.verify_callback = verify_callback\n  end\n\n  ##\n  # the OpenSSL server certificate verification method.  The default is\n  # OpenSSL::SSL::VERIFY_PEER and certificate verification uses the default\n  # system certificates.  See also cert_store\n\n  def verify_mode\n    @agent.verify_mode\n  end\n\n  ##\n  # Sets the OpenSSL server certificate verification method.\n\n  def verify_mode= verify_mode\n    @agent.verify_mode = verify_mode\n  end\n\n  # :section: Utilities\n\n  attr_reader :agent # :nodoc:\n\n  ##\n  # Parses the +body+ of the +response+ from +uri+ using the pluggable parser\n  # that matches its content type\n\n  def parse uri, response, body\n    content_type = nil\n\n    unless response['Content-Type'].nil?\n      data, = response['Content-Type'].split ';', 2\n      content_type, = data.downcase.split ',', 2 unless data.nil?\n    end\n\n    parser_klass = @pluggable_parser.parser content_type\n\n    unless parser_klass <= Mechanize::Download then\n      body = case body\n             when IO, Tempfile, StringIO then\n               body.read\n             else\n               body\n             end\n    end\n\n    parser_klass.new uri, response, body, response.code do |parser|\n      parser.mech = self if parser.respond_to? :mech=\n\n      parser.watch_for_set = @watch_for_set if\n        @watch_for_set and parser.respond_to?(:watch_for_set=)\n    end\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.object_group(self) {\n      q.breakable\n      q.pp cookie_jar\n      q.breakable\n      q.pp current_page\n    }\n  end\n\n  ##\n  # Sets the proxy +address+ at +port+ with an optional +user+ and +password+\n\n  def set_proxy address, port, user = nil, password = nil\n    @proxy_addr = address\n    @proxy_port = port\n    @proxy_user = user\n    @proxy_pass = password\n\n    @agent.set_proxy address, port, user, password\n  end\n\n  ##\n  # Clears history and cookies.\n\n  def reset\n    @agent.reset\n  end\n\n  ##\n  # Shuts down this session by clearing browsing state and closing all\n  # persistent connections.\n\n  def shutdown\n    reset\n    @agent.shutdown\n  end\n\n  private\n\n  ##\n  # Posts +form+ to +uri+\n\n  def post_form(uri, form, headers = {})\n    cur_page = form.page || current_page ||\n      Page.new\n\n    request_data = form.request_data\n\n    log.debug(\"query: #{ request_data.inspect }\") if log\n\n    headers = {\n      'Content-Type'    => form.enctype,\n      'Content-Length'  => request_data.size.to_s,\n    }.merge headers\n\n    # fetch the page\n    page = @agent.fetch uri, :post, headers, [request_data], cur_page\n    add_to_history(page)\n    page\n  end\n\n  ##\n  # Adds +page+ to the history\n\n  def add_to_history(page)\n    @agent.history.push(page, @agent.resolve(page.uri))\n    @history_added.call(page) if @history_added\n  end\n\nend\n\nrequire 'mechanize/element_not_found_error'\nrequire 'mechanize/response_read_error'\nrequire 'mechanize/chunked_termination_error'\nrequire 'mechanize/content_type_error'\nrequire 'mechanize/cookie'\nrequire 'mechanize/cookie_jar'\nrequire 'mechanize/parser'\nrequire 'mechanize/download'\nrequire 'mechanize/directory_saver'\nrequire 'mechanize/file'\nrequire 'mechanize/file_connection'\nrequire 'mechanize/file_request'\nrequire 'mechanize/file_response'\nrequire 'mechanize/form'\nrequire 'mechanize/history'\nrequire 'mechanize/http'\nrequire 'mechanize/http/agent'\nrequire 'mechanize/http/auth_challenge'\nrequire 'mechanize/http/auth_realm'\nrequire 'mechanize/http/content_disposition_parser'\nrequire 'mechanize/http/www_authenticate_parser'\nrequire 'mechanize/image'\nrequire 'mechanize/page'\nrequire 'mechanize/pluggable_parsers'\nrequire 'mechanize/redirect_limit_reached_error'\nrequire 'mechanize/redirect_not_get_or_head_error'\nrequire 'mechanize/response_code_error'\nrequire 'mechanize/robots_disallowed_error'\nrequire 'mechanize/unauthorized_error'\nrequire 'mechanize/unsupported_scheme_error'\nrequire 'mechanize/util'\n\n", "warn 'mechanize/cookie_jar will be deprecated.  Please migrate to the http-cookie APIs.' if $VERBOSE\n\nrequire 'http/cookie_jar'\nrequire 'http/cookie_jar/yaml_saver'\nrequire 'mechanize/cookie'\n\nclass Mechanize\n  module CookieJarIMethods\n    include CookieDeprecated\n\n    def add(arg1, arg2 = nil)\n      if arg2\n        __deprecated__ 'add and origin='\n        super arg2.dup.tap { |ncookie|\n          begin\n            ncookie.origin = arg1\n          rescue\n            return nil\n          end\n        }\n      else\n        super arg1\n      end\n    end\n\n    # See HTTP::CookieJar#add.\n    def add!(cookie)\n      __deprecated__ :add\n      cookie.domain.nil? and raise NoMethodError, 'raised for compatibility'\n      @store.add(cookie)\n      self\n    end\n\n    # See HTTP::CookieJar#save.\n    def save_as(filename, *options)\n      __deprecated__ :save\n      save(filename, *options)\n    end\n\n    # See HTTP::CookieJar#clear.\n    def clear!\n      __deprecated__ :clear\n      clear\n    end\n\n    # See HTTP::CookieJar#store.\n    def jar\n      __deprecated__ :store\n      @store.instance_variable_get(:@jar)\n    end\n\n    # See HTTP::CookieJar#load.\n    def load_cookiestxt(io)\n      __deprecated__ :load\n      load(io, :cookiestxt)\n    end\n\n    # See HTTP::CookieJar#save.\n    def dump_cookiestxt(io)\n      __deprecated__ :save\n      save(io, :cookiestxt)\n    end\n  end\n\n  class CookieJar < ::HTTP::CookieJar\n    def save(output, *options)\n      output.respond_to?(:write) or\n        return ::File.open(output, 'w') { |io| save(io, *options) }\n\n      opthash = {\n        :format => :yaml,\n        :session => false,\n      }\n      case options.size\n      when 0\n      when 1\n        case options = options.first\n        when Symbol\n          opthash[:format] = options\n        else\n          opthash.update(options) if options\n        end\n      when 2\n        opthash[:format], options = options\n        opthash.update(options) if options\n      else\n        raise ArgumentError, 'wrong number of arguments (%d for 1-3)' % (1 + options.size)\n      end\n\n      return super(output, opthash) if opthash[:format] != :yaml\n\n      session = opthash[:session]\n      nstore = HashStore.new\n\n      each { |cookie|\n        next if !session && cookie.session?\n\n        if cookie.max_age\n          cookie = cookie.dup\n          cookie.expires = cookie.expires # convert max_age to expires\n        end\n        nstore.add(cookie)\n      }\n\n      yaml = YAML.dump(nstore.instance_variable_get(:@jar))\n\n      # a gross hack\n      yaml.gsub!(%r{^(    [^ ].*: !ruby/object:)HTTP::Cookie$}) {\n        $1 + 'Mechanize::Cookie'\n      }\n      yaml.gsub!(%r{^(      expires: )(?:|!!null|(.+?)) *$}) {\n        $1 + ($2 ? Time.parse($2).httpdate : '')\n      }\n\n      output.write yaml\n\n      self\n    end\n\n    def load(input, *options)\n      input.respond_to?(:write) or\n        return ::File.open(input, 'r') { |io| load(io, *options) }\n\n      opthash = {\n        :format => :yaml,\n        :session => false,\n      }\n      case options.size\n      when 0\n      when 1\n        case options = options.first\n        when Symbol\n          opthash[:format] = options\n        else\n          if hash = Hash.try_convert(options)\n            opthash.update(hash)\n          end\n        end\n      when 2\n        opthash[:format], options = options\n        if hash = Hash.try_convert(options)\n          opthash.update(hash)\n        end\n      else\n        raise ArgumentError, 'wrong number of arguments (%d for 1-3)' % (1 + options.size)\n      end\n\n      return super(input, opthash) if opthash[:format] != :yaml\n\n      begin\n        data = YAML.load(input)\n      rescue ArgumentError\n        @logger.warn \"unloadable YAML cookie data discarded\" if @logger\n        return self\n      end\n\n      case data\n      when Array\n        # Forward compatibility\n        data.each { |cookie|\n          add(cookie)\n        }\n      when Hash\n        data.each { |domain, paths|\n          paths.each { |path, names|\n            names.each { |cookie_name, cookie|\n              add(cookie)\n            }\n          }\n        }\n      else\n        @logger.warn \"incompatible YAML cookie data discarded\" if @logger\n        return self\n      end\n    end\n  end\n\n  # Compatibility for Ruby 1.8/1.9\n  unless ::HTTP::CookieJar.respond_to?(:prepend, true)\n    require 'mechanize/prependable'\n\n    class ::HTTP::CookieJar\n      extend Prependable\n    end\n  end\n\n  class ::HTTP::CookieJar\n    prepend CookieJarIMethods\n  end\nend\n", "##\n# Download is a pluggable parser for downloading files without loading them\n# into memory first.  You may subclass this class to handle content types you\n# do not wish to load into memory first.\n#\n# See Mechanize::PluggableParser for instructions on using this class.\n\nclass Mechanize::Download\n\n  include Mechanize::Parser\n\n  ##\n  # The filename for this file based on the content-disposition of the\n  # response or the basename of the URL\n\n  attr_accessor :filename\n\n  ##\n  # Accessor for the IO-like that contains the body\n\n  attr_reader :body_io\n\n  alias content body_io\n\n  ##\n  # Creates a new download retrieved from the given +uri+ and +response+\n  # object.  The +body_io+ is an IO-like containing the HTTP response body and\n  # +code+ is the HTTP status.\n\n  def initialize uri = nil, response = nil, body_io = nil, code = nil\n    @uri      = uri\n    @body_io  = body_io\n    @code     = code\n\n    @full_path = false unless defined? @full_path\n\n    fill_header response\n    extract_filename\n\n    yield self if block_given?\n  end\n\n  ##\n  # The body of this response as a String.\n  #\n  # Take care, this may use lots of memory if the response body is large.\n\n  def body\n    @body_io.read.tap { @body_io.rewind }\n  end\n\n  ##\n  # Saves a copy of the body_io to +filename+\n  # returns the filename\n\n  def save filename = nil\n    filename = find_free_name filename\n    save! filename\n  end\n\n  alias save_as save\n\n  ##\n  # Use this method to save the content of body_io to +filename+.\n  # This method will overwrite any existing filename that exists with the\n  # same name.\n  # returns the filename\n\n  def save! filename = nil\n    filename ||= @filename\n    dirname = File.dirname filename\n    FileUtils.mkdir_p dirname\n\n    ::File.open(filename, 'wb')do |io|\n      until @body_io.eof? do\n        io.write @body_io.read 16384\n      end\n    end\n\n    filename\n  end\n\nend\n\n", "##\n# This is the base class for the Pluggable Parsers.  If Mechanize cannot find\n# an appropriate class to use for the content type, this class will be used.\n# For example, if you download an image/jpeg, Mechanize will not know how to\n# parse it, so this class will be instantiated.\n#\n# This is a good class to use as the base class for building your own\n# pluggable parsers.\n#\n# == Example\n#\n#   require 'mechanize'\n#\n#   agent = Mechanize.new\n#   agent.get('http://example.com/foo.jpg').class  #=> Mechanize::File\n\nclass Mechanize::File\n\n  include Mechanize::Parser\n\n  ##\n  # The HTTP response body, the raw file contents\n\n  attr_accessor :body\n\n  ##\n  # The filename for this file based on the content-disposition of the\n  # response or the basename of the URL\n\n  attr_accessor :filename\n\n  alias content body\n\n  ##\n  # Creates a new file retrieved from the given +uri+ and +response+ object.\n  # The +body+ is the HTTP response body and +code+ is the HTTP status.\n\n  def initialize uri = nil, response = nil, body = nil, code = nil\n    @uri  = uri\n    @body = body\n    @code = code\n\n    @full_path = false unless defined? @full_path\n\n    fill_header response\n    extract_filename\n\n    yield self if block_given?\n  end\n\n  ##\n  # Use this method to save the content of this object to +filename+.\n  # returns the filename\n  #\n  #   file.save 'index.html'\n  #   file.save 'index.html' # saves to index.html.1\n  #\n  #   uri = URI 'http://localhost/test.html'\n  #   file = Mechanize::File.new uri, nil, ''\n  #   filename = file.save  # saves to test.html\n  #   puts filename         # test.html\n\n  def save filename = nil\n    filename = find_free_name filename\n    save! filename\n  end\n\n  alias save_as save\n\n  ##\n  # Use this method to save the content of this object to +filename+.\n  # This method will overwrite any existing filename that exists with the\n  # same name.\n  # returns the filename\n  #\n  #   file.save 'index.html'\n  #   file.save! 'index.html' # overwrite original file\n  #   filename = file.save! 'index.html' # overwrite original file with filename 'index.html'\n\n  def save! filename = nil\n    filename ||= @filename\n    dirname = File.dirname filename\n    FileUtils.mkdir_p dirname\n\n    ::File.open(filename, 'wb')do |f|\n      f.write body\n    end\n\n    filename\n  end\n\nend\n\n", "##\n# Fake response for dealing with file:/// requests\n\nclass Mechanize::FileResponse\n\n  def initialize(file_path)\n    @file_path = file_path\n    @uri       = nil\n  end\n\n  def read_body\n    raise Mechanize::ResponseCodeError.new(self) unless\n      File.exist? @file_path\n\n    if directory?\n      yield dir_body\n    else\n      ::File.open(@file_path, 'rb') do |io|\n        yield io.read\n      end\n    end\n  end\n\n  def code\n    File.exist?(@file_path) ? 200 : 404\n  end\n\n  def content_length\n    return dir_body.length if directory?\n    File.exist?(@file_path) ? File.stat(@file_path).size : 0\n  end\n\n  def each_header; end\n\n  def [](key)\n    return nil if key.casecmp('Content-Type') != 0\n    return 'text/html' if directory?\n    return 'text/html' if ['.html', '.xhtml'].any? { |extn|\n      @file_path.end_with?(extn)\n    }\n    nil\n  end\n\n  def each\n  end\n\n  def get_fields(key)\n    []\n  end\n\n  def http_version\n    '0'\n  end\n\n  def message\n    File.exist?(@file_path) ? 'OK' : 'Not Found'\n  end\n\n  def uri\n    @uri ||= URI \"file://#{@file_path}\"\n  end\n\n  private\n\n  def dir_body\n    body = %w[<html><body>]\n    body.concat Dir[File.join(@file_path, '*')].map { |f|\n      \"<a href=\\\"file://#{f}\\\">#{File.basename(f)}</a>\"\n    }\n    body << %w[</body></html>]\n\n    body.join(\"\\n\").force_encoding(Encoding::BINARY)\n  end\n\n  def directory?\n    File.directory?(@file_path)\n  end\n\nend\n\n", "require 'mechanize'\nrequire 'logger'\nrequire 'tempfile'\nrequire 'tmpdir'\nrequire 'webrick'\nrequire 'zlib'\n\nrequire 'rubygems'\n\nbegin\n  gem 'minitest'\nrescue Gem::LoadError\nend\n\nrequire 'minitest/autorun'\n\nbegin\n  require 'minitest/pride'\nrescue LoadError\nend\n\n##\n# A generic test case for testing mechanize.  Using a subclass of\n# Mechanize::TestCase for your tests will create an isolated mechanize\n# instance that won't pollute your filesystem or other tests.\n#\n# Once Mechanize::TestCase is loaded no HTTP requests will be made outside\n# mechanize itself.  All requests are handled via WEBrick servlets.\n#\n# Mechanize uses WEBrick servlets to test some functionality.  You can run\n# other HTTP clients against the servlets using:\n#\n#   ruby -rmechanize/test_case/server -e0\n#\n# Which will launch a test server at http://localhost:8000\n\nclass Mechanize::TestCase < Minitest::Test\n\n  TEST_DIR = File.expand_path '../../../test', __FILE__\n  REQUESTS = []\n\n  ##\n  # Creates a clean mechanize instance +@mech+ for use in tests.\n\n  def setup\n    super\n\n    REQUESTS.clear\n    @mech = Mechanize.new\n    @ssl_private_key = nil\n    @ssl_certificate = nil\n  end\n\n  ##\n  # Creates a fake page with URI http://fake.example and an empty, submittable\n  # form.\n\n  def fake_page agent = @mech\n    uri = URI 'http://fake.example/'\n    html = <<-END\n<html>\n<body>\n<form><input type=\"submit\" value=\"submit\" /></form>\n</body>\n</html>\n    END\n\n    Mechanize::Page.new uri, nil, html, 200, agent\n  end\n\n  ##\n  # Is the Encoding constant defined?\n\n  def have_encoding?\n    Object.const_defined? :Encoding\n  end\n\n  ##\n  # Creates a Mechanize::Page with the given +body+\n\n  def html_page body\n    uri = URI 'http://example/'\n    Mechanize::Page.new uri, nil, body, 200, @mech\n  end\n\n  ##\n  # Creates a Mechanize::CookieJar by parsing the given +str+\n\n  def cookie_jar str, uri = URI('http://example')\n    jar = Mechanize::CookieJar.new\n\n    jar.parse str, uri\n\n    jar\n  end\n\n  ##\n  # Runs the block inside a temporary directory\n\n  def in_tmpdir\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        yield\n      end\n    end\n  end\n\n  ##\n  # Creates a Nokogiri Node +element+ with the given +attributes+\n\n  def node element, attributes = {}\n    doc = Nokogiri::HTML::Document.new\n\n    node = Nokogiri::XML::Node.new element, doc\n\n    attributes.each do |name, value|\n      node[name] = value\n    end\n\n    node\n  end\n\n  ##\n  # Creates a Mechanize::Page for the given +uri+ with the given\n  # +content_type+, response +body+ and HTTP status +code+\n\n  def page uri, content_type = 'text/html', body = '', code = 200\n    uri = URI uri unless URI::Generic === uri\n\n    Mechanize::Page.new(uri, { 'content-type' => content_type }, body, code,\n                        @mech)\n  end\n\n  ##\n  # Requests made during this tests\n\n  def requests\n    REQUESTS\n  end\n\n  ##\n  # An SSL private key.  This key is the same across all test runs\n\n  def ssl_private_key\n    @ssl_private_key ||= OpenSSL::PKey::RSA.new <<-KEY\n-----BEGIN RSA PRIVATE KEY-----\nMIG7AgEAAkEA8pmEfmP0Ibir91x6pbts4JmmsVZd3xvD5p347EFvBCbhBW1nv1Gs\nbCBEFlSiT1q2qvxGb5IlbrfdhdgyqdTXUQIBAQIBAQIhAPumXslvf6YasXa1hni3\np80joKOug2UUgqOLD2GUSO//AiEA9ssY6AFxjHWuwo/+/rkLmkfO2s1Lz3OeUEWq\n6DiHOK8CAQECAQECIQDt8bc4vS6wh9VXApNSKIpVygtxSFe/IwLeX26n77j6Qg==\n-----END RSA PRIVATE KEY-----\n    KEY\n  end\n\n  ##\n  # An X509 certificate.  This certificate is the same across all test runs\n\n  def ssl_certificate\n    @ssl_certificate ||= OpenSSL::X509::Certificate.new <<-CERT\n-----BEGIN CERTIFICATE-----\nMIIBQjCB7aADAgECAgEAMA0GCSqGSIb3DQEBBQUAMCoxDzANBgNVBAMMBm5vYm9k\neTEXMBUGCgmSJomT8ixkARkWB2V4YW1wbGUwIBcNMTExMTAzMjEwODU5WhgPOTk5\nOTEyMzExMjU5NTlaMCoxDzANBgNVBAMMBm5vYm9keTEXMBUGCgmSJomT8ixkARkW\nB2V4YW1wbGUwWjANBgkqhkiG9w0BAQEFAANJADBGAkEA8pmEfmP0Ibir91x6pbts\n4JmmsVZd3xvD5p347EFvBCbhBW1nv1GsbCBEFlSiT1q2qvxGb5IlbrfdhdgyqdTX\nUQIBATANBgkqhkiG9w0BAQUFAANBAAAB////////////////////////////////\n//8AMCEwCQYFKw4DAhoFAAQUePiv+QrJxyjtEJNnH5pB9OTWIqA=\n-----END CERTIFICATE-----\n    CERT\n  end\n\n  ##\n  # Creates a Tempfile with +content+ that is immediately unlinked\n\n  def tempfile content\n    body_io = Tempfile.new @NAME\n    body_io.unlink\n    body_io.write content\n    body_io.flush\n    body_io.rewind\n\n    body_io\n  end\n\nend\n\nrequire 'mechanize/test_case/servlets'\n\nmodule Net # :nodoc:\nend\n\nclass Net::HTTP # :nodoc:\n  alias :old_do_start :do_start\n\n  def do_start\n    @started = true\n  end\n\n  PAGE_CACHE = {}\n\n  alias :old_request :request\n\n  def request(req, *data, &block)\n    url = URI.parse(req.path)\n    path = WEBrick::HTTPUtils.unescape(url.path)\n\n    path = '/index.html' if path == '/'\n\n    res = ::Response.new\n    res.query_params = url.query\n\n    req.query = if 'POST' != req.method && url.query then\n                  WEBrick::HTTPUtils.parse_query url.query\n                elsif req['content-type'] =~ /www-form-urlencoded/ then\n                  WEBrick::HTTPUtils.parse_query req.body\n                elsif req['content-type'] =~ /boundary=(.+)/ then\n                  boundary = WEBrick::HTTPUtils.dequote $1\n                  WEBrick::HTTPUtils.parse_form_data req.body, boundary\n                else\n                  {}\n                end\n\n    req.cookies = WEBrick::Cookie.parse(req['Cookie'])\n\n    Mechanize::TestCase::REQUESTS << req\n\n    if servlet_klass = MECHANIZE_TEST_CASE_SERVLETS[path]\n      servlet = servlet_klass.new({})\n      servlet.send \"do_#{req.method}\", req, res\n    else\n      filename = \"htdocs#{path.gsub(/[^\\/\\\\.\\w\\s]/, '_')}\"\n      unless PAGE_CACHE[filename]\n        ::File.open(\"#{Mechanize::TestCase::TEST_DIR}/#{filename}\", 'rb') do |io|\n          PAGE_CACHE[filename] = io.read\n        end\n      end\n\n      res.body = PAGE_CACHE[filename]\n      case filename\n      when /\\.txt$/\n        res['Content-Type'] = 'text/plain'\n      when /\\.jpg$/\n        res['Content-Type'] = 'image/jpeg'\n      end\n    end\n\n    res['Content-Type'] ||= 'text/html'\n    res.code ||= \"200\"\n\n    response_klass = Net::HTTPResponse::CODE_TO_OBJ[res.code.to_s]\n    response = response_klass.new res.http_version, res.code, res.message\n\n    res.header.each do |k,v|\n      v = v.first if v.length == 1\n      response[k] = v\n    end\n\n    res.cookies.each do |cookie|\n      response.add_field 'Set-Cookie', cookie.to_s\n    end\n\n    response['Content-Type'] ||= 'text/html'\n    response['Content-Length'] = res['Content-Length'] || res.body.length.to_s\n\n    io = StringIO.new(res.body)\n    response.instance_variable_set :@socket, io\n    def io.read clen, dest = nil, _ = nil\n      if dest then\n        dest << super(clen)\n      else\n        super clen\n      end\n    end\n\n    body_exist = req.response_body_permitted? &&\n      response_klass.body_permitted?\n\n    response.instance_variable_set :@body_exist, body_exist\n\n    yield response if block_given?\n\n    response\n  end\nend\n\nclass Net::HTTPRequest # :nodoc:\n  attr_accessor :query, :body, :cookies, :user\n\n  def host\n    'example'\n  end\n\n  def port\n    80\n  end\nend\n\nclass Response # :nodoc:\n  include Net::HTTPHeader\n\n  attr_reader :code\n  attr_accessor :body, :query, :cookies\n  attr_accessor :query_params, :http_version\n  attr_accessor :header\n\n  def code=(c)\n    @code = c.to_s\n  end\n\n  alias :status :code\n  alias :status= :code=\n\n    def initialize\n      @header = {}\n      @body = ''\n      @code = nil\n      @query = nil\n      @cookies = []\n      @http_version = '1.1'\n    end\n\n  def read_body\n    yield body\n  end\n\n  def message\n    ''\n  end\nend\n\n", "require 'stringio'\nrequire 'zlib'\n\nclass GzipServlet < WEBrick::HTTPServlet::AbstractServlet\n\n  TEST_DIR = File.expand_path '../../../../test', __FILE__\n\n  def do_GET(req, res)\n    if req['Accept-Encoding'] !~ /gzip/ then\n      res.code = 400\n      res.body = 'Content-Encoding: gzip is not supported by your user-agent'\n      return\n    end\n\n    if name = req.query['file'] then\n      ::File.open(\"#{TEST_DIR}/htdocs/#{name}\") do |io|\n        string = String.new\n        zipped = StringIO.new string, 'w'\n        Zlib::GzipWriter.wrap zipped do |gz|\n          gz.write io.read\n        end\n        res.body = string\n      end\n    else\n      res.body = String.new\n    end\n\n    res['Content-Encoding'] = req['X-ResponseContentEncoding'] || 'gzip'\n    res['Content-Type'] = \"text/html\"\n  end\nend\n\n", "class VerbServlet < WEBrick::HTTPServlet::AbstractServlet\n  %w[HEAD GET POST PUT DELETE].each do |verb|\n    define_method \"do_#{verb}\" do |req, res|\n      res.header['X-Request-Method'] = verb\n      res.body = verb\n    end\n  end\nend\n\n", "# coding: utf-8\n\nrequire 'mechanize/test_case'\n\nclass TestMechanize < Mechanize::TestCase\n\n  def setup\n    super\n\n    @uri = URI 'http://example/'\n    @req = Net::HTTP::Get.new '/'\n\n    @res = Net::HTTPOK.allocate\n    @res.instance_variable_set :@code, 200\n    @res.instance_variable_set :@header, {}\n  end\n\n  def test_back\n    0.upto(5) do |i|\n      assert_equal(i, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n    @mech.get(\"http://localhost/form_test.html\")\n\n    assert_equal(\"http://localhost/form_test.html\",\n      @mech.history.last.uri.to_s)\n    assert_equal(\"http://localhost/\",\n      @mech.history[-2].uri.to_s)\n\n    assert_equal(7, @mech.history.size)\n    @mech.back\n    assert_equal(6, @mech.history.size)\n    assert_equal(\"http://localhost/\",\n      @mech.history.last.uri.to_s)\n  end\n\n  def test_basic_auth\n    _, err = capture_io do\n      @mech.basic_auth 'user', 'pass' # warns\n    end\n\n    line = __LINE__ - 3\n    file = File.basename __FILE__\n\n    assert_match \"#{file} line #{line}\", err\n\n    page = @mech.get @uri + '/basic_auth'\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_cert_key_file\n    in_tmpdir do\n      open 'key.pem', 'w'  do |io| io.write ssl_private_key.to_pem end\n      open 'cert.pem', 'w' do |io| io.write ssl_certificate.to_pem end\n\n      mech = Mechanize.new do |a|\n        a.cert = 'cert.pem'\n        a.key  = 'key.pem'\n      end\n\n      # Certificate#== seems broken\n      assert_equal ssl_certificate.to_pem, mech.certificate.to_pem\n    end\n  end\n\n  def test_cert_key_object\n    mech = Mechanize.new do |a|\n      a.cert = ssl_certificate\n      a.key  = ssl_private_key\n    end\n\n    assert_equal ssl_certificate, mech.certificate\n    assert_equal ssl_certificate, mech.cert\n    assert_equal ssl_private_key, mech.key\n  end\n\n  def test_cert_store\n    assert_nil @mech.cert_store\n\n    store = OpenSSL::X509::Store.new\n    @mech.cert_store = store\n\n    assert_equal store, @mech.cert_store\n  end\n\n  def test_click\n    @mech.user_agent_alias = 'Mac Safari'\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = page.link_with(:text => \"Form Test\")\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end unless RUBY_ENGINE == 'jruby'  # NekoHTML does not parse body of NOFRAMES\n\n  def test_click_bogus_link_with_cookies\n    @mech.cookie_jar = cookie_jar(\"a=b\")\n\n    page = html_page <<-BODY\n<a href=\"http:///index.html\">yes really</a>\n    BODY\n\n    page.links[0].click\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_image_button\n    page = @mech.get(\"http://localhost/form_test.html\")\n    get_form = page.forms.find { |f| f.name == \"get_form1\" }\n    image_button = get_form.buttons.first\n    new_page = @mech.click(image_button)\n    assert_equal \"http://localhost/form_post?first_name=&button.x=0&button.y=0\", new_page.uri.to_s\n  end\n\n  def test_click_submit_button\n    page = @mech.get(\"http://localhost/form_test.html\")\n    get_form = page.forms.find { |f| f.name == \"get_form1\" }\n    submit_button = get_form.submits.first\n    new_page = @mech.click(submit_button)\n    assert_equal \"http://localhost/form_post?first_name=\", new_page.uri.to_s\n  end\n\n  def test_click_frame\n    frame = node 'frame', 'src' => '/index.html'\n    frame = Mechanize::Page::Frame.new frame, @mech, fake_page\n\n    @mech.click frame\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_frame_hpricot_style\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = (page/\"//frame[@name='frame2']\").first\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end\n\n  def test_click_hpricot_style # HACK move to test_divide in Page\n    page = @mech.get(\"http://localhost/frame_test.html\")\n    link = (page/\"//a[@class='bar']\").first\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_test.html\",\n                 @mech.history.last.uri.to_s)\n  end unless RUBY_ENGINE == 'jruby'  # NekoHTML does not parse body of NOFRAMES\n\n  def test_click_link\n    link = node 'a', 'href' => '/index.html'\n    link = Mechanize::Page::Link.new link, @mech, fake_page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n    assert_equal 'http://fake.example/', requests.first['Referer']\n  end\n\n  def test_click_link_nofollow\n    page = html_page <<-BODY\n<meta name=\"ROBOTS\" content=\"nofollow\">\n\n<p>Do not follow <a href=\"/index.html\">this</a> or <a href=\"/\">this</a>!\n    BODY\n\n    page.links[0].click\n    page.links[1].click\n\n    @mech.robots = true\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[0].click\n    end\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[1].click\n    end\n  end\n\n  def test_click_link_noreferrer\n    link = node 'a', 'href' => '/index.html', 'rel' => 'noreferrer'\n    link = Mechanize::Page::Link.new link, @mech, fake_page\n\n    @mech.click link\n\n    assert_nil requests.first['referer']\n  end\n\n  def test_click_link_rel_nofollow\n    page = html_page <<-BODY\n<p>You can follow <a href=\"/index.html\">this link</a>\nbut not <a href=\"/\" rel=\"me nofollow\">this</a>!\n    BODY\n\n    page.links[0].click\n    page.links[1].click\n\n    @mech.robots = true\n\n    page.links[0].click\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      page.links[1].click\n    end\n  end\n\n  def test_click_link_parent\n    page = page URI 'http://example/a/index.html'\n    link = node 'a', 'href' => '../index.html'\n    link = Mechanize::Page::Link.new link, @mech, page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_link_parent_extra\n    page = page URI 'http://example/a/index.html'\n    link = node 'a', 'href' => '../../index.html'\n    link = Mechanize::Page::Link.new link, @mech, page\n\n    @mech.click link\n\n    assert_equal '/index.html', requests.first.path\n  end\n\n  def test_click_link_hpricot_style # HACK move to test_search in Page\n    page = @mech.get(\"http://localhost/tc_encoded_links.html\")\n\n    page = @mech.click(page.search('a').first)\n\n    assert_equal(\"http://localhost/form_post?a=b&b=c\", page.uri.to_s)\n  end\n\n  def test_click_link_query\n    page = @mech.get(\"http://localhost/tc_encoded_links.html\")\n    link = page.links.first\n    assert_equal('/form_post?a=b&b=c', link.href)\n\n    page = @mech.click(link)\n\n    assert_equal(\"http://localhost/form_post?a=b&b=c\", page.uri.to_s)\n  end\n\n  def test_click_link_space\n    page = @mech.get(\"http://localhost/tc_bad_links.html\")\n\n    @mech.click page.links.first\n\n    assert_match(/alt_text.html$/, @mech.history.last.uri.to_s)\n    assert_equal(2, @mech.history.length)\n  end\n\n  def test_click_more\n    @mech.get 'http://localhost/test_click.html'\n    @mech.click 'A Button'\n    assert_equal 'http://localhost/frame_test.html?words=nil',\n      @mech.page.uri.to_s\n    @mech.back\n    @mech.click 'A Link'\n    assert_equal 'http://localhost/index.html',\n      @mech.page.uri.to_s\n    @mech.back\n    @mech.click @mech.page.link_with(:text => 'A Link')\n    assert_equal 'http://localhost/index.html',\n      @mech.page.uri.to_s\n  end\n\n  def test_cookies\n    uri = URI 'http://example'\n    jar = HTTP::CookieJar.new\n    jar.parse 'a=b', uri\n\n    @mech.cookie_jar = jar\n\n    refute_empty @mech.cookies\n  end\n\n  def test_cookie_jar\n    assert_kind_of Mechanize::CookieJar, @mech.cookie_jar\n\n    jar = HTTP::CookieJar.new\n\n    @mech.cookie_jar = jar\n\n    assert_equal jar, @mech.cookie_jar\n  end\n\n  def test_delete\n    page = @mech.delete('http://localhost/verb', { 'q' => 'foo' })\n    assert_equal 1, @mech.history.length\n    assert_equal 'DELETE', page.header['X-Request-Method']\n  end\n\n  def test_delete_redirect\n    page = @mech.delete('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_download\n    page = nil\n\n    in_tmpdir do\n      open 'download', 'w' do |io|\n        page = @mech.download 'http://example', io\n\n        refute io.closed?\n      end\n\n      assert_operator 1, :<=, File.stat('download').size\n    end\n\n    assert_empty @mech.history\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_download_filename\n    page = nil\n\n    in_tmpdir do\n      page = @mech.download 'http://example', 'download'\n\n      assert_operator 1, :<=, File.stat('download').size\n    end\n\n    assert_empty @mech.history\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_download_filename_error\n    in_tmpdir do\n      assert_raises Mechanize::UnauthorizedError do\n        @mech.download 'http://example/digest_auth', 'download'\n      end\n\n      refute File.exist? 'download'\n    end\n  end\n\n  def test_download_does_not_allow_command_injection\n    in_tmpdir do\n      @mech.download('http://example', '| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\'')\n\n      refute_operator(File, :exist?, \"vul.txt\")\n    end\n  end\n\n  def test_get\n    uri = URI 'http://localhost'\n\n    page = @mech.get uri, { :q => 'h' }, 'http://example', { 'X-H' => 'v' }\n\n    assert_equal URI('http://localhost/?q=h'), page.uri\n    assert_equal URI('http://localhost'), uri\n  end\n\n  def test_get_HTTP\n    page = @mech.get('HTTP://localhost/', { :q => 'hello' })\n\n    assert_kind_of URI::HTTP, page.uri\n    assert_equal 'localhost', page.uri.host\n    assert_equal 80,          page.uri.port\n    assert_equal '/?q=hello', page.uri.request_uri\n  end\n\n  def test_get_anchor\n    page = @mech.get('http://localhost/?foo=bar&#34;')\n    assert_equal('http://localhost/?foo=bar%22', page.uri.to_s)\n  end\n\n  def test_get_bad_url\n    assert_raises ArgumentError do\n      @mech.get '/foo.html'\n    end\n  end\n\n  def test_get_auth\n    @mech.add_auth @uri, 'user', 'pass'\n\n    page = @mech.get @uri + '/basic_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_auth_bad\n    @mech.add_auth(@uri, 'aaron', 'aaron')\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @mech.get(@uri + '/basic_auth')\n    end\n\n    assert_equal(\"401\", e.response_code)\n  end\n\n  def test_get_auth_none\n    e = assert_raises Mechanize::UnauthorizedError do\n      @mech.get(@uri + '/basic_auth')\n    end\n\n    assert_equal(\"401\", e.response_code)\n  end\n\n  def test_get_auth_realm\n    @mech.add_auth @uri, 'user', 'pass', 'Blah'\n\n    page = @mech.get @uri + '/basic_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_conditional\n    assert_empty @mech.history\n\n    page = @mech.get 'http://localhost/if_modified_since'\n    assert_match(/You did not send/, page.body)\n\n    assert_equal 1, @mech.history.length\n    page2 = @mech.get 'http://localhost/if_modified_since'\n\n    assert_equal 2, @mech.history.length\n    assert_equal page.object_id, page2.object_id\n  end\n\n  def test_get_digest_auth\n    @mech.add_auth @uri, 'user', 'pass'\n\n    page = @mech.get @uri + '/digest_auth'\n\n    assert_equal 'You are authenticated', page.body\n  end\n\n  def test_get_follow_meta_refresh\n    @mech.follow_meta_refresh = true\n\n    page = @mech.get('http://localhost/tc_follow_meta.html')\n\n    assert_equal(2, @mech.history.length)\n\n    assert_equal('http://localhost/tc_follow_meta.html',\n                 @mech.history.first.uri.to_s)\n    assert_equal('http://localhost/index.html', page.uri.to_s)\n    assert_equal('http://localhost/index.html', @mech.history.last.uri.to_s)\n\n    [5, 6].each { |limit|\n      @mech.redirection_limit = limit\n      begin\n        @mech.get('http://localhost/tc_follow_meta_loop_1.html')\n      rescue => e\n        assert_instance_of Mechanize::RedirectLimitReachedError, e\n        assert_equal limit, e.redirects\n        if limit % 2 == 0\n          assert_equal '/tc_follow_meta_loop_1.html', e.page.uri.path\n        else\n          assert_equal '/tc_follow_meta_loop_2.html', e.page.uri.path\n        end\n      end\n    }\n  end\n\n  def test_get_follow_meta_refresh_anywhere\n    @mech.follow_meta_refresh = :anywhere\n\n    @mech.get('http://localhost/tc_meta_in_body.html')\n    assert_equal 2, requests.length\n  end\n\n  def test_get_follow_meta_refresh_disabled\n    page = @mech.get('http://localhost/tc_follow_meta.html')\n    assert_equal('http://localhost/tc_follow_meta.html', page.uri.to_s)\n    assert_equal(1, page.meta_refresh.length)\n  end\n\n  def test_get_follow_meta_refresh_empty_url\n    @mech.follow_meta_refresh = true\n    @mech.follow_meta_refresh_self = true\n\n    page = @mech.get('http://example/refresh_with_empty_url')\n\n    assert_equal(3, @mech.history.length)\n    assert_equal('http://example/refresh_with_empty_url',\n                 @mech.history[0].uri.to_s)\n    assert_equal('http://example/refresh_with_empty_url',\n                 @mech.history[1].uri.to_s)\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal('http://example/', @mech.history.last.uri.to_s)\n  end\n\n  def test_get_follow_meta_refresh_in_body\n    @mech.follow_meta_refresh = true\n\n    @mech.get('http://localhost/tc_meta_in_body.html')\n    assert_equal 1, requests.length\n  end\n\n  def test_get_follow_meta_refresh_no_url\n    @mech.follow_meta_refresh = true\n    @mech.follow_meta_refresh_self = true\n\n    page = @mech.get('http://example/refresh_without_url')\n\n    assert_equal(3, @mech.history.length)\n    assert_equal('http://example/refresh_without_url',\n                 @mech.history[0].uri.to_s)\n    assert_equal('http://example/refresh_without_url',\n                 @mech.history[1].uri.to_s)\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal('http://example/', @mech.history.last.uri.to_s)\n  end\n\n  def test_get_follow_meta_refresh_referer_not_sent\n    @mech.follow_meta_refresh = true\n\n    @mech.get('http://localhost/tc_follow_meta.html')\n\n    assert_equal 2, @mech.history.length\n    assert_nil requests.last['referer']\n  end\n\n  def test_get_referer_download\n    download = Mechanize::Download.new URI 'http://example/prev'\n\n    uri = URI 'http://example'\n\n    page = @mech.get uri, { :q => 'h' }, download, { 'X-H' => 'v' }\n\n    assert_equal URI('http://example/?q=h'), page.uri\n    assert_equal URI('http://example'), uri\n\n    assert_equal 'http://example/prev', requests.first['referer']\n  end\n\n  def test_get_robots\n    @mech.robots = true\n\n    assert_equal \"Page Title\", @mech.get(\"http://localhost/index.html\").title\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @mech.get \"http://localhost/norobots.html\"\n    end\n  end\n\n  def test_follow_meta_refresh_self\n    refute @mech.agent.follow_meta_refresh_self\n\n    @mech.follow_meta_refresh_self = true\n\n    assert @mech.agent.follow_meta_refresh_self\n  end\n\n  def test_get_gzip\n    page = @mech.get(\"http://localhost/gzip?file=index.html\")\n\n    assert_kind_of(Mechanize::Page, page)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def test_content_encoding_hooks_header\n    h = {'X-ResponseContentEncoding' => 'agzip'}\n\n    # test of X-ResponseContentEncoding feature\n    assert_raises(Mechanize::Error, 'Unsupported Content-Encoding: agzip') do\n      @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n    end\n\n    @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      response['content-encoding'] = 'gzip' if response['content-encoding'] == 'agzip'}\n\n    page = @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def external_cmd(io); Zlib::GzipReader.new(io).read; end\n\n  def test_content_encoding_hooks_body_io\n    h = {'X-ResponseContentEncoding' => 'unsupported_content_encoding'}\n\n   @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      if response['content-encoding'] == 'unsupported_content_encoding'\n        response['content-encoding'] = 'none'\n        response_body_io.string = external_cmd(response_body_io)\n      end}\n\n    page = @mech.get(\"http://localhost/gzip?file=index.html\", nil, nil, h)\n\n    assert_match('Hello World', page.body)\n  end\n\n  def test_get_http_refresh\n    @mech.follow_meta_refresh = true\n\n    page = @mech.get('http://example/http_refresh?refresh_time=0')\n\n    assert_equal('http://example/', page.uri.to_s)\n    assert_equal(2, @mech.history.length)\n    assert_nil requests.last['referer']\n  end\n\n  def test_get_http_refresh_delay\n    @mech.follow_meta_refresh = true\n    class << @mech.agent\n      attr_accessor :slept\n      def sleep *args\n        @slept = args\n      end\n    end\n\n    @mech.get('http://localhost/http_refresh?refresh_time=1')\n    assert_equal [1], @mech.agent.slept\n  end\n\n  def test_get_http_refresh_disabled\n    page = @mech.get('http://localhost/http_refresh?refresh_time=0')\n    assert_equal('http://localhost/http_refresh?refresh_time=0', page.uri.to_s)\n  end\n\n  def test_get_query\n    page = @mech.get('http://localhost/', { :q => 'hello' })\n    assert_equal('http://localhost/?q=hello', page.uri.to_s)\n\n    page = @mech.get('http://localhost/', { :q => %w[hello world]})\n    assert_equal('http://localhost/?q=hello&q=world', page.uri.to_s)\n\n    page = @mech.get('http://localhost/', { :paging => { start: 1, limit: 25 } })\n    assert_equal('http://localhost/?paging%5Bstart%5D=1&paging%5Blimit%5D=25', page.uri.to_s)\n  end\n\n  def test_get_redirect\n    page = @mech.get('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_get_redirect_found\n    page = @mech.get('http://localhost/response_code?code=302&ct=test/xml')\n\n    assert_equal('http://localhost/index.html', page.uri.to_s)\n\n    assert_equal(2, @mech.history.length)\n  end\n\n  def test_get_redirect_infinite\n    assert_raises(Mechanize::RedirectLimitReachedError) {\n      @mech.get('http://localhost/infinite_refresh')\n    }\n  end\n\n  def test_get_referer\n    request = nil\n    @mech.pre_connect_hooks << lambda { |_, req|\n      request = req\n    }\n\n    @mech.get('http://localhost/', [], 'http://tenderlovemaking.com/')\n    assert_equal 'http://tenderlovemaking.com/', request['Referer']\n  end\n\n  def test_get_referer_file\n    uri = URI 'http://tenderlovemaking.com/crossdomain.xml'\n    file = Mechanize::File.new uri\n\n    @mech.get('http://localhost', [], file)\n\n    # HACK no assertion of behavior\n  end\n\n  def test_get_referer_none\n    @mech.get('http://localhost/')\n    @mech.get('http://localhost/')\n    assert_equal(2, requests.length)\n    requests.each do |request|\n      assert_nil request['referer']\n    end\n  end\n\n  def test_get_scheme_unsupported\n    assert_raises Mechanize::UnsupportedSchemeError do\n      begin\n        @mech.get('ftp://server.com/foo.html')\n      rescue Mechanize::UnsupportedSchemeError => error\n        assert_equal 'ftp', error.scheme\n        assert_equal 'ftp://server.com/foo.html', error.uri.to_s\n        raise\n      end\n    end\n  end\n\n  def test_get_space\n    @mech.get(\"http://localhost/tc_bad_links.html \")\n\n    assert_match(/tc_bad_links.html$/, @mech.history.last.uri.to_s)\n\n    assert_equal(1, @mech.history.length)\n  end\n\n  def test_get_tilde\n    page = @mech.get('http://localhost/?foo=~2')\n\n    assert_equal('http://localhost/?foo=~2', page.uri.to_s)\n  end\n\n  def test_get_weird\n    @mech.get('http://localhost/?action=bing&bang=boom=1|a=|b=|c=')\n    @mech.get('http://localhost/?a=b&#038;b=c&#038;c=d')\n    @mech.get(\"http://localhost/?a=#{[0xd6].pack('U')}\")\n\n    # HACK no assertion of behavior\n  end\n\n  def test_get_yield\n    pages = nil\n\n    @mech.get(\"http://localhost/file_upload.html\") { |page|\n      pages = page\n    }\n\n    assert pages\n    assert_equal('File Upload Form', pages.title)\n  end\n\n  def test_get_file\n    body = @mech.get_file 'http://localhost/frame_test.html'\n\n    assert_kind_of String, body\n    refute_empty body\n  end\n\n  def test_get_file_download\n    # non-Mechanize::File\n    body = @mech.get_file 'http://localhost/button.jpg'\n\n    assert_kind_of String, body\n    refute_empty body\n  end\n\n  def test_head\n    page = @mech.head('http://localhost/verb', { 'q' => 'foo' })\n    assert_equal 0, @mech.history.length\n    assert_equal 'HEAD', page.header['X-Request-Method']\n  end\n\n  def test_head_redirect\n    page = @mech.head('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'HEAD', page.header['X-Request-Method']\n  end\n\n  def test_history\n    2.times do |i|\n      assert_equal(i, @mech.history.size)\n\n      @mech.get(\"http://localhost/\")\n    end\n\n    page = @mech.get(\"http://localhost/form_test.html\")\n\n    assert_equal(\"http://localhost/form_test.html\",\n      @mech.history.last.uri.to_s)\n    assert_equal(\"http://localhost/\",\n      @mech.history[-2].uri.to_s)\n\n    assert @mech.visited?(\"http://localhost/\")\n    assert @mech.visited?(\"/form_test.html\"), 'relative'\n    assert !@mech.visited?(\"http://google.com/\")\n    assert @mech.visited?(page.links.first)\n  end\n\n  def test_history_added_gets_called\n    added_page = nil\n\n    @mech.history_added = lambda { |page|\n      added_page = page\n    }\n\n    assert_equal @mech.get('http://localhost/tc_blank_form.html'), added_page\n  end\n\n  def test_history_order\n    @mech.max_history = 2\n    assert_equal(0, @mech.history.length)\n\n    @mech.get('http://localhost/form_test.html')\n    assert_equal(1, @mech.history.length)\n\n    @mech.get('http://localhost/empty_form.html')\n    assert_equal(2, @mech.history.length)\n\n    @mech.get('http://localhost/tc_checkboxes.html')\n    assert_equal(2, @mech.history.length)\n    assert_equal('http://localhost/empty_form.html', @mech.history[0].uri.to_s)\n    assert_equal('http://localhost/tc_checkboxes.html',\n                 @mech.history[1].uri.to_s)\n  end\n\n  def test_initialize\n    mech = Mechanize.new\n\n    assert_equal 50, mech.max_history\n  end\n\n  def test_html_parser_equals\n    @mech.html_parser = {}\n    assert_raises(NoMethodError) {\n      @mech.get('http://localhost/?foo=~2').links\n    }\n  end\n\n  def test_idle_timeout_default\n    assert_equal 5, Mechanize.new.idle_timeout\n  end\n\n  def test_idle_timeout_equals\n    @mech.idle_timeout = 15\n\n    assert_equal 15, @mech.idle_timeout\n  end\n\n  def test_keep_alive_equals\n    assert @mech.keep_alive\n\n    @mech.keep_alive = false\n\n    refute @mech.keep_alive\n  end\n\n  def test_keep_alive_time\n    assert_equal 0, @mech.keep_alive_time\n\n    @mech.keep_alive_time = 1\n\n    assert_equal 1, @mech.keep_alive_time\n  end\n\n  def test_log\n    assert_nil @mech.log\n  end\n\n  def test_log_equals\n    @mech.log = Logger.new $stderr\n\n    refute_nil @mech.log\n    assert_nil Mechanize.log\n  end\n\n  def test_max_file_buffer_equals\n    @mech.max_file_buffer = 1024\n\n    assert_equal 1024, @mech.agent.max_file_buffer\n  end\n\n  def test_max_history_equals\n    @mech.max_history = 10\n    0.upto(10) do |i|\n      assert_equal(i, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n\n    0.upto(10) do |i|\n      assert_equal(10, @mech.history.size)\n      @mech.get(\"http://localhost/\")\n    end\n  end\n\n  def test_open_timeout_equals\n    @mech.open_timeout = 5\n\n    assert_equal 5, @mech.open_timeout\n  end\n\n  def test_parse_download\n    @mech.pluggable_parser['application/octet-stream'] = Mechanize::Download\n\n    response = Net::HTTPOK.allocate\n    response.instance_variable_set(:@header,\n                                   'content-type' =>\n                                     ['application/octet-stream'])\n\n    download = @mech.parse @uri, response, StringIO.new('raw')\n\n    assert_kind_of Mechanize::Download, download\n    assert_kind_of StringIO, download.content\n  end\n\n  def test_parse_html\n    response = Net::HTTPOK.allocate\n    response.instance_variable_set :@header, 'content-type' => ['text/html']\n\n    page = @mech.parse URI('http://example/'), response, ''\n\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_post\n    @mech.post \"http://example\", 'gender' => 'female'\n\n    assert_equal \"gender=female\", requests.first.body\n  end\n\n  def test_post_auth\n    requests = []\n\n    @mech.pre_connect_hooks << proc { |agent, request|\n      requests << request.class\n    }\n\n    @mech.add_auth(@uri, 'user', 'pass')\n    page = @mech.post(@uri + '/basic_auth')\n    assert_equal('You are authenticated', page.body)\n    assert_equal(2, requests.length)\n    r1 = requests[0]\n    r2 = requests[1]\n    assert_equal(r1, r2)\n  end\n\n  def test_post_entity\n    @mech.post \"http://localhost/form_post\", 'json' => '[\"&quot;\"]'\n\n    assert_equal \"json=%5B%22%22%22%5D\", requests.first.body\n  end\n\n  def test_post_multiple_values\n    @mech.post \"http://localhost/form_post\",\n                      [%w[gender female], %w[gender male]]\n\n    assert_equal \"gender=female&gender=male\", requests.first.body\n  end\n\n  def test_post_multipart\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => File.open(__FILE__)\n    })\n\n    name = File.basename __FILE__\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\",\n      page.body\n    )\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_file_upload_nonascii\n    name = '\u30e6\u30fc\u30b6\u30d5\u30a1\u30a4\u30eb1'\n    file_upload = Mechanize::Form::FileUpload.new({'name' => 'userfile1'}, name)\n    file_upload.file_data = File.read(__FILE__)\n    file_upload.mime_type = 'application/zip'\n\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => file_upload\n    })\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\".force_encoding(Encoding::ASCII_8BIT),\n      page.body\n    )\n    assert_match(\"Content-Type: application/zip\", page.body)\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_file_upload\n    name = File.basename(__FILE__)\n    file_upload = Mechanize::Form::FileUpload.new({'name' => 'userfile1'}, name)\n    file_upload.file_data = File.read(__FILE__)\n    file_upload.mime_type = 'application/zip'\n\n    page = @mech.post('http://localhost/file_upload', {\n      :name       => 'Some file',\n      :userfile1  => file_upload\n    })\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{name}\\\"\",\n      page.body\n    )\n    assert_match(\"Content-Type: application/zip\", page.body)\n    assert_operator page.body.bytesize, :>, File.size(__FILE__)\n  end\n\n  def test_post_redirect\n    page = @mech.post('http://localhost/redirect')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_put\n    page = @mech.put('http://localhost/verb', 'foo')\n    assert_equal 1, @mech.history.length\n    assert_equal 'PUT', page.header['X-Request-Method']\n  end\n\n  def test_put_redirect\n    page = @mech.put('http://localhost/redirect', 'foo')\n\n    assert_equal(page.uri.to_s, 'http://localhost/verb')\n\n    assert_equal 'GET', page.header['X-Request-Method']\n  end\n\n  def test_read_timeout_equals\n    @mech.read_timeout = 5\n\n    assert_equal 5, @mech.read_timeout\n  end\n\n  def test_timeouts_for_file_connection\n    uri = URI.parse \"file://#{File.expand_path __FILE__}\"\n    @mech.read_timeout = 5\n    @mech.open_timeout = 5\n    assert @mech.get(uri)\n  end\n\n  def test_referer\n    host_path = \"localhost/tc_referer.html?t=1\"\n    ['http', 'https'].each { |proto|\n      referer = \"#{proto}://#{host_path}\"\n      [\n        \"\",\n\t\"@\",\n\t\"user1@\",\n\t\":@\",\n\t\"user1:@\",\n\t\":password1@\",\n\t\"user1:password1@\",\n      ].each { |userinfo|\n        url = \"#{proto}://#{userinfo}#{host_path}\"\n        [url, url + \"#foo\"].each { |furl|\n          [\n            ['relative',\t\ttrue],\n            ['insecure',\t\tproto == 'http'],\n            ['secure',\t\t\ttrue],\n            ['relative noreferrer',\tfalse],\n            ['insecure noreferrer',\tfalse],\n            ['secure noreferrer',\tfalse],\n          ].each_with_index { |(type, bool), i|\n            rpage = @mech.get(furl)\n            page = rpage.links[i].click\n            assert_equal bool ? referer : '', page.body, \"%s link from %s\" % [type, furl]\n          }\n\n          rpage = @mech.get(furl)\n          page = rpage.forms.first.submit\n          assert_equal referer, page.body, \"post from %s\" % furl\n        }\n      }\n    }\n  end\n\n  def test_retry_change_requests_equals\n    unless Gem::Requirement.new(\"< 4.0.0\").satisfied_by?(Gem::Version.new(Net::HTTP::Persistent::VERSION))\n      # see https://github.com/drbrain/net-http-persistent/pull/100\n      skip(\"net-http-persistent 4.0.0 and later does not support retry_change_requests\")\n    end\n\n    refute @mech.retry_change_requests\n\n    @mech.retry_change_requests = true\n\n    assert @mech.retry_change_requests\n  end\n\n  def test_set_proxy\n    http = @mech.agent.http\n\n    @mech.set_proxy 'localhost', 8080, 'user', 'pass'\n\n    assert_equal 'localhost', @mech.proxy_addr\n    assert_equal 8080,        @mech.proxy_port\n    assert_equal 'user',      @mech.proxy_user\n    assert_equal 'pass',      @mech.proxy_pass\n\n    assert_equal URI('http://user:pass@localhost:8080'), http.proxy_uri\n  end\n\n  def test_shutdown\n    uri = URI 'http://localhost'\n    jar = HTTP::CookieJar.new\n    jar.parse 'a=b', uri\n\n    @mech.cookie_jar = jar\n\n    @mech.get(\"http://localhost/\")\n\n    assert_match(/Hello World/, @mech.current_page.body)\n    refute_empty @mech.cookies\n\n    @mech.shutdown\n\n    assert_empty @mech.history\n    assert_empty @mech.cookies\n  end\n\n  def test_start\n    body = nil\n\n    Mechanize.start do |m|\n      body = m.get(\"http://localhost/\").body\n    end\n\n    assert_match(/Hello World/, body)\n  end\n\n  def test_submit_bad_form_method\n    page = @mech.get(\"http://localhost/bad_form_test.html\")\n    assert_raises ArgumentError do\n      @mech.submit(page.forms.first)\n    end\n  end\n\n  def test_submit_check_one\n    page = @mech.get('http://localhost/tc_checkboxes.html')\n    form = page.forms.first\n    form.checkboxes_with(:name => 'green')[1].check\n\n    page = @mech.submit(form)\n\n    assert_equal(1, page.links.length)\n    assert_equal('green:on', page.links.first.text)\n  end\n\n  def test_submit_check_two\n    page = @mech.get('http://localhost/tc_checkboxes.html')\n    form = page.forms.first\n    form.checkboxes_with(:name => 'green')[0].check\n    form.checkboxes_with(:name => 'green')[1].check\n\n    page = @mech.submit(form)\n\n    assert_equal(2, page.links.length)\n    assert_equal('green:on', page.links[0].text)\n    assert_equal('green:on', page.links[1].text)\n  end\n\n  def test_submit_enctype\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[0].enctype)\n\n    form = page.forms.first\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.mime_type = \"text/plain\"\n    form.file_uploads.first.file_data = \"Hello World\\n\\n\"\n\n    page = @mech.submit(form)\n\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"name\\\"\",\n      page.body\n    )\n    assert_match('Content-Type: text/plain', page.body)\n    assert_match('Hello World', page.body)\n    assert_match('foo[aaron]', page.body)\n  end\n\n  def test_submit_file_data\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.file_data = File.read __FILE__\n\n    page = @mech.submit(form)\n\n    contents = File.binread __FILE__\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n\n    assert_match(contents, page.body)\n  end\n\n  def test_submit_file_name\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n\n    page = @mech.submit(form)\n\n    contents = File.binread __FILE__\n    basename = File.basename __FILE__\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n    assert_match(contents, page.body)\n  end\n\n  def test_submit_get\n    form = node 'form', 'method' => 'GET', 'action' => '/?a=b'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/', requests.first.path\n  end\n\n  def test_submit_headers\n    page = @mech.get 'http://localhost:2000/form_no_action.html'\n\n    assert form = page.forms.first\n    form.action = '/http_headers'\n\n    page = @mech.submit form, nil, 'foo' => 'bar'\n\n    headers = page.body.split(\"\\n\").map { |x| x.split('|', 2) }.flatten\n    headers = Hash[*headers]\n\n    assert_equal 'bar', headers['foo']\n  end\n\n  def test_submit_multipart\n    page = @mech.get(\"http://localhost/file_upload.html\")\n\n    assert_equal('multipart/form-data', page.forms[1].enctype)\n\n    form = page.forms[1]\n    form.file_uploads.first.file_name = __FILE__\n    form.file_uploads.first.mime_type = \"text/plain\"\n    form.file_uploads.first.file_data = \"Hello World\\n\\n\"\n\n    page = @mech.submit(form)\n\n    basename = File.basename __FILE__\n\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"green[eggs]\\\"; filename=\\\"#{basename}\\\"\",\n      page.body\n    )\n  end\n\n  def test_submit_no_file\n    page = @mech.get(\"http://localhost/file_upload.html\")\n    form = page.forms.first\n    form.field_with(:name => 'name').value = 'Aaron'\n    @page = @mech.submit(form)\n    assert_match('Aaron', @page.body)\n    assert_match(\n      \"Content-Disposition: form-data; name=\\\"userfile1\\\"; filename=\\\"\\\"\",\n      @page.body\n    )\n  end\n\n  def test_submit_post\n    form = node 'form', 'method' => 'POST', 'action' => '/?a=b'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/?a=b', requests.first.path\n  end\n\n  def test_submit_post_pound\n    form = node 'form', 'method' => 'POST', 'action' => '/#1'\n    form = Mechanize::Form.new form, @mech, fake_page\n\n    @mech.submit form\n\n    assert_equal '/', requests.first.path\n  end\n\n  def test_submit_too_many_radiobuttons\n    page = @mech.get(\"http://localhost/form_test.html\")\n    form = page.form_with(:name => 'post_form1')\n    form.radiobuttons.each { |r| r.checked = true }\n\n    assert_raises Mechanize::Error do\n      @mech.submit(form)\n    end\n  end\n\n  def test_transact\n    @mech.get(\"http://localhost/frame_test.html\")\n    assert_equal(1, @mech.history.length)\n    @mech.transact { |a|\n      5.times {\n        @mech.get(\"http://localhost/frame_test.html\")\n      }\n      assert_equal(6, @mech.history.length)\n    }\n    assert_equal(1, @mech.history.length)\n  end\n\n  def test_user_agent_alias_equals_unknown\n    assert_raises ArgumentError do\n      @mech.user_agent_alias = \"Aaron's Browser\"\n    end\n  end\n\n  def test_verify_mode\n    assert_equal OpenSSL::SSL::VERIFY_PEER, @mech.verify_mode\n\n    @mech.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n    assert_equal OpenSSL::SSL::VERIFY_NONE, @mech.verify_mode\n  end\n\n  def test_visited_eh\n    @mech.get(\"http://localhost/content_type_test?ct=application/pdf\")\n\n    assert \\\n      @mech.visited?(\"http://localhost/content_type_test?ct=application/pdf\")\n    assert \\\n      !@mech.visited?(\"http://localhost/content_type_test\")\n    assert \\\n      !@mech.visited?(\"http://localhost/content_type_test?ct=text/html\")\n  end\n\n  def test_visited_eh_link\n    @mech.get(\"http://example/index.html\")\n\n    page = page URI 'http://example'\n    link = node 'a', 'href' => '/index.html'\n    link = Mechanize::Page::Link.new link, page, @mech\n\n    assert @mech.visited? link\n  end\n\n  def test_visited_eh_redirect\n    @mech.get(\"http://localhost/response_code?code=302\")\n\n    assert_equal(\"http://localhost/index.html\", @mech.current_page.uri.to_s)\n\n    assert @mech.visited?('http://localhost/response_code?code=302')\n  end\n\n  def test_no_frames_exists\n    page = @mech.get(\"http://localhost/empty_form.html\");\n    assert_nil page.frame_with(:name => 'noframe')\n    assert_raises Mechanize::ElementNotFoundError do\n      page.frame_with!(:name => 'noframe')\n    end\n  end\n\n  def assert_header(page, header)\n    headers = {}\n\n    page.body.split(/[\\r\\n]+/).each do |page_header|\n      headers.[]=(*page_header.chomp.split(/\\|/))\n    end\n\n    header.each do |key, value|\n      assert(headers.has_key?(key))\n      assert_equal(value, headers[key])\n    end\n  end\nend\n", "require 'mechanize/test_case'\nrequire 'fileutils'\n\nclass TestMechanizeCookieJar < Mechanize::TestCase\n\n  def setup\n    super\n\n    @jar = Mechanize::CookieJar.new\n\n    @jar.extend Minitest::Assertions\n\n    def @jar.add(*args)\n      capture_io { super }\n    end\n\n    def @jar.jar(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n\n    def @jar.save_as(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n\n    def @jar.clear!(*args)\n      result = nil\n      capture_io { result = super }\n      result\n    end\n  end\n\n  def cookie_values(options = {})\n    {\n      :name     => 'Foo',\n      :value    => 'Bar',\n      :path     => '/',\n      :expires  => Time.now + (10 * 86400),\n      :for_domain => true,\n      :domain   => 'rubygems.org'\n   }.merge(options)\n  end\n\n  def test_two_cookies_same_domain_and_name_different_paths\n    url = URI 'http://rubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:path => '/onetwo')))\n\n    assert_equal(1, @jar.cookies(url).length)\n    assert_equal 2, @jar.cookies(URI('http://rubygems.org/onetwo')).length\n  end\n\n  def test_domain_case\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:domain => 'rubygems.Org', :name   => 'aaron')))\n\n    assert_equal(2, @jar.cookies(url).length)\n\n    url2 = URI 'http://rubygems.oRg/'\n    assert_equal(2, @jar.cookies(url2).length)\n  end\n\n  def test_host_only\n    url = URI.parse('http://rubygems.org/')\n\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:domain => 'rubygems.org', :for_domain => false)))\n\n    assert_equal(1, @jar.cookies(url).length)\n\n    assert_equal(1, @jar.cookies(URI('http://rubygems.org/')).length)\n\n    assert_equal(1, @jar.cookies(URI('https://rubygems.org/')).length)\n\n    assert_equal(0, @jar.cookies(URI('http://www.rubygems.org/')).length)\n  end\n\n  def test_empty_value\n    values = cookie_values(:value => \"\")\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    @jar.add url, Mechanize::Cookie.new(values.merge(:domain => 'rubygems.Org',\n                                                     :name   => 'aaron'))\n\n    assert_equal(2, @jar.cookies(url).length)\n\n    url2 = URI 'http://rubygems.oRg/'\n    assert_equal(2, @jar.cookies(url2).length)\n  end\n\n  def test_add_future_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add the same cookie, and we should still only have one\n    @jar.add(url, Mechanize::Cookie.new(cookie_values))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(1, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Make sure we can't get the cookie from different domains\n    assert_equal(0, @jar.cookies(URI('http://google.com/')).length)\n  end\n\n  def test_add_multiple_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add the same cookie, and we should still only have one\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Make sure we can't get the cookie from different domains\n    assert_equal(0, @jar.cookies(URI('http://google.com/')).length)\n  end\n\n  def test_add_rejects_cookies_that_do_not_contain_an_embedded_dot\n    url = URI 'http://rubygems.org/'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.org'))\n    @jar.add(url, tld_cookie)\n    # single dot domain is now treated as no domain\n    # single_dot_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.'))\n    # @jar.add(url, single_dot_cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_fall_back_rules_for_local_domains\n    url = URI 'http://www.example.local'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.local'))\n    @jar.add(url, tld_cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n\n    sld_cookie = Mechanize::Cookie.new(cookie_values(:domain => '.example.local'))\n    @jar.add(url, sld_cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_makes_exception_for_localhost\n    url = URI 'http://localhost'\n\n    tld_cookie = Mechanize::Cookie.new(cookie_values(:domain => 'localhost'))\n    @jar.add(url, tld_cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_cookie_for_the_parent_domain\n    url = URI 'http://x.foo.com'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.foo.com'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_add_does_not_reject_cookies_from_a_nested_subdomain\n    url = URI 'http://y.x.foo.com'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.foo.com'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookie_without_leading_dot_does_not_cause_substring_match\n    url = URI 'http://arubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => 'rubygems.org'))\n    @jar.add(url, cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_without_leading_dot_matches_subdomains\n    url = URI 'http://admin.rubygems.org/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => 'rubygems.org'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_subdomains\n    url = URI 'http://admin.rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_parent_domains\n    url = URI 'http://rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_with_leading_dot_match_parent_domains_exactly\n    url = URI 'http://arubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:domain => '.rubygems.org')))\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv4_address_matches_the_exact_ipaddress\n    url = URI 'http://192.168.0.1/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '192.168.0.1'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv4_address_does_not_cause_subdomain_match\n    url = URI 'http://192.168.0.1/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '.0.1'))\n    @jar.add(url, cookie)\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_cookie_for_ipv6_address_matches_the_exact_ipaddress\n    url = URI 'http://[fe80::0123:4567:89ab:cdef]/'\n\n    cookie = Mechanize::Cookie.new(cookie_values(:domain => '[fe80::0123:4567:89ab:cdef]'))\n    @jar.add(url, cookie)\n\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_cookies_dot\n    url = URI 'http://www.host.example/'\n\n    @jar.add(url,\n             Mechanize::Cookie.new(cookie_values(:domain => 'www.host.example')))\n\n    url = URI 'http://wwwxhost.example/'\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_clear_bang\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    @jar.clear!\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_save_cookies_yaml\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      value = @jar.save_as(\"cookies.yml\")\n      assert_same @jar, value\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.yml\")\n      assert_equal(2, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n  def test_save_session_cookies_yaml\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.yml\", :format => :yaml, :session => true)\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.yml\")\n      assert_equal(3, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n\n  def test_save_cookies_cookiestxt\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    s_cookie = Mechanize::Cookie.new(cookie_values(:name => 'Bar',\n                                              :expires => nil))\n\n    @jar.add(url, cookie)\n    @jar.add(url, s_cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n\n    assert_equal(3, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n\n      assert_match(/\\A# (?:Netscape )?HTTP Cookie File$/, File.read(\"cookies.txt\"))\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt)\n      assert_equal(2, jar.cookies(url).length)\n    end\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt, :session => true)\n\n      assert_match(/\\A# (?:Netscape )?HTTP Cookie File$/, File.read(\"cookies.txt\"))\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt)\n      assert_equal(3, jar.cookies(url).length)\n    end\n\n    assert_equal(3, @jar.cookies(url).length)\n  end\n\n  def test_expire_cookies\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values(:expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        cookie_values( :name => 'Baz', :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_session_cookies\n    values = cookie_values(:expires => nil)\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we can get the cookie from different paths\n    assert_equal(2, @jar.cookies(URI('http://rubygems.org/login')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge(:expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(\n        values.merge(:name => 'Baz', :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n\n    # When given a URI with a blank path, CookieJar#cookies should return\n    # cookies with the path '/':\n    url = URI 'http://rubygems.org'\n    assert_equal '', url.path\n    assert_equal(0, @jar.cookies(url).length)\n    # Now add a cookie with the path set to '/':\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'has_root_path',\n                                          :path => '/')))\n    assert_equal(1, @jar.cookies(url).length)\n  end\n\n  def test_paths\n    values = cookie_values(:path => \"/login\", :expires => nil)\n    url = URI 'http://rubygems.org/login'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Add a second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'Baz' )))\n    assert_equal(2, @jar.cookies(url).length)\n\n    # Make sure we don't get the cookie in a different path\n    assert_equal(0, @jar.cookies(URI('http://rubygems.org/hello')).length)\n    assert_equal(0, @jar.cookies(URI('http://rubygems.org/')).length)\n\n    # Expire the first cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :expires => Time.now - (10 * 86400))))\n    assert_equal(1, @jar.cookies(url).length)\n\n    # Expire the second cookie\n    @jar.add(url, Mechanize::Cookie.new(values.merge( :name => 'Baz',\n                                          :expires => Time.now - (10 * 86400))))\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_save_and_read_cookiestxt\n    url = URI 'http://rubygems.org/'\n\n    # Add one cookie with an expiration date in the future\n    cookie = Mechanize::Cookie.new(cookie_values)\n    @jar.add(url, cookie)\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:name => 'Baz')))\n    assert_equal(2, @jar.cookies(url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n      @jar.clear!\n\n      @jar.load(\"cookies.txt\", :cookiestxt)\n    end\n\n    assert_equal(2, @jar.cookies(url).length)\n  end\n\n  def test_save_and_read_cookiestxt_with_session_cookies\n    url = URI 'http://rubygems.org/'\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values(:expires => nil)))\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n      @jar.clear!\n\n      @jar.load(\"cookies.txt\", :cookiestxt)\n    end\n\n    assert_equal(0, @jar.cookies(url).length)\n  end\n\n  def test_prevent_command_injection_when_saving\n    url = URI 'http://rubygems.org/'\n    path = '| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\''\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values))\n\n    in_tmpdir do\n      @jar.save_as(path, :cookiestxt)\n      assert_equal(false, File.exist?('vul.txt'))\n    end\n  end\n\n  def test_prevent_command_injection_when_loading\n    url = URI 'http://rubygems.org/'\n    path = '| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\''\n\n    @jar.add(url, Mechanize::Cookie.new(cookie_values))\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n      @jar.clear!\n\n      assert_raises Errno::ENOENT do\n        @jar.load(path, :cookiestxt)\n      end\n      assert_equal(false, File.exist?('vul.txt'))\n    end\n  end\n\n  def test_save_and_read_expired_cookies\n    url = URI 'http://rubygems.org/'\n\n    @jar.jar['rubygems.org'] = {}\n\n\n    @jar.add url, Mechanize::Cookie.new(cookie_values)\n\n    # HACK no asertion\n  end\n\n  def test_ssl_cookies\n    # thanks to michal \"ocher\" ochman for reporting the bug responsible for this test.\n    values = cookie_values(:expires => nil)\n    values_ssl = values.merge(:name => 'Baz', :domain => \"#{values[:domain]}:443\")\n    url = URI 'https://rubygems.org/login'\n\n    cookie = Mechanize::Cookie.new(values)\n    @jar.add(url, cookie)\n    assert_equal(1, @jar.cookies(url).length, \"did not handle SSL cookie\")\n\n    cookie = Mechanize::Cookie.new(values_ssl)\n    @jar.add(url, cookie)\n    assert_equal(2, @jar.cookies(url).length, \"did not handle SSL cookie with :443\")\n  end\n\n  def test_secure_cookie\n    nurl = URI 'http://rubygems.org/login'\n    surl = URI 'https://rubygems.org/login'\n\n    ncookie = Mechanize::Cookie.new(cookie_values(:name => 'Foo1'))\n    scookie = Mechanize::Cookie.new(cookie_values(:name => 'Foo2', :secure => true))\n\n    @jar.add(nurl, ncookie)\n    @jar.add(nurl, scookie)\n    @jar.add(surl, ncookie)\n    @jar.add(surl, scookie)\n\n    assert_equal('Foo1',      @jar.cookies(nurl).map { |c| c.name }.sort.join(' ') )\n    assert_equal('Foo1 Foo2', @jar.cookies(surl).map { |c| c.name }.sort.join(' ') )\n  end\n\n  def test_save_cookies_cookiestxt_subdomain\n    top_url = URI 'http://rubygems.org/'\n    subdomain_url = URI 'http://admin.rubygems.org/'\n\n    # cookie1 is for *.rubygems.org; cookie2 is only for rubygems.org, no subdomains\n    cookie1 = Mechanize::Cookie.new(cookie_values)\n    cookie2 = Mechanize::Cookie.new(cookie_values(:name => 'Boo', :for_domain => false))\n\n    @jar.add(top_url, cookie1)\n    @jar.add(top_url, cookie2)\n\n    assert_equal(2, @jar.cookies(top_url).length)\n    assert_equal(1, @jar.cookies(subdomain_url).length)\n\n    in_tmpdir do\n      @jar.save_as(\"cookies.txt\", :cookiestxt)\n\n      jar = Mechanize::CookieJar.new\n      jar.load(\"cookies.txt\", :cookiestxt) # HACK test the format\n      assert_equal(2, jar.cookies(top_url).length)\n      assert_equal(1, jar.cookies(subdomain_url).length)\n\n      # Check that we actually wrote the file correctly (not just that we were\n      # able to read what we wrote):\n      #\n      # * Cookies that only match exactly the domain specified must not have a\n      #   leading dot, and must have FALSE as the second field.\n      # * Cookies that match subdomains may have a leading dot, and must have\n      #   TRUE as the second field.\n      cookies_txt = File.readlines(\"cookies.txt\")\n      assert_equal(1, cookies_txt.grep( /^rubygems\\.org\\tFALSE/ ).length)\n      assert_equal(1, cookies_txt.grep( /^\\.rubygems\\.org\\tTRUE/ ).length)\n    end\n\n    assert_equal(2, @jar.cookies(top_url).length)\n    assert_equal(1, @jar.cookies(subdomain_url).length)\n  end\nend\n", "require 'mechanize/test_case'\n\nclass TestMechanizeDownload < Mechanize::TestCase\n\n  def setup\n    super\n\n    @parser = Mechanize::Download\n  end\n\n  def test_body\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    assert_equal '0123456789', download.body\n    assert_equal 0, download.body_io.pos\n  end\n\n  def test_save_string_io\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    in_tmpdir do\n      filename = download.save\n\n      assert File.exist? 'foo.html'\n      assert_equal \"foo.html\", filename\n    end\n  end\n\n  def test_save_bang\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    in_tmpdir do\n      filename = download.save!\n\n      assert File.exist? 'foo.html'\n      assert_equal \"foo.html\", filename\n    end\n  end\n\n  def test_save_bang_does_not_allow_command_injection\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    in_tmpdir do\n      download.save!('| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\'')\n      refute_operator(File, :exist?, \"vul.txt\")\n    end\n  end\n\n  def test_save_tempfile\n    uri = URI.parse 'http://example/foo.html'\n    Tempfile.open @NAME do |body_io|\n      body_io.unlink\n      body_io.write '0123456789'\n\n      body_io.flush\n      body_io.rewind\n\n      download = @parser.new uri, nil, body_io\n\n      in_tmpdir do\n        filename = download.save\n\n        assert File.exist? 'foo.html'\n        assert_equal \"foo.html\", filename\n\n        filename = download.save\n\n        assert File.exist? 'foo.html.1'\n        assert_equal \"foo.html.1\", filename\n\n        filename = download.save\n\n        assert File.exist? 'foo.html.2'\n        assert_equal \"foo.html.2\", filename\n      end\n    end\n  end\n\n  def test_filename\n    uri = URI.parse 'http://example/foo.html'\n    body_io = StringIO.new '0123456789'\n\n    download = @parser.new uri, nil, body_io\n\n    assert_equal \"foo.html\", download.filename\n  end\nend\n\n", "require 'mechanize/test_case'\n\nclass TestMechanizeFile < Mechanize::TestCase\n\n  def setup\n    super\n\n    @parser = Mechanize::File\n  end\n\n  def test_save\n    uri = URI 'http://example/name.html'\n    page = Mechanize::File.new uri, nil, '0123456789'\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html'\n        assert_equal '0123456789', File.read('test.html')\n        assert_equal \"test.html\", filename\n\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html.1'\n        assert_equal '0123456789', File.read('test.html.1')\n        assert_equal \"test.html.1\", filename\n\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html.2'\n        assert_equal '0123456789', File.read('test.html.2')\n        assert_equal \"test.html.2\", filename\n      end\n    end\n  end\n\n  def test_save_default\n    uri = URI 'http://example/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save\n\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save\n\n        assert File.exist? 'test.html.1'\n        assert_equal \"test.html.1\", filename\n\n        filename = page.save\n\n        assert File.exist? 'test.html.2'\n        assert_equal \"test.html.2\", filename\n      end\n    end\n  end\n\n  def test_save_default_dots\n    uri = URI 'http://localhost/../test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save\n        assert File.exist? 'test.html.1'\n        assert_equal \"test.html.1\", filename\n      end\n    end\n  end\n\n  def test_filename\n    uri = URI 'http://localhost/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    assert_equal \"test.html\", page.filename\n  end\n\n  def test_save_overwrite\n    uri = URI 'http://example/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    Dir.mktmpdir do |dir|\n      Dir.chdir dir do\n        filename = page.save 'test.html'\n\n        assert File.exist? 'test.html'\n        assert_equal \"test.html\", filename\n\n        filename = page.save! 'test.html'\n\n        assert File.exist? 'test.html'\n        refute File.exist? 'test.html.1'\n        assert_equal \"test.html\", filename\n      end\n    end\n  end\n\n  def test_save_bang_does_not_allow_command_injection\n    uri = URI 'http://example/test.html'\n    page = Mechanize::File.new uri, nil, ''\n\n    in_tmpdir do\n      page.save!('| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\'')\n      refute_operator(File, :exist?, \"vul.txt\")\n    end\n  end\nend\n\n", "require 'mechanize/test_case'\n\nclass TestMechanizeFileResponse < Mechanize::TestCase\n  def test_content_type\n    Tempfile.open %w[pi .nothtml] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_nil res['content-type']\n    end\n\n    Tempfile.open %w[pi .xhtml] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_equal 'text/html', res['content-type']\n    end\n\n    Tempfile.open %w[pi .html] do |tempfile|\n      res = Mechanize::FileResponse.new tempfile.path\n      assert_equal 'text/html', res['Content-Type']\n    end\n  end\n\n  def test_read_body\n    Tempfile.open %w[pi .html] do |tempfile|\n      tempfile.write(\"asdfasdfasdf\")\n      tempfile.close\n\n      res = Mechanize::FileResponse.new(tempfile.path)\n      res.read_body do |input|\n        assert_equal(\"asdfasdfasdf\", input)\n      end\n    end\n  end\n\n  def test_read_body_does_not_allow_command_injection\n    in_tmpdir do\n      FileUtils.touch('| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\'')\n      res = Mechanize::FileResponse.new('| ruby -rfileutils -e \\'FileUtils.touch(\"vul.txt\")\\'')\n      res.read_body { |_| }\n      refute_operator(File, :exist?, \"vul.txt\")\n    end\n  end\nend\n"], "filenames": ["CHANGELOG.rdoc", "lib/mechanize.rb", "lib/mechanize/cookie_jar.rb", "lib/mechanize/download.rb", "lib/mechanize/file.rb", "lib/mechanize/file_response.rb", "lib/mechanize/test_case.rb", "lib/mechanize/test_case/gzip_servlet.rb", "lib/mechanize/test_case/verb_servlet.rb", "test/test_mechanize.rb", "test/test_mechanize_cookie_jar.rb", "test/test_mechanize_download.rb", "test/test_mechanize_file.rb", "test/test_mechanize_file_response.rb"], "buggy_code_start_loc": [3, 399, 68, 74, 85, 18, 233, 16, 3, 344, 1, 48, 105, 4], "buggy_code_end_loc": [3, 400, 123, 75, 86, 19, 236, 17, 9, 344, 500, 88, 105, 24], "fixing_code_start_loc": [4, 399, 68, 74, 85, 18, 233, 16, 3, 345, 2, 49, 106, 3], "fixing_code_end_loc": [20, 400, 123, 75, 86, 19, 236, 17, 7, 353, 531, 98, 115, 41], "type": "CWE-78", "message": "Mechanize is an open-source ruby library that makes automated web interaction easy. In Mechanize from version 2.0.0 and before version 2.7.7 there is a command injection vulnerability. Affected versions of mechanize allow for OS commands to be injected using several classes' methods which implicitly use Ruby's Kernel.open method. Exploitation is possible only if untrusted input is used as a local filename and passed to any of these calls: Mechanize::CookieJar#load, Mechanize::CookieJar#save_as, Mechanize#download, Mechanize::Download#save, Mechanize::File#save, and Mechanize::FileResponse#read_body. This is fixed in version 2.7.7.", "other": {"cve": {"id": "CVE-2021-21289", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-02T19:15:14.220", "lastModified": "2022-04-26T15:07:42.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mechanize is an open-source ruby library that makes automated web interaction easy. In Mechanize from version 2.0.0 and before version 2.7.7 there is a command injection vulnerability. Affected versions of mechanize allow for OS commands to be injected using several classes' methods which implicitly use Ruby's Kernel.open method. Exploitation is possible only if untrusted input is used as a local filename and passed to any of these calls: Mechanize::CookieJar#load, Mechanize::CookieJar#save_as, Mechanize#download, Mechanize::Download#save, Mechanize::File#save, and Mechanize::FileResponse#read_body. This is fixed in version 2.7.7."}, {"lang": "es", "value": "Mechanize es una biblioteca de ruby ??de c\u00f3digo abierto que facilita la interacci\u00f3n web automatizada.&#xa0;En Mechanize desde versi\u00f3n 2.0.0 y versiones anteriores a 2.7.7, se presenta una vulnerabilidad de inyecci\u00f3n de comandos.&#xa0;Las versiones afectadas de mechanize permiten a unos comandos del Sistema Operativo ser inyectados usando m\u00e9todos de varias clases que impl\u00edcitamente usan el m\u00e9todo Kernel.open de Ruby.&#xa0;Una explotaci\u00f3n es posible solo si es usada una entrada que no sea confiable como nombre de archivo local y sea pasada a cualquiera de estas llamadas: Mechanize::CookieJar#load, Mechanize::CookieJar#save_as, Mechanize#download, Mechanize::Download#save, Mechanize::File#save y Mechanize::FileResponse#read_body.&#xa0;Esto es corregido en versi\u00f3n 2.7.7"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.6}, "baseSeverity": "HIGH", "exploitabilityScore": 4.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mechanize_project:mechanize:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "2.0", "versionEndExcluding": "2.7.7", "matchCriteriaId": "3F476565-B5B7-4547-812E-F9428E9FA312"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/sparklemotion/mechanize/commit/66a6a1bfa653a5f13274a396a5e5441238656aa0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/mechanize/releases/tag/v2.7.7", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/mechanize/security/advisories/GHSA-qrqm-fpv6-6r8g", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LBVVJUL4P4KCJH4IQTHFZ4ATXY7XXZPV/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YNFZ7ROYS6V4J5L5PRAJUG2AWC7VXR2V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://rubygems.org/gems/mechanize/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-17", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/mechanize/commit/66a6a1bfa653a5f13274a396a5e5441238656aa0"}}