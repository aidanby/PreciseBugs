{"buggy_code": ["/*\n * Minio Cloud Storage, (C) 2015-2018 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(\"Authorization\"), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(\"Authorization\"), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(\"Authorization\"), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(\"Authorization\"), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.URL.Query()[\"X-Amz-Credential\"]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.URL.Query()[\"AWSAccessKeyId\"]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\treturn strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data\") &&\n\t\tr.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(\"x-amz-content-sha256\") == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Header[\"Authorization\"]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\n// checkAdminRequestAuthType checks whether the request is a valid signature V2 or V4 request.\n// It does not accept presigned or JWT or anonymous requests.\nfunc checkAdminRequestAuthType(r *http.Request, region string) APIErrorCode {\n\ts3Err := ErrAccessDenied\n\tif getRequestAuthType(r) == authTypeSigned { // we only support V4 (no presign)\n\t\ts3Err = isReqAuthenticated(r, region)\n\t}\n\tif s3Err != ErrNone {\n\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"requestHeaders\", dumpRequest(r))\n\t\tctx := logger.SetReqInfo(context.Background(), reqInfo)\n\t\tlogger.LogIf(ctx, errors.New(getAPIError(s3Err).Description))\n\t}\n\treturn s3Err\n}\n\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) APIErrorCode {\n\tisOwner := true\n\taccountName := globalServerConfig.GetCredential().AccessKey\n\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown:\n\t\treturn ErrAccessDenied\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif errorCode := isReqAuthenticatedV2(r); errorCode != ErrNone {\n\t\t\treturn errorCode\n\t\t}\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalServerConfig.GetRegion()\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\n\t\tif errorCode := isReqAuthenticated(r, region); errorCode != ErrNone {\n\t\t\treturn errorCode\n\t\t}\n\tdefault:\n\t\tisOwner = false\n\t\taccountName = \"\"\n\t}\n\n\t// LocationConstraint is valid only for CreateBucketAction.\n\tvar locationConstraint string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\n\t\tvar s3Error APIErrorCode\n\t\tlocationConstraint, s3Error = parseLocationConstraint(r)\n\t\tif s3Error != ErrNone {\n\t\t\treturn s3Error\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tif globalPolicySys.IsAllowed(policy.Args{\n\t\tAccountName:     accountName,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, locationConstraint),\n\t\tIsOwner:         isOwner,\n\t\tObjectName:      objectName,\n\t}) {\n\t\treturn ErrNone\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(r *http.Request, region string) (s3Error APIErrorCode) {\n\tif r == nil {\n\t\treturn ErrInternalError\n\t}\n\n\tif errCode := reqSignatureV4Verify(r, region); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tpayload, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlogger.LogIf(context.Background(), err)\n\t\treturn ErrInternalError\n\t}\n\n\t// Populate back the payload.\n\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\n\t// Verify Content-Md5, if payload is set.\n\tif clntMD5B64, ok := r.Header[\"Content-Md5\"]; ok {\n\t\tif clntMD5B64[0] == \"\" {\n\t\t\treturn ErrInvalidDigest\n\t\t}\n\t\tmd5Sum, err := base64.StdEncoding.Strict().DecodeString(clntMD5B64[0])\n\t\tif err != nil {\n\t\t\treturn ErrInvalidDigest\n\t\t}\n\t\tif !bytes.Equal(md5Sum, getMD5Sum(payload)) {\n\t\t\treturn ErrBadDigest\n\t\t}\n\t}\n\n\tif skipContentSha256Cksum(r) {\n\t\treturn ErrNone\n\t}\n\n\t// Verify that X-Amz-Content-Sha256 Header == sha256(payload)\n\t// If X-Amz-Content-Sha256 header is not sent then we don't calculate/verify sha256(payload)\n\tsumHex, ok := r.Header[\"X-Amz-Content-Sha256\"]\n\tif isRequestPresignedSignatureV4(r) {\n\t\tsumHex, ok = r.URL.Query()[\"X-Amz-Content-Sha256\"]\n\t}\n\tif ok {\n\t\tif sumHex[0] == \"\" {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t\tsum, err := hex.DecodeString(sumHex[0])\n\t\tif err != nil {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t\tif !bytes.Equal(sum, getSHA256Sum(payload)) {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\treturn ErrNone\n}\n\n// authHandler - handles all the incoming authorization headers and validates them if possible.\ntype authHandler struct {\n\thandler http.Handler\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\treturn authHandler{h}\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// handler for validating incoming authorization headers.\nfunc (a authHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\taType := getRequestAuthType(r)\n\tif isSupportedS3AuthType(aType) {\n\t\t// Let top level caller validate for anonymous and known signed requests.\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeJWT {\n\t\t// Validate Authorization header if its valid for JWT request.\n\t\tif !isHTTPRequestValid(r) {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\twriteErrorResponse(w, ErrSignatureVersionNotSupported, r.URL)\n}\n", "/*\n * Minio Cloud Storage, (C) 2016, 2017 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/minio/pkg/auth\"\n)\n\n// Test get request auth type.\nfunc TestGetRequestAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\treq   *http.Request\n\t\tauthT authType\n\t}\n\ttestCases := []testCase{\n\t\t// Test case - 1\n\t\t// Check for generic signature v4 header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\":        []string{\"AWS4-HMAC-SHA256 <cred_string>\"},\n\t\t\t\t\t\"X-Amz-Content-Sha256\": []string{streamingContentSHA256},\n\t\t\t\t\t\"Content-Encoding\":     []string{streamingContentEncoding},\n\t\t\t\t},\n\t\t\t\tMethod: \"PUT\",\n\t\t\t},\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t},\n\t\t// Test case - 2\n\t\t// Check for JWT header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"Bearer 12313123\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeJWT,\n\t\t},\n\t\t// Test case - 3\n\t\t// Empty authorization header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeUnknown,\n\t\t},\n\t\t// Test case - 4\n\t\t// Check for presigned.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:     \"127.0.0.1:9000\",\n\t\t\t\t\tScheme:   httpScheme,\n\t\t\t\t\tPath:     \"/\",\n\t\t\t\t\tRawQuery: \"X-Amz-Credential=EXAMPLEINVALIDEXAMPL%2Fs3%2F20160314%2Fus-east-1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypePresigned,\n\t\t},\n\t\t// Test case - 5\n\t\t// Check for post policy.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Content-Type\": []string{\"multipart/form-data\"},\n\t\t\t\t},\n\t\t\t\tMethod: \"POST\",\n\t\t\t},\n\t\t\tauthT: authTypePostPolicy,\n\t\t},\n\t}\n\n\t// .. Tests all request auth type.\n\tfor i, testc := range testCases {\n\t\tauthT := getRequestAuthType(testc.req)\n\t\tif authT != testc.authT {\n\t\t\tt.Errorf(\"Test %d: Expected %d, got %d\", i+1, testc.authT, authT)\n\t\t}\n\t}\n}\n\n// Test all s3 supported auth types.\nfunc TestS3SupportedAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\tauthT authType\n\t\tpass  bool\n\t}\n\t// List of all valid and invalid test cases.\n\ttestCases := []testCase{\n\t\t// Test 1 - supported s3 type anonymous.\n\t\t{\n\t\t\tauthT: authTypeAnonymous,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 2 - supported s3 type presigned.\n\t\t{\n\t\t\tauthT: authTypePresigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 3 - supported s3 type signed.\n\t\t{\n\t\t\tauthT: authTypeSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 4 - supported s3 type with post policy.\n\t\t{\n\t\t\tauthT: authTypePostPolicy,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 5 - supported s3 type with streaming signed.\n\t\t{\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 6 - supported s3 type with signature v2.\n\t\t{\n\t\t\tauthT: authTypeSignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 7 - supported s3 type with presign v2.\n\t\t{\n\t\t\tauthT: authTypePresignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 8 - JWT is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeJWT,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 9 - unknown auth header is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeUnknown,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 10 - some new auth type is not supported s3 type.\n\t\t{\n\t\t\tauthT: authType(9),\n\t\t\tpass:  false,\n\t\t},\n\t}\n\t// Validate all the test cases.\n\tfor i, tt := range testCases {\n\t\tok := isSupportedS3AuthType(tt.authT)\n\t\tif ok != tt.pass {\n\t\t\tt.Errorf(\"Test %d:, Expected %t, got %t\", i+1, tt.pass, ok)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestPresignedSignatureV2(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"AWSAccessKeyId\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"AWSAccessKeyId\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV2(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsRequestPresignedSignatureV4 - Test validates the logic for presign signature verision v4 detection.\nfunc TestIsRequestPresignedSignatureV4(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"\"X-Amz-Credential\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"X-Amz-Credential\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV4(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// Provides a fully populated http request instance, fails otherwise.\nfunc mustNewRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq, err := newTestRequest(method, urlStr, contentLength, body)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to initialize new http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V4, fails if not able to do so.\nfunc mustNewSignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V2, fails if not able to do so.\nfunc mustNewSignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV2(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V2, fails if not able to do so.\nfunc mustNewPresignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := preSignV2(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V4, fails if not able to do so.\nfunc mustNewPresignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := preSignV4(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedShortMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"invalid-digest\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedEmptyMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedBadMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"YWFhYWFhYWFhYWFhYWFhCg==\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// Tests is requested authenticated function, tests replies for s3 errors.\nfunc TestIsReqAuthenticated(t *testing.T) {\n\tpath, err := newTestConfig(globalMinioDefaultRegion)\n\tif err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\tdefer os.RemoveAll(path)\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalServerConfig.SetCredential(creds)\n\n\t// List of test cases for validating http request authentication.\n\ttestCases := []struct {\n\t\treq     *http.Request\n\t\ts3Error APIErrorCode\n\t}{\n\t\t// When request is nil, internal error is returned.\n\t\t{nil, ErrInternalError},\n\t\t// When request is unsigned, access denied is returned.\n\t\t{mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrAccessDenied},\n\t\t// Empty Content-Md5 header.\n\t\t{mustNewSignedEmptyMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// Short Content-Md5 header.\n\t\t{mustNewSignedShortMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// When request is properly signed, but has bad Content-MD5 header.\n\t\t{mustNewSignedBadMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrBadDigest},\n\t\t// When request is properly signed, error is none.\n\t\t{mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrNone},\n\t}\n\n\t// Validates all testcases.\n\tfor _, testCase := range testCases {\n\t\tif s3Error := isReqAuthenticated(testCase.req, globalServerConfig.GetRegion()); s3Error != testCase.s3Error {\n\t\t\tt.Fatalf(\"Unexpected s3error returned wanted %d, got %d\", testCase.s3Error, s3Error)\n\t\t}\n\t}\n}\nfunc TestCheckAdminRequestAuthType(t *testing.T) {\n\tpath, err := newTestConfig(globalMinioDefaultRegion)\n\tif err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\tdefer os.RemoveAll(path)\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalServerConfig.SetCredential(creds)\n\ttestCases := []struct {\n\t\tRequest *http.Request\n\t\tErrCode APIErrorCode\n\t}{\n\t\t{Request: mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrNone},\n\t\t{Request: mustNewSignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t}\n\tfor i, testCase := range testCases {\n\t\tif s3Error := checkAdminRequestAuthType(testCase.Request, globalServerConfig.GetRegion()); s3Error != testCase.ErrCode {\n\t\t\tt.Errorf(\"Test %d: Unexpected s3error returned wanted %d, got %d\", i, testCase.ErrCode, s3Error)\n\t\t}\n\t}\n}\n", "/*\n * Minio Cloud Storage, (C) 2017 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage hash\n\nimport (\n\t\"bytes\"\n\t\"crypto/md5\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"hash\"\n\t\"io\"\n\n\tsha256 \"github.com/minio/sha256-simd\"\n)\n\nvar errNestedReader = errors.New(\"Nesting of Reader detected, not allowed\")\n\n// Reader writes what it reads from an io.Reader to an MD5 and SHA256 hash.Hash.\n// Reader verifies that the content of the io.Reader matches the expected checksums.\ntype Reader struct {\n\tsrc  io.Reader\n\tsize int64\n\n\tmd5sum, sha256sum   []byte // Byte values of md5sum, sha256sum of client sent values.\n\tmd5Hash, sha256Hash hash.Hash\n}\n\n// NewReader returns a new hash Reader which computes the MD5 sum and\n// SHA256 sum (if set) of the provided io.Reader at EOF.\nfunc NewReader(src io.Reader, size int64, md5Hex, sha256Hex string) (*Reader, error) {\n\tif _, ok := src.(*Reader); ok {\n\t\treturn nil, errNestedReader\n\t}\n\n\tsha256sum, err := hex.DecodeString(sha256Hex)\n\tif err != nil {\n\t\treturn nil, SHA256Mismatch{}\n\t}\n\n\tmd5sum, err := hex.DecodeString(md5Hex)\n\tif err != nil {\n\t\treturn nil, BadDigest{}\n\t}\n\n\tvar sha256Hash hash.Hash\n\tif len(sha256sum) != 0 {\n\t\tsha256Hash = sha256.New()\n\t}\n\n\treturn &Reader{\n\t\tmd5sum:     md5sum,\n\t\tsha256sum:  sha256sum,\n\t\tsrc:        io.LimitReader(src, size),\n\t\tsize:       size,\n\t\tmd5Hash:    md5.New(),\n\t\tsha256Hash: sha256Hash,\n\t}, nil\n}\n\nfunc (r *Reader) Read(p []byte) (n int, err error) {\n\tn, err = r.src.Read(p)\n\tif n > 0 {\n\t\tr.md5Hash.Write(p[:n])\n\t\tif r.sha256Hash != nil {\n\t\t\tr.sha256Hash.Write(p[:n])\n\t\t}\n\t}\n\n\t// At io.EOF verify if the checksums are right.\n\tif err == io.EOF {\n\t\tif cerr := r.Verify(); cerr != nil {\n\t\t\treturn 0, cerr\n\t\t}\n\t}\n\n\treturn\n}\n\n// Size returns the absolute number of bytes the Reader\n// will return during reading. It returns -1 for unlimited\n// data.\nfunc (r *Reader) Size() int64 { return r.size }\n\n// MD5 - returns byte md5 value\nfunc (r *Reader) MD5() []byte {\n\treturn r.md5sum\n}\n\n// MD5Current - returns byte md5 value of the current state\n// of the md5 hash after reading the incoming content.\n// NOTE: Calling this function multiple times might yield\n// different results if they are intermixed with Reader.\nfunc (r *Reader) MD5Current() []byte {\n\treturn r.md5Hash.Sum(nil)\n}\n\n// SHA256 - returns byte sha256 value\nfunc (r *Reader) SHA256() []byte {\n\treturn r.sha256sum\n}\n\n// MD5HexString returns hex md5 value.\nfunc (r *Reader) MD5HexString() string {\n\treturn hex.EncodeToString(r.md5sum)\n}\n\n// MD5Base64String returns base64 encoded MD5sum value.\nfunc (r *Reader) MD5Base64String() string {\n\treturn base64.StdEncoding.EncodeToString(r.md5sum)\n}\n\n// SHA256HexString returns hex sha256 value.\nfunc (r *Reader) SHA256HexString() string {\n\treturn hex.EncodeToString(r.sha256sum)\n}\n\n// Verify verifies if the computed MD5 sum and SHA256 sum are\n// equal to the ones specified when creating the Reader.\nfunc (r *Reader) Verify() error {\n\tif r.sha256Hash != nil && len(r.sha256sum) > 0 {\n\t\tif sum := r.sha256Hash.Sum(nil); !bytes.Equal(r.sha256sum, sum) {\n\t\t\treturn SHA256Mismatch{hex.EncodeToString(r.sha256sum), hex.EncodeToString(sum)}\n\t\t}\n\t}\n\tif len(r.md5sum) > 0 {\n\t\tif sum := r.md5Hash.Sum(nil); !bytes.Equal(r.md5sum, sum) {\n\t\t\treturn BadDigest{hex.EncodeToString(r.md5sum), hex.EncodeToString(sum)}\n\t\t}\n\t}\n\treturn nil\n}\n"], "fixing_code": ["/*\n * Minio Cloud Storage, (C) 2015-2018 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/hash\"\n\t\"github.com/minio/minio/pkg/policy\"\n)\n\n// Verify if request has JWT.\nfunc isRequestJWT(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(\"Authorization\"), jwtAlgorithm)\n}\n\n// Verify if request has AWS Signature Version '4'.\nfunc isRequestSignatureV4(r *http.Request) bool {\n\treturn strings.HasPrefix(r.Header.Get(\"Authorization\"), signV4Algorithm)\n}\n\n// Verify if request has AWS Signature Version '2'.\nfunc isRequestSignatureV2(r *http.Request) bool {\n\treturn (!strings.HasPrefix(r.Header.Get(\"Authorization\"), signV4Algorithm) &&\n\t\tstrings.HasPrefix(r.Header.Get(\"Authorization\"), signV2Algorithm))\n}\n\n// Verify if request has AWS PreSign Version '4'.\nfunc isRequestPresignedSignatureV4(r *http.Request) bool {\n\t_, ok := r.URL.Query()[\"X-Amz-Credential\"]\n\treturn ok\n}\n\n// Verify request has AWS PreSign Version '2'.\nfunc isRequestPresignedSignatureV2(r *http.Request) bool {\n\t_, ok := r.URL.Query()[\"AWSAccessKeyId\"]\n\treturn ok\n}\n\n// Verify if request has AWS Post policy Signature Version '4'.\nfunc isRequestPostPolicySignatureV4(r *http.Request) bool {\n\treturn strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data\") &&\n\t\tr.Method == http.MethodPost\n}\n\n// Verify if the request has AWS Streaming Signature Version '4'. This is only valid for 'PUT' operation.\nfunc isRequestSignStreamingV4(r *http.Request) bool {\n\treturn r.Header.Get(\"x-amz-content-sha256\") == streamingContentSHA256 &&\n\t\tr.Method == http.MethodPut\n}\n\n// Authorization type.\ntype authType int\n\n// List of all supported auth types.\nconst (\n\tauthTypeUnknown authType = iota\n\tauthTypeAnonymous\n\tauthTypePresigned\n\tauthTypePresignedV2\n\tauthTypePostPolicy\n\tauthTypeStreamingSigned\n\tauthTypeSigned\n\tauthTypeSignedV2\n\tauthTypeJWT\n)\n\n// Get request authentication type.\nfunc getRequestAuthType(r *http.Request) authType {\n\tif isRequestSignatureV2(r) {\n\t\treturn authTypeSignedV2\n\t} else if isRequestPresignedSignatureV2(r) {\n\t\treturn authTypePresignedV2\n\t} else if isRequestSignStreamingV4(r) {\n\t\treturn authTypeStreamingSigned\n\t} else if isRequestSignatureV4(r) {\n\t\treturn authTypeSigned\n\t} else if isRequestPresignedSignatureV4(r) {\n\t\treturn authTypePresigned\n\t} else if isRequestJWT(r) {\n\t\treturn authTypeJWT\n\t} else if isRequestPostPolicySignatureV4(r) {\n\t\treturn authTypePostPolicy\n\t} else if _, ok := r.Header[\"Authorization\"]; !ok {\n\t\treturn authTypeAnonymous\n\t}\n\treturn authTypeUnknown\n}\n\n// checkAdminRequestAuthType checks whether the request is a valid signature V2 or V4 request.\n// It does not accept presigned or JWT or anonymous requests.\nfunc checkAdminRequestAuthType(r *http.Request, region string) APIErrorCode {\n\ts3Err := ErrAccessDenied\n\tif getRequestAuthType(r) == authTypeSigned { // we only support V4 (no presign)\n\t\ts3Err = isReqAuthenticated(r, region)\n\t}\n\tif s3Err != ErrNone {\n\t\treqInfo := (&logger.ReqInfo{}).AppendTags(\"requestHeaders\", dumpRequest(r))\n\t\tctx := logger.SetReqInfo(context.Background(), reqInfo)\n\t\tlogger.LogIf(ctx, errors.New(getAPIError(s3Err).Description))\n\t}\n\treturn s3Err\n}\n\nfunc checkRequestAuthType(ctx context.Context, r *http.Request, action policy.Action, bucketName, objectName string) APIErrorCode {\n\tisOwner := true\n\taccountName := globalServerConfig.GetCredential().AccessKey\n\n\tswitch getRequestAuthType(r) {\n\tcase authTypeUnknown:\n\t\treturn ErrAccessDenied\n\tcase authTypePresignedV2, authTypeSignedV2:\n\t\tif errorCode := isReqAuthenticatedV2(r); errorCode != ErrNone {\n\t\t\treturn errorCode\n\t\t}\n\tcase authTypeSigned, authTypePresigned:\n\t\tregion := globalServerConfig.GetRegion()\n\t\tswitch action {\n\t\tcase policy.GetBucketLocationAction, policy.ListAllMyBucketsAction:\n\t\t\tregion = \"\"\n\t\t}\n\n\t\tif errorCode := isReqAuthenticated(r, region); errorCode != ErrNone {\n\t\t\treturn errorCode\n\t\t}\n\tdefault:\n\t\tisOwner = false\n\t\taccountName = \"\"\n\t}\n\n\t// LocationConstraint is valid only for CreateBucketAction.\n\tvar locationConstraint string\n\tif action == policy.CreateBucketAction {\n\t\t// To extract region from XML in request body, get copy of request body.\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, maxLocationConstraintSize))\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn ErrMalformedXML\n\t\t}\n\n\t\t// Populate payload to extract location constraint.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\n\t\tvar s3Error APIErrorCode\n\t\tlocationConstraint, s3Error = parseLocationConstraint(r)\n\t\tif s3Error != ErrNone {\n\t\t\treturn s3Error\n\t\t}\n\n\t\t// Populate payload again to handle it in HTTP handler.\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t}\n\n\tif globalPolicySys.IsAllowed(policy.Args{\n\t\tAccountName:     accountName,\n\t\tAction:          action,\n\t\tBucketName:      bucketName,\n\t\tConditionValues: getConditionValues(r, locationConstraint),\n\t\tIsOwner:         isOwner,\n\t\tObjectName:      objectName,\n\t}) {\n\t\treturn ErrNone\n\t}\n\n\treturn ErrAccessDenied\n}\n\n// Verify if request has valid AWS Signature Version '2'.\nfunc isReqAuthenticatedV2(r *http.Request) (s3Error APIErrorCode) {\n\tif isRequestSignatureV2(r) {\n\t\treturn doesSignV2Match(r)\n\t}\n\treturn doesPresignV2SignatureMatch(r)\n}\n\nfunc reqSignatureV4Verify(r *http.Request, region string) (s3Error APIErrorCode) {\n\tsha256sum := getContentSha256Cksum(r)\n\tswitch {\n\tcase isRequestSignatureV4(r):\n\t\treturn doesSignatureMatch(sha256sum, r, region)\n\tcase isRequestPresignedSignatureV4(r):\n\t\treturn doesPresignedSignatureMatch(sha256sum, r, region)\n\tdefault:\n\t\treturn ErrAccessDenied\n\t}\n}\n\n// Verify if request has valid AWS Signature Version '4'.\nfunc isReqAuthenticated(r *http.Request, region string) (s3Error APIErrorCode) {\n\tif errCode := reqSignatureV4Verify(r, region); errCode != ErrNone {\n\t\treturn errCode\n\t}\n\n\tvar (\n\t\terr                       error\n\t\tcontentMD5, contentSHA256 []byte\n\t)\n\t// Extract 'Content-Md5' if present.\n\tif _, ok := r.Header[\"Content-Md5\"]; ok {\n\t\tcontentMD5, err = base64.StdEncoding.Strict().DecodeString(r.Header.Get(\"Content-Md5\"))\n\t\tif err != nil || len(contentMD5) == 0 {\n\t\t\treturn ErrInvalidDigest\n\t\t}\n\t}\n\n\t// Extract either 'X-Amz-Content-Sha256' header or 'X-Amz-Content-Sha256' query parameter (if V4 presigned)\n\t// Do not verify 'X-Amz-Content-Sha256' if skipSHA256.\n\tif skipSHA256 := skipContentSha256Cksum(r); !skipSHA256 && isRequestPresignedSignatureV4(r) {\n\t\tif sha256Sum, ok := r.URL.Query()[\"X-Amz-Content-Sha256\"]; ok && len(sha256Sum) > 0 {\n\t\t\tcontentSHA256, err = hex.DecodeString(sha256Sum[0])\n\t\t\tif err != nil {\n\t\t\t\treturn ErrContentSHA256Mismatch\n\t\t\t}\n\t\t}\n\t} else if _, ok := r.Header[\"X-Amz-Content-Sha256\"]; !skipSHA256 && ok {\n\t\tcontentSHA256, err = hex.DecodeString(r.Header.Get(\"X-Amz-Content-Sha256\"))\n\t\tif err != nil || len(contentSHA256) == 0 {\n\t\t\treturn ErrContentSHA256Mismatch\n\t\t}\n\t}\n\n\t// Verify 'Content-Md5' and/or 'X-Amz-Content-Sha256' if present.\n\t// The verification happens implicit during reading.\n\treader, err := hash.NewReader(r.Body, -1, hex.EncodeToString(contentMD5), hex.EncodeToString(contentSHA256))\n\tif err != nil {\n\t\treturn toAPIErrorCode(err)\n\t}\n\tr.Body = ioutil.NopCloser(reader)\n\treturn ErrNone\n}\n\n// authHandler - handles all the incoming authorization headers and validates them if possible.\ntype authHandler struct {\n\thandler http.Handler\n}\n\n// setAuthHandler to validate authorization header for the incoming request.\nfunc setAuthHandler(h http.Handler) http.Handler {\n\treturn authHandler{h}\n}\n\n// List of all support S3 auth types.\nvar supportedS3AuthTypes = map[authType]struct{}{\n\tauthTypeAnonymous:       {},\n\tauthTypePresigned:       {},\n\tauthTypePresignedV2:     {},\n\tauthTypeSigned:          {},\n\tauthTypeSignedV2:        {},\n\tauthTypePostPolicy:      {},\n\tauthTypeStreamingSigned: {},\n}\n\n// Validate if the authType is valid and supported.\nfunc isSupportedS3AuthType(aType authType) bool {\n\t_, ok := supportedS3AuthTypes[aType]\n\treturn ok\n}\n\n// handler for validating incoming authorization headers.\nfunc (a authHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\taType := getRequestAuthType(r)\n\tif isSupportedS3AuthType(aType) {\n\t\t// Let top level caller validate for anonymous and known signed requests.\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t} else if aType == authTypeJWT {\n\t\t// Validate Authorization header if its valid for JWT request.\n\t\tif !isHTTPRequestValid(r) {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\ta.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\twriteErrorResponse(w, ErrSignatureVersionNotSupported, r.URL)\n}\n", "/*\n * Minio Cloud Storage, (C) 2016, 2017 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/minio/pkg/auth\"\n)\n\n// Test get request auth type.\nfunc TestGetRequestAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\treq   *http.Request\n\t\tauthT authType\n\t}\n\ttestCases := []testCase{\n\t\t// Test case - 1\n\t\t// Check for generic signature v4 header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\":        []string{\"AWS4-HMAC-SHA256 <cred_string>\"},\n\t\t\t\t\t\"X-Amz-Content-Sha256\": []string{streamingContentSHA256},\n\t\t\t\t\t\"Content-Encoding\":     []string{streamingContentEncoding},\n\t\t\t\t},\n\t\t\t\tMethod: \"PUT\",\n\t\t\t},\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t},\n\t\t// Test case - 2\n\t\t// Check for JWT header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"Bearer 12313123\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeJWT,\n\t\t},\n\t\t// Test case - 3\n\t\t// Empty authorization header.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Authorization\": []string{\"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypeUnknown,\n\t\t},\n\t\t// Test case - 4\n\t\t// Check for presigned.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:     \"127.0.0.1:9000\",\n\t\t\t\t\tScheme:   httpScheme,\n\t\t\t\t\tPath:     \"/\",\n\t\t\t\t\tRawQuery: \"X-Amz-Credential=EXAMPLEINVALIDEXAMPL%2Fs3%2F20160314%2Fus-east-1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthT: authTypePresigned,\n\t\t},\n\t\t// Test case - 5\n\t\t// Check for post policy.\n\t\t{\n\t\t\treq: &http.Request{\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tHost:   \"127.0.0.1:9000\",\n\t\t\t\t\tScheme: httpScheme,\n\t\t\t\t\tPath:   \"/\",\n\t\t\t\t},\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\"Content-Type\": []string{\"multipart/form-data\"},\n\t\t\t\t},\n\t\t\t\tMethod: \"POST\",\n\t\t\t},\n\t\t\tauthT: authTypePostPolicy,\n\t\t},\n\t}\n\n\t// .. Tests all request auth type.\n\tfor i, testc := range testCases {\n\t\tauthT := getRequestAuthType(testc.req)\n\t\tif authT != testc.authT {\n\t\t\tt.Errorf(\"Test %d: Expected %d, got %d\", i+1, testc.authT, authT)\n\t\t}\n\t}\n}\n\n// Test all s3 supported auth types.\nfunc TestS3SupportedAuthType(t *testing.T) {\n\ttype testCase struct {\n\t\tauthT authType\n\t\tpass  bool\n\t}\n\t// List of all valid and invalid test cases.\n\ttestCases := []testCase{\n\t\t// Test 1 - supported s3 type anonymous.\n\t\t{\n\t\t\tauthT: authTypeAnonymous,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 2 - supported s3 type presigned.\n\t\t{\n\t\t\tauthT: authTypePresigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 3 - supported s3 type signed.\n\t\t{\n\t\t\tauthT: authTypeSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 4 - supported s3 type with post policy.\n\t\t{\n\t\t\tauthT: authTypePostPolicy,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 5 - supported s3 type with streaming signed.\n\t\t{\n\t\t\tauthT: authTypeStreamingSigned,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 6 - supported s3 type with signature v2.\n\t\t{\n\t\t\tauthT: authTypeSignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 7 - supported s3 type with presign v2.\n\t\t{\n\t\t\tauthT: authTypePresignedV2,\n\t\t\tpass:  true,\n\t\t},\n\t\t// Test 8 - JWT is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeJWT,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 9 - unknown auth header is not supported s3 type.\n\t\t{\n\t\t\tauthT: authTypeUnknown,\n\t\t\tpass:  false,\n\t\t},\n\t\t// Test 10 - some new auth type is not supported s3 type.\n\t\t{\n\t\t\tauthT: authType(9),\n\t\t\tpass:  false,\n\t\t},\n\t}\n\t// Validate all the test cases.\n\tfor i, tt := range testCases {\n\t\tok := isSupportedS3AuthType(tt.authT)\n\t\tif ok != tt.pass {\n\t\t\tt.Errorf(\"Test %d:, Expected %t, got %t\", i+1, tt.pass, ok)\n\t\t}\n\t}\n}\n\nfunc TestIsRequestPresignedSignatureV2(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"AWSAccessKeyId\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"AWSAccessKeyId\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV2(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsRequestPresignedSignatureV4 - Test validates the logic for presign signature verision v4 detection.\nfunc TestIsRequestPresignedSignatureV4(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\t\texpectedResult  bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with query key \"\"X-Amz-Credential\" set.\n\t\t{\"\", \"\", false},\n\t\t// Test case - 2.\n\t\t{\"X-Amz-Credential\", \"\", true},\n\t\t// Test case - 3.\n\t\t{\"X-Amz-Content-Sha256\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the query parameters are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tq := inputReq.URL.Query()\n\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\tinputReq.URL.RawQuery = q.Encode()\n\n\t\tactualResult := isRequestPresignedSignatureV4(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// Provides a fully populated http request instance, fails otherwise.\nfunc mustNewRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq, err := newTestRequest(method, urlStr, contentLength, body)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to initialize new http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V4, fails if not able to do so.\nfunc mustNewSignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is signed with AWS Signature V2, fails if not able to do so.\nfunc mustNewSignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV2(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V2, fails if not able to do so.\nfunc mustNewPresignedV2Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := preSignV2(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// This is similar to mustNewRequest but additionally the request\n// is presigned with AWS Signature V4, fails if not able to do so.\nfunc mustNewPresignedRequest(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\tcred := globalServerConfig.GetCredential()\n\tif err := preSignV4(req, cred.AccessKey, cred.SecretKey, time.Now().Add(10*time.Minute).Unix()); err != nil {\n\t\tt.Fatalf(\"Unable to inititalized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedShortMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"invalid-digest\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedEmptyMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\nfunc mustNewSignedBadMD5Request(method string, urlStr string, contentLength int64, body io.ReadSeeker, t *testing.T) *http.Request {\n\treq := mustNewRequest(method, urlStr, contentLength, body, t)\n\treq.Header.Set(\"Content-Md5\", \"YWFhYWFhYWFhYWFhYWFhCg==\")\n\tcred := globalServerConfig.GetCredential()\n\tif err := signRequestV4(req, cred.AccessKey, cred.SecretKey); err != nil {\n\t\tt.Fatalf(\"Unable to initialized new signed http request %s\", err)\n\t}\n\treturn req\n}\n\n// Tests is requested authenticated function, tests replies for s3 errors.\nfunc TestIsReqAuthenticated(t *testing.T) {\n\tpath, err := newTestConfig(globalMinioDefaultRegion)\n\tif err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\tdefer os.RemoveAll(path)\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalServerConfig.SetCredential(creds)\n\n\t// List of test cases for validating http request authentication.\n\ttestCases := []struct {\n\t\treq     *http.Request\n\t\ts3Error APIErrorCode\n\t}{\n\t\t// When request is unsigned, access denied is returned.\n\t\t{mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrAccessDenied},\n\t\t// Empty Content-Md5 header.\n\t\t{mustNewSignedEmptyMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// Short Content-Md5 header.\n\t\t{mustNewSignedShortMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrInvalidDigest},\n\t\t// When request is properly signed, but has bad Content-MD5 header.\n\t\t{mustNewSignedBadMD5Request(\"PUT\", \"http://127.0.0.1:9000/\", 5, bytes.NewReader([]byte(\"hello\")), t), ErrBadDigest},\n\t\t// When request is properly signed, error is none.\n\t\t{mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrNone},\n\t}\n\n\t// Validates all testcases.\n\tfor i, testCase := range testCases {\n\t\tif s3Error := isReqAuthenticated(testCase.req, globalServerConfig.GetRegion()); s3Error != testCase.s3Error {\n\t\t\tif _, err := ioutil.ReadAll(testCase.req.Body); toAPIErrorCode(err) != testCase.s3Error {\n\t\t\t\tt.Fatalf(\"Test %d: Unexpected S3 error: want %d - got %d (got after reading request %d)\", i, testCase.s3Error, s3Error, toAPIErrorCode(err))\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestCheckAdminRequestAuthType(t *testing.T) {\n\tpath, err := newTestConfig(globalMinioDefaultRegion)\n\tif err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\tdefer os.RemoveAll(path)\n\n\tcreds, err := auth.CreateCredentials(\"myuser\", \"mypassword\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalServerConfig.SetCredential(creds)\n\ttestCases := []struct {\n\t\tRequest *http.Request\n\t\tErrCode APIErrorCode\n\t}{\n\t\t{Request: mustNewRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewSignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrNone},\n\t\t{Request: mustNewSignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedV2Request(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t\t{Request: mustNewPresignedRequest(\"GET\", \"http://127.0.0.1:9000\", 0, nil, t), ErrCode: ErrAccessDenied},\n\t}\n\tfor i, testCase := range testCases {\n\t\tif s3Error := checkAdminRequestAuthType(testCase.Request, globalServerConfig.GetRegion()); s3Error != testCase.ErrCode {\n\t\t\tt.Errorf(\"Test %d: Unexpected s3error returned wanted %d, got %d\", i, testCase.ErrCode, s3Error)\n\t\t}\n\t}\n}\n", "/*\n * Minio Cloud Storage, (C) 2017 Minio, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage hash\n\nimport (\n\t\"bytes\"\n\t\"crypto/md5\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"hash\"\n\t\"io\"\n\n\tsha256 \"github.com/minio/sha256-simd\"\n)\n\nvar errNestedReader = errors.New(\"Nesting of Reader detected, not allowed\")\n\n// Reader writes what it reads from an io.Reader to an MD5 and SHA256 hash.Hash.\n// Reader verifies that the content of the io.Reader matches the expected checksums.\ntype Reader struct {\n\tsrc  io.Reader\n\tsize int64\n\n\tmd5sum, sha256sum   []byte // Byte values of md5sum, sha256sum of client sent values.\n\tmd5Hash, sha256Hash hash.Hash\n}\n\n// NewReader returns a new hash Reader which computes the MD5 sum and\n// SHA256 sum (if set) of the provided io.Reader at EOF.\nfunc NewReader(src io.Reader, size int64, md5Hex, sha256Hex string) (*Reader, error) {\n\tif _, ok := src.(*Reader); ok {\n\t\treturn nil, errNestedReader\n\t}\n\n\tsha256sum, err := hex.DecodeString(sha256Hex)\n\tif err != nil {\n\t\treturn nil, SHA256Mismatch{}\n\t}\n\n\tmd5sum, err := hex.DecodeString(md5Hex)\n\tif err != nil {\n\t\treturn nil, BadDigest{}\n\t}\n\n\tvar sha256Hash hash.Hash\n\tif len(sha256sum) != 0 {\n\t\tsha256Hash = sha256.New()\n\t}\n\tif size >= 0 {\n\t\tsrc = io.LimitReader(src, size)\n\t}\n\treturn &Reader{\n\t\tmd5sum:     md5sum,\n\t\tsha256sum:  sha256sum,\n\t\tsrc:        src,\n\t\tsize:       size,\n\t\tmd5Hash:    md5.New(),\n\t\tsha256Hash: sha256Hash,\n\t}, nil\n}\n\nfunc (r *Reader) Read(p []byte) (n int, err error) {\n\tn, err = r.src.Read(p)\n\tif n > 0 {\n\t\tr.md5Hash.Write(p[:n])\n\t\tif r.sha256Hash != nil {\n\t\t\tr.sha256Hash.Write(p[:n])\n\t\t}\n\t}\n\n\t// At io.EOF verify if the checksums are right.\n\tif err == io.EOF {\n\t\tif cerr := r.Verify(); cerr != nil {\n\t\t\treturn 0, cerr\n\t\t}\n\t}\n\n\treturn\n}\n\n// Size returns the absolute number of bytes the Reader\n// will return during reading. It returns -1 for unlimited\n// data.\nfunc (r *Reader) Size() int64 { return r.size }\n\n// MD5 - returns byte md5 value\nfunc (r *Reader) MD5() []byte {\n\treturn r.md5sum\n}\n\n// MD5Current - returns byte md5 value of the current state\n// of the md5 hash after reading the incoming content.\n// NOTE: Calling this function multiple times might yield\n// different results if they are intermixed with Reader.\nfunc (r *Reader) MD5Current() []byte {\n\treturn r.md5Hash.Sum(nil)\n}\n\n// SHA256 - returns byte sha256 value\nfunc (r *Reader) SHA256() []byte {\n\treturn r.sha256sum\n}\n\n// MD5HexString returns hex md5 value.\nfunc (r *Reader) MD5HexString() string {\n\treturn hex.EncodeToString(r.md5sum)\n}\n\n// MD5Base64String returns base64 encoded MD5sum value.\nfunc (r *Reader) MD5Base64String() string {\n\treturn base64.StdEncoding.EncodeToString(r.md5sum)\n}\n\n// SHA256HexString returns hex sha256 value.\nfunc (r *Reader) SHA256HexString() string {\n\treturn hex.EncodeToString(r.sha256sum)\n}\n\n// Verify verifies if the computed MD5 sum and SHA256 sum are\n// equal to the ones specified when creating the Reader.\nfunc (r *Reader) Verify() error {\n\tif r.sha256Hash != nil && len(r.sha256sum) > 0 {\n\t\tif sum := r.sha256Hash.Sum(nil); !bytes.Equal(r.sha256sum, sum) {\n\t\t\treturn SHA256Mismatch{hex.EncodeToString(r.sha256sum), hex.EncodeToString(sum)}\n\t\t}\n\t}\n\tif len(r.md5sum) > 0 {\n\t\tif sum := r.md5Hash.Sum(nil); !bytes.Equal(r.md5sum, sum) {\n\t\t\treturn BadDigest{hex.EncodeToString(r.md5sum), hex.EncodeToString(sum)}\n\t\t}\n\t}\n\treturn nil\n}\n"], "filenames": ["cmd/auth-handler.go", "cmd/auth-handler_test.go", "pkg/hash/reader.go"], "buggy_code_start_loc": [30, 21, 64], "buggy_code_end_loc": [265, 382, 69], "fixing_code_start_loc": [31, 22, 64], "fixing_code_end_loc": [252, 383, 71], "type": "CWE-774", "message": "Minio Inc. Minio S3 server version prior to RELEASE.2018-05-16T23-35-33Z contains a Allocation of Memory Without Limits or Throttling (similar to CWE-774) vulnerability in write-to-RAM that can result in Denial of Service. This attack appear to be exploitable via Sending V4-(pre)signed requests with large bodies . This vulnerability appears to have been fixed in after commit 9c8b7306f55f2c8c0a5c7cea9a8db9d34be8faa7.", "other": {"cve": {"id": "CVE-2018-1000538", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-26T16:29:02.133", "lastModified": "2018-08-23T16:38:01.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio Inc. Minio S3 server version prior to RELEASE.2018-05-16T23-35-33Z contains a Allocation of Memory Without Limits or Throttling (similar to CWE-774) vulnerability in write-to-RAM that can result in Denial of Service. This attack appear to be exploitable via Sending V4-(pre)signed requests with large bodies . This vulnerability appears to have been fixed in after commit 9c8b7306f55f2c8c0a5c7cea9a8db9d34be8faa7."}, {"lang": "es", "value": "El servidor Minio S3, de Minio Inc., en versiones anteriores al RELEASE.2018-05-16T23-35-33Z contiene una vulnerabilidad de memoria sin l\u00edmites o \"throttling\" (similar al CWE-774) en write-to-RAM que puede resultar en una denegaci\u00f3n de servicio (DoS). El ataque parece ser explotable mediante el env\u00edo de peticiones prefirmadas con V4 con cuerpos largos. La vulnerabilidad parece haber sido solucionada tras el commit con ID 9c8b7306f55f2c8c0a5c7cea9a8db9d34be8faa7."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-774"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-05-16t23-35-33z", "matchCriteriaId": "5215DB3C-DC61-4ECE-84CC-A74AA2975671"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/9c8b7306f55f2c8c0a5c7cea9a8db9d34be8faa7#diff-e8c3bc9bc83b5516d0cc806cd461d08bL220", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/5957", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/9c8b7306f55f2c8c0a5c7cea9a8db9d34be8faa7#diff-e8c3bc9bc83b5516d0cc806cd461d08bL220"}}