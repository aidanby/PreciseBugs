{"buggy_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#include <curl/curl.h>\n\n#include \"urldata.h\"\n#include \"transfer.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"easyif.h\"\n#include \"share.h\"\n#include \"psl.h\"\n#include \"multiif.h\"\n#include \"sendf.h\"\n#include \"timeval.h\"\n#include \"http.h\"\n#include \"select.h\"\n#include \"warnless.h\"\n#include \"speedcheck.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"sigpipe.h\"\n#include \"vtls/vtls.h\"\n#include \"connect.h\"\n#include \"http_proxy.h\"\n#include \"http2.h\"\n#include \"socketpair.h\"\n#include \"socks.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n  CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97\n  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every\n  CURL handle takes 45-50 K memory, therefore this 3K are not significant.\n*/\n#ifndef CURL_SOCKET_HASH_TABLE_SIZE\n#define CURL_SOCKET_HASH_TABLE_SIZE 911\n#endif\n\n#ifndef CURL_CONNECTION_HASH_SIZE\n#define CURL_CONNECTION_HASH_SIZE 97\n#endif\n\n#define CURL_MULTI_HANDLE 0x000bab1e\n\n#define GOOD_MULTI_HANDLE(x) \\\n  ((x) && (x)->magic == CURL_MULTI_HANDLE)\n\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data);\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d);\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms);\nstatic void process_pending_handles(struct Curl_multi *multi);\n\n#ifdef DEBUGBUILD\nstatic const char * const statename[]={\n  \"INIT\",\n  \"PENDING\",\n  \"CONNECT\",\n  \"RESOLVING\",\n  \"CONNECTING\",\n  \"TUNNELING\",\n  \"PROTOCONNECT\",\n  \"PROTOCONNECTING\",\n  \"DO\",\n  \"DOING\",\n  \"DOING_MORE\",\n  \"DID\",\n  \"PERFORMING\",\n  \"RATELIMITING\",\n  \"DONE\",\n  \"COMPLETED\",\n  \"MSGSENT\",\n};\n#endif\n\n/* function pointer called once when switching TO a state */\ntypedef void (*init_multistate_func)(struct Curl_easy *data);\n\n/* called in DID state, before PERFORMING state */\nstatic void before_perform(struct Curl_easy *data)\n{\n  data->req.chunk = FALSE;\n  Curl_pgrsTime(data, TIMER_PRETRANSFER);\n}\n\nstatic void init_completed(struct Curl_easy *data)\n{\n  /* this is a completed transfer */\n\n  /* Important: reset the conn pointer so that we don't point to memory\n     that could be freed anytime */\n  Curl_detach_connnection(data);\n  Curl_expire_clear(data); /* stop all timers */\n}\n\n/* always use this function to change state, to make debugging easier */\nstatic void mstate(struct Curl_easy *data, CURLMstate state\n#ifdef DEBUGBUILD\n                   , int lineno\n#endif\n)\n{\n  CURLMstate oldstate = data->mstate;\n  static const init_multistate_func finit[MSTATE_LAST] = {\n    NULL,              /* INIT */\n    NULL,              /* PENDING */\n    Curl_init_CONNECT, /* CONNECT */\n    NULL,              /* RESOLVING */\n    NULL,              /* CONNECTING */\n    NULL,              /* TUNNELING */\n    NULL,              /* PROTOCONNECT */\n    NULL,              /* PROTOCONNECTING */\n    Curl_connect_free, /* DO */\n    NULL,              /* DOING */\n    NULL,              /* DOING_MORE */\n    before_perform,    /* DID */\n    NULL,              /* PERFORMING */\n    NULL,              /* RATELIMITING */\n    NULL,              /* DONE */\n    init_completed,    /* COMPLETED */\n    NULL               /* MSGSENT */\n  };\n\n#if defined(DEBUGBUILD) && defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) lineno;\n#endif\n\n  if(oldstate == state)\n    /* don't bother when the new state is the same as the old state */\n    return;\n\n  data->mstate = state;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  if(data->mstate >= MSTATE_PENDING &&\n     data->mstate < MSTATE_COMPLETED) {\n    long connection_id = -5000;\n\n    if(data->conn)\n      connection_id = data->conn->connection_id;\n\n    infof(data,\n          \"STATE: %s => %s handle %p; line %d (connection #%ld)\\n\",\n          statename[oldstate], statename[data->mstate],\n          (void *)data, lineno, connection_id);\n  }\n#endif\n\n  if(state == MSTATE_COMPLETED) {\n    /* changing to COMPLETED means there's one less easy handle 'alive' */\n    DEBUGASSERT(data->multi->num_alive > 0);\n    data->multi->num_alive--;\n  }\n\n  /* if this state has an init-function, run it */\n  if(finit[state])\n    finit[state](data);\n}\n\n#ifndef DEBUGBUILD\n#define multistate(x,y) mstate(x,y)\n#else\n#define multistate(x,y) mstate(x,y, __LINE__)\n#endif\n\n/*\n * We add one of these structs to the sockhash for each socket\n */\n\nstruct Curl_sh_entry {\n  struct Curl_hash transfers; /* hash of transfers using this socket */\n  unsigned int action;  /* what combined action READ/WRITE this socket waits\n                           for */\n  unsigned int users; /* number of transfers using this */\n  void *socketp; /* settable by users with curl_multi_assign() */\n  unsigned int readers; /* this many transfers want to read */\n  unsigned int writers; /* this many transfers want to write */\n};\n/* bits for 'action' having no bits means this socket is not expecting any\n   action */\n#define SH_READ  1\n#define SH_WRITE 2\n\n/* look up a given socket in the socket hash, skip invalid sockets */\nstatic struct Curl_sh_entry *sh_getentry(struct Curl_hash *sh,\n                                         curl_socket_t s)\n{\n  if(s != CURL_SOCKET_BAD) {\n    /* only look for proper sockets */\n    return Curl_hash_pick(sh, (char *)&s, sizeof(curl_socket_t));\n  }\n  return NULL;\n}\n\n#define TRHASH_SIZE 13\nstatic size_t trhash(void *key, size_t key_length, size_t slots_num)\n{\n  size_t keyval = (size_t)*(struct Curl_easy **)key;\n  (void) key_length;\n\n  return (keyval % slots_num);\n}\n\nstatic size_t trhash_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void)k1_len;\n  (void)k2_len;\n\n  return *(struct Curl_easy **)k1 == *(struct Curl_easy **)k2;\n}\n\nstatic void trhash_dtor(void *nada)\n{\n  (void)nada;\n}\n\n\n/* make sure this socket is present in the hash for this handle */\nstatic struct Curl_sh_entry *sh_addentry(struct Curl_hash *sh,\n                                         curl_socket_t s)\n{\n  struct Curl_sh_entry *there = sh_getentry(sh, s);\n  struct Curl_sh_entry *check;\n\n  if(there) {\n    /* it is present, return fine */\n    return there;\n  }\n\n  /* not present, add it */\n  check = calloc(1, sizeof(struct Curl_sh_entry));\n  if(!check)\n    return NULL; /* major failure */\n\n  if(Curl_hash_init(&check->transfers, TRHASH_SIZE, trhash,\n                    trhash_compare, trhash_dtor)) {\n    free(check);\n    return NULL;\n  }\n\n  /* make/add new hash entry */\n  if(!Curl_hash_add(sh, (char *)&s, sizeof(curl_socket_t), check)) {\n    Curl_hash_destroy(&check->transfers);\n    free(check);\n    return NULL; /* major failure */\n  }\n\n  return check; /* things are good in sockhash land */\n}\n\n\n/* delete the given socket + handle from the hash */\nstatic void sh_delentry(struct Curl_sh_entry *entry,\n                        struct Curl_hash *sh, curl_socket_t s)\n{\n  Curl_hash_destroy(&entry->transfers);\n\n  /* We remove the hash entry. This will end up in a call to\n     sh_freeentry(). */\n  Curl_hash_delete(sh, (char *)&s, sizeof(curl_socket_t));\n}\n\n/*\n * free a sockhash entry\n */\nstatic void sh_freeentry(void *freethis)\n{\n  struct Curl_sh_entry *p = (struct Curl_sh_entry *) freethis;\n\n  free(p);\n}\n\nstatic size_t fd_key_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void) k1_len; (void) k2_len;\n\n  return (*((curl_socket_t *) k1)) == (*((curl_socket_t *) k2));\n}\n\nstatic size_t hash_fd(void *key, size_t key_length, size_t slots_num)\n{\n  curl_socket_t fd = *((curl_socket_t *) key);\n  (void) key_length;\n\n  return (fd % slots_num);\n}\n\n/*\n * sh_init() creates a new socket hash and returns the handle for it.\n *\n * Quote from README.multi_socket:\n *\n * \"Some tests at 7000 and 9000 connections showed that the socket hash lookup\n * is somewhat of a bottle neck. Its current implementation may be a bit too\n * limiting. It simply has a fixed-size array, and on each entry in the array\n * it has a linked list with entries. So the hash only checks which list to\n * scan through. The code I had used so for used a list with merely 7 slots\n * (as that is what the DNS hash uses) but with 7000 connections that would\n * make an average of 1000 nodes in each list to run through. I upped that to\n * 97 slots (I believe a prime is suitable) and noticed a significant speed\n * increase.  I need to reconsider the hash implementation or use a rather\n * large default value like this. At 9000 connections I was still below 10us\n * per call.\"\n *\n */\nstatic int sh_init(struct Curl_hash *hash, int hashsize)\n{\n  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,\n                        sh_freeentry);\n}\n\n/*\n * multi_addmsg()\n *\n * Called when a transfer is completed. Adds the given msg pointer to\n * the list kept in the multi handle.\n */\nstatic CURLMcode multi_addmsg(struct Curl_multi *multi,\n                              struct Curl_message *msg)\n{\n  Curl_llist_insert_next(&multi->msglist, multi->msglist.tail, msg,\n                         &msg->list);\n  return CURLM_OK;\n}\n\nstruct Curl_multi *Curl_multi_handle(int hashsize, /* socket hash */\n                                     int chashsize) /* connection hash */\n{\n  struct Curl_multi *multi = calloc(1, sizeof(struct Curl_multi));\n\n  if(!multi)\n    return NULL;\n\n  multi->magic = CURL_MULTI_HANDLE;\n\n  if(Curl_mk_dnscache(&multi->hostcache))\n    goto error;\n\n  if(sh_init(&multi->sockhash, hashsize))\n    goto error;\n\n  if(Curl_conncache_init(&multi->conn_cache, chashsize))\n    goto error;\n\n  Curl_llist_init(&multi->msglist, NULL);\n  Curl_llist_init(&multi->pending, NULL);\n\n  multi->multiplexing = TRUE;\n\n  /* -1 means it not set by user, use the default value */\n  multi->maxconnects = -1;\n  multi->max_concurrent_streams = 100;\n  multi->ipv6_works = Curl_ipv6works(NULL);\n\n#ifdef USE_WINSOCK\n  multi->wsa_event = WSACreateEvent();\n  if(multi->wsa_event == WSA_INVALID_EVENT)\n    goto error;\n#else\n#ifdef ENABLE_WAKEUP\n  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, multi->wakeup_pair) < 0) {\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||\n          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n#endif\n#endif\n\n  return multi;\n\n  error:\n\n  Curl_hash_destroy(&multi->sockhash);\n  Curl_hash_destroy(&multi->hostcache);\n  Curl_conncache_destroy(&multi->conn_cache);\n  Curl_llist_destroy(&multi->msglist, NULL);\n  Curl_llist_destroy(&multi->pending, NULL);\n\n  free(multi);\n  return NULL;\n}\n\nstruct Curl_multi *curl_multi_init(void)\n{\n  return Curl_multi_handle(CURL_SOCKET_HASH_TABLE_SIZE,\n                           CURL_CONNECTION_HASH_SIZE);\n}\n\nCURLMcode curl_multi_add_handle(struct Curl_multi *multi,\n                                struct Curl_easy *data)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from adding same easy handle more than once and prevent\n     adding to more than one multi stack */\n  if(data->multi)\n    return CURLM_ADDED_ALREADY;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  /* Initialize timeout list for this handle */\n  Curl_llist_init(&data->state.timeoutlist, NULL);\n\n  /*\n   * No failure allowed in this function beyond this point. And no\n   * modification of easy nor multi handle allowed before this except for\n   * potential multi's connection cache growing which won't be undone in this\n   * function no matter what.\n   */\n  if(data->set.errorbuffer)\n    data->set.errorbuffer[0] = 0;\n\n  /* set the easy handle */\n  multistate(data, MSTATE_INIT);\n\n  /* for multi interface connections, we share DNS cache automatically if the\n     easy handle's one is currently not set. */\n  if(!data->dns.hostcache ||\n     (data->dns.hostcachetype == HCACHE_NONE)) {\n    data->dns.hostcache = &multi->hostcache;\n    data->dns.hostcachetype = HCACHE_MULTI;\n  }\n\n  /* Point to the shared or multi handle connection cache */\n  if(data->share && (data->share->specifier & (1<< CURL_LOCK_DATA_CONNECT)))\n    data->state.conn_cache = &data->share->conn_cache;\n  else\n    data->state.conn_cache = &multi->conn_cache;\n  data->state.lastconnect_id = -1;\n\n#ifdef USE_LIBPSL\n  /* Do the same for PSL. */\n  if(data->share && (data->share->specifier & (1 << CURL_LOCK_DATA_PSL)))\n    data->psl = &data->share->psl;\n  else\n    data->psl = &multi->psl;\n#endif\n\n  /* We add the new entry last in the list. */\n  data->next = NULL; /* end of the line */\n  if(multi->easyp) {\n    struct Curl_easy *last = multi->easylp;\n    last->next = data;\n    data->prev = last;\n    multi->easylp = data; /* the new last node */\n  }\n  else {\n    /* first node, make prev NULL! */\n    data->prev = NULL;\n    multi->easylp = multi->easyp = data; /* both first and last */\n  }\n\n  /* make the Curl_easy refer back to this multi handle */\n  data->multi = multi;\n\n  /* Set the timeout for this handle to expire really soon so that it will\n     be taken care of even when this handle is added in the midst of operation\n     when only the curl_multi_socket() API is used. During that flow, only\n     sockets that time-out or have actions will be dealt with. Since this\n     handle has no action yet, we make sure it times out to get things to\n     happen. */\n  Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n  /* increase the node-counter */\n  multi->num_easy++;\n\n  /* increase the alive-counter */\n  multi->num_alive++;\n\n  /* A somewhat crude work-around for a little glitch in Curl_update_timer()\n     that happens if the lastcall time is set to the same time when the handle\n     is removed as when the next handle is added, as then the check in\n     Curl_update_timer() that prevents calling the application multiple times\n     with the same timer info will not trigger and then the new handle's\n     timeout will not be notified to the app.\n\n     The work-around is thus simply to clear the 'lastcall' variable to force\n     Curl_update_timer() to always trigger a callback to the app when a new\n     easy handle is added */\n  memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n\n  CONNCACHE_LOCK(data);\n  /* The closure handle only ever has default timeouts set. To improve the\n     state somewhat we clone the timeouts from each added handle so that the\n     closure handle always has the same timeouts as the most recently added\n     easy handle. */\n  data->state.conn_cache->closure_handle->set.timeout = data->set.timeout;\n  data->state.conn_cache->closure_handle->set.server_response_timeout =\n    data->set.server_response_timeout;\n  data->state.conn_cache->closure_handle->set.no_signal =\n    data->set.no_signal;\n  CONNCACHE_UNLOCK(data);\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n#if 0\n/* Debug-function, used like this:\n *\n * Curl_hash_print(multi->sockhash, debug_print_sock_hash);\n *\n * Enable the hash print function first by editing hash.c\n */\nstatic void debug_print_sock_hash(void *p)\n{\n  struct Curl_sh_entry *sh = (struct Curl_sh_entry *)p;\n\n  fprintf(stderr, \" [easy %p/magic %x/socket %d]\",\n          (void *)sh->data, sh->data->magic, (int)sh->socket);\n}\n#endif\n\nstatic CURLcode multi_done(struct Curl_easy *data,\n                           CURLcode status,  /* an error if this is called\n                                                after an error was detected */\n                           bool premature)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  unsigned int i;\n\n  DEBUGF(infof(data, \"multi_done\\n\"));\n\n  if(data->state.done)\n    /* Stop if multi_done() has already been called */\n    return CURLE_OK;\n\n  /* Stop the resolver and free its own resources (but not dns_entry yet). */\n  Curl_resolver_kill(data);\n\n  /* Cleanup possible redirect junk */\n  Curl_safefree(data->req.newurl);\n  Curl_safefree(data->req.location);\n\n  switch(status) {\n  case CURLE_ABORTED_BY_CALLBACK:\n  case CURLE_READ_ERROR:\n  case CURLE_WRITE_ERROR:\n    /* When we're aborted due to a callback return code it basically have to\n       be counted as premature as there is trouble ahead if we don't. We have\n       many callbacks and protocols work differently, we could potentially do\n       this more fine-grained in the future. */\n    premature = TRUE;\n  default:\n    break;\n  }\n\n  /* this calls the protocol-specific function pointer previously set */\n  if(conn->handler->done)\n    result = conn->handler->done(data, status, premature);\n  else\n    result = status;\n\n  if(CURLE_ABORTED_BY_CALLBACK != result) {\n    /* avoid this if we already aborted by callback to avoid this calling\n       another callback */\n    CURLcode rc = Curl_pgrsDone(data);\n    if(!result && rc)\n      result = CURLE_ABORTED_BY_CALLBACK;\n  }\n\n  process_pending_handles(data->multi); /* connection / multiplex */\n\n  CONNCACHE_LOCK(data);\n  Curl_detach_connnection(data);\n  if(CONN_INUSE(conn)) {\n    /* Stop if still used. */\n    CONNCACHE_UNLOCK(data);\n    DEBUGF(infof(data, \"Connection still in use %zu, \"\n                 \"no more multi_done now!\\n\",\n                 conn->easyq.size));\n    return CURLE_OK;\n  }\n\n  data->state.done = TRUE; /* called just now! */\n\n  if(conn->dns_entry) {\n    Curl_resolv_unlock(data, conn->dns_entry); /* done with this */\n    conn->dns_entry = NULL;\n  }\n  Curl_hostcache_prune(data);\n  Curl_safefree(data->state.ulbuf);\n\n  /* if the transfer was completed in a paused state there can be buffered\n     data left to free */\n  for(i = 0; i < data->state.tempcount; i++) {\n    Curl_dyn_free(&data->state.tempwrite[i].b);\n  }\n  data->state.tempcount = 0;\n\n  /* if data->set.reuse_forbid is TRUE, it means the libcurl client has\n     forced us to close this connection. This is ignored for requests taking\n     place in a NTLM/NEGOTIATE authentication handshake\n\n     if conn->bits.close is TRUE, it means that the connection should be\n     closed in spite of all our efforts to be nice, due to protocol\n     restrictions in our or the server's end\n\n     if premature is TRUE, it means this connection was said to be DONE before\n     the entire request operation is complete and thus we can't know in what\n     state it is for re-using, so we're forced to close it. In a perfect world\n     we can add code that keep track of if we really must close it here or not,\n     but currently we have no such detail knowledge.\n  */\n\n  if((data->set.reuse_forbid\n#if defined(USE_NTLM)\n      && !(conn->http_ntlm_state == NTLMSTATE_TYPE2 ||\n           conn->proxy_ntlm_state == NTLMSTATE_TYPE2)\n#endif\n#if defined(USE_SPNEGO)\n      && !(conn->http_negotiate_state == GSS_AUTHRECV ||\n           conn->proxy_negotiate_state == GSS_AUTHRECV)\n#endif\n     ) || conn->bits.close\n       || (premature && !(conn->handler->flags & PROTOPT_STREAM))) {\n    CURLcode res2;\n    connclose(conn, \"disconnecting\");\n    Curl_conncache_remove_conn(data, conn, FALSE);\n    CONNCACHE_UNLOCK(data);\n    res2 = Curl_disconnect(data, conn, premature);\n\n    /* If we had an error already, make sure we return that one. But\n       if we got a new error, return that. */\n    if(!result && res2)\n      result = res2;\n  }\n  else {\n    char buffer[256];\n    const char *host =\n#ifndef CURL_DISABLE_PROXY\n      conn->bits.socksproxy ?\n      conn->socks_proxy.host.dispname :\n      conn->bits.httpproxy ? conn->http_proxy.host.dispname :\n#endif\n      conn->bits.conn_to_host ? conn->conn_to_host.dispname :\n      conn->host.dispname;\n    /* create string before returning the connection */\n    msnprintf(buffer, sizeof(buffer),\n              \"Connection #%ld to host %s left intact\",\n              conn->connection_id, host);\n    /* the connection is no longer in use by this transfer */\n    CONNCACHE_UNLOCK(data);\n    if(Curl_conncache_return_conn(data, conn)) {\n      /* remember the most recently used connection */\n      data->state.lastconnect_id = conn->connection_id;\n      infof(data, \"%s\\n\", buffer);\n    }\n    else\n      data->state.lastconnect_id = -1;\n  }\n\n  Curl_safefree(data->state.buffer);\n  Curl_free_request_state(data);\n  return result;\n}\n\nstatic int close_connect_only(struct Curl_easy *data,\n                              struct connectdata *conn, void *param)\n{\n  (void)param;\n  if(data->state.lastconnect_id != conn->connection_id)\n    return 0;\n\n  if(!conn->bits.connect_only)\n    return 1;\n\n  connclose(conn, \"Removing connect-only easy handle\");\n  conn->bits.connect_only = FALSE;\n\n  return 1;\n}\n\nCURLMcode curl_multi_remove_handle(struct Curl_multi *multi,\n                                   struct Curl_easy *data)\n{\n  struct Curl_easy *easy = data;\n  bool premature;\n  struct Curl_llist_element *e;\n\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from trying to remove same easy handle more than once */\n  if(!data->multi)\n    return CURLM_OK; /* it is already removed so let's say it is fine! */\n\n  /* Prevent users from trying to remove an easy handle from the wrong multi */\n  if(data->multi != multi)\n    return CURLM_BAD_EASY_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  premature = (data->mstate < MSTATE_COMPLETED) ? TRUE : FALSE;\n\n  /* If the 'state' is not INIT or COMPLETED, we might need to do something\n     nice to put the easy_handle in a good known state when this returns. */\n  if(premature) {\n    /* this handle is \"alive\" so we need to count down the total number of\n       alive connections when this is removed */\n    multi->num_alive--;\n  }\n\n  if(data->conn &&\n     data->mstate > MSTATE_DO &&\n     data->mstate < MSTATE_COMPLETED) {\n    /* Set connection owner so that the DONE function closes it.  We can\n       safely do this here since connection is killed. */\n    streamclose(data->conn, \"Removed with partial response\");\n  }\n\n  if(data->conn) {\n    /* multi_done() clears the association between the easy handle and the\n       connection.\n\n       Note that this ignores the return code simply because there's\n       nothing really useful to do with it anyway! */\n    (void)multi_done(data, data->result, premature);\n  }\n\n  /* The timer must be shut down before data->multi is set to NULL, else the\n     timenode will remain in the splay tree after curl_easy_cleanup is\n     called. Do it after multi_done() in case that sets another time! */\n  Curl_expire_clear(data);\n\n  if(data->connect_queue.ptr)\n    /* the handle was in the pending list waiting for an available connection,\n       so go ahead and remove it */\n    Curl_llist_remove(&multi->pending, &data->connect_queue, NULL);\n\n  if(data->dns.hostcachetype == HCACHE_MULTI) {\n    /* stop using the multi handle's DNS cache, *after* the possible\n       multi_done() call above */\n    data->dns.hostcache = NULL;\n    data->dns.hostcachetype = HCACHE_NONE;\n  }\n\n  Curl_wildcard_dtor(&data->wildcard);\n\n  /* destroy the timeout list that is held in the easy handle, do this *after*\n     multi_done() as that may actually call Curl_expire that uses this */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  /* change state without using multistate(), only to make singlesocket() do\n     what we want */\n  data->mstate = MSTATE_COMPLETED;\n  singlesocket(multi, easy); /* to let the application know what sockets that\n                                vanish with this handle */\n\n  /* Remove the association between the connection and the handle */\n  Curl_detach_connnection(data);\n\n  if(data->state.lastconnect_id != -1) {\n    /* Mark any connect-only connection for closure */\n    Curl_conncache_foreach(data, data->state.conn_cache,\n                           NULL, close_connect_only);\n  }\n\n#ifdef USE_LIBPSL\n  /* Remove the PSL association. */\n  if(data->psl == &multi->psl)\n    data->psl = NULL;\n#endif\n\n  /* as this was using a shared connection cache we clear the pointer to that\n     since we're not part of that multi handle anymore */\n  data->state.conn_cache = NULL;\n\n  data->multi = NULL; /* clear the association to this multi handle */\n\n  /* make sure there's no pending message in the queue sent from this easy\n     handle */\n\n  for(e = multi->msglist.head; e; e = e->next) {\n    struct Curl_message *msg = e->ptr;\n\n    if(msg->extmsg.easy_handle == easy) {\n      Curl_llist_remove(&multi->msglist, e, NULL);\n      /* there can only be one from this specific handle */\n      break;\n    }\n  }\n\n  /* Remove from the pending list if it is there. Otherwise this will\n     remain on the pending list forever due to the state change. */\n  for(e = multi->pending.head; e; e = e->next) {\n    struct Curl_easy *curr_data = e->ptr;\n\n    if(curr_data == data) {\n      Curl_llist_remove(&multi->pending, e, NULL);\n      break;\n    }\n  }\n\n  /* make the previous node point to our next */\n  if(data->prev)\n    data->prev->next = data->next;\n  else\n    multi->easyp = data->next; /* point to first node */\n\n  /* make our next point to our previous node */\n  if(data->next)\n    data->next->prev = data->prev;\n  else\n    multi->easylp = data->prev; /* point to last node */\n\n  /* NOTE NOTE NOTE\n     We do not touch the easy handle here! */\n  multi->num_easy--; /* one less to care about now */\n\n  process_pending_handles(multi);\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n/* Return TRUE if the application asked for multiplexing */\nbool Curl_multiplex_wanted(const struct Curl_multi *multi)\n{\n  return (multi && (multi->multiplexing));\n}\n\n/*\n * Curl_detach_connnection() removes the given transfer from the connection.\n *\n * This is the only function that should clear data->conn. This will\n * occasionally be called with the data->conn pointer already cleared.\n */\nvoid Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}\n\n/*\n * Curl_attach_connnection() attaches this transfer to this connection.\n *\n * This is the only function that should assign data->conn\n */\nvoid Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n}\n\nstatic int waitconnect_getsock(struct connectdata *conn,\n                               curl_socket_t *sock)\n{\n  int i;\n  int s = 0;\n  int rc = 0;\n\n#ifdef USE_SSL\n#ifndef CURL_DISABLE_PROXY\n  if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n    return Curl_ssl->getsock(conn, sock);\n#endif\n#endif\n\n  if(SOCKS_STATE(conn->cnnct.state))\n    return Curl_SOCKS_getsock(conn, sock, FIRSTSOCKET);\n\n  for(i = 0; i<2; i++) {\n    if(conn->tempsock[i] != CURL_SOCKET_BAD) {\n      sock[s] = conn->tempsock[i];\n      rc |= GETSOCK_WRITESOCK(s);\n#ifdef ENABLE_QUIC\n      if(conn->transport == TRNSPRT_QUIC)\n        /* when connecting QUIC, we want to read the socket too */\n        rc |= GETSOCK_READSOCK(s);\n#endif\n      s++;\n    }\n  }\n\n  return rc;\n}\n\nstatic int waitproxyconnect_getsock(struct connectdata *conn,\n                                    curl_socket_t *sock)\n{\n  sock[0] = conn->sock[FIRSTSOCKET];\n\n  if(conn->connect_state)\n    return Curl_connect_getsock(conn);\n\n  return GETSOCK_WRITESOCK(0);\n}\n\nstatic int domore_getsock(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          curl_socket_t *socks)\n{\n  if(conn && conn->handler->domore_getsock)\n    return conn->handler->domore_getsock(data, conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int doing_getsock(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         curl_socket_t *socks)\n{\n  if(conn && conn->handler->doing_getsock)\n    return conn->handler->doing_getsock(data, conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int protocol_getsock(struct Curl_easy *data,\n                            struct connectdata *conn,\n                            curl_socket_t *socks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(data, conn, socks);\n  /* Backup getsock logic. Since there is a live socket in use, we must wait\n     for it or it will be removed from watching when the multi_socket API is\n     used. */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\n/* returns bitmapped flags for this handle and its sockets. The 'socks[]'\n   array contains MAX_SOCKSPEREASYHANDLE entries. */\nstatic int multi_getsock(struct Curl_easy *data,\n                         curl_socket_t *socks)\n{\n  struct connectdata *conn = data->conn;\n  /* The no connection case can happen when this is called from\n     curl_multi_remove_handle() => singlesocket() => multi_getsock().\n  */\n  if(!conn)\n    return 0;\n\n  switch(data->mstate) {\n  default:\n    return 0;\n\n  case MSTATE_RESOLVING:\n    return Curl_resolv_getsock(data, socks);\n\n  case MSTATE_PROTOCONNECTING:\n  case MSTATE_PROTOCONNECT:\n    return protocol_getsock(data, conn, socks);\n\n  case MSTATE_DO:\n  case MSTATE_DOING:\n    return doing_getsock(data, conn, socks);\n\n  case MSTATE_TUNNELING:\n    return waitproxyconnect_getsock(conn, socks);\n\n  case MSTATE_CONNECTING:\n    return waitconnect_getsock(conn, socks);\n\n  case MSTATE_DOING_MORE:\n    return domore_getsock(data, conn, socks);\n\n  case MSTATE_DID: /* since is set after DO is completed, we switch to\n                        waiting for the same as the PERFORMING state */\n  case MSTATE_PERFORMING:\n    return Curl_single_getsock(data, conn, socks);\n  }\n\n}\n\nCURLMcode curl_multi_fdset(struct Curl_multi *multi,\n                           fd_set *read_fd_set, fd_set *write_fd_set,\n                           fd_set *exc_fd_set, int *max_fd)\n{\n  /* Scan through all the easy handles to get the file descriptors set.\n     Some easy handles may not have connected to the remote host yet,\n     and then we must make sure that is done. */\n  struct Curl_easy *data;\n  int this_max_fd = -1;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  (void)exc_fd_set; /* not used */\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    int bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], read_fd_set);\n        s = sockbunch[i];\n      }\n      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], write_fd_set);\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD)\n        /* this socket is unused, break out of loop */\n        break;\n      if((int)s > this_max_fd)\n        this_max_fd = (int)s;\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  *max_fd = this_max_fd;\n\n  return CURLM_OK;\n}\n\n#define NUM_POLLS_ON_STACK 10\n\nstatic CURLMcode multi_wait(struct Curl_multi *multi,\n                            struct curl_waitfd extra_fds[],\n                            unsigned int extra_nfds,\n                            int timeout_ms,\n                            int *ret,\n                            bool extrawait, /* when no socket, wait */\n                            bool use_wakeup)\n{\n  struct Curl_easy *data;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int bitmap;\n  unsigned int i;\n  unsigned int nfds = 0;\n  unsigned int curlfds;\n  long timeout_internal;\n  int retcode = 0;\n  struct pollfd a_few_on_stack[NUM_POLLS_ON_STACK];\n  struct pollfd *ufds = &a_few_on_stack[0];\n  bool ufds_malloc = FALSE;\n#ifdef USE_WINSOCK\n  WSANETWORKEVENTS wsa_events;\n  DEBUGASSERT(multi->wsa_event != WSA_INVALID_EVENT);\n#endif\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  if(timeout_ms < 0)\n    return CURLM_BAD_FUNCTION_ARGUMENT;\n\n  /* Count up how many fds we have from the multi handle */\n  data = multi->easyp;\n  while(data) {\n    bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD) {\n        break;\n      }\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  /* If the internally desired timeout is actually shorter than requested from\n     the outside, then use the shorter time! But only if the internal timer\n     is actually larger than -1! */\n  (void)multi_timeout(multi, &timeout_internal);\n  if((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms))\n    timeout_ms = (int)timeout_internal;\n\n  curlfds = nfds; /* number of internal file descriptors */\n  nfds += extra_nfds; /* add the externally provided ones */\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(use_wakeup) {\n#else\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n#endif\n    ++nfds;\n  }\n#endif\n\n  if(nfds > NUM_POLLS_ON_STACK) {\n    /* 'nfds' is a 32 bit value and 'struct pollfd' is typically 8 bytes\n       big, so at 2^29 sockets this value might wrap. When a process gets\n       the capability to actually handle over 500 million sockets this\n       calculation needs a integer overflow check. */\n    ufds = malloc(nfds * sizeof(struct pollfd));\n    if(!ufds)\n      return CURLM_OUT_OF_MEMORY;\n    ufds_malloc = TRUE;\n  }\n  nfds = 0;\n\n  /* only do the second loop if we found descriptors in the first stage run\n     above */\n\n  if(curlfds) {\n    /* Add the curl handles to our pollfds first */\n    data = multi->easyp;\n    while(data) {\n      bitmap = multi_getsock(data, sockbunch);\n\n      for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n        curl_socket_t s = CURL_SOCKET_BAD;\n#ifdef USE_WINSOCK\n        long mask = 0;\n#endif\n        if(bitmap & GETSOCK_READSOCK(i)) {\n          s = sockbunch[i];\n#ifdef USE_WINSOCK\n          mask |= FD_READ|FD_ACCEPT|FD_CLOSE;\n#endif\n          ufds[nfds].fd = s;\n          ufds[nfds].events = POLLIN;\n          ++nfds;\n        }\n        if(bitmap & GETSOCK_WRITESOCK(i)) {\n          s = sockbunch[i];\n#ifdef USE_WINSOCK\n          mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;\n          send(s, NULL, 0, 0); /* reset FD_WRITE */\n#endif\n          ufds[nfds].fd = s;\n          ufds[nfds].events = POLLOUT;\n          ++nfds;\n        }\n        /* s is only set if either being readable or writable is checked */\n        if(s == CURL_SOCKET_BAD) {\n          /* break on entry not checked for being readable or writable */\n          break;\n        }\n#ifdef USE_WINSOCK\n        if(WSAEventSelect(s, multi->wsa_event, mask) != 0) {\n          if(ufds_malloc)\n            free(ufds);\n          return CURLM_INTERNAL_ERROR;\n        }\n#endif\n      }\n\n      data = data->next; /* check next handle */\n    }\n  }\n\n  /* Add external file descriptions from poll-like struct curl_waitfd */\n  for(i = 0; i < extra_nfds; i++) {\n#ifdef USE_WINSOCK\n    long mask = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN)\n      mask |= FD_READ|FD_ACCEPT|FD_CLOSE;\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI)\n      mask |= FD_OOB;\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT) {\n      mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;\n      send(extra_fds[i].fd, NULL, 0, 0); /* reset FD_WRITE */\n    }\n    if(WSAEventSelect(extra_fds[i].fd, multi->wsa_event, mask) != 0) {\n      if(ufds_malloc)\n        free(ufds);\n      return CURLM_INTERNAL_ERROR;\n    }\n#endif\n    ufds[nfds].fd = extra_fds[i].fd;\n    ufds[nfds].events = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN)\n      ufds[nfds].events |= POLLIN;\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI)\n      ufds[nfds].events |= POLLPRI;\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT)\n      ufds[nfds].events |= POLLOUT;\n    ++nfds;\n  }\n\n#ifdef ENABLE_WAKEUP\n#ifndef USE_WINSOCK\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n    ufds[nfds].fd = multi->wakeup_pair[0];\n    ufds[nfds].events = POLLIN;\n    ++nfds;\n  }\n#endif\n#endif\n\n#if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)\n  if(nfds || use_wakeup) {\n#else\n  if(nfds) {\n#endif\n    int pollrc;\n#ifdef USE_WINSOCK\n    if(nfds)\n      pollrc = Curl_poll(ufds, nfds, 0); /* just pre-check with WinSock */\n    else\n      pollrc = 0;\n    if(pollrc <= 0) /* now wait... if not ready during the pre-check above */\n      WSAWaitForMultipleEvents(1, &multi->wsa_event, FALSE, timeout_ms, FALSE);\n#else\n    pollrc = Curl_poll(ufds, nfds, timeout_ms); /* wait... */\n#endif\n\n    if(pollrc > 0) {\n      retcode = pollrc;\n#ifdef USE_WINSOCK\n    }\n    /* With WinSock, we have to run the following section unconditionally\n       to call WSAEventSelect(fd, event, 0) on all the sockets */\n    {\n#endif\n      /* copy revents results from the poll to the curl_multi_wait poll\n         struct, the bit values of the actual underlying poll() implementation\n         may not be the same as the ones in the public libcurl API! */\n      for(i = 0; i < extra_nfds; i++) {\n        unsigned r = ufds[curlfds + i].revents;\n        unsigned short mask = 0;\n#ifdef USE_WINSOCK\n        wsa_events.lNetworkEvents = 0;\n        if(WSAEnumNetworkEvents(extra_fds[i].fd, NULL, &wsa_events) == 0) {\n          if(wsa_events.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLIN;\n          if(wsa_events.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLOUT;\n          if(wsa_events.lNetworkEvents & FD_OOB)\n            mask |= CURL_WAIT_POLLPRI;\n          if(ret && pollrc <= 0 && wsa_events.lNetworkEvents)\n            retcode++;\n        }\n        WSAEventSelect(extra_fds[i].fd, multi->wsa_event, 0);\n        if(pollrc <= 0)\n          continue;\n#endif\n        if(r & POLLIN)\n          mask |= CURL_WAIT_POLLIN;\n        if(r & POLLOUT)\n          mask |= CURL_WAIT_POLLOUT;\n        if(r & POLLPRI)\n          mask |= CURL_WAIT_POLLPRI;\n        extra_fds[i].revents = mask;\n      }\n\n#ifdef USE_WINSOCK\n      /* Count up all our own sockets that had activity,\n         and remove them from the event. */\n      if(curlfds) {\n        data = multi->easyp;\n        while(data) {\n          bitmap = multi_getsock(data, sockbunch);\n\n          for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n            if(bitmap & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i))) {\n              wsa_events.lNetworkEvents = 0;\n              if(WSAEnumNetworkEvents(sockbunch[i], NULL, &wsa_events) == 0) {\n                if(ret && pollrc <= 0 && wsa_events.lNetworkEvents)\n                  retcode++;\n              }\n              WSAEventSelect(sockbunch[i], multi->wsa_event, 0);\n            }\n            else {\n              /* break on entry not checked for being readable or writable */\n              break;\n            }\n          }\n\n          data = data->next;\n        }\n      }\n\n      WSAResetEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n      if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n        if(ufds[curlfds + extra_nfds].revents & POLLIN) {\n          char buf[64];\n          ssize_t nread;\n          while(1) {\n            /* the reading socket is non-blocking, try to read\n               data from it until it receives an error (except EINTR).\n               In normal cases it will get EAGAIN or EWOULDBLOCK\n               when there is no more data, breaking the loop. */\n            nread = sread(multi->wakeup_pair[0], buf, sizeof(buf));\n            if(nread <= 0) {\n              if(nread < 0 && EINTR == SOCKERRNO)\n                continue;\n              break;\n            }\n          }\n          /* do not count the wakeup socket into the returned value */\n          retcode--;\n        }\n      }\n#endif\n#endif\n    }\n  }\n\n  if(ufds_malloc)\n    free(ufds);\n  if(ret)\n    *ret = retcode;\n#if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)\n  if(extrawait && !nfds && !use_wakeup) {\n#else\n  if(extrawait && !nfds) {\n#endif\n    long sleep_ms = 0;\n\n    /* Avoid busy-looping when there's nothing particular to wait for */\n    if(!curl_multi_timeout(multi, &sleep_ms) && sleep_ms) {\n      if(sleep_ms > timeout_ms)\n        sleep_ms = timeout_ms;\n      /* when there are no easy handles in the multi, this holds a -1\n         timeout */\n      else if(sleep_ms < 0)\n        sleep_ms = timeout_ms;\n      Curl_wait_ms(sleep_ms);\n    }\n  }\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_wait(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, FALSE,\n                    FALSE);\n}\n\nCURLMcode curl_multi_poll(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, TRUE,\n                    TRUE);\n}\n\nCURLMcode curl_multi_wakeup(struct Curl_multi *multi)\n{\n  /* this function is usually called from another thread,\n     it has to be careful only to access parts of the\n     Curl_multi struct that are constant */\n\n  /* GOOD_MULTI_HANDLE can be safely called */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(WSASetEvent(multi->wsa_event))\n    return CURLM_OK;\n#else\n  /* the wakeup_pair variable is only written during init and cleanup,\n     making it safe to access from another thread after the init part\n     and before cleanup */\n  if(multi->wakeup_pair[1] != CURL_SOCKET_BAD) {\n    char buf[1];\n    buf[0] = 1;\n    while(1) {\n      /* swrite() is not thread-safe in general, because concurrent calls\n         can have their messages interleaved, but in this case the content\n         of the messages does not matter, which makes it ok to call.\n\n         The write socket is set to non-blocking, this way this function\n         cannot block, making it safe to call even from the same thread\n         that will call curl_multi_wait(). If swrite() returns that it\n         would block, it's considered successful because it means that\n         previous calls to this function will wake up the poll(). */\n      if(swrite(multi->wakeup_pair[1], buf, sizeof(buf)) < 0) {\n        int err = SOCKERRNO;\n        int return_success;\n#ifdef USE_WINSOCK\n        return_success = WSAEWOULDBLOCK == err;\n#else\n        if(EINTR == err)\n          continue;\n        return_success = EWOULDBLOCK == err || EAGAIN == err;\n#endif\n        if(!return_success)\n          return CURLM_WAKEUP_FAILURE;\n      }\n      return CURLM_OK;\n    }\n  }\n#endif\n#endif\n  return CURLM_WAKEUP_FAILURE;\n}\n\n/*\n * multi_ischanged() is called\n *\n * Returns TRUE/FALSE whether the state is changed to trigger a CONNECT_PEND\n * => CONNECT action.\n *\n * Set 'clear' to TRUE to have it also clear the state variable.\n */\nstatic bool multi_ischanged(struct Curl_multi *multi, bool clear)\n{\n  bool retval = multi->recheckstate;\n  if(clear)\n    multi->recheckstate = FALSE;\n  return retval;\n}\n\nCURLMcode Curl_multi_add_perform(struct Curl_multi *multi,\n                                 struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  CURLMcode rc;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  rc = curl_multi_add_handle(multi, data);\n  if(!rc) {\n    struct SingleRequest *k = &data->req;\n\n    /* pass in NULL for 'conn' here since we don't want to init the\n       connection, only this transfer */\n    Curl_init_do(data, NULL);\n\n    /* take this handle to the perform state right away */\n    multistate(data, MSTATE_PERFORMING);\n    Curl_attach_connnection(data, conn);\n    k->keepon |= KEEP_RECV; /* setup to receive! */\n  }\n  return rc;\n}\n\nstatic CURLcode multi_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->handler);\n\n  if(conn->handler->do_it)\n    /* generic protocol-specific function pointer set in curl_connect() */\n    result = conn->handler->do_it(data, done);\n\n  return result;\n}\n\n/*\n * multi_do_more() is called during the DO_MORE multi state. It is basically a\n * second stage DO state which (wrongly) was introduced to support FTP's\n * second connection.\n *\n * 'complete' can return 0 for incomplete, 1 for done and -1 for go back to\n * DOING state there's more work to do!\n */\n\nstatic CURLcode multi_do_more(struct Curl_easy *data, int *complete)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  *complete = 0;\n\n  if(conn->handler->do_more)\n    result = conn->handler->do_more(data, complete);\n\n  return result;\n}\n\n/*\n * We are doing protocol-specific connecting and this is being called over and\n * over from the multi interface until the connection phase is done on\n * protocol layer.\n */\n\nstatic CURLcode protocol_connecting(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(conn && conn->handler->connecting) {\n    *done = FALSE;\n    result = conn->handler->connecting(data, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We are DOING this is being called over and over from the multi interface\n * until the DOING phase is done on protocol layer.\n */\n\nstatic CURLcode protocol_doing(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(conn && conn->handler->doing) {\n    *done = FALSE;\n    result = conn->handler->doing(data, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We have discovered that the TCP connection has been successful, we can now\n * proceed with some action.\n *\n */\nstatic CURLcode protocol_connect(struct Curl_easy *data,\n                                 bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  DEBUGASSERT(conn);\n  DEBUGASSERT(protocol_done);\n\n  *protocol_done = FALSE;\n\n  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {\n    /* We already are connected, get back. This may happen when the connect\n       worked fine in the first call, like when we connect to a local server\n       or proxy. Note that we don't know if the protocol is actually done.\n\n       Unless this protocol doesn't have any protocol-connect callback, as\n       then we know we're done. */\n    if(!conn->handler->connecting)\n      *protocol_done = TRUE;\n\n    return CURLE_OK;\n  }\n\n  if(!conn->bits.protoconnstart) {\n#ifndef CURL_DISABLE_PROXY\n    result = Curl_proxy_connect(data, FIRSTSOCKET);\n    if(result)\n      return result;\n\n    if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n      /* wait for HTTPS proxy SSL initialization to complete */\n      return CURLE_OK;\n\n    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&\n       Curl_connect_ongoing(conn))\n      /* when using an HTTP tunnel proxy, await complete tunnel establishment\n         before proceeding further. Return CURLE_OK so we'll be called again */\n      return CURLE_OK;\n#endif\n    if(conn->handler->connect_it) {\n      /* is there a protocol-specific connect() procedure? */\n\n      /* Call the protocol-specific connect function */\n      result = conn->handler->connect_it(data, protocol_done);\n    }\n    else\n      *protocol_done = TRUE;\n\n    /* it has started, possibly even completed but that knowledge isn't stored\n       in this bit! */\n    if(!result)\n      conn->bits.protoconnstart = TRUE;\n  }\n\n  return result; /* pass back status */\n}\n\n/*\n * Curl_preconnect() is called immediately before a connect starts. When a\n * redirect is followed, this is then called multiple times during a single\n * transfer.\n */\nCURLcode Curl_preconnect(struct Curl_easy *data)\n{\n  if(!data->state.buffer) {\n    data->state.buffer = malloc(data->set.buffer_size + 1);\n    if(!data->state.buffer)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  return CURLE_OK;\n}\n\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime *nowp,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connected = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  timediff_t timeout_ms;\n  timediff_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* multiplexed */\n    }\n\n    if(data->mstate > MSTATE_CONNECT &&\n       data->mstate < MSTATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      DEBUGASSERT(data->conn);\n      if(!data->conn)\n        return CURLM_INTERNAL_ERROR;\n    }\n\n    if(data->conn &&\n       (data->mstate >= MSTATE_CONNECT) &&\n       (data->mstate < MSTATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, nowp,\n                                 (data->mstate <= MSTATE_DO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == MSTATE_RESOLVING)\n          failf(data, \"Resolving timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else if(data->mstate == MSTATE_CONNECTING)\n          failf(data, \"Connection timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else {\n          struct SingleRequest *k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T\n                  \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > MSTATE_DO) {\n          streamclose(data->conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(data, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case MSTATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, MSTATE_CONNECT);\n        *nowp = Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case MSTATE_PENDING:\n      /* We will stay here until there is a connection available. Then\n         we try again in the MSTATE_CONNECT state. */\n      break;\n\n    case MSTATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      /* init this transfer. */\n      result = Curl_preconnect(data);\n      if(result)\n        break;\n\n      *nowp = Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      if(data->set.timeout)\n        Curl_expire(data, data->set.timeout, EXPIRE_TIMEOUT);\n\n      if(data->set.connecttimeout)\n        Curl_expire(data, data->set.connecttimeout, EXPIRE_CONNECTTIMEOUT);\n\n      result = Curl_connect(data, &async, &protocol_connected);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, MSTATE_PENDING);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n      else if(data->state.previouslypending) {\n        /* this transfer comes from the pending queue so try move another */\n        infof(data, \"Transfer was pending, now try another\\n\");\n        process_pending_handles(data->multi);\n      }\n\n      if(!result) {\n        if(async)\n          /* We're now waiting for an asynchronous name lookup */\n          multistate(data, MSTATE_RESOLVING);\n        else {\n          /* after the connect has been sent off, go WAITCONNECT unless the\n             protocol connect is already done and we can go directly to\n             WAITDO or DO! */\n          rc = CURLM_CALL_MULTI_PERFORM;\n\n          if(protocol_connected)\n            multistate(data, MSTATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, MSTATE_TUNNELING);\n            else\n#endif\n              multistate(data, MSTATE_CONNECTING);\n          }\n        }\n      }\n      break;\n\n    case MSTATE_RESOLVING:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->conn;\n      const char *hostname;\n\n      DEBUGASSERT(conn);\n#ifndef CURL_DISABLE_PROXY\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else\n#endif\n        if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(data, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        data->state.async.dns = dns;\n        data->state.async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolv_check(data, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_once_resolved(data, &protocol_connected);\n\n        if(result)\n          /* if Curl_once_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->conn = NULL; /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connected)\n            multistate(data, MSTATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, MSTATE_TUNNELING);\n            else\n#endif\n              multistate(data, MSTATE_CONNECTING);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case MSTATE_TUNNELING:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      DEBUGASSERT(data->conn);\n      result = Curl_http_connect(data, &protocol_connected);\n#ifndef CURL_DISABLE_PROXY\n      if(data->conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(data, CURLE_OK, FALSE);\n        multistate(data, MSTATE_CONNECT);\n      }\n      else\n#endif\n        if(!result) {\n          if(\n#ifndef CURL_DISABLE_PROXY\n            (data->conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n             data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n#endif\n            Curl_connect_complete(data->conn)) {\n            rc = CURLM_CALL_MULTI_PERFORM;\n            /* initiate protocol connect phase */\n            multistate(data, MSTATE_PROTOCONNECT);\n          }\n        }\n      else\n        stream_error = TRUE;\n      break;\n#endif\n\n    case MSTATE_CONNECTING:\n      /* awaiting a completion of an asynch TCP connect */\n      DEBUGASSERT(data->conn);\n      result = Curl_is_connected(data, data->conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if(\n#ifndef CURL_DISABLE_PROXY\n          (data->conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n           !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n#endif\n          Curl_connect_ongoing(data->conn)) {\n          multistate(data, MSTATE_TUNNELING);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n#ifndef CURL_DISABLE_PROXY\n        multistate(data,\n                   data->conn->bits.tunnel_proxy?\n                   MSTATE_TUNNELING : MSTATE_PROTOCONNECT);\n#else\n        multistate(data, MSTATE_PROTOCONNECT);\n#endif\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case MSTATE_PROTOCONNECT:\n      result = protocol_connect(data, &protocol_connected);\n      if(!result && !protocol_connected)\n        /* switch to waiting state */\n        multistate(data, MSTATE_PROTOCONNECTING);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, MSTATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_PROTOCONNECTING:\n      /* protocol-specific connect phase */\n      result = protocol_connecting(data, &protocol_connected);\n      if(!result && protocol_connected) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, MSTATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->conn, \"CONNECT_ONLY\");\n        multistate(data, MSTATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(data, &dophase_done);\n\n        /* When multi_do() returns failure, data->conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n#ifndef CURL_DISABLE_FTP\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(data, CURLE_OK, FALSE);\n\n                /* if there's no connection left, skip the DONE state */\n                multistate(data, data->conn ?\n                           MSTATE_DONE : MSTATE_COMPLETED);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n#endif\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, MSTATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, MSTATE_DOING_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DID */\n            multistate(data, MSTATE_DID);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n\n          drc = Curl_retry_request(data, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n\n          Curl_posttransfer(data);\n          drc = multi_done(data, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(newurl) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, MSTATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->conn)\n            multi_done(data, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case MSTATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      DEBUGASSERT(data->conn);\n      result = protocol_doing(data, &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->conn->bits.do_more?\n                     MSTATE_DOING_MORE : MSTATE_DID);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DOING_MORE:\n      /*\n       * When we are connected, DOING MORE and then go DID\n       */\n      DEBUGASSERT(data->conn);\n      result = multi_do_more(data, &control);\n\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     MSTATE_DID : MSTATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DID:\n      DEBUGASSERT(data->conn);\n      if(data->conn->bits.multiplex)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, MSTATE_PERFORMING);\n      else {\n#ifndef CURL_DISABLE_FTP\n        if(data->state.wildcardmatch &&\n           ((data->conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n          data->wildcard.state = CURLWC_DONE;\n        }\n#endif\n        multistate(data, MSTATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case MSTATE_RATELIMITING: /* limit-rate exceeded in either direction */\n      DEBUGASSERT(data->conn);\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, *nowp);\n\n      if(result) {\n        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n      }\n      else {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   *nowp);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   *nowp);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, MSTATE_PERFORMING);\n          Curl_ratelimit(data, *nowp);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case MSTATE_PERFORMING:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n      DEBUGASSERT(data->state.buffer);\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 *nowp);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 *nowp);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, *nowp);\n        multistate(data, MSTATE_RATELIMITING);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->conn, data, &done, &comeback);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n        else if(!result)\n          result = ret;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n      else if((CURLE_HTTP2_STREAM == result) &&\n              Curl_h2_http_1_1_error(data)) {\n        CURLcode ret = Curl_retry_request(data, &newurl);\n\n        if(!ret) {\n          infof(data, \"Downgrades to HTTP/1.1!\\n\");\n          streamclose(data->conn, \"Disconnect HTTP/2 for HTTP/1\");\n          data->state.httpwant = CURL_HTTP_VERSION_1_1;\n          /* clear the error message bit too as we ignore the one we got */\n          data->state.errorbuf = FALSE;\n          if(!newurl)\n            /* typically for HTTP_1_1_REQUIRED error on first flight */\n            newurl = strdup(data->state.url);\n          /* if we are to retry, set the result to OK and consider the request\n             as done */\n          retry = TRUE;\n          result = CURLE_OK;\n          done = TRUE;\n        }\n        else\n          result = ret;\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n      }\n      else if(done) {\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          followtype follow = FOLLOW_NONE;\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          (void)multi_done(data, CURLE_OK, FALSE);\n          /* multi_done() might return CURLE_GOT_NOTHING */\n          result = Curl_follow(data, newurl, follow);\n          if(!result) {\n            multistate(data, MSTATE_CONNECT);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n          free(newurl);\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            free(newurl);\n            if(result) {\n              stream_error = TRUE;\n              result = multi_done(data, result, TRUE);\n            }\n          }\n\n          if(!result) {\n            multistate(data, MSTATE_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n      }\n      else if(comeback) {\n        /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer\n           won't get stuck on this transfer at the expense of other concurrent\n           transfers */\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n        rc = CURLM_OK;\n      }\n      break;\n    }\n\n    case MSTATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->conn) {\n        CURLcode res;\n\n        if(data->conn->bits.multiplex)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(data, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n      }\n\n#ifndef CURL_DISABLE_FTP\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with MSTATE_INIT */\n          multistate(data, MSTATE_INIT);\n          break;\n        }\n      }\n#endif\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, MSTATE_COMPLETED);\n      break;\n\n    case MSTATE_COMPLETED:\n      break;\n\n    case MSTATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < MSTATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->conn) {\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            struct connectdata *conn = data->conn;\n\n            /* This is where we make sure that the conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            Curl_detach_connnection(data);\n\n            /* remove connection from cache */\n            Curl_conncache_remove_conn(data, conn, TRUE);\n\n            /* disconnect properly */\n            Curl_disconnect(data, conn, dead_connection);\n          }\n        }\n        else if(data->mstate == MSTATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, MSTATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->conn && Curl_pgrsUpdate(data)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < MSTATE_DONE)?\n                   MSTATE_DONE: MSTATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(MSTATE_COMPLETED == data->mstate) {\n      if(data->set.fmultidone) {\n        /* signal via callback instead */\n        data->set.fmultidone(data, result);\n      }\n      else {\n        /* now fill in the Curl_message with this info */\n        msg = &data->msg;\n\n        msg->extmsg.msg = CURLMSG_DONE;\n        msg->extmsg.easy_handle = data;\n        msg->extmsg.data.result = result;\n\n        rc = multi_addmsg(multi, msg);\n        DEBUGASSERT(!data->conn);\n      }\n      multistate(data, MSTATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n  return rc;\n}\n\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, &now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    Curl_update_timer(multi);\n\n  return returncode;\n}\n\nCURLMcode curl_multi_cleanup(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  struct Curl_easy *nextdata;\n\n  if(GOOD_MULTI_HANDLE(multi)) {\n    if(multi->in_callback)\n      return CURLM_RECURSIVE_API_CALL;\n\n    multi->magic = 0; /* not good anymore */\n\n    /* Firsrt remove all remaining easy handles */\n    data = multi->easyp;\n    while(data) {\n      nextdata = data->next;\n      if(!data->state.done && data->conn)\n        /* if DONE was never called for this handle */\n        (void)multi_done(data, CURLE_OK, TRUE);\n      if(data->dns.hostcachetype == HCACHE_MULTI) {\n        /* clear out the usage of the shared DNS cache */\n        Curl_hostcache_clean(data, data->dns.hostcache);\n        data->dns.hostcache = NULL;\n        data->dns.hostcachetype = HCACHE_NONE;\n      }\n\n      /* Clear the pointer to the connection cache */\n      data->state.conn_cache = NULL;\n      data->multi = NULL; /* clear the association */\n\n#ifdef USE_LIBPSL\n      if(data->psl == &multi->psl)\n        data->psl = NULL;\n#endif\n\n      data = nextdata;\n    }\n\n    /* Close all the connections in the connection cache */\n    Curl_conncache_close_all_connections(&multi->conn_cache);\n\n    Curl_hash_destroy(&multi->sockhash);\n    Curl_conncache_destroy(&multi->conn_cache);\n    Curl_llist_destroy(&multi->msglist, NULL);\n    Curl_llist_destroy(&multi->pending, NULL);\n\n    Curl_hash_destroy(&multi->hostcache);\n    Curl_psl_destroy(&multi->psl);\n\n#ifdef USE_WINSOCK\n    WSACloseEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n#endif\n#endif\n    free(multi);\n\n    return CURLM_OK;\n  }\n  return CURLM_BAD_HANDLE;\n}\n\n/*\n * curl_multi_info_read()\n *\n * This function is the primary way for a multi/multi_socket application to\n * figure out if a transfer has ended. We MUST make this function as fast as\n * possible as it will be polled frequently and we MUST NOT scan any lists in\n * here to figure out things. We must scale fine to thousands of handles and\n * beyond. The current design is fully O(1).\n */\n\nCURLMsg *curl_multi_info_read(struct Curl_multi *multi, int *msgs_in_queue)\n{\n  struct Curl_message *msg;\n\n  *msgs_in_queue = 0; /* default to none */\n\n  if(GOOD_MULTI_HANDLE(multi) &&\n     !multi->in_callback &&\n     Curl_llist_count(&multi->msglist)) {\n    /* there is one or more messages in the list */\n    struct Curl_llist_element *e;\n\n    /* extract the head of the list to return */\n    e = multi->msglist.head;\n\n    msg = e->ptr;\n\n    /* remove the extracted entry */\n    Curl_llist_remove(&multi->msglist, e, NULL);\n\n    *msgs_in_queue = curlx_uztosi(Curl_llist_count(&multi->msglist));\n\n    return &msg->extmsg;\n  }\n  return NULL;\n}\n\n/*\n * singlesocket() checks what sockets we deal with and their \"action state\"\n * and if we have a different state in any of those sockets from last time we\n * call the callback accordingly.\n */\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data)\n{\n  curl_socket_t socks[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  struct Curl_sh_entry *entry;\n  curl_socket_t s;\n  int num;\n  unsigned int curraction;\n  unsigned char actions[MAX_SOCKSPEREASYHANDLE];\n\n  for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++)\n    socks[i] = CURL_SOCKET_BAD;\n\n  /* Fill in the 'current' struct with the state as it is now: what sockets to\n     supervise and for what actions */\n  curraction = multi_getsock(data, socks);\n\n  /* We have 0 .. N sockets already and we get to know about the 0 .. M\n     sockets we should have from now on. Detect the differences, remove no\n     longer supervised ones and add new ones */\n\n  /* walk over the sockets we got right now */\n  for(i = 0; (i< MAX_SOCKSPEREASYHANDLE) &&\n        (curraction & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i)));\n      i++) {\n    unsigned char action = CURL_POLL_NONE;\n    unsigned char prevaction = 0;\n    int comboaction;\n    bool sincebefore = FALSE;\n\n    s = socks[i];\n\n    /* get it from the hash */\n    entry = sh_getentry(&multi->sockhash, s);\n\n    if(curraction & GETSOCK_READSOCK(i))\n      action |= CURL_POLL_IN;\n    if(curraction & GETSOCK_WRITESOCK(i))\n      action |= CURL_POLL_OUT;\n\n    actions[i] = action;\n    if(entry) {\n      /* check if new for this transfer */\n      int j;\n      for(j = 0; j< data->numsocks; j++) {\n        if(s == data->sockets[j]) {\n          prevaction = data->actions[j];\n          sincebefore = TRUE;\n          break;\n        }\n      }\n    }\n    else {\n      /* this is a socket we didn't have before, add it to the hash! */\n      entry = sh_addentry(&multi->sockhash, s);\n      if(!entry)\n        /* fatal */\n        return CURLM_OUT_OF_MEMORY;\n    }\n    if(sincebefore && (prevaction != action)) {\n      /* Socket was used already, but different action now */\n      if(prevaction & CURL_POLL_IN)\n        entry->readers--;\n      if(prevaction & CURL_POLL_OUT)\n        entry->writers--;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n    }\n    else if(!sincebefore) {\n      /* a new user */\n      entry->users++;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n\n      /* add 'data' to the transfer hash on this socket! */\n      if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */\n                        sizeof(struct Curl_easy *), data))\n        return CURLM_OUT_OF_MEMORY;\n    }\n\n    comboaction = (entry->writers? CURL_POLL_OUT : 0) |\n                   (entry->readers ? CURL_POLL_IN : 0);\n\n    /* socket existed before and has the same action set as before */\n    if(sincebefore && ((int)entry->action == comboaction))\n      /* same, continue */\n      continue;\n\n    if(multi->socket_cb)\n      multi->socket_cb(data, s, comboaction, multi->socket_userp,\n                       entry->socketp);\n\n    entry->action = comboaction; /* store the current action state */\n  }\n\n  num = i; /* number of sockets */\n\n  /* when we've walked over all the sockets we should have right now, we must\n     make sure to detect sockets that are removed */\n  for(i = 0; i< data->numsocks; i++) {\n    int j;\n    bool stillused = FALSE;\n    s = data->sockets[i];\n    for(j = 0; j < num; j++) {\n      if(s == socks[j]) {\n        /* this is still supervised */\n        stillused = TRUE;\n        break;\n      }\n    }\n    if(stillused)\n      continue;\n\n    entry = sh_getentry(&multi->sockhash, s);\n    /* if this is NULL here, the socket has been closed and notified so\n       already by Curl_multi_closed() */\n    if(entry) {\n      unsigned char oldactions = data->actions[i];\n      /* this socket has been removed. Decrease user count */\n      entry->users--;\n      if(oldactions & CURL_POLL_OUT)\n        entry->writers--;\n      if(oldactions & CURL_POLL_IN)\n        entry->readers--;\n      if(!entry->users) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n      else {\n        /* still users, but remove this handle as a user of this socket */\n        if(Curl_hash_delete(&entry->transfers, (char *)&data,\n                            sizeof(struct Curl_easy *))) {\n          DEBUGASSERT(NULL);\n        }\n      }\n    }\n  } /* for loop over numsocks */\n\n  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));\n  memcpy(data->actions, actions, num*sizeof(char));\n  data->numsocks = num;\n  return CURLM_OK;\n}\n\nvoid Curl_updatesocket(struct Curl_easy *data)\n{\n  singlesocket(data->multi, data);\n}\n\n\n/*\n * Curl_multi_closed()\n *\n * Used by the connect code to tell the multi_socket code that one of the\n * sockets we were using is about to be closed.  This function will then\n * remove it from the sockethash for this handle to make the multi_socket API\n * behave properly, especially for the case when libcurl will create another\n * socket again and it gets the same file descriptor number.\n */\n\nvoid Curl_multi_closed(struct Curl_easy *data, curl_socket_t s)\n{\n  if(data) {\n    /* if there's still an easy handle associated with this connection */\n    struct Curl_multi *multi = data->multi;\n    if(multi) {\n      /* this is set if this connection is part of a handle that is added to\n         a multi handle, and only then this is necessary */\n      struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n      if(entry) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n\n        /* now remove it from the socket hash */\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n    }\n  }\n}\n\n/*\n * add_next_timeout()\n *\n * Each Curl_easy has a list of timeouts. The add_next_timeout() is called\n * when it has just been removed from the splay tree because the timeout has\n * expired. This function is then to advance in the list to pick the next\n * timeout to use (skip the already expired ones) and add this node back to\n * the splay tree again.\n *\n * The splay tree only has each sessionhandle as a single node and the nearest\n * timeout is used to sort it on.\n */\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d)\n{\n  struct curltime *tv = &d->state.expiretime;\n  struct Curl_llist *list = &d->state.timeoutlist;\n  struct Curl_llist_element *e;\n  struct time_node *node = NULL;\n\n  /* move over the timeout list for this specific handle and remove all\n     timeouts that are now passed tense and store the next pending\n     timeout in *tv */\n  for(e = list->head; e;) {\n    struct Curl_llist_element *n = e->next;\n    timediff_t diff;\n    node = (struct time_node *)e->ptr;\n    diff = Curl_timediff(node->time, now);\n    if(diff <= 0)\n      /* remove outdated entry */\n      Curl_llist_remove(list, e, NULL);\n    else\n      /* the list is sorted so get out on the first mismatch */\n      break;\n    e = n;\n  }\n  e = list->head;\n  if(!e) {\n    /* clear the expire times within the handles that we remove from the\n       splay tree */\n    tv->tv_sec = 0;\n    tv->tv_usec = 0;\n  }\n  else {\n    /* copy the first entry to 'tv' */\n    memcpy(tv, &node->time, sizeof(*tv));\n\n    /* Insert this node again into the splay.  Keep the timer in the list in\n       case we need to recompute future timers. */\n    multi->timetree = Curl_splayinsert(*tv, multi->timetree,\n                                       &d->state.timenode);\n  }\n  return CURLM_OK;\n}\n\nstatic CURLMcode multi_socket(struct Curl_multi *multi,\n                              bool checkall,\n                              curl_socket_t s,\n                              int ev_bitmask,\n                              int *running_handles)\n{\n  CURLMcode result = CURLM_OK;\n  struct Curl_easy *data = NULL;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(checkall) {\n    /* *perform() deals with running_handles on its own */\n    result = curl_multi_perform(multi, running_handles);\n\n    /* walk through each easy handle and do the socket state change magic\n       and callbacks */\n    if(result != CURLM_BAD_HANDLE) {\n      data = multi->easyp;\n      while(data && !result) {\n        result = singlesocket(multi, data);\n        data = data->next;\n      }\n    }\n\n    /* or should we fall-through and do the timer-based stuff? */\n    return result;\n  }\n  if(s != CURL_SOCKET_TIMEOUT) {\n    struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n    if(!entry)\n      /* Unmatched socket, we can't act on it but we ignore this fact.  In\n         real-world tests it has been proved that libevent can in fact give\n         the application actions even though the socket was just previously\n         asked to get removed, so thus we better survive stray socket actions\n         and just move on. */\n      ;\n    else {\n      struct Curl_hash_iterator iter;\n      struct Curl_hash_element *he;\n\n      /* the socket can be shared by many transfers, iterate */\n      Curl_hash_start_iterate(&entry->transfers, &iter);\n      for(he = Curl_hash_next_element(&iter); he;\n          he = Curl_hash_next_element(&iter)) {\n        data = (struct Curl_easy *)he->ptr;\n        DEBUGASSERT(data);\n        DEBUGASSERT(data->magic == CURLEASY_MAGIC_NUMBER);\n\n        if(data->conn && !(data->conn->handler->flags & PROTOPT_DIRLOCK))\n          /* set socket event bitmask if they're not locked */\n          data->conn->cselect_bits = ev_bitmask;\n\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n      }\n\n      /* Now we fall-through and do the timer-based stuff, since we don't want\n         to force the user to have to deal with timeouts as long as at least\n         one connection in fact has traffic. */\n\n      data = NULL; /* set data to NULL again to avoid calling\n                      multi_runsingle() in case there's no need to */\n      now = Curl_now(); /* get a newer time since the multi_runsingle() loop\n                           may have taken some time */\n    }\n  }\n  else {\n    /* Asked to run due to time-out. Clear the 'lastcall' variable to force\n       Curl_update_timer() to trigger a callback to the app again even if the\n       same timeout is still the one to run after this call. That handles the\n       case when the application asks libcurl to run the timeout\n       prematurely. */\n    memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n  }\n\n  /*\n   * The loop following here will go on as long as there are expire-times left\n   * to process in the splay and 'data' will be re-assigned for every expired\n   * handle we deal with.\n   */\n  do {\n    /* the first loop lap 'data' can be NULL */\n    if(data) {\n      SIGPIPE_VARIABLE(pipe_st);\n\n      sigpipe_ignore(data, &pipe_st);\n      result = multi_runsingle(multi, &now, data);\n      sigpipe_restore(&pipe_st);\n\n      if(CURLM_OK >= result) {\n        /* get the socket(s) and check if the state has been changed since\n           last */\n        result = singlesocket(multi, data);\n        if(result)\n          return result;\n      }\n    }\n\n    /* Check if there's one (more) expired timer to deal with! This function\n       extracts a matching node if there is one */\n\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t) {\n      data = t->payload; /* assign this for next loop */\n      (void)add_next_timeout(now, multi, t->payload);\n    }\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n  return result;\n}\n\n#undef curl_multi_setopt\nCURLMcode curl_multi_setopt(struct Curl_multi *multi,\n                            CURLMoption option, ...)\n{\n  CURLMcode res = CURLM_OK;\n  va_list param;\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  va_start(param, option);\n\n  switch(option) {\n  case CURLMOPT_SOCKETFUNCTION:\n    multi->socket_cb = va_arg(param, curl_socket_callback);\n    break;\n  case CURLMOPT_SOCKETDATA:\n    multi->socket_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PUSHFUNCTION:\n    multi->push_cb = va_arg(param, curl_push_callback);\n    break;\n  case CURLMOPT_PUSHDATA:\n    multi->push_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PIPELINING:\n    multi->multiplexing = va_arg(param, long) & CURLPIPE_MULTIPLEX;\n    break;\n  case CURLMOPT_TIMERFUNCTION:\n    multi->timer_cb = va_arg(param, curl_multi_timer_callback);\n    break;\n  case CURLMOPT_TIMERDATA:\n    multi->timer_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_MAXCONNECTS:\n    multi->maxconnects = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_HOST_CONNECTIONS:\n    multi->max_host_connections = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_TOTAL_CONNECTIONS:\n    multi->max_total_connections = va_arg(param, long);\n    break;\n    /* options formerly used for pipelining */\n  case CURLMOPT_MAX_PIPELINE_LENGTH:\n    break;\n  case CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_PIPELINING_SITE_BL:\n    break;\n  case CURLMOPT_PIPELINING_SERVER_BL:\n    break;\n  case CURLMOPT_MAX_CONCURRENT_STREAMS:\n    {\n      long streams = va_arg(param, long);\n      if(streams < 1)\n        streams = 100;\n      multi->max_concurrent_streams = curlx_sltoui(streams);\n    }\n    break;\n  default:\n    res = CURLM_UNKNOWN_OPTION;\n    break;\n  }\n  va_end(param);\n  return res;\n}\n\n/* we define curl_multi_socket() in the public multi.h header */\n#undef curl_multi_socket\n\nCURLMcode curl_multi_socket(struct Curl_multi *multi, curl_socket_t s,\n                            int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_action(struct Curl_multi *multi, curl_socket_t s,\n                                   int ev_bitmask, int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, ev_bitmask, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_all(struct Curl_multi *multi, int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, TRUE, CURL_SOCKET_BAD, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms)\n{\n  static struct curltime tv_zero = {0, 0};\n\n  if(multi->timetree) {\n    /* we have a tree of expire times */\n    struct curltime now = Curl_now();\n\n    /* splay the lowest to the bottom */\n    multi->timetree = Curl_splay(tv_zero, multi->timetree);\n\n    if(Curl_splaycomparekeys(multi->timetree->key, now) > 0) {\n      /* some time left before expiration */\n      timediff_t diff = Curl_timediff(multi->timetree->key, now);\n      if(diff <= 0)\n        /*\n         * Since we only provide millisecond resolution on the returned value\n         * and the diff might be less than one millisecond here, we don't\n         * return zero as that may cause short bursts of busyloops on fast\n         * processors while the diff is still present but less than one\n         * millisecond! instead we return 1 until the time is ripe.\n         */\n        *timeout_ms = 1;\n      else\n        /* this should be safe even on 64 bit archs, as we don't use that\n           overly long timeouts */\n        *timeout_ms = (long)diff;\n    }\n    else\n      /* 0 means immediately */\n      *timeout_ms = 0;\n  }\n  else\n    *timeout_ms = -1;\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_timeout(struct Curl_multi *multi,\n                             long *timeout_ms)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  return multi_timeout(multi, timeout_ms);\n}\n\n/*\n * Tell the application it should update its timers, if it subscribes to the\n * update timer callback.\n */\nvoid Curl_update_timer(struct Curl_multi *multi)\n{\n  long timeout_ms;\n\n  if(!multi->timer_cb)\n    return;\n  if(multi_timeout(multi, &timeout_ms)) {\n    return;\n  }\n  if(timeout_ms < 0) {\n    static const struct curltime none = {0, 0};\n    if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {\n      multi->timer_lastcall = none;\n      /* there's no timeout now but there was one previously, tell the app to\n         disable it */\n      multi->timer_cb(multi, -1, multi->timer_userp);\n      return;\n    }\n    return;\n  }\n\n  /* When multi_timeout() is done, multi->timetree points to the node with the\n   * timeout we got the (relative) time-out time for. We can thus easily check\n   * if this is the same (fixed) time as we got in a previous call and then\n   * avoid calling the callback again. */\n  if(Curl_splaycomparekeys(multi->timetree->key, multi->timer_lastcall) == 0)\n    return;\n\n  multi->timer_lastcall = multi->timetree->key;\n\n  multi->timer_cb(multi, timeout_ms, multi->timer_userp);\n}\n\n/*\n * multi_deltimeout()\n *\n * Remove a given timestamp from the list of timeouts.\n */\nstatic void\nmulti_deltimeout(struct Curl_easy *data, expire_id eid)\n{\n  struct Curl_llist_element *e;\n  struct Curl_llist *timeoutlist = &data->state.timeoutlist;\n  /* find and remove the specific node from the list */\n  for(e = timeoutlist->head; e; e = e->next) {\n    struct time_node *n = (struct time_node *)e->ptr;\n    if(n->eid == eid) {\n      Curl_llist_remove(timeoutlist, e, NULL);\n      return;\n    }\n  }\n}\n\n/*\n * multi_addtimeout()\n *\n * Add a timestamp to the list of timeouts. Keep the list sorted so that head\n * of list is always the timeout nearest in time.\n *\n */\nstatic CURLMcode\nmulti_addtimeout(struct Curl_easy *data,\n                 struct curltime *stamp,\n                 expire_id eid)\n{\n  struct Curl_llist_element *e;\n  struct time_node *node;\n  struct Curl_llist_element *prev = NULL;\n  size_t n;\n  struct Curl_llist *timeoutlist = &data->state.timeoutlist;\n\n  node = &data->state.expires[eid];\n\n  /* copy the timestamp and id */\n  memcpy(&node->time, stamp, sizeof(*stamp));\n  node->eid = eid; /* also marks it as in use */\n\n  n = Curl_llist_count(timeoutlist);\n  if(n) {\n    /* find the correct spot in the list */\n    for(e = timeoutlist->head; e; e = e->next) {\n      struct time_node *check = (struct time_node *)e->ptr;\n      timediff_t diff = Curl_timediff(check->time, node->time);\n      if(diff > 0)\n        break;\n      prev = e;\n    }\n\n  }\n  /* else\n     this is the first timeout on the list */\n\n  Curl_llist_insert_next(timeoutlist, prev, node, &node->list);\n  return CURLM_OK;\n}\n\n/*\n * Curl_expire()\n *\n * given a number of milliseconds from now to use to set the 'act before\n * this'-time for the transfer, to be extracted by curl_multi_timeout()\n *\n * The timeout will be added to a queue of timeouts if it defines a moment in\n * time that is later than the current head of queue.\n *\n * Expire replaces a former timeout using the same id if already set.\n */\nvoid Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n  struct curltime set;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  DEBUGASSERT(id < EXPIRE_LAST);\n\n  set = Curl_now();\n  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */\n  set.tv_usec += (unsigned int)(milli%1000)*1000;\n\n  if(set.tv_usec >= 1000000) {\n    set.tv_sec++;\n    set.tv_usec -= 1000000;\n  }\n\n  /* Remove any timer with the same id just in case. */\n  multi_deltimeout(data, id);\n\n  /* Add it to the timer list.  It must stay in the list until it has expired\n     in case we need to recompute the minimum timer later. */\n  multi_addtimeout(data, &set, id);\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* This means that the struct is added as a node in the splay tree.\n       Compare if the new time is earlier, and only remove-old/add-new if it\n       is. */\n    timediff_t diff = Curl_timediff(set, *nowp);\n    int rc;\n\n    if(diff > 0) {\n      /* The current splay tree entry is sooner than this new expiry time.\n         We don't need to update our splay tree entry. */\n      return;\n    }\n\n    /* Since this is an updated time, we must remove the previous entry from\n       the splay tree first and then re-add the new value */\n    rc = Curl_splayremove(multi->timetree, &data->state.timenode,\n                          &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error removing splay node = %d\\n\", rc);\n  }\n\n  /* Indicate that we are in the splay tree and insert the new timer expiry\n     value since it is our local minimum. */\n  *nowp = set;\n  data->state.timenode.payload = data;\n  multi->timetree = Curl_splayinsert(*nowp, multi->timetree,\n                                     &data->state.timenode);\n}\n\n/*\n * Curl_expire_done()\n *\n * Removes the expire timer. Marks it as done.\n *\n */\nvoid Curl_expire_done(struct Curl_easy *data, expire_id id)\n{\n  /* remove the timer, if there */\n  multi_deltimeout(data, id);\n}\n\n/*\n * Curl_expire_clear()\n *\n * Clear ALL timeout values for this handle.\n */\nvoid Curl_expire_clear(struct Curl_easy *data)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* Since this is an cleared time, we must remove the previous entry from\n       the splay tree */\n    struct Curl_llist *list = &data->state.timeoutlist;\n    int rc;\n\n    rc = Curl_splayremove(multi->timetree, &data->state.timenode,\n                          &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error clearing splay node = %d\\n\", rc);\n\n    /* flush the timeout list too */\n    while(list->size > 0) {\n      Curl_llist_remove(list, list->tail, NULL);\n    }\n\n#ifdef DEBUGBUILD\n    infof(data, \"Expire cleared (transfer %p)\\n\", data);\n#endif\n    nowp->tv_sec = 0;\n    nowp->tv_usec = 0;\n  }\n}\n\n\n\n\nCURLMcode curl_multi_assign(struct Curl_multi *multi, curl_socket_t s,\n                            void *hashp)\n{\n  struct Curl_sh_entry *there = NULL;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  there = sh_getentry(&multi->sockhash, s);\n\n  if(!there)\n    return CURLM_BAD_SOCKET;\n\n  there->socketp = hashp;\n\n  return CURLM_OK;\n}\n\nsize_t Curl_multi_max_host_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_host_connections : 0;\n}\n\nsize_t Curl_multi_max_total_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_total_connections : 0;\n}\n\n/*\n * When information about a connection has appeared, call this!\n */\n\nvoid Curl_multiuse_state(struct Curl_easy *data,\n                         int bundlestate) /* use BUNDLE_* defines */\n{\n  struct connectdata *conn;\n  DEBUGASSERT(data);\n  DEBUGASSERT(data->multi);\n  conn = data->conn;\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->bundle);\n\n  conn->bundle->multiuse = bundlestate;\n  process_pending_handles(data->multi);\n}\n\nstatic void process_pending_handles(struct Curl_multi *multi)\n{\n  struct Curl_llist_element *e = multi->pending.head;\n  if(e) {\n    struct Curl_easy *data = e->ptr;\n\n    DEBUGASSERT(data->mstate == MSTATE_PENDING);\n\n    multistate(data, MSTATE_CONNECT);\n\n    /* Remove this node from the list */\n    Curl_llist_remove(&multi->pending, e, NULL);\n\n    /* Make sure that the handle will be processed soonish. */\n    Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n    /* mark this as having been in the pending queue */\n    data->state.previouslypending = TRUE;\n  }\n}\n\nvoid Curl_set_in_callback(struct Curl_easy *data, bool value)\n{\n  /* might get called when there is no data pointer! */\n  if(data) {\n    if(data->multi_easy)\n      data->multi_easy->in_callback = value;\n    else if(data->multi)\n      data->multi->in_callback = value;\n  }\n}\n\nbool Curl_is_in_callback(struct Curl_easy *easy)\n{\n  return ((easy->multi && easy->multi->in_callback) ||\n          (easy->multi_easy && easy->multi_easy->in_callback));\n}\n\n#ifdef DEBUGBUILD\nvoid Curl_multi_dump(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  int i;\n  fprintf(stderr, \"* Multi status: %d handles, %d alive\\n\",\n          multi->num_easy, multi->num_alive);\n  for(data = multi->easyp; data; data = data->next) {\n    if(data->mstate < MSTATE_COMPLETED) {\n      /* only display handles that are not completed */\n      fprintf(stderr, \"handle %p, state %s, %d sockets\\n\",\n              (void *)data,\n              statename[data->mstate], data->numsocks);\n      for(i = 0; i < data->numsocks; i++) {\n        curl_socket_t s = data->sockets[i];\n        struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n        fprintf(stderr, \"%d \", (int)s);\n        if(!entry) {\n          fprintf(stderr, \"INTERNAL CONFUSION\\n\");\n          continue;\n        }\n        fprintf(stderr, \"[%s %s] \",\n                (entry->action&CURL_POLL_IN)?\"RECVING\":\"\",\n                (entry->action&CURL_POLL_OUT)?\"SENDING\":\"\");\n      }\n      if(data->numsocks)\n        fprintf(stderr, \"\\n\");\n    }\n  }\n}\n#endif\n\nunsigned int Curl_multi_max_concurrent_streams(struct Curl_multi *multi)\n{\n  DEBUGASSERT(multi);\n  return multi->max_concurrent_streams;\n}\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef USE_GSKIT\n\n#include <gskssl.h>\n#include <qsoasync.h>\n#undef HAVE_SOCKETPAIR /* because the native one isn't good enough */\n#include \"socketpair.h\"\n\n/* Some symbols are undefined/unsupported on OS400 versions < V7R1. */\n#ifndef GSK_SSL_EXTN_SERVERNAME_REQUEST\n#define GSK_SSL_EXTN_SERVERNAME_REQUEST         230\n#endif\n\n#ifndef GSK_TLSV10_CIPHER_SPECS\n#define GSK_TLSV10_CIPHER_SPECS                 236\n#endif\n\n#ifndef GSK_TLSV11_CIPHER_SPECS\n#define GSK_TLSV11_CIPHER_SPECS                 237\n#endif\n\n#ifndef GSK_TLSV12_CIPHER_SPECS\n#define GSK_TLSV12_CIPHER_SPECS                 238\n#endif\n\n#ifndef GSK_PROTOCOL_TLSV11\n#define GSK_PROTOCOL_TLSV11                     437\n#endif\n\n#ifndef GSK_PROTOCOL_TLSV12\n#define GSK_PROTOCOL_TLSV12                     438\n#endif\n\n#ifndef GSK_FALSE\n#define GSK_FALSE                               0\n#endif\n\n#ifndef GSK_TRUE\n#define GSK_TRUE                                1\n#endif\n\n\n#include <limits.h>\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"gskit.h\"\n#include \"vtls.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n\n/* Directions. */\n#define SOS_READ        0x01\n#define SOS_WRITE       0x02\n\n/* SSL version flags. */\n#define CURL_GSKPROTO_SSLV2     0\n#define CURL_GSKPROTO_SSLV2_MASK        (1 << CURL_GSKPROTO_SSLV2)\n#define CURL_GSKPROTO_SSLV3     1\n#define CURL_GSKPROTO_SSLV3_MASK        (1 << CURL_GSKPROTO_SSLV3)\n#define CURL_GSKPROTO_TLSV10    2\n#define CURL_GSKPROTO_TLSV10_MASK        (1 << CURL_GSKPROTO_TLSV10)\n#define CURL_GSKPROTO_TLSV11    3\n#define CURL_GSKPROTO_TLSV11_MASK        (1 << CURL_GSKPROTO_TLSV11)\n#define CURL_GSKPROTO_TLSV12    4\n#define CURL_GSKPROTO_TLSV12_MASK        (1 << CURL_GSKPROTO_TLSV12)\n#define CURL_GSKPROTO_LAST      5\n\nstruct ssl_backend_data {\n  gsk_handle handle;\n  int iocport;\n#ifndef CURL_DISABLE_PROXY\n  int localfd;\n  int remotefd;\n#endif\n};\n\n#define BACKEND connssl->backend\n\n/* Supported ciphers. */\nstruct gskit_cipher {\n  const char *name;            /* Cipher name. */\n  const char *gsktoken;        /* Corresponding token for GSKit String. */\n  unsigned int versions;       /* SSL version flags. */\n};\n\nstatic const struct gskit_cipher  ciphertable[] = {\n  { \"null-md5\",         \"01\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"null-sha\",         \"02\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"exp-rc4-md5\",      \"03\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK },\n  { \"rc4-md5\",          \"04\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"rc4-sha\",          \"05\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"exp-rc2-cbc-md5\",  \"06\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK },\n  { \"exp-des-cbc-sha\",  \"09\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK },\n  { \"des-cbc3-sha\",     \"0A\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-sha\",       \"2F\",\n      CURL_GSKPROTO_TLSV10_MASK | CURL_GSKPROTO_TLSV11_MASK |\n      CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-sha\",       \"35\",\n      CURL_GSKPROTO_TLSV10_MASK | CURL_GSKPROTO_TLSV11_MASK |\n      CURL_GSKPROTO_TLSV12_MASK },\n  { \"null-sha256\",      \"3B\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-sha256\",    \"3C\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-sha256\",    \"3D\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-gcm-sha256\",\n                        \"9C\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-gcm-sha384\",\n                        \"9D\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"rc4-md5\",          \"1\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"exp-rc4-md5\",      \"2\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"rc2-md5\",          \"3\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"exp-rc2-md5\",      \"4\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"des-cbc-md5\",      \"6\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"des-cbc3-md5\",     \"7\",    CURL_GSKPROTO_SSLV2_MASK },\n  { (const char *) NULL, (const char *) NULL, 0       }\n};\n\n\nstatic bool is_separator(char c)\n{\n  /* Return whether character is a cipher list separator. */\n  switch(c) {\n  case ' ':\n  case '\\t':\n  case ':':\n  case ',':\n  case ';':\n    return true;\n  }\n  return false;\n}\n\n\nstatic CURLcode gskit_status(struct Curl_easy *data, int rc,\n                             const char *procname, CURLcode defcode)\n{\n  /* Process GSKit status and map it to a CURLcode. */\n  switch(rc) {\n  case GSK_OK:\n  case GSK_OS400_ASYNCHRONOUS_SOC_INIT:\n    return CURLE_OK;\n  case GSK_KEYRING_OPEN_ERROR:\n  case GSK_OS400_ERROR_NO_ACCESS:\n    return CURLE_SSL_CACERT_BADFILE;\n  case GSK_INSUFFICIENT_STORAGE:\n    return CURLE_OUT_OF_MEMORY;\n  case GSK_ERROR_BAD_V2_CIPHER:\n  case GSK_ERROR_BAD_V3_CIPHER:\n  case GSK_ERROR_NO_CIPHERS:\n    return CURLE_SSL_CIPHER;\n  case GSK_OS400_ERROR_NOT_TRUSTED_ROOT:\n  case GSK_ERROR_CERT_VALIDATION:\n    return CURLE_PEER_FAILED_VERIFICATION;\n  case GSK_OS400_ERROR_TIMED_OUT:\n    return CURLE_OPERATION_TIMEDOUT;\n  case GSK_WOULD_BLOCK:\n    return CURLE_AGAIN;\n  case GSK_OS400_ERROR_NOT_REGISTERED:\n    break;\n  case GSK_ERROR_IO:\n    switch(errno) {\n    case ENOMEM:\n      return CURLE_OUT_OF_MEMORY;\n    default:\n      failf(data, \"%s I/O error: %s\", procname, strerror(errno));\n      break;\n    }\n    break;\n  default:\n    failf(data, \"%s: %s\", procname, gsk_strerror(rc));\n    break;\n  }\n  return defcode;\n}\n\n\nstatic CURLcode set_enum(struct Curl_easy *data, gsk_handle h,\n                GSK_ENUM_ID id, GSK_ENUM_VALUE value, bool unsupported_ok)\n{\n  int rc = gsk_attribute_set_enum(h, id, value);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_enum() I/O error: %s\", strerror(errno));\n    break;\n  case GSK_ATTRIBUTE_INVALID_ID:\n    if(unsupported_ok)\n      return CURLE_UNSUPPORTED_PROTOCOL;\n  default:\n    failf(data, \"gsk_attribute_set_enum(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_buffer(struct Curl_easy *data, gsk_handle h,\n                        GSK_BUF_ID id, const char *buffer, bool unsupported_ok)\n{\n  int rc = gsk_attribute_set_buffer(h, id, buffer, 0);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_buffer() I/O error: %s\", strerror(errno));\n    break;\n  case GSK_ATTRIBUTE_INVALID_ID:\n    if(unsupported_ok)\n      return CURLE_UNSUPPORTED_PROTOCOL;\n  default:\n    failf(data, \"gsk_attribute_set_buffer(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_numeric(struct Curl_easy *data,\n                            gsk_handle h, GSK_NUM_ID id, int value)\n{\n  int rc = gsk_attribute_set_numeric_value(h, id, value);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_numeric_value() I/O error: %s\",\n          strerror(errno));\n    break;\n  default:\n    failf(data, \"gsk_attribute_set_numeric_value(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_callback(struct Curl_easy *data,\n                             gsk_handle h, GSK_CALLBACK_ID id, void *info)\n{\n  int rc = gsk_attribute_set_callback(h, id, info);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_callback() I/O error: %s\", strerror(errno));\n    break;\n  default:\n    failf(data, \"gsk_attribute_set_callback(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_ciphers(struct Curl_easy *data,\n                            gsk_handle h, unsigned int *protoflags)\n{\n  struct connectdata *conn = data->conn;\n  const char *cipherlist = SSL_CONN_CONFIG(cipher_list);\n  const char *clp;\n  const struct gskit_cipher *ctp;\n  int i;\n  int l;\n  bool unsupported;\n  CURLcode result;\n  struct {\n    char *buf;\n    char *ptr;\n  } ciphers[CURL_GSKPROTO_LAST];\n\n  /* Compile cipher list into GSKit-compatible cipher lists. */\n\n  if(!cipherlist)\n    return CURLE_OK;\n  while(is_separator(*cipherlist))     /* Skip initial separators. */\n    cipherlist++;\n  if(!*cipherlist)\n    return CURLE_OK;\n\n  /* We allocate GSKit buffers of the same size as the input string: since\n     GSKit tokens are always shorter than their cipher names, allocated buffers\n     will always be large enough to accommodate the result. */\n  l = strlen(cipherlist) + 1;\n  memset((char *) ciphers, 0, sizeof(ciphers));\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n    ciphers[i].buf = malloc(l);\n    if(!ciphers[i].buf) {\n      while(i--)\n        free(ciphers[i].buf);\n      return CURLE_OUT_OF_MEMORY;\n    }\n    ciphers[i].ptr = ciphers[i].buf;\n    *ciphers[i].ptr = '\\0';\n  }\n\n  /* Process each cipher in input string. */\n  unsupported = FALSE;\n  result = CURLE_OK;\n  for(;;) {\n    for(clp = cipherlist; *cipherlist && !is_separator(*cipherlist);)\n      cipherlist++;\n    l = cipherlist - clp;\n    if(!l)\n      break;\n    /* Search the cipher in our table. */\n    for(ctp = ciphertable; ctp->name; ctp++)\n      if(strncasecompare(ctp->name, clp, l) && !ctp->name[l])\n        break;\n    if(!ctp->name) {\n      failf(data, \"Unknown cipher %.*s\", l, clp);\n      result = CURLE_SSL_CIPHER;\n    }\n    else {\n      unsupported |= !(ctp->versions & (CURL_GSKPROTO_SSLV2_MASK |\n                        CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK));\n      for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n        if(ctp->versions & (1 << i)) {\n          strcpy(ciphers[i].ptr, ctp->gsktoken);\n          ciphers[i].ptr += strlen(ctp->gsktoken);\n        }\n      }\n    }\n\n   /* Advance to next cipher name or end of string. */\n    while(is_separator(*cipherlist))\n      cipherlist++;\n  }\n\n  /* Disable protocols with empty cipher lists. */\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n    if(!(*protoflags & (1 << i)) || !ciphers[i].buf[0]) {\n      *protoflags &= ~(1 << i);\n      ciphers[i].buf[0] = '\\0';\n    }\n  }\n\n  /* Try to set-up TLSv1.1 and TLSv2.1 ciphers. */\n  if(*protoflags & CURL_GSKPROTO_TLSV11_MASK) {\n    result = set_buffer(data, h, GSK_TLSV11_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV11].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(unsupported) {\n        failf(data, \"TLSv1.1-only ciphers are not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result && (*protoflags & CURL_GSKPROTO_TLSV12_MASK)) {\n    result = set_buffer(data, h, GSK_TLSV12_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV12].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(unsupported) {\n        failf(data, \"TLSv1.2-only ciphers are not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n\n  /* Try to set-up TLSv1.0 ciphers. If not successful, concatenate them to\n     the SSLv3 ciphers. OS/400 prior to version 7.1 will understand it. */\n  if(!result && (*protoflags & CURL_GSKPROTO_TLSV10_MASK)) {\n    result = set_buffer(data, h, GSK_TLSV10_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV10].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      strcpy(ciphers[CURL_GSKPROTO_SSLV3].ptr,\n             ciphers[CURL_GSKPROTO_TLSV10].ptr);\n    }\n  }\n\n  /* Set-up other ciphers. */\n  if(!result && (*protoflags & CURL_GSKPROTO_SSLV3_MASK))\n    result = set_buffer(data, h, GSK_V3_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_SSLV3].buf, FALSE);\n  if(!result && (*protoflags & CURL_GSKPROTO_SSLV2_MASK))\n    result = set_buffer(data, h, GSK_V2_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_SSLV2].buf, FALSE);\n\n  /* Clean-up. */\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++)\n    free(ciphers[i].buf);\n\n  return result;\n}\n\n\nstatic int gskit_init(void)\n{\n  /* No initialisation needed. */\n\n  return 1;\n}\n\n\nstatic void gskit_cleanup(void)\n{\n  /* Nothing to do. */\n}\n\n\nstatic CURLcode init_environment(struct Curl_easy *data,\n                                 gsk_handle *envir, const char *appid,\n                                 const char *file, const char *label,\n                                 const char *password)\n{\n  int rc;\n  CURLcode result;\n  gsk_handle h;\n\n  /* Creates the GSKit environment. */\n\n  rc = gsk_environment_open(&h);\n  switch(rc) {\n  case GSK_OK:\n    break;\n  case GSK_INSUFFICIENT_STORAGE:\n    return CURLE_OUT_OF_MEMORY;\n  default:\n    failf(data, \"gsk_environment_open(): %s\", gsk_strerror(rc));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  result = set_enum(data, h, GSK_SESSION_TYPE, GSK_CLIENT_SESSION, FALSE);\n  if(!result && appid)\n    result = set_buffer(data, h, GSK_OS400_APPLICATION_ID, appid, FALSE);\n  if(!result && file)\n    result = set_buffer(data, h, GSK_KEYRING_FILE, file, FALSE);\n  if(!result && label)\n    result = set_buffer(data, h, GSK_KEYRING_LABEL, label, FALSE);\n  if(!result && password)\n    result = set_buffer(data, h, GSK_KEYRING_PW, password, FALSE);\n\n  if(!result) {\n    /* Locate CAs, Client certificate and key according to our settings.\n       Note: this call may be blocking for some tenths of seconds. */\n    result = gskit_status(data, gsk_environment_init(h),\n                          \"gsk_environment_init()\", CURLE_SSL_CERTPROBLEM);\n    if(!result) {\n      *envir = h;\n      return result;\n    }\n  }\n  /* Error: rollback. */\n  gsk_environment_close(&h);\n  return result;\n}\n\n\nstatic void cancel_async_handshake(struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  Qso_OverlappedIO_t cstat;\n\n  if(QsoCancelOperation(conn->sock[sockindex], 0) > 0)\n    QsoWaitForIOCompletion(BACKEND->iocport, &cstat, (struct timeval *) NULL);\n}\n\n\nstatic void close_async_handshake(struct ssl_connect_data *connssl)\n{\n  QsoDestroyIOCompletionPort(BACKEND->iocport);\n  BACKEND->iocport = -1;\n}\n\nstatic int pipe_ssloverssl(struct connectdata *conn, int sockindex,\n                           int directions)\n{\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_connect_data *connproxyssl = &conn->proxy_ssl[sockindex];\n  fd_set fds_read;\n  fd_set fds_write;\n  int n;\n  int m;\n  int i;\n  int ret = 0;\n  char buf[CURL_MAX_WRITE_SIZE];\n\n  if(!connssl->use || !connproxyssl->use)\n    return 0;   /* No SSL over SSL: OK. */\n\n  FD_ZERO(&fds_read);\n  FD_ZERO(&fds_write);\n  n = -1;\n  if(directions & SOS_READ) {\n    FD_SET(BACKEND->remotefd, &fds_write);\n    n = BACKEND->remotefd;\n  }\n  if(directions & SOS_WRITE) {\n    FD_SET(BACKEND->remotefd, &fds_read);\n    n = BACKEND->remotefd;\n    FD_SET(conn->sock[sockindex], &fds_write);\n    if(n < conn->sock[sockindex])\n      n = conn->sock[sockindex];\n  }\n  i = Curl_select(n + 1, &fds_read, &fds_write, NULL, 0);\n  if(i < 0)\n    return -1;  /* Select error. */\n\n  if(FD_ISSET(BACKEND->remotefd, &fds_write)) {\n    /* Try getting data from HTTPS proxy and pipe it upstream. */\n    n = 0;\n    i = gsk_secure_soc_read(connproxyssl->backend->handle,\n                            buf, sizeof(buf), &n);\n    switch(i) {\n    case GSK_OK:\n      if(n) {\n        i = write(BACKEND->remotefd, buf, n);\n        if(i < 0)\n          return -1;\n        ret = 1;\n      }\n      break;\n    case GSK_OS400_ERROR_TIMED_OUT:\n    case GSK_WOULD_BLOCK:\n      break;\n    default:\n      return -1;\n    }\n  }\n\n  if(FD_ISSET(BACKEND->remotefd, &fds_read) &&\n     FD_ISSET(conn->sock[sockindex], &fds_write)) {\n    /* Pipe data to HTTPS proxy. */\n    n = read(BACKEND->remotefd, buf, sizeof(buf));\n    if(n < 0)\n      return -1;\n    if(n) {\n      i = gsk_secure_soc_write(connproxyssl->backend->handle, buf, n, &m);\n      if(i != GSK_OK || n != m)\n        return -1;\n      ret = 1;\n    }\n  }\n\n  return ret;  /* OK */\n#else\n  return 0;\n#endif\n}\n\n\nstatic void close_one(struct ssl_connect_data *connssl, struct Curl_easy *data,\n                      struct connectdata *conn, int sockindex)\n{\n  if(BACKEND->handle) {\n    gskit_status(data, gsk_secure_soc_close(&BACKEND->handle),\n              \"gsk_secure_soc_close()\", 0);\n    /* Last chance to drain output. */\n    while(pipe_ssloverssl(conn, sockindex, SOS_WRITE) > 0)\n      ;\n    BACKEND->handle = (gsk_handle) NULL;\n#ifndef CURL_DISABLE_PROXY\n    if(BACKEND->localfd >= 0) {\n      close(BACKEND->localfd);\n      BACKEND->localfd = -1;\n    }\n    if(BACKEND->remotefd >= 0) {\n      close(BACKEND->remotefd);\n      BACKEND->remotefd = -1;\n    }\n#endif\n  }\n  if(BACKEND->iocport >= 0)\n    close_async_handshake(connssl);\n}\n\n\nstatic ssize_t gskit_send(struct Curl_easy *data, int sockindex,\n                          const void *mem, size_t len, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CURLcode cc = CURLE_SEND_ERROR;\n  int written;\n\n  if(pipe_ssloverssl(conn, sockindex, SOS_WRITE) >= 0) {\n    cc = gskit_status(data,\n                      gsk_secure_soc_write(BACKEND->handle,\n                                           (char *) mem, (int) len, &written),\n                      \"gsk_secure_soc_write()\", CURLE_SEND_ERROR);\n    if(cc == CURLE_OK)\n      if(pipe_ssloverssl(conn, sockindex, SOS_WRITE) < 0)\n        cc = CURLE_SEND_ERROR;\n  }\n  if(cc != CURLE_OK) {\n    *curlcode = cc;\n    written = -1;\n  }\n  return (ssize_t) written; /* number of bytes */\n}\n\n\nstatic ssize_t gskit_recv(struct Curl_easy *data, int num, char *buf,\n                               size_t buffersize, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  int nread;\n  CURLcode cc = CURLE_RECV_ERROR;\n\n  if(pipe_ssloverssl(conn, num, SOS_READ) >= 0) {\n    int buffsize = buffersize > (size_t) INT_MAX? INT_MAX: (int) buffersize;\n    cc = gskit_status(data, gsk_secure_soc_read(BACKEND->handle,\n                                                buf, buffsize, &nread),\n                      \"gsk_secure_soc_read()\", CURLE_RECV_ERROR);\n  }\n  switch(cc) {\n  case CURLE_OK:\n    break;\n  case CURLE_OPERATION_TIMEDOUT:\n    cc = CURLE_AGAIN;\n  default:\n    *curlcode = cc;\n    nread = -1;\n    break;\n  }\n  return (ssize_t) nread;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(unsigned int *protoflags, struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = CURL_SSLVERSION_TLSv1_2;\n      break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n      case CURL_SSLVERSION_TLSv1_0:\n        *protoflags |= CURL_GSKPROTO_TLSV10_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_1:\n        *protoflags |= CURL_GSKPROTO_TLSV11_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_2:\n        *protoflags |= CURL_GSKPROTO_TLSV11_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_3:\n        failf(data, \"GSKit: TLS 1.3 is not yet supported\");\n        return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode gskit_connect_step1(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  gsk_handle envir;\n  CURLcode result;\n  const char * const keyringfile = SSL_CONN_CONFIG(CAfile);\n  const char * const keyringpwd = SSL_SET_OPTION(key_passwd);\n  const char * const keyringlabel = SSL_SET_OPTION(primary.clientcert);\n  const long int ssl_version = SSL_CONN_CONFIG(version);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const hostname = SSL_HOST_NAME();\n  const char *sni;\n  unsigned int protoflags = 0;\n  Qso_OverlappedIO_t commarea;\n#ifndef CURL_DISABLE_PROXY\n  int sockpair[2];\n  static const int sobufsize = CURL_MAX_WRITE_SIZE;\n#endif\n\n  /* Create SSL environment, start (preferably asynchronous) handshake. */\n\n  BACKEND->handle = (gsk_handle) NULL;\n  BACKEND->iocport = -1;\n#ifndef CURL_DISABLE_PROXY\n  BACKEND->localfd = -1;\n  BACKEND->remotefd = -1;\n#endif\n\n  /* GSKit supports two ways of specifying an SSL context: either by\n   *  application identifier (that should have been defined at the system\n   *  level) or by keyring file, password and certificate label.\n   * Local certificate name (CURLOPT_SSLCERT) is used to hold either the\n   *  application identifier of the certificate label.\n   * Key password (CURLOPT_KEYPASSWD) holds the keyring password.\n   * It is not possible to have different keyrings for the CAs and the\n   *  local certificate. We thus use the CA file (CURLOPT_CAINFO) to identify\n   *  the keyring file.\n   * If no key password is given and the keyring is the system keyring,\n   *  application identifier mode is tried first, as recommended in IBM doc.\n   */\n\n  envir = (gsk_handle) NULL;\n\n  if(keyringlabel && *keyringlabel && !keyringpwd &&\n      !strcmp(keyringfile, CURL_CA_BUNDLE)) {\n    /* Try application identifier mode. */\n    init_environment(data, &envir, keyringlabel, (const char *) NULL,\n                     (const char *) NULL, (const char *) NULL);\n  }\n\n  if(!envir) {\n    /* Use keyring mode. */\n    result = init_environment(data, &envir, (const char *) NULL,\n                              keyringfile, keyringlabel, keyringpwd);\n    if(result)\n      return result;\n  }\n\n  /* Create secure session. */\n  result = gskit_status(data, gsk_secure_soc_open(envir, &BACKEND->handle),\n                        \"gsk_secure_soc_open()\", CURLE_SSL_CONNECT_ERROR);\n  gsk_environment_close(&envir);\n  if(result)\n    return result;\n\n#ifndef CURL_DISABLE_PROXY\n  /* Establish a pipelining socket pair for SSL over SSL. */\n  if(conn->proxy_ssl[sockindex].use) {\n    if(Curl_socketpair(0, 0, 0, sockpair))\n      return CURLE_SSL_CONNECT_ERROR;\n    BACKEND->localfd = sockpair[0];\n    BACKEND->remotefd = sockpair[1];\n    setsockopt(BACKEND->localfd, SOL_SOCKET, SO_RCVBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->remotefd, SOL_SOCKET, SO_RCVBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->localfd, SOL_SOCKET, SO_SNDBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->remotefd, SOL_SOCKET, SO_SNDBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    curlx_nonblock(BACKEND->localfd, TRUE);\n    curlx_nonblock(BACKEND->remotefd, TRUE);\n  }\n#endif\n\n  /* Determine which SSL/TLS version should be enabled. */\n  sni = hostname;\n  switch(ssl_version) {\n  case CURL_SSLVERSION_SSLv2:\n    protoflags = CURL_GSKPROTO_SSLV2_MASK;\n    sni = NULL;\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    protoflags = CURL_GSKPROTO_SSLV3_MASK;\n    sni = NULL;\n    break;\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    protoflags = CURL_GSKPROTO_TLSV10_MASK |\n                 CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK;\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    result = set_ssl_version_min_max(&protoflags, data);\n    if(result != CURLE_OK)\n      return result;\n    break;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* Process SNI. Ignore if not supported (on OS400 < V7R1). */\n  if(sni) {\n    result = set_buffer(data, BACKEND->handle,\n                        GSK_SSL_EXTN_SERVERNAME_REQUEST, sni, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL)\n      result = CURLE_OK;\n  }\n\n  /* Set session parameters. */\n  if(!result) {\n    /* Compute the handshake timeout. Since GSKit granularity is 1 second,\n       we round up the required value. */\n    timediff_t timeout = Curl_timeleft(data, NULL, TRUE);\n    if(timeout < 0)\n      result = CURLE_OPERATION_TIMEDOUT;\n    else\n      result = set_numeric(data, BACKEND->handle, GSK_HANDSHAKE_TIMEOUT,\n                           (timeout + 999) / 1000);\n  }\n  if(!result)\n    result = set_numeric(data, BACKEND->handle, GSK_OS400_READ_TIMEOUT, 1);\n  if(!result)\n#ifndef CURL_DISABLE_PROXY\n    result = set_numeric(data, BACKEND->handle, GSK_FD, BACKEND->localfd >= 0?\n                         BACKEND->localfd: conn->sock[sockindex]);\n#else\n    result = set_numeric(data, BACKEND->handle, GSK_FD,\n                         conn->sock[sockindex]);\n#endif\n  if(!result)\n    result = set_ciphers(data, BACKEND->handle, &protoflags);\n  if(!protoflags) {\n    failf(data, \"No SSL protocol/cipher combination enabled\");\n    result = CURLE_SSL_CIPHER;\n  }\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_SSLV2,\n                      (protoflags & CURL_GSKPROTO_SSLV2_MASK)?\n                      GSK_PROTOCOL_SSLV2_ON: GSK_PROTOCOL_SSLV2_OFF, FALSE);\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_SSLV3,\n                      (protoflags & CURL_GSKPROTO_SSLV3_MASK)?\n                      GSK_PROTOCOL_SSLV3_ON: GSK_PROTOCOL_SSLV3_OFF, FALSE);\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV1,\n                      (protoflags & CURL_GSKPROTO_TLSV10_MASK)?\n                      GSK_PROTOCOL_TLSV1_ON: GSK_PROTOCOL_TLSV1_OFF, FALSE);\n  if(!result) {\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV11,\n                      (protoflags & CURL_GSKPROTO_TLSV11_MASK)?\n                      GSK_TRUE: GSK_FALSE, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(protoflags == CURL_GSKPROTO_TLSV11_MASK) {\n        failf(data, \"TLS 1.1 not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result) {\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV12,\n                      (protoflags & CURL_GSKPROTO_TLSV12_MASK)?\n                      GSK_TRUE: GSK_FALSE, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(protoflags == CURL_GSKPROTO_TLSV12_MASK) {\n        failf(data, \"TLS 1.2 not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_SERVER_AUTH_TYPE,\n                      verifypeer? GSK_SERVER_AUTH_FULL:\n                      GSK_SERVER_AUTH_PASSTHRU, FALSE);\n\n  if(!result) {\n    /* Start handshake. Try asynchronous first. */\n    memset(&commarea, 0, sizeof(commarea));\n    BACKEND->iocport = QsoCreateIOCompletionPort();\n    if(BACKEND->iocport != -1) {\n      result = gskit_status(data,\n                            gsk_secure_soc_startInit(BACKEND->handle,\n                                                     BACKEND->iocport,\n                                                     &commarea),\n                            \"gsk_secure_soc_startInit()\",\n                            CURLE_SSL_CONNECT_ERROR);\n      if(!result) {\n        connssl->connecting_state = ssl_connect_2;\n        return CURLE_OK;\n      }\n      else\n        close_async_handshake(connssl);\n    }\n    else if(errno != ENOBUFS)\n      result = gskit_status(data, GSK_ERROR_IO,\n                            \"QsoCreateIOCompletionPort()\", 0);\n#ifndef CURL_DISABLE_PROXY\n    else if(conn->proxy_ssl[sockindex].use) {\n      /* Cannot pipeline while handshaking synchronously. */\n      result = CURLE_SSL_CONNECT_ERROR;\n    }\n#endif\n    else {\n      /* No more completion port available. Use synchronous IO. */\n      result = gskit_status(data, gsk_secure_soc_init(BACKEND->handle),\n                            \"gsk_secure_soc_init()\", CURLE_SSL_CONNECT_ERROR);\n      if(!result) {\n        connssl->connecting_state = ssl_connect_3;\n        return CURLE_OK;\n      }\n    }\n  }\n\n  /* Error: rollback. */\n  close_one(connssl, data, conn, sockindex);\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_step2(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    bool nonblocking)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  Qso_OverlappedIO_t cstat;\n  struct timeval stmv;\n  CURLcode result;\n\n  /* Poll or wait for end of SSL asynchronous handshake. */\n\n  for(;;) {\n    timediff_t timeout_ms = nonblocking? 0: Curl_timeleft(data, NULL, TRUE);\n    if(timeout_ms < 0)\n      timeout_ms = 0;\n    stmv.tv_sec = timeout_ms / 1000;\n    stmv.tv_usec = (timeout_ms - stmv.tv_sec * 1000) * 1000;\n    switch(QsoWaitForIOCompletion(BACKEND->iocport, &cstat, &stmv)) {\n    case 1:             /* Operation complete. */\n      break;\n    case -1:            /* An error occurred: handshake still in progress. */\n      if(errno == EINTR) {\n        if(nonblocking)\n          return CURLE_OK;\n        continue;       /* Retry. */\n      }\n      if(errno != ETIME) {\n        failf(data, \"QsoWaitForIOCompletion() I/O error: %s\", strerror(errno));\n        cancel_async_handshake(conn, sockindex);\n        close_async_handshake(connssl);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* FALL INTO... */\n    case 0:             /* Handshake in progress, timeout occurred. */\n      if(nonblocking)\n        return CURLE_OK;\n      cancel_async_handshake(conn, sockindex);\n      close_async_handshake(connssl);\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    break;\n  }\n  result = gskit_status(data, cstat.returnValue, \"SSL handshake\",\n                        CURLE_SSL_CONNECT_ERROR);\n  if(!result)\n    connssl->connecting_state = ssl_connect_3;\n  close_async_handshake(connssl);\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_step3(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  const gsk_cert_data_elem *cdev;\n  int cdec;\n  const gsk_cert_data_elem *p;\n  const char *cert = (const char *) NULL;\n  const char *certend;\n  const char *ptr;\n  CURLcode result;\n\n  /* SSL handshake done: gather certificate info and verify host. */\n\n  if(gskit_status(data, gsk_attribute_get_cert_info(BACKEND->handle,\n                                                    GSK_PARTNER_CERT_INFO,\n                                                    &cdev, &cdec),\n                  \"gsk_attribute_get_cert_info()\", CURLE_SSL_CONNECT_ERROR) ==\n     CURLE_OK) {\n    int i;\n\n    infof(data, \"Server certificate:\\n\");\n    p = cdev;\n    for(i = 0; i++ < cdec; p++)\n      switch(p->cert_data_id) {\n      case CERT_BODY_DER:\n        cert = p->cert_data_p;\n        certend = cert + cdev->cert_data_l;\n        break;\n      case CERT_DN_PRINTABLE:\n        infof(data, \"\\t subject: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_ISSUER_DN_PRINTABLE:\n        infof(data, \"\\t issuer: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_VALID_FROM:\n        infof(data, \"\\t start date: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_VALID_TO:\n        infof(data, \"\\t expire date: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n    }\n  }\n\n  /* Verify host. */\n  result = Curl_verifyhost(data, conn, cert, certend);\n  if(result)\n    return result;\n\n  /* The only place GSKit can get the whole CA chain is a validation\n     callback where no user data pointer is available. Therefore it's not\n     possible to copy this chain into our structures for CAINFO.\n     However the server certificate may be available, thus we can return\n     info about it. */\n  if(data->set.ssl.certinfo) {\n    result = Curl_ssl_init_certinfo(data, 1);\n    if(result)\n      return result;\n\n    if(cert) {\n      result = Curl_extract_certinfo(data, 0, cert, certend);\n      if(result)\n        return result;\n    }\n  }\n\n  /* Check pinned public key. */\n  ptr = SSL_PINNED_PUB_KEY();\n  if(!result && ptr) {\n    curl_X509certificate x509;\n    curl_asn1Element *p;\n\n    if(Curl_parseX509(&x509, cert, certend))\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    p = &x509.subjectPublicKeyInfo;\n    result = Curl_pin_peer_pubkey(data, ptr, p->header, p->end - p->header);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n  return CURLE_OK;\n}\n\n\nstatic CURLcode gskit_connect_common(struct Curl_easy *data,\n                                     struct connectdata *conn, int sockindex,\n                                     bool nonblocking, bool *done)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  timediff_t timeout_ms;\n  CURLcode result = CURLE_OK;\n\n  *done = connssl->state == ssl_connection_complete;\n  if(*done)\n    return CURLE_OK;\n\n  /* Step 1: create session, start handshake. */\n  if(connssl->connecting_state == ssl_connect_1) {\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      result = CURLE_OPERATION_TIMEDOUT;\n    }\n    else\n      result = gskit_connect_step1(data, conn, sockindex);\n  }\n\n  /* Handle handshake pipelining. */\n  if(!result)\n    if(pipe_ssloverssl(conn, sockindex, SOS_READ | SOS_WRITE) < 0)\n      result = CURLE_SSL_CONNECT_ERROR;\n\n  /* Step 2: check if handshake is over. */\n  if(!result && connssl->connecting_state == ssl_connect_2) {\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      result = CURLE_OPERATION_TIMEDOUT;\n    }\n    else\n      result = gskit_connect_step2(data, conn, sockindex, nonblocking);\n  }\n\n  /* Handle handshake pipelining. */\n  if(!result)\n    if(pipe_ssloverssl(conn, sockindex, SOS_READ | SOS_WRITE) < 0)\n      result = CURLE_SSL_CONNECT_ERROR;\n\n  /* Step 3: gather certificate info, verify host. */\n  if(!result && connssl->connecting_state == ssl_connect_3)\n    result = gskit_connect_step3(data, conn, sockindex);\n\n  if(result)\n    close_one(connssl, data, conn, sockindex);\n  else if(connssl->connecting_state == ssl_connect_done) {\n    connssl->state = ssl_connection_complete;\n    connssl->connecting_state = ssl_connect_1;\n    conn->recv[sockindex] = gskit_recv;\n    conn->send[sockindex] = gskit_send;\n    *done = TRUE;\n  }\n\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_nonblocking(struct Curl_easy *data,\n                                          struct connectdata *conn,\n                                          int sockindex, bool *done)\n{\n  CURLcode result;\n\n  result = gskit_connect_common(data, conn, sockindex, TRUE, done);\n  if(*done || result)\n    conn->ssl[sockindex].connecting_state = ssl_connect_1;\n  return result;\n}\n\n\nstatic CURLcode gskit_connect(struct Curl_easy *data,\n                              struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done;\n\n  conn->ssl[sockindex].connecting_state = ssl_connect_1;\n  result = gskit_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\n\nstatic void gskit_close(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  close_one(&conn->ssl[sockindex], data, conn, sockindex);\n#ifndef CURL_DISABLE_PROXY\n  close_one(&conn->proxy_ssl[sockindex], data, conn, sockindex);\n#endif\n}\n\n\nstatic int gskit_shutdown(struct Curl_easy *data,\n                          struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  int what;\n  int rc;\n  char buf[120];\n\n  if(!BACKEND->handle)\n    return 0;\n\n#ifndef CURL_DISABLE_FTP\n  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)\n    return 0;\n#endif\n\n  close_one(connssl, data, conn, sockindex);\n  rc = 0;\n  what = SOCKET_READABLE(conn->sock[sockindex],\n                         SSL_SHUTDOWN_TIMEOUT);\n\n  for(;;) {\n    ssize_t nread;\n\n    if(what < 0) {\n      /* anything that gets here is fatally bad */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      rc = -1;\n      break;\n    }\n\n    if(!what) {                                /* timeout */\n      failf(data, \"SSL shutdown timeout\");\n      break;\n    }\n\n    /* Something to read, let's do it and hope that it is the close\n       notify alert from the server. No way to gsk_secure_soc_read() now, so\n       use read(). */\n\n    nread = read(conn->sock[sockindex], buf, sizeof(buf));\n\n    if(nread < 0) {\n      failf(data, \"read: %s\", strerror(errno));\n      rc = -1;\n    }\n\n    if(nread <= 0)\n      break;\n\n    what = SOCKET_READABLE(conn->sock[sockindex], 0);\n  }\n\n  return rc;\n}\n\n\nstatic size_t gskit_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"GSKit\");\n}\n\n\nstatic int gskit_check_cxn(struct connectdata *cxn)\n{\n  struct ssl_connect_data *connssl = &cxn->ssl[FIRSTSOCKET];\n  int err;\n  int errlen;\n\n  /* The only thing that can be tested here is at the socket level. */\n\n  if(!BACKEND->handle)\n    return 0; /* connection has been closed */\n\n  err = 0;\n  errlen = sizeof(err);\n\n  if(getsockopt(cxn->sock[FIRSTSOCKET], SOL_SOCKET, SO_ERROR,\n                 (unsigned char *) &err, &errlen) ||\n     errlen != sizeof(err) || err)\n    return 0; /* connection has been closed */\n\n  return -1;  /* connection status unknown */\n}\n\nstatic void *gskit_get_internals(struct ssl_connect_data *connssl,\n                                 CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return BACKEND->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_gskit = {\n  { CURLSSLBACKEND_GSKIT, \"gskit\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  gskit_init,                     /* init */\n  gskit_cleanup,                  /* cleanup */\n  gskit_version,                  /* version */\n  gskit_check_cxn,                /* check_cxn */\n  gskit_shutdown,                 /* shutdown */\n  Curl_none_data_pending,         /* data_pending */\n  Curl_none_random,               /* random */\n  Curl_none_cert_status_request,  /* cert_status_request */\n  gskit_connect,                  /* connect */\n  gskit_connect_nonblocking,      /* connect_nonblocking */\n  gskit_get_internals,            /* get_internals */\n  gskit_close,                    /* close_one */\n  Curl_none_close_all,            /* close_all */\n  /* No session handling for GSKit */\n  Curl_none_session_free,         /* session_free */\n  Curl_none_set_engine,           /* set_engine */\n  Curl_none_set_engine_default,   /* set_engine_default */\n  Curl_none_engines_list,         /* engines_list */\n  Curl_none_false_start,          /* false_start */\n  NULL                            /* sha256sum */\n};\n\n#endif /* USE_GSKIT */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all GnuTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n * Note: don't use the GnuTLS' *_t variable type names in this source code,\n * since they were not present in 1.0.X.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_GNUTLS\n\n#include <gnutls/abstract.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <nettle/sha2.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"gtls.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"multiif.h\"\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n/* Enable GnuTLS debugging by defining GTLSDEBUG */\n/*#define GTLSDEBUG */\n\n#ifdef GTLSDEBUG\nstatic void tls_log_func(int level, const char *str)\n{\n    fprintf(stderr, \"|<%d>| %s\", level, str);\n}\n#endif\nstatic bool gtls_inited = FALSE;\n\n#if !defined(GNUTLS_VERSION_NUMBER) || (GNUTLS_VERSION_NUMBER < 0x03010a)\n#error \"too old GnuTLS version\"\n#endif\n\n# include <gnutls/ocsp.h>\n\nstruct ssl_backend_data {\n  gnutls_session_t session;\n  gnutls_certificate_credentials_t cred;\n#ifdef HAVE_GNUTLS_SRP\n  gnutls_srp_client_credentials_t srp_client_cred;\n#endif\n};\n\nstatic ssize_t gtls_push(void *s, const void *buf, size_t len)\n{\n  curl_socket_t sock = *(curl_socket_t *)s;\n  ssize_t ret = swrite(sock, buf, len);\n  return ret;\n}\n\nstatic ssize_t gtls_pull(void *s, void *buf, size_t len)\n{\n  curl_socket_t sock = *(curl_socket_t *)s;\n  ssize_t ret = sread(sock, buf, len);\n  return ret;\n}\n\nstatic ssize_t gtls_push_ssl(void *s, const void *buf, size_t len)\n{\n  return gnutls_record_send((gnutls_session_t) s, buf, len);\n}\n\nstatic ssize_t gtls_pull_ssl(void *s, void *buf, size_t len)\n{\n  return gnutls_record_recv((gnutls_session_t) s, buf, len);\n}\n\n/* gtls_init()\n *\n * Global GnuTLS init, called from Curl_ssl_init(). This calls functions that\n * are not thread-safe and thus this function itself is not thread-safe and\n * must only be called from within curl_global_init() to keep the thread\n * situation under control!\n */\nstatic int gtls_init(void)\n{\n  int ret = 1;\n  if(!gtls_inited) {\n    ret = gnutls_global_init()?0:1;\n#ifdef GTLSDEBUG\n    gnutls_global_set_log_function(tls_log_func);\n    gnutls_global_set_log_level(2);\n#endif\n    gtls_inited = TRUE;\n  }\n  return ret;\n}\n\nstatic void gtls_cleanup(void)\n{\n  if(gtls_inited) {\n    gnutls_global_deinit();\n    gtls_inited = FALSE;\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void showtime(struct Curl_easy *data,\n                     const char *text,\n                     time_t stamp)\n{\n  struct tm buffer;\n  const struct tm *tm = &buffer;\n  char str[96];\n  CURLcode result = Curl_gmtime(stamp, &buffer);\n  if(result)\n    return;\n\n  msnprintf(str,\n            sizeof(str),\n            \"\\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT\",\n            text,\n            Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],\n            tm->tm_mday,\n            Curl_month[tm->tm_mon],\n            tm->tm_year + 1900,\n            tm->tm_hour,\n            tm->tm_min,\n            tm->tm_sec);\n  infof(data, \"%s\\n\", str);\n}\n#endif\n\nstatic gnutls_datum_t load_file(const char *file)\n{\n  FILE *f;\n  gnutls_datum_t loaded_file = { NULL, 0 };\n  long filelen;\n  void *ptr;\n\n  f = fopen(file, \"rb\");\n  if(!f)\n    return loaded_file;\n  if(fseek(f, 0, SEEK_END) != 0\n     || (filelen = ftell(f)) < 0\n     || fseek(f, 0, SEEK_SET) != 0\n     || !(ptr = malloc((size_t)filelen)))\n    goto out;\n  if(fread(ptr, 1, (size_t)filelen, f) < (size_t)filelen) {\n    free(ptr);\n    goto out;\n  }\n\n  loaded_file.data = ptr;\n  loaded_file.size = (unsigned int)filelen;\nout:\n  fclose(f);\n  return loaded_file;\n}\n\nstatic void unload_file(gnutls_datum_t data)\n{\n  free(data.data);\n}\n\n\n/* this function does a SSL/TLS (re-)handshake */\nstatic CURLcode handshake(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          int sockindex,\n                          bool duringconnect,\n                          bool nonblocking)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  gnutls_session_t session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n\n  for(;;) {\n    timediff_t timeout_ms;\n    int rc;\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, duringconnect);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n      int what;\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:\n                               timeout_ms?timeout_ms:1000);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking)\n          return CURLE_OK;\n        else if(timeout_ms) {\n          /* timeout */\n          failf(data, \"SSL connection timeout at %ld\", (long)timeout_ms);\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    rc = gnutls_handshake(session);\n\n    if((rc == GNUTLS_E_AGAIN) || (rc == GNUTLS_E_INTERRUPTED)) {\n      connssl->connecting_state =\n        gnutls_record_get_direction(session)?\n        ssl_connect_2_writing:ssl_connect_2_reading;\n      continue;\n    }\n    else if((rc < 0) && !gnutls_error_is_fatal(rc)) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      infof(data, \"gnutls_handshake() warning: %s\\n\", strerr);\n      continue;\n    }\n    else if(rc < 0) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      failf(data, \"gnutls_handshake() failed: %s\", strerr);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* Reset our connect state machine */\n    connssl->connecting_state = ssl_connect_1;\n    return CURLE_OK;\n  }\n}\n\nstatic gnutls_x509_crt_fmt_t do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return GNUTLS_X509_FMT_DER;\n  return GNUTLS_X509_FMT_PEM; /* default to PEM */\n}\n\n#define GNUTLS_CIPHERS \"NORMAL:-ARCFOUR-128:-CTYPE-ALL:+CTYPE-X509\"\n/* If GnuTLS was compiled without support for SRP it will error out if SRP is\n   requested in the priority string, so treat it specially\n */\n#define GNUTLS_SRP \"+SRP\"\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data,\n                        const char **prioritylist,\n                        const char *tls13support)\n{\n  struct connectdata *conn = data->conn;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  if((ssl_version == CURL_SSLVERSION_DEFAULT) ||\n     (ssl_version == CURL_SSLVERSION_TLSv1))\n    ssl_version = CURL_SSLVERSION_TLSv1_0;\n  if(ssl_version_max == CURL_SSLVERSION_MAX_NONE)\n    ssl_version_max = CURL_SSLVERSION_MAX_DEFAULT;\n  if(!tls13support) {\n    /* If the running GnuTLS doesn't support TLS 1.3, we must not specify a\n       prioritylist involving that since it will make GnuTLS return an en\n       error back at us */\n    if((ssl_version_max == CURL_SSLVERSION_MAX_TLSv1_3) ||\n       (ssl_version_max == CURL_SSLVERSION_MAX_DEFAULT)) {\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    }\n  }\n\n  switch(ssl_version | ssl_version_max) {\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_0:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1:+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1:+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1:+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1:+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  }\n\n  failf(data, \"GnuTLS: cannot set ssl protocol\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic CURLcode\ngtls_connect_step1(struct Curl_easy *data,\n                   struct connectdata *conn,\n                   int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  unsigned int init_flags;\n  gnutls_session_t session;\n  int rc;\n  bool sni = TRUE; /* default is SNI enabled */\n  void *transport_ptr = NULL;\n  gnutls_push_func gnutls_transport_push = NULL;\n  gnutls_pull_func gnutls_transport_pull = NULL;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  const char *prioritylist;\n  const char *err = NULL;\n  const char * const hostname = SSL_HOST_NAME();\n  long * const certverifyresult = &SSL_SET_OPTION_LVALUE(certverifyresult);\n  const char *tls13support;\n\n  if(connssl->state == ssl_connection_complete)\n    /* to make us tolerant against being called more than once for the\n       same connection */\n    return CURLE_OK;\n\n  if(!gtls_inited)\n    gtls_init();\n\n  /* Initialize certverifyresult to OK */\n  *certverifyresult = 0;\n\n  if(SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"GnuTLS does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n  /* allocate a cred struct */\n  rc = gnutls_certificate_allocate_credentials(&backend->cred);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_cert_all_cred() failed: %s\", gnutls_strerror(rc));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    infof(data, \"Using TLS-SRP username: %s\\n\", SSL_SET_OPTION(username));\n\n    rc = gnutls_srp_allocate_client_credentials(\n           &backend->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_allocate_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    rc = gnutls_srp_set_client_credentials(backend->srp_client_cred,\n                                           SSL_SET_OPTION(username),\n                                           SSL_SET_OPTION(password));\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_set_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n  }\n#endif\n\n  if(SSL_CONN_CONFIG(CAfile)) {\n    /* set the trusted CA cert bundle file */\n    gnutls_certificate_set_verify_flags(backend->cred,\n                                        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n\n    rc = gnutls_certificate_set_x509_trust_file(backend->cred,\n                                                SSL_CONN_CONFIG(CAfile),\n                                                GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      infof(data, \"error reading ca cert file %s (%s)\\n\",\n            SSL_CONN_CONFIG(CAfile), gnutls_strerror(rc));\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        *certverifyresult = rc;\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n    }\n    else\n      infof(data, \"found %d certificates in %s\\n\", rc,\n            SSL_CONN_CONFIG(CAfile));\n  }\n\n  if(SSL_CONN_CONFIG(CApath)) {\n    /* set the trusted CA cert directory */\n    rc = gnutls_certificate_set_x509_trust_dir(backend->cred,\n                                               SSL_CONN_CONFIG(CApath),\n                                               GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      infof(data, \"error reading ca cert file %s (%s)\\n\",\n            SSL_CONN_CONFIG(CApath), gnutls_strerror(rc));\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        *certverifyresult = rc;\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n    }\n    else\n      infof(data, \"found %d certificates in %s\\n\",\n            rc, SSL_CONN_CONFIG(CApath));\n  }\n\n#ifdef CURL_CA_FALLBACK\n  /* use system ca certificate store as fallback */\n  if(SSL_CONN_CONFIG(verifypeer) &&\n     !(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(CApath))) {\n    gnutls_certificate_set_x509_system_trust(backend->cred);\n  }\n#endif\n\n  if(SSL_SET_OPTION(CRLfile)) {\n    /* set the CRL list file */\n    rc = gnutls_certificate_set_x509_crl_file(backend->cred,\n                                              SSL_SET_OPTION(CRLfile),\n                                              GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      failf(data, \"error reading crl file %s (%s)\",\n            SSL_SET_OPTION(CRLfile), gnutls_strerror(rc));\n      return CURLE_SSL_CRL_BADFILE;\n    }\n    else\n      infof(data, \"found %d CRL in %s\\n\",\n            rc, SSL_SET_OPTION(CRLfile));\n  }\n\n  /* Initialize TLS session as a client */\n  init_flags = GNUTLS_CLIENT;\n\n#if defined(GNUTLS_FORCE_CLIENT_CERT)\n  init_flags |= GNUTLS_FORCE_CLIENT_CERT;\n#endif\n\n#if defined(GNUTLS_NO_TICKETS)\n  /* Disable TLS session tickets */\n  init_flags |= GNUTLS_NO_TICKETS;\n#endif\n\n  rc = gnutls_init(&backend->session, init_flags);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_init() failed: %d\", rc);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* convenient assign */\n  session = backend->session;\n\n  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&\n#ifdef ENABLE_IPV6\n     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&\n#endif\n     sni &&\n     (gnutls_server_name_set(session, GNUTLS_NAME_DNS, hostname,\n                             strlen(hostname)) < 0))\n    infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n          \"TLS extension\\n\");\n\n  /* Use default priorities */\n  rc = gnutls_set_default_priority(session);\n  if(rc != GNUTLS_E_SUCCESS)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* \"In GnuTLS 3.6.5, TLS 1.3 is enabled by default\" */\n  tls13support = gnutls_check_version(\"3.6.5\");\n\n  /* Ensure +SRP comes at the *end* of all relevant strings so that it can be\n   * removed if a run-time error indicates that SRP is not supported by this\n   * GnuTLS version */\n  switch(SSL_CONN_CONFIG(version)) {\n    case CURL_SSLVERSION_TLSv1_3:\n      if(!tls13support) {\n        failf(data, \"This GnuTLS installation does not support TLS 1.3\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2: {\n      CURLcode result = set_ssl_version_min_max(data, &prioritylist,\n                                                tls13support);\n      if(result)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv2:\n    case CURL_SSLVERSION_SSLv3:\n    default:\n      failf(data, \"GnuTLS does not support SSLv2 or SSLv3\");\n      return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  /* Only add SRP to the cipher list if SRP is requested. Otherwise\n   * GnuTLS will disable TLS 1.3 support. */\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    size_t len = strlen(prioritylist);\n\n    char *prioritysrp = malloc(len + sizeof(GNUTLS_SRP) + 1);\n    if(!prioritysrp)\n      return CURLE_OUT_OF_MEMORY;\n    strcpy(prioritysrp, prioritylist);\n    strcpy(prioritysrp + len, \":\" GNUTLS_SRP);\n    rc = gnutls_priority_set_direct(session, prioritysrp, &err);\n    free(prioritysrp);\n\n    if((rc == GNUTLS_E_INVALID_REQUEST) && err) {\n      infof(data, \"This GnuTLS does not support SRP\\n\");\n    }\n  }\n  else {\n#endif\n    rc = gnutls_priority_set_direct(session, prioritylist, &err);\n#ifdef HAVE_GNUTLS_SRP\n  }\n#endif\n\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"Error %d setting GnuTLS cipher list starting with %s\",\n          rc, err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    gnutls_datum_t protocols[2];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n       ) {\n      protocols[cur].data = (unsigned char *)ALPN_H2;\n      protocols[cur].size = ALPN_H2_LENGTH;\n      cur++;\n      infof(data, \"ALPN, offering %.*s\\n\", ALPN_H2_LENGTH, ALPN_H2);\n    }\n#endif\n\n    protocols[cur].data = (unsigned char *)ALPN_HTTP_1_1;\n    protocols[cur].size = ALPN_HTTP_1_1_LENGTH;\n    cur++;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    gnutls_alpn_set_protocols(session, protocols, cur, 0);\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert)) {\n    if(SSL_SET_OPTION(key_passwd)) {\n      const unsigned int supported_key_encryption_algorithms =\n        GNUTLS_PKCS_USE_PKCS12_3DES | GNUTLS_PKCS_USE_PKCS12_ARCFOUR |\n        GNUTLS_PKCS_USE_PKCS12_RC2_40 | GNUTLS_PKCS_USE_PBES2_3DES |\n        GNUTLS_PKCS_USE_PBES2_AES_128 | GNUTLS_PKCS_USE_PBES2_AES_192 |\n        GNUTLS_PKCS_USE_PBES2_AES_256;\n      rc = gnutls_certificate_set_x509_key_file2(\n           backend->cred,\n           SSL_SET_OPTION(primary.clientcert),\n           SSL_SET_OPTION(key) ?\n           SSL_SET_OPTION(key) : SSL_SET_OPTION(primary.clientcert),\n           do_file_type(SSL_SET_OPTION(cert_type)),\n           SSL_SET_OPTION(key_passwd),\n           supported_key_encryption_algorithms);\n      if(rc != GNUTLS_E_SUCCESS) {\n        failf(data,\n              \"error reading X.509 potentially-encrypted key file: %s\",\n              gnutls_strerror(rc));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    else {\n      if(gnutls_certificate_set_x509_key_file(\n           backend->cred,\n           SSL_SET_OPTION(primary.clientcert),\n           SSL_SET_OPTION(key) ?\n           SSL_SET_OPTION(key) : SSL_SET_OPTION(primary.clientcert),\n           do_file_type(SSL_SET_OPTION(cert_type)) ) !=\n         GNUTLS_E_SUCCESS) {\n        failf(data, \"error reading X.509 key or certificate file\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  /* put the credentials to the current session */\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    rc = gnutls_credentials_set(session, GNUTLS_CRD_SRP,\n                                backend->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else\n#endif\n  {\n    rc = gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,\n                                backend->cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    transport_ptr = conn->proxy_ssl[sockindex].backend->session;\n    gnutls_transport_push = gtls_push_ssl;\n    gnutls_transport_pull = gtls_pull_ssl;\n  }\n  else\n#endif\n  {\n    /* file descriptor for the socket */\n    transport_ptr = &conn->sock[sockindex];\n    gnutls_transport_push = gtls_push;\n    gnutls_transport_pull = gtls_pull;\n  }\n\n  /* set the connection handle */\n  gnutls_transport_set_ptr(session, transport_ptr);\n\n  /* register callback functions to send and receive data. */\n  gnutls_transport_set_push_function(session, gnutls_transport_push);\n  gnutls_transport_set_pull_function(session, gnutls_transport_pull);\n\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    rc = gnutls_ocsp_status_request_enable_client(session, NULL, 0, NULL);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_ocsp_status_request_enable_client() failed: %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* This might be a reconnect, so we check for a session ID in the cache\n     to speed up things */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid;\n    size_t ssl_idsize;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, &ssl_idsize, sockindex)) {\n      /* we got a session id, use it! */\n      gnutls_session_set_data(session, ssl_sessionid, ssl_idsize);\n\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    gnutls_x509_crt_t cert,\n                                    const char *pinnedpubkey)\n{\n  /* Scratch */\n  size_t len1 = 0, len2 = 0;\n  unsigned char *buff1 = NULL;\n\n  gnutls_pubkey_t key = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(NULL == pinnedpubkey)\n    return CURLE_OK;\n\n  if(NULL == cert)\n    return result;\n\n  do {\n    int ret;\n\n    /* Begin Gyrations to get the public key     */\n    gnutls_pubkey_init(&key);\n\n    ret = gnutls_pubkey_import_x509(key, cert, 0);\n    if(ret < 0)\n      break; /* failed */\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, NULL, &len1);\n    if(ret != GNUTLS_E_SHORT_MEMORY_BUFFER || len1 == 0)\n      break; /* failed */\n\n    buff1 = malloc(len1);\n    if(NULL == buff1)\n      break; /* failed */\n\n    len2 = len1;\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, buff1, &len2);\n    if(ret < 0 || len1 != len2)\n      break; /* failed */\n\n    /* End Gyrations */\n\n    /* The one good exit point */\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, buff1, len1);\n  } while(0);\n\n  if(NULL != key)\n    gnutls_pubkey_deinit(key);\n\n  Curl_safefree(buff1);\n\n  return result;\n}\n\nstatic Curl_recv gtls_recv;\nstatic Curl_send gtls_send;\n\nstatic CURLcode\ngtls_connect_step3(struct Curl_easy *data,\n                   struct connectdata *conn,\n                   int sockindex)\n{\n  unsigned int cert_list_size;\n  const gnutls_datum_t *chainp;\n  unsigned int verify_status = 0;\n  gnutls_x509_crt_t x509_cert, x509_issuer;\n  gnutls_datum_t issuerp;\n  gnutls_datum_t certfields;\n  char certname[65] = \"\"; /* limited to 64 chars by ASN.1 */\n  size_t size;\n  time_t certclock;\n  const char *ptr;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  gnutls_session_t session = backend->session;\n  int rc;\n  gnutls_datum_t proto;\n  CURLcode result = CURLE_OK;\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  unsigned int algo;\n  unsigned int bits;\n  gnutls_protocol_t version = gnutls_protocol_get_version(session);\n#endif\n  const char * const hostname = SSL_HOST_NAME();\n  long * const certverifyresult = &SSL_SET_OPTION_LVALUE(certverifyresult);\n\n  /* the name of the cipher suite used, e.g. ECDHE_RSA_AES_256_GCM_SHA384. */\n  ptr = gnutls_cipher_suite_get_name(gnutls_kx_get(session),\n                                     gnutls_cipher_get(session),\n                                     gnutls_mac_get(session));\n\n  infof(data, \"SSL connection using %s / %s\\n\",\n        gnutls_protocol_get_name(version), ptr);\n\n  /* This function will return the peer's raw certificate (chain) as sent by\n     the peer. These certificates are in raw format (DER encoded for\n     X.509). In case of a X.509 then a certificate list may be present. The\n     first certificate in the list is the peer's certificate, following the\n     issuer's certificate, then the issuer's issuer etc. */\n\n  chainp = gnutls_certificate_get_peers(session, &cert_list_size);\n  if(!chainp) {\n    if(SSL_CONN_CONFIG(verifypeer) ||\n       SSL_CONN_CONFIG(verifyhost) ||\n       SSL_SET_OPTION(issuercert)) {\n#ifdef HAVE_GNUTLS_SRP\n      if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n         && SSL_SET_OPTION(username) != NULL\n         && !SSL_CONN_CONFIG(verifypeer)\n         && gnutls_cipher_get(session)) {\n        /* no peer cert, but auth is ok if we have SRP user and cipher and no\n           peer verify */\n      }\n      else {\n#endif\n        failf(data, \"failed to get server cert\");\n        *certverifyresult = GNUTLS_E_NO_CERTIFICATE_FOUND;\n        return CURLE_PEER_FAILED_VERIFICATION;\n#ifdef HAVE_GNUTLS_SRP\n      }\n#endif\n    }\n    infof(data, \"\\t common name: WARNING couldn't obtain\\n\");\n  }\n\n  if(data->set.ssl.certinfo && chainp) {\n    unsigned int i;\n\n    result = Curl_ssl_init_certinfo(data, cert_list_size);\n    if(result)\n      return result;\n\n    for(i = 0; i < cert_list_size; i++) {\n      const char *beg = (const char *) chainp[i].data;\n      const char *end = beg + chainp[i].size;\n\n      result = Curl_extract_certinfo(data, i, beg, end);\n      if(result)\n        return result;\n    }\n  }\n\n  if(SSL_CONN_CONFIG(verifypeer)) {\n    /* This function will try to verify the peer's certificate and return its\n       status (trusted, invalid etc.). The value of status should be one or\n       more of the gnutls_certificate_status_t enumerated elements bitwise\n       or'd. To avoid denial of service attacks some default upper limits\n       regarding the certificate key size and chain size are set. To override\n       them use gnutls_certificate_set_verify_limits(). */\n\n    rc = gnutls_certificate_verify_peers2(session, &verify_status);\n    if(rc < 0) {\n      failf(data, \"server cert verify failed: %d\", rc);\n      *certverifyresult = rc;\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    *certverifyresult = verify_status;\n\n    /* verify_status is a bitmask of gnutls_certificate_status bits */\n    if(verify_status & GNUTLS_CERT_INVALID) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate verification failed. CAfile: %s \"\n              \"CRLfile: %s\", SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile):\n              \"none\",\n              SSL_SET_OPTION(CRLfile)?SSL_SET_OPTION(CRLfile):\"none\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate verification FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate verification OK\\n\");\n  }\n  else\n    infof(data, \"\\t server certificate verification SKIPPED\\n\");\n\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    if(gnutls_ocsp_status_request_is_checked(session, 0) == 0) {\n      gnutls_datum_t status_request;\n      gnutls_ocsp_resp_t ocsp_resp;\n\n      gnutls_ocsp_cert_status_t status;\n      gnutls_x509_crl_reason_t reason;\n\n      rc = gnutls_ocsp_status_request_get(session, &status_request);\n\n      infof(data, \"\\t server certificate status verification FAILED\\n\");\n\n      if(rc == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n        failf(data, \"No OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      gnutls_ocsp_resp_init(&ocsp_resp);\n\n      rc = gnutls_ocsp_resp_import(ocsp_resp, &status_request);\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      (void)gnutls_ocsp_resp_get_single(ocsp_resp, 0, NULL, NULL, NULL, NULL,\n                                        &status, NULL, NULL, NULL, &reason);\n\n      switch(status) {\n      case GNUTLS_OCSP_CERT_GOOD:\n        break;\n\n      case GNUTLS_OCSP_CERT_REVOKED: {\n        const char *crl_reason;\n\n        switch(reason) {\n          default:\n          case GNUTLS_X509_CRLREASON_UNSPECIFIED:\n            crl_reason = \"unspecified reason\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_KEYCOMPROMISE:\n            crl_reason = \"private key compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CACOMPROMISE:\n            crl_reason = \"CA compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AFFILIATIONCHANGED:\n            crl_reason = \"affiliation has changed\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_SUPERSEDED:\n            crl_reason = \"certificate superseded\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CESSATIONOFOPERATION:\n            crl_reason = \"operation has ceased\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CERTIFICATEHOLD:\n            crl_reason = \"certificate is on hold\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_REMOVEFROMCRL:\n            crl_reason = \"will be removed from delta CRL\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_PRIVILEGEWITHDRAWN:\n            crl_reason = \"privilege withdrawn\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AACOMPROMISE:\n            crl_reason = \"AA compromised\";\n            break;\n        }\n\n        failf(data, \"Server certificate was revoked: %s\", crl_reason);\n        break;\n      }\n\n      default:\n      case GNUTLS_OCSP_CERT_UNKNOWN:\n        failf(data, \"Server certificate status is unknown\");\n        break;\n      }\n\n      gnutls_ocsp_resp_deinit(ocsp_resp);\n\n      return CURLE_SSL_INVALIDCERTSTATUS;\n    }\n    else\n      infof(data, \"\\t server certificate status verification OK\\n\");\n  }\n  else\n    infof(data, \"\\t server certificate status verification SKIPPED\\n\");\n\n  /* initialize an X.509 certificate structure. */\n  gnutls_x509_crt_init(&x509_cert);\n\n  if(chainp)\n    /* convert the given DER or PEM encoded Certificate to the native\n       gnutls_x509_crt_t format */\n    gnutls_x509_crt_import(x509_cert, chainp, GNUTLS_X509_FMT_DER);\n\n  if(SSL_SET_OPTION(issuercert)) {\n    gnutls_x509_crt_init(&x509_issuer);\n    issuerp = load_file(SSL_SET_OPTION(issuercert));\n    gnutls_x509_crt_import(x509_issuer, &issuerp, GNUTLS_X509_FMT_PEM);\n    rc = gnutls_x509_crt_check_issuer(x509_cert, x509_issuer);\n    gnutls_x509_crt_deinit(x509_issuer);\n    unload_file(issuerp);\n    if(rc <= 0) {\n      failf(data, \"server certificate issuer check failed (IssuerCert: %s)\",\n            SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"none\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_ISSUER_ERROR;\n    }\n    infof(data, \"\\t server certificate issuer check OK (Issuer Cert: %s)\\n\",\n          SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"none\");\n  }\n\n  size = sizeof(certname);\n  rc = gnutls_x509_crt_get_dn_by_oid(x509_cert, GNUTLS_OID_X520_COMMON_NAME,\n                                     0, /* the first and only one */\n                                     FALSE,\n                                     certname,\n                                     &size);\n  if(rc) {\n    infof(data, \"error fetching CN from cert:%s\\n\",\n          gnutls_strerror(rc));\n  }\n\n  /* This function will check if the given certificate's subject matches the\n     given hostname. This is a basic implementation of the matching described\n     in RFC2818 (HTTPS), which takes into account wildcards, and the subject\n     alternative name PKIX extension. Returns non zero on success, and zero on\n     failure. */\n  rc = gnutls_x509_crt_check_hostname(x509_cert, hostname);\n#if GNUTLS_VERSION_NUMBER < 0x030306\n  /* Before 3.3.6, gnutls_x509_crt_check_hostname() didn't check IP\n     addresses. */\n  if(!rc) {\n#ifdef ENABLE_IPV6\n    #define use_addr in6_addr\n#else\n    #define use_addr in_addr\n#endif\n    unsigned char addrbuf[sizeof(struct use_addr)];\n    size_t addrlen = 0;\n\n    if(Curl_inet_pton(AF_INET, hostname, addrbuf) > 0)\n      addrlen = 4;\n#ifdef ENABLE_IPV6\n    else if(Curl_inet_pton(AF_INET6, hostname, addrbuf) > 0)\n      addrlen = 16;\n#endif\n\n    if(addrlen) {\n      unsigned char certaddr[sizeof(struct use_addr)];\n      int i;\n\n      for(i = 0; ; i++) {\n        size_t certaddrlen = sizeof(certaddr);\n        int ret = gnutls_x509_crt_get_subject_alt_name(x509_cert, i, certaddr,\n                                                       &certaddrlen, NULL);\n        /* If this happens, it wasn't an IP address. */\n        if(ret == GNUTLS_E_SHORT_MEMORY_BUFFER)\n          continue;\n        if(ret < 0)\n          break;\n        if(ret != GNUTLS_SAN_IPADDRESS)\n          continue;\n        if(certaddrlen == addrlen && !memcmp(addrbuf, certaddr, addrlen)) {\n          rc = 1;\n          break;\n        }\n      }\n    }\n  }\n#endif\n  if(!rc) {\n    if(SSL_CONN_CONFIG(verifyhost)) {\n      failf(data, \"SSL: certificate subject name (%s) does not match \"\n            \"target host name '%s'\", certname, SSL_HOST_DISPNAME());\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else\n      infof(data, \"\\t common name: %s (does not match '%s')\\n\",\n            certname, SSL_HOST_DISPNAME());\n  }\n  else\n    infof(data, \"\\t common name: %s (matched)\\n\", certname);\n\n  /* Check for time-based validity */\n  certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(SSL_CONN_CONFIG(verifypeer)) {\n      failf(data, \"server cert expiration date verify failed\");\n      *certverifyresult = GNUTLS_CERT_EXPIRED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"\\t server certificate expiration date verify FAILED\\n\");\n  }\n  else {\n    if(certclock < time(NULL)) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate expiration date has passed.\");\n        *certverifyresult = GNUTLS_CERT_EXPIRED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate expiration date FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate expiration date OK\\n\");\n  }\n\n  certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(SSL_CONN_CONFIG(verifypeer)) {\n      failf(data, \"server cert activation date verify failed\");\n      *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"\\t server certificate activation date verify FAILED\\n\");\n  }\n  else {\n    if(certclock > time(NULL)) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate not activated yet.\");\n        *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate activation date FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate activation date OK\\n\");\n  }\n\n  ptr = SSL_PINNED_PUB_KEY();\n  if(ptr) {\n    result = pkp_pin_peer_pubkey(data, x509_cert, ptr);\n    if(result != CURLE_OK) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return result;\n    }\n  }\n\n  /* Show:\n\n  - subject\n  - start date\n  - expire date\n  - common name\n  - issuer\n\n  */\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  /* public key algorithm's parameters */\n  algo = gnutls_x509_crt_get_pk_algorithm(x509_cert, &bits);\n  infof(data, \"\\t certificate public key: %s\\n\",\n        gnutls_pk_algorithm_get_name(algo));\n\n  /* version of the X.509 certificate. */\n  infof(data, \"\\t certificate version: #%d\\n\",\n        gnutls_x509_crt_get_version(x509_cert));\n\n\n  rc = gnutls_x509_crt_get_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate name\\n\");\n  else {\n    infof(data, \"\\t subject: %s\\n\", certfields.data);\n\n    certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n    showtime(data, \"start date\", certclock);\n\n    certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n    showtime(data, \"expire date\", certclock);\n\n    gnutls_free(certfields.data);\n  }\n\n  rc = gnutls_x509_crt_get_issuer_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate issuer\\n\");\n  else {\n    infof(data, \"\\t issuer: %s\\n\", certfields.data);\n\n    gnutls_free(certfields.data);\n  }\n#endif\n\n  gnutls_x509_crt_deinit(x509_cert);\n\n  if(conn->bits.tls_enable_alpn) {\n    rc = gnutls_alpn_get_selected_protocol(session, &proto);\n    if(rc == 0) {\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", proto.size,\n          proto.data);\n\n#ifdef USE_HTTP2\n      if(proto.size == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, proto.data,\n                 ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n      if(proto.size == ALPN_HTTP_1_1_LENGTH &&\n         !memcmp(ALPN_HTTP_1_1, proto.data, ALPN_HTTP_1_1_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_1_1;\n      }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n\n  conn->ssl[sockindex].state = ssl_connection_complete;\n  conn->recv[sockindex] = gtls_recv;\n  conn->send[sockindex] = gtls_send;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    /* we always unconditionally get the session id here, as even if we\n       already got it from the cache and asked to use it in the connection, it\n       might've been rejected and then a new one is in use now and we need to\n       detect that. */\n    void *connect_sessionid;\n    size_t connect_idsize = 0;\n\n    /* get the session ID data size */\n    gnutls_session_get_data(session, NULL, &connect_idsize);\n    connect_sessionid = malloc(connect_idsize); /* get a buffer for it */\n\n    if(connect_sessionid) {\n      bool incache;\n      void *ssl_sessionid;\n\n      /* extract session ID to the allocated buffer */\n      gnutls_session_get_data(session, connect_sessionid, &connect_idsize);\n\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(data, conn,\n                                        SSL_IS_PROXY() ? TRUE : FALSE,\n                                        &ssl_sessionid, NULL, sockindex));\n      if(incache) {\n        /* there was one before in the cache, so instead of risking that the\n           previous one was rejected, we just kill that and store the new */\n        Curl_ssl_delsessionid(data, ssl_sessionid);\n      }\n\n      /* store this session id */\n      result = Curl_ssl_addsessionid(data, conn,\n                                     SSL_IS_PROXY() ? TRUE : FALSE,\n                                     connect_sessionid, connect_idsize,\n                                     sockindex);\n      Curl_ssl_sessionid_unlock(data);\n      if(result) {\n        free(connect_sessionid);\n        result = CURLE_OUT_OF_MEMORY;\n      }\n    }\n    else\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  return result;\n}\n\n\n/*\n * This function is called after the TCP connect has completed. Setup the TLS\n * layer and do all necessary magic.\n */\n/* We use connssl->connecting_state to keep track of the connection status;\n   there are three states: 'ssl_connect_1' (not started yet or complete),\n   'ssl_connect_2_reading' (waiting for data from server), and\n   'ssl_connect_2_writing' (waiting to be able to write).\n */\nstatic CURLcode\ngtls_connect_common(struct Curl_easy *data,\n                    struct connectdata *conn,\n                    int sockindex,\n                    bool nonblocking,\n                    bool *done)\n{\n  int rc;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  /* Initiate the connection, if not already done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    rc = gtls_connect_step1(data, conn, sockindex);\n    if(rc)\n      return rc;\n  }\n\n  rc = handshake(data, conn, sockindex, TRUE, nonblocking);\n  if(rc)\n    /* handshake() sets its own error message with failf() */\n    return rc;\n\n  /* Finish connecting once the handshake is done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    rc = gtls_connect_step3(data, conn, sockindex);\n    if(rc)\n      return rc;\n  }\n\n  *done = ssl_connect_1 == connssl->connecting_state;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode gtls_connect_nonblocking(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex, bool *done)\n{\n  return gtls_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode gtls_connect(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = gtls_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool gtls_data_pending(const struct connectdata *conn,\n                              int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  bool res = FALSE;\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->session &&\n     0 != gnutls_record_check_pending(backend->session))\n    res = TRUE;\n\n#ifndef CURL_DISABLE_PROXY\n  connssl = &conn->proxy_ssl[connindex];\n  backend = connssl->backend;\n  if(backend->session &&\n     0 != gnutls_record_check_pending(backend->session))\n    res = TRUE;\n#endif\n\n  return res;\n}\n\nstatic ssize_t gtls_send(struct Curl_easy *data,\n                         int sockindex,\n                         const void *mem,\n                         size_t len,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t rc = gnutls_record_send(backend->session, mem, len);\n\n  if(rc < 0) {\n    *curlcode = (rc == GNUTLS_E_AGAIN)\n      ? CURLE_AGAIN\n      : CURLE_SEND_ERROR;\n\n    rc = -1;\n  }\n\n  return rc;\n}\n\nstatic void close_one(struct ssl_connect_data *connssl)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->session) {\n    gnutls_bye(backend->session, GNUTLS_SHUT_WR);\n    gnutls_deinit(backend->session);\n    backend->session = NULL;\n  }\n  if(backend->cred) {\n    gnutls_certificate_free_credentials(backend->cred);\n    backend->cred = NULL;\n  }\n#ifdef HAVE_GNUTLS_SRP\n  if(backend->srp_client_cred) {\n    gnutls_srp_free_client_credentials(backend->srp_client_cred);\n    backend->srp_client_cred = NULL;\n  }\n#endif\n}\n\nstatic void gtls_close(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  (void) data;\n  close_one(&conn->ssl[sockindex]);\n#ifndef CURL_DISABLE_PROXY\n  close_one(&conn->proxy_ssl[sockindex]);\n#endif\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int gtls_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int retval = 0;\n\n#ifndef CURL_DISABLE_FTP\n  /* This has only been tested on the proftpd server, and the mod_tls code\n     sends a close notify alert without waiting for a close notify alert in\n     response. Thus we wait for a close notify alert from the server, but\n     we do not send one. Let's hope other servers do the same... */\n\n  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)\n    gnutls_bye(backend->session, GNUTLS_SHUT_WR);\n#endif\n\n  if(backend->session) {\n    ssize_t result;\n    bool done = FALSE;\n    char buf[120];\n\n    while(!done) {\n      int what = SOCKET_READABLE(conn->sock[sockindex],\n                                 SSL_SHUTDOWN_TIMEOUT);\n      if(what > 0) {\n        /* Something to read, let's do it and hope that it is the close\n           notify alert from the server */\n        result = gnutls_record_recv(backend->session,\n                                    buf, sizeof(buf));\n        switch(result) {\n        case 0:\n          /* This is the expected response. There was no data but only\n             the close notify alert */\n          done = TRUE;\n          break;\n        case GNUTLS_E_AGAIN:\n        case GNUTLS_E_INTERRUPTED:\n          infof(data, \"GNUTLS_E_AGAIN || GNUTLS_E_INTERRUPTED\\n\");\n          break;\n        default:\n          retval = -1;\n          done = TRUE;\n          break;\n        }\n      }\n      else if(0 == what) {\n        /* timeout */\n        failf(data, \"SSL shutdown timeout\");\n        done = TRUE;\n      }\n      else {\n        /* anything that gets here is fatally bad */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        retval = -1;\n        done = TRUE;\n      }\n    }\n    gnutls_deinit(backend->session);\n  }\n  gnutls_certificate_free_credentials(backend->cred);\n\n#ifdef HAVE_GNUTLS_SRP\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n     && SSL_SET_OPTION(username) != NULL)\n    gnutls_srp_free_client_credentials(backend->srp_client_cred);\n#endif\n\n  backend->cred = NULL;\n  backend->session = NULL;\n\n  return retval;\n}\n\nstatic ssize_t gtls_recv(struct Curl_easy *data, /* connection data */\n                         int num,                  /* socketindex */\n                         char *buf,                /* store read data here */\n                         size_t buffersize,        /* max amount to read */\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t ret;\n\n  ret = gnutls_record_recv(backend->session, buf, buffersize);\n  if((ret == GNUTLS_E_AGAIN) || (ret == GNUTLS_E_INTERRUPTED)) {\n    *curlcode = CURLE_AGAIN;\n    return -1;\n  }\n\n  if(ret == GNUTLS_E_REHANDSHAKE) {\n    /* BLOCKING call, this is bad but a work-around for now. Fixing this \"the\n       proper way\" takes a whole lot of work. */\n    CURLcode result = handshake(data, conn, num, FALSE, FALSE);\n    if(result)\n      /* handshake() writes error message on its own */\n      *curlcode = result;\n    else\n      *curlcode = CURLE_AGAIN; /* then return as if this was a wouldblock */\n    return -1;\n  }\n\n  if(ret < 0) {\n    failf(data, \"GnuTLS recv error (%d): %s\",\n\n          (int)ret, gnutls_strerror((int)ret));\n    *curlcode = CURLE_RECV_ERROR;\n    return -1;\n  }\n\n  return ret;\n}\n\nstatic void gtls_session_free(void *ptr)\n{\n  free(ptr);\n}\n\nstatic size_t gtls_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"GnuTLS/%s\", gnutls_check_version(NULL));\n}\n\n/* data might be NULL! */\nstatic CURLcode gtls_random(struct Curl_easy *data,\n                            unsigned char *entropy, size_t length)\n{\n  int rc;\n  (void)data;\n  rc = gnutls_rnd(GNUTLS_RND_RANDOM, entropy, length);\n  return rc?CURLE_FAILED_INIT:CURLE_OK;\n}\n\nstatic CURLcode gtls_sha256sum(const unsigned char *tmp, /* input */\n                               size_t tmplen,\n                               unsigned char *sha256sum, /* output */\n                               size_t sha256len)\n{\n  struct sha256_ctx SHA256pw;\n  sha256_init(&SHA256pw);\n  sha256_update(&SHA256pw, (unsigned int)tmplen, tmp);\n  sha256_digest(&SHA256pw, (unsigned int)sha256len, sha256sum);\n  return CURLE_OK;\n}\n\nstatic bool gtls_cert_status_request(void)\n{\n  return TRUE;\n}\n\nstatic void *gtls_get_internals(struct ssl_connect_data *connssl,\n                                     CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->session;\n}\n\nconst struct Curl_ssl Curl_ssl_gnutls = {\n  { CURLSSLBACKEND_GNUTLS, \"gnutls\" }, /* info */\n\n  SSLSUPP_CA_PATH  |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  gtls_init,                     /* init */\n  gtls_cleanup,                  /* cleanup */\n  gtls_version,                  /* version */\n  Curl_none_check_cxn,           /* check_cxn */\n  gtls_shutdown,                 /* shutdown */\n  gtls_data_pending,             /* data_pending */\n  gtls_random,                   /* random */\n  gtls_cert_status_request,      /* cert_status_request */\n  gtls_connect,                  /* connect */\n  gtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,              /* getsock */\n  gtls_get_internals,            /* get_internals */\n  gtls_close,                    /* close_one */\n  Curl_none_close_all,           /* close_all */\n  gtls_session_free,             /* session_free */\n  Curl_none_set_engine,          /* set_engine */\n  Curl_none_set_engine_default,  /* set_engine_default */\n  Curl_none_engines_list,        /* engines_list */\n  Curl_none_false_start,         /* false_start */\n  gtls_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_GNUTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2010 - 2011, Hoi-Ho Chan, <hoiho.chan@gmail.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all mbedTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_MBEDTLS\n\n/* Define this to enable lots of debugging for mbedTLS */\n/* #define MBEDTLS_DEBUG */\n\n#include <mbedtls/version.h>\n#if MBEDTLS_VERSION_NUMBER >= 0x02040000\n#include <mbedtls/net_sockets.h>\n#else\n#include <mbedtls/net.h>\n#endif\n#include <mbedtls/ssl.h>\n#include <mbedtls/certs.h>\n#include <mbedtls/x509.h>\n\n#include <mbedtls/error.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/sha256.h>\n\n#if MBEDTLS_VERSION_MAJOR >= 2\n#  ifdef MBEDTLS_DEBUG\n#    include <mbedtls/debug.h>\n#  endif\n#endif\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"mbedtls.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"mbedtls_threadlock.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\nstruct ssl_backend_data {\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_context entropy;\n  mbedtls_ssl_context ssl;\n  int server_fd;\n  mbedtls_x509_crt cacert;\n  mbedtls_x509_crt clicert;\n  mbedtls_x509_crl crl;\n  mbedtls_pk_context pk;\n  mbedtls_ssl_config config;\n  const char *protocols[3];\n};\n\n/* apply threading? */\n#if defined(USE_THREADS_POSIX) || defined(USE_THREADS_WIN32)\n#define THREADING_SUPPORT\n#endif\n\n#if defined(THREADING_SUPPORT)\nstatic mbedtls_entropy_context ts_entropy;\n\nstatic int entropy_init_initialized = 0;\n\n/* start of entropy_init_mutex() */\nstatic void entropy_init_mutex(mbedtls_entropy_context *ctx)\n{\n  /* lock 0 = entropy_init_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(0);\n  if(entropy_init_initialized == 0) {\n    mbedtls_entropy_init(ctx);\n    entropy_init_initialized = 1;\n  }\n  Curl_mbedtlsthreadlock_unlock_function(0);\n}\n/* end of entropy_init_mutex() */\n\n/* start of entropy_func_mutex() */\nstatic int entropy_func_mutex(void *data, unsigned char *output, size_t len)\n{\n  int ret;\n  /* lock 1 = entropy_func_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(1);\n  ret = mbedtls_entropy_func(data, output, len);\n  Curl_mbedtlsthreadlock_unlock_function(1);\n\n  return ret;\n}\n/* end of entropy_func_mutex() */\n\n#endif /* THREADING_SUPPORT */\n\n#ifdef MBEDTLS_DEBUG\nstatic void mbed_debug(void *context, int level, const char *f_name,\n                       int line_nb, const char *line)\n{\n  struct Curl_easy *data = NULL;\n\n  if(!context)\n    return;\n\n  data = (struct Curl_easy *)context;\n\n  infof(data, \"%s\", line);\n  (void) level;\n}\n#else\n#endif\n\n/* ALPN for http2? */\n#ifdef USE_NGHTTP2\n#  undef HAS_ALPN\n#  ifdef MBEDTLS_SSL_ALPN\n#    define HAS_ALPN\n#  endif\n#endif\n\n\n/*\n *  profile\n */\nstatic const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_fr =\n{\n  /* Hashes from SHA-1 and above */\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA1) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_RIPEMD160) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA224) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),\n  0xFFFFFFF, /* Any PK alg    */\n  0xFFFFFFF, /* Any curve     */\n  1024,      /* RSA min key len */\n};\n\n/* See https://tls.mbed.org/discussions/generic/\n   howto-determine-exact-buffer-len-for-mbedtls_pk_write_pubkey_der\n*/\n#define RSA_PUB_DER_MAX_BYTES   (38 + 2 * MBEDTLS_MPI_MAX_SIZE)\n#define ECP_PUB_DER_MAX_BYTES   (30 + 2 * MBEDTLS_ECP_MAX_BYTES)\n\n#define PUB_DER_MAX_BYTES   (RSA_PUB_DER_MAX_BYTES > ECP_PUB_DER_MAX_BYTES ? \\\n                             RSA_PUB_DER_MAX_BYTES : ECP_PUB_DER_MAX_BYTES)\n\nstatic Curl_recv mbed_recv;\nstatic Curl_send mbed_send;\n\nstatic CURLcode mbedtls_version_from_curl(int *mbedver, long version)\n{\n  switch(version) {\n    case CURL_SSLVERSION_TLSv1_0:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_1;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_1:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_2;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_2:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_3;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int mbedtls_ver_min = MBEDTLS_SSL_MINOR_VERSION_1;\n  int mbedtls_ver_max = MBEDTLS_SSL_MINOR_VERSION_1;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  CURLcode result = CURLE_OK;\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      ssl_version = CURL_SSLVERSION_TLSv1_0;\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n      break;\n  }\n\n  result = mbedtls_version_from_curl(&mbedtls_ver_min, ssl_version);\n  if(result) {\n    failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n  result = mbedtls_version_from_curl(&mbedtls_ver_max, ssl_version_max >> 16);\n  if(result) {\n    failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n\n  mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_min);\n  mbedtls_ssl_conf_max_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_max);\n\n  return result;\n}\n\nstatic CURLcode\nmbed_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const char * const ssl_cafile = SSL_CONN_CONFIG(CAfile);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n  const char * const hostname = SSL_HOST_NAME();\n  const long int port = SSL_HOST_PORT();\n  int ret = -1;\n  char errorbuf[128];\n  errorbuf[0] = 0;\n\n  if((SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv2) ||\n     (SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv3)) {\n    failf(data, \"Not supported SSL version\");\n    return CURLE_NOT_BUILT_IN;\n  }\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&ts_entropy);\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, entropy_func_mutex,\n                              &ts_entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n#else\n  mbedtls_entropy_init(&backend->entropy);\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, mbedtls_entropy_func,\n                              &backend->entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  mbedtls_x509_crt_init(&backend->cacert);\n\n  if(ssl_cafile) {\n    ret = mbedtls_x509_crt_parse_file(&backend->cacert, ssl_cafile);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cafile, -ret, errorbuf);\n\n      if(verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(ssl_capath) {\n    ret = mbedtls_x509_crt_parse_path(&backend->cacert, ssl_capath);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - mbedTLS: (-0x%04X) %s\",\n            ssl_capath, -ret, errorbuf);\n\n      if(verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  mbedtls_x509_crt_init(&backend->clicert);\n\n  if(ssl_cert) {\n    ret = mbedtls_x509_crt_parse_file(&backend->clicert, ssl_cert);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading client cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cert, -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  mbedtls_pk_init(&backend->pk);\n\n  if(SSL_SET_OPTION(key)) {\n    ret = mbedtls_pk_parse_keyfile(&backend->pk, SSL_SET_OPTION(key),\n                                   SSL_SET_OPTION(key_passwd));\n    if(ret == 0 && !(mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_RSA) ||\n                     mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_ECKEY)))\n      ret = MBEDTLS_ERR_PK_TYPE_MISMATCH;\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n            SSL_SET_OPTION(key), -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  mbedtls_x509_crl_init(&backend->crl);\n\n  if(ssl_crlfile) {\n    ret = mbedtls_x509_crl_parse_file(&backend->crl, ssl_crlfile);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading CRL file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_crlfile, -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"mbedTLS: Connecting to %s:%ld\\n\", hostname, port);\n\n  mbedtls_ssl_config_init(&backend->config);\n\n  mbedtls_ssl_init(&backend->ssl);\n  if(mbedtls_ssl_setup(&backend->ssl, &backend->config)) {\n    failf(data, \"mbedTLS: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  ret = mbedtls_ssl_config_defaults(&backend->config,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT);\n  if(ret) {\n    failf(data, \"mbedTLS: ssl_config failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* new profile with RSA min key len = 1024 ... */\n  mbedtls_ssl_conf_cert_profile(&backend->config,\n                                &mbedtls_x509_crt_profile_fr);\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set min SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    {\n      CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_conf_authmode(&backend->config, MBEDTLS_SSL_VERIFY_OPTIONAL);\n\n  mbedtls_ssl_conf_rng(&backend->config, mbedtls_ctr_drbg_random,\n                       &backend->ctr_drbg);\n  mbedtls_ssl_set_bio(&backend->ssl, &conn->sock[sockindex],\n                      mbedtls_net_send,\n                      mbedtls_net_recv,\n                      NULL /*  rev_timeout() */);\n\n  mbedtls_ssl_conf_ciphersuites(&backend->config,\n                                mbedtls_ssl_list_ciphersuites());\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n  mbedtls_ssl_conf_renegotiation(&backend->config,\n                                 MBEDTLS_SSL_RENEGOTIATION_ENABLED);\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n  mbedtls_ssl_conf_session_tickets(&backend->config,\n                                   MBEDTLS_SSL_SESSION_TICKETS_DISABLED);\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *old_session = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &old_session, NULL, sockindex)) {\n      ret = mbedtls_ssl_set_session(&backend->ssl, old_session);\n      if(ret) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"mbedtls_ssl_set_session returned -0x%x\", -ret);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      infof(data, \"mbedTLS re-using session\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  mbedtls_ssl_conf_ca_chain(&backend->config,\n                            &backend->cacert,\n                            &backend->crl);\n\n  if(SSL_SET_OPTION(key)) {\n    mbedtls_ssl_conf_own_cert(&backend->config,\n                              &backend->clicert, &backend->pk);\n  }\n  if(mbedtls_ssl_set_hostname(&backend->ssl, hostname)) {\n    /* mbedtls_ssl_set_hostname() sets the name to use in CN/SAN checks *and*\n       the name to set in the SNI extension. So even if curl connects to a\n       host specified as an IP address, this function must be used. */\n    failf(data, \"couldn't set hostname in mbedTLS\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char **p = &backend->protocols[0];\n#ifdef USE_NGHTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2)\n      *p++ = NGHTTP2_PROTO_VERSION_ID;\n#endif\n    *p++ = ALPN_HTTP_1_1;\n    *p = NULL;\n    /* this function doesn't clone the protocols array, which is why we need\n       to keep it around */\n    if(mbedtls_ssl_conf_alpn_protocols(&backend->config,\n                                       &backend->protocols[0])) {\n      failf(data, \"Failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    for(p = &backend->protocols[0]; *p; ++p)\n      infof(data, \"ALPN, offering %s\\n\", *p);\n  }\n#endif\n\n#ifdef MBEDTLS_DEBUG\n  /* In order to make that work in mbedtls MBEDTLS_DEBUG_C must be defined. */\n  mbedtls_ssl_conf_dbg(&backend->config, mbed_debug, data);\n  /* - 0 No debug\n   * - 1 Error\n   * - 2 State change\n   * - 3 Informational\n   * - 4 Verbose\n   */\n  mbedtls_debug_set_threshold(4);\n#endif\n\n  /* give application a chance to interfere with mbedTLS set up. */\n  if(data->set.ssl.fsslctx) {\n    ret = (*data->set.ssl.fsslctx)(data, &backend->config,\n                                   data->set.ssl.fsslctxp);\n    if(ret) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return ret;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  int ret;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const mbedtls_x509_crt *peercert;\n  const char * const pinnedpubkey = SSL_PINNED_PUB_KEY();\n\n  conn->recv[sockindex] = mbed_recv;\n  conn->send[sockindex] = mbed_send;\n\n  ret = mbedtls_ssl_handshake(&backend->ssl);\n\n  if(ret == MBEDTLS_ERR_SSL_WANT_READ) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n  else if(ret == MBEDTLS_ERR_SSL_WANT_WRITE) {\n    connssl->connecting_state = ssl_connect_2_writing;\n    return CURLE_OK;\n  }\n  else if(ret) {\n    char errorbuf[128];\n    errorbuf[0] = 0;\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"ssl_handshake returned - mbedTLS: (-0x%04X) %s\",\n          -ret, errorbuf);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  infof(data, \"mbedTLS: Handshake complete, cipher is %s\\n\",\n        mbedtls_ssl_get_ciphersuite(&backend->ssl)\n    );\n\n  ret = mbedtls_ssl_get_verify_result(&backend->ssl);\n\n  if(!SSL_CONN_CONFIG(verifyhost))\n    /* Ignore hostname errors if verifyhost is disabled */\n    ret &= ~MBEDTLS_X509_BADCERT_CN_MISMATCH;\n\n  if(ret && SSL_CONN_CONFIG(verifypeer)) {\n    if(ret & MBEDTLS_X509_BADCERT_EXPIRED)\n      failf(data, \"Cert verify failed: BADCERT_EXPIRED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_REVOKED)\n      failf(data, \"Cert verify failed: BADCERT_REVOKED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_CN_MISMATCH)\n      failf(data, \"Cert verify failed: BADCERT_CN_MISMATCH\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_NOT_TRUSTED)\n      failf(data, \"Cert verify failed: BADCERT_NOT_TRUSTED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_FUTURE)\n      failf(data, \"Cert verify failed: BADCERT_FUTURE\");\n\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  peercert = mbedtls_ssl_get_peer_cert(&backend->ssl);\n\n  if(peercert && data->set.verbose) {\n    const size_t bufsize = 16384;\n    char *buffer = malloc(bufsize);\n\n    if(!buffer)\n      return CURLE_OUT_OF_MEMORY;\n\n    if(mbedtls_x509_crt_info(buffer, bufsize, \"* \", peercert) > 0)\n      infof(data, \"Dumping cert info:\\n%s\\n\", buffer);\n    else\n      infof(data, \"Unable to dump certificate information.\\n\");\n\n    free(buffer);\n  }\n\n  if(pinnedpubkey) {\n    int size;\n    CURLcode result;\n    mbedtls_x509_crt *p;\n    unsigned char pubkey[PUB_DER_MAX_BYTES];\n\n    if(!peercert || !peercert->raw.p || !peercert->raw.len) {\n      failf(data, \"Failed due to missing peer certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    p = calloc(1, sizeof(*p));\n\n    if(!p)\n      return CURLE_OUT_OF_MEMORY;\n\n    mbedtls_x509_crt_init(p);\n\n    /* Make a copy of our const peercert because mbedtls_pk_write_pubkey_der\n       needs a non-const key, for now.\n       https://github.com/ARMmbed/mbedtls/issues/396 */\n    if(mbedtls_x509_crt_parse_der(p, peercert->raw.p, peercert->raw.len)) {\n      failf(data, \"Failed copying peer certificate\");\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    size = mbedtls_pk_write_pubkey_der(&p->pk, pubkey, PUB_DER_MAX_BYTES);\n\n    if(size <= 0) {\n      failf(data, \"Failed copying public key from peer certificate\");\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    /* mbedtls_pk_write_pubkey_der writes data at the end of the buffer. */\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  &pubkey[PUB_DER_MAX_BYTES - size], size);\n    if(result) {\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return result;\n    }\n\n    mbedtls_x509_crt_free(p);\n    free(p);\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char *next_protocol = mbedtls_ssl_get_alpn_protocol(&backend->ssl);\n\n    if(next_protocol) {\n      infof(data, \"ALPN, server accepted to use %s\\n\", next_protocol);\n#ifdef USE_NGHTTP2\n      if(!strncmp(next_protocol, NGHTTP2_PROTO_VERSION_ID,\n                  NGHTTP2_PROTO_VERSION_ID_LEN) &&\n         !next_protocol[NGHTTP2_PROTO_VERSION_ID_LEN]) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(!strncmp(next_protocol, ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH) &&\n           !next_protocol[ALPN_HTTP_1_1_LENGTH]) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else {\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    }\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  connssl->connecting_state = ssl_connect_3;\n  infof(data, \"SSL connected\\n\");\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  CURLcode retcode = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int ret;\n    mbedtls_ssl_session *our_ssl_sessionid;\n    void *old_ssl_sessionid = NULL;\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    our_ssl_sessionid = malloc(sizeof(mbedtls_ssl_session));\n    if(!our_ssl_sessionid)\n      return CURLE_OUT_OF_MEMORY;\n\n    mbedtls_ssl_session_init(our_ssl_sessionid);\n\n    ret = mbedtls_ssl_get_session(&backend->ssl, our_ssl_sessionid);\n    if(ret) {\n      if(ret != MBEDTLS_ERR_SSL_ALLOC_FAILED)\n        mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n      failf(data, \"mbedtls_ssl_get_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* If there's already a matching session in the cache, delete it */\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, isproxy, &old_ssl_sessionid, NULL,\n                              sockindex))\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n\n    retcode = Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid,\n                                    0, sockindex);\n    Curl_ssl_sessionid_unlock(data);\n    if(retcode) {\n      mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n      failf(data, \"failed to store ssl session\");\n      return retcode;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t mbed_send(struct Curl_easy *data, int sockindex,\n                         const void *mem, size_t len,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int ret = -1;\n\n  ret = mbedtls_ssl_write(&backend->ssl, (unsigned char *)mem, len);\n\n  if(ret < 0) {\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_WRITE) ?\n      CURLE_AGAIN : CURLE_SEND_ERROR;\n    ret = -1;\n  }\n\n  return ret;\n}\n\nstatic void mbedtls_close_all(struct Curl_easy *data)\n{\n  (void)data;\n}\n\nstatic void mbedtls_close(struct Curl_easy *data,\n                          struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n  mbedtls_pk_free(&backend->pk);\n  mbedtls_x509_crt_free(&backend->clicert);\n  mbedtls_x509_crt_free(&backend->cacert);\n  mbedtls_x509_crl_free(&backend->crl);\n  mbedtls_ssl_config_free(&backend->config);\n  mbedtls_ssl_free(&backend->ssl);\n  mbedtls_ctr_drbg_free(&backend->ctr_drbg);\n#ifndef THREADING_SUPPORT\n  mbedtls_entropy_free(&backend->entropy);\n#endif /* THREADING_SUPPORT */\n}\n\nstatic ssize_t mbed_recv(struct Curl_easy *data, int num,\n                         char *buf, size_t buffersize,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  int ret = -1;\n  ssize_t len = -1;\n\n  ret = mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf,\n                         buffersize);\n\n  if(ret <= 0) {\n    if(ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)\n      return 0;\n\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_READ) ?\n      CURLE_AGAIN : CURLE_RECV_ERROR;\n    return -1;\n  }\n\n  len = ret;\n\n  return len;\n}\n\nstatic void mbedtls_session_free(void *ptr)\n{\n  mbedtls_ssl_session_free(ptr);\n  free(ptr);\n}\n\nstatic size_t mbedtls_version(char *buffer, size_t size)\n{\n#ifdef MBEDTLS_VERSION_C\n  /* if mbedtls_version_get_number() is available it is better */\n  unsigned int version = mbedtls_version_get_number();\n  return msnprintf(buffer, size, \"mbedTLS/%u.%u.%u\", version>>24,\n                   (version>>16)&0xff, (version>>8)&0xff);\n#else\n  return msnprintf(buffer, size, \"mbedTLS/%s\", MBEDTLS_VERSION_STRING);\n#endif\n}\n\nstatic CURLcode mbedtls_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n#if defined(MBEDTLS_CTR_DRBG_C)\n  int ret = -1;\n  char errorbuf[128];\n  mbedtls_entropy_context ctr_entropy;\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_init(&ctr_entropy);\n  mbedtls_ctr_drbg_init(&ctr_drbg);\n  errorbuf[0] = 0;\n\n  ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func,\n                              &ctr_entropy, NULL, 0);\n\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_seed returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n  else {\n    ret = mbedtls_ctr_drbg_random(&ctr_drbg, entropy, length);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n            -ret, errorbuf);\n    }\n  }\n\n  mbedtls_ctr_drbg_free(&ctr_drbg);\n  mbedtls_entropy_free(&ctr_entropy);\n\n  return ret == 0 ? CURLE_OK : CURLE_FAILED_INIT;\n#elif defined(MBEDTLS_HAVEGE_C)\n  mbedtls_havege_state hs;\n  mbedtls_havege_init(&hs);\n  mbedtls_havege_random(&hs, entropy, length);\n  mbedtls_havege_free(&hs);\n  return CURLE_OK;\n#else\n  return CURLE_NOT_BUILT_IN;\n#endif\n}\n\nstatic CURLcode\nmbed_connect_common(struct Curl_easy *data,\n                    struct connectdata *conn,\n                    int sockindex,\n                    bool nonblocking,\n                    bool *done)\n{\n  CURLcode retcode;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    retcode = mbed_connect_step1(data, conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    retcode = mbed_connect_step2(data, conn, sockindex);\n    if(retcode || (nonblocking &&\n                   (ssl_connect_2 == connssl->connecting_state ||\n                    ssl_connect_2_reading == connssl->connecting_state ||\n                    ssl_connect_2_writing == connssl->connecting_state)))\n      return retcode;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    retcode = mbed_connect_step3(data, conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = mbed_recv;\n    conn->send[sockindex] = mbed_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode mbedtls_connect_nonblocking(struct Curl_easy *data,\n                                            struct connectdata *conn,\n                                            int sockindex, bool *done)\n{\n  return mbed_connect_common(data, conn, sockindex, TRUE, done);\n}\n\n\nstatic CURLcode mbedtls_connect(struct Curl_easy *data,\n                                struct connectdata *conn, int sockindex)\n{\n  CURLcode retcode;\n  bool done = FALSE;\n\n  retcode = mbed_connect_common(data, conn, sockindex, FALSE, &done);\n  if(retcode)\n    return retcode;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\n/*\n * return 0 error initializing SSL\n * return 1 SSL initialized successfully\n */\nstatic int mbedtls_init(void)\n{\n  return Curl_mbedtlsthreadlock_thread_setup();\n}\n\nstatic void mbedtls_cleanup(void)\n{\n  (void)Curl_mbedtlsthreadlock_thread_cleanup();\n}\n\nstatic bool mbedtls_data_pending(const struct connectdata *conn,\n                                 int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  return mbedtls_ssl_get_bytes_avail(&backend->ssl) != 0;\n}\n\nstatic CURLcode mbedtls_sha256sum(const unsigned char *input,\n                                  size_t inputlen,\n                                  unsigned char *sha256sum,\n                                  size_t sha256len UNUSED_PARAM)\n{\n  (void)sha256len;\n#if MBEDTLS_VERSION_NUMBER < 0x02070000\n  mbedtls_sha256(input, inputlen, sha256sum, 0);\n#else\n  /* returns 0 on success, otherwise failure */\n  if(mbedtls_sha256_ret(input, inputlen, sha256sum, 0) != 0)\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n#endif\n  return CURLE_OK;\n}\n\nstatic void *mbedtls_get_internals(struct ssl_connect_data *connssl,\n                                   CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return &backend->ssl;\n}\n\nconst struct Curl_ssl Curl_ssl_mbedtls = {\n  { CURLSSLBACKEND_MBEDTLS, \"mbedtls\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  mbedtls_init,                     /* init */\n  mbedtls_cleanup,                  /* cleanup */\n  mbedtls_version,                  /* version */\n  Curl_none_check_cxn,              /* check_cxn */\n  Curl_none_shutdown,               /* shutdown */\n  mbedtls_data_pending,             /* data_pending */\n  mbedtls_random,                   /* random */\n  Curl_none_cert_status_request,    /* cert_status_request */\n  mbedtls_connect,                  /* connect */\n  mbedtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                 /* getsock */\n  mbedtls_get_internals,            /* get_internals */\n  mbedtls_close,                    /* close_one */\n  mbedtls_close_all,                /* close_all */\n  mbedtls_session_free,             /* session_free */\n  Curl_none_set_engine,             /* set_engine */\n  Curl_none_set_engine_default,     /* set_engine_default */\n  Curl_none_engines_list,           /* engines_list */\n  Curl_none_false_start,            /* false_start */\n  mbedtls_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_MBEDTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2017 - 2018, Yiming Jing, <jingyiming@baidu.com>\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all MesaLink-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n/*\n * Based upon the CyaSSL implementation in cyassl.c and cyassl.h:\n *   Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * Thanks for code and inspiration!\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_MESALINK\n\n#include <mesalink/options.h>\n#include <mesalink/version.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n\n#include \"mesalink.h\"\n#include <mesalink/openssl/ssl.h>\n#include <mesalink/openssl/err.h>\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define MESALINK_MAX_ERROR_SZ 80\n\nstruct ssl_backend_data\n{\n  SSL_CTX *ctx;\n  SSL *handle;\n};\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv mesalink_recv;\nstatic Curl_send mesalink_send;\n\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  return -1;\n}\n\n/*\n * This function loads all the client/CA certificates and CRLs. Setup the TLS\n * layer and do all necessary magic.\n */\nstatic CURLcode\nmesalink_connect_step1(struct Curl_easy *data,\n                       struct connectdata *conn, int sockindex)\n{\n  char *ciphers;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct in_addr addr4;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  const char * const hostname = SSL_HOST_NAME();\n  size_t hostname_len = strlen(hostname);\n\n  SSL_METHOD *req_method = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n\n  if(connssl->state == ssl_connection_complete)\n    return CURLE_OK;\n\n  if(SSL_CONN_CONFIG(version_max) != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"MesaLink does not support to set maximum SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_SSLv3:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n    failf(data, \"MesaLink does not support SSL 3.0, TLS 1.0, or TLS 1.1\");\n    return CURLE_NOT_BUILT_IN;\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1_2:\n    req_method = TLSv1_2_client_method();\n    break;\n  case CURL_SSLVERSION_TLSv1_3:\n    req_method = TLSv1_3_client_method();\n    break;\n  case CURL_SSLVERSION_SSLv2:\n    failf(data, \"MesaLink does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(!req_method) {\n    failf(data, \"SSL: couldn't create a method!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(BACKEND->ctx)\n    SSL_CTX_free(BACKEND->ctx);\n  BACKEND->ctx = SSL_CTX_new(req_method);\n\n  if(!BACKEND->ctx) {\n    failf(data, \"SSL: couldn't create a context!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  SSL_CTX_set_verify(\n    BACKEND->ctx, SSL_CONN_CONFIG(verifypeer) ?\n      SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);\n\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(CApath)) {\n    if(!SSL_CTX_load_verify_locations(BACKEND->ctx, SSL_CONN_CONFIG(CAfile),\n                                                    SSL_CONN_CONFIG(CApath))) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data,\n              \"error setting certificate verify locations: \"\n              \" CAfile: %s CApath: %s\",\n              SSL_CONN_CONFIG(CAfile) ?\n              SSL_CONN_CONFIG(CAfile) : \"none\",\n              SSL_CONN_CONFIG(CApath) ?\n              SSL_CONN_CONFIG(CApath) : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      infof(data,\n          \"error setting certificate verify locations,\"\n          \" continuing anyway:\\n\");\n    }\n    else {\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\",\n          SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile): \"none\");\n    infof(data, \" CApath: %s\\n\",\n          SSL_CONN_CONFIG(CApath) ? SSL_CONN_CONFIG(CApath): \"none\");\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert) && SSL_SET_OPTION(key)) {\n    int file_type = do_file_type(SSL_SET_OPTION(cert_type));\n\n    if(SSL_CTX_use_certificate_chain_file(BACKEND->ctx,\n                                          SSL_SET_OPTION(primary.clientcert),\n                                          file_type) != 1) {\n      failf(data, \"unable to use client certificate (no key or wrong pass\"\n            \" phrase?)\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    file_type = do_file_type(SSL_SET_OPTION(key_type));\n    if(SSL_CTX_use_PrivateKey_file(BACKEND->ctx, SSL_SET_OPTION(key),\n                                    file_type) != 1) {\n      failf(data, \"unable to set private key\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data,\n          \"client cert: %s\\n\",\n          SSL_CONN_CONFIG(clientcert)?\n          SSL_CONN_CONFIG(clientcert): \"none\");\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n#ifdef MESALINK_HAVE_CIPHER\n    if(!SSL_CTX_set_cipher_list(BACKEND->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n#endif\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n  if(BACKEND->handle)\n    SSL_free(BACKEND->handle);\n  BACKEND->handle = SSL_new(BACKEND->ctx);\n  if(!BACKEND->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if((hostname_len < USHRT_MAX) &&\n     (0 == Curl_inet_pton(AF_INET, hostname, &addr4))\n#ifdef ENABLE_IPV6\n     && (0 == Curl_inet_pton(AF_INET6, hostname, &addr6))\n#endif\n  ) {\n    /* hostname is not a valid IP address */\n    if(SSL_set_tlsext_host_name(BACKEND->handle, hostname) != SSL_SUCCESS) {\n      failf(data,\n            \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#ifdef CURLDEBUG\n    /* Check if the hostname is 127.0.0.1 or [::1];\n     * otherwise reject because MesaLink always wants a valid DNS Name\n     * specified in RFC 5280 Section 7.2 */\n    if(strncmp(hostname, \"127.0.0.1\", 9) == 0\n#ifdef ENABLE_IPV6\n       || strncmp(hostname, \"[::1]\", 5) == 0\n#endif\n    ) {\n      SSL_set_tlsext_host_name(BACKEND->handle, \"localhost\");\n    }\n    else\n#endif\n    {\n      failf(data,\n            \"ERROR: MesaLink does not accept an IP address as a hostname\\n\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n#ifdef MESALINK_HAVE_SESSION\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(BACKEND->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(\n          data,\n          \"SSL: SSL_set_session failed: %s\",\n          ERR_error_string(SSL_get_error(BACKEND->handle, 0), error_buffer));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n#endif /* MESALINK_HAVE_SESSION */\n\n  if(SSL_set_fd(BACKEND->handle, (int)sockfd) != SSL_SUCCESS) {\n    failf(data, \"SSL: SSL_set_fd failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_step2(struct Curl_easy *data,\n                       struct connectdata *conn, int sockindex)\n{\n  int ret = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  conn->recv[sockindex] = mesalink_recv;\n  conn->send[sockindex] = mesalink_send;\n\n  ret = SSL_connect(BACKEND->handle);\n  if(ret != SSL_SUCCESS) {\n    int detail = SSL_get_error(BACKEND->handle, ret);\n\n    if(SSL_ERROR_WANT_CONNECT == detail || SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    else {\n      char error_buffer[MESALINK_MAX_ERROR_SZ];\n      failf(data,\n            \"SSL_connect failed with error %d: %s\",\n            detail,\n            ERR_error_string_n(detail, error_buffer, sizeof(error_buffer)));\n      ERR_print_errors_fp(stderr);\n      if(detail && SSL_CONN_CONFIG(verifypeer)) {\n        detail &= ~0xFF;\n        if(detail == TLS_ERROR_WEBPKI_ERRORS) {\n          failf(data, \"Cert verify failed\");\n          return CURLE_PEER_FAILED_VERIFICATION;\n        }\n      }\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_3;\n  infof(data,\n        \"SSL connection using %s / %s\\n\",\n        SSL_get_version(BACKEND->handle),\n        SSL_get_cipher_name(BACKEND->handle));\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_step3(struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n#ifdef MESALINK_HAVE_SESSION\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    SSL_SESSION *our_ssl_sessionid;\n    void *old_ssl_sessionid = NULL;\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    our_ssl_sessionid = SSL_get_session(BACKEND->handle);\n\n    Curl_ssl_sessionid_lock(data);\n    incache =\n      !(Curl_ssl_getsessionid(data, conn, isproxy, &old_ssl_sessionid, NULL,\n                              sockindex));\n    if(incache) {\n      if(old_ssl_sessionid != our_ssl_sessionid) {\n        infof(data, \"old SSL session ID is stale, removing\\n\");\n        Curl_ssl_delsessionid(data, old_ssl_sessionid);\n        incache = FALSE;\n      }\n    }\n\n    if(!incache) {\n      result =\n        Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid, 0,\n                              sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"failed to store ssl session\");\n        return result;\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n#endif /* MESALINK_HAVE_SESSION */\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic ssize_t\nmesalink_send(struct Curl_easy *data, int sockindex, const void *mem,\n              size_t len, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char error_buffer[MESALINK_MAX_ERROR_SZ];\n  int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  int rc = SSL_write(BACKEND->handle, mem, memlen);\n\n  if(rc < 0) {\n    int err = SSL_get_error(BACKEND->handle, rc);\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_write() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data,\n            \"SSL write: %s, errno %d\",\n            ERR_error_string_n(err, error_buffer, sizeof(error_buffer)),\n            SOCKERRNO);\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n  return rc;\n}\n\nstatic void\nmesalink_close(struct Curl_easy *data, struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  (void) data;\n\n  if(BACKEND->handle) {\n    (void)SSL_shutdown(BACKEND->handle);\n    SSL_free(BACKEND->handle);\n    BACKEND->handle = NULL;\n  }\n  if(BACKEND->ctx) {\n    SSL_CTX_free(BACKEND->ctx);\n    BACKEND->ctx = NULL;\n  }\n}\n\nstatic ssize_t\nmesalink_recv(struct Curl_easy *data, int num, char *buf, size_t buffersize,\n              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  char error_buffer[MESALINK_MAX_ERROR_SZ];\n  int buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  int nread = SSL_read(BACKEND->handle, buf, buffsize);\n\n  if(nread <= 0) {\n    int err = SSL_get_error(BACKEND->handle, nread);\n\n    switch(err) {\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n    case IO_ERROR_CONNECTION_ABORTED:\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data,\n            \"SSL read: %s, errno %d\",\n            ERR_error_string_n(err, error_buffer, sizeof(error_buffer)),\n            SOCKERRNO);\n      *curlcode = CURLE_RECV_ERROR;\n      return -1;\n    }\n  }\n  return nread;\n}\n\nstatic size_t\nmesalink_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"MesaLink/%s\", MESALINK_VERSION_STRING);\n}\n\nstatic int\nmesalink_init(void)\n{\n  return (SSL_library_init() == SSL_SUCCESS);\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int\nmesalink_shutdown(struct Curl_easy *data,\n                  struct connectdata *conn, int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  (void) data;\n\n  if(BACKEND->handle) {\n    SSL_free(BACKEND->handle);\n    BACKEND->handle = NULL;\n  }\n  return retval;\n}\n\nstatic CURLcode\nmesalink_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = mesalink_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd =\n        ssl_connect_2_writing == connssl->connecting_state ? sockfd\n                                                           : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading == connssl->connecting_state\n                               ? sockfd\n                               : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = mesalink_connect_step2(data, conn, sockindex);\n\n    if(result ||\n       (nonblocking && (ssl_connect_2 == connssl->connecting_state ||\n                        ssl_connect_2_reading == connssl->connecting_state ||\n                        ssl_connect_2_writing == connssl->connecting_state))) {\n      return result;\n    }\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = mesalink_connect_step3(conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = mesalink_recv;\n    conn->send[sockindex] = mesalink_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, bool *done)\n{\n  return mesalink_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode\nmesalink_connect(struct Curl_easy *data, struct connectdata *conn,\n                 int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = mesalink_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic void *\nmesalink_get_internals(struct ssl_connect_data *connssl,\n                       CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return BACKEND->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_mesalink = {\n  { CURLSSLBACKEND_MESALINK, \"MesaLink\" }, /* info */\n\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  mesalink_init,                 /* init */\n  Curl_none_cleanup,             /* cleanup */\n  mesalink_version,              /* version */\n  Curl_none_check_cxn,           /* check_cxn */\n  mesalink_shutdown,             /* shutdown */\n  Curl_none_data_pending,        /* data_pending */\n  Curl_none_random,              /* random */\n  Curl_none_cert_status_request, /* cert_status_request */\n  mesalink_connect,              /* connect */\n  mesalink_connect_nonblocking,  /* connect_nonblocking */\n  Curl_ssl_getsock,              /* getsock */\n  mesalink_get_internals,        /* get_internals */\n  mesalink_close,                /* close_one */\n  Curl_none_close_all,           /* close_all */\n  Curl_none_session_free,        /* session_free */\n  Curl_none_set_engine,          /* set_engine */\n  Curl_none_set_engine_default,  /* set_engine_default */\n  Curl_none_engines_list,        /* engines_list */\n  Curl_none_false_start,         /* false_start */\n  NULL                           /* sha256sum */\n};\n\n#endif\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all NSS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_NSS\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"formdata.h\" /* for the boundary function */\n#include \"url.h\" /* for the ssl config check function */\n#include \"connect.h\"\n#include \"strcase.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"llist.h\"\n#include \"multiif.h\"\n#include \"curl_printf.h\"\n#include \"nssg.h\"\n#include <nspr.h>\n#include <nss.h>\n#include <ssl.h>\n#include <sslerr.h>\n#include <secerr.h>\n#include <secmod.h>\n#include <sslproto.h>\n#include <prtypes.h>\n#include <pk11pub.h>\n#include <prio.h>\n#include <secitem.h>\n#include <secport.h>\n#include <certdb.h>\n#include <base64.h>\n#include <cert.h>\n#include <prerror.h>\n#include <keyhi.h>         /* for SECKEY_DestroyPublicKey() */\n#include <private/pprio.h> /* for PR_ImportTCPSocket */\n\n#define NSSVERNUM ((NSS_VMAJOR<<16)|(NSS_VMINOR<<8)|NSS_VPATCH)\n\n#if NSSVERNUM >= 0x030f00 /* 3.15.0 */\n#include <ocsp.h>\n#endif\n\n#include \"strcase.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define SSL_DIR \"/etc/pki/nssdb\"\n\n/* enough to fit the string \"PEM Token #[0|1]\" */\n#define SLOTSIZE 13\n\nstruct ssl_backend_data {\n  PRFileDesc *handle;\n  char *client_nickname;\n  struct Curl_easy *data;\n  struct Curl_llist obj_list;\n  PK11GenericObject *obj_clicert;\n};\n\nstatic PRLock *nss_initlock = NULL;\nstatic PRLock *nss_crllock = NULL;\nstatic PRLock *nss_findslot_lock = NULL;\nstatic PRLock *nss_trustload_lock = NULL;\nstatic struct Curl_llist nss_crl_list;\nstatic NSSInitContext *nss_context = NULL;\nstatic volatile int initialized = 0;\n\n/* type used to wrap pointers as list nodes */\nstruct ptr_list_wrap {\n  void *ptr;\n  struct Curl_llist_element node;\n};\n\nstruct cipher_s {\n  const char *name;\n  int num;\n};\n\n#define PK11_SETATTRS(_attr, _idx, _type, _val, _len) do {  \\\n  CK_ATTRIBUTE *ptr = (_attr) + ((_idx)++);                 \\\n  ptr->type = (_type);                                      \\\n  ptr->pValue = (_val);                                     \\\n  ptr->ulValueLen = (_len);                                 \\\n} while(0)\n\n#define CERT_NewTempCertificate __CERT_NewTempCertificate\n\n#define NUM_OF_CIPHERS sizeof(cipherlist)/sizeof(cipherlist[0])\nstatic const struct cipher_s cipherlist[] = {\n  /* SSL2 cipher suites */\n  {\"rc4\",                        SSL_EN_RC4_128_WITH_MD5},\n  {\"rc4-md5\",                    SSL_EN_RC4_128_WITH_MD5},\n  {\"rc4export\",                  SSL_EN_RC4_128_EXPORT40_WITH_MD5},\n  {\"rc2\",                        SSL_EN_RC2_128_CBC_WITH_MD5},\n  {\"rc2export\",                  SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5},\n  {\"des\",                        SSL_EN_DES_64_CBC_WITH_MD5},\n  {\"desede3\",                    SSL_EN_DES_192_EDE3_CBC_WITH_MD5},\n  /* SSL3/TLS cipher suites */\n  {\"rsa_rc4_128_md5\",            SSL_RSA_WITH_RC4_128_MD5},\n  {\"rsa_rc4_128_sha\",            SSL_RSA_WITH_RC4_128_SHA},\n  {\"rsa_3des_sha\",               SSL_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"rsa_des_sha\",                SSL_RSA_WITH_DES_CBC_SHA},\n  {\"rsa_rc4_40_md5\",             SSL_RSA_EXPORT_WITH_RC4_40_MD5},\n  {\"rsa_rc2_40_md5\",             SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5},\n  {\"rsa_null_md5\",               SSL_RSA_WITH_NULL_MD5},\n  {\"rsa_null_sha\",               SSL_RSA_WITH_NULL_SHA},\n  {\"fips_3des_sha\",              SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA},\n  {\"fips_des_sha\",               SSL_RSA_FIPS_WITH_DES_CBC_SHA},\n  {\"fortezza\",                   SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA},\n  {\"fortezza_rc4_128_sha\",       SSL_FORTEZZA_DMS_WITH_RC4_128_SHA},\n  {\"fortezza_null\",              SSL_FORTEZZA_DMS_WITH_NULL_SHA},\n  {\"dhe_rsa_3des_sha\",           SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"dhe_dss_3des_sha\",           SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA},\n  {\"dhe_rsa_des_sha\",            SSL_DHE_RSA_WITH_DES_CBC_SHA},\n  {\"dhe_dss_des_sha\",            SSL_DHE_DSS_WITH_DES_CBC_SHA},\n  /* TLS 1.0: Exportable 56-bit Cipher Suites. */\n  {\"rsa_des_56_sha\",             TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA},\n  {\"rsa_rc4_56_sha\",             TLS_RSA_EXPORT1024_WITH_RC4_56_SHA},\n  /* Ephemeral DH with RC4 bulk encryption */\n  {\"dhe_dss_rc4_128_sha\",    TLS_DHE_DSS_WITH_RC4_128_SHA},\n  /* AES ciphers. */\n  {\"dhe_dss_aes_128_cbc_sha\",    TLS_DHE_DSS_WITH_AES_128_CBC_SHA},\n  {\"dhe_dss_aes_256_cbc_sha\",    TLS_DHE_DSS_WITH_AES_256_CBC_SHA},\n  {\"dhe_rsa_aes_128_cbc_sha\",    TLS_DHE_RSA_WITH_AES_128_CBC_SHA},\n  {\"dhe_rsa_aes_256_cbc_sha\",    TLS_DHE_RSA_WITH_AES_256_CBC_SHA},\n  {\"rsa_aes_128_sha\",            TLS_RSA_WITH_AES_128_CBC_SHA},\n  {\"rsa_aes_256_sha\",            TLS_RSA_WITH_AES_256_CBC_SHA},\n  /* ECC ciphers. */\n  {\"ecdh_ecdsa_null_sha\",        TLS_ECDH_ECDSA_WITH_NULL_SHA},\n  {\"ecdh_ecdsa_rc4_128_sha\",     TLS_ECDH_ECDSA_WITH_RC4_128_SHA},\n  {\"ecdh_ecdsa_3des_sha\",        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_ecdsa_aes_128_sha\",     TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA},\n  {\"ecdh_ecdsa_aes_256_sha\",     TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA},\n  {\"ecdhe_ecdsa_null_sha\",       TLS_ECDHE_ECDSA_WITH_NULL_SHA},\n  {\"ecdhe_ecdsa_rc4_128_sha\",    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA},\n  {\"ecdhe_ecdsa_3des_sha\",       TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdhe_ecdsa_aes_128_sha\",    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA},\n  {\"ecdhe_ecdsa_aes_256_sha\",    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA},\n  {\"ecdh_rsa_null_sha\",          TLS_ECDH_RSA_WITH_NULL_SHA},\n  {\"ecdh_rsa_128_sha\",           TLS_ECDH_RSA_WITH_RC4_128_SHA},\n  {\"ecdh_rsa_3des_sha\",          TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_rsa_aes_128_sha\",       TLS_ECDH_RSA_WITH_AES_128_CBC_SHA},\n  {\"ecdh_rsa_aes_256_sha\",       TLS_ECDH_RSA_WITH_AES_256_CBC_SHA},\n  {\"ecdhe_rsa_null\",             TLS_ECDHE_RSA_WITH_NULL_SHA},\n  {\"ecdhe_rsa_rc4_128_sha\",      TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n  {\"ecdhe_rsa_3des_sha\",         TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdhe_rsa_aes_128_sha\",      TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA},\n  {\"ecdhe_rsa_aes_256_sha\",      TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA},\n  {\"ecdh_anon_null_sha\",         TLS_ECDH_anon_WITH_NULL_SHA},\n  {\"ecdh_anon_rc4_128sha\",       TLS_ECDH_anon_WITH_RC4_128_SHA},\n  {\"ecdh_anon_3des_sha\",         TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_anon_aes_128_sha\",      TLS_ECDH_anon_WITH_AES_128_CBC_SHA},\n  {\"ecdh_anon_aes_256_sha\",      TLS_ECDH_anon_WITH_AES_256_CBC_SHA},\n#ifdef TLS_RSA_WITH_NULL_SHA256\n  /* new HMAC-SHA256 cipher suites specified in RFC */\n  {\"rsa_null_sha_256\",                TLS_RSA_WITH_NULL_SHA256},\n  {\"rsa_aes_128_cbc_sha_256\",         TLS_RSA_WITH_AES_128_CBC_SHA256},\n  {\"rsa_aes_256_cbc_sha_256\",         TLS_RSA_WITH_AES_256_CBC_SHA256},\n  {\"dhe_rsa_aes_128_cbc_sha_256\",     TLS_DHE_RSA_WITH_AES_128_CBC_SHA256},\n  {\"dhe_rsa_aes_256_cbc_sha_256\",     TLS_DHE_RSA_WITH_AES_256_CBC_SHA256},\n  {\"ecdhe_ecdsa_aes_128_cbc_sha_256\", TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256},\n  {\"ecdhe_rsa_aes_128_cbc_sha_256\",   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256},\n#endif\n#ifdef TLS_RSA_WITH_AES_128_GCM_SHA256\n  /* AES GCM cipher suites in RFC 5288 and RFC 5289 */\n  {\"rsa_aes_128_gcm_sha_256\",         TLS_RSA_WITH_AES_128_GCM_SHA256},\n  {\"dhe_rsa_aes_128_gcm_sha_256\",     TLS_DHE_RSA_WITH_AES_128_GCM_SHA256},\n  {\"dhe_dss_aes_128_gcm_sha_256\",     TLS_DHE_DSS_WITH_AES_128_GCM_SHA256},\n  {\"ecdhe_ecdsa_aes_128_gcm_sha_256\", TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdh_ecdsa_aes_128_gcm_sha_256\",  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdhe_rsa_aes_128_gcm_sha_256\",   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdh_rsa_aes_128_gcm_sha_256\",    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256},\n#endif\n#ifdef TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n  /* cipher suites using SHA384 */\n  {\"rsa_aes_256_gcm_sha_384\",         TLS_RSA_WITH_AES_256_GCM_SHA384},\n  {\"dhe_rsa_aes_256_gcm_sha_384\",     TLS_DHE_RSA_WITH_AES_256_GCM_SHA384},\n  {\"dhe_dss_aes_256_gcm_sha_384\",     TLS_DHE_DSS_WITH_AES_256_GCM_SHA384},\n  {\"ecdhe_ecdsa_aes_256_sha_384\",     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384},\n  {\"ecdhe_rsa_aes_256_sha_384\",       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384},\n  {\"ecdhe_ecdsa_aes_256_gcm_sha_384\", TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384},\n  {\"ecdhe_rsa_aes_256_gcm_sha_384\",   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384},\n#endif\n#ifdef TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n  /* chacha20-poly1305 cipher suites */\n {\"ecdhe_rsa_chacha20_poly1305_sha_256\",\n     TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256},\n {\"ecdhe_ecdsa_chacha20_poly1305_sha_256\",\n     TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256},\n {\"dhe_rsa_chacha20_poly1305_sha_256\",\n     TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256},\n#endif\n#ifdef TLS_AES_256_GCM_SHA384\n {\"aes_128_gcm_sha_256\",              TLS_AES_128_GCM_SHA256},\n {\"aes_256_gcm_sha_384\",              TLS_AES_256_GCM_SHA384},\n {\"chacha20_poly1305_sha_256\",        TLS_CHACHA20_POLY1305_SHA256},\n#endif\n#ifdef TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\n  /* AES CBC cipher suites in RFC 5246. Introduced in NSS release 3.20 */\n  {\"dhe_dss_aes_128_sha_256\",         TLS_DHE_DSS_WITH_AES_128_CBC_SHA256},\n  {\"dhe_dss_aes_256_sha_256\",         TLS_DHE_DSS_WITH_AES_256_CBC_SHA256},\n#endif\n#ifdef TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\n  /* Camellia cipher suites in RFC 4132/5932.\n     Introduced in NSS release 3.12 */\n  {\"dhe_rsa_camellia_128_sha\",        TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA},\n  {\"dhe_dss_camellia_128_sha\",        TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA},\n  {\"dhe_rsa_camellia_256_sha\",        TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA},\n  {\"dhe_dss_camellia_256_sha\",        TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA},\n  {\"rsa_camellia_128_sha\",            TLS_RSA_WITH_CAMELLIA_128_CBC_SHA},\n  {\"rsa_camellia_256_sha\",            TLS_RSA_WITH_CAMELLIA_256_CBC_SHA},\n#endif\n#ifdef TLS_RSA_WITH_SEED_CBC_SHA\n  /* SEED cipher suite in RFC 4162. Introduced in NSS release 3.12.3 */\n  {\"rsa_seed_sha\",                    TLS_RSA_WITH_SEED_CBC_SHA},\n#endif\n};\n\n#if defined(WIN32)\nstatic const char *pem_library = \"nsspem.dll\";\nstatic const char *trust_library = \"nssckbi.dll\";\n#elif defined(__APPLE__)\nstatic const char *pem_library = \"libnsspem.dylib\";\nstatic const char *trust_library = \"libnssckbi.dylib\";\n#else\nstatic const char *pem_library = \"libnsspem.so\";\nstatic const char *trust_library = \"libnssckbi.so\";\n#endif\n\nstatic SECMODModule *pem_module = NULL;\nstatic SECMODModule *trust_module = NULL;\n\n/* NSPR I/O layer we use to detect blocking direction during SSL handshake */\nstatic PRDescIdentity nspr_io_identity = PR_INVALID_IO_LAYER;\nstatic PRIOMethods nspr_io_methods;\n\nstatic const char *nss_error_to_name(PRErrorCode code)\n{\n  const char *name = PR_ErrorToName(code);\n  if(name)\n    return name;\n\n  return \"unknown error\";\n}\n\nstatic void nss_print_error_message(struct Curl_easy *data, PRUint32 err)\n{\n  failf(data, \"%s\", PR_ErrorToString(err, PR_LANGUAGE_I_DEFAULT));\n}\n\nstatic char *nss_sslver_to_name(PRUint16 nssver)\n{\n  switch(nssver) {\n  case SSL_LIBRARY_VERSION_2:\n    return strdup(\"SSLv2\");\n  case SSL_LIBRARY_VERSION_3_0:\n    return strdup(\"SSLv3\");\n  case SSL_LIBRARY_VERSION_TLS_1_0:\n    return strdup(\"TLSv1.0\");\n#ifdef SSL_LIBRARY_VERSION_TLS_1_1\n  case SSL_LIBRARY_VERSION_TLS_1_1:\n    return strdup(\"TLSv1.1\");\n#endif\n#ifdef SSL_LIBRARY_VERSION_TLS_1_2\n  case SSL_LIBRARY_VERSION_TLS_1_2:\n    return strdup(\"TLSv1.2\");\n#endif\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n  case SSL_LIBRARY_VERSION_TLS_1_3:\n    return strdup(\"TLSv1.3\");\n#endif\n  default:\n    return curl_maprintf(\"0x%04x\", nssver);\n  }\n}\n\nstatic SECStatus set_ciphers(struct Curl_easy *data, PRFileDesc * model,\n                             char *cipher_list)\n{\n  unsigned int i;\n  PRBool cipher_state[NUM_OF_CIPHERS];\n  PRBool found;\n  char *cipher;\n\n  /* use accessors to avoid dynamic linking issues after an update of NSS */\n  const PRUint16 num_implemented_ciphers = SSL_GetNumImplementedCiphers();\n  const PRUint16 *implemented_ciphers = SSL_GetImplementedCiphers();\n  if(!implemented_ciphers)\n    return SECFailure;\n\n  /* First disable all ciphers. This uses a different max value in case\n   * NSS adds more ciphers later we don't want them available by\n   * accident\n   */\n  for(i = 0; i < num_implemented_ciphers; i++) {\n    SSL_CipherPrefSet(model, implemented_ciphers[i], PR_FALSE);\n  }\n\n  /* Set every entry in our list to false */\n  for(i = 0; i < NUM_OF_CIPHERS; i++) {\n    cipher_state[i] = PR_FALSE;\n  }\n\n  cipher = cipher_list;\n\n  while(cipher_list && (cipher_list[0])) {\n    while((*cipher) && (ISSPACE(*cipher)))\n      ++cipher;\n\n    cipher_list = strpbrk(cipher, \":, \");\n    if(cipher_list) {\n      *cipher_list++ = '\\0';\n    }\n\n    found = PR_FALSE;\n\n    for(i = 0; i<NUM_OF_CIPHERS; i++) {\n      if(strcasecompare(cipher, cipherlist[i].name)) {\n        cipher_state[i] = PR_TRUE;\n        found = PR_TRUE;\n        break;\n      }\n    }\n\n    if(found == PR_FALSE) {\n      failf(data, \"Unknown cipher in list: %s\", cipher);\n      return SECFailure;\n    }\n\n    if(cipher_list) {\n      cipher = cipher_list;\n    }\n  }\n\n  /* Finally actually enable the selected ciphers */\n  for(i = 0; i<NUM_OF_CIPHERS; i++) {\n    if(!cipher_state[i])\n      continue;\n\n    if(SSL_CipherPrefSet(model, cipherlist[i].num, PR_TRUE) != SECSuccess) {\n      failf(data, \"cipher-suite not supported by NSS: %s\", cipherlist[i].name);\n      return SECFailure;\n    }\n  }\n\n  return SECSuccess;\n}\n\n/*\n * Return true if at least one cipher-suite is enabled. Used to determine\n * if we need to call NSS_SetDomesticPolicy() to enable the default ciphers.\n */\nstatic bool any_cipher_enabled(void)\n{\n  unsigned int i;\n\n  for(i = 0; i<NUM_OF_CIPHERS; i++) {\n    PRInt32 policy = 0;\n    SSL_CipherPolicyGet(cipherlist[i].num, &policy);\n    if(policy)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n/*\n * Determine whether the nickname passed in is a filename that needs to\n * be loaded as a PEM or a regular NSS nickname.\n *\n * returns 1 for a file\n * returns 0 for not a file (NSS nickname)\n */\nstatic int is_file(const char *filename)\n{\n  struct_stat st;\n\n  if(!filename)\n    return 0;\n\n  if(stat(filename, &st) == 0)\n    if(S_ISREG(st.st_mode) || S_ISFIFO(st.st_mode) || S_ISCHR(st.st_mode))\n      return 1;\n\n  return 0;\n}\n\n/* Check if the given string is filename or nickname of a certificate.  If the\n * given string is recognized as filename, return NULL.  If the given string is\n * recognized as nickname, return a duplicated string.  The returned string\n * should be later deallocated using free().  If the OOM failure occurs, we\n * return NULL, too.\n */\nstatic char *dup_nickname(struct Curl_easy *data, const char *str)\n{\n  const char *n;\n\n  if(!is_file(str))\n    /* no such file exists, use the string as nickname */\n    return strdup(str);\n\n  /* search the first slash; we require at least one slash in a file name */\n  n = strchr(str, '/');\n  if(!n) {\n    infof(data, \"warning: certificate file name \\\"%s\\\" handled as nickname; \"\n          \"please use \\\"./%s\\\" to force file name\\n\", str, str);\n    return strdup(str);\n  }\n\n  /* we'll use the PEM reader to read the certificate from file */\n  return NULL;\n}\n\n/* Lock/unlock wrapper for PK11_FindSlotByName() to work around race condition\n * in nssSlot_IsTokenPresent() causing spurious SEC_ERROR_NO_TOKEN.  For more\n * details, go to <https://bugzilla.mozilla.org/1297397>.\n */\nstatic PK11SlotInfo* nss_find_slot_by_name(const char *slot_name)\n{\n  PK11SlotInfo *slot;\n  PR_Lock(nss_findslot_lock);\n  slot = PK11_FindSlotByName(slot_name);\n  PR_Unlock(nss_findslot_lock);\n  return slot;\n}\n\n/* wrap 'ptr' as list node and tail-insert into 'list' */\nstatic CURLcode insert_wrapped_ptr(struct Curl_llist *list, void *ptr)\n{\n  struct ptr_list_wrap *wrap = malloc(sizeof(*wrap));\n  if(!wrap)\n    return CURLE_OUT_OF_MEMORY;\n\n  wrap->ptr = ptr;\n  Curl_llist_insert_next(list, list->tail, wrap, &wrap->node);\n  return CURLE_OK;\n}\n\n/* Call PK11_CreateGenericObject() with the given obj_class and filename.  If\n * the call succeeds, append the object handle to the list of objects so that\n * the object can be destroyed in nss_close(). */\nstatic CURLcode nss_create_object(struct ssl_connect_data *connssl,\n                                  CK_OBJECT_CLASS obj_class,\n                                  const char *filename, bool cacert)\n{\n  PK11SlotInfo *slot;\n  PK11GenericObject *obj;\n  CK_BBOOL cktrue = CK_TRUE;\n  CK_BBOOL ckfalse = CK_FALSE;\n  CK_ATTRIBUTE attrs[/* max count of attributes */ 4];\n  int attr_cnt = 0;\n  CURLcode result = (cacert)\n    ? CURLE_SSL_CACERT_BADFILE\n    : CURLE_SSL_CERTPROBLEM;\n\n  const int slot_id = (cacert) ? 0 : 1;\n  char *slot_name = aprintf(\"PEM Token #%d\", slot_id);\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!slot_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  slot = nss_find_slot_by_name(slot_name);\n  free(slot_name);\n  if(!slot)\n    return result;\n\n  PK11_SETATTRS(attrs, attr_cnt, CKA_CLASS, &obj_class, sizeof(obj_class));\n  PK11_SETATTRS(attrs, attr_cnt, CKA_TOKEN, &cktrue, sizeof(CK_BBOOL));\n  PK11_SETATTRS(attrs, attr_cnt, CKA_LABEL, (unsigned char *)filename,\n                (CK_ULONG)strlen(filename) + 1);\n\n  if(CKO_CERTIFICATE == obj_class) {\n    CK_BBOOL *pval = (cacert) ? (&cktrue) : (&ckfalse);\n    PK11_SETATTRS(attrs, attr_cnt, CKA_TRUST, pval, sizeof(*pval));\n  }\n\n  /* PK11_CreateManagedGenericObject() was introduced in NSS 3.34 because\n   * PK11_DestroyGenericObject() does not release resources allocated by\n   * PK11_CreateGenericObject() early enough.  */\n  obj =\n#ifdef HAVE_PK11_CREATEMANAGEDGENERICOBJECT\n    PK11_CreateManagedGenericObject\n#else\n    PK11_CreateGenericObject\n#endif\n    (slot, attrs, attr_cnt, PR_FALSE);\n\n  PK11_FreeSlot(slot);\n  if(!obj)\n    return result;\n\n  if(insert_wrapped_ptr(&backend->obj_list, obj) != CURLE_OK) {\n    PK11_DestroyGenericObject(obj);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(!cacert && CKO_CERTIFICATE == obj_class)\n    /* store reference to a client certificate */\n    backend->obj_clicert = obj;\n\n  return CURLE_OK;\n}\n\n/* Destroy the NSS object whose handle is given by ptr.  This function is\n * a callback of Curl_llist_alloc() used by Curl_llist_destroy() to destroy\n * NSS objects in nss_close() */\nstatic void nss_destroy_object(void *user, void *ptr)\n{\n  struct ptr_list_wrap *wrap = (struct ptr_list_wrap *) ptr;\n  PK11GenericObject *obj = (PK11GenericObject *) wrap->ptr;\n  (void) user;\n  PK11_DestroyGenericObject(obj);\n  free(wrap);\n}\n\n/* same as nss_destroy_object() but for CRL items */\nstatic void nss_destroy_crl_item(void *user, void *ptr)\n{\n  struct ptr_list_wrap *wrap = (struct ptr_list_wrap *) ptr;\n  SECItem *crl_der = (SECItem *) wrap->ptr;\n  (void) user;\n  SECITEM_FreeItem(crl_der, PR_TRUE);\n  free(wrap);\n}\n\nstatic CURLcode nss_load_cert(struct ssl_connect_data *ssl,\n                              const char *filename, PRBool cacert)\n{\n  CURLcode result = (cacert)\n    ? CURLE_SSL_CACERT_BADFILE\n    : CURLE_SSL_CERTPROBLEM;\n\n  /* libnsspem.so leaks memory if the requested file does not exist.  For more\n   * details, go to <https://bugzilla.redhat.com/734760>. */\n  if(is_file(filename))\n    result = nss_create_object(ssl, CKO_CERTIFICATE, filename, cacert);\n\n  if(!result && !cacert) {\n    /* we have successfully loaded a client certificate */\n    char *nickname = NULL;\n    char *n = strrchr(filename, '/');\n    if(n)\n      n++;\n\n    /* The following undocumented magic helps to avoid a SIGSEGV on call\n     * of PK11_ReadRawAttribute() from SelectClientCert() when using an\n     * immature version of libnsspem.so.  For more details, go to\n     * <https://bugzilla.redhat.com/733685>. */\n    nickname = aprintf(\"PEM Token #1:%s\", n);\n    if(nickname) {\n      CERTCertificate *cert = PK11_FindCertFromNickname(nickname, NULL);\n      if(cert)\n        CERT_DestroyCertificate(cert);\n\n      free(nickname);\n    }\n  }\n\n  return result;\n}\n\n/* add given CRL to cache if it is not already there */\nstatic CURLcode nss_cache_crl(SECItem *crl_der)\n{\n  CERTCertDBHandle *db = CERT_GetDefaultCertDB();\n  CERTSignedCrl *crl = SEC_FindCrlByDERCert(db, crl_der, 0);\n  if(crl) {\n    /* CRL already cached */\n    SEC_DestroyCrl(crl);\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    return CURLE_OK;\n  }\n\n  /* acquire lock before call of CERT_CacheCRL() and accessing nss_crl_list */\n  PR_Lock(nss_crllock);\n\n  if(SECSuccess != CERT_CacheCRL(db, crl_der)) {\n    /* unable to cache CRL */\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_SSL_CRL_BADFILE;\n  }\n\n  /* store the CRL item so that we can free it in nss_cleanup() */\n  if(insert_wrapped_ptr(&nss_crl_list, crl_der) != CURLE_OK) {\n    if(SECSuccess == CERT_UncacheCRL(db, crl_der))\n      SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  /* we need to clear session cache, so that the CRL could take effect */\n  SSL_ClearSessionCache();\n  PR_Unlock(nss_crllock);\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_load_crl(const char *crlfilename)\n{\n  PRFileDesc *infile;\n  PRFileInfo  info;\n  SECItem filedata = { 0, NULL, 0 };\n  SECItem *crl_der = NULL;\n  char *body;\n\n  infile = PR_Open(crlfilename, PR_RDONLY, 0);\n  if(!infile)\n    return CURLE_SSL_CRL_BADFILE;\n\n  if(PR_SUCCESS != PR_GetOpenFileInfo(infile, &info))\n    goto fail;\n\n  if(!SECITEM_AllocItem(NULL, &filedata, info.size + /* zero ended */ 1))\n    goto fail;\n\n  if(info.size != PR_Read(infile, filedata.data, info.size))\n    goto fail;\n\n  crl_der = SECITEM_AllocItem(NULL, NULL, 0U);\n  if(!crl_der)\n    goto fail;\n\n  /* place a trailing zero right after the visible data */\n  body = (char *)filedata.data;\n  body[--filedata.len] = '\\0';\n\n  body = strstr(body, \"-----BEGIN\");\n  if(body) {\n    /* assume ASCII */\n    char *trailer;\n    char *begin = PORT_Strchr(body, '\\n');\n    if(!begin)\n      begin = PORT_Strchr(body, '\\r');\n    if(!begin)\n      goto fail;\n\n    trailer = strstr(++begin, \"-----END\");\n    if(!trailer)\n      goto fail;\n\n    /* retrieve DER from ASCII */\n    *trailer = '\\0';\n    if(ATOB_ConvertAsciiToItem(crl_der, begin))\n      goto fail;\n\n    SECITEM_FreeItem(&filedata, PR_FALSE);\n  }\n  else\n    /* assume DER */\n    *crl_der = filedata;\n\n  PR_Close(infile);\n  return nss_cache_crl(crl_der);\n\nfail:\n  PR_Close(infile);\n  SECITEM_FreeItem(crl_der, PR_TRUE);\n  SECITEM_FreeItem(&filedata, PR_FALSE);\n  return CURLE_SSL_CRL_BADFILE;\n}\n\nstatic CURLcode nss_load_key(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, char *key_file)\n{\n  PK11SlotInfo *slot, *tmp;\n  SECStatus status;\n  CURLcode result;\n  struct ssl_connect_data *ssl = conn->ssl;\n\n  (void)sockindex; /* unused */\n\n  result = nss_create_object(ssl, CKO_PRIVATE_KEY, key_file, FALSE);\n  if(result) {\n    PR_SetError(SEC_ERROR_BAD_KEY, 0);\n    return result;\n  }\n\n  slot = nss_find_slot_by_name(\"PEM Token #1\");\n  if(!slot)\n    return CURLE_SSL_CERTPROBLEM;\n\n  /* This will force the token to be seen as re-inserted */\n  tmp = SECMOD_WaitForAnyTokenEvent(pem_module, 0, 0);\n  if(tmp)\n    PK11_FreeSlot(tmp);\n  if(!PK11_IsPresent(slot)) {\n    PK11_FreeSlot(slot);\n    return CURLE_SSL_CERTPROBLEM;\n  }\n\n  status = PK11_Authenticate(slot, PR_TRUE, SSL_SET_OPTION(key_passwd));\n  PK11_FreeSlot(slot);\n\n  return (SECSuccess == status) ? CURLE_OK : CURLE_SSL_CERTPROBLEM;\n}\n\nstatic int display_error(struct Curl_easy *data, PRInt32 err,\n                         const char *filename)\n{\n  switch(err) {\n  case SEC_ERROR_BAD_PASSWORD:\n    failf(data, \"Unable to load client key: Incorrect password\");\n    return 1;\n  case SEC_ERROR_UNKNOWN_CERT:\n    failf(data, \"Unable to load certificate %s\", filename);\n    return 1;\n  default:\n    break;\n  }\n  return 0; /* The caller will print a generic error */\n}\n\nstatic CURLcode cert_stuff(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex, char *cert_file, char *key_file)\n{\n  CURLcode result;\n\n  if(cert_file) {\n    result = nss_load_cert(&conn->ssl[sockindex], cert_file, PR_FALSE);\n    if(result) {\n      const PRErrorCode err = PR_GetError();\n      if(!display_error(data, err, cert_file)) {\n        const char *err_name = nss_error_to_name(err);\n        failf(data, \"unable to load client cert: %d (%s)\", err, err_name);\n      }\n\n      return result;\n    }\n  }\n\n  if(key_file || (is_file(cert_file))) {\n    if(key_file)\n      result = nss_load_key(data, conn, sockindex, key_file);\n    else\n      /* In case the cert file also has the key */\n      result = nss_load_key(data, conn, sockindex, cert_file);\n    if(result) {\n      const PRErrorCode err = PR_GetError();\n      if(!display_error(data, err, key_file)) {\n        const char *err_name = nss_error_to_name(err);\n        failf(data, \"unable to load client key: %d (%s)\", err, err_name);\n      }\n\n      return result;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic char *nss_get_password(PK11SlotInfo *slot, PRBool retry, void *arg)\n{\n  (void)slot; /* unused */\n\n  if(retry || NULL == arg)\n    return NULL;\n  else\n    return (char *)PORT_Strdup((char *)arg);\n}\n\n/* bypass the default SSL_AuthCertificate() hook in case we do not want to\n * verify peer */\nstatic SECStatus nss_auth_cert_hook(void *arg, PRFileDesc *fd, PRBool checksig,\n                                    PRBool isServer)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    SECStatus cacheResult;\n\n    const SECItemArray *csa = SSL_PeerStapledOCSPResponses(fd);\n    if(!csa) {\n      failf(data, \"Invalid OCSP response\");\n      return SECFailure;\n    }\n\n    if(csa->len == 0) {\n      failf(data, \"No OCSP response received\");\n      return SECFailure;\n    }\n\n    cacheResult = CERT_CacheOCSPResponseFromSideChannel(\n      CERT_GetDefaultCertDB(), SSL_PeerCertificate(fd),\n      PR_Now(), &csa->items[0], arg\n    );\n\n    if(cacheResult != SECSuccess) {\n      failf(data, \"Invalid OCSP response\");\n      return cacheResult;\n    }\n  }\n#endif\n\n  if(!SSL_CONN_CONFIG(verifypeer)) {\n    infof(data, \"skipping SSL peer certificate verification\\n\");\n    return SECSuccess;\n  }\n\n  return SSL_AuthCertificate(CERT_GetDefaultCertDB(), fd, checksig, isServer);\n}\n\n/**\n * Inform the application that the handshake is complete.\n */\nstatic void HandshakeCallback(PRFileDesc *sock, void *arg)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  unsigned int buflenmax = 50;\n  unsigned char buf[50];\n  unsigned int buflen;\n  SSLNextProtoState state;\n\n  if(!conn->bits.tls_enable_npn && !conn->bits.tls_enable_alpn) {\n    return;\n  }\n\n  if(SSL_GetNextProto(sock, &state, buf, &buflen, buflenmax) == SECSuccess) {\n\n    switch(state) {\n#if NSSVERNUM >= 0x031a00 /* 3.26.0 */\n    /* used by NSS internally to implement 0-RTT */\n    case SSL_NEXT_PROTO_EARLY_VALUE:\n      /* fall through! */\n#endif\n    case SSL_NEXT_PROTO_NO_SUPPORT:\n    case SSL_NEXT_PROTO_NO_OVERLAP:\n      infof(data, \"ALPN/NPN, server did not agree to a protocol\\n\");\n      return;\n#ifdef SSL_ENABLE_ALPN\n    case SSL_NEXT_PROTO_SELECTED:\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", buflen, buf);\n      break;\n#endif\n    case SSL_NEXT_PROTO_NEGOTIATED:\n      infof(data, \"NPN, server accepted to use %.*s\\n\", buflen, buf);\n      break;\n    }\n\n#ifdef USE_NGHTTP2\n    if(buflen == ALPN_H2_LENGTH &&\n       !memcmp(ALPN_H2, buf, ALPN_H2_LENGTH)) {\n      conn->negnpn = CURL_HTTP_VERSION_2;\n    }\n    else\n#endif\n    if(buflen == ALPN_HTTP_1_1_LENGTH &&\n       !memcmp(ALPN_HTTP_1_1, buf, ALPN_HTTP_1_1_LENGTH)) {\n      conn->negnpn = CURL_HTTP_VERSION_1_1;\n    }\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n}\n\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\nstatic SECStatus CanFalseStartCallback(PRFileDesc *sock, void *client_data,\n                                       PRBool *canFalseStart)\n{\n  struct Curl_easy *data = (struct Curl_easy *)client_data;\n\n  SSLChannelInfo channelInfo;\n  SSLCipherSuiteInfo cipherInfo;\n\n  SECStatus rv;\n  PRBool negotiatedExtension;\n\n  *canFalseStart = PR_FALSE;\n\n  if(SSL_GetChannelInfo(sock, &channelInfo, sizeof(channelInfo)) != SECSuccess)\n    return SECFailure;\n\n  if(SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherInfo,\n                            sizeof(cipherInfo)) != SECSuccess)\n    return SECFailure;\n\n  /* Prevent version downgrade attacks from TLS 1.2, and avoid False Start for\n   * TLS 1.3 and later. See https://bugzilla.mozilla.org/show_bug.cgi?id=861310\n   */\n  if(channelInfo.protocolVersion != SSL_LIBRARY_VERSION_TLS_1_2)\n    goto end;\n\n  /* Only allow ECDHE key exchange algorithm.\n   * See https://bugzilla.mozilla.org/show_bug.cgi?id=952863 */\n  if(cipherInfo.keaType != ssl_kea_ecdh)\n    goto end;\n\n  /* Prevent downgrade attacks on the symmetric cipher. We do not allow CBC\n   * mode due to BEAST, POODLE, and other attacks on the MAC-then-Encrypt\n   * design. See https://bugzilla.mozilla.org/show_bug.cgi?id=1109766 */\n  if(cipherInfo.symCipher != ssl_calg_aes_gcm)\n    goto end;\n\n  /* Enforce ALPN or NPN to do False Start, as an indicator of server\n   * compatibility. */\n  rv = SSL_HandshakeNegotiatedExtension(sock, ssl_app_layer_protocol_xtn,\n                                        &negotiatedExtension);\n  if(rv != SECSuccess || !negotiatedExtension) {\n    rv = SSL_HandshakeNegotiatedExtension(sock, ssl_next_proto_nego_xtn,\n                                          &negotiatedExtension);\n  }\n\n  if(rv != SECSuccess || !negotiatedExtension)\n    goto end;\n\n  *canFalseStart = PR_TRUE;\n\n  infof(data, \"Trying TLS False Start\\n\");\n\nend:\n  return SECSuccess;\n}\n#endif\n\nstatic void display_cert_info(struct Curl_easy *data,\n                              CERTCertificate *cert)\n{\n  char *subject, *issuer, *common_name;\n  PRExplodedTime printableTime;\n  char timeString[256];\n  PRTime notBefore, notAfter;\n\n  subject = CERT_NameToAscii(&cert->subject);\n  issuer = CERT_NameToAscii(&cert->issuer);\n  common_name = CERT_GetCommonName(&cert->subject);\n  infof(data, \"\\tsubject: %s\\n\", subject);\n\n  CERT_GetCertTimes(cert, &notBefore, &notAfter);\n  PR_ExplodeTime(notBefore, PR_GMTParameters, &printableTime);\n  PR_FormatTime(timeString, 256, \"%b %d %H:%M:%S %Y GMT\", &printableTime);\n  infof(data, \"\\tstart date: %s\\n\", timeString);\n  PR_ExplodeTime(notAfter, PR_GMTParameters, &printableTime);\n  PR_FormatTime(timeString, 256, \"%b %d %H:%M:%S %Y GMT\", &printableTime);\n  infof(data, \"\\texpire date: %s\\n\", timeString);\n  infof(data, \"\\tcommon name: %s\\n\", common_name);\n  infof(data, \"\\tissuer: %s\\n\", issuer);\n\n  PR_Free(subject);\n  PR_Free(issuer);\n  PR_Free(common_name);\n}\n\nstatic CURLcode display_conn_info(struct Curl_easy *data, PRFileDesc *sock)\n{\n  CURLcode result = CURLE_OK;\n  SSLChannelInfo channel;\n  SSLCipherSuiteInfo suite;\n  CERTCertificate *cert;\n  CERTCertificate *cert2;\n  CERTCertificate *cert3;\n  PRTime now;\n\n  if(SSL_GetChannelInfo(sock, &channel, sizeof(channel)) ==\n     SECSuccess && channel.length == sizeof(channel) &&\n     channel.cipherSuite) {\n    if(SSL_GetCipherSuiteInfo(channel.cipherSuite,\n                              &suite, sizeof(suite)) == SECSuccess) {\n      infof(data, \"SSL connection using %s\\n\", suite.cipherSuiteName);\n    }\n  }\n\n  cert = SSL_PeerCertificate(sock);\n  if(cert) {\n    infof(data, \"Server certificate:\\n\");\n\n    if(!data->set.ssl.certinfo) {\n      display_cert_info(data, cert);\n      CERT_DestroyCertificate(cert);\n    }\n    else {\n      /* Count certificates in chain. */\n      int i = 1;\n      now = PR_Now();\n      if(!cert->isRoot) {\n        cert2 = CERT_FindCertIssuer(cert, now, certUsageSSLCA);\n        while(cert2) {\n          i++;\n          if(cert2->isRoot) {\n            CERT_DestroyCertificate(cert2);\n            break;\n          }\n          cert3 = CERT_FindCertIssuer(cert2, now, certUsageSSLCA);\n          CERT_DestroyCertificate(cert2);\n          cert2 = cert3;\n        }\n      }\n\n      result = Curl_ssl_init_certinfo(data, i);\n      if(!result) {\n        for(i = 0; cert; cert = cert2) {\n          result = Curl_extract_certinfo(data, i++, (char *)cert->derCert.data,\n                                         (char *)cert->derCert.data +\n                                                 cert->derCert.len);\n          if(result)\n            break;\n\n          if(cert->isRoot) {\n            CERT_DestroyCertificate(cert);\n            break;\n          }\n\n          cert2 = CERT_FindCertIssuer(cert, now, certUsageSSLCA);\n          CERT_DestroyCertificate(cert);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nstatic SECStatus BadCertHandler(void *arg, PRFileDesc *sock)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  PRErrorCode err = PR_GetError();\n  CERTCertificate *cert;\n\n  /* remember the cert verification result */\n  SSL_SET_OPTION_LVALUE(certverifyresult) = err;\n\n  if(err == SSL_ERROR_BAD_CERT_DOMAIN && !SSL_CONN_CONFIG(verifyhost))\n    /* we are asked not to verify the host name */\n    return SECSuccess;\n\n  /* print only info about the cert, the error is printed off the callback */\n  cert = SSL_PeerCertificate(sock);\n  if(cert) {\n    infof(data, \"Server certificate:\\n\");\n    display_cert_info(data, cert);\n    CERT_DestroyCertificate(cert);\n  }\n\n  return SECFailure;\n}\n\n/**\n *\n * Check that the Peer certificate's issuer certificate matches the one found\n * by issuer_nickname.  This is not exactly the way OpenSSL and GNU TLS do the\n * issuer check, so we provide comments that mimic the OpenSSL\n * X509_check_issued function (in x509v3/v3_purp.c)\n */\nstatic SECStatus check_issuer_cert(PRFileDesc *sock,\n                                   char *issuer_nickname)\n{\n  CERTCertificate *cert, *cert_issuer, *issuer;\n  SECStatus res = SECSuccess;\n  void *proto_win = NULL;\n\n  cert = SSL_PeerCertificate(sock);\n  cert_issuer = CERT_FindCertIssuer(cert, PR_Now(), certUsageObjectSigner);\n\n  proto_win = SSL_RevealPinArg(sock);\n  issuer = PK11_FindCertFromNickname(issuer_nickname, proto_win);\n\n  if((!cert_issuer) || (!issuer))\n    res = SECFailure;\n  else if(SECITEM_CompareItem(&cert_issuer->derCert,\n                              &issuer->derCert) != SECEqual)\n    res = SECFailure;\n\n  CERT_DestroyCertificate(cert);\n  CERT_DestroyCertificate(issuer);\n  CERT_DestroyCertificate(cert_issuer);\n  return res;\n}\n\nstatic CURLcode cmp_peer_pubkey(struct ssl_connect_data *connssl,\n                                const char *pinnedpubkey)\n{\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->data;\n  CERTCertificate *cert;\n\n  if(!pinnedpubkey)\n    /* no pinned public key specified */\n    return CURLE_OK;\n\n  /* get peer certificate */\n  cert = SSL_PeerCertificate(backend->handle);\n  if(cert) {\n    /* extract public key from peer certificate */\n    SECKEYPublicKey *pubkey = CERT_ExtractPublicKey(cert);\n    if(pubkey) {\n      /* encode the public key as DER */\n      SECItem *cert_der = PK11_DEREncodePublicKey(pubkey);\n      if(cert_der) {\n        /* compare the public key with the pinned public key */\n        result = Curl_pin_peer_pubkey(data, pinnedpubkey, cert_der->data,\n                                      cert_der->len);\n        SECITEM_FreeItem(cert_der, PR_TRUE);\n      }\n      SECKEY_DestroyPublicKey(pubkey);\n    }\n    CERT_DestroyCertificate(cert);\n  }\n\n  /* report the resulting status */\n  switch(result) {\n  case CURLE_OK:\n    infof(data, \"pinned public key verified successfully!\\n\");\n    break;\n  case CURLE_SSL_PINNEDPUBKEYNOTMATCH:\n    failf(data, \"failed to verify pinned public key\");\n    break;\n  default:\n    /* OOM, etc. */\n    break;\n  }\n\n  return result;\n}\n\n/**\n *\n * Callback to pick the SSL client certificate.\n */\nstatic SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n                                  struct CERTDistNamesStr *caNames,\n                                  struct CERTCertificateStr **pRetCert,\n                                  struct SECKEYPrivateKeyStr **pRetKey)\n{\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->data;\n  const char *nickname = backend->client_nickname;\n  static const char pem_slotname[] = \"PEM Token #1\";\n\n  if(backend->obj_clicert) {\n    /* use the cert/key provided by PEM reader */\n    SECItem cert_der = { 0, NULL, 0 };\n    void *proto_win = SSL_RevealPinArg(sock);\n    struct CERTCertificateStr *cert;\n    struct SECKEYPrivateKeyStr *key;\n\n    PK11SlotInfo *slot = nss_find_slot_by_name(pem_slotname);\n    if(NULL == slot) {\n      failf(data, \"NSS: PK11 slot not found: %s\", pem_slotname);\n      return SECFailure;\n    }\n\n    if(PK11_ReadRawAttribute(PK11_TypeGeneric, backend->obj_clicert, CKA_VALUE,\n                             &cert_der) != SECSuccess) {\n      failf(data, \"NSS: CKA_VALUE not found in PK11 generic object\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);\n    SECITEM_FreeItem(&cert_der, PR_FALSE);\n    if(NULL == cert) {\n      failf(data, \"NSS: client certificate from file not found\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);\n    PK11_FreeSlot(slot);\n    if(NULL == key) {\n      failf(data, \"NSS: private key from file not found\");\n      CERT_DestroyCertificate(cert);\n      return SECFailure;\n    }\n\n    infof(data, \"NSS: client certificate from file\\n\");\n    display_cert_info(data, cert);\n\n    *pRetCert = cert;\n    *pRetKey = key;\n    return SECSuccess;\n  }\n\n  /* use the default NSS hook */\n  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,\n                                          pRetCert, pRetKey)\n      || NULL == *pRetCert) {\n\n    if(NULL == nickname)\n      failf(data, \"NSS: client certificate not found (nickname not \"\n            \"specified)\");\n    else\n      failf(data, \"NSS: client certificate not found: %s\", nickname);\n\n    return SECFailure;\n  }\n\n  /* get certificate nickname if any */\n  nickname = (*pRetCert)->nickname;\n  if(NULL == nickname)\n    nickname = \"[unknown]\";\n\n  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {\n    failf(data, \"NSS: refusing previously loaded certificate from file: %s\",\n          nickname);\n    return SECFailure;\n  }\n\n  if(NULL == *pRetKey) {\n    failf(data, \"NSS: private key not found for certificate: %s\", nickname);\n    return SECFailure;\n  }\n\n  infof(data, \"NSS: using client certificate: %s\\n\", nickname);\n  display_cert_info(data, *pRetCert);\n  return SECSuccess;\n}\n\n/* update blocking direction in case of PR_WOULD_BLOCK_ERROR */\nstatic void nss_update_connecting_state(ssl_connect_state state, void *secret)\n{\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)secret;\n  if(PR_GetError() != PR_WOULD_BLOCK_ERROR)\n    /* an unrelated error is passing by */\n    return;\n\n  switch(connssl->connecting_state) {\n  case ssl_connect_2:\n  case ssl_connect_2_reading:\n  case ssl_connect_2_writing:\n    break;\n  default:\n    /* we are not called from an SSL handshake */\n    return;\n  }\n\n  /* update the state accordingly */\n  connssl->connecting_state = state;\n}\n\n/* recv() wrapper we use to detect blocking direction during SSL handshake */\nstatic PRInt32 nspr_io_recv(PRFileDesc *fd, void *buf, PRInt32 amount,\n                            PRIntn flags, PRIntervalTime timeout)\n{\n  const PRRecvFN recv_fn = fd->lower->methods->recv;\n  const PRInt32 rv = recv_fn(fd->lower, buf, amount, flags, timeout);\n  if(rv < 0)\n    /* check for PR_WOULD_BLOCK_ERROR and update blocking direction */\n    nss_update_connecting_state(ssl_connect_2_reading, fd->secret);\n  return rv;\n}\n\n/* send() wrapper we use to detect blocking direction during SSL handshake */\nstatic PRInt32 nspr_io_send(PRFileDesc *fd, const void *buf, PRInt32 amount,\n                            PRIntn flags, PRIntervalTime timeout)\n{\n  const PRSendFN send_fn = fd->lower->methods->send;\n  const PRInt32 rv = send_fn(fd->lower, buf, amount, flags, timeout);\n  if(rv < 0)\n    /* check for PR_WOULD_BLOCK_ERROR and update blocking direction */\n    nss_update_connecting_state(ssl_connect_2_writing, fd->secret);\n  return rv;\n}\n\n/* close() wrapper to avoid assertion failure due to fd->secret != NULL */\nstatic PRStatus nspr_io_close(PRFileDesc *fd)\n{\n  const PRCloseFN close_fn = PR_GetDefaultIOMethods()->close;\n  fd->secret = NULL;\n  return close_fn(fd);\n}\n\n/* load a PKCS #11 module */\nstatic CURLcode nss_load_module(SECMODModule **pmod, const char *library,\n                                const char *name)\n{\n  char *config_string;\n  SECMODModule *module = *pmod;\n  if(module)\n    /* already loaded */\n    return CURLE_OK;\n\n  config_string = aprintf(\"library=%s name=%s\", library, name);\n  if(!config_string)\n    return CURLE_OUT_OF_MEMORY;\n\n  module = SECMOD_LoadUserModule(config_string, NULL, PR_FALSE);\n  free(config_string);\n\n  if(module && module->loaded) {\n    /* loaded successfully */\n    *pmod = module;\n    return CURLE_OK;\n  }\n\n  if(module)\n    SECMOD_DestroyModule(module);\n  return CURLE_FAILED_INIT;\n}\n\n/* unload a PKCS #11 module */\nstatic void nss_unload_module(SECMODModule **pmod)\n{\n  SECMODModule *module = *pmod;\n  if(!module)\n    /* not loaded */\n    return;\n\n  if(SECMOD_UnloadUserModule(module) != SECSuccess)\n    /* unload failed */\n    return;\n\n  SECMOD_DestroyModule(module);\n  *pmod = NULL;\n}\n\n/* data might be NULL */\nstatic CURLcode nss_init_core(struct Curl_easy *data, const char *cert_dir)\n{\n  NSSInitParameters initparams;\n  PRErrorCode err;\n  const char *err_name;\n\n  if(nss_context != NULL)\n    return CURLE_OK;\n\n  memset((void *) &initparams, '\\0', sizeof(initparams));\n  initparams.length = sizeof(initparams);\n\n  if(cert_dir) {\n    char *certpath = aprintf(\"sql:%s\", cert_dir);\n    if(!certpath)\n      return CURLE_OUT_OF_MEMORY;\n\n    infof(data, \"Initializing NSS with certpath: %s\\n\", certpath);\n    nss_context = NSS_InitContext(certpath, \"\", \"\", \"\", &initparams,\n                                  NSS_INIT_READONLY | NSS_INIT_PK11RELOAD);\n    free(certpath);\n\n    if(nss_context != NULL)\n      return CURLE_OK;\n\n    err = PR_GetError();\n    err_name = nss_error_to_name(err);\n    infof(data, \"Unable to initialize NSS database: %d (%s)\\n\", err, err_name);\n  }\n\n  infof(data, \"Initializing NSS with certpath: none\\n\");\n  nss_context = NSS_InitContext(\"\", \"\", \"\", \"\", &initparams, NSS_INIT_READONLY\n         | NSS_INIT_NOCERTDB   | NSS_INIT_NOMODDB       | NSS_INIT_FORCEOPEN\n         | NSS_INIT_NOROOTINIT | NSS_INIT_OPTIMIZESPACE | NSS_INIT_PK11RELOAD);\n  if(nss_context != NULL)\n    return CURLE_OK;\n\n  err = PR_GetError();\n  err_name = nss_error_to_name(err);\n  failf(data, \"Unable to initialize NSS: %d (%s)\", err, err_name);\n  return CURLE_SSL_CACERT_BADFILE;\n}\n\n/* data might be NULL */\nstatic CURLcode nss_setup(struct Curl_easy *data)\n{\n  char *cert_dir;\n  struct_stat st;\n  CURLcode result;\n\n  if(initialized)\n    return CURLE_OK;\n\n  /* list of all CRL items we need to destroy in nss_cleanup() */\n  Curl_llist_init(&nss_crl_list, nss_destroy_crl_item);\n\n  /* First we check if $SSL_DIR points to a valid dir */\n  cert_dir = getenv(\"SSL_DIR\");\n  if(cert_dir) {\n    if((stat(cert_dir, &st) != 0) ||\n        (!S_ISDIR(st.st_mode))) {\n      cert_dir = NULL;\n    }\n  }\n\n  /* Now we check if the default location is a valid dir */\n  if(!cert_dir) {\n    if((stat(SSL_DIR, &st) == 0) &&\n        (S_ISDIR(st.st_mode))) {\n      cert_dir = (char *)SSL_DIR;\n    }\n  }\n\n  if(nspr_io_identity == PR_INVALID_IO_LAYER) {\n    /* allocate an identity for our own NSPR I/O layer */\n    nspr_io_identity = PR_GetUniqueIdentity(\"libcurl\");\n    if(nspr_io_identity == PR_INVALID_IO_LAYER)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* the default methods just call down to the lower I/O layer */\n    memcpy(&nspr_io_methods, PR_GetDefaultIOMethods(),\n           sizeof(nspr_io_methods));\n\n    /* override certain methods in the table by our wrappers */\n    nspr_io_methods.recv  = nspr_io_recv;\n    nspr_io_methods.send  = nspr_io_send;\n    nspr_io_methods.close = nspr_io_close;\n  }\n\n  result = nss_init_core(data, cert_dir);\n  if(result)\n    return result;\n\n  if(!any_cipher_enabled())\n    NSS_SetDomesticPolicy();\n\n  initialized = 1;\n\n  return CURLE_OK;\n}\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nstatic int nss_init(void)\n{\n  /* curl_global_init() is not thread-safe so this test is ok */\n  if(!nss_initlock) {\n    PR_Init(PR_USER_THREAD, PR_PRIORITY_NORMAL, 0);\n    nss_initlock = PR_NewLock();\n    nss_crllock = PR_NewLock();\n    nss_findslot_lock = PR_NewLock();\n    nss_trustload_lock = PR_NewLock();\n  }\n\n  /* We will actually initialize NSS later */\n\n  return 1;\n}\n\n/* data might be NULL */\nCURLcode Curl_nss_force_init(struct Curl_easy *data)\n{\n  CURLcode result;\n  if(!nss_initlock) {\n    if(data)\n      failf(data, \"unable to initialize NSS, curl_global_init() should have \"\n                  \"been called with CURL_GLOBAL_SSL or CURL_GLOBAL_ALL\");\n    return CURLE_FAILED_INIT;\n  }\n\n  PR_Lock(nss_initlock);\n  result = nss_setup(data);\n  PR_Unlock(nss_initlock);\n\n  return result;\n}\n\n/* Global cleanup */\nstatic void nss_cleanup(void)\n{\n  /* This function isn't required to be threadsafe and this is only done\n   * as a safety feature.\n   */\n  PR_Lock(nss_initlock);\n  if(initialized) {\n    /* Free references to client certificates held in the SSL session cache.\n     * Omitting this hampers destruction of the security module owning\n     * the certificates. */\n    SSL_ClearSessionCache();\n\n    nss_unload_module(&pem_module);\n    nss_unload_module(&trust_module);\n    NSS_ShutdownContext(nss_context);\n    nss_context = NULL;\n  }\n\n  /* destroy all CRL items */\n  Curl_llist_destroy(&nss_crl_list, NULL);\n\n  PR_Unlock(nss_initlock);\n\n  PR_DestroyLock(nss_initlock);\n  PR_DestroyLock(nss_crllock);\n  PR_DestroyLock(nss_findslot_lock);\n  PR_DestroyLock(nss_trustload_lock);\n  nss_initlock = NULL;\n\n  initialized = 0;\n}\n\n/*\n * This function uses SSL_peek to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int nss_check_cxn(struct connectdata *conn)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n  struct ssl_backend_data *backend = connssl->backend;\n  int rc;\n  char buf;\n\n  rc =\n    PR_Recv(backend->handle, (void *)&buf, 1, PR_MSG_PEEK,\n            PR_SecondsToInterval(1));\n  if(rc > 0)\n    return 1; /* connection still in place */\n\n  if(rc == 0)\n    return 0; /* connection has been closed */\n\n  return -1;  /* connection status unknown */\n}\n\nstatic void close_one(struct ssl_connect_data *connssl)\n{\n  /* before the cleanup, check whether we are using a client certificate */\n  struct ssl_backend_data *backend = connssl->backend;\n  const bool client_cert = (backend->client_nickname != NULL)\n    || (backend->obj_clicert != NULL);\n\n  free(backend->client_nickname);\n  backend->client_nickname = NULL;\n\n  /* destroy all NSS objects in order to avoid failure of NSS shutdown */\n  Curl_llist_destroy(&backend->obj_list, NULL);\n  backend->obj_clicert = NULL;\n\n  if(backend->handle) {\n    if(client_cert)\n      /* A server might require different authentication based on the\n       * particular path being requested by the client.  To support this\n       * scenario, we must ensure that a connection will never reuse the\n       * authentication data from a previous connection. */\n      SSL_InvalidateSession(backend->handle);\n\n    PR_Close(backend->handle);\n    backend->handle = NULL;\n  }\n}\n\n/*\n * This function is called when an SSL connection is closed.\n */\nstatic void nss_close(struct Curl_easy *data, struct connectdata *conn,\n                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data *connssl_proxy = &conn->proxy_ssl[sockindex];\n#endif\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void)data;\n  if(backend->handle\n#ifndef CURL_DISABLE_PROXY\n    || connssl_proxy->backend->handle\n#endif\n    ) {\n    /* NSS closes the socket we previously handed to it, so we must mark it\n       as closed to avoid double close */\n    fake_sclose(conn->sock[sockindex]);\n    conn->sock[sockindex] = CURL_SOCKET_BAD;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(backend->handle)\n    /* nss_close(connssl) will transitively close also\n       connssl_proxy->backend->handle if both are used. Clear it to avoid\n       a double close leading to crash. */\n    connssl_proxy->backend->handle = NULL;\n\n  close_one(connssl_proxy);\n#endif\n  close_one(connssl);\n}\n\n/* return true if NSS can provide error code (and possibly msg) for the\n   error */\nstatic bool is_nss_error(CURLcode err)\n{\n  switch(err) {\n  case CURLE_PEER_FAILED_VERIFICATION:\n  case CURLE_SSL_CERTPROBLEM:\n  case CURLE_SSL_CONNECT_ERROR:\n  case CURLE_SSL_ISSUER_ERROR:\n    return true;\n\n  default:\n    return false;\n  }\n}\n\n/* return true if the given error code is related to a client certificate */\nstatic bool is_cc_error(PRInt32 err)\n{\n  switch(err) {\n  case SSL_ERROR_BAD_CERT_ALERT:\n  case SSL_ERROR_EXPIRED_CERT_ALERT:\n  case SSL_ERROR_REVOKED_CERT_ALERT:\n    return true;\n\n  default:\n    return false;\n  }\n}\n\nstatic Curl_recv nss_recv;\nstatic Curl_send nss_send;\n\nstatic CURLcode nss_load_ca_certificates(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex)\n{\n  const char *cafile = SSL_CONN_CONFIG(CAfile);\n  const char *capath = SSL_CONN_CONFIG(CApath);\n  bool use_trust_module;\n  CURLcode result = CURLE_OK;\n\n  /* treat empty string as unset */\n  if(cafile && !cafile[0])\n    cafile = NULL;\n  if(capath && !capath[0])\n    capath = NULL;\n\n  infof(data, \" CAfile: %s\\n\", cafile ? cafile : \"none\");\n  infof(data, \" CApath: %s\\n\", capath ? capath : \"none\");\n\n  /* load libnssckbi.so if no other trust roots were specified */\n  use_trust_module = !cafile && !capath;\n\n  PR_Lock(nss_trustload_lock);\n  if(use_trust_module && !trust_module) {\n    /* libnssckbi.so needed but not yet loaded --> load it! */\n    result = nss_load_module(&trust_module, trust_library, \"trust\");\n    infof(data, \"%s %s\\n\", (result) ? \"failed to load\" : \"loaded\",\n          trust_library);\n    if(result == CURLE_FAILED_INIT)\n      /* If libnssckbi.so is not available (or fails to load), one can still\n         use CA certificates stored in NSS database.  Ignore the failure. */\n      result = CURLE_OK;\n  }\n  else if(!use_trust_module && trust_module) {\n    /* libnssckbi.so not needed but already loaded --> unload it! */\n    infof(data, \"unloading %s\\n\", trust_library);\n    nss_unload_module(&trust_module);\n  }\n  PR_Unlock(nss_trustload_lock);\n\n  if(cafile)\n    result = nss_load_cert(&conn->ssl[sockindex], cafile, PR_TRUE);\n\n  if(result)\n    return result;\n\n  if(capath) {\n    struct_stat st;\n    if(stat(capath, &st) == -1)\n      return CURLE_SSL_CACERT_BADFILE;\n\n    if(S_ISDIR(st.st_mode)) {\n      PRDirEntry *entry;\n      PRDir *dir = PR_OpenDir(capath);\n      if(!dir)\n        return CURLE_SSL_CACERT_BADFILE;\n\n      while((entry =\n             PR_ReadDir(dir, (PRDirFlags)(PR_SKIP_BOTH | PR_SKIP_HIDDEN)))) {\n        char *fullpath = aprintf(\"%s/%s\", capath, entry->name);\n        if(!fullpath) {\n          PR_CloseDir(dir);\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        if(CURLE_OK != nss_load_cert(&conn->ssl[sockindex], fullpath, PR_TRUE))\n          /* This is purposefully tolerant of errors so non-PEM files can\n           * be in the same directory */\n          infof(data, \"failed to load '%s' from CURLOPT_CAPATH\\n\", fullpath);\n\n        free(fullpath);\n      }\n\n      PR_CloseDir(dir);\n    }\n    else\n      infof(data, \"warning: CURLOPT_CAPATH not a directory (%s)\\n\", capath);\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_sslver_from_curl(PRUint16 *nssver, long version)\n{\n  switch(version) {\n  case CURL_SSLVERSION_SSLv2:\n    *nssver = SSL_LIBRARY_VERSION_2;\n    return CURLE_OK;\n\n  case CURL_SSLVERSION_SSLv3:\n    return CURLE_NOT_BUILT_IN;\n\n  case CURL_SSLVERSION_TLSv1_0:\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_0;\n    return CURLE_OK;\n\n  case CURL_SSLVERSION_TLSv1_1:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_1\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_1;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  case CURL_SSLVERSION_TLSv1_2:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_2\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_2;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  case CURL_SSLVERSION_TLSv1_3:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_3;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  default:\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n}\n\nstatic CURLcode nss_init_sslver(SSLVersionRange *sslver,\n                                struct Curl_easy *data,\n                                struct connectdata *conn)\n{\n  CURLcode result;\n  const long min = SSL_CONN_CONFIG(version);\n  const long max = SSL_CONN_CONFIG(version_max);\n  SSLVersionRange vrange;\n\n  switch(min) {\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_DEFAULT:\n    /* Bump our minimum TLS version if NSS has stricter requirements. */\n    if(SSL_VersionRangeGetDefault(ssl_variant_stream, &vrange) != SECSuccess)\n      return CURLE_SSL_CONNECT_ERROR;\n    if(sslver->min < vrange.min)\n      sslver->min = vrange.min;\n    break;\n  default:\n    result = nss_sslver_from_curl(&sslver->min, min);\n    if(result) {\n      failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n  }\n\n  switch(max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    break;\n  default:\n    result = nss_sslver_from_curl(&sslver->max, max >> 16);\n    if(result) {\n      failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_fail_connect(struct ssl_connect_data *connssl,\n                                 struct Curl_easy *data,\n                                 CURLcode curlerr)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n\n  if(is_nss_error(curlerr)) {\n    /* read NSPR error code */\n    PRErrorCode err = PR_GetError();\n    if(is_cc_error(err))\n      curlerr = CURLE_SSL_CERTPROBLEM;\n\n    /* print the error number and error string */\n    infof(data, \"NSS error %d (%s)\\n\", err, nss_error_to_name(err));\n\n    /* print a human-readable message describing the error if available */\n    nss_print_error_message(data, err);\n  }\n\n  /* cleanup on connection failure */\n  Curl_llist_destroy(&backend->obj_list, NULL);\n\n  return curlerr;\n}\n\n/* Switch the SSL socket into blocking or non-blocking mode. */\nstatic CURLcode nss_set_blocking(struct ssl_connect_data *connssl,\n                                 struct Curl_easy *data,\n                                 bool blocking)\n{\n  PRSocketOptionData sock_opt;\n  struct ssl_backend_data *backend = connssl->backend;\n  sock_opt.option = PR_SockOpt_Nonblocking;\n  sock_opt.value.non_blocking = !blocking;\n\n  if(PR_SetSocketOption(backend->handle, &sock_opt) != PR_SUCCESS)\n    return nss_fail_connect(connssl, data, CURLE_SSL_CONNECT_ERROR);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_setup_connect(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex)\n{\n  PRFileDesc *model = NULL;\n  PRFileDesc *nspr_io = NULL;\n  PRFileDesc *nspr_io_stub = NULL;\n  PRBool ssl_no_cache;\n  PRBool ssl_cbc_random_iv;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode result;\n  bool second_layer = FALSE;\n  SSLVersionRange sslver_supported;\n\n  SSLVersionRange sslver = {\n    SSL_LIBRARY_VERSION_TLS_1_0,  /* min */\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n    SSL_LIBRARY_VERSION_TLS_1_3   /* max */\n#elif defined SSL_LIBRARY_VERSION_TLS_1_2\n    SSL_LIBRARY_VERSION_TLS_1_2\n#elif defined SSL_LIBRARY_VERSION_TLS_1_1\n    SSL_LIBRARY_VERSION_TLS_1_1\n#else\n    SSL_LIBRARY_VERSION_TLS_1_0\n#endif\n  };\n\n  backend->data = data;\n\n  /* list of all NSS objects we need to destroy in nss_do_close() */\n  Curl_llist_init(&backend->obj_list, nss_destroy_object);\n\n  PR_Lock(nss_initlock);\n  result = nss_setup(data);\n  if(result) {\n    PR_Unlock(nss_initlock);\n    goto error;\n  }\n\n  PK11_SetPasswordFunc(nss_get_password);\n\n  result = nss_load_module(&pem_module, pem_library, \"PEM\");\n  PR_Unlock(nss_initlock);\n  if(result == CURLE_FAILED_INIT)\n    infof(data, \"WARNING: failed to load NSS PEM library %s. Using \"\n                \"OpenSSL PEM certificates will not work.\\n\", pem_library);\n  else if(result)\n    goto error;\n\n  result = CURLE_SSL_CONNECT_ERROR;\n\n  model = PR_NewTCPSocket();\n  if(!model)\n    goto error;\n  model = SSL_ImportFD(NULL, model);\n\n  if(SSL_OptionSet(model, SSL_SECURITY, PR_TRUE) != SECSuccess)\n    goto error;\n  if(SSL_OptionSet(model, SSL_HANDSHAKE_AS_SERVER, PR_FALSE) != SECSuccess)\n    goto error;\n  if(SSL_OptionSet(model, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE) != SECSuccess)\n    goto error;\n\n  /* do not use SSL cache if disabled or we are not going to verify peer */\n  ssl_no_cache = (SSL_SET_OPTION(primary.sessionid)\n                  && SSL_CONN_CONFIG(verifypeer)) ? PR_FALSE : PR_TRUE;\n  if(SSL_OptionSet(model, SSL_NO_CACHE, ssl_no_cache) != SECSuccess)\n    goto error;\n\n  /* enable/disable the requested SSL version(s) */\n  if(nss_init_sslver(&sslver, data, conn) != CURLE_OK)\n    goto error;\n  if(SSL_VersionRangeGetSupported(ssl_variant_stream,\n                                  &sslver_supported) != SECSuccess)\n    goto error;\n  if(sslver_supported.max < sslver.max && sslver_supported.max >= sslver.min) {\n    char *sslver_req_str, *sslver_supp_str;\n    sslver_req_str = nss_sslver_to_name(sslver.max);\n    sslver_supp_str = nss_sslver_to_name(sslver_supported.max);\n    if(sslver_req_str && sslver_supp_str)\n      infof(data, \"Falling back from %s to max supported SSL version (%s)\\n\",\n                  sslver_req_str, sslver_supp_str);\n    free(sslver_req_str);\n    free(sslver_supp_str);\n    sslver.max = sslver_supported.max;\n  }\n  if(SSL_VersionRangeSet(model, &sslver) != SECSuccess)\n    goto error;\n\n  ssl_cbc_random_iv = !SSL_SET_OPTION(enable_beast);\n#ifdef SSL_CBC_RANDOM_IV\n  /* unless the user explicitly asks to allow the protocol vulnerability, we\n     use the work-around */\n  if(SSL_OptionSet(model, SSL_CBC_RANDOM_IV, ssl_cbc_random_iv) != SECSuccess)\n    infof(data, \"warning: failed to set SSL_CBC_RANDOM_IV = %d\\n\",\n          ssl_cbc_random_iv);\n#else\n  if(ssl_cbc_random_iv)\n    infof(data, \"warning: support for SSL_CBC_RANDOM_IV not compiled in\\n\");\n#endif\n\n  if(SSL_CONN_CONFIG(cipher_list)) {\n    if(set_ciphers(data, model, SSL_CONN_CONFIG(cipher_list)) != SECSuccess) {\n      result = CURLE_SSL_CIPHER;\n      goto error;\n    }\n  }\n\n  if(!SSL_CONN_CONFIG(verifypeer) && SSL_CONN_CONFIG(verifyhost))\n    infof(data, \"warning: ignoring value of ssl.verifyhost\\n\");\n\n  /* bypass the default SSL_AuthCertificate() hook in case we do not want to\n   * verify peer */\n  if(SSL_AuthCertificateHook(model, nss_auth_cert_hook, data) != SECSuccess)\n    goto error;\n\n  /* not checked yet */\n  SSL_SET_OPTION_LVALUE(certverifyresult) = 0;\n\n  if(SSL_BadCertHook(model, BadCertHandler, data) != SECSuccess)\n    goto error;\n\n  if(SSL_HandshakeCallback(model, HandshakeCallback, data) != SECSuccess)\n    goto error;\n\n  {\n    const CURLcode rv = nss_load_ca_certificates(data, conn, sockindex);\n    if((rv == CURLE_SSL_CACERT_BADFILE) && !SSL_CONN_CONFIG(verifypeer))\n      /* not a fatal error because we are not going to verify the peer */\n      infof(data, \"warning: CA certificates failed to load\\n\");\n    else if(rv) {\n      result = rv;\n      goto error;\n    }\n  }\n\n  if(SSL_SET_OPTION(CRLfile)) {\n    const CURLcode rv = nss_load_crl(SSL_SET_OPTION(CRLfile));\n    if(rv) {\n      result = rv;\n      goto error;\n    }\n    infof(data, \"  CRLfile: %s\\n\", SSL_SET_OPTION(CRLfile));\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert)) {\n    char *nickname = dup_nickname(data, SSL_SET_OPTION(primary.clientcert));\n    if(nickname) {\n      /* we are not going to use libnsspem.so to read the client cert */\n      backend->obj_clicert = NULL;\n    }\n    else {\n      CURLcode rv = cert_stuff(data, conn, sockindex,\n                               SSL_SET_OPTION(primary.clientcert),\n                               SSL_SET_OPTION(key));\n      if(rv) {\n        /* failf() is already done in cert_stuff() */\n        result = rv;\n        goto error;\n      }\n    }\n\n    /* store the nickname for SelectClientCert() called during handshake */\n    backend->client_nickname = nickname;\n  }\n  else\n    backend->client_nickname = NULL;\n\n  if(SSL_GetClientAuthDataHook(model, SelectClientCert,\n                               (void *)connssl) != SECSuccess) {\n    result = CURLE_SSL_CERTPROBLEM;\n    goto error;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(conn->proxy_ssl[sockindex].backend->handle != NULL);\n    nspr_io = conn->proxy_ssl[sockindex].backend->handle;\n    second_layer = TRUE;\n  }\n#endif\n  else {\n    /* wrap OS file descriptor by NSPR's file descriptor abstraction */\n    nspr_io = PR_ImportTCPSocket(sockfd);\n    if(!nspr_io)\n      goto error;\n  }\n\n  /* create our own NSPR I/O layer */\n  nspr_io_stub = PR_CreateIOLayerStub(nspr_io_identity, &nspr_io_methods);\n  if(!nspr_io_stub) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    goto error;\n  }\n\n  /* make the per-connection data accessible from NSPR I/O callbacks */\n  nspr_io_stub->secret = (void *)connssl;\n\n  /* push our new layer to the NSPR I/O stack */\n  if(PR_PushIOLayer(nspr_io, PR_TOP_IO_LAYER, nspr_io_stub) != PR_SUCCESS) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    PR_Close(nspr_io_stub);\n    goto error;\n  }\n\n  /* import our model socket onto the current I/O stack */\n  backend->handle = SSL_ImportFD(model, nspr_io);\n  if(!backend->handle) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    goto error;\n  }\n\n  PR_Close(model); /* We don't need this any more */\n  model = NULL;\n\n  /* This is the password associated with the cert that we're using */\n  if(SSL_SET_OPTION(key_passwd)) {\n    SSL_SetPKCS11PinArg(backend->handle, SSL_SET_OPTION(key_passwd));\n  }\n\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    if(SSL_OptionSet(backend->handle, SSL_ENABLE_OCSP_STAPLING, PR_TRUE)\n        != SECSuccess)\n      goto error;\n  }\n#endif\n\n#ifdef SSL_ENABLE_NPN\n  if(SSL_OptionSet(backend->handle, SSL_ENABLE_NPN, conn->bits.tls_enable_npn\n                   ? PR_TRUE : PR_FALSE) != SECSuccess)\n    goto error;\n#endif\n\n#ifdef SSL_ENABLE_ALPN\n  if(SSL_OptionSet(backend->handle, SSL_ENABLE_ALPN, conn->bits.tls_enable_alpn\n                   ? PR_TRUE : PR_FALSE) != SECSuccess)\n    goto error;\n#endif\n\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\n  if(data->set.ssl.falsestart) {\n    if(SSL_OptionSet(backend->handle, SSL_ENABLE_FALSE_START, PR_TRUE)\n        != SECSuccess)\n      goto error;\n\n    if(SSL_SetCanFalseStartCallback(backend->handle, CanFalseStartCallback,\n        data) != SECSuccess)\n      goto error;\n  }\n#endif\n\n#if defined(SSL_ENABLE_NPN) || defined(SSL_ENABLE_ALPN)\n  if(conn->bits.tls_enable_npn || conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    unsigned char protocols[128];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n      && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n      ) {\n      protocols[cur++] = ALPN_H2_LENGTH;\n      memcpy(&protocols[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n    }\n#endif\n    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n\n    if(SSL_SetNextProtoNego(backend->handle, protocols, cur) != SECSuccess)\n      goto error;\n  }\n#endif\n\n\n  /* Force handshake on next I/O */\n  if(SSL_ResetHandshake(backend->handle, /* asServer */ PR_FALSE)\n      != SECSuccess)\n    goto error;\n\n  /* propagate hostname to the TLS layer */\n  if(SSL_SetURL(backend->handle, SSL_HOST_NAME()) != SECSuccess)\n    goto error;\n\n  /* prevent NSS from re-using the session for a different hostname */\n  if(SSL_SetSockPeerID(backend->handle, SSL_HOST_NAME()) != SECSuccess)\n    goto error;\n\n  return CURLE_OK;\n\nerror:\n  if(model)\n    PR_Close(model);\n\n  return nss_fail_connect(connssl, data, result);\n}\n\nstatic CURLcode nss_do_connect(struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode result = CURLE_SSL_CONNECT_ERROR;\n  PRUint32 timeout;\n\n  /* check timeout situation */\n  const timediff_t time_left = Curl_timeleft(data, NULL, TRUE);\n  if(time_left < 0) {\n    failf(data, \"timed out before SSL handshake\");\n    result = CURLE_OPERATION_TIMEDOUT;\n    goto error;\n  }\n\n  /* Force the handshake now */\n  timeout = PR_MillisecondsToInterval((PRUint32) time_left);\n  if(SSL_ForceHandshakeWithTimeout(backend->handle, timeout) != SECSuccess) {\n    if(PR_GetError() == PR_WOULD_BLOCK_ERROR)\n      /* blocking direction is updated by nss_update_connecting_state() */\n      return CURLE_AGAIN;\n    else if(SSL_SET_OPTION(certverifyresult) == SSL_ERROR_BAD_CERT_DOMAIN)\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    else if(SSL_SET_OPTION(certverifyresult) != 0)\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    goto error;\n  }\n\n  result = display_conn_info(data, backend->handle);\n  if(result)\n    goto error;\n\n  if(SSL_SET_OPTION(issuercert)) {\n    SECStatus ret = SECFailure;\n    char *nickname = dup_nickname(data, SSL_SET_OPTION(issuercert));\n    if(nickname) {\n      /* we support only nicknames in case of issuercert for now */\n      ret = check_issuer_cert(backend->handle, nickname);\n      free(nickname);\n    }\n\n    if(SECFailure == ret) {\n      infof(data, \"SSL certificate issuer check failed\\n\");\n      result = CURLE_SSL_ISSUER_ERROR;\n      goto error;\n    }\n    else {\n      infof(data, \"SSL certificate issuer check ok\\n\");\n    }\n  }\n\n  result = cmp_peer_pubkey(connssl, SSL_PINNED_PUB_KEY());\n  if(result)\n    /* status already printed */\n    goto error;\n\n  return CURLE_OK;\n\nerror:\n  return nss_fail_connect(connssl, data, result);\n}\n\nstatic CURLcode nss_connect_common(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex,\n                                   bool *done)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  const bool blocking = (done == NULL);\n  CURLcode result;\n\n  if(connssl->state == ssl_connection_complete) {\n    if(!blocking)\n      *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(connssl->connecting_state == ssl_connect_1) {\n    result = nss_setup_connect(data, conn, sockindex);\n    if(result)\n      /* we do not expect CURLE_AGAIN from nss_setup_connect() */\n      return result;\n\n    connssl->connecting_state = ssl_connect_2;\n  }\n\n  /* enable/disable blocking mode before handshake */\n  result = nss_set_blocking(connssl, data, blocking);\n  if(result)\n    return result;\n\n  result = nss_do_connect(data, conn, sockindex);\n  switch(result) {\n  case CURLE_OK:\n    break;\n  case CURLE_AGAIN:\n    if(!blocking)\n      /* CURLE_AGAIN in non-blocking mode is not an error */\n      return CURLE_OK;\n    /* FALLTHROUGH */\n  default:\n    return result;\n  }\n\n  if(blocking) {\n    /* in blocking mode, set NSS non-blocking mode _after_ SSL handshake */\n    result = nss_set_blocking(connssl, data, /* blocking */ FALSE);\n    if(result)\n      return result;\n  }\n  else\n    /* signal completed SSL handshake */\n    *done = TRUE;\n\n  connssl->state = ssl_connection_complete;\n  conn->recv[sockindex] = nss_recv;\n  conn->send[sockindex] = nss_send;\n\n  /* ssl_connect_done is never used outside, go back to the initial state */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_connect(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  return nss_connect_common(data, conn, sockindex, /* blocking */ NULL);\n}\n\nstatic CURLcode nss_connect_nonblocking(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        int sockindex, bool *done)\n{\n  return nss_connect_common(data, conn, sockindex, done);\n}\n\nstatic ssize_t nss_send(struct Curl_easy *data,    /* transfer */\n                        int sockindex,             /* socketindex */\n                        const void *mem,           /* send this data */\n                        size_t len,                /* amount to write */\n                        CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t rc;\n\n  /* The SelectClientCert() hook uses this for infof() and failf() but the\n     handle stored in nss_setup_connect() could have already been freed. */\n  backend->data = data;\n\n  rc = PR_Send(backend->handle, mem, (int)len, 0, PR_INTERVAL_NO_WAIT);\n  if(rc < 0) {\n    PRInt32 err = PR_GetError();\n    if(err == PR_WOULD_BLOCK_ERROR)\n      *curlcode = CURLE_AGAIN;\n    else {\n      /* print the error number and error string */\n      const char *err_name = nss_error_to_name(err);\n      infof(data, \"SSL write: error %d (%s)\\n\", err, err_name);\n\n      /* print a human-readable message describing the error if available */\n      nss_print_error_message(data, err);\n\n      *curlcode = (is_cc_error(err))\n        ? CURLE_SSL_CERTPROBLEM\n        : CURLE_SEND_ERROR;\n    }\n\n    return -1;\n  }\n\n  return rc; /* number of bytes */\n}\n\nstatic ssize_t nss_recv(struct Curl_easy *data,    /* transfer */\n                        int sockindex,             /* socketindex */\n                        char *buf,             /* store read data here */\n                        size_t buffersize,     /* max amount to read */\n                        CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t nread;\n\n  /* The SelectClientCert() hook uses this for infof() and failf() but the\n     handle stored in nss_setup_connect() could have already been freed. */\n  backend->data = data;\n\n  nread = PR_Recv(backend->handle, buf, (int)buffersize, 0,\n                  PR_INTERVAL_NO_WAIT);\n  if(nread < 0) {\n    /* failed SSL read */\n    PRInt32 err = PR_GetError();\n\n    if(err == PR_WOULD_BLOCK_ERROR)\n      *curlcode = CURLE_AGAIN;\n    else {\n      /* print the error number and error string */\n      const char *err_name = nss_error_to_name(err);\n      infof(data, \"SSL read: errno %d (%s)\\n\", err, err_name);\n\n      /* print a human-readable message describing the error if available */\n      nss_print_error_message(data, err);\n\n      *curlcode = (is_cc_error(err))\n        ? CURLE_SSL_CERTPROBLEM\n        : CURLE_RECV_ERROR;\n    }\n\n    return -1;\n  }\n\n  return nread;\n}\n\nstatic size_t nss_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"NSS/%s\", NSS_GetVersion());\n}\n\n/* data might be NULL */\nstatic int Curl_nss_seed(struct Curl_easy *data)\n{\n  /* make sure that NSS is initialized */\n  return !!Curl_nss_force_init(data);\n}\n\n/* data might be NULL */\nstatic CURLcode nss_random(struct Curl_easy *data,\n                           unsigned char *entropy,\n                           size_t length)\n{\n  Curl_nss_seed(data);  /* Initiate the seed if not already done */\n\n  if(SECSuccess != PK11_GenerateRandom(entropy, curlx_uztosi(length)))\n    /* signal a failure */\n    return CURLE_FAILED_INIT;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_sha256sum(const unsigned char *tmp, /* input */\n                              size_t tmplen,\n                              unsigned char *sha256sum, /* output */\n                              size_t sha256len)\n{\n  PK11Context *SHA256pw = PK11_CreateDigestContext(SEC_OID_SHA256);\n  unsigned int SHA256out;\n\n  if(!SHA256pw)\n    return CURLE_NOT_BUILT_IN;\n\n  PK11_DigestOp(SHA256pw, tmp, curlx_uztoui(tmplen));\n  PK11_DigestFinal(SHA256pw, sha256sum, &SHA256out, curlx_uztoui(sha256len));\n  PK11_DestroyContext(SHA256pw, PR_TRUE);\n\n  return CURLE_OK;\n}\n\nstatic bool nss_cert_status_request(void)\n{\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic bool nss_false_start(void)\n{\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic void *nss_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_nss = {\n  { CURLSSLBACKEND_NSS, \"nss\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  nss_init,                     /* init */\n  nss_cleanup,                  /* cleanup */\n  nss_version,                  /* version */\n  nss_check_cxn,                /* check_cxn */\n  /* NSS has no shutdown function provided and thus always fail */\n  Curl_none_shutdown,           /* shutdown */\n  Curl_none_data_pending,       /* data_pending */\n  nss_random,                   /* random */\n  nss_cert_status_request,      /* cert_status_request */\n  nss_connect,                  /* connect */\n  nss_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,             /* getsock */\n  nss_get_internals,            /* get_internals */\n  nss_close,                    /* close_one */\n  Curl_none_close_all,          /* close_all */\n  /* NSS has its own session ID cache */\n  Curl_none_session_free,       /* session_free */\n  Curl_none_set_engine,         /* set_engine */\n  Curl_none_set_engine_default, /* set_engine_default */\n  Curl_none_engines_list,       /* engines_list */\n  nss_false_start,              /* false_start */\n  nss_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_NSS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all OpenSSL-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_OPENSSL\n\n#include <limits.h>\n\n/* Wincrypt must be included before anything that could include OpenSSL. */\n#if defined(USE_WIN32_CRYPTO)\n#include <wincrypt.h>\n/* Undefine wincrypt conflicting symbols for BoringSSL. */\n#undef X509_NAME\n#undef X509_EXTENSIONS\n#undef PKCS7_ISSUER_AND_SERIAL\n#undef PKCS7_SIGNER_INFO\n#undef OCSP_REQUEST\n#undef OCSP_RESPONSE\n#endif\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"formdata.h\" /* for the boundary function */\n#include \"url.h\" /* for the ssl config check function */\n#include \"inet_pton.h\"\n#include \"openssl.h\"\n#include \"connect.h\"\n#include \"slist.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"keylog.h\"\n#include \"strcase.h\"\n#include \"hostcheck.h\"\n#include \"multiif.h\"\n#include \"strerror.h\"\n#include \"curl_printf.h\"\n\n#include <openssl/ssl.h>\n#include <openssl/rand.h>\n#include <openssl/x509v3.h>\n#ifndef OPENSSL_NO_DSA\n#include <openssl/dsa.h>\n#endif\n#include <openssl/dh.h>\n#include <openssl/err.h>\n#include <openssl/md5.h>\n#include <openssl/conf.h>\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n#include <openssl/pkcs12.h>\n\n#ifdef USE_AMISSL\n#include \"amigaos.h\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_OCSP)\n#include <openssl/ocsp.h>\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090700fL) && /* 0.9.7 or later */     \\\n  !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_UI_CONSOLE)\n#define USE_OPENSSL_ENGINE\n#include <openssl/engine.h>\n#endif\n\n#include \"warnless.h\"\n#include \"non-ascii.h\" /* for Curl_convert_from_utf8 prototype */\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* Uncomment the ALLOW_RENEG line to a real #define if you want to allow TLS\n   renegotiations when built with BoringSSL. Renegotiating is non-compliant\n   with HTTP/2 and \"an extremely dangerous protocol feature\". Beware.\n\n#define ALLOW_RENEG 1\n */\n\n#ifndef OPENSSL_VERSION_NUMBER\n#error \"OPENSSL_VERSION_NUMBER not defined\"\n#endif\n\n#ifdef USE_OPENSSL_ENGINE\n#include <openssl/ui.h>\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n#define SSL_METHOD_QUAL const\n#else\n#define SSL_METHOD_QUAL\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n#define HAVE_ERR_REMOVE_THREAD_STATE 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && /* OpenSSL 1.1.0+ */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n#define SSLEAY_VERSION_NUMBER OPENSSL_VERSION_NUMBER\n#define HAVE_X509_GET0_EXTENSIONS 1 /* added in 1.1.0 -pre1 */\n#define HAVE_OPAQUE_EVP_PKEY 1 /* since 1.1.0 -pre3 */\n#define HAVE_OPAQUE_RSA_DSA_DH 1 /* since 1.1.0 -pre5 */\n#define CONST_EXTS const\n#define HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED 1\n\n/* funny typecast define due to difference in API */\n#ifdef LIBRESSL_VERSION_NUMBER\n#define ARG2_X509_signature_print (X509_ALGOR *)\n#else\n#define ARG2_X509_signature_print\n#endif\n\n#else\n/* For OpenSSL before 1.1.0 */\n#define ASN1_STRING_get0_data(x) ASN1_STRING_data(x)\n#define X509_get0_notBefore(x) X509_get_notBefore(x)\n#define X509_get0_notAfter(x) X509_get_notAfter(x)\n#define CONST_EXTS /* nope */\n#ifndef LIBRESSL_VERSION_NUMBER\n#define OpenSSL_version_num() SSLeay()\n#endif\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) && /* 1.0.2 or later */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n#define HAVE_X509_GET0_SIGNATURE 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) /* 1.0.2 or later */\n#define HAVE_SSL_GET_SHUTDOWN 1\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10002003L && \\\n  OPENSSL_VERSION_NUMBER <= 0x10002FFFL && \\\n  !defined(OPENSSL_NO_COMP)\n#define HAVE_SSL_COMP_FREE_COMPRESSION_METHODS 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x0090808fL)\n/* not present in older OpenSSL */\n#define OPENSSL_load_builtin_modules(x)\n#endif\n\n/*\n * Whether SSL_CTX_set_keylog_callback is available.\n * OpenSSL: supported since 1.1.1 https://github.com/openssl/openssl/pull/2287\n * BoringSSL: supported since d28f59c27bac (committed 2015-11-19)\n * LibreSSL: unsupported in at least 2.7.2 (explicitly check for it since it\n *           lies and pretends to be OpenSSL 2.0.0).\n */\n#if (OPENSSL_VERSION_NUMBER >= 0x10101000L && \\\n     !defined(LIBRESSL_VERSION_NUMBER)) || \\\n    defined(OPENSSL_IS_BORINGSSL)\n#define HAVE_KEYLOG_CALLBACK\n#endif\n\n/* Whether SSL_CTX_set_ciphersuites is available.\n * OpenSSL: supported since 1.1.1 (commit a53b5be6a05)\n * BoringSSL: no\n * LibreSSL: no\n */\n#if ((OPENSSL_VERSION_NUMBER >= 0x10101000L) && \\\n     !defined(LIBRESSL_VERSION_NUMBER) &&       \\\n     !defined(OPENSSL_IS_BORINGSSL))\n#define HAVE_SSL_CTX_SET_CIPHERSUITES\n#define HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH\n/* SET_EC_CURVES available under the same preconditions: see\n * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html\n */\n#define HAVE_SSL_CTX_SET_EC_CURVES\n#endif\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#define OSSL_PACKAGE \"LibreSSL\"\n#elif defined(OPENSSL_IS_BORINGSSL)\n#define OSSL_PACKAGE \"BoringSSL\"\n#else\n#define OSSL_PACKAGE \"OpenSSL\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n/* up2date versions of OpenSSL maintain the default reasonably secure without\n * breaking compatibility, so it is better not to override the default by curl\n */\n#define DEFAULT_CIPHER_SELECTION NULL\n#else\n/* ... but it is not the case with old versions of OpenSSL */\n#define DEFAULT_CIPHER_SELECTION \\\n  \"ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH\"\n#endif\n\n#ifdef HAVE_OPENSSL_SRP\n/* the function exists */\n#ifdef USE_TLS_SRP\n/* the functionality is not disabled */\n#define USE_OPENSSL_SRP\n#endif\n#endif\n\nstruct ssl_backend_data {\n  struct Curl_easy *logger; /* transfer handle to pass trace logs to, only\n                               using sockindex 0 */\n  /* these ones requires specific SSL-types */\n  SSL_CTX* ctx;\n  SSL*     handle;\n  X509*    server_cert;\n#ifndef HAVE_KEYLOG_CALLBACK\n  /* Set to true once a valid keylog entry has been created to avoid dupes. */\n  bool     keylog_done;\n#endif\n};\n\n/*\n * Number of bytes to read from the random number seed file. This must be\n * a finite value (because some entropy \"files\" like /dev/urandom have\n * an infinite length), but must be large enough to provide enough\n * entropy to properly seed OpenSSL's PRNG.\n */\n#define RAND_LOAD_LENGTH 1024\n\n#ifdef HAVE_KEYLOG_CALLBACK\nstatic void ossl_keylog_callback(const SSL *ssl, const char *line)\n{\n  (void)ssl;\n\n  Curl_tls_keylog_write_line(line);\n}\n#else\n/*\n * ossl_log_tls12_secret is called by libcurl to make the CLIENT_RANDOMs if the\n * OpenSSL being used doesn't have native support for doing that.\n */\nstatic void\nossl_log_tls12_secret(const SSL *ssl, bool *keylog_done)\n{\n  const SSL_SESSION *session = SSL_get_session(ssl);\n  unsigned char client_random[SSL3_RANDOM_SIZE];\n  unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];\n  int master_key_length = 0;\n\n  if(!session || *keylog_done)\n    return;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n  /* ssl->s3 is not checked in openssl 1.1.0-pre6, but let's assume that\n   * we have a valid SSL context if we have a non-NULL session. */\n  SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE);\n  master_key_length = (int)\n    SSL_SESSION_get_master_key(session, master_key, SSL_MAX_MASTER_KEY_LENGTH);\n#else\n  if(ssl->s3 && session->master_key_length > 0) {\n    master_key_length = session->master_key_length;\n    memcpy(master_key, session->master_key, session->master_key_length);\n    memcpy(client_random, ssl->s3->client_random, SSL3_RANDOM_SIZE);\n  }\n#endif\n\n  /* The handshake has not progressed sufficiently yet, or this is a TLS 1.3\n   * session (when curl was built with older OpenSSL headers and running with\n   * newer OpenSSL runtime libraries). */\n  if(master_key_length <= 0)\n    return;\n\n  *keylog_done = true;\n  Curl_tls_keylog_write(\"CLIENT_RANDOM\", client_random,\n                        master_key, master_key_length);\n}\n#endif /* !HAVE_KEYLOG_CALLBACK */\n\nstatic const char *SSL_ERROR_to_str(int err)\n{\n  switch(err) {\n  case SSL_ERROR_NONE:\n    return \"SSL_ERROR_NONE\";\n  case SSL_ERROR_SSL:\n    return \"SSL_ERROR_SSL\";\n  case SSL_ERROR_WANT_READ:\n    return \"SSL_ERROR_WANT_READ\";\n  case SSL_ERROR_WANT_WRITE:\n    return \"SSL_ERROR_WANT_WRITE\";\n  case SSL_ERROR_WANT_X509_LOOKUP:\n    return \"SSL_ERROR_WANT_X509_LOOKUP\";\n  case SSL_ERROR_SYSCALL:\n    return \"SSL_ERROR_SYSCALL\";\n  case SSL_ERROR_ZERO_RETURN:\n    return \"SSL_ERROR_ZERO_RETURN\";\n  case SSL_ERROR_WANT_CONNECT:\n    return \"SSL_ERROR_WANT_CONNECT\";\n  case SSL_ERROR_WANT_ACCEPT:\n    return \"SSL_ERROR_WANT_ACCEPT\";\n#if defined(SSL_ERROR_WANT_ASYNC)\n  case SSL_ERROR_WANT_ASYNC:\n    return \"SSL_ERROR_WANT_ASYNC\";\n#endif\n#if defined(SSL_ERROR_WANT_ASYNC_JOB)\n  case SSL_ERROR_WANT_ASYNC_JOB:\n    return \"SSL_ERROR_WANT_ASYNC_JOB\";\n#endif\n#if defined(SSL_ERROR_WANT_EARLY)\n  case SSL_ERROR_WANT_EARLY:\n    return \"SSL_ERROR_WANT_EARLY\";\n#endif\n  default:\n    return \"SSL_ERROR unknown\";\n  }\n}\n\n/* Return error string for last OpenSSL error\n */\nstatic char *ossl_strerror(unsigned long error, char *buf, size_t size)\n{\n  if(size)\n    *buf = '\\0';\n\n#ifdef OPENSSL_IS_BORINGSSL\n  ERR_error_string_n((uint32_t)error, buf, size);\n#else\n  ERR_error_string_n(error, buf, size);\n#endif\n\n  if(size > 1 && !*buf) {\n    strncpy(buf, (error ? \"Unknown error\" : \"No error\"), size);\n    buf[size - 1] = '\\0';\n  }\n\n  return buf;\n}\n\n/* Return an extra data index for the transfer data.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_data_index(void)\n{\n  static int ssl_ex_data_data_index = -1;\n  if(ssl_ex_data_data_index < 0) {\n    ssl_ex_data_data_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return ssl_ex_data_data_index;\n}\n\n/* Return an extra data index for the connection data.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_conn_index(void)\n{\n  static int ssl_ex_data_conn_index = -1;\n  if(ssl_ex_data_conn_index < 0) {\n    ssl_ex_data_conn_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return ssl_ex_data_conn_index;\n}\n\n/* Return an extra data index for the sockindex.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_sockindex_index(void)\n{\n  static int sockindex_index = -1;\n  if(sockindex_index < 0) {\n    sockindex_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return sockindex_index;\n}\n\n/* Return an extra data index for proxy boolean.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_proxy_index(void)\n{\n  static int proxy_index = -1;\n  if(proxy_index < 0) {\n    proxy_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return proxy_index;\n}\n\nstatic int passwd_callback(char *buf, int num, int encrypting,\n                           void *global_passwd)\n{\n  DEBUGASSERT(0 == encrypting);\n\n  if(!encrypting) {\n    int klen = curlx_uztosi(strlen((char *)global_passwd));\n    if(num > klen) {\n      memcpy(buf, global_passwd, klen + 1);\n      return klen;\n    }\n  }\n  return 0;\n}\n\n/*\n * rand_enough() returns TRUE if we have seeded the random engine properly.\n */\nstatic bool rand_enough(void)\n{\n  return (0 != RAND_status()) ? TRUE : FALSE;\n}\n\nstatic CURLcode ossl_seed(struct Curl_easy *data)\n{\n  /* we have the \"SSL is seeded\" boolean static to prevent multiple\n     time-consuming seedings in vain */\n  static bool ssl_seeded = FALSE;\n  char fname[256];\n\n  if(ssl_seeded)\n    return CURLE_OK;\n\n  if(rand_enough()) {\n    /* OpenSSL 1.1.0+ will return here */\n    ssl_seeded = TRUE;\n    return CURLE_OK;\n  }\n\n#ifndef RANDOM_FILE\n  /* if RANDOM_FILE isn't defined, we only perform this if an option tells\n     us to! */\n  if(data->set.str[STRING_SSL_RANDOM_FILE])\n#define RANDOM_FILE \"\" /* doesn't matter won't be used */\n#endif\n  {\n    /* let the option override the define */\n    RAND_load_file((data->set.str[STRING_SSL_RANDOM_FILE]?\n                    data->set.str[STRING_SSL_RANDOM_FILE]:\n                    RANDOM_FILE),\n                   RAND_LOAD_LENGTH);\n    if(rand_enough())\n      return CURLE_OK;\n  }\n\n#if defined(HAVE_RAND_EGD)\n  /* only available in OpenSSL 0.9.5 and later */\n  /* EGD_SOCKET is set at configure time or not at all */\n#ifndef EGD_SOCKET\n  /* If we don't have the define set, we only do this if the egd-option\n     is set */\n  if(data->set.str[STRING_SSL_EGDSOCKET])\n#define EGD_SOCKET \"\" /* doesn't matter won't be used */\n#endif\n  {\n    /* If there's an option and a define, the option overrides the\n       define */\n    int ret = RAND_egd(data->set.str[STRING_SSL_EGDSOCKET]?\n                       data->set.str[STRING_SSL_EGDSOCKET]:EGD_SOCKET);\n    if(-1 != ret) {\n      if(rand_enough())\n        return CURLE_OK;\n    }\n  }\n#endif\n\n  /* fallback to a custom seeding of the PRNG using a hash based on a current\n     time */\n  do {\n    unsigned char randb[64];\n    size_t len = sizeof(randb);\n    size_t i, i_max;\n    for(i = 0, i_max = len / sizeof(struct curltime); i < i_max; ++i) {\n      struct curltime tv = Curl_now();\n      Curl_wait_ms(1);\n      tv.tv_sec *= i + 1;\n      tv.tv_usec *= (unsigned int)i + 2;\n      tv.tv_sec ^= ((Curl_now().tv_sec + Curl_now().tv_usec) *\n                    (i + 3)) << 8;\n      tv.tv_usec ^= (unsigned int) ((Curl_now().tv_sec +\n                                     Curl_now().tv_usec) *\n                                    (i + 4)) << 16;\n      memcpy(&randb[i * sizeof(struct curltime)], &tv,\n             sizeof(struct curltime));\n    }\n    RAND_add(randb, (int)len, (double)len/2);\n  } while(!rand_enough());\n\n  /* generates a default path for the random seed file */\n  fname[0] = 0; /* blank it first */\n  RAND_file_name(fname, sizeof(fname));\n  if(fname[0]) {\n    /* we got a file name to try */\n    RAND_load_file(fname, RAND_LOAD_LENGTH);\n    if(rand_enough())\n      return CURLE_OK;\n  }\n\n  infof(data, \"libcurl is now using a weak random seed!\\n\");\n  return (rand_enough() ? CURLE_OK :\n    CURLE_SSL_CONNECT_ERROR /* confusing error code */);\n}\n\n#ifndef SSL_FILETYPE_ENGINE\n#define SSL_FILETYPE_ENGINE 42\n#endif\n#ifndef SSL_FILETYPE_PKCS12\n#define SSL_FILETYPE_PKCS12 43\n#endif\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  if(strcasecompare(type, \"ENG\"))\n    return SSL_FILETYPE_ENGINE;\n  if(strcasecompare(type, \"P12\"))\n    return SSL_FILETYPE_PKCS12;\n  return -1;\n}\n\n#ifdef USE_OPENSSL_ENGINE\n/*\n * Supply default password to the engine user interface conversation.\n * The password is passed by OpenSSL engine from ENGINE_load_private_key()\n * last argument to the ui and can be obtained by UI_get0_user_data(ui) here.\n */\nstatic int ssl_ui_reader(UI *ui, UI_STRING *uis)\n{\n  const char *password;\n  switch(UI_get_string_type(uis)) {\n  case UIT_PROMPT:\n  case UIT_VERIFY:\n    password = (const char *)UI_get0_user_data(ui);\n    if(password && (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD)) {\n      UI_set_result(ui, uis, password);\n      return 1;\n    }\n  default:\n    break;\n  }\n  return (UI_method_get_reader(UI_OpenSSL()))(ui, uis);\n}\n\n/*\n * Suppress interactive request for a default password if available.\n */\nstatic int ssl_ui_writer(UI *ui, UI_STRING *uis)\n{\n  switch(UI_get_string_type(uis)) {\n  case UIT_PROMPT:\n  case UIT_VERIFY:\n    if(UI_get0_user_data(ui) &&\n       (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD)) {\n      return 1;\n    }\n  default:\n    break;\n  }\n  return (UI_method_get_writer(UI_OpenSSL()))(ui, uis);\n}\n\n/*\n * Check if a given string is a PKCS#11 URI\n */\nstatic bool is_pkcs11_uri(const char *string)\n{\n  return (string && strncasecompare(string, \"pkcs11:\", 7));\n}\n\n#endif\n\nstatic CURLcode ossl_set_engine(struct Curl_easy *data, const char *engine);\n\nstatic int\nSSL_CTX_use_certificate_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                             int type, const char *key_passwd)\n{\n  int ret = 0;\n  X509 *x = NULL;\n  /* the typecast of blob->len is fine since it is guaranteed to never be\n     larger than CURL_MAX_INPUT_LENGTH */\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(type == SSL_FILETYPE_ASN1) {\n    /* j = ERR_R_ASN1_LIB; */\n    x = d2i_X509_bio(in, NULL);\n  }\n  else if(type == SSL_FILETYPE_PEM) {\n    /* ERR_R_PEM_LIB; */\n    x = PEM_read_bio_X509(in, NULL,\n                          passwd_callback, (void *)key_passwd);\n  }\n  else {\n    ret = 0;\n    goto end;\n  }\n\n  if(!x) {\n    ret = 0;\n    goto end;\n  }\n\n  ret = SSL_CTX_use_certificate(ctx, x);\n end:\n  X509_free(x);\n  BIO_free(in);\n  return ret;\n}\n\nstatic int\nSSL_CTX_use_PrivateKey_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                           int type, const char *key_passwd)\n{\n  int ret = 0;\n  EVP_PKEY *pkey = NULL;\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(type == SSL_FILETYPE_PEM)\n    pkey = PEM_read_bio_PrivateKey(in, NULL, passwd_callback,\n                                   (void *)key_passwd);\n  else if(type == SSL_FILETYPE_ASN1)\n    pkey = d2i_PrivateKey_bio(in, NULL);\n  else {\n    ret = 0;\n    goto end;\n  }\n  if(!pkey) {\n    ret = 0;\n    goto end;\n  }\n  ret = SSL_CTX_use_PrivateKey(ctx, pkey);\n  EVP_PKEY_free(pkey);\n  end:\n  BIO_free(in);\n  return ret;\n}\n\nstatic int\nSSL_CTX_use_certificate_chain_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                                   const char *key_passwd)\n{\n/* SSL_CTX_add1_chain_cert introduced in OpenSSL 1.0.2 */\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) && /* OpenSSL 1.0.2 or later */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      (LIBRESSL_VERSION_NUMBER < 0x2090100fL)) /* LibreSSL 2.9.1 or later */\n  int ret = 0;\n  X509 *x = NULL;\n  void *passwd_callback_userdata = (void *)key_passwd;\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  ERR_clear_error();\n\n  x = PEM_read_bio_X509_AUX(in, NULL,\n                            passwd_callback, (void *)key_passwd);\n\n  if(!x) {\n    ret = 0;\n    goto end;\n  }\n\n  ret = SSL_CTX_use_certificate(ctx, x);\n\n  if(ERR_peek_error() != 0)\n    ret = 0;\n\n  if(ret) {\n    X509 *ca;\n    unsigned long err;\n\n    if(!SSL_CTX_clear_chain_certs(ctx)) {\n      ret = 0;\n      goto end;\n    }\n\n    while((ca = PEM_read_bio_X509(in, NULL, passwd_callback,\n                                  passwd_callback_userdata))\n          != NULL) {\n\n      if(!SSL_CTX_add0_chain_cert(ctx, ca)) {\n        X509_free(ca);\n        ret = 0;\n        goto end;\n      }\n    }\n\n    err = ERR_peek_last_error();\n    if((ERR_GET_LIB(err) == ERR_LIB_PEM) &&\n       (ERR_GET_REASON(err) == PEM_R_NO_START_LINE))\n      ERR_clear_error();\n    else\n      ret = 0;\n  }\n\n end:\n  X509_free(x);\n  BIO_free(in);\n  return ret;\n#else\n  (void)ctx; /* unused */\n  (void)blob; /* unused */\n  (void)key_passwd; /* unused */\n  return 0;\n#endif\n}\n\nstatic\nint cert_stuff(struct Curl_easy *data,\n               SSL_CTX* ctx,\n               char *cert_file,\n               const struct curl_blob *cert_blob,\n               const char *cert_type,\n               char *key_file,\n               const struct curl_blob *key_blob,\n               const char *key_type,\n               char *key_passwd)\n{\n  char error_buffer[256];\n  bool check_privkey = TRUE;\n\n  int file_type = do_file_type(cert_type);\n\n  if(cert_file || cert_blob || (file_type == SSL_FILETYPE_ENGINE)) {\n    SSL *ssl;\n    X509 *x509;\n    int cert_done = 0;\n    int cert_use_result;\n\n    if(key_passwd) {\n      /* set the password in the callback userdata */\n      SSL_CTX_set_default_passwd_cb_userdata(ctx, key_passwd);\n      /* Set passwd callback: */\n      SSL_CTX_set_default_passwd_cb(ctx, passwd_callback);\n    }\n\n\n    switch(file_type) {\n    case SSL_FILETYPE_PEM:\n      /* SSL_CTX_use_certificate_chain_file() only works on PEM files */\n      cert_use_result = cert_blob ?\n        SSL_CTX_use_certificate_chain_blob(ctx, cert_blob, key_passwd) :\n        SSL_CTX_use_certificate_chain_file(ctx, cert_file);\n      if(cert_use_result != 1) {\n        failf(data,\n              \"could not load PEM client certificate, \" OSSL_PACKAGE\n              \" error %s, \"\n              \"(no key found, wrong pass phrase, or wrong file format?)\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        return 0;\n      }\n      break;\n\n    case SSL_FILETYPE_ASN1:\n      /* SSL_CTX_use_certificate_file() works with either PEM or ASN1, but\n         we use the case above for PEM so this can only be performed with\n         ASN1 files. */\n\n      cert_use_result = cert_blob ?\n        SSL_CTX_use_certificate_blob(ctx, cert_blob,\n                                     file_type, key_passwd) :\n        SSL_CTX_use_certificate_file(ctx, cert_file, file_type);\n      if(cert_use_result != 1) {\n        failf(data,\n              \"could not load ASN1 client certificate, \" OSSL_PACKAGE\n              \" error %s, \"\n              \"(no key found, wrong pass phrase, or wrong file format?)\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        return 0;\n      }\n      break;\n    case SSL_FILETYPE_ENGINE:\n#if defined(USE_OPENSSL_ENGINE) && defined(ENGINE_CTRL_GET_CMD_FROM_NAME)\n      {\n        /* Implicitly use pkcs11 engine if none was provided and the\n         * cert_file is a PKCS#11 URI */\n        if(!data->state.engine) {\n          if(is_pkcs11_uri(cert_file)) {\n            if(ossl_set_engine(data, \"pkcs11\") != CURLE_OK) {\n              return 0;\n            }\n          }\n        }\n\n        if(data->state.engine) {\n          const char *cmd_name = \"LOAD_CERT_CTRL\";\n          struct {\n            const char *cert_id;\n            X509 *cert;\n          } params;\n\n          params.cert_id = cert_file;\n          params.cert = NULL;\n\n          /* Does the engine supports LOAD_CERT_CTRL ? */\n          if(!ENGINE_ctrl(data->state.engine, ENGINE_CTRL_GET_CMD_FROM_NAME,\n                          0, (void *)cmd_name, NULL)) {\n            failf(data, \"ssl engine does not support loading certificates\");\n            return 0;\n          }\n\n          /* Load the certificate from the engine */\n          if(!ENGINE_ctrl_cmd(data->state.engine, cmd_name,\n                              0, &params, NULL, 1)) {\n            failf(data, \"ssl engine cannot load client cert with id\"\n                  \" '%s' [%s]\", cert_file,\n                  ossl_strerror(ERR_get_error(), error_buffer,\n                                sizeof(error_buffer)));\n            return 0;\n          }\n\n          if(!params.cert) {\n            failf(data, \"ssl engine didn't initialized the certificate \"\n                  \"properly.\");\n            return 0;\n          }\n\n          if(SSL_CTX_use_certificate(ctx, params.cert) != 1) {\n            failf(data, \"unable to set client certificate\");\n            X509_free(params.cert);\n            return 0;\n          }\n          X509_free(params.cert); /* we don't need the handle any more... */\n        }\n        else {\n          failf(data, \"crypto engine not set, can't load certificate\");\n          return 0;\n        }\n      }\n      break;\n#else\n      failf(data, \"file type ENG for certificate not implemented\");\n      return 0;\n#endif\n\n    case SSL_FILETYPE_PKCS12:\n    {\n      BIO *cert_bio = NULL;\n      PKCS12 *p12 = NULL;\n      EVP_PKEY *pri;\n      STACK_OF(X509) *ca = NULL;\n      if(cert_blob) {\n        cert_bio = BIO_new_mem_buf(cert_blob->data, (int)(cert_blob->len));\n        if(!cert_bio) {\n          failf(data,\n                \"BIO_new_mem_buf NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          return 0;\n        }\n      }\n      else {\n        cert_bio = BIO_new(BIO_s_file());\n        if(!cert_bio) {\n          failf(data,\n                \"BIO_new return NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          return 0;\n        }\n\n        if(BIO_read_filename(cert_bio, cert_file) <= 0) {\n          failf(data, \"could not open PKCS12 file '%s'\", cert_file);\n          BIO_free(cert_bio);\n          return 0;\n        }\n      }\n\n      p12 = d2i_PKCS12_bio(cert_bio, NULL);\n      BIO_free(cert_bio);\n\n      if(!p12) {\n        failf(data, \"error reading PKCS12 file '%s'\",\n              cert_blob ? \"(memory blob)\" : cert_file);\n        return 0;\n      }\n\n      PKCS12_PBE_add();\n\n      if(!PKCS12_parse(p12, key_passwd, &pri, &x509,\n                       &ca)) {\n        failf(data,\n              \"could not parse PKCS12 file, check password, \" OSSL_PACKAGE\n              \" error %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        PKCS12_free(p12);\n        return 0;\n      }\n\n      PKCS12_free(p12);\n\n      if(SSL_CTX_use_certificate(ctx, x509) != 1) {\n        failf(data,\n              \"could not load PKCS12 client certificate, \" OSSL_PACKAGE\n              \" error %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        goto fail;\n      }\n\n      if(SSL_CTX_use_PrivateKey(ctx, pri) != 1) {\n        failf(data, \"unable to use private key from PKCS12 file '%s'\",\n              cert_file);\n        goto fail;\n      }\n\n      if(!SSL_CTX_check_private_key (ctx)) {\n        failf(data, \"private key from PKCS12 file '%s' \"\n              \"does not match certificate in same file\", cert_file);\n        goto fail;\n      }\n      /* Set Certificate Verification chain */\n      if(ca) {\n        while(sk_X509_num(ca)) {\n          /*\n           * Note that sk_X509_pop() is used below to make sure the cert is\n           * removed from the stack properly before getting passed to\n           * SSL_CTX_add_extra_chain_cert(), which takes ownership. Previously\n           * we used sk_X509_value() instead, but then we'd clean it in the\n           * subsequent sk_X509_pop_free() call.\n           */\n          X509 *x = sk_X509_pop(ca);\n          if(!SSL_CTX_add_client_CA(ctx, x)) {\n            X509_free(x);\n            failf(data, \"cannot add certificate to client CA list\");\n            goto fail;\n          }\n          if(!SSL_CTX_add_extra_chain_cert(ctx, x)) {\n            X509_free(x);\n            failf(data, \"cannot add certificate to certificate chain\");\n            goto fail;\n          }\n        }\n      }\n\n      cert_done = 1;\n  fail:\n      EVP_PKEY_free(pri);\n      X509_free(x509);\n#ifdef USE_AMISSL\n      sk_X509_pop_free(ca, Curl_amiga_X509_free);\n#else\n      sk_X509_pop_free(ca, X509_free);\n#endif\n      if(!cert_done)\n        return 0; /* failure! */\n      break;\n    }\n    default:\n      failf(data, \"not supported file type '%s' for certificate\", cert_type);\n      return 0;\n    }\n\n    if((!key_file) && (!key_blob)) {\n      key_file = cert_file;\n      key_blob = cert_blob;\n    }\n    else\n      file_type = do_file_type(key_type);\n\n    switch(file_type) {\n    case SSL_FILETYPE_PEM:\n      if(cert_done)\n        break;\n      /* FALLTHROUGH */\n    case SSL_FILETYPE_ASN1:\n      cert_use_result = key_blob ?\n        SSL_CTX_use_PrivateKey_blob(ctx, key_blob, file_type, key_passwd) :\n        SSL_CTX_use_PrivateKey_file(ctx, key_file, file_type);\n      if(cert_use_result != 1) {\n        failf(data, \"unable to set private key file: '%s' type %s\",\n              key_file?key_file:\"(memory blob)\", key_type?key_type:\"PEM\");\n        return 0;\n      }\n      break;\n    case SSL_FILETYPE_ENGINE:\n#ifdef USE_OPENSSL_ENGINE\n      {                         /* XXXX still needs some work */\n        EVP_PKEY *priv_key = NULL;\n\n        /* Implicitly use pkcs11 engine if none was provided and the\n         * key_file is a PKCS#11 URI */\n        if(!data->state.engine) {\n          if(is_pkcs11_uri(key_file)) {\n            if(ossl_set_engine(data, \"pkcs11\") != CURLE_OK) {\n              return 0;\n            }\n          }\n        }\n\n        if(data->state.engine) {\n          UI_METHOD *ui_method =\n            UI_create_method((char *)\"curl user interface\");\n          if(!ui_method) {\n            failf(data, \"unable do create \" OSSL_PACKAGE\n                  \" user-interface method\");\n            return 0;\n          }\n          UI_method_set_opener(ui_method, UI_method_get_opener(UI_OpenSSL()));\n          UI_method_set_closer(ui_method, UI_method_get_closer(UI_OpenSSL()));\n          UI_method_set_reader(ui_method, ssl_ui_reader);\n          UI_method_set_writer(ui_method, ssl_ui_writer);\n          /* the typecast below was added to please mingw32 */\n          priv_key = (EVP_PKEY *)\n            ENGINE_load_private_key(data->state.engine, key_file,\n                                    ui_method,\n                                    key_passwd);\n          UI_destroy_method(ui_method);\n          if(!priv_key) {\n            failf(data, \"failed to load private key from crypto engine\");\n            return 0;\n          }\n          if(SSL_CTX_use_PrivateKey(ctx, priv_key) != 1) {\n            failf(data, \"unable to set private key\");\n            EVP_PKEY_free(priv_key);\n            return 0;\n          }\n          EVP_PKEY_free(priv_key);  /* we don't need the handle any more... */\n        }\n        else {\n          failf(data, \"crypto engine not set, can't load private key\");\n          return 0;\n        }\n      }\n      break;\n#else\n      failf(data, \"file type ENG for private key not supported\");\n      return 0;\n#endif\n    case SSL_FILETYPE_PKCS12:\n      if(!cert_done) {\n        failf(data, \"file type P12 for private key not supported\");\n        return 0;\n      }\n      break;\n    default:\n      failf(data, \"not supported file type for private key\");\n      return 0;\n    }\n\n    ssl = SSL_new(ctx);\n    if(!ssl) {\n      failf(data, \"unable to create an SSL structure\");\n      return 0;\n    }\n\n    x509 = SSL_get_certificate(ssl);\n\n    /* This version was provided by Evan Jordan and is supposed to not\n       leak memory as the previous version: */\n    if(x509) {\n      EVP_PKEY *pktmp = X509_get_pubkey(x509);\n      EVP_PKEY_copy_parameters(pktmp, SSL_get_privatekey(ssl));\n      EVP_PKEY_free(pktmp);\n    }\n\n#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_IS_BORINGSSL)\n    {\n      /* If RSA is used, don't check the private key if its flags indicate\n       * it doesn't support it. */\n      EVP_PKEY *priv_key = SSL_get_privatekey(ssl);\n      int pktype;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n      pktype = EVP_PKEY_id(priv_key);\n#else\n      pktype = priv_key->type;\n#endif\n      if(pktype == EVP_PKEY_RSA) {\n        RSA *rsa = EVP_PKEY_get1_RSA(priv_key);\n        if(RSA_flags(rsa) & RSA_METHOD_FLAG_NO_CHECK)\n          check_privkey = FALSE;\n        RSA_free(rsa); /* Decrement reference count */\n      }\n    }\n#endif\n\n    SSL_free(ssl);\n\n    /* If we are using DSA, we can copy the parameters from\n     * the private key */\n\n    if(check_privkey == TRUE) {\n      /* Now we know that a key and cert have been set against\n       * the SSL context */\n      if(!SSL_CTX_check_private_key(ctx)) {\n        failf(data, \"Private key does not match the certificate public key\");\n        return 0;\n      }\n    }\n  }\n  return 1;\n}\n\n/* returns non-zero on failure */\nstatic int x509_name_oneline(X509_NAME *a, char *buf, size_t size)\n{\n  BIO *bio_out = BIO_new(BIO_s_mem());\n  BUF_MEM *biomem;\n  int rc;\n\n  if(!bio_out)\n    return 1; /* alloc failed! */\n\n  rc = X509_NAME_print_ex(bio_out, a, 0, XN_FLAG_SEP_SPLUS_SPC);\n  BIO_get_mem_ptr(bio_out, &biomem);\n\n  if((size_t)biomem->length < size)\n    size = biomem->length;\n  else\n    size--; /* don't overwrite the buffer end */\n\n  memcpy(buf, biomem->data, size);\n  buf[size] = 0;\n\n  BIO_free(bio_out);\n\n  return !rc;\n}\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nstatic int ossl_init(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) &&  \\\n  !defined(LIBRESSL_VERSION_NUMBER)\n  const uint64_t flags =\n#ifdef OPENSSL_INIT_ENGINE_ALL_BUILTIN\n    /* not present in BoringSSL */\n    OPENSSL_INIT_ENGINE_ALL_BUILTIN |\n#endif\n#ifdef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG\n    OPENSSL_INIT_NO_LOAD_CONFIG |\n#else\n    OPENSSL_INIT_LOAD_CONFIG |\n#endif\n    0;\n  OPENSSL_init_ssl(flags, NULL);\n#else\n  OPENSSL_load_builtin_modules();\n\n#ifdef USE_OPENSSL_ENGINE\n  ENGINE_load_builtin_engines();\n#endif\n\n/* CONF_MFLAGS_DEFAULT_SECTION was introduced some time between 0.9.8b and\n   0.9.8e */\n#ifndef CONF_MFLAGS_DEFAULT_SECTION\n#define CONF_MFLAGS_DEFAULT_SECTION 0x0\n#endif\n\n#ifndef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG\n  CONF_modules_load_file(NULL, NULL,\n                         CONF_MFLAGS_DEFAULT_SECTION|\n                         CONF_MFLAGS_IGNORE_MISSING_FILE);\n#endif\n\n  /* Lets get nice error messages */\n  SSL_load_error_strings();\n\n  /* Init the global ciphers and digests */\n  if(!SSLeay_add_ssl_algorithms())\n    return 0;\n\n  OpenSSL_add_all_algorithms();\n#endif\n\n  Curl_tls_keylog_open();\n\n  /* Initialize the extra data indexes */\n  if(ossl_get_ssl_data_index() < 0 || ossl_get_ssl_conn_index() < 0 ||\n     ossl_get_ssl_sockindex_index() < 0 || ossl_get_proxy_index() < 0)\n    return 0;\n\n  return 1;\n}\n\n/* Global cleanup */\nstatic void ossl_cleanup(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && \\\n    !defined(LIBRESSL_VERSION_NUMBER)\n  /* OpenSSL 1.1 deprecates all these cleanup functions and\n     turns them into no-ops in OpenSSL 1.0 compatibility mode */\n#else\n  /* Free ciphers and digests lists */\n  EVP_cleanup();\n\n#ifdef USE_OPENSSL_ENGINE\n  /* Free engine list */\n  ENGINE_cleanup();\n#endif\n\n  /* Free OpenSSL error strings */\n  ERR_free_strings();\n\n  /* Free thread local error state, destroying hash upon zero refcount */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n  ERR_remove_thread_state(NULL);\n#else\n  ERR_remove_state(0);\n#endif\n\n  /* Free all memory allocated by all configuration modules */\n  CONF_modules_free();\n\n#ifdef HAVE_SSL_COMP_FREE_COMPRESSION_METHODS\n  SSL_COMP_free_compression_methods();\n#endif\n#endif\n\n  Curl_tls_keylog_close();\n}\n\n/*\n * This function is used to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int ossl_check_cxn(struct connectdata *conn)\n{\n  /* SSL_peek takes data out of the raw recv buffer without peeking so we use\n     recv MSG_PEEK instead. Bug #795 */\n#ifdef MSG_PEEK\n  char buf;\n  ssize_t nread;\n  nread = recv((RECV_TYPE_ARG1)conn->sock[FIRSTSOCKET], (RECV_TYPE_ARG2)&buf,\n               (RECV_TYPE_ARG3)1, (RECV_TYPE_ARG4)MSG_PEEK);\n  if(nread == 0)\n    return 0; /* connection has been closed */\n  if(nread == 1)\n    return 1; /* connection still in place */\n  else if(nread == -1) {\n      int err = SOCKERRNO;\n      if(err == EINPROGRESS ||\n#if defined(EAGAIN) && (EAGAIN != EWOULDBLOCK)\n         err == EAGAIN ||\n#endif\n         err == EWOULDBLOCK)\n        return 1; /* connection still in place */\n      if(err == ECONNRESET ||\n#ifdef ECONNABORTED\n         err == ECONNABORTED ||\n#endif\n#ifdef ENETDOWN\n         err == ENETDOWN ||\n#endif\n#ifdef ENETRESET\n         err == ENETRESET ||\n#endif\n#ifdef ESHUTDOWN\n         err == ESHUTDOWN ||\n#endif\n#ifdef ETIMEDOUT\n         err == ETIMEDOUT ||\n#endif\n         err == ENOTCONN)\n        return 0; /* connection has been closed */\n  }\n#endif\n  return -1; /* connection status unknown */\n}\n\n/* Selects an OpenSSL crypto engine\n */\nstatic CURLcode ossl_set_engine(struct Curl_easy *data, const char *engine)\n{\n#ifdef USE_OPENSSL_ENGINE\n  ENGINE *e;\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n  e = ENGINE_by_id(engine);\n#else\n  /* avoid memory leak */\n  for(e = ENGINE_get_first(); e; e = ENGINE_get_next(e)) {\n    const char *e_id = ENGINE_get_id(e);\n    if(!strcmp(engine, e_id))\n      break;\n  }\n#endif\n\n  if(!e) {\n    failf(data, \"SSL Engine '%s' not found\", engine);\n    return CURLE_SSL_ENGINE_NOTFOUND;\n  }\n\n  if(data->state.engine) {\n    ENGINE_finish(data->state.engine);\n    ENGINE_free(data->state.engine);\n    data->state.engine = NULL;\n  }\n  if(!ENGINE_init(e)) {\n    char buf[256];\n\n    ENGINE_free(e);\n    failf(data, \"Failed to initialise SSL Engine '%s': %s\",\n          engine, ossl_strerror(ERR_get_error(), buf, sizeof(buf)));\n    return CURLE_SSL_ENGINE_INITFAILED;\n  }\n  data->state.engine = e;\n  return CURLE_OK;\n#else\n  (void)engine;\n  failf(data, \"SSL Engine not supported\");\n  return CURLE_SSL_ENGINE_NOTFOUND;\n#endif\n}\n\n/* Sets engine as default for all SSL operations\n */\nstatic CURLcode ossl_set_engine_default(struct Curl_easy *data)\n{\n#ifdef USE_OPENSSL_ENGINE\n  if(data->state.engine) {\n    if(ENGINE_set_default(data->state.engine, ENGINE_METHOD_ALL) > 0) {\n      infof(data, \"set default crypto engine '%s'\\n\",\n            ENGINE_get_id(data->state.engine));\n    }\n    else {\n      failf(data, \"set default crypto engine '%s' failed\",\n            ENGINE_get_id(data->state.engine));\n      return CURLE_SSL_ENGINE_SETFAILED;\n    }\n  }\n#else\n  (void) data;\n#endif\n  return CURLE_OK;\n}\n\n/* Return list of OpenSSL crypto engine names.\n */\nstatic struct curl_slist *ossl_engines_list(struct Curl_easy *data)\n{\n  struct curl_slist *list = NULL;\n#ifdef USE_OPENSSL_ENGINE\n  struct curl_slist *beg;\n  ENGINE *e;\n\n  for(e = ENGINE_get_first(); e; e = ENGINE_get_next(e)) {\n    beg = curl_slist_append(list, ENGINE_get_id(e));\n    if(!beg) {\n      curl_slist_free_all(list);\n      return NULL;\n    }\n    list = beg;\n  }\n#endif\n  (void) data;\n  return list;\n}\n\n#define set_logger(conn, data)                  \\\n  conn->ssl[0].backend->logger = data\n\nstatic void ossl_closeone(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          struct ssl_connect_data *connssl)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->handle) {\n    set_logger(conn, data);\n    (void)SSL_shutdown(backend->handle);\n    SSL_set_connect_state(backend->handle);\n\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  if(backend->ctx) {\n    SSL_CTX_free(backend->ctx);\n    backend->ctx = NULL;\n  }\n}\n\n/*\n * This function is called when an SSL connection is closed.\n */\nstatic void ossl_close(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ossl_closeone(data, conn, &conn->ssl[sockindex]);\n#ifndef CURL_DISABLE_PROXY\n  ossl_closeone(data, conn, &conn->proxy_ssl[sockindex]);\n#endif\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int ossl_shutdown(struct Curl_easy *data,\n                         struct connectdata *conn, int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char buf[256]; /* We will use this for the OpenSSL error buffer, so it has\n                    to be at least 256 bytes long. */\n  unsigned long sslerror;\n  ssize_t nread;\n  int buffsize;\n  int err;\n  bool done = FALSE;\n  struct ssl_backend_data *backend = connssl->backend;\n\n#ifndef CURL_DISABLE_FTP\n  /* This has only been tested on the proftpd server, and the mod_tls code\n     sends a close notify alert without waiting for a close notify alert in\n     response. Thus we wait for a close notify alert from the server, but\n     we do not send one. Let's hope other servers do the same... */\n\n  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)\n      (void)SSL_shutdown(backend->handle);\n#endif\n\n  if(backend->handle) {\n    buffsize = (int)sizeof(buf);\n    while(!done) {\n      int what = SOCKET_READABLE(conn->sock[sockindex],\n                                 SSL_SHUTDOWN_TIMEOUT);\n      if(what > 0) {\n        ERR_clear_error();\n\n        /* Something to read, let's do it and hope that it is the close\n           notify alert from the server */\n        nread = (ssize_t)SSL_read(backend->handle, buf, buffsize);\n        err = SSL_get_error(backend->handle, (int)nread);\n\n        switch(err) {\n        case SSL_ERROR_NONE: /* this is not an error */\n        case SSL_ERROR_ZERO_RETURN: /* no more data */\n          /* This is the expected response. There was no data but only\n             the close notify alert */\n          done = TRUE;\n          break;\n        case SSL_ERROR_WANT_READ:\n          /* there's data pending, re-invoke SSL_read() */\n          infof(data, \"SSL_ERROR_WANT_READ\\n\");\n          break;\n        case SSL_ERROR_WANT_WRITE:\n          /* SSL wants a write. Really odd. Let's bail out. */\n          infof(data, \"SSL_ERROR_WANT_WRITE\\n\");\n          done = TRUE;\n          break;\n        default:\n          /* openssl/ssl.h says \"look at error stack/return value/errno\" */\n          sslerror = ERR_get_error();\n          failf(data, OSSL_PACKAGE \" SSL_read on shutdown: %s, errno %d\",\n                (sslerror ?\n                 ossl_strerror(sslerror, buf, sizeof(buf)) :\n                 SSL_ERROR_to_str(err)),\n                SOCKERRNO);\n          done = TRUE;\n          break;\n        }\n      }\n      else if(0 == what) {\n        /* timeout */\n        failf(data, \"SSL shutdown timeout\");\n        done = TRUE;\n      }\n      else {\n        /* anything that gets here is fatally bad */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        retval = -1;\n        done = TRUE;\n      }\n    } /* while()-loop for the select() */\n\n    if(data->set.verbose) {\n#ifdef HAVE_SSL_GET_SHUTDOWN\n      switch(SSL_get_shutdown(backend->handle)) {\n      case SSL_SENT_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_SENT_SHUTDOWN\\n\");\n        break;\n      case SSL_RECEIVED_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_RECEIVED_SHUTDOWN\\n\");\n        break;\n      case SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_SENT_SHUTDOWN|\"\n              \"SSL_RECEIVED__SHUTDOWN\\n\");\n        break;\n      }\n#endif\n    }\n\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  return retval;\n}\n\nstatic void ossl_session_free(void *ptr)\n{\n  /* free the ID */\n  SSL_SESSION_free(ptr);\n}\n\n/*\n * This function is called when the 'data' struct is going away. Close\n * down everything and free all resources!\n */\nstatic void ossl_close_all(struct Curl_easy *data)\n{\n#ifdef USE_OPENSSL_ENGINE\n  if(data->state.engine) {\n    ENGINE_finish(data->state.engine);\n    ENGINE_free(data->state.engine);\n    data->state.engine = NULL;\n  }\n#else\n  (void)data;\n#endif\n#if !defined(HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED) && \\\n  defined(HAVE_ERR_REMOVE_THREAD_STATE)\n  /* OpenSSL 1.0.1 and 1.0.2 build an error queue that is stored per-thread\n     so we need to clean it here in case the thread will be killed. All OpenSSL\n     code should extract the error in association with the error so clearing\n     this queue here should be harmless at worst. */\n  ERR_remove_thread_state(NULL);\n#endif\n}\n\n/* ====================================================== */\n\n/*\n * Match subjectAltName against the host name. This requires a conversion\n * in CURL_DOES_CONVERSIONS builds.\n */\nstatic bool subj_alt_hostcheck(struct Curl_easy *data,\n                               const char *match_pattern, const char *hostname,\n                               const char *dispname)\n#ifdef CURL_DOES_CONVERSIONS\n{\n  bool res = FALSE;\n\n  /* Curl_cert_hostcheck uses host encoding, but we get ASCII from\n     OpenSSl.\n   */\n  char *match_pattern2 = strdup(match_pattern);\n\n  if(match_pattern2) {\n    if(Curl_convert_from_network(data, match_pattern2,\n                                strlen(match_pattern2)) == CURLE_OK) {\n      if(Curl_cert_hostcheck(match_pattern2, hostname)) {\n        res = TRUE;\n        infof(data,\n                \" subjectAltName: host \\\"%s\\\" matched cert's \\\"%s\\\"\\n\",\n                dispname, match_pattern2);\n      }\n    }\n    free(match_pattern2);\n  }\n  else {\n    failf(data,\n        \"SSL: out of memory when allocating temporary for subjectAltName\");\n  }\n  return res;\n}\n#else\n{\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n  (void)dispname;\n  (void)data;\n#endif\n  if(Curl_cert_hostcheck(match_pattern, hostname)) {\n    infof(data, \" subjectAltName: host \\\"%s\\\" matched cert's \\\"%s\\\"\\n\",\n                  dispname, match_pattern);\n    return TRUE;\n  }\n  return FALSE;\n}\n#endif\n\n\n/* Quote from RFC2818 section 3.1 \"Server Identity\"\n\n   If a subjectAltName extension of type dNSName is present, that MUST\n   be used as the identity. Otherwise, the (most specific) Common Name\n   field in the Subject field of the certificate MUST be used. Although\n   the use of the Common Name is existing practice, it is deprecated and\n   Certification Authorities are encouraged to use the dNSName instead.\n\n   Matching is performed using the matching rules specified by\n   [RFC2459].  If more than one identity of a given type is present in\n   the certificate (e.g., more than one dNSName name, a match in any one\n   of the set is considered acceptable.) Names may contain the wildcard\n   character * which is considered to match any single domain name\n   component or component fragment. E.g., *.a.com matches foo.a.com but\n   not bar.foo.a.com. f*.com matches foo.com but not bar.com.\n\n   In some cases, the URI is specified as an IP address rather than a\n   hostname. In this case, the iPAddress subjectAltName must be present\n   in the certificate and must exactly match the IP in the URI.\n\n*/\nstatic CURLcode verifyhost(struct Curl_easy *data, struct connectdata *conn,\n                           X509 *server_cert)\n{\n  bool matched = FALSE;\n  int target = GEN_DNS; /* target type, GEN_DNS or GEN_IPADD */\n  size_t addrlen = 0;\n  STACK_OF(GENERAL_NAME) *altnames;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  CURLcode result = CURLE_OK;\n  bool dNSName = FALSE; /* if a dNSName field exists in the cert */\n  bool iPAddress = FALSE; /* if a iPAddress field exists in the cert */\n  const char * const hostname = SSL_HOST_NAME();\n  const char * const dispname = SSL_HOST_DISPNAME();\n\n#ifdef ENABLE_IPV6\n  if(conn->bits.ipv6_ip &&\n     Curl_inet_pton(AF_INET6, hostname, &addr)) {\n    target = GEN_IPADD;\n    addrlen = sizeof(struct in6_addr);\n  }\n  else\n#endif\n    if(Curl_inet_pton(AF_INET, hostname, &addr)) {\n      target = GEN_IPADD;\n      addrlen = sizeof(struct in_addr);\n    }\n\n  /* get a \"list\" of alternative names */\n  altnames = X509_get_ext_d2i(server_cert, NID_subject_alt_name, NULL, NULL);\n\n  if(altnames) {\n#ifdef OPENSSL_IS_BORINGSSL\n    size_t numalts;\n    size_t i;\n#else\n    int numalts;\n    int i;\n#endif\n    bool dnsmatched = FALSE;\n    bool ipmatched = FALSE;\n\n    /* get amount of alternatives, RFC2459 claims there MUST be at least\n       one, but we don't depend on it... */\n    numalts = sk_GENERAL_NAME_num(altnames);\n\n    /* loop through all alternatives - until a dnsmatch */\n    for(i = 0; (i < numalts) && !dnsmatched; i++) {\n      /* get a handle to alternative name number i */\n      const GENERAL_NAME *check = sk_GENERAL_NAME_value(altnames, i);\n\n      if(check->type == GEN_DNS)\n        dNSName = TRUE;\n      else if(check->type == GEN_IPADD)\n        iPAddress = TRUE;\n\n      /* only check alternatives of the same type the target is */\n      if(check->type == target) {\n        /* get data and length */\n        const char *altptr = (char *)ASN1_STRING_get0_data(check->d.ia5);\n        size_t altlen = (size_t) ASN1_STRING_length(check->d.ia5);\n\n        switch(target) {\n        case GEN_DNS: /* name/pattern comparison */\n          /* The OpenSSL man page explicitly says: \"In general it cannot be\n             assumed that the data returned by ASN1_STRING_data() is null\n             terminated or does not contain embedded nulls.\" But also that\n             \"The actual format of the data will depend on the actual string\n             type itself: for example for an IA5String the data will be ASCII\"\n\n             It has been however verified that in 0.9.6 and 0.9.7, IA5String\n             is always null-terminated.\n          */\n          if((altlen == strlen(altptr)) &&\n             /* if this isn't true, there was an embedded zero in the name\n                string and we cannot match it. */\n             subj_alt_hostcheck(data, altptr, hostname, dispname)) {\n            dnsmatched = TRUE;\n          }\n          break;\n\n        case GEN_IPADD: /* IP address comparison */\n          /* compare alternative IP address if the data chunk is the same size\n             our server IP address is */\n          if((altlen == addrlen) && !memcmp(altptr, &addr, altlen)) {\n            ipmatched = TRUE;\n            infof(data,\n                  \" subjectAltName: host \\\"%s\\\" matched cert's IP address!\\n\",\n                  dispname);\n          }\n          break;\n        }\n      }\n    }\n    GENERAL_NAMES_free(altnames);\n\n    if(dnsmatched || ipmatched)\n      matched = TRUE;\n  }\n\n  if(matched)\n    /* an alternative name matched */\n    ;\n  else if(dNSName || iPAddress) {\n    infof(data, \" subjectAltName does not match %s\\n\", dispname);\n    failf(data, \"SSL: no alternative certificate subject name matches \"\n          \"target host name '%s'\", dispname);\n    result = CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else {\n    /* we have to look to the last occurrence of a commonName in the\n       distinguished one to get the most significant one. */\n    int j, i = -1;\n\n    /* The following is done because of a bug in 0.9.6b */\n\n    unsigned char *nulstr = (unsigned char *)\"\";\n    unsigned char *peer_CN = nulstr;\n\n    X509_NAME *name = X509_get_subject_name(server_cert);\n    if(name)\n      while((j = X509_NAME_get_index_by_NID(name, NID_commonName, i)) >= 0)\n        i = j;\n\n    /* we have the name entry and we will now convert this to a string\n       that we can use for comparison. Doing this we support BMPstring,\n       UTF8 etc. */\n\n    if(i >= 0) {\n      ASN1_STRING *tmp =\n        X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, i));\n\n      /* In OpenSSL 0.9.7d and earlier, ASN1_STRING_to_UTF8 fails if the input\n         is already UTF-8 encoded. We check for this case and copy the raw\n         string manually to avoid the problem. This code can be made\n         conditional in the future when OpenSSL has been fixed. */\n      if(tmp) {\n        if(ASN1_STRING_type(tmp) == V_ASN1_UTF8STRING) {\n          j = ASN1_STRING_length(tmp);\n          if(j >= 0) {\n            peer_CN = OPENSSL_malloc(j + 1);\n            if(peer_CN) {\n              memcpy(peer_CN, ASN1_STRING_get0_data(tmp), j);\n              peer_CN[j] = '\\0';\n            }\n          }\n        }\n        else /* not a UTF8 name */\n          j = ASN1_STRING_to_UTF8(&peer_CN, tmp);\n\n        if(peer_CN && (curlx_uztosi(strlen((char *)peer_CN)) != j)) {\n          /* there was a terminating zero before the end of string, this\n             cannot match and we return failure! */\n          failf(data, \"SSL: illegal cert name field\");\n          result = CURLE_PEER_FAILED_VERIFICATION;\n        }\n      }\n    }\n\n    if(peer_CN == nulstr)\n       peer_CN = NULL;\n    else {\n      /* convert peer_CN from UTF8 */\n      CURLcode rc = Curl_convert_from_utf8(data, (char *)peer_CN,\n                                           strlen((char *)peer_CN));\n      /* Curl_convert_from_utf8 calls failf if unsuccessful */\n      if(rc) {\n        OPENSSL_free(peer_CN);\n        return rc;\n      }\n    }\n\n    if(result)\n      /* error already detected, pass through */\n      ;\n    else if(!peer_CN) {\n      failf(data,\n            \"SSL: unable to obtain common name from peer certificate\");\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else if(!Curl_cert_hostcheck((const char *)peer_CN, hostname)) {\n      failf(data, \"SSL: certificate subject name '%s' does not match \"\n            \"target host name '%s'\", peer_CN, dispname);\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else {\n      infof(data, \" common name: %s (matched)\\n\", peer_CN);\n    }\n    if(peer_CN)\n      OPENSSL_free(peer_CN);\n  }\n\n  return result;\n}\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\nstatic CURLcode verifystatus(struct Curl_easy *data,\n                             struct ssl_connect_data *connssl)\n{\n  int i, ocsp_status;\n  unsigned char *status;\n  const unsigned char *p;\n  CURLcode result = CURLE_OK;\n  OCSP_RESPONSE *rsp = NULL;\n  OCSP_BASICRESP *br = NULL;\n  X509_STORE     *st = NULL;\n  STACK_OF(X509) *ch = NULL;\n  struct ssl_backend_data *backend = connssl->backend;\n  X509 *cert;\n  OCSP_CERTID *id = NULL;\n  int cert_status, crl_reason;\n  ASN1_GENERALIZEDTIME *rev, *thisupd, *nextupd;\n  int ret;\n\n  long len = SSL_get_tlsext_status_ocsp_resp(backend->handle, &status);\n\n  if(!status) {\n    failf(data, \"No OCSP response received\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n  p = status;\n  rsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n  if(!rsp) {\n    failf(data, \"Invalid OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  ocsp_status = OCSP_response_status(rsp);\n  if(ocsp_status != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n    failf(data, \"Invalid OCSP response status: %s (%d)\",\n          OCSP_response_status_str(ocsp_status), ocsp_status);\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  br = OCSP_response_get1_basic(rsp);\n  if(!br) {\n    failf(data, \"Invalid OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  ch = SSL_get_peer_cert_chain(backend->handle);\n  st = SSL_CTX_get_cert_store(backend->ctx);\n\n#if ((OPENSSL_VERSION_NUMBER <= 0x1000201fL) /* Fixed after 1.0.2a */ || \\\n     (defined(LIBRESSL_VERSION_NUMBER) &&                               \\\n      LIBRESSL_VERSION_NUMBER <= 0x2040200fL))\n  /* The authorized responder cert in the OCSP response MUST be signed by the\n     peer cert's issuer (see RFC6960 section 4.2.2.2). If that's a root cert,\n     no problem, but if it's an intermediate cert OpenSSL has a bug where it\n     expects this issuer to be present in the chain embedded in the OCSP\n     response. So we add it if necessary. */\n\n  /* First make sure the peer cert chain includes both a peer and an issuer,\n     and the OCSP response contains a responder cert. */\n  if(sk_X509_num(ch) >= 2 && sk_X509_num(br->certs) >= 1) {\n    X509 *responder = sk_X509_value(br->certs, sk_X509_num(br->certs) - 1);\n\n    /* Find issuer of responder cert and add it to the OCSP response chain */\n    for(i = 0; i < sk_X509_num(ch); i++) {\n      X509 *issuer = sk_X509_value(ch, i);\n      if(X509_check_issued(issuer, responder) == X509_V_OK) {\n        if(!OCSP_basic_add1_cert(br, issuer)) {\n          failf(data, \"Could not add issuer cert to OCSP response\");\n          result = CURLE_SSL_INVALIDCERTSTATUS;\n          goto end;\n        }\n      }\n    }\n  }\n#endif\n\n  if(OCSP_basic_verify(br, ch, st, 0) <= 0) {\n    failf(data, \"OCSP response verification failed\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Compute the certificate's ID */\n  cert = SSL_get_peer_certificate(backend->handle);\n  if(!cert) {\n    failf(data, \"Error getting peer certificate\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  for(i = 0; i < sk_X509_num(ch); i++) {\n    X509 *issuer = sk_X509_value(ch, i);\n    if(X509_check_issued(issuer, cert) == X509_V_OK) {\n      id = OCSP_cert_to_id(EVP_sha1(), cert, issuer);\n      break;\n    }\n  }\n  X509_free(cert);\n\n  if(!id) {\n    failf(data, \"Error computing OCSP ID\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Find the single OCSP response corresponding to the certificate ID */\n  ret = OCSP_resp_find_status(br, id, &cert_status, &crl_reason, &rev,\n                              &thisupd, &nextupd);\n  OCSP_CERTID_free(id);\n  if(ret != 1) {\n    failf(data, \"Could not find certificate ID in OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Validate the corresponding single OCSP response */\n  if(!OCSP_check_validity(thisupd, nextupd, 300L, -1L)) {\n    failf(data, \"OCSP response has expired\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  infof(data, \"SSL certificate status: %s (%d)\\n\",\n        OCSP_cert_status_str(cert_status), cert_status);\n\n  switch(cert_status) {\n  case V_OCSP_CERTSTATUS_GOOD:\n    break;\n\n  case V_OCSP_CERTSTATUS_REVOKED:\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    failf(data, \"SSL certificate revocation reason: %s (%d)\",\n          OCSP_crl_reason_str(crl_reason), crl_reason);\n    goto end;\n\n  case V_OCSP_CERTSTATUS_UNKNOWN:\n  default:\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\nend:\n  if(br)\n    OCSP_BASICRESP_free(br);\n  OCSP_RESPONSE_free(rsp);\n\n  return result;\n}\n#endif\n\n#endif /* USE_OPENSSL */\n\n/* The SSL_CTRL_SET_MSG_CALLBACK doesn't exist in ancient OpenSSL versions\n   and thus this cannot be done there. */\n#ifdef SSL_CTRL_SET_MSG_CALLBACK\n\nstatic const char *ssl_msg_type(int ssl_ver, int msg)\n{\n#ifdef SSL2_VERSION_MAJOR\n  if(ssl_ver == SSL2_VERSION_MAJOR) {\n    switch(msg) {\n      case SSL2_MT_ERROR:\n        return \"Error\";\n      case SSL2_MT_CLIENT_HELLO:\n        return \"Client hello\";\n      case SSL2_MT_CLIENT_MASTER_KEY:\n        return \"Client key\";\n      case SSL2_MT_CLIENT_FINISHED:\n        return \"Client finished\";\n      case SSL2_MT_SERVER_HELLO:\n        return \"Server hello\";\n      case SSL2_MT_SERVER_VERIFY:\n        return \"Server verify\";\n      case SSL2_MT_SERVER_FINISHED:\n        return \"Server finished\";\n      case SSL2_MT_REQUEST_CERTIFICATE:\n        return \"Request CERT\";\n      case SSL2_MT_CLIENT_CERTIFICATE:\n        return \"Client CERT\";\n    }\n  }\n  else\n#endif\n  if(ssl_ver == SSL3_VERSION_MAJOR) {\n    switch(msg) {\n      case SSL3_MT_HELLO_REQUEST:\n        return \"Hello request\";\n      case SSL3_MT_CLIENT_HELLO:\n        return \"Client hello\";\n      case SSL3_MT_SERVER_HELLO:\n        return \"Server hello\";\n#ifdef SSL3_MT_NEWSESSION_TICKET\n      case SSL3_MT_NEWSESSION_TICKET:\n        return \"Newsession Ticket\";\n#endif\n      case SSL3_MT_CERTIFICATE:\n        return \"Certificate\";\n      case SSL3_MT_SERVER_KEY_EXCHANGE:\n        return \"Server key exchange\";\n      case SSL3_MT_CLIENT_KEY_EXCHANGE:\n        return \"Client key exchange\";\n      case SSL3_MT_CERTIFICATE_REQUEST:\n        return \"Request CERT\";\n      case SSL3_MT_SERVER_DONE:\n        return \"Server finished\";\n      case SSL3_MT_CERTIFICATE_VERIFY:\n        return \"CERT verify\";\n      case SSL3_MT_FINISHED:\n        return \"Finished\";\n#ifdef SSL3_MT_CERTIFICATE_STATUS\n      case SSL3_MT_CERTIFICATE_STATUS:\n        return \"Certificate Status\";\n#endif\n#ifdef SSL3_MT_ENCRYPTED_EXTENSIONS\n      case SSL3_MT_ENCRYPTED_EXTENSIONS:\n        return \"Encrypted Extensions\";\n#endif\n#ifdef SSL3_MT_END_OF_EARLY_DATA\n      case SSL3_MT_END_OF_EARLY_DATA:\n        return \"End of early data\";\n#endif\n#ifdef SSL3_MT_KEY_UPDATE\n      case SSL3_MT_KEY_UPDATE:\n        return \"Key update\";\n#endif\n#ifdef SSL3_MT_NEXT_PROTO\n      case SSL3_MT_NEXT_PROTO:\n        return \"Next protocol\";\n#endif\n#ifdef SSL3_MT_MESSAGE_HASH\n      case SSL3_MT_MESSAGE_HASH:\n        return \"Message hash\";\n#endif\n    }\n  }\n  return \"Unknown\";\n}\n\nstatic const char *tls_rt_type(int type)\n{\n  switch(type) {\n#ifdef SSL3_RT_HEADER\n  case SSL3_RT_HEADER:\n    return \"TLS header\";\n#endif\n  case SSL3_RT_CHANGE_CIPHER_SPEC:\n    return \"TLS change cipher\";\n  case SSL3_RT_ALERT:\n    return \"TLS alert\";\n  case SSL3_RT_HANDSHAKE:\n    return \"TLS handshake\";\n  case SSL3_RT_APPLICATION_DATA:\n    return \"TLS app data\";\n  default:\n    return \"TLS Unknown\";\n  }\n}\n\n/*\n * Our callback from the SSL/TLS layers.\n */\nstatic void ossl_trace(int direction, int ssl_ver, int content_type,\n                       const void *buf, size_t len, SSL *ssl,\n                       void *userp)\n{\n  char unknown[32];\n  const char *verstr = NULL;\n  struct connectdata *conn = userp;\n  struct ssl_connect_data *connssl = &conn->ssl[0];\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->logger;\n\n  if(!conn || !data || !data->set.fdebug ||\n     (direction != 0 && direction != 1))\n    return;\n\n  switch(ssl_ver) {\n#ifdef SSL2_VERSION /* removed in recent versions */\n  case SSL2_VERSION:\n    verstr = \"SSLv2\";\n    break;\n#endif\n#ifdef SSL3_VERSION\n  case SSL3_VERSION:\n    verstr = \"SSLv3\";\n    break;\n#endif\n  case TLS1_VERSION:\n    verstr = \"TLSv1.0\";\n    break;\n#ifdef TLS1_1_VERSION\n  case TLS1_1_VERSION:\n    verstr = \"TLSv1.1\";\n    break;\n#endif\n#ifdef TLS1_2_VERSION\n  case TLS1_2_VERSION:\n    verstr = \"TLSv1.2\";\n    break;\n#endif\n#ifdef TLS1_3_VERSION\n  case TLS1_3_VERSION:\n    verstr = \"TLSv1.3\";\n    break;\n#endif\n  case 0:\n    break;\n  default:\n    msnprintf(unknown, sizeof(unknown), \"(%x)\", ssl_ver);\n    verstr = unknown;\n    break;\n  }\n\n  /* Log progress for interesting records only (like Handshake or Alert), skip\n   * all raw record headers (content_type == SSL3_RT_HEADER or ssl_ver == 0).\n   * For TLS 1.3, skip notification of the decrypted inner Content Type.\n   */\n  if(ssl_ver\n#ifdef SSL3_RT_INNER_CONTENT_TYPE\n     && content_type != SSL3_RT_INNER_CONTENT_TYPE\n#endif\n    ) {\n    const char *msg_name, *tls_rt_name;\n    char ssl_buf[1024];\n    int msg_type, txt_len;\n\n    /* the info given when the version is zero is not that useful for us */\n\n    ssl_ver >>= 8; /* check the upper 8 bits only below */\n\n    /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL\n     * always pass-up content-type as 0. But the interesting message-type\n     * is at 'buf[0]'.\n     */\n    if(ssl_ver == SSL3_VERSION_MAJOR && content_type)\n      tls_rt_name = tls_rt_type(content_type);\n    else\n      tls_rt_name = \"\";\n\n    if(content_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n      msg_type = *(char *)buf;\n      msg_name = \"Change cipher spec\";\n    }\n    else if(content_type == SSL3_RT_ALERT) {\n      msg_type = (((char *)buf)[0] << 8) + ((char *)buf)[1];\n      msg_name = SSL_alert_desc_string_long(msg_type);\n    }\n    else {\n      msg_type = *(char *)buf;\n      msg_name = ssl_msg_type(ssl_ver, msg_type);\n    }\n\n    txt_len = msnprintf(ssl_buf, sizeof(ssl_buf), \"%s (%s), %s, %s (%d):\\n\",\n                        verstr, direction?\"OUT\":\"IN\",\n                        tls_rt_name, msg_name, msg_type);\n    if(0 <= txt_len && (unsigned)txt_len < sizeof(ssl_buf)) {\n      Curl_debug(data, CURLINFO_TEXT, ssl_buf, (size_t)txt_len);\n    }\n  }\n\n  Curl_debug(data, (direction == 1) ? CURLINFO_SSL_DATA_OUT :\n             CURLINFO_SSL_DATA_IN, (char *)buf, len);\n  (void) ssl;\n}\n#endif\n\n#ifdef USE_OPENSSL\n/* ====================================================== */\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n#  define use_sni(x)  sni = (x)\n#else\n#  define use_sni(x)  Curl_nop_stmt\n#endif\n\n/* Check for OpenSSL 1.0.2 which has ALPN support. */\n#undef HAS_ALPN\n#if OPENSSL_VERSION_NUMBER >= 0x10002000L \\\n    && !defined(OPENSSL_NO_TLSEXT)\n#  define HAS_ALPN 1\n#endif\n\n/* Check for OpenSSL 1.0.1 which has NPN support. */\n#undef HAS_NPN\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L \\\n    && !defined(OPENSSL_NO_TLSEXT) \\\n    && !defined(OPENSSL_NO_NEXTPROTONEG)\n#  define HAS_NPN 1\n#endif\n\n#ifdef HAS_NPN\n\n/*\n * in is a list of length prefixed strings. this function has to select\n * the protocol we want to use from the list and write its string into out.\n */\n\nstatic int\nselect_next_protocol(unsigned char **out, unsigned char *outlen,\n                     const unsigned char *in, unsigned int inlen,\n                     const char *key, unsigned int keylen)\n{\n  unsigned int i;\n  for(i = 0; i + keylen <= inlen; i += in[i] + 1) {\n    if(memcmp(&in[i + 1], key, keylen) == 0) {\n      *out = (unsigned char *) &in[i + 1];\n      *outlen = in[i];\n      return 0;\n    }\n  }\n  return -1;\n}\n\nstatic int\nselect_next_proto_cb(SSL *ssl,\n                     unsigned char **out, unsigned char *outlen,\n                     const unsigned char *in, unsigned int inlen,\n                     void *arg)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  (void)ssl;\n\n#ifdef USE_HTTP2\n  if(data->state.httpwant >= CURL_HTTP_VERSION_2 &&\n     !select_next_protocol(out, outlen, in, inlen, ALPN_H2, ALPN_H2_LENGTH)) {\n    infof(data, \"NPN, negotiated HTTP2 (%s)\\n\", ALPN_H2);\n    conn->negnpn = CURL_HTTP_VERSION_2;\n    return SSL_TLSEXT_ERR_OK;\n  }\n#endif\n\n  if(!select_next_protocol(out, outlen, in, inlen, ALPN_HTTP_1_1,\n                           ALPN_HTTP_1_1_LENGTH)) {\n    infof(data, \"NPN, negotiated HTTP1.1\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_1_1;\n    return SSL_TLSEXT_ERR_OK;\n  }\n\n  infof(data, \"NPN, no overlap, use HTTP1.1\\n\");\n  *out = (unsigned char *)ALPN_HTTP_1_1;\n  *outlen = ALPN_HTTP_1_1_LENGTH;\n  conn->negnpn = CURL_HTTP_VERSION_1_1;\n\n  return SSL_TLSEXT_ERR_OK;\n}\n#endif /* HAS_NPN */\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */\nstatic CURLcode\nset_ssl_version_min_max(SSL_CTX *ctx, struct connectdata *conn)\n{\n  /* first, TLS min version... */\n  long curl_ssl_version_min = SSL_CONN_CONFIG(version);\n  long curl_ssl_version_max;\n\n  /* convert cURL min SSL version option to OpenSSL constant */\n#if defined(OPENSSL_IS_BORINGSSL) || defined(LIBRESSL_VERSION_NUMBER)\n  uint16_t ossl_ssl_version_min = 0;\n  uint16_t ossl_ssl_version_max = 0;\n#else\n  long ossl_ssl_version_min = 0;\n  long ossl_ssl_version_max = 0;\n#endif\n  switch(curl_ssl_version_min) {\n    case CURL_SSLVERSION_TLSv1: /* TLS 1.x */\n    case CURL_SSLVERSION_TLSv1_0:\n      ossl_ssl_version_min = TLS1_VERSION;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      ossl_ssl_version_min = TLS1_1_VERSION;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      ossl_ssl_version_min = TLS1_2_VERSION;\n      break;\n#ifdef TLS1_3_VERSION\n    case CURL_SSLVERSION_TLSv1_3:\n      ossl_ssl_version_min = TLS1_3_VERSION;\n      break;\n#endif\n  }\n\n  /* CURL_SSLVERSION_DEFAULT means that no option was selected.\n     We don't want to pass 0 to SSL_CTX_set_min_proto_version as\n     it would enable all versions down to the lowest supported by\n     the library.\n     So we skip this, and stay with the OS default\n  */\n  if(curl_ssl_version_min != CURL_SSLVERSION_DEFAULT) {\n    if(!SSL_CTX_set_min_proto_version(ctx, ossl_ssl_version_min)) {\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* ... then, TLS max version */\n  curl_ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  /* convert cURL max SSL version option to OpenSSL constant */\n  switch(curl_ssl_version_max) {\n    case CURL_SSLVERSION_MAX_TLSv1_0:\n      ossl_ssl_version_max = TLS1_VERSION;\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_1:\n      ossl_ssl_version_max = TLS1_1_VERSION;\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_2:\n      ossl_ssl_version_max = TLS1_2_VERSION;\n      break;\n#ifdef TLS1_3_VERSION\n    case CURL_SSLVERSION_MAX_TLSv1_3:\n      ossl_ssl_version_max = TLS1_3_VERSION;\n      break;\n#endif\n    case CURL_SSLVERSION_MAX_NONE:  /* none selected */\n    case CURL_SSLVERSION_MAX_DEFAULT:  /* max selected */\n    default:\n      /* SSL_CTX_set_max_proto_version states that:\n        setting the maximum to 0 will enable\n        protocol versions up to the highest version\n        supported by the library */\n      ossl_ssl_version_max = 0;\n      break;\n  }\n\n  if(!SSL_CTX_set_max_proto_version(ctx, ossl_ssl_version_max)) {\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  return CURLE_OK;\n}\n#endif\n\n#ifdef OPENSSL_IS_BORINGSSL\ntypedef uint32_t ctx_option_t;\n#else\ntypedef long ctx_option_t;\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) /* 1.1.0 */\nstatic CURLcode\nset_ssl_version_min_max_legacy(ctx_option_t *ctx_options,\n                               struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  (void) data; /* In case it's unused. */\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_TLSv1_3:\n#ifdef TLS1_3_VERSION\n    {\n      struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n      SSL_CTX_set_max_proto_version(backend->ctx, TLS1_3_VERSION);\n      *ctx_options |= SSL_OP_NO_TLSv1_2;\n    }\n#else\n      (void)sockindex;\n      (void)ctx_options;\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.3 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_2:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_1;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.2 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_1:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.1 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1:\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_TLSv1_0:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_1;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_MAX_TLSv1_1:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_2;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_MAX_TLSv1_2:\n#ifdef TLS1_3_VERSION\n      *ctx_options |= SSL_OP_NO_TLSv1_3;\n#endif\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_3:\n#ifdef TLS1_3_VERSION\n      break;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.3 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n  }\n  return CURLE_OK;\n}\n#endif\n\n/* The \"new session\" callback must return zero if the session can be removed\n * or non-zero if the session has been put into the session cache.\n */\nstatic int ossl_new_session_cb(SSL *ssl, SSL_SESSION *ssl_sessionid)\n{\n  int res = 0;\n  struct connectdata *conn;\n  struct Curl_easy *data;\n  int sockindex;\n  curl_socket_t *sockindex_ptr;\n  int data_idx = ossl_get_ssl_data_index();\n  int connectdata_idx = ossl_get_ssl_conn_index();\n  int sockindex_idx = ossl_get_ssl_sockindex_index();\n  int proxy_idx = ossl_get_proxy_index();\n  bool isproxy;\n\n  if(data_idx < 0 || connectdata_idx < 0 || sockindex_idx < 0 || proxy_idx < 0)\n    return 0;\n\n  conn = (struct connectdata*) SSL_get_ex_data(ssl, connectdata_idx);\n  if(!conn)\n    return 0;\n\n  data = (struct Curl_easy *) SSL_get_ex_data(ssl, data_idx);\n\n  /* The sockindex has been stored as a pointer to an array element */\n  sockindex_ptr = (curl_socket_t*) SSL_get_ex_data(ssl, sockindex_idx);\n  sockindex = (int)(sockindex_ptr - conn->sock);\n\n  isproxy = SSL_get_ex_data(ssl, proxy_idx) ? TRUE : FALSE;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(isproxy)\n      incache = FALSE;\n    else\n      incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                        &old_ssl_sessionid, NULL, sockindex));\n    if(incache) {\n      if(old_ssl_sessionid != ssl_sessionid) {\n        infof(data, \"old SSL session ID is stale, removing\\n\");\n        Curl_ssl_delsessionid(data, old_ssl_sessionid);\n        incache = FALSE;\n      }\n    }\n\n    if(!incache) {\n      if(!Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n                                0 /* unknown size */, sockindex)) {\n        /* the session has been put into the session cache */\n        res = 1;\n      }\n      else\n        failf(data, \"failed to store ssl session\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  return res;\n}\n\nstatic CURLcode load_cacert_from_memory(SSL_CTX *ctx,\n                                        const struct curl_blob *ca_info_blob)\n{\n  /* these need freed at the end */\n  BIO *cbio = NULL;\n  STACK_OF(X509_INFO) *inf = NULL;\n\n  /* everything else is just a reference */\n  int i, count = 0;\n  X509_STORE *cts = NULL;\n  X509_INFO *itmp = NULL;\n\n  if(ca_info_blob->len > (size_t)INT_MAX)\n    return CURLE_SSL_CACERT_BADFILE;\n\n  cts = SSL_CTX_get_cert_store(ctx);\n  if(!cts)\n    return CURLE_OUT_OF_MEMORY;\n\n  cbio = BIO_new_mem_buf(ca_info_blob->data, (int)ca_info_blob->len);\n  if(!cbio)\n    return CURLE_OUT_OF_MEMORY;\n\n  inf = PEM_X509_INFO_read_bio(cbio, NULL, NULL, NULL);\n  if(!inf) {\n    BIO_free(cbio);\n    return CURLE_SSL_CACERT_BADFILE;\n  }\n\n  /* add each entry from PEM file to x509_store */\n  for(i = 0; i < (int)sk_X509_INFO_num(inf); ++i) {\n    itmp = sk_X509_INFO_value(inf, i);\n    if(itmp->x509) {\n      if(X509_STORE_add_cert(cts, itmp->x509)) {\n        ++count;\n      }\n      else {\n        /* set count to 0 to return an error */\n        count = 0;\n        break;\n      }\n    }\n    if(itmp->crl) {\n      if(X509_STORE_add_crl(cts, itmp->crl)) {\n        ++count;\n      }\n      else {\n        /* set count to 0 to return an error */\n        count = 0;\n        break;\n      }\n    }\n  }\n\n  sk_X509_INFO_pop_free(inf, X509_INFO_free);\n  BIO_free(cbio);\n\n  /* if we didn't end up importing anything, treat that as an error */\n  return (count > 0 ? CURLE_OK : CURLE_SSL_CACERT_BADFILE);\n}\n\nstatic CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n#endif\n  const long int ssl_version = SSL_CONN_CONFIG(version);\n#ifdef USE_OPENSSL_SRP\n  const enum CURL_TLSAUTH ssl_authtype = SSL_SET_OPTION(authtype);\n#endif\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n  const struct curl_blob *ca_info_blob = SSL_CONN_CONFIG(ca_info_blob);\n  const char * const ssl_cert_type = SSL_SET_OPTION(cert_type);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ca_info_blob ? NULL : SSL_CONN_CONFIG(CAfile));\n  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n  char error_buffer[256];\n  struct ssl_backend_data *backend = connssl->backend;\n  bool imported_native_ca = false;\n\n  DEBUGASSERT(ssl_connect_1 == connssl->connecting_state);\n\n  /* Make funny stuff to get random input */\n  result = ossl_seed(data);\n  if(result)\n    return result;\n\n  SSL_SET_OPTION_LVALUE(certverifyresult) = !X509_V_OK;\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n\n  switch(ssl_version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    /* it will be handled later with the context options */\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n    req_method = TLS_client_method();\n#else\n    req_method = SSLv23_client_method();\n#endif\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_SSLv2:\n    failf(data, \"No SSLv2 support\");\n    return CURLE_NOT_BUILT_IN;\n  case CURL_SSLVERSION_SSLv3:\n    failf(data, \"No SSLv3 support\");\n    return CURLE_NOT_BUILT_IN;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(backend->ctx)\n    SSL_CTX_free(backend->ctx);\n  backend->ctx = SSL_CTX_new(req_method);\n\n  if(!backend->ctx) {\n    failf(data, \"SSL: couldn't create a context: %s\",\n          ossl_strerror(ERR_peek_error(), error_buffer, sizeof(error_buffer)));\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(backend->ctx, SSL_MODE_RELEASE_BUFFERS);\n#endif\n\n#ifdef SSL_CTRL_SET_MSG_CALLBACK\n  if(data->set.fdebug && data->set.verbose) {\n    /* the SSL trace callback is only used for verbose logging */\n    SSL_CTX_set_msg_callback(backend->ctx, ossl_trace);\n    SSL_CTX_set_msg_callback_arg(backend->ctx, conn);\n    set_logger(conn, data);\n  }\n#endif\n\n  /* OpenSSL contains code to work-around lots of bugs and flaws in various\n     SSL-implementations. SSL_CTX_set_options() is used to enabled those\n     work-arounds. The man page for this option states that SSL_OP_ALL enables\n     all the work-arounds and that \"It is usually safe to use SSL_OP_ALL to\n     enable the bug workaround options if compatibility with somewhat broken\n     implementations is desired.\"\n\n     The \"-no_ticket\" option was introduced in Openssl0.9.8j. It's a flag to\n     disable \"rfc4507bis session ticket support\".  rfc4507bis was later turned\n     into the proper RFC5077 it seems: https://tools.ietf.org/html/rfc5077\n\n     The enabled extension concerns the session management. I wonder how often\n     libcurl stops a connection and then resumes a TLS session. also, sending\n     the session data is some overhead. .I suggest that you just use your\n     proposed patch (which explicitly disables TICKET).\n\n     If someone writes an application with libcurl and openssl who wants to\n     enable the feature, one can do this in the SSL callback.\n\n     SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG option enabling allowed proper\n     interoperability with web server Netscape Enterprise Server 2.0.1 which\n     was released back in 1996.\n\n     Due to CVE-2010-4180, option SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG has\n     become ineffective as of OpenSSL 0.9.8q and 1.0.0c. In order to mitigate\n     CVE-2010-4180 when using previous OpenSSL versions we no longer enable\n     this option regardless of OpenSSL version and SSL_OP_ALL definition.\n\n     OpenSSL added a work-around for a SSL 3.0/TLS 1.0 CBC vulnerability\n     (https://www.openssl.org/~bodo/tls-cbc.txt). In 0.9.6e they added a bit to\n     SSL_OP_ALL that _disables_ that work-around despite the fact that\n     SSL_OP_ALL is documented to do \"rather harmless\" workarounds. In order to\n     keep the secure work-around, the SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS bit\n     must not be set.\n  */\n\n  ctx_options = SSL_OP_ALL;\n\n#ifdef SSL_OP_NO_TICKET\n  ctx_options |= SSL_OP_NO_TICKET;\n#endif\n\n#ifdef SSL_OP_NO_COMPRESSION\n  ctx_options |= SSL_OP_NO_COMPRESSION;\n#endif\n\n#ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\n  /* mitigate CVE-2010-4180 */\n  ctx_options &= ~SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;\n#endif\n\n#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n  /* unless the user explicitly ask to allow the protocol vulnerability we\n     use the work-around */\n  if(!SSL_SET_OPTION(enable_beast))\n    ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_SSLv2:\n    case CURL_SSLVERSION_SSLv3:\n      return CURLE_NOT_BUILT_IN;\n\n    /* \"--tlsv<x.y>\" options mean TLS >= version <x.y> */\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1: /* TLS >= version 1.0 */\n    case CURL_SSLVERSION_TLSv1_0: /* TLS >= version 1.0 */\n    case CURL_SSLVERSION_TLSv1_1: /* TLS >= version 1.1 */\n    case CURL_SSLVERSION_TLSv1_2: /* TLS >= version 1.2 */\n    case CURL_SSLVERSION_TLSv1_3: /* TLS >= version 1.3 */\n      /* asking for any TLS version as the minimum, means no SSL versions\n        allowed */\n      ctx_options |= SSL_OP_NO_SSLv2;\n      ctx_options |= SSL_OP_NO_SSLv3;\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */\n      result = set_ssl_version_min_max(backend->ctx, conn);\n#else\n      result = set_ssl_version_min_max_legacy(&ctx_options, data, conn,\n                                              sockindex);\n#endif\n      if(result != CURLE_OK)\n        return result;\n      break;\n\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  SSL_CTX_set_options(backend->ctx, ctx_options);\n\n#ifdef HAS_NPN\n  if(conn->bits.tls_enable_npn)\n    SSL_CTX_set_next_proto_select_cb(backend->ctx, select_next_proto_cb, data);\n#endif\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    unsigned char protocols[128];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n      ) {\n      protocols[cur++] = ALPN_H2_LENGTH;\n\n      memcpy(&protocols[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    /* expects length prefixed preference ordered list of protocols in wire\n     * format\n     */\n    if(SSL_CTX_set_alpn_protos(backend->ctx, protocols, cur)) {\n      failf(data, \"Error setting ALPN\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif\n\n  if(ssl_cert || ssl_cert_blob || ssl_cert_type) {\n    if(!result &&\n       !cert_stuff(data, backend->ctx,\n                   ssl_cert, ssl_cert_blob, ssl_cert_type,\n                   SSL_SET_OPTION(key), SSL_SET_OPTION(key_blob),\n                   SSL_SET_OPTION(key_type), SSL_SET_OPTION(key_passwd)))\n      result = CURLE_SSL_CERTPROBLEM;\n    if(result)\n      /* failf() is already done in cert_stuff() */\n      return result;\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(!ciphers)\n    ciphers = (char *)DEFAULT_CIPHER_SELECTION;\n  if(ciphers) {\n    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES\n  {\n    char *ciphers13 = SSL_CONN_CONFIG(cipher_list13);\n    if(ciphers13) {\n      if(!SSL_CTX_set_ciphersuites(backend->ctx, ciphers13)) {\n        failf(data, \"failed setting TLS 1.3 cipher suite: %s\", ciphers13);\n        return CURLE_SSL_CIPHER;\n      }\n      infof(data, \"TLS 1.3 cipher selection: %s\\n\", ciphers13);\n    }\n  }\n#endif\n\n#ifdef HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH\n  /* OpenSSL 1.1.1 requires clients to opt-in for PHA */\n  SSL_CTX_set_post_handshake_auth(backend->ctx, 1);\n#endif\n\n#ifdef HAVE_SSL_CTX_SET_EC_CURVES\n  {\n    char *curves = SSL_CONN_CONFIG(curves);\n    if(curves) {\n      if(!SSL_CTX_set1_curves_list(backend->ctx, curves)) {\n        failf(data, \"failed setting curves list: '%s'\", curves);\n        return CURLE_SSL_CIPHER;\n      }\n    }\n  }\n#endif\n\n#ifdef USE_OPENSSL_SRP\n  if(ssl_authtype == CURL_TLSAUTH_SRP) {\n    char * const ssl_username = SSL_SET_OPTION(username);\n\n    infof(data, \"Using TLS-SRP username: %s\\n\", ssl_username);\n\n    if(!SSL_CTX_set_srp_username(backend->ctx, ssl_username)) {\n      failf(data, \"Unable to set SRP user name\");\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n    if(!SSL_CTX_set_srp_password(backend->ctx, SSL_SET_OPTION(password))) {\n      failf(data, \"failed setting SRP password\");\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n    if(!SSL_CONN_CONFIG(cipher_list)) {\n      infof(data, \"Setting cipher list SRP\\n\");\n\n      if(!SSL_CTX_set_cipher_list(backend->ctx, \"SRP\")) {\n        failf(data, \"failed setting SRP cipher list\");\n        return CURLE_SSL_CIPHER;\n      }\n    }\n  }\n#endif\n\n\n#if defined(USE_WIN32_CRYPTO)\n  /* Import certificates from the Windows root certificate store if requested.\n     https://stackoverflow.com/questions/9507184/\n     https://github.com/d3x0r/SACK/blob/master/src/netlib/ssl_layer.c#L1037\n     https://tools.ietf.org/html/rfc5280 */\n  if((SSL_CONN_CONFIG(verifypeer) || SSL_CONN_CONFIG(verifyhost)) &&\n     (SSL_SET_OPTION(native_ca_store))) {\n    X509_STORE *store = SSL_CTX_get_cert_store(backend->ctx);\n    HCERTSTORE hStore = CertOpenSystemStore(0, TEXT(\"ROOT\"));\n\n    if(hStore) {\n      PCCERT_CONTEXT pContext = NULL;\n      /* The array of enhanced key usage OIDs will vary per certificate and is\n         declared outside of the loop so that rather than malloc/free each\n         iteration we can grow it with realloc, when necessary. */\n      CERT_ENHKEY_USAGE *enhkey_usage = NULL;\n      DWORD enhkey_usage_size = 0;\n\n      /* This loop makes a best effort to import all valid certificates from\n         the MS root store. If a certificate cannot be imported it is skipped.\n         'result' is used to store only hard-fail conditions (such as out of\n         memory) that cause an early break. */\n      result = CURLE_OK;\n      for(;;) {\n        X509 *x509;\n        FILETIME now;\n        BYTE key_usage[2];\n        DWORD req_size;\n        const unsigned char *encoded_cert;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n        char cert_name[256];\n#endif\n\n        pContext = CertEnumCertificatesInStore(hStore, pContext);\n        if(!pContext)\n          break;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n        if(!CertGetNameStringA(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0,\n                               NULL, cert_name, sizeof(cert_name))) {\n          strcpy(cert_name, \"Unknown\");\n        }\n        infof(data, \"SSL: Checking cert \\\"%s\\\"\\n\", cert_name);\n#endif\n\n        encoded_cert = (const unsigned char *)pContext->pbCertEncoded;\n        if(!encoded_cert)\n          continue;\n\n        GetSystemTimeAsFileTime(&now);\n        if(CompareFileTime(&pContext->pCertInfo->NotBefore, &now) > 0 ||\n           CompareFileTime(&now, &pContext->pCertInfo->NotAfter) > 0)\n          continue;\n\n        /* If key usage exists check for signing attribute */\n        if(CertGetIntendedKeyUsage(pContext->dwCertEncodingType,\n                                   pContext->pCertInfo,\n                                   key_usage, sizeof(key_usage))) {\n          if(!(key_usage[0] & CERT_KEY_CERT_SIGN_KEY_USAGE))\n            continue;\n        }\n        else if(GetLastError())\n          continue;\n\n        /* If enhanced key usage exists check for server auth attribute.\n         *\n         * Note \"In a Microsoft environment, a certificate might also have EKU\n         * extended properties that specify valid uses for the certificate.\"\n         * The call below checks both, and behavior varies depending on what is\n         * found. For more details see CertGetEnhancedKeyUsage doc.\n         */\n        if(CertGetEnhancedKeyUsage(pContext, 0, NULL, &req_size)) {\n          if(req_size && req_size > enhkey_usage_size) {\n            void *tmp = realloc(enhkey_usage, req_size);\n\n            if(!tmp) {\n              failf(data, \"SSL: Out of memory allocating for OID list\");\n              result = CURLE_OUT_OF_MEMORY;\n              break;\n            }\n\n            enhkey_usage = (CERT_ENHKEY_USAGE *)tmp;\n            enhkey_usage_size = req_size;\n          }\n\n          if(CertGetEnhancedKeyUsage(pContext, 0, enhkey_usage, &req_size)) {\n            if(!enhkey_usage->cUsageIdentifier) {\n              /* \"If GetLastError returns CRYPT_E_NOT_FOUND, the certificate is\n                 good for all uses. If it returns zero, the certificate has no\n                 valid uses.\" */\n              if((HRESULT)GetLastError() != CRYPT_E_NOT_FOUND)\n                continue;\n            }\n            else {\n              DWORD i;\n              bool found = false;\n\n              for(i = 0; i < enhkey_usage->cUsageIdentifier; ++i) {\n                if(!strcmp(\"1.3.6.1.5.5.7.3.1\" /* OID server auth */,\n                           enhkey_usage->rgpszUsageIdentifier[i])) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if(!found)\n                continue;\n            }\n          }\n          else\n            continue;\n        }\n        else\n          continue;\n\n        x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);\n        if(!x509)\n          continue;\n\n        /* Try to import the certificate. This may fail for legitimate reasons\n           such as duplicate certificate, which is allowed by MS but not\n           OpenSSL. */\n        if(X509_STORE_add_cert(store, x509) == 1) {\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n          infof(data, \"SSL: Imported cert \\\"%s\\\"\\n\", cert_name);\n#endif\n          imported_native_ca = true;\n        }\n        X509_free(x509);\n      }\n\n      free(enhkey_usage);\n      CertFreeCertificateContext(pContext);\n      CertCloseStore(hStore, 0);\n\n      if(result)\n        return result;\n    }\n    if(imported_native_ca)\n      infof(data, \"successfully imported windows ca store\\n\");\n    else\n      infof(data, \"error importing windows ca store, continuing anyway\\n\");\n  }\n#endif\n\n  if(ca_info_blob) {\n    result = load_cacert_from_memory(backend->ctx, ca_info_blob);\n    if(result) {\n      if(result == CURLE_OUT_OF_MEMORY ||\n         (verifypeer && !imported_native_ca)) {\n        failf(data, \"error importing CA certificate blob\");\n        return result;\n      }\n      /* Only warning if no certificate verification is required. */\n      infof(data, \"error importing CA certificate blob, continuing anyway\\n\");\n    }\n  }\n\n#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)\n  /* OpenSSL 3.0.0 has deprecated SSL_CTX_load_verify_locations */\n  {\n    if(ssl_cafile) {\n      if(!SSL_CTX_load_verify_file(backend->ctx, ssl_cafile)) {\n        if(verifypeer && !imported_native_ca) {\n          /* Fail if we insist on successfully verifying the server. */\n          failf(data, \"error setting certificate file: %s\", ssl_cafile);\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n        /* Continue with a warning if no certificate verif is required. */\n        infof(data, \"error setting certificate file, continuing anyway\\n\");\n      }\n      infof(data, \" CAfile: %s\\n\", ssl_cafile);\n    }\n    if(ssl_capath) {\n      if(!SSL_CTX_load_verify_dir(backend->ctx, ssl_capath)) {\n        if(verifypeer && !imported_native_ca) {\n          /* Fail if we insist on successfully verifying the server. */\n          failf(data, \"error setting certificate path: %s\", ssl_capath);\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n        /* Continue with a warning if no certificate verif is required. */\n        infof(data, \"error setting certificate path, continuing anyway\\n\");\n      }\n      infof(data, \" CApath: %s\\n\", ssl_capath);\n    }\n  }\n#else\n  if(ssl_cafile || ssl_capath) {\n    /* tell SSL where to find CA certificates that are used to verify\n       the servers certificate. */\n    if(!SSL_CTX_load_verify_locations(backend->ctx, ssl_cafile, ssl_capath)) {\n      if(verifypeer && !imported_native_ca) {\n        /* Fail if we insist on successfully verifying the server. */\n        failf(data, \"error setting certificate verify locations:\"\n              \"  CAfile: %s CApath: %s\",\n              ssl_cafile ? ssl_cafile : \"none\",\n              ssl_capath ? ssl_capath : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      /* Just continue with a warning if no strict certificate verification\n         is required. */\n      infof(data, \"error setting certificate verify locations,\"\n            \" continuing anyway:\\n\");\n    }\n    else {\n      /* Everything is fine. */\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\", ssl_cafile ? ssl_cafile : \"none\");\n    infof(data, \" CApath: %s\\n\", ssl_capath ? ssl_capath : \"none\");\n  }\n#endif\n\n#ifdef CURL_CA_FALLBACK\n  if(verifypeer &&\n     !ca_info_blob && !ssl_cafile && !ssl_capath && !imported_native_ca) {\n    /* verifying the peer without any CA certificates won't\n       work so use openssl's built in default as fallback */\n    SSL_CTX_set_default_verify_paths(backend->ctx);\n  }\n#endif\n\n  if(ssl_crlfile) {\n    /* tell SSL where to find CRL file that is used to check certificate\n     * revocation */\n    lookup = X509_STORE_add_lookup(SSL_CTX_get_cert_store(backend->ctx),\n                                 X509_LOOKUP_file());\n    if(!lookup ||\n       (!X509_load_crl_file(lookup, ssl_crlfile, X509_FILETYPE_PEM)) ) {\n      failf(data, \"error loading CRL file: %s\", ssl_crlfile);\n      return CURLE_SSL_CRL_BADFILE;\n    }\n    /* Everything is fine. */\n    infof(data, \"successfully load CRL file:\\n\");\n    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                         X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);\n\n    infof(data, \"  CRLfile: %s\\n\", ssl_crlfile);\n  }\n\n  if(verifypeer) {\n    /* Try building a chain using issuers in the trusted store first to avoid\n       problems with server-sent legacy intermediates.  Newer versions of\n       OpenSSL do alternate chain checking by default but we do not know how to\n       determine that in a reliable manner.\n       https://rt.openssl.org/Ticket/Display.html?id=3621&user=guest&pass=guest\n    */\n#if defined(X509_V_FLAG_TRUSTED_FIRST)\n    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                         X509_V_FLAG_TRUSTED_FIRST);\n#endif\n#ifdef X509_V_FLAG_PARTIAL_CHAIN\n    if(!SSL_SET_OPTION(no_partialchain) && !ssl_crlfile) {\n      /* Have intermediate certificates in the trust store be treated as\n         trust-anchors, in the same way as self-signed root CA certificates\n         are. This allows users to verify servers using the intermediate cert\n         only, instead of needing the whole chain.\n\n         Due to OpenSSL bug https://github.com/openssl/openssl/issues/5081 we\n         cannot do partial chains with CRL check.\n      */\n      X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                           X509_V_FLAG_PARTIAL_CHAIN);\n    }\n#endif\n  }\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n  SSL_CTX_set_verify(backend->ctx,\n                     verifypeer ? SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);\n\n  /* Enable logging of secrets to the file specified in env SSLKEYLOGFILE. */\n#ifdef HAVE_KEYLOG_CALLBACK\n  if(Curl_tls_keylog_enabled()) {\n    SSL_CTX_set_keylog_callback(backend->ctx, ossl_keylog_callback);\n  }\n#endif\n\n  /* Enable the session cache because it's a prerequisite for the \"new session\"\n   * callback. Use the \"external storage\" mode to avoid that OpenSSL creates\n   * an internal session cache.\n   */\n  SSL_CTX_set_session_cache_mode(backend->ctx,\n      SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL);\n  SSL_CTX_sess_set_new_cb(backend->ctx, ossl_new_session_cb);\n\n  /* give application a chance to interfere with SSL set up. */\n  if(data->set.ssl.fsslctx) {\n    Curl_set_in_callback(data, true);\n    result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n                                      data->set.ssl.fsslctxp);\n    Curl_set_in_callback(data, false);\n    if(result) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return result;\n    }\n  }\n\n  /* Lets make an SSL structure */\n  if(backend->handle)\n    SSL_free(backend->handle);\n  backend->handle = SSL_new(backend->ctx);\n  if(!backend->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  if(SSL_CONN_CONFIG(verifystatus))\n    SSL_set_tlsext_status_type(backend->handle, TLSEXT_STATUSTYPE_ocsp);\n#endif\n\n#if defined(OPENSSL_IS_BORINGSSL) && defined(ALLOW_RENEG)\n  SSL_set_renegotiate_mode(backend->handle, ssl_renegotiate_freely);\n#endif\n\n  SSL_set_connect_state(backend->handle);\n\n  backend->server_cert = 0x0;\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&\n#ifdef ENABLE_IPV6\n     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&\n#endif\n     sni) {\n    size_t nlen = strlen(hostname);\n    if((long)nlen >= data->set.buffer_size)\n      /* this is seriously messed up */\n      return CURLE_SSL_CONNECT_ERROR;\n\n    /* RFC 6066 section 3 says the SNI field is case insensitive, but browsers\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased */\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      /* Store the data needed for the \"new session\" callback.\n       * The sockindex is stored as a pointer to an array element. */\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n\n    }\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);\n  }\n  else\n#endif\n    if(!SSL_set_fd(backend->handle, (int)sockfd)) {\n    /* pass the raw socket into the SSL layers */\n    failf(data, \"SSL: SSL_set_fd failed: %s\",\n          ossl_strerror(ERR_get_error(), error_buffer, sizeof(error_buffer)));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode ossl_connect_step2(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  int err;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state\n              || ssl_connect_2_reading == connssl->connecting_state\n              || ssl_connect_2_writing == connssl->connecting_state);\n\n  ERR_clear_error();\n\n  err = SSL_connect(backend->handle);\n#ifndef HAVE_KEYLOG_CALLBACK\n  if(Curl_tls_keylog_enabled()) {\n    /* If key logging is enabled, wait for the handshake to complete and then\n     * proceed with logging secrets (for TLS 1.2 or older).\n     */\n    ossl_log_tls12_secret(backend->handle, &backend->keylog_done);\n  }\n#endif\n\n  /* 1  is fine\n     0  is \"not successful but was shut down controlled\"\n     <0 is \"handshake was not successful, because a fatal error occurred\" */\n  if(1 != err) {\n    int detail = SSL_get_error(backend->handle, err);\n\n    if(SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    if(SSL_ERROR_WANT_WRITE == detail) {\n      connssl->connecting_state = ssl_connect_2_writing;\n      return CURLE_OK;\n    }\n#ifdef SSL_ERROR_WANT_ASYNC\n    if(SSL_ERROR_WANT_ASYNC == detail) {\n      connssl->connecting_state = ssl_connect_2;\n      return CURLE_OK;\n    }\n#endif\n    else {\n      /* untreated error */\n      unsigned long errdetail;\n      char error_buffer[256]=\"\";\n      CURLcode result;\n      long lerr;\n      int lib;\n      int reason;\n\n      /* the connection failed, we're not waiting for anything else. */\n      connssl->connecting_state = ssl_connect_2;\n\n      /* Get the earliest error code from the thread's error queue and removes\n         the entry. */\n      errdetail = ERR_get_error();\n\n      /* Extract which lib and reason */\n      lib = ERR_GET_LIB(errdetail);\n      reason = ERR_GET_REASON(errdetail);\n\n      if((lib == ERR_LIB_SSL) &&\n         ((reason == SSL_R_CERTIFICATE_VERIFY_FAILED) ||\n          (reason == SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED))) {\n        result = CURLE_PEER_FAILED_VERIFICATION;\n\n        lerr = SSL_get_verify_result(backend->handle);\n        if(lerr != X509_V_OK) {\n          SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;\n          msnprintf(error_buffer, sizeof(error_buffer),\n                    \"SSL certificate problem: %s\",\n                    X509_verify_cert_error_string(lerr));\n        }\n        else\n          /* strcpy() is fine here as long as the string fits within\n             error_buffer */\n          strcpy(error_buffer, \"SSL certificate verification failed\");\n      }\n#if (OPENSSL_VERSION_NUMBER >= 0x10101000L && \\\n    !defined(LIBRESSL_VERSION_NUMBER) && \\\n    !defined(OPENSSL_IS_BORINGSSL))\n      /* SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED is only available on\n         OpenSSL version above v1.1.1, not Libre SSL nor BoringSSL */\n      else if((lib == ERR_LIB_SSL) &&\n              (reason == SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED)) {\n          /* If client certificate is required, communicate the\n             error to client */\n          result = CURLE_SSL_CLIENTCERT;\n          ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));\n      }\n#endif\n      else {\n        result = CURLE_SSL_CONNECT_ERROR;\n        ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));\n      }\n\n      /* detail is already set to the SSL error above */\n\n      /* If we e.g. use SSLv2 request-method and the server doesn't like us\n       * (RST connection etc.), OpenSSL gives no explanation whatsoever and\n       * the SO_ERROR is also lost.\n       */\n      if(CURLE_SSL_CONNECT_ERROR == result && errdetail == 0) {\n        const char * const hostname = SSL_HOST_NAME();\n        const long int port = SSL_HOST_PORT();\n        char extramsg[80]=\"\";\n        int sockerr = SOCKERRNO;\n        if(sockerr && detail == SSL_ERROR_SYSCALL)\n          Curl_strerror(sockerr, extramsg, sizeof(extramsg));\n        failf(data, OSSL_PACKAGE \" SSL_connect: %s in connection to %s:%ld \",\n              extramsg[0] ? extramsg : SSL_ERROR_to_str(detail),\n              hostname, port);\n        return result;\n      }\n\n      /* Could be a CERT problem */\n      failf(data, \"%s\", error_buffer);\n\n      return result;\n    }\n  }\n  else {\n    /* we have been connected fine, we're not waiting for anything else. */\n    connssl->connecting_state = ssl_connect_3;\n\n    /* Informational message */\n    infof(data, \"SSL connection using %s / %s\\n\",\n          SSL_get_version(backend->handle),\n          SSL_get_cipher(backend->handle));\n\n#ifdef HAS_ALPN\n    /* Sets data and len to negotiated protocol, len is 0 if no protocol was\n     * negotiated\n     */\n    if(conn->bits.tls_enable_alpn) {\n      const unsigned char *neg_protocol;\n      unsigned int len;\n      SSL_get0_alpn_selected(backend->handle, &neg_protocol, &len);\n      if(len) {\n        infof(data, \"ALPN, server accepted to use %.*s\\n\", len, neg_protocol);\n\n#ifdef USE_HTTP2\n        if(len == ALPN_H2_LENGTH &&\n           !memcmp(ALPN_H2, neg_protocol, len)) {\n          conn->negnpn = CURL_HTTP_VERSION_2;\n        }\n        else\n#endif\n        if(len == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, neg_protocol, ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n      }\n      else\n        infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n      Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                          BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n    }\n#endif\n\n    return CURLE_OK;\n  }\n}\n\nstatic int asn1_object_dump(ASN1_OBJECT *a, char *buf, size_t len)\n{\n  int i, ilen;\n\n  ilen = (int)len;\n  if(ilen < 0)\n    return 1; /* buffer too big */\n\n  i = i2t_ASN1_OBJECT(buf, ilen, a);\n\n  if(i >= ilen)\n    return 1; /* buffer too small */\n\n  return 0;\n}\n\n#define push_certinfo(_label, _num) \\\ndo {                              \\\n  long info_len = BIO_get_mem_data(mem, &ptr); \\\n  Curl_ssl_push_certinfo_len(data, _num, _label, ptr, info_len); \\\n  if(1 != BIO_reset(mem))                                        \\\n    break;                                                       \\\n} while(0)\n\nstatic void pubkey_show(struct Curl_easy *data,\n                        BIO *mem,\n                        int num,\n                        const char *type,\n                        const char *name,\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n                        const\n#endif\n                        BIGNUM *bn)\n{\n  char *ptr;\n  char namebuf[32];\n\n  msnprintf(namebuf, sizeof(namebuf), \"%s(%s)\", type, name);\n\n  if(bn)\n    BN_print(mem, bn);\n  push_certinfo(namebuf, num);\n}\n\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n#define print_pubkey_BN(_type, _name, _num)              \\\n  pubkey_show(data, mem, _num, #_type, #_name, _name)\n\n#else\n#define print_pubkey_BN(_type, _name, _num)    \\\ndo {                              \\\n  if(_type->_name) { \\\n    pubkey_show(data, mem, _num, #_type, #_name, _type->_name); \\\n  } \\\n} while(0)\n#endif\n\nstatic void X509V3_ext(struct Curl_easy *data,\n                      int certnum,\n                      CONST_EXTS STACK_OF(X509_EXTENSION) *exts)\n{\n  int i;\n\n  if((int)sk_X509_EXTENSION_num(exts) <= 0)\n    /* no extensions, bail out */\n    return;\n\n  for(i = 0; i < (int)sk_X509_EXTENSION_num(exts); i++) {\n    ASN1_OBJECT *obj;\n    X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);\n    BUF_MEM *biomem;\n    char namebuf[128];\n    BIO *bio_out = BIO_new(BIO_s_mem());\n\n    if(!bio_out)\n      return;\n\n    obj = X509_EXTENSION_get_object(ext);\n\n    asn1_object_dump(obj, namebuf, sizeof(namebuf));\n\n    if(!X509V3_EXT_print(bio_out, ext, 0, 0))\n      ASN1_STRING_print(bio_out, (ASN1_STRING *)X509_EXTENSION_get_data(ext));\n\n    BIO_get_mem_ptr(bio_out, &biomem);\n    Curl_ssl_push_certinfo_len(data, certnum, namebuf, biomem->data,\n                               biomem->length);\n    BIO_free(bio_out);\n  }\n}\n\n#ifdef OPENSSL_IS_BORINGSSL\ntypedef size_t numcert_t;\n#else\ntypedef int numcert_t;\n#endif\n\n#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)\n#define OSSL3_CONST const\n#else\n#define OSSL3_CONST\n#endif\n\nstatic CURLcode get_cert_chain(struct Curl_easy *data,\n                               struct ssl_connect_data *connssl)\n{\n  CURLcode result;\n  STACK_OF(X509) *sk;\n  int i;\n  numcert_t numcerts;\n  BIO *mem;\n  struct ssl_backend_data *backend = connssl->backend;\n\n  sk = SSL_get_peer_cert_chain(backend->handle);\n  if(!sk) {\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  numcerts = sk_X509_num(sk);\n\n  result = Curl_ssl_init_certinfo(data, (int)numcerts);\n  if(result) {\n    return result;\n  }\n\n  mem = BIO_new(BIO_s_mem());\n\n  for(i = 0; i < (int)numcerts; i++) {\n    ASN1_INTEGER *num;\n    X509 *x = sk_X509_value(sk, i);\n    EVP_PKEY *pubkey = NULL;\n    int j;\n    char *ptr;\n    const ASN1_BIT_STRING *psig = NULL;\n\n    X509_NAME_print_ex(mem, X509_get_subject_name(x), 0, XN_FLAG_ONELINE);\n    push_certinfo(\"Subject\", i);\n\n    X509_NAME_print_ex(mem, X509_get_issuer_name(x), 0, XN_FLAG_ONELINE);\n    push_certinfo(\"Issuer\", i);\n\n    BIO_printf(mem, \"%lx\", X509_get_version(x));\n    push_certinfo(\"Version\", i);\n\n    num = X509_get_serialNumber(x);\n    if(num->type == V_ASN1_NEG_INTEGER)\n      BIO_puts(mem, \"-\");\n    for(j = 0; j < num->length; j++)\n      BIO_printf(mem, \"%02x\", num->data[j]);\n    push_certinfo(\"Serial Number\", i);\n\n#if defined(HAVE_X509_GET0_SIGNATURE) && defined(HAVE_X509_GET0_EXTENSIONS)\n    {\n      const X509_ALGOR *sigalg = NULL;\n      X509_PUBKEY *xpubkey = NULL;\n      ASN1_OBJECT *pubkeyoid = NULL;\n\n      X509_get0_signature(&psig, &sigalg, x);\n      if(sigalg) {\n        i2a_ASN1_OBJECT(mem, sigalg->algorithm);\n        push_certinfo(\"Signature Algorithm\", i);\n      }\n\n      xpubkey = X509_get_X509_PUBKEY(x);\n      if(xpubkey) {\n        X509_PUBKEY_get0_param(&pubkeyoid, NULL, NULL, NULL, xpubkey);\n        if(pubkeyoid) {\n          i2a_ASN1_OBJECT(mem, pubkeyoid);\n          push_certinfo(\"Public Key Algorithm\", i);\n        }\n      }\n\n      X509V3_ext(data, i, X509_get0_extensions(x));\n    }\n#else\n    {\n      /* before OpenSSL 1.0.2 */\n      X509_CINF *cinf = x->cert_info;\n\n      i2a_ASN1_OBJECT(mem, cinf->signature->algorithm);\n      push_certinfo(\"Signature Algorithm\", i);\n\n      i2a_ASN1_OBJECT(mem, cinf->key->algor->algorithm);\n      push_certinfo(\"Public Key Algorithm\", i);\n\n      X509V3_ext(data, i, cinf->extensions);\n\n      psig = x->signature;\n    }\n#endif\n\n    ASN1_TIME_print(mem, X509_get0_notBefore(x));\n    push_certinfo(\"Start date\", i);\n\n    ASN1_TIME_print(mem, X509_get0_notAfter(x));\n    push_certinfo(\"Expire date\", i);\n\n    pubkey = X509_get_pubkey(x);\n    if(!pubkey)\n      infof(data, \"   Unable to load public key\\n\");\n    else {\n      int pktype;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n      pktype = EVP_PKEY_id(pubkey);\n#else\n      pktype = pubkey->type;\n#endif\n      switch(pktype) {\n      case EVP_PKEY_RSA:\n      {\n        OSSL3_CONST RSA *rsa;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        rsa = EVP_PKEY_get0_RSA(pubkey);\n#else\n        rsa = pubkey->pkey.rsa;\n#endif\n\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *n;\n          const BIGNUM *e;\n\n          RSA_get0_key(rsa, &n, &e, NULL);\n          BIO_printf(mem, \"%d\", BN_num_bits(n));\n          push_certinfo(\"RSA Public Key\", i);\n          print_pubkey_BN(rsa, n, i);\n          print_pubkey_BN(rsa, e, i);\n        }\n#else\n        BIO_printf(mem, \"%d\", BN_num_bits(rsa->n));\n        push_certinfo(\"RSA Public Key\", i);\n        print_pubkey_BN(rsa, n, i);\n        print_pubkey_BN(rsa, e, i);\n#endif\n\n        break;\n      }\n      case EVP_PKEY_DSA:\n      {\n#ifndef OPENSSL_NO_DSA\n        OSSL3_CONST DSA *dsa;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        dsa = EVP_PKEY_get0_DSA(pubkey);\n#else\n        dsa = pubkey->pkey.dsa;\n#endif\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *p;\n          const BIGNUM *q;\n          const BIGNUM *g;\n          const BIGNUM *pub_key;\n\n          DSA_get0_pqg(dsa, &p, &q, &g);\n          DSA_get0_key(dsa, &pub_key, NULL);\n\n          print_pubkey_BN(dsa, p, i);\n          print_pubkey_BN(dsa, q, i);\n          print_pubkey_BN(dsa, g, i);\n          print_pubkey_BN(dsa, pub_key, i);\n        }\n#else\n        print_pubkey_BN(dsa, p, i);\n        print_pubkey_BN(dsa, q, i);\n        print_pubkey_BN(dsa, g, i);\n        print_pubkey_BN(dsa, pub_key, i);\n#endif\n#endif /* !OPENSSL_NO_DSA */\n        break;\n      }\n      case EVP_PKEY_DH:\n      {\n        OSSL3_CONST DH *dh;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        dh = EVP_PKEY_get0_DH(pubkey);\n#else\n        dh = pubkey->pkey.dh;\n#endif\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *p;\n          const BIGNUM *q;\n          const BIGNUM *g;\n          const BIGNUM *pub_key;\n          DH_get0_pqg(dh, &p, &q, &g);\n          DH_get0_key(dh, &pub_key, NULL);\n          print_pubkey_BN(dh, p, i);\n          print_pubkey_BN(dh, q, i);\n          print_pubkey_BN(dh, g, i);\n          print_pubkey_BN(dh, pub_key, i);\n       }\n#else\n        print_pubkey_BN(dh, p, i);\n        print_pubkey_BN(dh, g, i);\n        print_pubkey_BN(dh, pub_key, i);\n#endif\n        break;\n      }\n      }\n      EVP_PKEY_free(pubkey);\n    }\n\n    if(psig) {\n      for(j = 0; j < psig->length; j++)\n        BIO_printf(mem, \"%02x:\", psig->data[j]);\n      push_certinfo(\"Signature\", i);\n    }\n\n    PEM_write_bio_X509(mem, x);\n    push_certinfo(\"Cert\", i);\n  }\n\n  BIO_free(mem);\n\n  return CURLE_OK;\n}\n\n/*\n * Heavily modified from:\n * https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#OpenSSL\n */\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data, X509* cert,\n                                    const char *pinnedpubkey)\n{\n  /* Scratch */\n  int len1 = 0, len2 = 0;\n  unsigned char *buff1 = NULL, *temp = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  if(!cert)\n    return result;\n\n  do {\n    /* Begin Gyrations to get the subjectPublicKeyInfo     */\n    /* Thanks to Viktor Dukhovni on the OpenSSL mailing list */\n\n    /* https://groups.google.com/group/mailing.openssl.users/browse_thread\n     /thread/d61858dae102c6c7 */\n    len1 = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), NULL);\n    if(len1 < 1)\n      break; /* failed */\n\n    buff1 = temp = malloc(len1);\n    if(!buff1)\n      break; /* failed */\n\n    /* https://www.openssl.org/docs/crypto/d2i_X509.html */\n    len2 = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), &temp);\n\n    /*\n     * These checks are verifying we got back the same values as when we\n     * sized the buffer. It's pretty weak since they should always be the\n     * same. But it gives us something to test.\n     */\n    if((len1 != len2) || !temp || ((temp - buff1) != len1))\n      break; /* failed */\n\n    /* End Gyrations */\n\n    /* The one good exit point */\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, buff1, len1);\n  } while(0);\n\n  if(buff1)\n    free(buff1);\n\n  return result;\n}\n\n/*\n * Get the server cert, verify it and show it etc, only call failf() if the\n * 'strict' argument is TRUE as otherwise all this is for informational\n * purposes only!\n *\n * We check certificates to authenticate the server; otherwise we risk\n * man-in-the-middle attack.\n */\nstatic CURLcode servercert(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           struct ssl_connect_data *connssl,\n                           bool strict)\n{\n  CURLcode result = CURLE_OK;\n  int rc;\n  long lerr;\n  X509 *issuer;\n  BIO *fp = NULL;\n  char error_buffer[256]=\"\";\n  char buffer[2048];\n  const char *ptr;\n  BIO *mem = BIO_new(BIO_s_mem());\n  struct ssl_backend_data *backend = connssl->backend;\n\n  if(data->set.ssl.certinfo)\n    /* we've been asked to gather certificate info! */\n    (void)get_cert_chain(data, connssl);\n\n  backend->server_cert = SSL_get_peer_certificate(backend->handle);\n  if(!backend->server_cert) {\n    BIO_free(mem);\n    if(!strict)\n      return CURLE_OK;\n\n    failf(data, \"SSL: couldn't get peer certificate!\");\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  infof(data, \"%s certificate:\\n\", SSL_IS_PROXY() ? \"Proxy\" : \"Server\");\n\n  rc = x509_name_oneline(X509_get_subject_name(backend->server_cert),\n                         buffer, sizeof(buffer));\n  infof(data, \" subject: %s\\n\", rc?\"[NONE]\":buffer);\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  {\n    long len;\n    ASN1_TIME_print(mem, X509_get0_notBefore(backend->server_cert));\n    len = BIO_get_mem_data(mem, (char **) &ptr);\n    infof(data, \" start date: %.*s\\n\", len, ptr);\n    (void)BIO_reset(mem);\n\n    ASN1_TIME_print(mem, X509_get0_notAfter(backend->server_cert));\n    len = BIO_get_mem_data(mem, (char **) &ptr);\n    infof(data, \" expire date: %.*s\\n\", len, ptr);\n    (void)BIO_reset(mem);\n  }\n#endif\n\n  BIO_free(mem);\n\n  if(SSL_CONN_CONFIG(verifyhost)) {\n    result = verifyhost(data, conn, backend->server_cert);\n    if(result) {\n      X509_free(backend->server_cert);\n      backend->server_cert = NULL;\n      return result;\n    }\n  }\n\n  rc = x509_name_oneline(X509_get_issuer_name(backend->server_cert),\n                         buffer, sizeof(buffer));\n  if(rc) {\n    if(strict)\n      failf(data, \"SSL: couldn't get X509-issuer name!\");\n    result = CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else {\n    infof(data, \" issuer: %s\\n\", buffer);\n\n    /* We could do all sorts of certificate verification stuff here before\n       deallocating the certificate. */\n\n    /* e.g. match issuer name with provided issuer certificate */\n    if(SSL_SET_OPTION(issuercert) || SSL_SET_OPTION(issuercert_blob)) {\n      if(SSL_SET_OPTION(issuercert_blob))\n        fp = BIO_new_mem_buf(SSL_SET_OPTION(issuercert_blob)->data,\n                             (int)SSL_SET_OPTION(issuercert_blob)->len);\n      else {\n        fp = BIO_new(BIO_s_file());\n        if(!fp) {\n          failf(data,\n                \"BIO_new return NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          X509_free(backend->server_cert);\n          backend->server_cert = NULL;\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        if(BIO_read_filename(fp, SSL_SET_OPTION(issuercert)) <= 0) {\n          if(strict)\n            failf(data, \"SSL: Unable to open issuer cert (%s)\",\n                  SSL_SET_OPTION(issuercert));\n          BIO_free(fp);\n          X509_free(backend->server_cert);\n          backend->server_cert = NULL;\n          return CURLE_SSL_ISSUER_ERROR;\n        }\n      }\n\n      issuer = PEM_read_bio_X509(fp, NULL, ZERO_NULL, NULL);\n      if(!issuer) {\n        if(strict)\n          failf(data, \"SSL: Unable to read issuer cert (%s)\",\n                SSL_SET_OPTION(issuercert));\n        BIO_free(fp);\n        X509_free(issuer);\n        X509_free(backend->server_cert);\n        backend->server_cert = NULL;\n        return CURLE_SSL_ISSUER_ERROR;\n      }\n\n      if(X509_check_issued(issuer, backend->server_cert) != X509_V_OK) {\n        if(strict)\n          failf(data, \"SSL: Certificate issuer check failed (%s)\",\n                SSL_SET_OPTION(issuercert));\n        BIO_free(fp);\n        X509_free(issuer);\n        X509_free(backend->server_cert);\n        backend->server_cert = NULL;\n        return CURLE_SSL_ISSUER_ERROR;\n      }\n\n      infof(data, \" SSL certificate issuer check ok (%s)\\n\",\n            SSL_SET_OPTION(issuercert));\n      BIO_free(fp);\n      X509_free(issuer);\n    }\n\n    lerr = SSL_get_verify_result(backend->handle);\n    SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;\n    if(lerr != X509_V_OK) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        /* We probably never reach this, because SSL_connect() will fail\n           and we return earlier if verifypeer is set? */\n        if(strict)\n          failf(data, \"SSL certificate verify result: %s (%ld)\",\n                X509_verify_cert_error_string(lerr), lerr);\n        result = CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \" SSL certificate verify result: %s (%ld),\"\n              \" continuing anyway.\\n\",\n              X509_verify_cert_error_string(lerr), lerr);\n    }\n    else\n      infof(data, \" SSL certificate verify ok.\\n\");\n  }\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    result = verifystatus(data, connssl);\n    if(result) {\n      X509_free(backend->server_cert);\n      backend->server_cert = NULL;\n      return result;\n    }\n  }\n#endif\n\n  if(!strict)\n    /* when not strict, we don't bother about the verify cert problems */\n    result = CURLE_OK;\n\n  ptr = SSL_PINNED_PUB_KEY();\n  if(!result && ptr) {\n    result = pkp_pin_peer_pubkey(data, backend->server_cert, ptr);\n    if(result)\n      failf(data, \"SSL: public key does not match pinned public key!\");\n  }\n\n  X509_free(backend->server_cert);\n  backend->server_cert = NULL;\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic CURLcode ossl_connect_step3(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  /*\n   * We check certificates to authenticate the server; otherwise we risk\n   * man-in-the-middle attack; NEVERTHELESS, if we're told explicitly not to\n   * verify the peer ignore faults and failures from the server cert\n   * operations.\n   */\n\n  result = servercert(data, conn, connssl, (SSL_CONN_CONFIG(verifypeer) ||\n                                            SSL_CONN_CONFIG(verifyhost)));\n\n  if(!result)\n    connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic Curl_recv ossl_recv;\nstatic Curl_send ossl_send;\n\nstatic CURLcode ossl_connect_common(struct Curl_easy *data,\n                                    struct connectdata *conn,\n                                    int sockindex,\n                                    bool nonblocking,\n                                    bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = ossl_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        /* timeout */\n        failf(data, \"SSL connection timeout\");\n        return CURLE_OPERATION_TIMEDOUT;\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if this\n     * connection is done nonblocking and this loop would execute again. This\n     * permits the owner of a multi handle to abort a connection attempt\n     * before step2 has completed while ensuring that a client using select()\n     * or epoll() will always have a valid fdset to wait on.\n     */\n    result = ossl_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = ossl_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = ossl_recv;\n    conn->send[sockindex] = ossl_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode ossl_connect_nonblocking(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex,\n                                         bool *done)\n{\n  return ossl_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode ossl_connect(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = ossl_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool ossl_data_pending(const struct connectdata *conn,\n                              int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  if(connssl->backend->handle && SSL_pending(connssl->backend->handle))\n    return TRUE;\n#ifndef CURL_DISABLE_PROXY\n  {\n    const struct ssl_connect_data *proxyssl = &conn->proxy_ssl[connindex];\n    if(proxyssl->backend->handle && SSL_pending(proxyssl->backend->handle))\n      return TRUE;\n  }\n#endif\n  return FALSE;\n}\n\nstatic size_t ossl_version(char *buffer, size_t size);\n\nstatic ssize_t ossl_send(struct Curl_easy *data,\n                         int sockindex,\n                         const void *mem,\n                         size_t len,\n                         CURLcode *curlcode)\n{\n  /* SSL_write() is said to return 'int' while write() and send() returns\n     'size_t' */\n  int err;\n  char error_buffer[256];\n  unsigned long sslerror;\n  int memlen;\n  int rc;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  ERR_clear_error();\n\n  memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  set_logger(conn, data);\n  rc = SSL_write(backend->handle, mem, memlen);\n\n  if(rc <= 0) {\n    err = SSL_get_error(backend->handle, rc);\n\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* The operation did not complete; the same TLS/SSL I/O function\n         should be called again later. This is basically an EWOULDBLOCK\n         equivalent. */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    case SSL_ERROR_SYSCALL:\n      {\n        int sockerr = SOCKERRNO;\n        sslerror = ERR_get_error();\n        if(sslerror)\n          ossl_strerror(sslerror, error_buffer, sizeof(error_buffer));\n        else if(sockerr)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          strncpy(error_buffer, SSL_ERROR_to_str(err), sizeof(error_buffer));\n          error_buffer[sizeof(error_buffer) - 1] = '\\0';\n        }\n        failf(data, OSSL_PACKAGE \" SSL_write: %s, errno %d\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_SEND_ERROR;\n        return -1;\n      }\n    case SSL_ERROR_SSL:\n      /*  A failure in the SSL library occurred, usually a protocol error.\n          The OpenSSL error queue contains more information on the error. */\n      sslerror = ERR_get_error();\n      if(ERR_GET_LIB(sslerror) == ERR_LIB_SSL &&\n         ERR_GET_REASON(sslerror) == SSL_R_BIO_NOT_SET &&\n         conn->ssl[sockindex].state == ssl_connection_complete\n#ifndef CURL_DISABLE_PROXY\n         && conn->proxy_ssl[sockindex].state == ssl_connection_complete\n#endif\n        ) {\n        char ver[120];\n        ossl_version(ver, 120);\n        failf(data, \"Error: %s does not support double SSL tunneling.\", ver);\n      }\n      else\n        failf(data, \"SSL_write() error: %s\",\n              ossl_strerror(sslerror, error_buffer, sizeof(error_buffer)));\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n    /* a true error */\n    failf(data, OSSL_PACKAGE \" SSL_write: %s, errno %d\",\n          SSL_ERROR_to_str(err), SOCKERRNO);\n    *curlcode = CURLE_SEND_ERROR;\n    return -1;\n  }\n  *curlcode = CURLE_OK;\n  return (ssize_t)rc; /* number of bytes */\n}\n\nstatic ssize_t ossl_recv(struct Curl_easy *data,   /* transfer */\n                         int num,                  /* socketindex */\n                         char *buf,                /* store read data here */\n                         size_t buffersize,        /* max amount to read */\n                         CURLcode *curlcode)\n{\n  char error_buffer[256];\n  unsigned long sslerror;\n  ssize_t nread;\n  int buffsize;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  ERR_clear_error();\n\n  buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  set_logger(conn, data);\n  nread = (ssize_t)SSL_read(backend->handle, buf, buffsize);\n  if(nread <= 0) {\n    /* failed SSL_read */\n    int err = SSL_get_error(backend->handle, (int)nread);\n\n    switch(err) {\n    case SSL_ERROR_NONE: /* this is not an error */\n      break;\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n      /* close_notify alert */\n      if(num == FIRSTSOCKET)\n        /* mark the connection for close if it is indeed the control\n           connection */\n        connclose(conn, \"TLS close_notify\");\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      /* openssl/ssl.h for SSL_ERROR_SYSCALL says \"look at error stack/return\n         value/errno\" */\n      /* https://www.openssl.org/docs/crypto/ERR_get_error.html */\n      sslerror = ERR_get_error();\n      if((nread < 0) || sslerror) {\n        /* If the return code was negative or there actually is an error in the\n           queue */\n        int sockerr = SOCKERRNO;\n        if(sslerror)\n          ossl_strerror(sslerror, error_buffer, sizeof(error_buffer));\n        else if(sockerr && err == SSL_ERROR_SYSCALL)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          strncpy(error_buffer, SSL_ERROR_to_str(err), sizeof(error_buffer));\n          error_buffer[sizeof(error_buffer) - 1] = '\\0';\n        }\n        failf(data, OSSL_PACKAGE \" SSL_read: %s, errno %d\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1;\n      }\n      /* For debug builds be a little stricter and error on any\n         SSL_ERROR_SYSCALL. For example a server may have closed the connection\n         abruptly without a close_notify alert. For compatibility with older\n         peers we don't do this by default. #4624\n\n         We can use this to gauge how many users may be affected, and\n         if it goes ok eventually transition to allow in dev and release with\n         the newest OpenSSL: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) */\n#ifdef DEBUGBUILD\n      if(err == SSL_ERROR_SYSCALL) {\n        int sockerr = SOCKERRNO;\n        if(sockerr)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          msnprintf(error_buffer, sizeof(error_buffer),\n                    \"Connection closed abruptly\");\n        }\n        failf(data, OSSL_PACKAGE \" SSL_read: %s, errno %d\"\n              \" (Fatal because this is a curl debug build)\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1;\n      }\n#endif\n    }\n  }\n  return nread;\n}\n\nstatic size_t ossl_version(char *buffer, size_t size)\n{\n#ifdef LIBRESSL_VERSION_NUMBER\n#if LIBRESSL_VERSION_NUMBER < 0x2070100fL\n  return msnprintf(buffer, size, \"%s/%lx.%lx.%lx\",\n                   OSSL_PACKAGE,\n                   (LIBRESSL_VERSION_NUMBER>>28)&0xf,\n                   (LIBRESSL_VERSION_NUMBER>>20)&0xff,\n                   (LIBRESSL_VERSION_NUMBER>>12)&0xff);\n#else /* OpenSSL_version() first appeared in LibreSSL 2.7.1 */\n  char *p;\n  int count;\n  const char *ver = OpenSSL_version(OPENSSL_VERSION);\n  const char expected[] = OSSL_PACKAGE \" \"; /* ie \"LibreSSL \" */\n  if(Curl_strncasecompare(ver, expected, sizeof(expected) - 1)) {\n    ver += sizeof(expected) - 1;\n  }\n  count = msnprintf(buffer, size, \"%s/%s\", OSSL_PACKAGE, ver);\n  for(p = buffer; *p; ++p) {\n    if(ISSPACE(*p))\n      *p = '_';\n  }\n  return count;\n#endif\n#elif defined(OPENSSL_IS_BORINGSSL)\n  return msnprintf(buffer, size, OSSL_PACKAGE);\n#elif defined(HAVE_OPENSSL_VERSION) && defined(OPENSSL_VERSION_STRING)\n  return msnprintf(buffer, size, \"%s/%s\",\n                   OSSL_PACKAGE, OpenSSL_version(OPENSSL_VERSION_STRING));\n#else\n  /* not LibreSSL, BoringSSL and not using OpenSSL_version */\n\n  char sub[3];\n  unsigned long ssleay_value;\n  sub[2]='\\0';\n  sub[1]='\\0';\n  ssleay_value = OpenSSL_version_num();\n  if(ssleay_value < 0x906000) {\n    ssleay_value = SSLEAY_VERSION_NUMBER;\n    sub[0]='\\0';\n  }\n  else {\n    if(ssleay_value&0xff0) {\n      int minor_ver = (ssleay_value >> 4) & 0xff;\n      if(minor_ver > 26) {\n        /* handle extended version introduced for 0.9.8za */\n        sub[1] = (char) ((minor_ver - 1) % 26 + 'a' + 1);\n        sub[0] = 'z';\n      }\n      else {\n        sub[0] = (char) (minor_ver + 'a' - 1);\n      }\n    }\n    else\n      sub[0]='\\0';\n  }\n\n  return msnprintf(buffer, size, \"%s/%lx.%lx.%lx%s\"\n#ifdef OPENSSL_FIPS\n                   \"-fips\"\n#endif\n                   ,\n                   OSSL_PACKAGE,\n                   (ssleay_value>>28)&0xf,\n                   (ssleay_value>>20)&0xff,\n                   (ssleay_value>>12)&0xff,\n                   sub);\n#endif /* OPENSSL_IS_BORINGSSL */\n}\n\n/* can be called with data == NULL */\nstatic CURLcode ossl_random(struct Curl_easy *data,\n                            unsigned char *entropy, size_t length)\n{\n  int rc;\n  if(data) {\n    if(ossl_seed(data)) /* Initiate the seed if not already done */\n      return CURLE_FAILED_INIT; /* couldn't seed for some reason */\n  }\n  else {\n    if(!rand_enough())\n      return CURLE_FAILED_INIT;\n  }\n  /* RAND_bytes() returns 1 on success, 0 otherwise.  */\n  rc = RAND_bytes(entropy, curlx_uztosi(length));\n  return (rc == 1 ? CURLE_OK : CURLE_FAILED_INIT);\n}\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\nstatic CURLcode ossl_sha256sum(const unsigned char *tmp, /* input */\n                               size_t tmplen,\n                               unsigned char *sha256sum /* output */,\n                               size_t unused)\n{\n  EVP_MD_CTX *mdctx;\n  unsigned int len = 0;\n  (void) unused;\n\n  mdctx = EVP_MD_CTX_create();\n  if(!mdctx)\n    return CURLE_OUT_OF_MEMORY;\n  EVP_DigestInit(mdctx, EVP_sha256());\n  EVP_DigestUpdate(mdctx, tmp, tmplen);\n  EVP_DigestFinal_ex(mdctx, sha256sum, &len);\n  EVP_MD_CTX_destroy(mdctx);\n  return CURLE_OK;\n}\n#endif\n\nstatic bool ossl_cert_status_request(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic void *ossl_get_internals(struct ssl_connect_data *connssl,\n                                CURLINFO info)\n{\n  /* Legacy: CURLINFO_TLS_SESSION must return an SSL_CTX pointer. */\n  struct ssl_backend_data *backend = connssl->backend;\n  return info == CURLINFO_TLS_SESSION ?\n         (void *)backend->ctx : (void *)backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_openssl = {\n  { CURLSSLBACKEND_OPENSSL, \"openssl\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CAINFO_BLOB |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_SSL_CTX |\n#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES\n  SSLSUPP_TLS13_CIPHERSUITES |\n#endif\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  ossl_init,                /* init */\n  ossl_cleanup,             /* cleanup */\n  ossl_version,             /* version */\n  ossl_check_cxn,           /* check_cxn */\n  ossl_shutdown,            /* shutdown */\n  ossl_data_pending,        /* data_pending */\n  ossl_random,              /* random */\n  ossl_cert_status_request, /* cert_status_request */\n  ossl_connect,             /* connect */\n  ossl_connect_nonblocking, /* connect_nonblocking */\n  Curl_ssl_getsock,         /* getsock */\n  ossl_get_internals,       /* get_internals */\n  ossl_close,               /* close_one */\n  ossl_close_all,           /* close_all */\n  ossl_session_free,        /* session_free */\n  ossl_set_engine,          /* set_engine */\n  ossl_set_engine_default,  /* set_engine_default */\n  ossl_engines_list,        /* engines_list */\n  Curl_none_false_start,    /* false_start */\n#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\n  ossl_sha256sum            /* sha256sum */\n#else\n  NULL                      /* sha256sum */\n#endif\n};\n\n#endif /* USE_OPENSSL */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2020 - 2021, Jacob Hoffman-Andrews,\n * <github@hoffman-andrews.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#ifdef USE_RUSTLS\n\n#include \"curl_printf.h\"\n\n#include <errno.h>\n#include <crustls.h>\n\n#include \"inet_pton.h\"\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"vtls.h\"\n#include \"select.h\"\n\n#include \"multiif.h\"\n\n/* Per https://www.bearssl.org/api1.html, max TLS record size plus max\n   per-record overhead. */\n#define TLSBUF_SIZE (16384 + 325)\n\nstruct ssl_backend_data\n{\n  const struct rustls_client_config *config;\n  struct rustls_client_session *session;\n  bool data_pending;\n  uint8_t *tlsbuf;\n};\n\n/* For a given rustls_result error code, return the best-matching CURLcode. */\nstatic CURLcode map_error(rustls_result r)\n{\n  if(rustls_result_is_cert_error(r)) {\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  switch(r) {\n    case RUSTLS_RESULT_OK:\n      return CURLE_OK;\n    case RUSTLS_RESULT_NULL_PARAMETER:\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    default:\n      return CURLE_READ_ERROR;\n  }\n}\n\nstatic bool\ncr_data_pending(const struct connectdata *conn, int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  return backend->data_pending;\n}\n\nstatic CURLcode\ncr_connect(struct Curl_easy *data UNUSED_PARAM,\n                    struct connectdata *conn UNUSED_PARAM,\n                    int sockindex UNUSED_PARAM)\n{\n  infof(data, \"rustls_connect: unimplemented\\n\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n/*\n * On each run:\n *  - Read a chunk of bytes from the socket into rustls' TLS input buffer.\n *  - Tell rustls to process any new packets.\n *  - Read out as many plaintext bytes from rustls as possible, until hitting\n *    error, EOF, or EAGAIN/EWOULDBLOCK, or plainbuf/plainlen is filled up.\n *\n * It's okay to call this function with plainbuf == NULL and plainlen == 0.\n * In that case, it will copy bytes from the socket into rustls' TLS input\n * buffer, and process packets, but won't consume bytes from rustls' plaintext\n * output buffer.\n */\nstatic ssize_t\ncr_recv(struct Curl_easy *data, int sockindex,\n            char *plainbuf, size_t plainlen, CURLcode *err)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *const session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  size_t n = 0;\n  ssize_t tls_bytes_read = 0;\n  size_t tls_bytes_processed = 0;\n  size_t plain_bytes_copied = 0;\n  rustls_result rresult = 0;\n  char errorbuf[255];\n\n  tls_bytes_read = sread(sockfd, backend->tlsbuf, TLSBUF_SIZE);\n  if(tls_bytes_read == 0) {\n    failf(data, \"connection closed without TLS close_notify alert\");\n    *err = CURLE_READ_ERROR;\n    return -1;\n  }\n  else if(tls_bytes_read < 0) {\n    if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {\n      infof(data, \"sread: EAGAIN or EWOULDBLOCK\\n\");\n      /* There is no data in the socket right now, but there could still be\n         some data in the rustls session, so we need to read from it below. */\n      tls_bytes_read = 0;\n    }\n    else {\n      failf(data, \"reading from socket: %s\", strerror(SOCKERRNO));\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n  }\n\n  /*\n  * Now pull those bytes from the buffer into ClientSession.\n  */\n  DEBUGASSERT(tls_bytes_read >= 0);\n  while(tls_bytes_processed < (size_t)tls_bytes_read) {\n    rresult = rustls_client_session_read_tls(session,\n      backend->tlsbuf + tls_bytes_processed,\n      tls_bytes_read - tls_bytes_processed,\n      &n);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_read_tls\");\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n    else if(n == 0) {\n      infof(data, \"EOF from rustls_client_session_read_tls\\n\");\n      break;\n    }\n\n    rresult = rustls_client_session_process_new_packets(session);\n    if(rresult != RUSTLS_RESULT_OK) {\n      rustls_error(rresult, errorbuf, sizeof(errorbuf), &n);\n      failf(data, \"%.*s\", n, errorbuf);\n      *err = map_error(rresult);\n      return -1;\n    }\n\n    tls_bytes_processed += n;\n    backend->data_pending = TRUE;\n  }\n\n  while(plain_bytes_copied < plainlen) {\n    rresult = rustls_client_session_read(session,\n      (uint8_t *)plainbuf + plain_bytes_copied,\n      plainlen - plain_bytes_copied,\n      &n);\n    if(rresult == RUSTLS_RESULT_ALERT_CLOSE_NOTIFY) {\n      *err = CURLE_OK;\n      return 0;\n    }\n    else if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_read\");\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n    else if(n == 0) {\n      /* rustls returns 0 from client_session_read to mean \"all currently\n        available data has been read.\" If we bring in more ciphertext with\n        read_tls, more plaintext will become available. So don't tell curl\n        this is an EOF. Instead, say \"come back later.\" */\n      infof(data, \"EOF from rustls_client_session_read\\n\");\n      backend->data_pending = FALSE;\n      break;\n    }\n    else {\n      plain_bytes_copied += n;\n    }\n  }\n\n  /* If we wrote out 0 plaintext bytes, it might just mean we haven't yet\n     read a full TLS record. Return CURLE_AGAIN so curl doesn't treat this\n     as EOF. */\n  if(plain_bytes_copied == 0) {\n    *err = CURLE_AGAIN;\n    return -1;\n  }\n\n  return plain_bytes_copied;\n}\n\n/*\n * On each call:\n *  - Copy `plainlen` bytes into rustls' plaintext input buffer (if > 0).\n *  - Fully drain rustls' plaintext output buffer into the socket until\n *    we get either an error or EAGAIN/EWOULDBLOCK.\n *\n * It's okay to call this function with plainbuf == NULL and plainlen == 0.\n * In that case, it won't read anything into rustls' plaintext input buffer.\n * It will only drain rustls' plaintext output buffer into the socket.\n */\nstatic ssize_t\ncr_send(struct Curl_easy *data, int sockindex,\n        const void *plainbuf, size_t plainlen, CURLcode *err)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *const session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  ssize_t n = 0;\n  size_t plainwritten = 0;\n  size_t tlslen = 0;\n  size_t tlswritten = 0;\n  rustls_result rresult;\n\n  if(plainlen > 0) {\n    rresult = rustls_client_session_write(session,\n                                          plainbuf, plainlen, &plainwritten);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_write\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n    else if(plainwritten == 0) {\n      failf(data, \"EOF in rustls_client_session_write\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n  }\n\n  while(rustls_client_session_wants_write(session)) {\n    rresult = rustls_client_session_write_tls(\n      session, backend->tlsbuf, TLSBUF_SIZE, &tlslen);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_write_tls\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n    else if(tlslen == 0) {\n      failf(data, \"EOF in rustls_client_session_write_tls\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n\n    tlswritten = 0;\n\n    while(tlswritten < tlslen) {\n      n = swrite(sockfd, backend->tlsbuf + tlswritten, tlslen - tlswritten);\n      if(n < 0) {\n        if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {\n          /* Since recv is called from poll, there should be room to\n             write at least some bytes before hitting EAGAIN. */\n          infof(data, \"swrite: EAGAIN after %ld bytes\\n\", tlswritten);\n          DEBUGASSERT(tlswritten > 0);\n          break;\n        }\n        failf(data, \"error in swrite\");\n        *err = CURLE_WRITE_ERROR;\n        return -1;\n      }\n      if(n == 0) {\n        failf(data, \"EOF in swrite\");\n        *err = CURLE_WRITE_ERROR;\n        return -1;\n      }\n      tlswritten += n;\n    }\n\n    DEBUGASSERT(tlswritten <= tlslen);\n  }\n\n  return plainwritten;\n}\n\n/* A server certificate verify callback for rustls that always returns\n   RUSTLS_RESULT_OK, or in other words disable certificate verification. */\nstatic enum rustls_result\ncr_verify_none(void *userdata UNUSED_PARAM,\n               const rustls_verify_server_cert_params *params UNUSED_PARAM)\n{\n  return RUSTLS_RESULT_OK;\n}\n\nstatic bool\ncr_hostname_is_ip(const char *hostname)\n{\n  struct in_addr in;\n#ifdef ENABLE_IPV6\n  struct in6_addr in6;\n  if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0) {\n    return true;\n  }\n#endif /* ENABLE_IPV6 */\n  if(Curl_inet_pton(AF_INET, hostname, &in) > 0) {\n    return true;\n  }\n  return false;\n}\n\nstatic CURLcode\ncr_init_backend(struct Curl_easy *data, struct connectdata *conn,\n                struct ssl_backend_data *const backend)\n{\n  struct rustls_client_session *session = backend->session;\n  struct rustls_client_config_builder *config_builder = NULL;\n  const char *const ssl_cafile = SSL_CONN_CONFIG(CAfile);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char *hostname = conn->host.name;\n  char errorbuf[256];\n  size_t errorlen;\n  int result;\n  rustls_slice_bytes alpn[2] = {\n    { (const uint8_t *)ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH },\n    { (const uint8_t *)ALPN_H2, ALPN_H2_LENGTH },\n  };\n\n  backend->tlsbuf = calloc(TLSBUF_SIZE, 1);\n  if(!backend->tlsbuf) {\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  config_builder = rustls_client_config_builder_new();\n#ifdef USE_HTTP2\n  infof(data, \"offering ALPN for HTTP/1.1 and HTTP/2\\n\");\n  rustls_client_config_builder_set_protocols(config_builder, alpn, 2);\n#else\n  infof(data, \"offering ALPN for HTTP/1.1 only\\n\");\n  rustls_client_config_builder_set_protocols(config_builder, alpn, 1);\n#endif\n  if(!verifypeer) {\n    rustls_client_config_builder_dangerous_set_certificate_verifier(\n      config_builder, cr_verify_none, NULL);\n    /* rustls doesn't support IP addresses (as of 0.19.0), and will reject\n     * sessions created with an IP address, even when certificate verification\n     * is turned off. Set a placeholder hostname and disable SNI. */\n    if(cr_hostname_is_ip(hostname)) {\n      rustls_client_config_builder_set_enable_sni(config_builder, false);\n      hostname = \"example.invalid\";\n    }\n  }\n  else if(ssl_cafile) {\n    result = rustls_client_config_builder_load_roots_from_file(\n      config_builder, ssl_cafile);\n    if(result != RUSTLS_RESULT_OK) {\n      failf(data, \"failed to load trusted certificates\");\n      rustls_client_config_free(\n        rustls_client_config_builder_build(config_builder));\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else {\n    result = rustls_client_config_builder_load_native_roots(config_builder);\n    if(result != RUSTLS_RESULT_OK) {\n      failf(data, \"failed to load trusted certificates\");\n      rustls_client_config_free(\n        rustls_client_config_builder_build(config_builder));\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  backend->config = rustls_client_config_builder_build(config_builder);\n  DEBUGASSERT(session == NULL);\n  result = rustls_client_session_new(\n    backend->config, hostname, &session);\n  if(result != RUSTLS_RESULT_OK) {\n    rustls_error(result, errorbuf, sizeof(errorbuf), &errorlen);\n    failf(data, \"failed to create client session: %.*s\", errorlen, errorbuf);\n    return CURLE_COULDNT_CONNECT;\n  }\n  backend->session = session;\n  return CURLE_OK;\n}\n\nstatic void\ncr_set_negotiated_alpn(struct Curl_easy *data, struct connectdata *conn,\n  const struct rustls_client_session *session)\n{\n  const uint8_t *protocol = NULL;\n  size_t len = 0;\n\n  rustls_client_session_get_alpn_protocol(session, &protocol, &len);\n  if(NULL == protocol) {\n    infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    return;\n  }\n\n#ifdef USE_HTTP2\n  if(len == ALPN_H2_LENGTH && 0 == memcmp(ALPN_H2, protocol, len)) {\n    infof(data, \"ALPN, negotiated h2\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_2;\n  }\n  else\n#endif\n  if(len == ALPN_HTTP_1_1_LENGTH &&\n      0 == memcmp(ALPN_HTTP_1_1, protocol, len)) {\n    infof(data, \"ALPN, negotiated http/1.1\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_1_1;\n  }\n  else {\n    infof(data, \"ALPN, negotiated an unrecognized protocol\\n\");\n  }\n\n  Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                      BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n}\n\nstatic CURLcode\ncr_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex, bool *done)\n{\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *session = NULL;\n  CURLcode tmperr = CURLE_OK;\n  int result;\n  int what;\n  bool wants_read;\n  bool wants_write;\n  curl_socket_t writefd;\n  curl_socket_t readfd;\n\n  if(ssl_connection_none == connssl->state) {\n    result = cr_init_backend(data, conn, connssl->backend);\n    if(result != CURLE_OK) {\n      return result;\n    }\n    connssl->state = ssl_connection_negotiating;\n  }\n\n  session = backend->session;\n\n  /* Read/write data until the handshake is done or the socket would block. */\n  for(;;) {\n    /*\n    * Connection has been established according to rustls. Set send/recv\n    * handlers, and update the state machine.\n    * This check has to come last because is_handshaking starts out false,\n    * then becomes true when we first write data, then becomes false again\n    * once the handshake is done.\n    */\n    if(!rustls_client_session_is_handshaking(session)) {\n      infof(data, \"Done handshaking\\n\");\n      /* Done with the handshake. Set up callbacks to send/receive data. */\n      connssl->state = ssl_connection_complete;\n\n      cr_set_negotiated_alpn(data, conn, session);\n\n      conn->recv[sockindex] = cr_recv;\n      conn->send[sockindex] = cr_send;\n      *done = TRUE;\n      return CURLE_OK;\n    }\n\n    wants_read = rustls_client_session_wants_read(session);\n    wants_write = rustls_client_session_wants_write(session);\n    DEBUGASSERT(wants_read || wants_write);\n    writefd = wants_write?sockfd:CURL_SOCKET_BAD;\n    readfd = wants_read?sockfd:CURL_SOCKET_BAD;\n\n    what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd, 0);\n    if(what < 0) {\n      /* fatal error */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    if(0 == what) {\n      infof(data, \"Curl_socket_check: %s would block\\n\",\n          wants_read&&wants_write ?\n            \"writing and reading\" :\n            wants_write ?\n              \"writing\" :\n              \"reading\");\n      *done = FALSE;\n      return CURLE_OK;\n    }\n    /* socket is readable or writable */\n\n    if(wants_write) {\n      infof(data, \"ClientSession wants us to write_tls.\\n\");\n      cr_send(data, sockindex, NULL, 0, &tmperr);\n      if(tmperr == CURLE_AGAIN) {\n        infof(data, \"writing would block\\n\");\n        /* fall through */\n      }\n      else if(tmperr != CURLE_OK) {\n        return tmperr;\n      }\n    }\n\n    if(wants_read) {\n      infof(data, \"ClientSession wants us to read_tls.\\n\");\n\n      cr_recv(data, sockindex, NULL, 0, &tmperr);\n      if(tmperr == CURLE_AGAIN) {\n        infof(data, \"reading would block\\n\");\n        /* fall through */\n      }\n      else if(tmperr != CURLE_OK) {\n        if(tmperr == CURLE_READ_ERROR) {\n          return CURLE_SSL_CONNECT_ERROR;\n        }\n        else {\n          return tmperr;\n        }\n      }\n    }\n  }\n\n  /* We should never fall through the loop. We should return either because\n     the handshake is done or because we can't read/write without blocking. */\n  DEBUGASSERT(false);\n}\n\n/* returns a bitmap of flags for this connection's first socket indicating\n   whether we want to read or write */\nstatic int\ncr_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  struct ssl_connect_data *const connssl = &conn->ssl[FIRSTSOCKET];\n  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *session = backend->session;\n\n  if(rustls_client_session_wants_write(session)) {\n    socks[0] = sockfd;\n    return GETSOCK_WRITESOCK(0);\n  }\n  if(rustls_client_session_wants_read(session)) {\n    socks[0] = sockfd;\n    return GETSOCK_READSOCK(0);\n  }\n\n  return GETSOCK_BLANK;\n}\n\nstatic void *\ncr_get_internals(struct ssl_connect_data *connssl,\n                 CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  return &backend->session;\n}\n\nstatic void\ncr_close(struct Curl_easy *data, struct connectdata *conn,\n         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode tmperr = CURLE_OK;\n  ssize_t n = 0;\n\n  if(backend->session) {\n    rustls_client_session_send_close_notify(backend->session);\n    n = cr_send(data, sockindex, NULL, 0, &tmperr);\n    if(n < 0) {\n      failf(data, \"error sending close notify: %d\", tmperr);\n    }\n\n    rustls_client_session_free(backend->session);\n    backend->session = NULL;\n  }\n  if(backend->config) {\n    rustls_client_config_free(backend->config);\n    backend->config = NULL;\n  }\n  free(backend->tlsbuf);\n}\n\nconst struct Curl_ssl Curl_ssl_rustls = {\n  { CURLSSLBACKEND_RUSTLS, \"rustls\" },\n  SSLSUPP_TLS13_CIPHERSUITES,      /* supports */\n  sizeof(struct ssl_backend_data),\n\n  Curl_none_init,                  /* init */\n  Curl_none_cleanup,               /* cleanup */\n  rustls_version,                  /* version */\n  Curl_none_check_cxn,             /* check_cxn */\n  Curl_none_shutdown,              /* shutdown */\n  cr_data_pending,                 /* data_pending */\n  Curl_none_random,                /* random */\n  Curl_none_cert_status_request,   /* cert_status_request */\n  cr_connect,                      /* connect */\n  cr_connect_nonblocking,          /* connect_nonblocking */\n  cr_getsock,                      /* cr_getsock */\n  cr_get_internals,                /* get_internals */\n  cr_close,                        /* close_one */\n  Curl_none_close_all,             /* close_all */\n  Curl_none_session_free,          /* session_free */\n  Curl_none_set_engine,            /* set_engine */\n  Curl_none_set_engine_default,    /* set_engine_default */\n  Curl_none_engines_list,          /* engines_list */\n  Curl_none_false_start,           /* false_start */\n  NULL                             /* sha256sum */\n};\n\n#endif /* USE_RUSTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2016, Marc Hoersken, <info@marc-hoersken.de>\n * Copyright (C) 2012, Mark Salisbury, <mark.salisbury@hp.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all Schannel-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#define EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifndef USE_WINDOWS_SSPI\n#  error \"Can't compile SCHANNEL support without SSPI.\"\n#endif\n\n#include \"schannel.h\"\n#include \"vtls.h\"\n#include \"strcase.h\"\n#include \"sendf.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"strerror.h\"\n#include \"select.h\" /* for the socket readiness */\n#include \"inet_pton.h\" /* for IP addr SNI check */\n#include \"curl_multibyte.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n#include \"version_win32.h\"\n\n/* The last #include file should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* ALPN requires version 8.1 of the Windows SDK, which was\n   shipped with Visual Studio 2013, aka _MSC_VER 1800:\n\n   https://technet.microsoft.com/en-us/library/hh831771%28v=ws.11%29.aspx\n*/\n#if defined(_MSC_VER) && (_MSC_VER >= 1800) && !defined(_USING_V110_SDK71_)\n#  define HAS_ALPN 1\n#endif\n\n#ifndef UNISP_NAME_A\n#define UNISP_NAME_A \"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME_W\n#define UNISP_NAME_W L\"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME\n#ifdef UNICODE\n#define UNISP_NAME  UNISP_NAME_W\n#else\n#define UNISP_NAME  UNISP_NAME_A\n#endif\n#endif\n\n#if defined(CryptStringToBinary) && defined(CRYPT_STRING_HEX)\n#define HAS_CLIENT_CERT_PATH\n#endif\n\n#ifdef HAS_CLIENT_CERT_PATH\n#ifdef UNICODE\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_W\n#else\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_A\n#endif\n#endif\n\n#ifndef SP_PROT_SSL2_CLIENT\n#define SP_PROT_SSL2_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_SSL3_CLIENT\n#define SP_PROT_SSL3_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_TLS1_CLIENT\n#define SP_PROT_TLS1_CLIENT             0x00000080\n#endif\n\n#ifndef SP_PROT_TLS1_0_CLIENT\n#define SP_PROT_TLS1_0_CLIENT           SP_PROT_TLS1_CLIENT\n#endif\n\n#ifndef SP_PROT_TLS1_1_CLIENT\n#define SP_PROT_TLS1_1_CLIENT           0x00000200\n#endif\n\n#ifndef SP_PROT_TLS1_2_CLIENT\n#define SP_PROT_TLS1_2_CLIENT           0x00000800\n#endif\n\n#ifndef SCH_USE_STRONG_CRYPTO\n#define SCH_USE_STRONG_CRYPTO           0x00400000\n#endif\n\n#ifndef SECBUFFER_ALERT\n#define SECBUFFER_ALERT                 17\n#endif\n\n/* Both schannel buffer sizes must be > 0 */\n#define CURL_SCHANNEL_BUFFER_INIT_SIZE   4096\n#define CURL_SCHANNEL_BUFFER_FREE_SIZE   1024\n\n#define CERT_THUMBPRINT_STR_LEN 40\n#define CERT_THUMBPRINT_DATA_LEN 20\n\n/* Uncomment to force verbose output\n * #define infof(x, y, ...) printf(y, __VA_ARGS__)\n * #define failf(x, y, ...) printf(y, __VA_ARGS__)\n */\n\n#ifndef CALG_SHA_256\n#  define CALG_SHA_256 0x0000800c\n#endif\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv schannel_recv;\nstatic Curl_send schannel_send;\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey);\n\nstatic void InitSecBuffer(SecBuffer *buffer, unsigned long BufType,\n                          void *BufDataPtr, unsigned long BufByteSize)\n{\n  buffer->cbBuffer = BufByteSize;\n  buffer->BufferType = BufType;\n  buffer->pvBuffer = BufDataPtr;\n}\n\nstatic void InitSecBufferDesc(SecBufferDesc *desc, SecBuffer *BufArr,\n                              unsigned long NumArrElem)\n{\n  desc->ulVersion = SECBUFFER_VERSION;\n  desc->pBuffers = BufArr;\n  desc->cBuffers = NumArrElem;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(SCHANNEL_CRED *schannel_cred, struct Curl_easy *data,\n                        struct connectdata *conn)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n\n  switch(ssl_version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n    case CURL_SSLVERSION_TLSv1_0:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_0_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_1_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_2_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_3:\n      failf(data, \"schannel: TLS 1.3 is not yet supported\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  return CURLE_OK;\n}\n\n/*longest is 26, buffer is slightly bigger*/\n#define LONGEST_ALG_ID 32\n#define CIPHEROPTION(X)                         \\\n  if(strcmp(#X, tmp) == 0)                      \\\n    return X\n\nstatic int\nget_alg_id_by_name(char *name)\n{\n  char tmp[LONGEST_ALG_ID] = { 0 };\n  char *nameEnd = strchr(name, ':');\n  size_t n = nameEnd ? min((size_t)(nameEnd - name), LONGEST_ALG_ID - 1) : \\\n    min(strlen(name), LONGEST_ALG_ID - 1);\n  strncpy(tmp, name, n);\n  tmp[n] = 0;\n  CIPHEROPTION(CALG_MD2);\n  CIPHEROPTION(CALG_MD4);\n  CIPHEROPTION(CALG_MD5);\n  CIPHEROPTION(CALG_SHA);\n  CIPHEROPTION(CALG_SHA1);\n  CIPHEROPTION(CALG_MAC);\n  CIPHEROPTION(CALG_RSA_SIGN);\n  CIPHEROPTION(CALG_DSS_SIGN);\n/*ifdefs for the options that are defined conditionally in wincrypt.h*/\n#ifdef CALG_NO_SIGN\n  CIPHEROPTION(CALG_NO_SIGN);\n#endif\n  CIPHEROPTION(CALG_RSA_KEYX);\n  CIPHEROPTION(CALG_DES);\n#ifdef CALG_3DES_112\n  CIPHEROPTION(CALG_3DES_112);\n#endif\n  CIPHEROPTION(CALG_3DES);\n  CIPHEROPTION(CALG_DESX);\n  CIPHEROPTION(CALG_RC2);\n  CIPHEROPTION(CALG_RC4);\n  CIPHEROPTION(CALG_SEAL);\n#ifdef CALG_DH_SF\n  CIPHEROPTION(CALG_DH_SF);\n#endif\n  CIPHEROPTION(CALG_DH_EPHEM);\n#ifdef CALG_AGREEDKEY_ANY\n  CIPHEROPTION(CALG_AGREEDKEY_ANY);\n#endif\n#ifdef CALG_HUGHES_MD5\n  CIPHEROPTION(CALG_HUGHES_MD5);\n#endif\n  CIPHEROPTION(CALG_SKIPJACK);\n#ifdef CALG_TEK\n  CIPHEROPTION(CALG_TEK);\n#endif\n  CIPHEROPTION(CALG_CYLINK_MEK);\n  CIPHEROPTION(CALG_SSL3_SHAMD5);\n#ifdef CALG_SSL3_MASTER\n  CIPHEROPTION(CALG_SSL3_MASTER);\n#endif\n#ifdef CALG_SCHANNEL_MASTER_HASH\n  CIPHEROPTION(CALG_SCHANNEL_MASTER_HASH);\n#endif\n#ifdef CALG_SCHANNEL_MAC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_MAC_KEY);\n#endif\n#ifdef CALG_SCHANNEL_ENC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_ENC_KEY);\n#endif\n#ifdef CALG_PCT1_MASTER\n  CIPHEROPTION(CALG_PCT1_MASTER);\n#endif\n#ifdef CALG_SSL2_MASTER\n  CIPHEROPTION(CALG_SSL2_MASTER);\n#endif\n#ifdef CALG_TLS1_MASTER\n  CIPHEROPTION(CALG_TLS1_MASTER);\n#endif\n#ifdef CALG_RC5\n  CIPHEROPTION(CALG_RC5);\n#endif\n#ifdef CALG_HMAC\n  CIPHEROPTION(CALG_HMAC);\n#endif\n#if !defined(__W32API_MAJOR_VERSION) ||                                 \\\n  !defined(__W32API_MINOR_VERSION) ||                                   \\\n  defined(__MINGW64_VERSION_MAJOR) ||                                   \\\n  (__W32API_MAJOR_VERSION > 5)     ||                                   \\\n  ((__W32API_MAJOR_VERSION == 5) && (__W32API_MINOR_VERSION > 0))\n  /* CALG_TLS1PRF has a syntax error in MinGW's w32api up to version 5.0,\n     see https://osdn.net/projects/mingw/ticket/38391 */\n  CIPHEROPTION(CALG_TLS1PRF);\n#endif\n#ifdef CALG_HASH_REPLACE_OWF\n  CIPHEROPTION(CALG_HASH_REPLACE_OWF);\n#endif\n#ifdef CALG_AES_128\n  CIPHEROPTION(CALG_AES_128);\n#endif\n#ifdef CALG_AES_192\n  CIPHEROPTION(CALG_AES_192);\n#endif\n#ifdef CALG_AES_256\n  CIPHEROPTION(CALG_AES_256);\n#endif\n#ifdef CALG_AES\n  CIPHEROPTION(CALG_AES);\n#endif\n#ifdef CALG_SHA_256\n  CIPHEROPTION(CALG_SHA_256);\n#endif\n#ifdef CALG_SHA_384\n  CIPHEROPTION(CALG_SHA_384);\n#endif\n#ifdef CALG_SHA_512\n  CIPHEROPTION(CALG_SHA_512);\n#endif\n#ifdef CALG_ECDH\n  CIPHEROPTION(CALG_ECDH);\n#endif\n#ifdef CALG_ECMQV\n  CIPHEROPTION(CALG_ECMQV);\n#endif\n#ifdef CALG_ECDSA\n  CIPHEROPTION(CALG_ECDSA);\n#endif\n#ifdef CALG_ECDH_EPHEM\n  CIPHEROPTION(CALG_ECDH_EPHEM);\n#endif\n  return 0;\n}\n\nstatic CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                int *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}\n\n#ifdef HAS_CLIENT_CERT_PATH\n\n/* Function allocates memory for store_path only if CURLE_OK is returned */\nstatic CURLcode\nget_cert_location(TCHAR *path, DWORD *store_name, TCHAR **store_path,\n                  TCHAR **thumbprint)\n{\n  TCHAR *sep;\n  TCHAR *store_path_start;\n  size_t store_name_len;\n\n  sep = _tcschr(path, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_name_len = sep - path;\n\n  if(_tcsnccmp(path, TEXT(\"CurrentUser\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachine\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE;\n  else if(_tcsnccmp(path, TEXT(\"CurrentService\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_SERVICE;\n  else if(_tcsnccmp(path, TEXT(\"Services\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_SERVICES;\n  else if(_tcsnccmp(path, TEXT(\"Users\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_USERS;\n  else if(_tcsnccmp(path, TEXT(\"CurrentUserGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineEnterprise\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;\n  else\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_path_start = sep + 1;\n\n  sep = _tcschr(store_path_start, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *thumbprint = sep + 1;\n  if(_tcslen(*thumbprint) != CERT_THUMBPRINT_STR_LEN)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *sep = TEXT('\\0');\n  *store_path = _tcsdup(store_path_start);\n  *sep = TEXT('\\\\');\n  if(!*store_path)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}\n#endif\n\nstatic CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  int i;\n  ssize_t nread = -1, written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  SecBuffer outbuf[3];\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf[2];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n  bool doread;\n  char * const hostname = SSL_HOST_NAME();\n  const char *pubkey_ptr;\n\n  doread = (connssl->connecting_state != ssl_connect_2_writing) ? TRUE : FALSE;\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 2/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred || !BACKEND->ctxt)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* buffer to store previously received and decrypted data */\n  if(!BACKEND->decdata_buffer) {\n    BACKEND->decdata_offset = 0;\n    BACKEND->decdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->decdata_buffer = malloc(BACKEND->decdata_length);\n    if(!BACKEND->decdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* buffer to store previously received and encrypted data */\n  if(!BACKEND->encdata_buffer) {\n    BACKEND->encdata_is_incomplete = false;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->encdata_buffer = malloc(BACKEND->encdata_length);\n    if(!BACKEND->encdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* if we need a bigger buffer to read a full message, increase buffer now */\n  if(BACKEND->encdata_length - BACKEND->encdata_offset <\n     CURL_SCHANNEL_BUFFER_FREE_SIZE) {\n    /* increase internal encrypted data buffer */\n    size_t reallocated_length = BACKEND->encdata_offset +\n      CURL_SCHANNEL_BUFFER_FREE_SIZE;\n    reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                 reallocated_length);\n\n    if(!reallocated_buffer) {\n      failf(data, \"schannel: unable to re-allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n    }\n  }\n\n  for(;;) {\n    TCHAR *host_name;\n    if(doread) {\n      /* read encrypted handshake data from socket */\n      result = Curl_read_plain(conn->sock[sockindex],\n                               (char *) (BACKEND->encdata_buffer +\n                                         BACKEND->encdata_offset),\n                               BACKEND->encdata_length -\n                               BACKEND->encdata_offset,\n                               &nread);\n      if(result == CURLE_AGAIN) {\n        if(connssl->connecting_state != ssl_connect_2_writing)\n          connssl->connecting_state = ssl_connect_2_reading;\n        DEBUGF(infof(data, \"schannel: failed to receive handshake, \"\n                     \"need more data\\n\"));\n        return CURLE_OK;\n      }\n      else if((result != CURLE_OK) || (nread == 0)) {\n        failf(data, \"schannel: failed to receive handshake, \"\n              \"SSL/TLS connection failed\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      /* increase encrypted data buffer offset */\n      BACKEND->encdata_offset += nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* setup input buffers */\n    InitSecBuffer(&inbuf[0], SECBUFFER_TOKEN, malloc(BACKEND->encdata_offset),\n                  curlx_uztoul(BACKEND->encdata_offset));\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 2);\n\n    /* setup output buffers */\n    InitSecBuffer(&outbuf[0], SECBUFFER_TOKEN, NULL, 0);\n    InitSecBuffer(&outbuf[1], SECBUFFER_ALERT, NULL, 0);\n    InitSecBuffer(&outbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, outbuf, 3);\n\n    if(!inbuf[0].pvBuffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    /* copy received handshake data into input buffer */\n    memcpy(inbuf[0].pvBuffer, BACKEND->encdata_buffer,\n           BACKEND->encdata_offset);\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n     */\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle, &BACKEND->ctxt->ctxt_handle,\n      host_name, BACKEND->req_flags, 0, 0, &inbuf_desc, 0, NULL,\n      &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    /* free buffer for received handshake data */\n    Curl_safefree(inbuf[0].pvBuffer);\n\n    /* check if the handshake was incomplete */\n    if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      connssl->connecting_state = ssl_connect_2_reading;\n      DEBUGF(infof(data,\n                   \"schannel: received incomplete message, need more data\\n\"));\n      return CURLE_OK;\n    }\n\n    /* If the server has requested a client certificate, attempt to continue\n       the handshake without one. This will allow connections to servers which\n       request a client certificate but do not require it. */\n    if(sspi_status == SEC_I_INCOMPLETE_CREDENTIALS &&\n       !(BACKEND->req_flags & ISC_REQ_USE_SUPPLIED_CREDS)) {\n      BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n      connssl->connecting_state = ssl_connect_2_writing;\n      DEBUGF(infof(data,\n                   \"schannel: a client certificate has been requested\\n\"));\n      return CURLE_OK;\n    }\n\n    /* check if the handshake needs to be continued */\n    if(sspi_status == SEC_I_CONTINUE_NEEDED || sspi_status == SEC_E_OK) {\n      for(i = 0; i < 3; i++) {\n        /* search for handshake tokens that need to be send */\n        if(outbuf[i].BufferType == SECBUFFER_TOKEN && outbuf[i].cbBuffer > 0) {\n          DEBUGF(infof(data, \"schannel: sending next handshake data: \"\n                       \"sending %lu bytes...\\n\", outbuf[i].cbBuffer));\n\n          /* send handshake token to server */\n          result = Curl_write_plain(data, conn->sock[sockindex],\n                                    outbuf[i].pvBuffer, outbuf[i].cbBuffer,\n                                    &written);\n          if((result != CURLE_OK) ||\n             (outbuf[i].cbBuffer != (size_t) written)) {\n            failf(data, \"schannel: failed to send next handshake data: \"\n                  \"sent %zd of %lu bytes\", written, outbuf[i].cbBuffer);\n            return CURLE_SSL_CONNECT_ERROR;\n          }\n        }\n\n        /* free obsolete buffer */\n        if(outbuf[i].pvBuffer != NULL) {\n          s_pSecFn->FreeContextBuffer(outbuf[i].pvBuffer);\n        }\n      }\n    }\n    else {\n      char buffer[STRERROR_LEN];\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_WRONG_PRINCIPAL:\n        failf(data, \"schannel: SNI or certificate check failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case SEC_E_UNTRUSTED_ROOT:\n        failf(data, \"schannel: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n        /*\n          case SEC_E_INVALID_HANDLE:\n          case SEC_E_INVALID_TOKEN:\n          case SEC_E_LOGON_DENIED:\n          case SEC_E_TARGET_UNKNOWN:\n          case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n          case SEC_E_INTERNAL_ERROR:\n          case SEC_E_NO_CREDENTIALS:\n          case SEC_E_UNSUPPORTED_FUNCTION:\n          case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n        */\n      default:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n\n    /* check if there was additional remaining encrypted data */\n    if(inbuf[1].BufferType == SECBUFFER_EXTRA && inbuf[1].cbBuffer > 0) {\n      DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                   inbuf[1].cbBuffer));\n      /*\n        There are two cases where we could be getting extra data here:\n        1) If we're renegotiating a connection and the handshake is already\n        complete (from the server perspective), it can encrypted app data\n        (not handshake data) in an extra buffer at this point.\n        2) (sspi_status == SEC_I_CONTINUE_NEEDED) We are negotiating a\n        connection and this extra data is part of the handshake.\n        We should process the data immediately; waiting for the socket to\n        be ready may fail since the server is done sending handshake data.\n      */\n      /* check if the remaining data is less than the total amount\n         and therefore begins after the already processed data */\n      if(BACKEND->encdata_offset > inbuf[1].cbBuffer) {\n        memmove(BACKEND->encdata_buffer,\n                (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                inbuf[1].cbBuffer, inbuf[1].cbBuffer);\n        BACKEND->encdata_offset = inbuf[1].cbBuffer;\n        if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n          doread = FALSE;\n          continue;\n        }\n      }\n    }\n    else {\n      BACKEND->encdata_offset = 0;\n    }\n    break;\n  }\n\n  /* check if the handshake needs to be continued */\n  if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n\n  /* check if the handshake is complete */\n  if(sspi_status == SEC_E_OK) {\n    connssl->connecting_state = ssl_connect_3;\n    DEBUGF(infof(data, \"schannel: SSL/TLS handshake complete\\n\"));\n  }\n\n  pubkey_ptr = SSL_PINNED_PUB_KEY();\n  if(pubkey_ptr) {\n    result = pkp_pin_peer_pubkey(data, conn, sockindex, pubkey_ptr);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n#ifdef HAS_MANUAL_VERIFY_API\n  if(conn->ssl_config.verifypeer && BACKEND->use_manual_cred_validation) {\n    return Curl_verify_certificate(data, conn, sockindex);\n  }\n#endif\n\n  return CURLE_OK;\n}\n\nstatic bool\nvalid_cert_encoding(const CERT_CONTEXT *cert_context)\n{\n  return (cert_context != NULL) &&\n    ((cert_context->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n    (cert_context->pbCertEncoded != NULL) &&\n    (cert_context->cbCertEncoded > 0);\n}\n\ntypedef bool(*Read_crt_func)(const CERT_CONTEXT *ccert_context, void *arg);\n\nstatic void\ntraverse_cert_store(const CERT_CONTEXT *context, Read_crt_func func,\n                    void *arg)\n{\n  const CERT_CONTEXT *current_context = NULL;\n  bool should_continue = true;\n  while(should_continue &&\n        (current_context = CertEnumCertificatesInStore(\n          context->hCertStore,\n          current_context)) != NULL)\n    should_continue = func(current_context, arg);\n\n  if(current_context)\n    CertFreeCertificateContext(current_context);\n}\n\nstatic bool\ncert_counter_callback(const CERT_CONTEXT *ccert_context, void *certs_count)\n{\n  if(valid_cert_encoding(ccert_context))\n    (*(int *)certs_count)++;\n  return true;\n}\n\nstruct Adder_args\n{\n  struct Curl_easy *data;\n  CURLcode result;\n  int idx;\n  int certs_count;\n};\n\nstatic bool\nadd_cert_to_certinfo(const CERT_CONTEXT *ccert_context, void *raw_arg)\n{\n  struct Adder_args *args = (struct Adder_args*)raw_arg;\n  args->result = CURLE_OK;\n  if(valid_cert_encoding(ccert_context)) {\n    const char *beg = (const char *) ccert_context->pbCertEncoded;\n    const char *end = beg + ccert_context->cbCertEncoded;\n    int insert_index = (args->certs_count - 1) - args->idx;\n    args->result = Curl_extract_certinfo(args->data, insert_index,\n                                         beg, end);\n    args->idx++;\n  }\n  return args->result == CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CERT_CONTEXT *ccert_context = NULL;\n  bool isproxy = SSL_IS_PROXY();\n#ifdef DEBUGBUILD\n  const char * const hostname = SSL_HOST_NAME();\n#endif\n#ifdef HAS_ALPN\n  SecPkgContext_ApplicationProtocol alpn_result;\n#endif\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 3/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* check if the required context attributes are met */\n  if(BACKEND->ret_flags != BACKEND->req_flags) {\n    if(!(BACKEND->ret_flags & ISC_RET_SEQUENCE_DETECT))\n      failf(data, \"schannel: failed to setup sequence detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_REPLAY_DETECT))\n      failf(data, \"schannel: failed to setup replay detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_CONFIDENTIALITY))\n      failf(data, \"schannel: failed to setup confidentiality\");\n    if(!(BACKEND->ret_flags & ISC_RET_ALLOCATED_MEMORY))\n      failf(data, \"schannel: failed to setup memory allocation\");\n    if(!(BACKEND->ret_flags & ISC_RET_STREAM))\n      failf(data, \"schannel: failed to setup stream orientation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_APPLICATION_PROTOCOL,\n                                       &alpn_result);\n\n    if(sspi_status != SEC_E_OK) {\n      failf(data, \"schannel: failed to retrieve ALPN result\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(alpn_result.ProtoNegoStatus ==\n       SecApplicationProtocolNegotiationStatus_Success) {\n\n      infof(data, \"schannel: ALPN, server accepted to use %.*s\\n\",\n            alpn_result.ProtocolIdSize, alpn_result.ProtocolId);\n\n#ifdef USE_HTTP2\n      if(alpn_result.ProtocolIdSize == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, alpn_result.ProtocolId, ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(alpn_result.ProtocolIdSize == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, alpn_result.ProtocolId,\n                   ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  /* save the current session data for possible re-use */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    struct Curl_schannel_cred *old_cred = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy, (void **)&old_cred,\n                                      NULL, sockindex));\n    if(incache) {\n      if(old_cred != BACKEND->cred) {\n        DEBUGF(infof(data,\n                     \"schannel: old credential handle is stale, removing\\n\"));\n        /* we're not taking old_cred ownership here, no refcount++ is needed */\n        Curl_ssl_delsessionid(data, (void *)old_cred);\n        incache = FALSE;\n      }\n    }\n    if(!incache) {\n      result = Curl_ssl_addsessionid(data, conn, isproxy, BACKEND->cred,\n                                     sizeof(struct Curl_schannel_cred),\n                                     sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"schannel: failed to store credential handle\");\n        return result;\n      }\n      else {\n        /* this cred session is now also referenced by sessionid cache */\n        BACKEND->cred->refcount++;\n        DEBUGF(infof(data,\n                     \"schannel: stored credential handle in session cache\\n\"));\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(data->set.ssl.certinfo) {\n    int certs_count = 0;\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &ccert_context);\n\n    if((sspi_status != SEC_E_OK) || !ccert_context) {\n      failf(data, \"schannel: failed to retrieve remote cert context\");\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n\n    traverse_cert_store(ccert_context, cert_counter_callback, &certs_count);\n\n    result = Curl_ssl_init_certinfo(data, certs_count);\n    if(!result) {\n      struct Adder_args args;\n      args.data = data;\n      args.idx = 0;\n      args.certs_count = certs_count;\n      traverse_cert_store(ccert_context, add_cert_to_certinfo, &args);\n      result = args.result;\n    }\n    CertFreeCertificateContext(ccert_context);\n    if(result)\n      return result;\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = schannel_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL/TLS socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL/TLS connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = schannel_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = schannel_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = schannel_recv;\n    conn->send[sockindex] = schannel_send;\n\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n    /* When SSPI is used in combination with Schannel\n     * we need the Schannel context to create the Schannel\n     * binding to pass the IIS extended protection checks.\n     * Available on Windows 7 or later.\n     */\n    conn->sslContext = &BACKEND->ctxt->ctxt_handle;\n#endif\n\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* reset our connection state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t\nschannel_send(struct Curl_easy *data, int sockindex,\n              const void *buf, size_t len, CURLcode *err)\n{\n  ssize_t written = -1;\n  size_t data_len = 0;\n  unsigned char *ptr = NULL;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf[4];\n  SecBufferDesc outbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n\n  /* check if the maximum stream sizes were queried */\n  if(BACKEND->stream_sizes.cbMaximumMessage == 0) {\n    sspi_status = s_pSecFn->QueryContextAttributes(\n      &BACKEND->ctxt->ctxt_handle,\n      SECPKG_ATTR_STREAM_SIZES,\n      &BACKEND->stream_sizes);\n    if(sspi_status != SEC_E_OK) {\n      *err = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n\n  /* check if the buffer is longer than the maximum message length */\n  if(len > BACKEND->stream_sizes.cbMaximumMessage) {\n    len = BACKEND->stream_sizes.cbMaximumMessage;\n  }\n\n  /* calculate the complete message length and allocate a buffer for it */\n  data_len = BACKEND->stream_sizes.cbHeader + len +\n    BACKEND->stream_sizes.cbTrailer;\n  ptr = (unsigned char *) malloc(data_len);\n  if(!ptr) {\n    *err = CURLE_OUT_OF_MEMORY;\n    return -1;\n  }\n\n  /* setup output buffers (header, data, trailer, empty) */\n  InitSecBuffer(&outbuf[0], SECBUFFER_STREAM_HEADER,\n                ptr, BACKEND->stream_sizes.cbHeader);\n  InitSecBuffer(&outbuf[1], SECBUFFER_DATA,\n                ptr + BACKEND->stream_sizes.cbHeader, curlx_uztoul(len));\n  InitSecBuffer(&outbuf[2], SECBUFFER_STREAM_TRAILER,\n                ptr + BACKEND->stream_sizes.cbHeader + len,\n                BACKEND->stream_sizes.cbTrailer);\n  InitSecBuffer(&outbuf[3], SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, outbuf, 4);\n\n  /* copy data into output buffer */\n  memcpy(outbuf[1].pvBuffer, buf, len);\n\n  /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375390.aspx */\n  sspi_status = s_pSecFn->EncryptMessage(&BACKEND->ctxt->ctxt_handle, 0,\n                                         &outbuf_desc, 0);\n\n  /* check if the message was encrypted */\n  if(sspi_status == SEC_E_OK) {\n    written = 0;\n\n    /* send the encrypted message including header, data and trailer */\n    len = outbuf[0].cbBuffer + outbuf[1].cbBuffer + outbuf[2].cbBuffer;\n\n    /*\n      It's important to send the full message which includes the header,\n      encrypted payload, and trailer.  Until the client receives all the\n      data a coherent message has not been delivered and the client\n      can't read any of it.\n\n      If we wanted to buffer the unwritten encrypted bytes, we would\n      tell the client that all data it has requested to be sent has been\n      sent. The unwritten encrypted bytes would be the first bytes to\n      send on the next invocation.\n      Here's the catch with this - if we tell the client that all the\n      bytes have been sent, will the client call this method again to\n      send the buffered data?  Looking at who calls this function, it\n      seems the answer is NO.\n    */\n\n    /* send entire message or fail */\n    while(len > (size_t)written) {\n      ssize_t this_write = 0;\n      int what;\n      timediff_t timeout_ms = Curl_timeleft(data, NULL, FALSE);\n      if(timeout_ms < 0) {\n        /* we already got the timeout */\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      else if(!timeout_ms)\n        timeout_ms = TIMEDIFF_T_MAX;\n      what = SOCKET_WRITABLE(conn->sock[sockindex], timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        *err = CURLE_SEND_ERROR;\n        written = -1;\n        break;\n      }\n      else if(0 == what) {\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      /* socket is writable */\n\n      result = Curl_write_plain(data, conn->sock[sockindex], ptr + written,\n                                len - written, &this_write);\n      if(result == CURLE_AGAIN)\n        continue;\n      else if(result != CURLE_OK) {\n        *err = result;\n        written = -1;\n        break;\n      }\n\n      written += this_write;\n    }\n  }\n  else if(sspi_status == SEC_E_INSUFFICIENT_MEMORY) {\n    *err = CURLE_OUT_OF_MEMORY;\n  }\n  else{\n    *err = CURLE_SEND_ERROR;\n  }\n\n  Curl_safefree(ptr);\n\n  if(len == (size_t)written)\n    /* Encrypted message including header, data and trailer entirely sent.\n       The return value is the number of unencrypted bytes that were sent. */\n    written = outbuf[1].cbBuffer;\n\n  return written;\n}\n\nstatic ssize_t\nschannel_recv(struct Curl_easy *data, int sockindex,\n              char *buf, size_t len, CURLcode *err)\n{\n  size_t size = 0;\n  ssize_t nread = -1;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  size_t reallocated_length;\n  bool done = FALSE;\n  SecBuffer inbuf[4];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  /* we want the length of the encrypted buffer to be at least large enough\n     that it can hold all the bytes requested and some TLS record overhead. */\n  size_t min_encdata_length = len + CURL_SCHANNEL_BUFFER_FREE_SIZE;\n\n  /****************************************************************************\n   * Don't return or set BACKEND->recv_unrecoverable_err unless in the cleanup.\n   * The pattern for return error is set *err, optional infof, goto cleanup.\n   *\n   * Our priority is to always return as much decrypted data to the caller as\n   * possible, even if an error occurs. The state of the decrypted buffer must\n   * always be valid. Transfer of decrypted data to the caller's buffer is\n   * handled in the cleanup.\n   */\n\n  DEBUGF(infof(data, \"schannel: client wants to read %zu bytes\\n\", len));\n  *err = CURLE_OK;\n\n  if(len && len <= BACKEND->decdata_offset) {\n    infof(data, \"schannel: enough decrypted data is already available\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_unrecoverable_err) {\n    *err = BACKEND->recv_unrecoverable_err;\n    infof(data, \"schannel: an unrecoverable error occurred in a prior call\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_sspi_close_notify) {\n    /* once a server has indicated shutdown there is no more encrypted data */\n    infof(data, \"schannel: server indicated shutdown in a prior call\\n\");\n    goto cleanup;\n  }\n\n  /* It's debatable what to return when !len. Regardless we can't return\n     immediately because there may be data to decrypt (in the case we want to\n     decrypt all encrypted cached data) so handle !len later in cleanup.\n  */\n  else if(len && !BACKEND->recv_connection_closed) {\n    /* increase enc buffer in order to fit the requested amount of data */\n    size = BACKEND->encdata_length - BACKEND->encdata_offset;\n    if(size < CURL_SCHANNEL_BUFFER_FREE_SIZE ||\n       BACKEND->encdata_length < min_encdata_length) {\n      reallocated_length = BACKEND->encdata_offset +\n        CURL_SCHANNEL_BUFFER_FREE_SIZE;\n      if(reallocated_length < min_encdata_length) {\n        reallocated_length = min_encdata_length;\n      }\n      reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                   reallocated_length);\n      if(!reallocated_buffer) {\n        *err = CURLE_OUT_OF_MEMORY;\n        failf(data, \"schannel: unable to re-allocate memory\");\n        goto cleanup;\n      }\n\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n      size = BACKEND->encdata_length - BACKEND->encdata_offset;\n      DEBUGF(infof(data, \"schannel: encdata_buffer resized %zu\\n\",\n                   BACKEND->encdata_length));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* read encrypted data from socket */\n    *err = Curl_read_plain(conn->sock[sockindex],\n                           (char *)(BACKEND->encdata_buffer +\n                                    BACKEND->encdata_offset),\n                           size, &nread);\n    if(*err) {\n      nread = -1;\n      if(*err == CURLE_AGAIN)\n        DEBUGF(infof(data,\n                     \"schannel: Curl_read_plain returned CURLE_AGAIN\\n\"));\n      else if(*err == CURLE_RECV_ERROR)\n        infof(data, \"schannel: Curl_read_plain returned CURLE_RECV_ERROR\\n\");\n      else\n        infof(data, \"schannel: Curl_read_plain returned error %d\\n\", *err);\n    }\n    else if(nread == 0) {\n      BACKEND->recv_connection_closed = true;\n      DEBUGF(infof(data, \"schannel: server closed the connection\\n\"));\n    }\n    else if(nread > 0) {\n      BACKEND->encdata_offset += (size_t)nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  /* decrypt loop */\n  while(BACKEND->encdata_offset > 0 && sspi_status == SEC_E_OK &&\n        (!len || BACKEND->decdata_offset < len ||\n         BACKEND->recv_connection_closed)) {\n    /* prepare data buffer for DecryptMessage call */\n    InitSecBuffer(&inbuf[0], SECBUFFER_DATA, BACKEND->encdata_buffer,\n                  curlx_uztoul(BACKEND->encdata_offset));\n\n    /* we need 3 more empty input buffers for possible output */\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[3], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 4);\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375348.aspx\n     */\n    sspi_status = s_pSecFn->DecryptMessage(&BACKEND->ctxt->ctxt_handle,\n                                           &inbuf_desc, 0, NULL);\n\n    /* check if everything went fine (server may want to renegotiate\n       or shutdown the connection context) */\n    if(sspi_status == SEC_E_OK || sspi_status == SEC_I_RENEGOTIATE ||\n       sspi_status == SEC_I_CONTEXT_EXPIRED) {\n      /* check for successfully decrypted data, even before actual\n         renegotiation or shutdown of the connection context */\n      if(inbuf[1].BufferType == SECBUFFER_DATA) {\n        DEBUGF(infof(data, \"schannel: decrypted data length: %lu\\n\",\n                     inbuf[1].cbBuffer));\n\n        /* increase buffer in order to fit the received amount of data */\n        size = inbuf[1].cbBuffer > CURL_SCHANNEL_BUFFER_FREE_SIZE ?\n          inbuf[1].cbBuffer : CURL_SCHANNEL_BUFFER_FREE_SIZE;\n        if(BACKEND->decdata_length - BACKEND->decdata_offset < size ||\n           BACKEND->decdata_length < len) {\n          /* increase internal decrypted data buffer */\n          reallocated_length = BACKEND->decdata_offset + size;\n          /* make sure that the requested amount of data fits */\n          if(reallocated_length < len) {\n            reallocated_length = len;\n          }\n          reallocated_buffer = realloc(BACKEND->decdata_buffer,\n                                       reallocated_length);\n          if(!reallocated_buffer) {\n            *err = CURLE_OUT_OF_MEMORY;\n            failf(data, \"schannel: unable to re-allocate memory\");\n            goto cleanup;\n          }\n          BACKEND->decdata_buffer = reallocated_buffer;\n          BACKEND->decdata_length = reallocated_length;\n        }\n\n        /* copy decrypted data to internal buffer */\n        size = inbuf[1].cbBuffer;\n        if(size) {\n          memcpy(BACKEND->decdata_buffer + BACKEND->decdata_offset,\n                 inbuf[1].pvBuffer, size);\n          BACKEND->decdata_offset += size;\n        }\n\n        DEBUGF(infof(data, \"schannel: decrypted data added: %zu\\n\", size));\n        DEBUGF(infof(data,\n                     \"schannel: decrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->decdata_offset, BACKEND->decdata_length));\n      }\n\n      /* check for remaining encrypted data */\n      if(inbuf[3].BufferType == SECBUFFER_EXTRA && inbuf[3].cbBuffer > 0) {\n        DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                     inbuf[3].cbBuffer));\n\n        /* check if the remaining data is less than the total amount\n         * and therefore begins after the already processed data\n         */\n        if(BACKEND->encdata_offset > inbuf[3].cbBuffer) {\n          /* move remaining encrypted data forward to the beginning of\n             buffer */\n          memmove(BACKEND->encdata_buffer,\n                  (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                  inbuf[3].cbBuffer, inbuf[3].cbBuffer);\n          BACKEND->encdata_offset = inbuf[3].cbBuffer;\n        }\n\n        DEBUGF(infof(data,\n                     \"schannel: encrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->encdata_offset, BACKEND->encdata_length));\n      }\n      else {\n        /* reset encrypted buffer offset, because there is no data remaining */\n        BACKEND->encdata_offset = 0;\n      }\n\n      /* check if server wants to renegotiate the connection context */\n      if(sspi_status == SEC_I_RENEGOTIATE) {\n        infof(data, \"schannel: remote party requests renegotiation\\n\");\n        if(*err && *err != CURLE_AGAIN) {\n          infof(data, \"schannel: can't renogotiate, an error is pending\\n\");\n          goto cleanup;\n        }\n        if(BACKEND->encdata_offset) {\n          *err = CURLE_RECV_ERROR;\n          infof(data, \"schannel: can't renogotiate, \"\n                \"encrypted data available\\n\");\n          goto cleanup;\n        }\n        /* begin renegotiation */\n        infof(data, \"schannel: renegotiating SSL/TLS connection\\n\");\n        connssl->state = ssl_connection_negotiating;\n        connssl->connecting_state = ssl_connect_2_writing;\n        *err = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n        if(*err) {\n          infof(data, \"schannel: renegotiation failed\\n\");\n          goto cleanup;\n        }\n        /* now retry receiving data */\n        sspi_status = SEC_E_OK;\n        infof(data, \"schannel: SSL/TLS connection renegotiated\\n\");\n        continue;\n      }\n      /* check if the server closed the connection */\n      else if(sspi_status == SEC_I_CONTEXT_EXPIRED) {\n        /* In Windows 2000 SEC_I_CONTEXT_EXPIRED (close_notify) is not\n           returned so we have to work around that in cleanup. */\n        BACKEND->recv_sspi_close_notify = true;\n        if(!BACKEND->recv_connection_closed) {\n          BACKEND->recv_connection_closed = true;\n          infof(data, \"schannel: server closed the connection\\n\");\n        }\n        goto cleanup;\n      }\n    }\n    else if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      if(!*err)\n        *err = CURLE_AGAIN;\n      infof(data, \"schannel: failed to decrypt data, need more data\\n\");\n      goto cleanup;\n    }\n    else {\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      char buffer[STRERROR_LEN];\n#endif\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: failed to read data from server: %s\\n\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      goto cleanup;\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  DEBUGF(infof(data,\n               \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->decdata_offset, BACKEND->decdata_length));\n\n  cleanup:\n  /* Warning- there is no guarantee the encdata state is valid at this point */\n  DEBUGF(infof(data, \"schannel: schannel_recv cleanup\\n\"));\n\n  /* Error if the connection has closed without a close_notify.\n\n     The behavior here is a matter of debate. We don't want to be vulnerable\n     to a truncation attack however there's some browser precedent for\n     ignoring the close_notify for compatibility reasons.\n\n     Additionally, Windows 2000 (v5.0) is a special case since it seems it\n     doesn't return close_notify. In that case if the connection was closed we\n     assume it was graceful (close_notify) since there doesn't seem to be a\n     way to tell.\n  */\n  if(len && !BACKEND->decdata_offset && BACKEND->recv_connection_closed &&\n     !BACKEND->recv_sspi_close_notify) {\n    bool isWin2k = curlx_verify_windows_version(5, 0, PLATFORM_WINNT,\n                                                VERSION_EQUAL);\n\n    if(isWin2k && sspi_status == SEC_E_OK)\n      BACKEND->recv_sspi_close_notify = true;\n    else {\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: server closed abruptly (missing close_notify)\\n\");\n    }\n  }\n\n  /* Any error other than CURLE_AGAIN is an unrecoverable error. */\n  if(*err && *err != CURLE_AGAIN)\n    BACKEND->recv_unrecoverable_err = *err;\n\n  size = len < BACKEND->decdata_offset ? len : BACKEND->decdata_offset;\n  if(size) {\n    memcpy(buf, BACKEND->decdata_buffer, size);\n    memmove(BACKEND->decdata_buffer, BACKEND->decdata_buffer + size,\n            BACKEND->decdata_offset - size);\n    BACKEND->decdata_offset -= size;\n    DEBUGF(infof(data, \"schannel: decrypted data returned %zu\\n\", size));\n    DEBUGF(infof(data,\n                 \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->decdata_offset, BACKEND->decdata_length));\n    *err = CURLE_OK;\n    return (ssize_t)size;\n  }\n\n  if(!*err && !BACKEND->recv_connection_closed)\n    *err = CURLE_AGAIN;\n\n  /* It's debatable what to return when !len. We could return whatever error\n     we got from decryption but instead we override here so the return is\n     consistent.\n  */\n  if(!len)\n    *err = CURLE_OK;\n\n  return *err ? -1 : 0;\n}\n\nstatic CURLcode schannel_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  return schannel_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode schannel_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool schannel_data_pending(const struct connectdata *conn,\n                                  int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  if(connssl->use) /* SSL/TLS is in use */\n    return (BACKEND->decdata_offset > 0 ||\n            (BACKEND->encdata_offset > 0 && !BACKEND->encdata_is_incomplete));\n  else\n    return FALSE;\n}\n\nstatic void schannel_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(conn->ssl[sockindex].use)\n    /* if the SSL/TLS channel hasn't been shut down yet, do that now. */\n    Curl_ssl_shutdown(data, conn, sockindex);\n}\n\nstatic void schannel_session_free(void *ptr)\n{\n  /* this is expected to be called under sessionid lock */\n  struct Curl_schannel_cred *cred = ptr;\n\n  cred->refcount--;\n  if(cred->refcount == 0) {\n    s_pSecFn->FreeCredentialsHandle(&cred->cred_handle);\n    Curl_safefree(cred);\n  }\n}\n\nstatic int schannel_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  /* See https://msdn.microsoft.com/en-us/library/windows/desktop/aa380138.aspx\n   * Shutting Down an Schannel Connection\n   */\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(data);\n\n  infof(data, \"schannel: shutting down SSL/TLS connection with %s port %hu\\n\",\n        hostname, conn->remote_port);\n\n  if(BACKEND->cred && BACKEND->ctxt) {\n    SecBufferDesc BuffDesc;\n    SecBuffer Buffer;\n    SECURITY_STATUS sspi_status;\n    SecBuffer outbuf;\n    SecBufferDesc outbuf_desc;\n    CURLcode result;\n    TCHAR *host_name;\n    DWORD dwshut = SCHANNEL_SHUTDOWN;\n\n    InitSecBuffer(&Buffer, SECBUFFER_TOKEN, &dwshut, sizeof(dwshut));\n    InitSecBufferDesc(&BuffDesc, &Buffer, 1);\n\n    sspi_status = s_pSecFn->ApplyControlToken(&BACKEND->ctxt->ctxt_handle,\n                                              &BuffDesc);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: ApplyControlToken failure: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n    }\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* setup output buffer */\n    InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle,\n      &BACKEND->ctxt->ctxt_handle,\n      host_name,\n      BACKEND->req_flags,\n      0,\n      0,\n      NULL,\n      0,\n      &BACKEND->ctxt->ctxt_handle,\n      &outbuf_desc,\n      &BACKEND->ret_flags,\n      &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    if((sspi_status == SEC_E_OK) || (sspi_status == SEC_I_CONTEXT_EXPIRED)) {\n      /* send close message which is in output buffer */\n      ssize_t written;\n      result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                                outbuf.cbBuffer, &written);\n\n      s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n      if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n        infof(data, \"schannel: failed to send close msg: %s\"\n              \" (bytes written: %zd)\\n\", curl_easy_strerror(result), written);\n      }\n    }\n  }\n\n  /* free SSPI Schannel API security context handle */\n  if(BACKEND->ctxt) {\n    DEBUGF(infof(data, \"schannel: clear security context handle\\n\"));\n    s_pSecFn->DeleteSecurityContext(&BACKEND->ctxt->ctxt_handle);\n    Curl_safefree(BACKEND->ctxt);\n  }\n\n  /* free SSPI Schannel API credential handle */\n  if(BACKEND->cred) {\n    Curl_ssl_sessionid_lock(data);\n    schannel_session_free(BACKEND->cred);\n    Curl_ssl_sessionid_unlock(data);\n    BACKEND->cred = NULL;\n  }\n\n  /* free internal buffer for received encrypted data */\n  if(BACKEND->encdata_buffer != NULL) {\n    Curl_safefree(BACKEND->encdata_buffer);\n    BACKEND->encdata_length = 0;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_is_incomplete = false;\n  }\n\n  /* free internal buffer for received decrypted data */\n  if(BACKEND->decdata_buffer != NULL) {\n    Curl_safefree(BACKEND->decdata_buffer);\n    BACKEND->decdata_length = 0;\n    BACKEND->decdata_offset = 0;\n  }\n\n  return CURLE_OK;\n}\n\nstatic int schannel_init(void)\n{\n  return (Curl_sspi_global_init() == CURLE_OK ? 1 : 0);\n}\n\nstatic void schannel_cleanup(void)\n{\n  Curl_sspi_global_cleanup();\n}\n\nstatic size_t schannel_version(char *buffer, size_t size)\n{\n  size = msnprintf(buffer, size, \"Schannel\");\n\n  return size;\n}\n\nstatic CURLcode schannel_random(struct Curl_easy *data UNUSED_PARAM,\n                                unsigned char *entropy, size_t length)\n{\n  HCRYPTPROV hCryptProv = 0;\n\n  (void)data;\n\n  if(!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return CURLE_FAILED_INIT;\n\n  if(!CryptGenRandom(hCryptProv, (DWORD)length, entropy)) {\n    CryptReleaseContext(hCryptProv, 0UL);\n    return CURLE_FAILED_INIT;\n  }\n\n  CryptReleaseContext(hCryptProv, 0UL);\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CERT_CONTEXT *pCertContextServer = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  do {\n    SECURITY_STATUS sspi_status;\n    const char *x509_der;\n    DWORD x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &pCertContextServer);\n\n    if((sspi_status != SEC_E_OK) || !pCertContextServer) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: Failed to read remote certificate context: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      break; /* failed */\n    }\n\n\n    if(!(((pCertContextServer->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n         (pCertContextServer->cbCertEncoded > 0)))\n      break;\n\n    x509_der = (const char *)pCertContextServer->pbCertEncoded;\n    x509_der_len = pCertContextServer->cbCertEncoded;\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      break;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      break;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n    }\n  } while(0);\n\n  if(pCertContextServer)\n    CertFreeCertificateContext(pCertContextServer);\n\n  return result;\n}\n\nstatic void schannel_checksum(const unsigned char *input,\n                              size_t inputlen,\n                              unsigned char *checksum,\n                              size_t checksumlen,\n                              DWORD provType,\n                              const unsigned int algId)\n{\n  HCRYPTPROV hProv = 0;\n  HCRYPTHASH hHash = 0;\n  DWORD cbHashSize = 0;\n  DWORD dwHashSizeLen = (DWORD)sizeof(cbHashSize);\n  DWORD dwChecksumLen = (DWORD)checksumlen;\n\n  /* since this can fail in multiple ways, zero memory first so we never\n   * return old data\n   */\n  memset(checksum, 0, checksumlen);\n\n  if(!CryptAcquireContext(&hProv, NULL, NULL, provType,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return; /* failed */\n\n  do {\n    if(!CryptCreateHash(hProv, algId, 0, 0, &hHash))\n      break; /* failed */\n\n    /* workaround for original MinGW, should be (const BYTE*) */\n    if(!CryptHashData(hHash, (BYTE*)input, (DWORD)inputlen, 0))\n      break; /* failed */\n\n    /* get hash size */\n    if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&cbHashSize,\n                          &dwHashSizeLen, 0))\n      break; /* failed */\n\n    /* check hash size */\n    if(checksumlen < cbHashSize)\n      break; /* failed */\n\n    if(CryptGetHashParam(hHash, HP_HASHVAL, checksum, &dwChecksumLen, 0))\n      break; /* failed */\n  } while(0);\n\n  if(hHash)\n    CryptDestroyHash(hHash);\n\n  if(hProv)\n    CryptReleaseContext(hProv, 0);\n}\n\nstatic CURLcode schannel_sha256sum(const unsigned char *input,\n                                   size_t inputlen,\n                                   unsigned char *sha256sum,\n                                   size_t sha256len)\n{\n  schannel_checksum(input, inputlen, sha256sum, sha256len,\n                    PROV_RSA_AES, CALG_SHA_256);\n  return CURLE_OK;\n}\n\nstatic void *schannel_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return &BACKEND->ctxt->ctxt_handle;\n}\n\nconst struct Curl_ssl Curl_ssl_schannel = {\n  { CURLSSLBACKEND_SCHANNEL, \"schannel\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n#ifdef HAS_MANUAL_VERIFY_API\n  SSLSUPP_CAINFO_BLOB |\n#endif\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  schannel_init,                     /* init */\n  schannel_cleanup,                  /* cleanup */\n  schannel_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  schannel_shutdown,                 /* shutdown */\n  schannel_data_pending,             /* data_pending */\n  schannel_random,                   /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  schannel_connect,                  /* connect */\n  schannel_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                  /* getsock */\n  schannel_get_internals,            /* get_internals */\n  schannel_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  schannel_session_free,             /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  schannel_sha256sum                 /* sha256sum */\n};\n\n#endif /* USE_SCHANNEL */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2017, Nick Zitzmann, <nickzman@gmail.com>.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all iOS and macOS SecureTransport-specific code for the\n * TLS/SSL layer. No code but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#include \"urldata.h\" /* for the Curl_easy definition */\n#include \"curl_base64.h\"\n#include \"strtok.h\"\n#include \"multiif.h\"\n\n#ifdef USE_SECTRANSP\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wtautological-pointer-compare\"\n#endif /* __clang__ */\n\n#include <limits.h>\n\n#include <Security/Security.h>\n/* For some reason, when building for iOS, the omnibus header above does\n * not include SecureTransport.h as of iOS SDK 5.1. */\n#include <Security/SecureTransport.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include <CommonCrypto/CommonDigest.h>\n\n/* The Security framework has changed greatly between iOS and different macOS\n   versions, and we will try to support as many of them as we can (back to\n   Leopard and iOS 5) by using macros and weak-linking.\n\n   In general, you want to build this using the most recent OS SDK, since some\n   features require curl to be built against the latest SDK. TLS 1.1 and 1.2\n   support, for instance, require the macOS 10.8 SDK or later. TLS 1.3\n   requires the macOS 10.13 or iOS 11 SDK or later. */\n#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050\n#error \"The Secure Transport back-end requires Leopard or later.\"\n#endif /* MAC_OS_X_VERSION_MAX_ALLOWED < 1050 */\n\n#define CURL_BUILD_IOS 0\n#define CURL_BUILD_IOS_7 0\n#define CURL_BUILD_IOS_9 0\n#define CURL_BUILD_IOS_11 0\n#define CURL_BUILD_IOS_13 0\n#define CURL_BUILD_MAC 1\n/* This is the maximum API level we are allowed to use when building: */\n#define CURL_BUILD_MAC_10_5 MAC_OS_X_VERSION_MAX_ALLOWED >= 1050\n#define CURL_BUILD_MAC_10_6 MAC_OS_X_VERSION_MAX_ALLOWED >= 1060\n#define CURL_BUILD_MAC_10_7 MAC_OS_X_VERSION_MAX_ALLOWED >= 1070\n#define CURL_BUILD_MAC_10_8 MAC_OS_X_VERSION_MAX_ALLOWED >= 1080\n#define CURL_BUILD_MAC_10_9 MAC_OS_X_VERSION_MAX_ALLOWED >= 1090\n#define CURL_BUILD_MAC_10_11 MAC_OS_X_VERSION_MAX_ALLOWED >= 101100\n#define CURL_BUILD_MAC_10_13 MAC_OS_X_VERSION_MAX_ALLOWED >= 101300\n#define CURL_BUILD_MAC_10_15 MAC_OS_X_VERSION_MAX_ALLOWED >= 101500\n/* These macros mean \"the following code is present to allow runtime backward\n   compatibility with at least this cat or earlier\":\n   (You set this at build-time using the compiler command line option\n   \"-mmacosx-version-min.\") */\n#define CURL_SUPPORT_MAC_10_5 MAC_OS_X_VERSION_MIN_REQUIRED <= 1050\n#define CURL_SUPPORT_MAC_10_6 MAC_OS_X_VERSION_MIN_REQUIRED <= 1060\n#define CURL_SUPPORT_MAC_10_7 MAC_OS_X_VERSION_MIN_REQUIRED <= 1070\n#define CURL_SUPPORT_MAC_10_8 MAC_OS_X_VERSION_MIN_REQUIRED <= 1080\n#define CURL_SUPPORT_MAC_10_9 MAC_OS_X_VERSION_MIN_REQUIRED <= 1090\n\n#elif TARGET_OS_EMBEDDED || TARGET_OS_IPHONE\n#define CURL_BUILD_IOS 1\n#define CURL_BUILD_IOS_7 __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000\n#define CURL_BUILD_IOS_9 __IPHONE_OS_VERSION_MAX_ALLOWED >= 90000\n#define CURL_BUILD_IOS_11 __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000\n#define CURL_BUILD_IOS_13 __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000\n#define CURL_BUILD_MAC 0\n#define CURL_BUILD_MAC_10_5 0\n#define CURL_BUILD_MAC_10_6 0\n#define CURL_BUILD_MAC_10_7 0\n#define CURL_BUILD_MAC_10_8 0\n#define CURL_BUILD_MAC_10_9 0\n#define CURL_BUILD_MAC_10_11 0\n#define CURL_BUILD_MAC_10_13 0\n#define CURL_BUILD_MAC_10_15 0\n#define CURL_SUPPORT_MAC_10_5 0\n#define CURL_SUPPORT_MAC_10_6 0\n#define CURL_SUPPORT_MAC_10_7 0\n#define CURL_SUPPORT_MAC_10_8 0\n#define CURL_SUPPORT_MAC_10_9 0\n\n#else\n#error \"The Secure Transport back-end requires iOS or macOS.\"\n#endif /* (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) */\n\n#if CURL_BUILD_MAC\n#include <sys/sysctl.h>\n#endif /* CURL_BUILD_MAC */\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"connect.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"sectransp.h\"\n#include \"curl_printf.h\"\n#include \"strdup.h\"\n\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n/* From MacTypes.h (which we can't include because it isn't present in iOS: */\n#define ioErr -36\n#define paramErr -50\n\nstruct ssl_backend_data {\n  SSLContextRef ssl_ctx;\n  curl_socket_t ssl_sockfd;\n  bool ssl_direction; /* true if writing, false if reading */\n  size_t ssl_write_buffered_length;\n};\n\nstruct st_cipher {\n  const char *name; /* Cipher suite IANA name. It starts with \"TLS_\" prefix */\n  const char *alias_name; /* Alias name is the same as OpenSSL cipher name */\n  SSLCipherSuite num; /* Cipher suite code/number defined in IANA registry */\n  bool weak; /* Flag to mark cipher as weak based on previous implementation\n                of Secure Transport back-end by CURL */\n};\n\n/* Macro to initialize st_cipher data structure: stringify id to name, cipher\n   number/id, 'weak' suite flag\n */\n#define CIPHER_DEF(num, alias, weak) \\\n  { #num, alias, num, weak }\n\n/*\n Macro to initialize st_cipher data structure with name, code (IANA cipher\n number/id value), and 'weak' suite flag. The first 28 cipher suite numbers\n have the same IANA code for both SSL and TLS standards: numbers 0x0000 to\n 0x001B. They have different names though. The first 4 letters of the cipher\n suite name are the protocol name: \"SSL_\" or \"TLS_\", rest of the IANA name is\n the same for both SSL and TLS cipher suite name.\n The second part of the problem is that macOS/iOS SDKs don't define all TLS\n codes but only 12 of them. The SDK defines all SSL codes though, i.e. SSL_NUM\n constant is always defined for those 28 ciphers while TLS_NUM is defined only\n for 12 of the first 28 ciphers. Those 12 TLS cipher codes match to\n corresponding SSL enum value and represent the same cipher suite. Therefore\n we'll use the SSL enum value for those cipher suites because it is defined\n for all 28 of them.\n We make internal data consistent and based on TLS names, i.e. all st_cipher\n item names start with the \"TLS_\" prefix.\n Summarizing all the above, those 28 first ciphers are presented in our table\n with both TLS and SSL names. Their cipher numbers are assigned based on the\n SDK enum value for the SSL cipher, which matches to IANA TLS number.\n */\n#define CIPHER_DEF_SSLTLS(num_wo_prefix, alias, weak) \\\n  { \"TLS_\" #num_wo_prefix, alias, SSL_##num_wo_prefix, weak }\n\n/*\n Cipher suites were marked as weak based on the following:\n RC4 encryption - rfc7465, the document contains a list of deprecated ciphers.\n     Marked in the code below as weak.\n RC2 encryption - many mentions, was found vulnerable to a relatively easy\n     attack https://link.springer.com/chapter/10.1007%2F3-540-69710-1_14\n     Marked in the code below as weak.\n DES and IDEA encryption - rfc5469, has a list of deprecated ciphers.\n     Marked in the code below as weak.\n Anonymous Diffie-Hellman authentication and anonymous elliptic curve\n     Diffie-Hellman - vulnerable to a man-in-the-middle attack. Deprecated by\n     RFC 4346 aka TLS 1.1 (section A.5, page 60)\n Null bulk encryption suites - not encrypted communication\n Export ciphers, i.e. ciphers with restrictions to be used outside the US for\n     software exported to some countries, they were excluded from TLS 1.1\n     version. More precisely, they were noted as ciphers which MUST NOT be\n     negotiated in RFC 4346 aka TLS 1.1 (section A.5, pages 60 and 61).\n     All of those filters were considered weak because they contain a weak\n     algorithm like DES, RC2 or RC4, and already considered weak by other\n     criteria.\n 3DES - NIST deprecated it and is going to retire it by 2023\n https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA\n     OpenSSL https://www.openssl.org/blog/blog/2016/08/24/sweet32/ also\n     deprecated those ciphers. Some other libraries also consider it\n     vulnerable or at least not strong enough.\n\n CBC ciphers are vulnerable with SSL3.0 and TLS1.0:\n https://www.cisco.com/c/en/us/support/docs/security/email-security-appliance\n /118518-technote-esa-00.html\n     We don't take care of this issue because it is resolved by later TLS\n     versions and for us, it requires more complicated checks, we need to\n     check a protocol version also. Vulnerability doesn't look very critical\n     and we do not filter out those cipher suites.\n */\n\n#define CIPHER_WEAK_NOT_ENCRYPTED   TRUE\n#define CIPHER_WEAK_RC_ENCRYPTION   TRUE\n#define CIPHER_WEAK_DES_ENCRYPTION  TRUE\n#define CIPHER_WEAK_IDEA_ENCRYPTION TRUE\n#define CIPHER_WEAK_ANON_AUTH       TRUE\n#define CIPHER_WEAK_3DES_ENCRYPTION TRUE\n#define CIPHER_STRONG_ENOUGH        FALSE\n\n/* Please do not change the order of the first ciphers available for SSL.\n   Do not insert and do not delete any of them. Code below\n   depends on their order and continuity.\n   If you add a new cipher, please maintain order by number, i.e.\n   insert in between existing items to appropriate place based on\n   cipher suite IANA number\n*/\nconst static struct st_cipher ciphertable[] = {\n  /* SSL version 3.0 and initial TLS 1.0 cipher suites.\n     Defined since SDK 10.2.8 */\n  CIPHER_DEF_SSLTLS(NULL_WITH_NULL_NULL,                           /* 0x0000 */\n                    NULL,\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_MD5,                             /* 0x0001 */\n                    \"NULL-MD5\",\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_SHA,                             /* 0x0002 */\n                    \"NULL-SHA\",\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC4_40_MD5,                    /* 0x0003 */\n                    \"EXP-RC4-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_MD5,                          /* 0x0004 */\n                    \"RC4-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_SHA,                          /* 0x0005 */\n                    \"RC4-SHA\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC2_CBC_40_MD5,                /* 0x0006 */\n                    \"EXP-RC2-CBC-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_IDEA_CBC_SHA,                         /* 0x0007 */\n                    \"IDEA-CBC-SHA\",\n                    CIPHER_WEAK_IDEA_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_DES40_CBC_SHA,                 /* 0x0008 */\n                    \"EXP-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_DES_CBC_SHA,                          /* 0x0009 */\n                    \"DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_3DES_EDE_CBC_SHA,                     /* 0x000A */\n                    \"DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000B */\n                    \"EXP-DH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_WITH_DES_CBC_SHA,                       /* 0x000C */\n                    \"DH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_WITH_3DES_EDE_CBC_SHA,                  /* 0x000D */\n                    \"DH-DSS-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000E */\n                    \"EXP-DH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_WITH_DES_CBC_SHA,                       /* 0x000F */\n                    \"DH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0x0010 */\n                    \"DH-RSA-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0011 */\n                    \"EXP-EDH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_DES_CBC_SHA,                      /* 0x0012 */\n                    \"EDH-DSS-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_3DES_EDE_CBC_SHA,                 /* 0x0013 */\n                    \"DHE-DSS-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0014 */\n                    \"EXP-EDH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_DES_CBC_SHA,                      /* 0x0015 */\n                    \"EDH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_3DES_EDE_CBC_SHA,                 /* 0x0016 */\n                    \"DHE-RSA-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_RC4_40_MD5,                /* 0x0017 */\n                    \"EXP-ADH-RC4-MD5\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_RC4_128_MD5,                      /* 0x0018 */\n                    \"ADH-RC4-MD5\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0019 */\n                    \"EXP-ADH-DES-CBC-SHA\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_DES_CBC_SHA,                      /* 0x001A */\n                    \"ADH-DES-CBC-SHA\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_3DES_EDE_CBC_SHA,                 /* 0x001B */\n                    \"ADH-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_NULL_SHA,                       /* 0x001C */\n             NULL,\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA,               /* 0x001D */\n             NULL,\n             CIPHER_STRONG_ENOUGH),\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* RFC 4785 - Pre-Shared Key (PSK) Ciphersuites with NULL Encryption */\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA,                                /* 0x002C */\n             \"PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA,                            /* 0x002D */\n             \"DHE-PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA,                            /* 0x002E */\n             \"RSA-PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* TLS addenda using AES, per RFC 3268. Defined since SDK 10.4u */\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA,                         /* 0x002F */\n             \"AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA,                      /* 0x0030 */\n             \"DH-DSS-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA,                      /* 0x0031 */\n             \"DH-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA,                     /* 0x0032 */\n             \"DHE-DSS-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA,                     /* 0x0033 */\n             \"DHE-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA,                     /* 0x0034 */\n             \"ADH-AES128-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA,                         /* 0x0035 */\n             \"AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA,                      /* 0x0036 */\n             \"DH-DSS-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA,                      /* 0x0037 */\n             \"DH-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA,                     /* 0x0038 */\n             \"DHE-DSS-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA,                     /* 0x0039 */\n             \"DHE-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA,                     /* 0x003A */\n             \"ADH-AES256-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* TLS 1.2 addenda, RFC 5246 */\n  /* Server provided RSA certificate for key exchange. */\n  CIPHER_DEF(TLS_RSA_WITH_NULL_SHA256,                             /* 0x003B */\n             \"NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA256,                      /* 0x003C */\n             \"AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA256,                      /* 0x003D */\n             \"AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  /* Server-authenticated (and optionally client-authenticated)\n     Diffie-Hellman. */\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA256,                   /* 0x003E */\n             \"DH-DSS-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA256,                   /* 0x003F */\n             \"DH-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,                  /* 0x0040 */\n             \"DHE-DSS-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n\n  /* TLS 1.2 addenda, RFC 5246 */\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,                  /* 0x0067 */\n             \"DHE-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA256,                   /* 0x0068 */\n             \"DH-DSS-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA256,                   /* 0x0069 */\n             \"DH-RSA-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,                  /* 0x006A */\n             \"DHE-DSS-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,                  /* 0x006B */\n             \"DHE-RSA-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA256,                  /* 0x006C */\n             \"ADH-AES128-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA256,                  /* 0x006D */\n             \"ADH-AES256-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* Addendum from RFC 4279, TLS PSK */\n  CIPHER_DEF(TLS_PSK_WITH_RC4_128_SHA,                             /* 0x008A */\n             \"PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_PSK_WITH_3DES_EDE_CBC_SHA,                        /* 0x008B */\n             \"PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA,                         /* 0x008C */\n             \"PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA,                         /* 0x008D */\n             \"PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_RC4_128_SHA,                         /* 0x008E */\n             \"DHE-PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x008F */\n             \"DHE-PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0090 */\n             \"DHE-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0091 */\n             \"DHE-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_RC4_128_SHA,                         /* 0x0092 */\n             \"RSA-PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x0093 */\n             \"RSA-PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0094 */\n             \"RSA-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0095 */\n             \"RSA-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* Addenda from rfc 5288 AES Galois Counter Mode (GCM) Cipher Suites\n     for TLS. */\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_GCM_SHA256,                      /* 0x009C */\n             \"AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_GCM_SHA384,                      /* 0x009D */\n             \"AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,                  /* 0x009E */\n             \"DHE-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,                  /* 0x009F */\n             \"DHE-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_GCM_SHA256,                   /* 0x00A0 */\n             \"DH-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_GCM_SHA384,                   /* 0x00A1 */\n             \"DH-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,                  /* 0x00A2 */\n             \"DHE-DSS-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384,                  /* 0x00A3 */\n             \"DHE-DSS-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_GCM_SHA256,                   /* 0x00A4 */\n             \"DH-DSS-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_GCM_SHA384,                   /* 0x00A5 */\n             \"DH-DSS-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_GCM_SHA256,                  /* 0x00A6 */\n             \"ADH-AES128-GCM-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_GCM_SHA384,                  /* 0x00A7 */\n             \"ADH-AES256-GCM-SHA384\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* RFC 5487 - PSK with SHA-256/384 and AES GCM */\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_GCM_SHA256,                      /* 0x00A8 */\n             \"PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_GCM_SHA384,                      /* 0x00A9 */\n             \"PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AA */\n             \"DHE-PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AB */\n             \"DHE-PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AC */\n             \"RSA-PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AD */\n             \"RSA-PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA256,                      /* 0x00AE */\n             \"PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA384,                      /* 0x00AF */\n             \"PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA256,                             /* 0x00B0 */\n             \"PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA384,                             /* 0x00B1 */\n             \"PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B2 */\n             \"DHE-PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B3 */\n             \"DHE-PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA256,                         /* 0x00B4 */\n             \"DHE-PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA384,                         /* 0x00B5 */\n             \"DHE-PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B6 */\n             \"RSA-PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B7 */\n             \"RSA-PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA256,                         /* 0x00B8 */\n             \"RSA-PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA384,                         /* 0x00B9 */\n             \"RSA-PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* RFC 5746 - Secure Renegotiation. This is not a real suite,\n     it is a response to initiate negotiation again */\n  CIPHER_DEF(TLS_EMPTY_RENEGOTIATION_INFO_SCSV,                    /* 0x00FF */\n             NULL,\n             CIPHER_STRONG_ENOUGH),\n\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n  /* TLS 1.3 standard cipher suites for ChaCha20+Poly1305.\n     Note: TLS 1.3 ciphersuites do not specify the key exchange\n     algorithm -- they only specify the symmetric ciphers.\n     Cipher alias name matches to OpenSSL cipher name, and for\n     TLS 1.3 ciphers */\n  CIPHER_DEF(TLS_AES_128_GCM_SHA256,                               /* 0x1301 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_256_GCM_SHA384,                               /* 0x1302 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_CHACHA20_POLY1305_SHA256,                         /* 0x1303 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_128_CCM_SHA256,                               /* 0x1304 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_128_CCM_8_SHA256,                             /* 0x1305 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n\n#if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS\n  /* ECDSA addenda, RFC 4492 */\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_NULL_SHA,                         /* 0xC001 */\n             \"ECDH-ECDSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_RC4_128_SHA,                      /* 0xC002 */\n             \"ECDH-ECDSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,                 /* 0xC003 */\n             \"ECDH-ECDSA-DES-CBC3-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,                  /* 0xC004 */\n             \"ECDH-ECDSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,                  /* 0xC005 */\n             \"ECDH-ECDSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_NULL_SHA,                        /* 0xC006 */\n             \"ECDHE-ECDSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,                     /* 0xC007 */\n             \"ECDHE-ECDSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,                /* 0xC008 */\n             \"ECDHE-ECDSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,                 /* 0xC009 */\n             \"ECDHE-ECDSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,                 /* 0xC00A */\n             \"ECDHE-ECDSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_NULL_SHA,                           /* 0xC00B */\n             \"ECDH-RSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_RC4_128_SHA,                        /* 0xC00C */\n             \"ECDH-RSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,                   /* 0xC00D */\n             \"ECDH-RSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,                    /* 0xC00E */\n             \"ECDH-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,                    /* 0xC00F */\n             \"ECDH-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_NULL_SHA,                          /* 0xC010 */\n             \"ECDHE-RSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_RC4_128_SHA,                       /* 0xC011 */\n             \"ECDHE-RSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0xC012 */\n             \"ECDHE-RSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,                   /* 0xC013 */\n             \"ECDHE-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,                   /* 0xC014 */\n             \"ECDHE-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_NULL_SHA,                          /* 0xC015 */\n             \"AECDH-NULL-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_RC4_128_SHA,                       /* 0xC016 */\n             \"AECDH-RC4-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,                  /* 0xC017 */\n             \"AECDH-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_128_CBC_SHA,                   /* 0xC018 */\n             \"AECDH-AES128-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_256_CBC_SHA,                   /* 0xC019 */\n             \"AECDH-AES256-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with\n     HMAC SHA-256/384. */\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,              /* 0xC023 */\n             \"ECDHE-ECDSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,              /* 0xC024 */\n             \"ECDHE-ECDSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,               /* 0xC025 */\n             \"ECDH-ECDSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,               /* 0xC026 */\n             \"ECDH-ECDSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,                /* 0xC027 */\n             \"ECDHE-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,                /* 0xC028 */\n             \"ECDHE-RSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,                 /* 0xC029 */\n             \"ECDH-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,                 /* 0xC02A */\n             \"ECDH-RSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with\n     SHA-256/384 and AES Galois Counter Mode (GCM) */\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,              /* 0xC02B */\n             \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,              /* 0xC02C */\n             \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,               /* 0xC02D */\n             \"ECDH-ECDSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,               /* 0xC02E */\n             \"ECDH-ECDSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,                /* 0xC02F */\n             \"ECDHE-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,                /* 0xC030 */\n             \"ECDHE-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,                 /* 0xC031 */\n             \"ECDH-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,                 /* 0xC032 */\n             \"ECDH-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13\n  /* ECDHE_PSK Cipher Suites for Transport Layer Security (TLS), RFC 5489 */\n  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,                   /* 0xC035 */\n             \"ECDHE-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,                   /* 0xC036 */\n             \"ECDHE-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */\n\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n  /* Addenda from rfc 7905  ChaCha20-Poly1305 Cipher Suites for\n     Transport Layer Security (TLS). */\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,          /* 0xCCA8 */\n             \"ECDHE-RSA-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,        /* 0xCCA9 */\n             \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n\n#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13\n  /* ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS),\n     RFC 7905 */\n  CIPHER_DEF(TLS_PSK_WITH_CHACHA20_POLY1305_SHA256,                /* 0xCCAB */\n             \"PSK-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */\n\n  /* Tags for SSL 2 cipher kinds which are not specified for SSL 3.\n     Defined since SDK 10.2.8 */\n  CIPHER_DEF(SSL_RSA_WITH_RC2_CBC_MD5,                             /* 0xFF80 */\n             NULL,\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_IDEA_CBC_MD5,                            /* 0xFF81 */\n             NULL,\n             CIPHER_WEAK_IDEA_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_DES_CBC_MD5,                             /* 0xFF82 */\n             NULL,\n             CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_3DES_EDE_CBC_MD5,                        /* 0xFF83 */\n             NULL,\n             CIPHER_WEAK_3DES_ENCRYPTION),\n};\n\n#define NUM_OF_CIPHERS sizeof(ciphertable)/sizeof(ciphertable[0])\n\n\n/* pinned public key support tests */\n\n/* version 1 supports macOS 10.12+ and iOS 10+ */\n#if ((TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MIN_REQUIRED >= 100000) || \\\n    (!TARGET_OS_IPHONE && __MAC_OS_X_VERSION_MIN_REQUIRED  >= 101200))\n#define SECTRANSP_PINNEDPUBKEY_V1 1\n#endif\n\n/* version 2 supports MacOSX 10.7+ */\n#if (!TARGET_OS_IPHONE && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)\n#define SECTRANSP_PINNEDPUBKEY_V2 1\n#endif\n\n#if defined(SECTRANSP_PINNEDPUBKEY_V1) || defined(SECTRANSP_PINNEDPUBKEY_V2)\n/* this backend supports CURLOPT_PINNEDPUBLICKEY */\n#define SECTRANSP_PINNEDPUBKEY 1\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n#ifdef SECTRANSP_PINNEDPUBKEY\n/* both new and old APIs return rsa keys missing the spki header (not DER) */\nstatic const unsigned char rsa4096SpkiHeader[] = {\n                                       0x30, 0x82, 0x02, 0x22, 0x30, 0x0d,\n                                       0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n                                       0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,\n                                       0x00, 0x03, 0x82, 0x02, 0x0f, 0x00};\n\nstatic const unsigned char rsa2048SpkiHeader[] = {\n                                       0x30, 0x82, 0x01, 0x22, 0x30, 0x0d,\n                                       0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n                                       0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,\n                                       0x00, 0x03, 0x82, 0x01, 0x0f, 0x00};\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n/* the *new* version doesn't return DER encoded ecdsa certs like the old... */\nstatic const unsigned char ecDsaSecp256r1SpkiHeader[] = {\n                                       0x30, 0x59, 0x30, 0x13, 0x06, 0x07,\n                                       0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,\n                                       0x01, 0x06, 0x08, 0x2a, 0x86, 0x48,\n                                       0xce, 0x3d, 0x03, 0x01, 0x07, 0x03,\n                                       0x42, 0x00};\n\nstatic const unsigned char ecDsaSecp384r1SpkiHeader[] = {\n                                       0x30, 0x76, 0x30, 0x10, 0x06, 0x07,\n                                       0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,\n                                       0x01, 0x06, 0x05, 0x2b, 0x81, 0x04,\n                                       0x00, 0x22, 0x03, 0x62, 0x00};\n#endif /* SECTRANSP_PINNEDPUBKEY_V1 */\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n/* The following two functions were ripped from Apple sample code,\n * with some modifications: */\nstatic OSStatus SocketRead(SSLConnectionRef connection,\n                           void *data,          /* owned by\n                                                 * caller, data\n                                                 * RETURNED */\n                           size_t *dataLength)  /* IN/OUT */\n{\n  size_t bytesToGo = *dataLength;\n  size_t initLen = bytesToGo;\n  UInt8 *currData = (UInt8 *)data;\n  /*int sock = *(int *)connection;*/\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)connection;\n  struct ssl_backend_data *backend = connssl->backend;\n  int sock = backend->ssl_sockfd;\n  OSStatus rtn = noErr;\n  size_t bytesRead;\n  ssize_t rrtn;\n  int theErr;\n\n  *dataLength = 0;\n\n  for(;;) {\n    bytesRead = 0;\n    rrtn = read(sock, currData, bytesToGo);\n    if(rrtn <= 0) {\n      /* this is guesswork... */\n      theErr = errno;\n      if(rrtn == 0) { /* EOF = server hung up */\n        /* the framework will turn this into errSSLClosedNoNotify */\n        rtn = errSSLClosedGraceful;\n      }\n      else /* do the switch */\n        switch(theErr) {\n          case ENOENT:\n            /* connection closed */\n            rtn = errSSLClosedGraceful;\n            break;\n          case ECONNRESET:\n            rtn = errSSLClosedAbort;\n            break;\n          case EAGAIN:\n            rtn = errSSLWouldBlock;\n            backend->ssl_direction = false;\n            break;\n          default:\n            rtn = ioErr;\n            break;\n        }\n      break;\n    }\n    else {\n      bytesRead = rrtn;\n    }\n    bytesToGo -= bytesRead;\n    currData  += bytesRead;\n\n    if(bytesToGo == 0) {\n      /* filled buffer with incoming data, done */\n      break;\n    }\n  }\n  *dataLength = initLen - bytesToGo;\n\n  return rtn;\n}\n\nstatic OSStatus SocketWrite(SSLConnectionRef connection,\n                            const void *data,\n                            size_t *dataLength)  /* IN/OUT */\n{\n  size_t bytesSent = 0;\n  /*int sock = *(int *)connection;*/\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)connection;\n  struct ssl_backend_data *backend = connssl->backend;\n  int sock = backend->ssl_sockfd;\n  ssize_t length;\n  size_t dataLen = *dataLength;\n  const UInt8 *dataPtr = (UInt8 *)data;\n  OSStatus ortn;\n  int theErr;\n\n  *dataLength = 0;\n\n  do {\n    length = write(sock,\n                   (char *)dataPtr + bytesSent,\n                   dataLen - bytesSent);\n  } while((length > 0) &&\n           ( (bytesSent += length) < dataLen) );\n\n  if(length <= 0) {\n    theErr = errno;\n    if(theErr == EAGAIN) {\n      ortn = errSSLWouldBlock;\n      backend->ssl_direction = true;\n    }\n    else {\n      ortn = ioErr;\n    }\n  }\n  else {\n    ortn = noErr;\n  }\n  *dataLength = bytesSent;\n  return ortn;\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nCF_INLINE const char *TLSCipherNameForNumber(SSLCipherSuite cipher)\n{\n  /* The first ciphers in the ciphertable are continuos. Here we do small\n     optimization and instead of loop directly get SSL name by cipher number.\n   */\n  if(cipher <= SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA) {\n    return ciphertable[cipher].name;\n  }\n  /* Iterate through the rest of the ciphers */\n  for(size_t i = SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA + 1;\n      i < NUM_OF_CIPHERS;\n      ++i) {\n    if(ciphertable[i].num == cipher) {\n      return ciphertable[i].name;\n    }\n  }\n  return ciphertable[SSL_NULL_WITH_NULL_NULL].name;\n}\n#endif /* !CURL_DISABLE_VERBOSE_STRINGS */\n\n#if CURL_BUILD_MAC\nCF_INLINE void GetDarwinVersionNumber(int *major, int *minor)\n{\n  int mib[2];\n  char *os_version;\n  size_t os_version_len;\n  char *os_version_major, *os_version_minor;\n  char *tok_buf;\n\n  /* Get the Darwin kernel version from the kernel using sysctl(): */\n  mib[0] = CTL_KERN;\n  mib[1] = KERN_OSRELEASE;\n  if(sysctl(mib, 2, NULL, &os_version_len, NULL, 0) == -1)\n    return;\n  os_version = malloc(os_version_len*sizeof(char));\n  if(!os_version)\n    return;\n  if(sysctl(mib, 2, os_version, &os_version_len, NULL, 0) == -1) {\n    free(os_version);\n    return;\n  }\n\n  /* Parse the version: */\n  os_version_major = strtok_r(os_version, \".\", &tok_buf);\n  os_version_minor = strtok_r(NULL, \".\", &tok_buf);\n  *major = atoi(os_version_major);\n  *minor = atoi(os_version_minor);\n  free(os_version);\n}\n#endif /* CURL_BUILD_MAC */\n\n/* Apple provides a myriad of ways of getting information about a certificate\n   into a string. Some aren't available under iOS or newer cats. So here's\n   a unified function for getting a string describing the certificate that\n   ought to work in all cats starting with Leopard. */\nCF_INLINE CFStringRef getsubject(SecCertificateRef cert)\n{\n  CFStringRef server_cert_summary = CFSTR(\"(null)\");\n\n#if CURL_BUILD_IOS\n  /* iOS: There's only one way to do this. */\n  server_cert_summary = SecCertificateCopySubjectSummary(cert);\n#else\n#if CURL_BUILD_MAC_10_7\n  /* Lion & later: Get the long description if we can. */\n  if(SecCertificateCopyLongDescription != NULL)\n    server_cert_summary =\n      SecCertificateCopyLongDescription(NULL, cert, NULL);\n  else\n#endif /* CURL_BUILD_MAC_10_7 */\n#if CURL_BUILD_MAC_10_6\n  /* Snow Leopard: Get the certificate summary. */\n  if(SecCertificateCopySubjectSummary != NULL)\n    server_cert_summary = SecCertificateCopySubjectSummary(cert);\n  else\n#endif /* CURL_BUILD_MAC_10_6 */\n  /* Leopard is as far back as we go... */\n  (void)SecCertificateCopyCommonName(cert, &server_cert_summary);\n#endif /* CURL_BUILD_IOS */\n  return server_cert_summary;\n}\n\nstatic CURLcode CopyCertSubject(struct Curl_easy *data,\n                                SecCertificateRef cert, char **certp)\n{\n  CFStringRef c = getsubject(cert);\n  CURLcode result = CURLE_OK;\n  const char *direct;\n  char *cbuf = NULL;\n  *certp = NULL;\n\n  if(!c) {\n    failf(data, \"SSL: invalid CA certificate subject\");\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  /* If the subject is already available as UTF-8 encoded (ie 'direct') then\n     use that, else convert it. */\n  direct = CFStringGetCStringPtr(c, kCFStringEncodingUTF8);\n  if(direct) {\n    *certp = strdup(direct);\n    if(!*certp) {\n      failf(data, \"SSL: out of memory\");\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n  else {\n    size_t cbuf_size = ((size_t)CFStringGetLength(c) * 4) + 1;\n    cbuf = calloc(cbuf_size, 1);\n    if(cbuf) {\n      if(!CFStringGetCString(c, cbuf, cbuf_size,\n                             kCFStringEncodingUTF8)) {\n        failf(data, \"SSL: invalid CA certificate subject\");\n        result = CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        /* pass back the buffer */\n        *certp = cbuf;\n    }\n    else {\n      failf(data, \"SSL: couldn't allocate %zu bytes of memory\", cbuf_size);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n  if(result)\n    free(cbuf);\n  CFRelease(c);\n  return result;\n}\n\n#if CURL_SUPPORT_MAC_10_6\n/* The SecKeychainSearch API was deprecated in Lion, and using it will raise\n   deprecation warnings, so let's not compile this unless it's necessary: */\nstatic OSStatus CopyIdentityWithLabelOldSchool(char *label,\n                                               SecIdentityRef *out_c_a_k)\n{\n  OSStatus status = errSecItemNotFound;\n  SecKeychainAttributeList attr_list;\n  SecKeychainAttribute attr;\n  SecKeychainSearchRef search = NULL;\n  SecCertificateRef cert = NULL;\n\n  /* Set up the attribute list: */\n  attr_list.count = 1L;\n  attr_list.attr = &attr;\n\n  /* Set up our lone search criterion: */\n  attr.tag = kSecLabelItemAttr;\n  attr.data = label;\n  attr.length = (UInt32)strlen(label);\n\n  /* Start searching: */\n  status = SecKeychainSearchCreateFromAttributes(NULL,\n                                                 kSecCertificateItemClass,\n                                                 &attr_list,\n                                                 &search);\n  if(status == noErr) {\n    status = SecKeychainSearchCopyNext(search,\n                                       (SecKeychainItemRef *)&cert);\n    if(status == noErr && cert) {\n      /* If we found a certificate, does it have a private key? */\n      status = SecIdentityCreateWithCertificate(NULL, cert, out_c_a_k);\n      CFRelease(cert);\n    }\n  }\n\n  if(search)\n    CFRelease(search);\n  return status;\n}\n#endif /* CURL_SUPPORT_MAC_10_6 */\n\nstatic OSStatus CopyIdentityWithLabel(char *label,\n                                      SecIdentityRef *out_cert_and_key)\n{\n  OSStatus status = errSecItemNotFound;\n\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n  CFArrayRef keys_list;\n  CFIndex keys_list_count;\n  CFIndex i;\n  CFStringRef common_name;\n\n  /* SecItemCopyMatching() was introduced in iOS and Snow Leopard.\n     kSecClassIdentity was introduced in Lion. If both exist, let's use them\n     to find the certificate. */\n  if(SecItemCopyMatching != NULL && kSecClassIdentity != NULL) {\n    CFTypeRef keys[5];\n    CFTypeRef values[5];\n    CFDictionaryRef query_dict;\n    CFStringRef label_cf = CFStringCreateWithCString(NULL, label,\n      kCFStringEncodingUTF8);\n\n    /* Set up our search criteria and expected results: */\n    values[0] = kSecClassIdentity; /* we want a certificate and a key */\n    keys[0] = kSecClass;\n    values[1] = kCFBooleanTrue;    /* we want a reference */\n    keys[1] = kSecReturnRef;\n    values[2] = kSecMatchLimitAll; /* kSecMatchLimitOne would be better if the\n                                    * label matching below worked correctly */\n    keys[2] = kSecMatchLimit;\n    /* identity searches need a SecPolicyRef in order to work */\n    values[3] = SecPolicyCreateSSL(false, NULL);\n    keys[3] = kSecMatchPolicy;\n    /* match the name of the certificate (doesn't work in macOS 10.12.1) */\n    values[4] = label_cf;\n    keys[4] = kSecAttrLabel;\n    query_dict = CFDictionaryCreate(NULL, (const void **)keys,\n                                    (const void **)values, 5L,\n                                    &kCFCopyStringDictionaryKeyCallBacks,\n                                    &kCFTypeDictionaryValueCallBacks);\n    CFRelease(values[3]);\n\n    /* Do we have a match? */\n    status = SecItemCopyMatching(query_dict, (CFTypeRef *) &keys_list);\n\n    /* Because kSecAttrLabel matching doesn't work with kSecClassIdentity,\n     * we need to find the correct identity ourselves */\n    if(status == noErr) {\n      keys_list_count = CFArrayGetCount(keys_list);\n      *out_cert_and_key = NULL;\n      status = 1;\n      for(i = 0; i<keys_list_count; i++) {\n        OSStatus err = noErr;\n        SecCertificateRef cert = NULL;\n        SecIdentityRef identity =\n          (SecIdentityRef) CFArrayGetValueAtIndex(keys_list, i);\n        err = SecIdentityCopyCertificate(identity, &cert);\n        if(err == noErr) {\n#if CURL_BUILD_IOS\n          common_name = SecCertificateCopySubjectSummary(cert);\n#elif CURL_BUILD_MAC_10_7\n          SecCertificateCopyCommonName(cert, &common_name);\n#endif\n          if(CFStringCompare(common_name, label_cf, 0) == kCFCompareEqualTo) {\n            CFRelease(cert);\n            CFRelease(common_name);\n            CFRetain(identity);\n            *out_cert_and_key = identity;\n            status = noErr;\n            break;\n          }\n          CFRelease(common_name);\n        }\n        CFRelease(cert);\n      }\n    }\n\n    if(keys_list)\n      CFRelease(keys_list);\n    CFRelease(query_dict);\n    CFRelease(label_cf);\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_6\n    /* On Leopard and Snow Leopard, fall back to SecKeychainSearch. */\n    status = CopyIdentityWithLabelOldSchool(label, out_cert_and_key);\n#endif /* CURL_SUPPORT_MAC_10_6 */\n  }\n#elif CURL_SUPPORT_MAC_10_6\n  /* For developers building on older cats, we have no choice but to fall back\n     to SecKeychainSearch. */\n  status = CopyIdentityWithLabelOldSchool(label, out_cert_and_key);\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n  return status;\n}\n\nstatic OSStatus CopyIdentityFromPKCS12File(const char *cPath,\n                                           const struct curl_blob *blob,\n                                           const char *cPassword,\n                                           SecIdentityRef *out_cert_and_key)\n{\n  OSStatus status = errSecItemNotFound;\n  CFURLRef pkcs_url = NULL;\n  CFStringRef password = cPassword ? CFStringCreateWithCString(NULL,\n    cPassword, kCFStringEncodingUTF8) : NULL;\n  CFDataRef pkcs_data = NULL;\n\n  /* We can import P12 files on iOS or OS X 10.7 or later: */\n  /* These constants are documented as having first appeared in 10.6 but they\n     raise linker errors when used on that cat for some reason. */\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n  bool resource_imported;\n\n  if(blob) {\n    pkcs_data = CFDataCreate(kCFAllocatorDefault,\n                             (const unsigned char *)blob->data, blob->len);\n    status = (pkcs_data != NULL) ? errSecSuccess : errSecAllocate;\n    resource_imported = (pkcs_data != NULL);\n  }\n  else {\n    pkcs_url =\n      CFURLCreateFromFileSystemRepresentation(NULL,\n                                              (const UInt8 *)cPath,\n                                              strlen(cPath), false);\n    resource_imported =\n      CFURLCreateDataAndPropertiesFromResource(NULL,\n                                               pkcs_url, &pkcs_data,\n                                               NULL, NULL, &status);\n  }\n\n  if(resource_imported) {\n    CFArrayRef items = NULL;\n\n  /* On iOS SecPKCS12Import will never add the client certificate to the\n   * Keychain.\n   *\n   * It gives us back a SecIdentityRef that we can use directly. */\n#if CURL_BUILD_IOS\n    const void *cKeys[] = {kSecImportExportPassphrase};\n    const void *cValues[] = {password};\n    CFDictionaryRef options = CFDictionaryCreate(NULL, cKeys, cValues,\n      password ? 1L : 0L, NULL, NULL);\n\n    if(options != NULL) {\n      status = SecPKCS12Import(pkcs_data, options, &items);\n      CFRelease(options);\n    }\n\n\n  /* On macOS SecPKCS12Import will always add the client certificate to\n   * the Keychain.\n   *\n   * As this doesn't match iOS, and apps may not want to see their client\n   * certificate saved in the user's keychain, we use SecItemImport\n   * with a NULL keychain to avoid importing it.\n   *\n   * This returns a SecCertificateRef from which we can construct a\n   * SecIdentityRef.\n   */\n#elif CURL_BUILD_MAC_10_7\n    SecItemImportExportKeyParameters keyParams;\n    SecExternalFormat inputFormat = kSecFormatPKCS12;\n    SecExternalItemType inputType = kSecItemTypeCertificate;\n\n    memset(&keyParams, 0x00, sizeof(keyParams));\n    keyParams.version    = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n    keyParams.passphrase = password;\n\n    status = SecItemImport(pkcs_data, NULL, &inputFormat, &inputType,\n                           0, &keyParams, NULL, &items);\n#endif\n\n\n    /* Extract the SecIdentityRef */\n    if(status == errSecSuccess && items && CFArrayGetCount(items)) {\n      CFIndex i, count;\n      count = CFArrayGetCount(items);\n\n      for(i = 0; i < count; i++) {\n        CFTypeRef item = (CFTypeRef) CFArrayGetValueAtIndex(items, i);\n        CFTypeID  itemID = CFGetTypeID(item);\n\n        if(itemID == CFDictionaryGetTypeID()) {\n          CFTypeRef identity = (CFTypeRef) CFDictionaryGetValue(\n                                                 (CFDictionaryRef) item,\n                                                 kSecImportItemIdentity);\n          CFRetain(identity);\n          *out_cert_and_key = (SecIdentityRef) identity;\n          break;\n        }\n#if CURL_BUILD_MAC_10_7\n        else if(itemID == SecCertificateGetTypeID()) {\n          status = SecIdentityCreateWithCertificate(NULL,\n                                                 (SecCertificateRef) item,\n                                                 out_cert_and_key);\n          break;\n        }\n#endif\n      }\n    }\n\n    if(items)\n      CFRelease(items);\n    CFRelease(pkcs_data);\n  }\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n  if(password)\n    CFRelease(password);\n  if(pkcs_url)\n    CFRelease(pkcs_url);\n  return status;\n}\n\n/* This code was borrowed from nss.c, with some modifications:\n * Determine whether the nickname passed in is a filename that needs to\n * be loaded as a PEM or a regular NSS nickname.\n *\n * returns 1 for a file\n * returns 0 for not a file\n */\nCF_INLINE bool is_file(const char *filename)\n{\n  struct_stat st;\n\n  if(!filename)\n    return false;\n\n  if(stat(filename, &st) == 0)\n    return S_ISREG(st.st_mode);\n  return false;\n}\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\nstatic CURLcode sectransp_version_from_curl(SSLProtocol *darwinver,\n                                            long ssl_version)\n{\n  switch(ssl_version) {\n    case CURL_SSLVERSION_TLSv1_0:\n      *darwinver = kTLSProtocol1;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_1:\n      *darwinver = kTLSProtocol11;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_2:\n      *darwinver = kTLSProtocol12;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      /* TLS 1.3 support first appeared in iOS 11 and macOS 10.13 */\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n      if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n        *darwinver = kTLSProtocol13;\n        return CURLE_OK;\n      }\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n      break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n#endif\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long max_supported_version_by_os;\n\n  /* macOS 10.5-10.7 supported TLS 1.0 only.\n     macOS 10.8 and later, and iOS 5 and later, added TLS 1.1 and 1.2.\n     macOS 10.13 and later, and iOS 11 and later, added TLS 1.3. */\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n  if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n    max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_3;\n  }\n  else {\n    max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_2;\n  }\n#else\n  max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_2;\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      ssl_version = CURL_SSLVERSION_TLSv1_0;\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = max_supported_version_by_os;\n      break;\n  }\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLSetProtocolVersionMax != NULL) {\n    SSLProtocol darwin_ver_min = kTLSProtocol1;\n    SSLProtocol darwin_ver_max = kTLSProtocol1;\n    CURLcode result = sectransp_version_from_curl(&darwin_ver_min,\n                                                  ssl_version);\n    if(result) {\n      failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n    result = sectransp_version_from_curl(&darwin_ver_max,\n                                         ssl_version_max >> 16);\n    if(result) {\n      failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n\n    (void)SSLSetProtocolVersionMin(backend->ssl_ctx, darwin_ver_min);\n    (void)SSLSetProtocolVersionMax(backend->ssl_ctx, darwin_ver_max);\n    return result;\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    long i = ssl_version;\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kSSLProtocolAll,\n                                       false);\n    for(; i <= (ssl_version_max >> 16); i++) {\n      switch(i) {\n        case CURL_SSLVERSION_TLSv1_0:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol1,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_1:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol11,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_2:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol12,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_3:\n          failf(data, \"Your version of the OS does not support TLSv1.3\");\n          return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    return CURLE_OK;\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n  }\n#endif  /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n  failf(data, \"Secure Transport: cannot set SSL protocol\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic bool is_cipher_suite_strong(SSLCipherSuite suite_num)\n{\n  for(size_t i = 0; i < NUM_OF_CIPHERS; ++i) {\n    if(ciphertable[i].num == suite_num) {\n      return !ciphertable[i].weak;\n    }\n  }\n  /* If the cipher is not in our list, assume it is a new one\n     and therefore strong. Previous implementation was the same,\n     if cipher suite is not in the list, it was considered strong enough */\n  return true;\n}\n\nstatic bool is_separator(char c)\n{\n  /* Return whether character is a cipher list separator. */\n  switch(c) {\n  case ' ':\n  case '\\t':\n  case ':':\n  case ',':\n  case ';':\n    return true;\n  }\n  return false;\n}\n\nstatic CURLcode sectransp_set_default_ciphers(struct Curl_easy *data,\n                                              SSLContextRef ssl_ctx)\n{\n  size_t all_ciphers_count = 0UL, allowed_ciphers_count = 0UL, i;\n  SSLCipherSuite *all_ciphers = NULL, *allowed_ciphers = NULL;\n  OSStatus err = noErr;\n\n#if CURL_BUILD_MAC\n  int darwinver_maj = 0, darwinver_min = 0;\n\n  GetDarwinVersionNumber(&darwinver_maj, &darwinver_min);\n#endif /* CURL_BUILD_MAC */\n\n  /* Disable cipher suites that ST supports but are not safe. These ciphers\n     are unlikely to be used in any case since ST gives other ciphers a much\n     higher priority, but it's probably better that we not connect at all than\n     to give the user a false sense of security if the server only supports\n     insecure ciphers. (Note: We don't care about SSLv2-only ciphers.) */\n  err = SSLGetNumberSupportedCiphers(ssl_ctx, &all_ciphers_count);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLGetNumberSupportedCiphers() failed: OSStatus %d\",\n          err);\n    return CURLE_SSL_CIPHER;\n  }\n  all_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));\n  if(!all_ciphers) {\n    failf(data, \"SSL: Failed to allocate memory for all ciphers\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n  allowed_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));\n  if(!allowed_ciphers) {\n    Curl_safefree(all_ciphers);\n    failf(data, \"SSL: Failed to allocate memory for allowed ciphers\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n  err = SSLGetSupportedCiphers(ssl_ctx, all_ciphers,\n                               &all_ciphers_count);\n  if(err != noErr) {\n    Curl_safefree(all_ciphers);\n    Curl_safefree(allowed_ciphers);\n    return CURLE_SSL_CIPHER;\n  }\n  for(i = 0UL ; i < all_ciphers_count ; i++) {\n#if CURL_BUILD_MAC\n   /* There's a known bug in early versions of Mountain Lion where ST's ECC\n      ciphers (cipher suite 0xC001 through 0xC032) simply do not work.\n      Work around the problem here by disabling those ciphers if we are\n      running in an affected version of OS X. */\n    if(darwinver_maj == 12 && darwinver_min <= 3 &&\n       all_ciphers[i] >= 0xC001 && all_ciphers[i] <= 0xC032) {\n      continue;\n    }\n#endif /* CURL_BUILD_MAC */\n    if(is_cipher_suite_strong(all_ciphers[i])) {\n      allowed_ciphers[allowed_ciphers_count++] = all_ciphers[i];\n    }\n  }\n  err = SSLSetEnabledCiphers(ssl_ctx, allowed_ciphers,\n                             allowed_ciphers_count);\n  Curl_safefree(all_ciphers);\n  Curl_safefree(allowed_ciphers);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnabledCiphers() failed: OSStatus %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_set_selected_ciphers(struct Curl_easy *data,\n                                               SSLContextRef ssl_ctx,\n                                               const char *ciphers)\n{\n  size_t ciphers_count = 0;\n  const char *cipher_start = ciphers;\n  OSStatus err = noErr;\n  SSLCipherSuite selected_ciphers[NUM_OF_CIPHERS];\n\n  if(!ciphers)\n    return CURLE_OK;\n\n  while(is_separator(*ciphers))     /* Skip initial separators. */\n    ciphers++;\n  if(!*ciphers)\n    return CURLE_OK;\n\n  cipher_start = ciphers;\n  while(*cipher_start && ciphers_count < NUM_OF_CIPHERS) {\n    bool cipher_found = FALSE;\n    size_t cipher_len = 0;\n    const char *cipher_end = NULL;\n    bool tls_name = FALSE;\n\n    /* Skip separators */\n    while(is_separator(*cipher_start))\n       cipher_start++;\n    if(*cipher_start == '\\0') {\n      break;\n    }\n    /* Find last position of a cipher in the ciphers string */\n    cipher_end = cipher_start;\n    while (*cipher_end != '\\0' && !is_separator(*cipher_end)) {\n      ++cipher_end;\n    }\n\n    /* IANA cipher names start with the TLS_ or SSL_ prefix.\n       If the 4th symbol of the cipher is '_' we look for a cipher in the\n       table by its (TLS) name.\n       Otherwise, we try to match cipher by an alias. */\n    if(cipher_start[3] == '_') {\n      tls_name = TRUE;\n    }\n    /* Iterate through the cipher table and look for the cipher, starting\n       the cipher number 0x01 because the 0x00 is not the real cipher */\n    cipher_len = cipher_end - cipher_start;\n    for(size_t i = 1; i < NUM_OF_CIPHERS; ++i) {\n      const char *table_cipher_name = NULL;\n      if(tls_name) {\n        table_cipher_name = ciphertable[i].name;\n      }\n      else if(ciphertable[i].alias_name != NULL) {\n        table_cipher_name = ciphertable[i].alias_name;\n      }\n      else {\n        continue;\n      }\n      /* Compare a part of the string between separators with a cipher name\n         in the table and make sure we matched the whole cipher name */\n      if(strncmp(cipher_start, table_cipher_name, cipher_len) == 0\n          && table_cipher_name[cipher_len] == '\\0') {\n        selected_ciphers[ciphers_count] = ciphertable[i].num;\n        ++ciphers_count;\n        cipher_found = TRUE;\n        break;\n      }\n    }\n    if(!cipher_found) {\n      /* It would be more human-readable if we print the wrong cipher name\n         but we don't want to allocate any additional memory and copy the name\n         into it, then add it into logs.\n         Also, we do not modify an original cipher list string. We just point\n         to positions where cipher starts and ends in the cipher list string.\n         The message is a bit cryptic and longer than necessary but can be\n         understood by humans. */\n      failf(data, \"SSL: cipher string \\\"%s\\\" contains unsupported cipher name\"\n            \" starting position %d and ending position %d\",\n            ciphers,\n            cipher_start - ciphers,\n            cipher_end - ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    if(*cipher_end) {\n      cipher_start = cipher_end + 1;\n    }\n    else {\n      break;\n    }\n  }\n  /* All cipher suites in the list are found. Report to logs as-is */\n  infof(data, \"SSL: Setting cipher suites list \\\"%s\\\"\\n\", ciphers);\n\n  err = SSLSetEnabledCiphers(ssl_ctx, selected_ciphers, ciphers_count);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnabledCiphers() failed: OSStatus %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_connect_step1(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        int sockindex)\n{\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const struct curl_blob *ssl_cablob = SSL_CONN_CONFIG(ca_info_blob);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ssl_cablob ? NULL : SSL_CONN_CONFIG(CAfile));\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n  bool isproxy = SSL_IS_PROXY();\n  const char * const hostname = SSL_HOST_NAME();\n  const long int port = SSL_HOST_PORT();\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif /* ENABLE_IPV6 */\n  char *ciphers;\n  OSStatus err = noErr;\n#if CURL_BUILD_MAC\n  int darwinver_maj = 0, darwinver_min = 0;\n\n  GetDarwinVersionNumber(&darwinver_maj, &darwinver_min);\n#endif /* CURL_BUILD_MAC */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLCreateContext != NULL) {  /* use the newer API if available */\n    if(backend->ssl_ctx)\n      CFRelease(backend->ssl_ctx);\n    backend->ssl_ctx = SSLCreateContext(NULL, kSSLClientSide, kSSLStreamType);\n    if(!backend->ssl_ctx) {\n      failf(data, \"SSL: couldn't create a context!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  else {\n  /* The old ST API does not exist under iOS, so don't compile it: */\n#if CURL_SUPPORT_MAC_10_8\n    if(backend->ssl_ctx)\n      (void)SSLDisposeContext(backend->ssl_ctx);\n    err = SSLNewContext(false, &(backend->ssl_ctx));\n    if(err != noErr) {\n      failf(data, \"SSL: couldn't create a context: OSStatus %d\", err);\n      return CURLE_OUT_OF_MEMORY;\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  if(backend->ssl_ctx)\n    (void)SSLDisposeContext(backend->ssl_ctx);\n  err = SSLNewContext(false, &(backend->ssl_ctx));\n  if(err != noErr) {\n    failf(data, \"SSL: couldn't create a context: OSStatus %d\", err);\n    return CURLE_OUT_OF_MEMORY;\n  }\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n  backend->ssl_write_buffered_length = 0UL; /* reset buffered write length */\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLSetProtocolVersionMax != NULL) {\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_TLSv1:\n      (void)SSLSetProtocolVersionMin(backend->ssl_ctx, kTLSProtocol1);\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n      if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n        (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol13);\n      }\n      else {\n        (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol12);\n      }\n#else\n      (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol12);\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n      break;\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n      {\n        CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n        if(result != CURLE_OK)\n          return result;\n        break;\n      }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kSSLProtocolAll,\n                                       false);\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol1,\n                                         true);\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol11,\n                                         true);\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol12,\n                                         true);\n      break;\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n      {\n        CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n        if(result != CURLE_OK)\n          return result;\n        break;\n      }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  if(conn->ssl_config.version_max != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"Your version of the OS does not support to set maximum\"\n                \" SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx, kSSLProtocolAll, false);\n  switch(conn->ssl_config.version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kTLSProtocol1,\n                                       true);\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    failf(data, \"Your version of the OS does not support TLSv1.1\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_TLSv1_2:\n    failf(data, \"Your version of the OS does not support TLSv1.2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_TLSv1_3:\n    failf(data, \"Your version of the OS does not support TLSv1.3\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_SSLv2:\n  case CURL_SSLVERSION_SSLv3:\n    failf(data, \"SSL versions not supported\");\n    return CURLE_NOT_BUILT_IN;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n  if(conn->bits.tls_enable_alpn) {\n    if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {\n      CFMutableArrayRef alpnArr = CFArrayCreateMutable(NULL, 0,\n                                                       &kCFTypeArrayCallBacks);\n\n#ifdef USE_HTTP2\n      if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n         && (!isproxy || !conn->bits.tunnel_proxy)\n#endif\n        ) {\n        CFArrayAppendValue(alpnArr, CFSTR(ALPN_H2));\n        infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n      }\n#endif\n\n      CFArrayAppendValue(alpnArr, CFSTR(ALPN_HTTP_1_1));\n      infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n      /* expects length prefixed preference ordered list of protocols in wire\n       * format\n       */\n      err = SSLSetALPNProtocols(backend->ssl_ctx, alpnArr);\n      if(err != noErr)\n        infof(data, \"WARNING: failed to set ALPN protocols; OSStatus %d\\n\",\n              err);\n      CFRelease(alpnArr);\n    }\n  }\n#endif\n\n  if(SSL_SET_OPTION(key)) {\n    infof(data, \"WARNING: SSL: CURLOPT_SSLKEY is ignored by Secure \"\n          \"Transport. The private key must be in the Keychain.\\n\");\n  }\n\n  if(ssl_cert || ssl_cert_blob) {\n    bool is_cert_data = ssl_cert_blob != NULL;\n    bool is_cert_file = (!is_cert_data) && is_file(ssl_cert);\n    SecIdentityRef cert_and_key = NULL;\n\n    /* User wants to authenticate with a client cert. Look for it:\n       If we detect that this is a file on disk, then let's load it.\n       Otherwise, assume that the user wants to use an identity loaded\n       from the Keychain. */\n    if(is_cert_file || is_cert_data) {\n      if(!SSL_SET_OPTION(cert_type))\n        infof(data, \"WARNING: SSL: Certificate type not set, assuming \"\n                    \"PKCS#12 format.\\n\");\n      else if(strncmp(SSL_SET_OPTION(cert_type), \"P12\",\n        strlen(SSL_SET_OPTION(cert_type))) != 0)\n        infof(data, \"WARNING: SSL: The Security framework only supports \"\n                    \"loading identities that are in PKCS#12 format.\\n\");\n\n      err = CopyIdentityFromPKCS12File(ssl_cert, ssl_cert_blob,\n        SSL_SET_OPTION(key_passwd), &cert_and_key);\n    }\n    else\n      err = CopyIdentityWithLabel(ssl_cert, &cert_and_key);\n\n    if(err == noErr && cert_and_key) {\n      SecCertificateRef cert = NULL;\n      CFTypeRef certs_c[1];\n      CFArrayRef certs;\n\n      /* If we found one, print it out: */\n      err = SecIdentityCopyCertificate(cert_and_key, &cert);\n      if(err == noErr) {\n        char *certp;\n        CURLcode result = CopyCertSubject(data, cert, &certp);\n        if(!result) {\n          infof(data, \"Client certificate: %s\\n\", certp);\n          free(certp);\n        }\n\n        CFRelease(cert);\n        if(result == CURLE_PEER_FAILED_VERIFICATION)\n          return CURLE_SSL_CERTPROBLEM;\n        if(result)\n          return result;\n      }\n      certs_c[0] = cert_and_key;\n      certs = CFArrayCreate(NULL, (const void **)certs_c, 1L,\n                            &kCFTypeArrayCallBacks);\n      err = SSLSetCertificate(backend->ssl_ctx, certs);\n      if(certs)\n        CFRelease(certs);\n      if(err != noErr) {\n        failf(data, \"SSL: SSLSetCertificate() failed: OSStatus %d\", err);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n      CFRelease(cert_and_key);\n    }\n    else {\n      const char *cert_showfilename_error =\n        is_cert_data ? \"(memory blob)\" : ssl_cert;\n\n      switch(err) {\n      case errSecAuthFailed: case -25264: /* errSecPkcs12VerifyFailure */\n        failf(data, \"SSL: Incorrect password for the certificate \\\"%s\\\" \"\n                    \"and its private key.\", cert_showfilename_error);\n        break;\n      case -26275: /* errSecDecode */ case -25257: /* errSecUnknownFormat */\n        failf(data, \"SSL: Couldn't make sense of the data in the \"\n                    \"certificate \\\"%s\\\" and its private key.\",\n                    cert_showfilename_error);\n        break;\n      case -25260: /* errSecPassphraseRequired */\n        failf(data, \"SSL The certificate \\\"%s\\\" requires a password.\",\n                    cert_showfilename_error);\n        break;\n      case errSecItemNotFound:\n        failf(data, \"SSL: Can't find the certificate \\\"%s\\\" and its private \"\n                    \"key in the Keychain.\", cert_showfilename_error);\n        break;\n      default:\n        failf(data, \"SSL: Can't load the certificate \\\"%s\\\" and its private \"\n                    \"key: OSStatus %d\", cert_showfilename_error, err);\n        break;\n      }\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n#if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS\n  /* Snow Leopard introduced the SSLSetSessionOption() function, but due to\n     a library bug with the way the kSSLSessionOptionBreakOnServerAuth flag\n     works, it doesn't work as expected under Snow Leopard, Lion or\n     Mountain Lion.\n     So we need to call SSLSetEnableCertVerify() on those older cats in order\n     to disable certificate validation if the user turned that off.\n     (SecureTransport will always validate the certificate chain by\n     default.)\n  Note:\n  Darwin 11.x.x is Lion (10.7)\n  Darwin 12.x.x is Mountain Lion (10.8)\n  Darwin 13.x.x is Mavericks (10.9)\n  Darwin 14.x.x is Yosemite (10.10)\n  Darwin 15.x.x is El Capitan (10.11)\n  */\n#if CURL_BUILD_MAC\n  if(SSLSetSessionOption != NULL && darwinver_maj >= 13) {\n#else\n  if(SSLSetSessionOption != NULL) {\n#endif /* CURL_BUILD_MAC */\n    bool break_on_auth = !conn->ssl_config.verifypeer ||\n      ssl_cafile || ssl_cablob;\n    err = SSLSetSessionOption(backend->ssl_ctx,\n                              kSSLSessionOptionBreakOnServerAuth,\n                              break_on_auth);\n    if(err != noErr) {\n      failf(data, \"SSL: SSLSetSessionOption() failed: OSStatus %d\", err);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    err = SSLSetEnableCertVerify(backend->ssl_ctx,\n                                 conn->ssl_config.verifypeer?true:false);\n    if(err != noErr) {\n      failf(data, \"SSL: SSLSetEnableCertVerify() failed: OSStatus %d\", err);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  err = SSLSetEnableCertVerify(backend->ssl_ctx,\n                               conn->ssl_config.verifypeer?true:false);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnableCertVerify() failed: OSStatus %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS */\n\n  if((ssl_cafile || ssl_cablob) && verifypeer) {\n    bool is_cert_data = ssl_cablob != NULL;\n    bool is_cert_file = (!is_cert_data) && is_file(ssl_cafile);\n\n    if(!(is_cert_file || is_cert_data)) {\n      failf(data, \"SSL: can't load CA certificate file %s\",\n            ssl_cafile ? ssl_cafile : \"(blob memory)\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Configure hostname check. SNI is used if available.\n   * Both hostname check and SNI require SSLSetPeerDomainName().\n   * Also: the verifyhost setting influences SNI usage */\n  if(conn->ssl_config.verifyhost) {\n    err = SSLSetPeerDomainName(backend->ssl_ctx, hostname,\n    strlen(hostname));\n\n    if(err != noErr) {\n      infof(data, \"WARNING: SSL: SSLSetPeerDomainName() failed: OSStatus %d\\n\",\n            err);\n    }\n\n    if((Curl_inet_pton(AF_INET, hostname, &addr))\n  #ifdef ENABLE_IPV6\n    || (Curl_inet_pton(AF_INET6, hostname, &addr))\n  #endif\n       ) {\n      infof(data, \"WARNING: using IP address, SNI is being disabled by \"\n            \"the OS.\\n\");\n    }\n  }\n  else {\n    infof(data, \"WARNING: disabling hostname validation also disables SNI.\\n\");\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n    err = sectransp_set_selected_ciphers(data, backend->ssl_ctx, ciphers);\n  }\n  else {\n    err = sectransp_set_default_ciphers(data, backend->ssl_ctx);\n  }\n  if(err != noErr) {\n    failf(data, \"SSL: Unable to set ciphers for SSL/TLS handshake. \"\n          \"Error code: %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* We want to enable 1/n-1 when using a CBC cipher unless the user\n     specifically doesn't want us doing that: */\n  if(SSLSetSessionOption != NULL) {\n    SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionSendOneByteRecord,\n                        !SSL_SET_OPTION(enable_beast));\n    SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionFalseStart,\n                      data->set.ssl.falsestart); /* false start support */\n  }\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    char *ssl_sessionid;\n    size_t ssl_sessionid_len;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, isproxy, (void **)&ssl_sessionid,\n                              &ssl_sessionid_len, sockindex)) {\n      /* we got a session id, use it! */\n      err = SSLSetPeerID(backend->ssl_ctx, ssl_sessionid, ssl_sessionid_len);\n      Curl_ssl_sessionid_unlock(data);\n      if(err != noErr) {\n        failf(data, \"SSL: SSLSetPeerID() failed: OSStatus %d\", err);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    /* If there isn't one, then let's make one up! This has to be done prior\n       to starting the handshake. */\n    else {\n      CURLcode result;\n      ssl_sessionid =\n        aprintf(\"%s:%d:%d:%s:%ld\",\n                ssl_cafile ? ssl_cafile : \"(blob memory)\",\n                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);\n      ssl_sessionid_len = strlen(ssl_sessionid);\n\n      err = SSLSetPeerID(backend->ssl_ctx, ssl_sessionid, ssl_sessionid_len);\n      if(err != noErr) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSLSetPeerID() failed: OSStatus %d\", err);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      result = Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n                                     ssl_sessionid_len, sockindex);\n      Curl_ssl_sessionid_unlock(data);\n      if(result) {\n        failf(data, \"failed to store ssl session\");\n        return result;\n      }\n    }\n  }\n\n  err = SSLSetIOFuncs(backend->ssl_ctx, SocketRead, SocketWrite);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetIOFuncs() failed: OSStatus %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* pass the raw socket into the SSL layers */\n  /* We need to store the FD in a constant memory address, because\n   * SSLSetConnection() will not copy that address. I've found that\n   * conn->sock[sockindex] may change on its own. */\n  backend->ssl_sockfd = sockfd;\n  err = SSLSetConnection(backend->ssl_ctx, connssl);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetConnection() failed: %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\nstatic long pem_to_der(const char *in, unsigned char **out, size_t *outlen)\n{\n  char *sep_start, *sep_end, *cert_start, *cert_end;\n  size_t i, j, err;\n  size_t len;\n  unsigned char *b64;\n\n  /* Jump through the separators at the beginning of the certificate. */\n  sep_start = strstr(in, \"-----\");\n  if(!sep_start)\n    return 0;\n  cert_start = strstr(sep_start + 1, \"-----\");\n  if(!cert_start)\n    return -1;\n\n  cert_start += 5;\n\n  /* Find separator after the end of the certificate. */\n  cert_end = strstr(cert_start, \"-----\");\n  if(!cert_end)\n    return -1;\n\n  sep_end = strstr(cert_end + 1, \"-----\");\n  if(!sep_end)\n    return -1;\n  sep_end += 5;\n\n  len = cert_end - cert_start;\n  b64 = malloc(len + 1);\n  if(!b64)\n    return -1;\n\n  /* Create base64 string without linefeeds. */\n  for(i = 0, j = 0; i < len; i++) {\n    if(cert_start[i] != '\\r' && cert_start[i] != '\\n')\n      b64[j++] = cert_start[i];\n  }\n  b64[j] = '\\0';\n\n  err = Curl_base64_decode((const char *)b64, out, outlen);\n  free(b64);\n  if(err) {\n    free(*out);\n    return -1;\n  }\n\n  return sep_end - in;\n}\n\nstatic int read_cert(const char *file, unsigned char **out, size_t *outlen)\n{\n  int fd;\n  ssize_t n, len = 0, cap = 512;\n  unsigned char buf[512], *data;\n\n  fd = open(file, 0);\n  if(fd < 0)\n    return -1;\n\n  data = malloc(cap);\n  if(!data) {\n    close(fd);\n    return -1;\n  }\n\n  for(;;) {\n    n = read(fd, buf, sizeof(buf));\n    if(n < 0) {\n      close(fd);\n      free(data);\n      return -1;\n    }\n    else if(n == 0) {\n      close(fd);\n      break;\n    }\n\n    if(len + n >= cap) {\n      cap *= 2;\n      data = Curl_saferealloc(data, cap);\n      if(!data) {\n        close(fd);\n        return -1;\n      }\n    }\n\n    memcpy(data + len, buf, n);\n    len += n;\n  }\n  data[len] = '\\0';\n\n  *out = data;\n  *outlen = len;\n\n  return 0;\n}\n\nstatic int append_cert_to_array(struct Curl_easy *data,\n                                const unsigned char *buf, size_t buflen,\n                                CFMutableArrayRef array)\n{\n    CFDataRef certdata = CFDataCreate(kCFAllocatorDefault, buf, buflen);\n    char *certp;\n    CURLcode result;\n    if(!certdata) {\n      failf(data, \"SSL: failed to allocate array for CA certificate\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    SecCertificateRef cacert =\n      SecCertificateCreateWithData(kCFAllocatorDefault, certdata);\n    CFRelease(certdata);\n    if(!cacert) {\n      failf(data, \"SSL: failed to create SecCertificate from CA certificate\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n\n    /* Check if cacert is valid. */\n    result = CopyCertSubject(data, cacert, &certp);\n    switch(result) {\n      case CURLE_OK:\n        break;\n      case CURLE_PEER_FAILED_VERIFICATION:\n        return CURLE_SSL_CACERT_BADFILE;\n      case CURLE_OUT_OF_MEMORY:\n      default:\n        return result;\n    }\n    free(certp);\n\n    CFArrayAppendValue(array, cacert);\n    CFRelease(cacert);\n\n    return CURLE_OK;\n}\n\nstatic CURLcode verify_cert_buf(struct Curl_easy *data,\n                                const unsigned char *certbuf, size_t buflen,\n                                SSLContextRef ctx)\n{\n  int n = 0, rc;\n  long res;\n  unsigned char *der;\n  size_t derlen, offset = 0;\n\n  /*\n   * Certbuf now contains the contents of the certificate file, which can be\n   * - a single DER certificate,\n   * - a single PEM certificate or\n   * - a bunch of PEM certificates (certificate bundle).\n   *\n   * Go through certbuf, and convert any PEM certificate in it into DER\n   * format.\n   */\n  CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0,\n                                                 &kCFTypeArrayCallBacks);\n  if(!array) {\n    failf(data, \"SSL: out of memory creating CA certificate array\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  while(offset < buflen) {\n    n++;\n\n    /*\n     * Check if the certificate is in PEM format, and convert it to DER. If\n     * this fails, we assume the certificate is in DER format.\n     */\n    res = pem_to_der((const char *)certbuf + offset, &der, &derlen);\n    if(res < 0) {\n      CFRelease(array);\n      failf(data, \"SSL: invalid CA certificate #%d (offset %zu) in bundle\",\n            n, offset);\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n    offset += res;\n\n    if(res == 0 && offset == 0) {\n      /* This is not a PEM file, probably a certificate in DER format. */\n      rc = append_cert_to_array(data, certbuf, buflen, array);\n      if(rc != CURLE_OK) {\n        CFRelease(array);\n        return rc;\n      }\n      break;\n    }\n    else if(res == 0) {\n      /* No more certificates in the bundle. */\n      break;\n    }\n\n    rc = append_cert_to_array(data, der, derlen, array);\n    free(der);\n    if(rc != CURLE_OK) {\n      CFRelease(array);\n      return rc;\n    }\n  }\n\n  SecTrustRef trust;\n  OSStatus ret = SSLCopyPeerTrust(ctx, &trust);\n  if(!trust) {\n    failf(data, \"SSL: error getting certificate chain\");\n    CFRelease(array);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else if(ret != noErr) {\n    CFRelease(array);\n    failf(data, \"SSLCopyPeerTrust() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  ret = SecTrustSetAnchorCertificates(trust, array);\n  if(ret != noErr) {\n    CFRelease(array);\n    CFRelease(trust);\n    failf(data, \"SecTrustSetAnchorCertificates() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  ret = SecTrustSetAnchorCertificatesOnly(trust, true);\n  if(ret != noErr) {\n    CFRelease(array);\n    CFRelease(trust);\n    failf(data, \"SecTrustSetAnchorCertificatesOnly() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  SecTrustResultType trust_eval = 0;\n  ret = SecTrustEvaluate(trust, &trust_eval);\n  CFRelease(array);\n  CFRelease(trust);\n  if(ret != noErr) {\n    failf(data, \"SecTrustEvaluate() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  switch(trust_eval) {\n    case kSecTrustResultUnspecified:\n    case kSecTrustResultProceed:\n      return CURLE_OK;\n\n    case kSecTrustResultRecoverableTrustFailure:\n    case kSecTrustResultDeny:\n    default:\n      failf(data, \"SSL: certificate verification failed (result: %d)\",\n            trust_eval);\n      return CURLE_PEER_FAILED_VERIFICATION;\n  }\n}\n\nstatic CURLcode verify_cert(struct Curl_easy *data, const char *cafile,\n                            const struct curl_blob *ca_info_blob,\n                            SSLContextRef ctx)\n{\n  int result;\n  unsigned char *certbuf;\n  size_t buflen;\n\n  if(ca_info_blob) {\n    certbuf = (unsigned char *)malloc(ca_info_blob->len + 1);\n    if(!certbuf) {\n      return CURLE_OUT_OF_MEMORY;\n    }\n    buflen = ca_info_blob->len;\n    memcpy(certbuf, ca_info_blob->data, ca_info_blob->len);\n    certbuf[ca_info_blob->len]='\\0';\n  }\n  else if(cafile) {\n    if(read_cert(cafile, &certbuf, &buflen) < 0) {\n      failf(data, \"SSL: failed to read or invalid CA certificate\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    return CURLE_SSL_CACERT_BADFILE;\n\n  result = verify_cert_buf(data, certbuf, buflen, ctx);\n  free(certbuf);\n  return result;\n}\n\n\n#ifdef SECTRANSP_PINNEDPUBKEY\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    SSLContextRef ctx,\n                                    const char *pinnedpubkey)\n{  /* Scratch */\n  size_t pubkeylen, realpubkeylen, spkiHeaderLength = 24;\n  unsigned char *pubkey = NULL, *realpubkey = NULL;\n  const unsigned char *spkiHeader = NULL;\n  CFDataRef publicKeyBits = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n\n  if(!ctx)\n    return result;\n\n  do {\n    SecTrustRef trust;\n    OSStatus ret = SSLCopyPeerTrust(ctx, &trust);\n    if(ret != noErr || !trust)\n      break;\n\n    SecKeyRef keyRef = SecTrustCopyPublicKey(trust);\n    CFRelease(trust);\n    if(!keyRef)\n      break;\n\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n\n    publicKeyBits = SecKeyCopyExternalRepresentation(keyRef, NULL);\n    CFRelease(keyRef);\n    if(!publicKeyBits)\n      break;\n\n#elif SECTRANSP_PINNEDPUBKEY_V2\n\n    OSStatus success = SecItemExport(keyRef, kSecFormatOpenSSL, 0, NULL,\n                                     &publicKeyBits);\n    CFRelease(keyRef);\n    if(success != errSecSuccess || !publicKeyBits)\n      break;\n\n#endif /* SECTRANSP_PINNEDPUBKEY_V2 */\n\n    pubkeylen = CFDataGetLength(publicKeyBits);\n    pubkey = (unsigned char *)CFDataGetBytePtr(publicKeyBits);\n\n    switch(pubkeylen) {\n      case 526:\n        /* 4096 bit RSA pubkeylen == 526 */\n        spkiHeader = rsa4096SpkiHeader;\n        break;\n      case 270:\n        /* 2048 bit RSA pubkeylen == 270 */\n        spkiHeader = rsa2048SpkiHeader;\n        break;\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n      case 65:\n        /* ecDSA secp256r1 pubkeylen == 65 */\n        spkiHeader = ecDsaSecp256r1SpkiHeader;\n        spkiHeaderLength = 26;\n        break;\n      case 97:\n        /* ecDSA secp384r1 pubkeylen == 97 */\n        spkiHeader = ecDsaSecp384r1SpkiHeader;\n        spkiHeaderLength = 23;\n        break;\n      default:\n        infof(data, \"SSL: unhandled public key length: %d\\n\", pubkeylen);\n#elif SECTRANSP_PINNEDPUBKEY_V2\n      default:\n        /* ecDSA secp256r1 pubkeylen == 91 header already included?\n         * ecDSA secp384r1 header already included too\n         * we assume rest of algorithms do same, so do nothing\n         */\n        result = Curl_pin_peer_pubkey(data, pinnedpubkey, pubkey,\n                                    pubkeylen);\n#endif /* SECTRANSP_PINNEDPUBKEY_V2 */\n        continue; /* break from loop */\n    }\n\n    realpubkeylen = pubkeylen + spkiHeaderLength;\n    realpubkey = malloc(realpubkeylen);\n    if(!realpubkey)\n      break;\n\n    memcpy(realpubkey, spkiHeader, spkiHeaderLength);\n    memcpy(realpubkey + spkiHeaderLength, pubkey, pubkeylen);\n\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, realpubkey,\n                                  realpubkeylen);\n\n  } while(0);\n\n  Curl_safefree(realpubkey);\n  if(publicKeyBits != NULL)\n    CFRelease(publicKeyBits);\n\n  return result;\n}\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\nstatic CURLcode\nsectransp_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  SSLCipherSuite cipher;\n  SSLProtocol protocol = 0;\n  const char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state\n              || ssl_connect_2_reading == connssl->connecting_state\n              || ssl_connect_2_writing == connssl->connecting_state);\n\n  /* Here goes nothing: */\n  err = SSLHandshake(backend->ssl_ctx);\n\n  if(err != noErr) {\n    switch(err) {\n      case errSSLWouldBlock:  /* they're not done with us yet */\n        connssl->connecting_state = backend->ssl_direction ?\n            ssl_connect_2_writing : ssl_connect_2_reading;\n        return CURLE_OK;\n\n      /* The below is errSSLServerAuthCompleted; it's not defined in\n        Leopard's headers */\n      case -9841:\n        if((SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) &&\n           SSL_CONN_CONFIG(verifypeer)) {\n          CURLcode result = verify_cert(data, SSL_CONN_CONFIG(CAfile),\n                                        SSL_CONN_CONFIG(ca_info_blob),\n                                        backend->ssl_ctx);\n          if(result)\n            return result;\n        }\n        /* the documentation says we need to call SSLHandshake() again */\n        return sectransp_connect_step2(data, conn, sockindex);\n\n      /* Problem with encrypt / decrypt */\n      case errSSLPeerDecodeError:\n        failf(data, \"Decode failed\");\n        break;\n      case errSSLDecryptionFail:\n      case errSSLPeerDecryptionFail:\n        failf(data, \"Decryption failed\");\n        break;\n      case errSSLPeerDecryptError:\n        failf(data, \"A decryption error occurred\");\n        break;\n      case errSSLBadCipherSuite:\n        failf(data, \"A bad SSL cipher suite was encountered\");\n        break;\n      case errSSLCrypto:\n        failf(data, \"An underlying cryptographic error was encountered\");\n        break;\n#if CURL_BUILD_MAC_10_11 || CURL_BUILD_IOS_9\n      case errSSLWeakPeerEphemeralDHKey:\n        failf(data, \"Indicates a weak ephemeral Diffie-Hellman key\");\n        break;\n#endif\n\n      /* Problem with the message record validation */\n      case errSSLBadRecordMac:\n      case errSSLPeerBadRecordMac:\n        failf(data, \"A record with a bad message authentication code (MAC) \"\n                    \"was encountered\");\n        break;\n      case errSSLRecordOverflow:\n      case errSSLPeerRecordOverflow:\n        failf(data, \"A record overflow occurred\");\n        break;\n\n      /* Problem with zlib decompression */\n      case errSSLPeerDecompressFail:\n        failf(data, \"Decompression failed\");\n        break;\n\n      /* Problem with access */\n      case errSSLPeerAccessDenied:\n        failf(data, \"Access was denied\");\n        break;\n      case errSSLPeerInsufficientSecurity:\n        failf(data, \"There is insufficient security for this operation\");\n        break;\n\n      /* These are all certificate problems with the server: */\n      case errSSLXCertChainInvalid:\n        failf(data, \"SSL certificate problem: Invalid certificate chain\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLUnknownRootCert:\n        failf(data, \"SSL certificate problem: Untrusted root certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLNoRootCert:\n        failf(data, \"SSL certificate problem: No root certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLCertNotYetValid:\n        failf(data, \"SSL certificate problem: The certificate chain had a \"\n                    \"certificate that is not yet valid\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLCertExpired:\n      case errSSLPeerCertExpired:\n        failf(data, \"SSL certificate problem: Certificate chain had an \"\n              \"expired certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLBadCert:\n      case errSSLPeerBadCert:\n        failf(data, \"SSL certificate problem: Couldn't understand the server \"\n              \"certificate format\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerUnsupportedCert:\n        failf(data, \"SSL certificate problem: An unsupported certificate \"\n                    \"format was encountered\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerCertRevoked:\n        failf(data, \"SSL certificate problem: The certificate was revoked\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerCertUnknown:\n        failf(data, \"SSL certificate problem: The certificate is unknown\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n\n      /* These are all certificate problems with the client: */\n      case errSecAuthFailed:\n        failf(data, \"SSL authentication failed\");\n        break;\n      case errSSLPeerHandshakeFail:\n        failf(data, \"SSL peer handshake failed, the server most likely \"\n              \"requires a client certificate to connect\");\n        break;\n      case errSSLPeerUnknownCA:\n        failf(data, \"SSL server rejected the client certificate due to \"\n              \"the certificate being signed by an unknown certificate \"\n              \"authority\");\n        break;\n\n      /* This error is raised if the server's cert didn't match the server's\n         host name: */\n      case errSSLHostNameMismatch:\n        failf(data, \"SSL certificate peer verification failed, the \"\n              \"certificate did not match \\\"%s\\\"\\n\", conn->host.dispname);\n        return CURLE_PEER_FAILED_VERIFICATION;\n\n      /* Problem with SSL / TLS negotiation */\n      case errSSLNegotiation:\n        failf(data, \"Could not negotiate an SSL cipher suite with the server\");\n        break;\n      case errSSLBadConfiguration:\n        failf(data, \"A configuration error occurred\");\n        break;\n      case errSSLProtocol:\n        failf(data, \"SSL protocol error\");\n        break;\n      case errSSLPeerProtocolVersion:\n        failf(data, \"A bad protocol version was encountered\");\n        break;\n      case errSSLPeerNoRenegotiation:\n        failf(data, \"No renegotiation is allowed\");\n        break;\n\n      /* Generic handshake errors: */\n      case errSSLConnectionRefused:\n        failf(data, \"Server dropped the connection during the SSL handshake\");\n        break;\n      case errSSLClosedAbort:\n        failf(data, \"Server aborted the SSL handshake\");\n        break;\n      case errSSLClosedGraceful:\n        failf(data, \"The connection closed gracefully\");\n        break;\n      case errSSLClosedNoNotify:\n        failf(data, \"The server closed the session with no notification\");\n        break;\n      /* Sometimes paramErr happens with buggy ciphers: */\n      case paramErr:\n      case errSSLInternal:\n      case errSSLPeerInternalError:\n        failf(data, \"Internal SSL engine error encountered during the \"\n              \"SSL handshake\");\n        break;\n      case errSSLFatalAlert:\n        failf(data, \"Fatal SSL engine error encountered during the SSL \"\n              \"handshake\");\n        break;\n      /* Unclassified error */\n      case errSSLBufferOverflow:\n        failf(data, \"An insufficient buffer was provided\");\n        break;\n      case errSSLIllegalParam:\n        failf(data, \"An illegal parameter was encountered\");\n        break;\n      case errSSLModuleAttach:\n        failf(data, \"Module attach failure\");\n        break;\n      case errSSLSessionNotFound:\n        failf(data, \"An attempt to restore an unknown session failed\");\n        break;\n      case errSSLPeerExportRestriction:\n        failf(data, \"An export restriction occurred\");\n        break;\n      case errSSLPeerUserCancelled:\n        failf(data, \"The user canceled the operation\");\n        break;\n      case errSSLPeerUnexpectedMsg:\n        failf(data, \"Peer rejected unexpected message\");\n        break;\n#if CURL_BUILD_MAC_10_11 || CURL_BUILD_IOS_9\n      /* Treaing non-fatal error as fatal like before */\n      case errSSLClientHelloReceived:\n        failf(data, \"A non-fatal result for providing a server name \"\n                    \"indication\");\n        break;\n#endif\n\n      /* Error codes defined in the enum but should never be returned.\n         We list them here just in case. */\n#if CURL_BUILD_MAC_10_6\n      /* Only returned when kSSLSessionOptionBreakOnCertRequested is set */\n      case errSSLClientCertRequested:\n        failf(data, \"Server requested a client certificate during the \"\n              \"handshake\");\n        return CURLE_SSL_CLIENTCERT;\n#endif\n#if CURL_BUILD_MAC_10_9\n      /* Alias for errSSLLast, end of error range */\n      case errSSLUnexpectedRecord:\n        failf(data, \"Unexpected (skipped) record in DTLS\");\n        break;\n#endif\n      default:\n        /* May also return codes listed in Security Framework Result Codes */\n        failf(data, \"Unknown SSL protocol error in connection to %s:%d\",\n              hostname, err);\n        break;\n    }\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else {\n    /* we have been connected fine, we're not waiting for anything else. */\n    connssl->connecting_state = ssl_connect_3;\n\n#ifdef SECTRANSP_PINNEDPUBKEY\n    if(data->set.str[STRING_SSL_PINNEDPUBLICKEY]) {\n      CURLcode result =\n        pkp_pin_peer_pubkey(data, backend->ssl_ctx,\n                            data->set.str[STRING_SSL_PINNEDPUBLICKEY]);\n      if(result) {\n        failf(data, \"SSL: public key does not match pinned public key!\");\n        return result;\n      }\n    }\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n    /* Informational message */\n    (void)SSLGetNegotiatedCipher(backend->ssl_ctx, &cipher);\n    (void)SSLGetNegotiatedProtocolVersion(backend->ssl_ctx, &protocol);\n    switch(protocol) {\n      case kSSLProtocol2:\n        infof(data, \"SSL 2.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kSSLProtocol3:\n        infof(data, \"SSL 3.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kTLSProtocol1:\n        infof(data, \"TLS 1.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n      case kTLSProtocol11:\n        infof(data, \"TLS 1.1 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kTLSProtocol12:\n        infof(data, \"TLS 1.2 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n      case kTLSProtocol13:\n        infof(data, \"TLS 1.3 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n      default:\n        infof(data, \"Unknown protocol connection\\n\");\n        break;\n    }\n\n#if(CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n    if(conn->bits.tls_enable_alpn) {\n      if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {\n        CFArrayRef alpnArr = NULL;\n        CFStringRef chosenProtocol = NULL;\n        err = SSLCopyALPNProtocols(backend->ssl_ctx, &alpnArr);\n\n        if(err == noErr && alpnArr && CFArrayGetCount(alpnArr) >= 1)\n          chosenProtocol = CFArrayGetValueAtIndex(alpnArr, 0);\n\n#ifdef USE_HTTP2\n        if(chosenProtocol &&\n           !CFStringCompare(chosenProtocol, CFSTR(ALPN_H2), 0)) {\n          conn->negnpn = CURL_HTTP_VERSION_2;\n        }\n        else\n#endif\n        if(chosenProtocol &&\n           !CFStringCompare(chosenProtocol, CFSTR(ALPN_HTTP_1_1), 0)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n        else\n          infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n        Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                            BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n\n        /* chosenProtocol is a reference to the string within alpnArr\n           and doesn't need to be freed separately */\n        if(alpnArr)\n          CFRelease(alpnArr);\n      }\n    }\n#endif\n\n    return CURLE_OK;\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n/* This should be called during step3 of the connection at the earliest */\nstatic void\nshow_verbose_server_cert(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CFArrayRef server_certs = NULL;\n  SecCertificateRef server_cert;\n  OSStatus err;\n  CFIndex i, count;\n  SecTrustRef trust = NULL;\n\n  if(!backend->ssl_ctx)\n    return;\n\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n#if CURL_BUILD_IOS\n#pragma unused(server_certs)\n  err = SSLCopyPeerTrust(backend->ssl_ctx, &trust);\n  /* For some reason, SSLCopyPeerTrust() can return noErr and yet return\n     a null trust, so be on guard for that: */\n  if(err == noErr && trust) {\n    count = SecTrustGetCertificateCount(trust);\n    for(i = 0L ; i < count ; i++) {\n      CURLcode result;\n      char *certp;\n      server_cert = SecTrustGetCertificateAtIndex(trust, i);\n      result = CopyCertSubject(data, server_cert, &certp);\n      if(!result) {\n        infof(data, \"Server certificate: %s\\n\", certp);\n        free(certp);\n      }\n    }\n    CFRelease(trust);\n  }\n#else\n  /* SSLCopyPeerCertificates() is deprecated as of Mountain Lion.\n     The function SecTrustGetCertificateAtIndex() is officially present\n     in Lion, but it is unfortunately also present in Snow Leopard as\n     private API and doesn't work as expected. So we have to look for\n     a different symbol to make sure this code is only executed under\n     Lion or later. */\n  if(SecTrustEvaluateAsync != NULL) {\n#pragma unused(server_certs)\n    err = SSLCopyPeerTrust(backend->ssl_ctx, &trust);\n    /* For some reason, SSLCopyPeerTrust() can return noErr and yet return\n       a null trust, so be on guard for that: */\n    if(err == noErr && trust) {\n      count = SecTrustGetCertificateCount(trust);\n      for(i = 0L ; i < count ; i++) {\n        char *certp;\n        CURLcode result;\n        server_cert = SecTrustGetCertificateAtIndex(trust, i);\n        result = CopyCertSubject(data, server_cert, &certp);\n        if(!result) {\n          infof(data, \"Server certificate: %s\\n\", certp);\n          free(certp);\n        }\n      }\n      CFRelease(trust);\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    err = SSLCopyPeerCertificates(backend->ssl_ctx, &server_certs);\n    /* Just in case SSLCopyPeerCertificates() returns null too... */\n    if(err == noErr && server_certs) {\n      count = CFArrayGetCount(server_certs);\n      for(i = 0L ; i < count ; i++) {\n        char *certp;\n        CURLcode result;\n        server_cert = (SecCertificateRef)CFArrayGetValueAtIndex(server_certs,\n                                                                i);\n        result = CopyCertSubject(data, server_cert, &certp);\n        if(!result) {\n          infof(data, \"Server certificate: %s\\n\", certp);\n          free(certp);\n        }\n      }\n      CFRelease(server_certs);\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#endif /* CURL_BUILD_IOS */\n#else\n#pragma unused(trust)\n  err = SSLCopyPeerCertificates(backend->ssl_ctx, &server_certs);\n  if(err == noErr) {\n    count = CFArrayGetCount(server_certs);\n    for(i = 0L ; i < count ; i++) {\n      CURLcode result;\n      char *certp;\n      server_cert = (SecCertificateRef)CFArrayGetValueAtIndex(server_certs, i);\n      result = CopyCertSubject(data, server_cert, &certp);\n      if(!result) {\n        infof(data, \"Server certificate: %s\\n\", certp);\n        free(certp);\n      }\n    }\n    CFRelease(server_certs);\n  }\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n}\n#endif /* !CURL_DISABLE_VERBOSE_STRINGS */\n\nstatic CURLcode\nsectransp_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  /* There is no step 3!\n   * Well, okay, if verbose mode is on, let's print the details of the\n   * server certificates. */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  if(data->set.verbose)\n    show_verbose_server_cert(data, conn, sockindex);\n#endif\n\n  connssl->connecting_state = ssl_connect_done;\n  return CURLE_OK;\n}\n\nstatic Curl_recv sectransp_recv;\nstatic Curl_send sectransp_send;\n\nstatic CURLcode\nsectransp_connect_common(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         int sockindex,\n                         bool nonblocking,\n                         bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = sectransp_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if this\n     * connection is done nonblocking and this loop would execute again. This\n     * permits the owner of a multi handle to abort a connection attempt\n     * before step2 has completed while ensuring that a client using select()\n     * or epoll() will always have a valid fdset to wait on.\n     */\n    result = sectransp_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = sectransp_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = sectransp_recv;\n    conn->send[sockindex] = sectransp_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_connect_nonblocking(struct Curl_easy *data,\n                                              struct connectdata *conn,\n                                              int sockindex, bool *done)\n{\n  return sectransp_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode sectransp_connect(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = sectransp_connect_common(data, conn, sockindex, FALSE, &done);\n\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic void sectransp_close(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->ssl_ctx) {\n    (void)SSLClose(backend->ssl_ctx);\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n    if(SSLCreateContext != NULL)\n      CFRelease(backend->ssl_ctx);\n#if CURL_SUPPORT_MAC_10_8\n    else\n      (void)SSLDisposeContext(backend->ssl_ctx);\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n#else\n    (void)SSLDisposeContext(backend->ssl_ctx);\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n    backend->ssl_ctx = NULL;\n  }\n  backend->ssl_sockfd = 0;\n}\n\nstatic int sectransp_shutdown(struct Curl_easy *data,\n                              struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t nread;\n  int what;\n  int rc;\n  char buf[120];\n\n  if(!backend->ssl_ctx)\n    return 0;\n\n#ifndef CURL_DISABLE_FTP\n  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)\n    return 0;\n#endif\n\n  sectransp_close(data, conn, sockindex);\n\n  rc = 0;\n\n  what = SOCKET_READABLE(conn->sock[sockindex], SSL_SHUTDOWN_TIMEOUT);\n\n  for(;;) {\n    if(what < 0) {\n      /* anything that gets here is fatally bad */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      rc = -1;\n      break;\n    }\n\n    if(!what) {                                /* timeout */\n      failf(data, \"SSL shutdown timeout\");\n      break;\n    }\n\n    /* Something to read, let's do it and hope that it is the close\n     notify alert from the server. No way to SSL_Read now, so use read(). */\n\n    nread = read(conn->sock[sockindex], buf, sizeof(buf));\n\n    if(nread < 0) {\n      failf(data, \"read: %s\", strerror(errno));\n      rc = -1;\n    }\n\n    if(nread <= 0)\n      break;\n\n    what = SOCKET_READABLE(conn->sock[sockindex], 0);\n  }\n\n  return rc;\n}\n\nstatic void sectransp_session_free(void *ptr)\n{\n  /* ST, as of iOS 5 and Mountain Lion, has no public method of deleting a\n     cached session ID inside the Security framework. There is a private\n     function that does this, but I don't want to have to explain to you why I\n     got your application rejected from the App Store due to the use of a\n     private API, so the best we can do is free up our own char array that we\n     created way back in sectransp_connect_step1... */\n  Curl_safefree(ptr);\n}\n\nstatic size_t sectransp_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"SecureTransport\");\n}\n\n/*\n * This function uses SSLGetSessionState to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int sectransp_check_cxn(struct connectdata *conn)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  SSLSessionState state;\n\n  if(backend->ssl_ctx) {\n    err = SSLGetSessionState(backend->ssl_ctx, &state);\n    if(err == noErr)\n      return state == kSSLConnected || state == kSSLHandshake;\n    return -1;\n  }\n  return 0;\n}\n\nstatic bool sectransp_data_pending(const struct connectdata *conn,\n                                   int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  size_t buffer;\n\n  if(backend->ssl_ctx) {  /* SSL is in use */\n    err = SSLGetBufferedReadSize(backend->ssl_ctx, &buffer);\n    if(err == noErr)\n      return buffer > 0UL;\n    return false;\n  }\n  else\n    return false;\n}\n\nstatic CURLcode sectransp_random(struct Curl_easy *data UNUSED_PARAM,\n                                 unsigned char *entropy, size_t length)\n{\n  /* arc4random_buf() isn't available on cats older than Lion, so let's\n     do this manually for the benefit of the older cats. */\n  size_t i;\n  u_int32_t random_number = 0;\n\n  (void)data;\n\n  for(i = 0 ; i < length ; i++) {\n    if(i % sizeof(u_int32_t) == 0)\n      random_number = arc4random();\n    entropy[i] = random_number & 0xFF;\n    random_number >>= 8;\n  }\n  i = random_number = 0;\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_sha256sum(const unsigned char *tmp, /* input */\n                                    size_t tmplen,\n                                    unsigned char *sha256sum, /* output */\n                                    size_t sha256len)\n{\n  assert(sha256len >= CURL_SHA256_DIGEST_LENGTH);\n  (void)CC_SHA256(tmp, (CC_LONG)tmplen, sha256sum);\n  return CURLE_OK;\n}\n\nstatic bool sectransp_false_start(void)\n{\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  if(SSLSetSessionOption != NULL)\n    return TRUE;\n#endif\n  return FALSE;\n}\n\nstatic ssize_t sectransp_send(struct Curl_easy *data,\n                              int sockindex,\n                              const void *mem,\n                              size_t len,\n                              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  size_t processed = 0UL;\n  OSStatus err;\n\n  /* The SSLWrite() function works a little differently than expected. The\n     fourth argument (processed) is currently documented in Apple's\n     documentation as: \"On return, the length, in bytes, of the data actually\n     written.\"\n\n     Now, one could interpret that as \"written to the socket,\" but actually,\n     it returns the amount of data that was written to a buffer internal to\n     the SSLContextRef instead. So it's possible for SSLWrite() to return\n     errSSLWouldBlock and a number of bytes \"written\" because those bytes were\n     encrypted and written to a buffer, not to the socket.\n\n     So if this happens, then we need to keep calling SSLWrite() over and\n     over again with no new data until it quits returning errSSLWouldBlock. */\n\n  /* Do we have buffered data to write from the last time we were called? */\n  if(backend->ssl_write_buffered_length) {\n    /* Write the buffered data: */\n    err = SSLWrite(backend->ssl_ctx, NULL, 0UL, &processed);\n    switch(err) {\n      case noErr:\n        /* processed is always going to be 0 because we didn't write to\n           the buffer, so return how much was written to the socket */\n        processed = backend->ssl_write_buffered_length;\n        backend->ssl_write_buffered_length = 0UL;\n        break;\n      case errSSLWouldBlock: /* argh, try again */\n        *curlcode = CURLE_AGAIN;\n        return -1L;\n      default:\n        failf(data, \"SSLWrite() returned error %d\", err);\n        *curlcode = CURLE_SEND_ERROR;\n        return -1L;\n    }\n  }\n  else {\n    /* We've got new data to write: */\n    err = SSLWrite(backend->ssl_ctx, mem, len, &processed);\n    if(err != noErr) {\n      switch(err) {\n        case errSSLWouldBlock:\n          /* Data was buffered but not sent, we have to tell the caller\n             to try sending again, and remember how much was buffered */\n          backend->ssl_write_buffered_length = len;\n          *curlcode = CURLE_AGAIN;\n          return -1L;\n        default:\n          failf(data, \"SSLWrite() returned error %d\", err);\n          *curlcode = CURLE_SEND_ERROR;\n          return -1L;\n      }\n    }\n  }\n  return (ssize_t)processed;\n}\n\nstatic ssize_t sectransp_recv(struct Curl_easy *data,\n                              int num,\n                              char *buf,\n                              size_t buffersize,\n                              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  size_t processed = 0UL;\n  OSStatus err;\n\n  again:\n  err = SSLRead(backend->ssl_ctx, buf, buffersize, &processed);\n\n  if(err != noErr) {\n    switch(err) {\n      case errSSLWouldBlock:  /* return how much we read (if anything) */\n        if(processed)\n          return (ssize_t)processed;\n        *curlcode = CURLE_AGAIN;\n        return -1L;\n        break;\n\n      /* errSSLClosedGraceful - server gracefully shut down the SSL session\n         errSSLClosedNoNotify - server hung up on us instead of sending a\n           closure alert notice, read() is returning 0\n         Either way, inform the caller that the server disconnected. */\n      case errSSLClosedGraceful:\n      case errSSLClosedNoNotify:\n        *curlcode = CURLE_OK;\n        return -1L;\n        break;\n\n        /* The below is errSSLPeerAuthCompleted; it's not defined in\n           Leopard's headers */\n      case -9841:\n        if((SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) &&\n           SSL_CONN_CONFIG(verifypeer)) {\n          CURLcode result = verify_cert(data, SSL_CONN_CONFIG(CAfile),\n                                        SSL_CONN_CONFIG(ca_info_blob),\n                                        backend->ssl_ctx);\n          if(result)\n            return result;\n        }\n        goto again;\n      default:\n        failf(data, \"SSLRead() return error %d\", err);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1L;\n        break;\n    }\n  }\n  return (ssize_t)processed;\n}\n\nstatic void *sectransp_get_internals(struct ssl_connect_data *connssl,\n                                     CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->ssl_ctx;\n}\n\nconst struct Curl_ssl Curl_ssl_sectransp = {\n  { CURLSSLBACKEND_SECURETRANSPORT, \"secure-transport\" }, /* info */\n\n  SSLSUPP_CAINFO_BLOB |\n#ifdef SECTRANSP_PINNEDPUBKEY\n  SSLSUPP_PINNEDPUBKEY,\n#else\n  0,\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n  sizeof(struct ssl_backend_data),\n\n  Curl_none_init,                     /* init */\n  Curl_none_cleanup,                  /* cleanup */\n  sectransp_version,                  /* version */\n  sectransp_check_cxn,                /* check_cxn */\n  sectransp_shutdown,                 /* shutdown */\n  sectransp_data_pending,             /* data_pending */\n  sectransp_random,                   /* random */\n  Curl_none_cert_status_request,      /* cert_status_request */\n  sectransp_connect,                  /* connect */\n  sectransp_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                   /* getsock */\n  sectransp_get_internals,            /* get_internals */\n  sectransp_close,                    /* close_one */\n  Curl_none_close_all,                /* close_all */\n  sectransp_session_free,             /* session_free */\n  Curl_none_set_engine,               /* set_engine */\n  Curl_none_set_engine_default,       /* set_engine_default */\n  Curl_none_engines_list,             /* engines_list */\n  sectransp_false_start,              /* false_start */\n  sectransp_sha256sum                 /* sha256sum */\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif /* USE_SECTRANSP */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/* This file is for implementing all \"generic\" SSL functions that all libcurl\n   internals should use. It is then responsible for calling the proper\n   \"backend\" function.\n\n   SSL-functions in libcurl should call functions in this source file, and not\n   to any specific SSL-layer.\n\n   Curl_ssl_ - prefix for generic ones\n\n   Note that this source code uses the functions of the configured SSL\n   backend via the global Curl_ssl instance.\n\n   \"SSL/TLS Strong Encryption: An Introduction\"\n   https://httpd.apache.org/docs/2.0/ssl/ssl_intro.html\n*/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#include \"urldata.h\"\n\n#include \"vtls.h\" /* generic SSL protos etc */\n#include \"slist.h\"\n#include \"sendf.h\"\n#include \"strcase.h\"\n#include \"url.h\"\n#include \"progress.h\"\n#include \"share.h\"\n#include \"multiif.h\"\n#include \"timeval.h\"\n#include \"curl_md5.h\"\n#include \"warnless.h\"\n#include \"curl_base64.h\"\n#include \"curl_printf.h\"\n#include \"strdup.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* convenience macro to check if this handle is using a shared SSL session */\n#define SSLSESSION_SHARED(data) (data->share &&                        \\\n                                 (data->share->specifier &             \\\n                                  (1<<CURL_LOCK_DATA_SSL_SESSION)))\n\n#define CLONE_STRING(var)                    \\\n  do {                                       \\\n    if(source->var) {                        \\\n      dest->var = strdup(source->var);       \\\n      if(!dest->var)                         \\\n        return FALSE;                        \\\n    }                                        \\\n    else                                     \\\n      dest->var = NULL;                      \\\n  } while(0)\n\n#define CLONE_BLOB(var)                        \\\n  do {                                         \\\n    if(blobdup(&dest->var, source->var))       \\\n      return FALSE;                            \\\n  } while(0)\n\nstatic CURLcode blobdup(struct curl_blob **dest,\n                        struct curl_blob *src)\n{\n  DEBUGASSERT(dest);\n  DEBUGASSERT(!*dest);\n  if(src) {\n    /* only if there's data to dupe! */\n    struct curl_blob *d;\n    d = malloc(sizeof(struct curl_blob) + src->len);\n    if(!d)\n      return CURLE_OUT_OF_MEMORY;\n    d->len = src->len;\n    /* Always duplicate because the connection may survive longer than the\n       handle that passed in the blob. */\n    d->flags = CURL_BLOB_COPY;\n    d->data = (void *)((char *)d + sizeof(struct curl_blob));\n    memcpy(d->data, src->data, src->len);\n    *dest = d;\n  }\n  return CURLE_OK;\n}\n\n/* returns TRUE if the blobs are identical */\nstatic bool blobcmp(struct curl_blob *first, struct curl_blob *second)\n{\n  if(!first && !second) /* both are NULL */\n    return TRUE;\n  if(!first || !second) /* one is NULL */\n    return FALSE;\n  if(first->len != second->len) /* different sizes */\n    return FALSE;\n  return !memcmp(first->data, second->data, first->len); /* same data */\n}\n\nbool\nCurl_ssl_config_matches(struct ssl_primary_config *data,\n                        struct ssl_primary_config *needle)\n{\n  if((data->version == needle->version) &&\n     (data->version_max == needle->version_max) &&\n     (data->verifypeer == needle->verifypeer) &&\n     (data->verifyhost == needle->verifyhost) &&\n     (data->verifystatus == needle->verifystatus) &&\n     blobcmp(data->cert_blob, needle->cert_blob) &&\n     blobcmp(data->ca_info_blob, needle->ca_info_blob) &&\n     Curl_safe_strcasecompare(data->CApath, needle->CApath) &&\n     Curl_safe_strcasecompare(data->CAfile, needle->CAfile) &&\n     Curl_safe_strcasecompare(data->clientcert, needle->clientcert) &&\n     Curl_safe_strcasecompare(data->random_file, needle->random_file) &&\n     Curl_safe_strcasecompare(data->egdsocket, needle->egdsocket) &&\n     Curl_safe_strcasecompare(data->cipher_list, needle->cipher_list) &&\n     Curl_safe_strcasecompare(data->cipher_list13, needle->cipher_list13) &&\n     Curl_safe_strcasecompare(data->curves, needle->curves) &&\n     Curl_safe_strcasecompare(data->pinned_key, needle->pinned_key))\n    return TRUE;\n\n  return FALSE;\n}\n\nbool\nCurl_clone_primary_ssl_config(struct ssl_primary_config *source,\n                              struct ssl_primary_config *dest)\n{\n  dest->version = source->version;\n  dest->version_max = source->version_max;\n  dest->verifypeer = source->verifypeer;\n  dest->verifyhost = source->verifyhost;\n  dest->verifystatus = source->verifystatus;\n  dest->sessionid = source->sessionid;\n\n  CLONE_BLOB(cert_blob);\n  CLONE_BLOB(ca_info_blob);\n  CLONE_STRING(CApath);\n  CLONE_STRING(CAfile);\n  CLONE_STRING(clientcert);\n  CLONE_STRING(random_file);\n  CLONE_STRING(egdsocket);\n  CLONE_STRING(cipher_list);\n  CLONE_STRING(cipher_list13);\n  CLONE_STRING(pinned_key);\n  CLONE_STRING(curves);\n\n  return TRUE;\n}\n\nvoid Curl_free_primary_ssl_config(struct ssl_primary_config *sslc)\n{\n  Curl_safefree(sslc->CApath);\n  Curl_safefree(sslc->CAfile);\n  Curl_safefree(sslc->clientcert);\n  Curl_safefree(sslc->random_file);\n  Curl_safefree(sslc->egdsocket);\n  Curl_safefree(sslc->cipher_list);\n  Curl_safefree(sslc->cipher_list13);\n  Curl_safefree(sslc->pinned_key);\n  Curl_safefree(sslc->cert_blob);\n  Curl_safefree(sslc->ca_info_blob);\n  Curl_safefree(sslc->curves);\n}\n\n#ifdef USE_SSL\nstatic int multissl_setup(const struct Curl_ssl *backend);\n#endif\n\nint Curl_ssl_backend(void)\n{\n#ifdef USE_SSL\n  multissl_setup(NULL);\n  return Curl_ssl->info.id;\n#else\n  return (int)CURLSSLBACKEND_NONE;\n#endif\n}\n\n#ifdef USE_SSL\n\n/* \"global\" init done? */\nstatic bool init_ssl = FALSE;\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nint Curl_ssl_init(void)\n{\n  /* make sure this is only done once */\n  if(init_ssl)\n    return 1;\n  init_ssl = TRUE; /* never again */\n\n  return Curl_ssl->init();\n}\n\n#if defined(CURL_WITH_MULTI_SSL)\nstatic const struct Curl_ssl Curl_ssl_multi;\n#endif\n\n/* Global cleanup */\nvoid Curl_ssl_cleanup(void)\n{\n  if(init_ssl) {\n    /* only cleanup if we did a previous init */\n    Curl_ssl->cleanup();\n#if defined(CURL_WITH_MULTI_SSL)\n    Curl_ssl = &Curl_ssl_multi;\n#endif\n    init_ssl = FALSE;\n  }\n}\n\nstatic bool ssl_prefs_check(struct Curl_easy *data)\n{\n  /* check for CURLOPT_SSLVERSION invalid parameter value */\n  const long sslver = data->set.ssl.primary.version;\n  if((sslver < 0) || (sslver >= CURL_SSLVERSION_LAST)) {\n    failf(data, \"Unrecognized parameter value passed via CURLOPT_SSLVERSION\");\n    return FALSE;\n  }\n\n  switch(data->set.ssl.primary.version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    break;\n\n  default:\n    if((data->set.ssl.primary.version_max >> 16) < sslver) {\n      failf(data, \"CURL_SSLVERSION_MAX incompatible with CURL_SSLVERSION\");\n      return FALSE;\n    }\n  }\n\n  return TRUE;\n}\n\n#ifndef CURL_DISABLE_PROXY\nstatic CURLcode\nssl_connect_init_proxy(struct connectdata *conn, int sockindex)\n{\n  DEBUGASSERT(conn->bits.proxy_ssl_connected[sockindex]);\n  if(ssl_connection_complete == conn->ssl[sockindex].state &&\n     !conn->proxy_ssl[sockindex].use) {\n    struct ssl_backend_data *pbdata;\n\n    if(!(Curl_ssl->supports & SSLSUPP_HTTPS_PROXY))\n      return CURLE_NOT_BUILT_IN;\n\n    /* The pointers to the ssl backend data, which is opaque here, are swapped\n       rather than move the contents. */\n    pbdata = conn->proxy_ssl[sockindex].backend;\n    conn->proxy_ssl[sockindex] = conn->ssl[sockindex];\n\n    memset(&conn->ssl[sockindex], 0, sizeof(conn->ssl[sockindex]));\n    memset(pbdata, 0, Curl_ssl->sizeof_ssl_backend_data);\n\n    conn->ssl[sockindex].backend = pbdata;\n  }\n  return CURLE_OK;\n}\n#endif\n\nCURLcode\nCurl_ssl_connect(struct Curl_easy *data, struct connectdata *conn,\n                 int sockindex)\n{\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_ssl_connected[sockindex]) {\n    result = ssl_connect_init_proxy(conn, sockindex);\n    if(result)\n      return result;\n  }\n#endif\n\n  if(!ssl_prefs_check(data))\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* mark this is being ssl-enabled from here on. */\n  conn->ssl[sockindex].use = TRUE;\n  conn->ssl[sockindex].state = ssl_connection_negotiating;\n\n  result = Curl_ssl->connect_blocking(data, conn, sockindex);\n\n  if(!result)\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSL is connected */\n  else\n    conn->ssl[sockindex].use = FALSE;\n\n  return result;\n}\n\nCURLcode\nCurl_ssl_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, bool *done)\n{\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_ssl_connected[sockindex]) {\n    result = ssl_connect_init_proxy(conn, sockindex);\n    if(result)\n      return result;\n  }\n#endif\n  if(!ssl_prefs_check(data))\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* mark this is being ssl requested from here on. */\n  conn->ssl[sockindex].use = TRUE;\n  result = Curl_ssl->connect_nonblocking(data, conn, sockindex, done);\n  if(result)\n    conn->ssl[sockindex].use = FALSE;\n  else if(*done)\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSL is connected */\n  return result;\n}\n\n/*\n * Lock shared SSL session data\n */\nvoid Curl_ssl_sessionid_lock(struct Curl_easy *data)\n{\n  if(SSLSESSION_SHARED(data))\n    Curl_share_lock(data, CURL_LOCK_DATA_SSL_SESSION, CURL_LOCK_ACCESS_SINGLE);\n}\n\n/*\n * Unlock shared SSL session data\n */\nvoid Curl_ssl_sessionid_unlock(struct Curl_easy *data)\n{\n  if(SSLSESSION_SHARED(data))\n    Curl_share_unlock(data, CURL_LOCK_DATA_SSL_SESSION);\n}\n\n/*\n * Check if there's a session ID for the given connection in the cache, and if\n * there's one suitable, it is provided. Returns TRUE when no entry matched.\n */\nbool Curl_ssl_getsessionid(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           const bool isProxy,\n                           void **ssl_sessionid,\n                           size_t *idsize, /* set 0 if unknown */\n                           int sockindex)\n{\n  struct Curl_ssl_session *check;\n  size_t i;\n  long *general_age;\n  bool no_match = TRUE;\n\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config * const ssl_config = isProxy ?\n    &conn->proxy_ssl_config :\n    &conn->ssl_config;\n  const char * const name = isProxy ?\n    conn->http_proxy.host.name : conn->host.name;\n  int port = isProxy ? (int)conn->port : conn->remote_port;\n#else\n  /* no proxy support */\n  struct ssl_primary_config * const ssl_config = &conn->ssl_config;\n  const char * const name = conn->host.name;\n  int port = conn->remote_port;\n#endif\n  (void)sockindex;\n  *ssl_sessionid = NULL;\n\n#ifdef CURL_DISABLE_PROXY\n  if(isProxy)\n    return TRUE;\n#endif\n\n  DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n\n  if(!SSL_SET_OPTION(primary.sessionid))\n    /* session ID re-use is disabled */\n    return TRUE;\n\n  /* Lock if shared */\n  if(SSLSESSION_SHARED(data))\n    general_age = &data->share->sessionage;\n  else\n    general_age = &data->state.sessionage;\n\n  for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++) {\n    check = &data->state.session[i];\n    if(!check->sessionid)\n      /* not session ID means blank entry */\n      continue;\n    if(strcasecompare(name, check->name) &&\n       ((!conn->bits.conn_to_host && !check->conn_to_host) ||\n        (conn->bits.conn_to_host && check->conn_to_host &&\n         strcasecompare(conn->conn_to_host.name, check->conn_to_host))) &&\n       ((!conn->bits.conn_to_port && check->conn_to_port == -1) ||\n        (conn->bits.conn_to_port && check->conn_to_port != -1 &&\n         conn->conn_to_port == check->conn_to_port)) &&\n       (port == check->remote_port) &&\n       strcasecompare(conn->handler->scheme, check->scheme) &&\n       Curl_ssl_config_matches(ssl_config, &check->ssl_config)) {\n      /* yes, we have a session ID! */\n      (*general_age)++;          /* increase general age */\n      check->age = *general_age; /* set this as used in this age */\n      *ssl_sessionid = check->sessionid;\n      if(idsize)\n        *idsize = check->idsize;\n      no_match = FALSE;\n      break;\n    }\n  }\n\n  return no_match;\n}\n\n/*\n * Kill a single session ID entry in the cache.\n */\nvoid Curl_ssl_kill_session(struct Curl_ssl_session *session)\n{\n  if(session->sessionid) {\n    /* defensive check */\n\n    /* free the ID the SSL-layer specific way */\n    Curl_ssl->session_free(session->sessionid);\n\n    session->sessionid = NULL;\n    session->age = 0; /* fresh */\n\n    Curl_free_primary_ssl_config(&session->ssl_config);\n\n    Curl_safefree(session->name);\n    Curl_safefree(session->conn_to_host);\n  }\n}\n\n/*\n * Delete the given session ID from the cache.\n */\nvoid Curl_ssl_delsessionid(struct Curl_easy *data, void *ssl_sessionid)\n{\n  size_t i;\n\n  for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++) {\n    struct Curl_ssl_session *check = &data->state.session[i];\n\n    if(check->sessionid == ssl_sessionid) {\n      Curl_ssl_kill_session(check);\n      break;\n    }\n  }\n}\n\n/*\n * Store session id in the session cache. The ID passed on to this function\n * must already have been extracted and allocated the proper way for the SSL\n * layer. Curl_XXXX_session_free() will be called to free/kill the session ID\n * later on.\n */\nCURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool isProxy,\n                               void *ssl_sessionid,\n                               size_t idsize,\n                               int sockindex)\n{\n  size_t i;\n  struct Curl_ssl_session *store = &data->state.session[0];\n  long oldest_age = data->state.session[0].age; /* zero if unused */\n  char *clone_host;\n  char *clone_conn_to_host;\n  int conn_to_port;\n  long *general_age;\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config * const ssl_config = isProxy ?\n    &conn->proxy_ssl_config :\n    &conn->ssl_config;\n  const char *hostname = isProxy ? conn->http_proxy.host.name :\n    conn->host.name;\n#else\n  struct ssl_primary_config * const ssl_config = &conn->ssl_config;\n  const char *hostname = conn->host.name;\n#endif\n  (void)sockindex;\n  DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n\n  clone_host = strdup(hostname);\n  if(!clone_host)\n    return CURLE_OUT_OF_MEMORY; /* bail out */\n\n  if(conn->bits.conn_to_host) {\n    clone_conn_to_host = strdup(conn->conn_to_host.name);\n    if(!clone_conn_to_host) {\n      free(clone_host);\n      return CURLE_OUT_OF_MEMORY; /* bail out */\n    }\n  }\n  else\n    clone_conn_to_host = NULL;\n\n  if(conn->bits.conn_to_port)\n    conn_to_port = conn->conn_to_port;\n  else\n    conn_to_port = -1;\n\n  /* Now we should add the session ID and the host name to the cache, (remove\n     the oldest if necessary) */\n\n  /* If using shared SSL session, lock! */\n  if(SSLSESSION_SHARED(data)) {\n    general_age = &data->share->sessionage;\n  }\n  else {\n    general_age = &data->state.sessionage;\n  }\n\n  /* find an empty slot for us, or find the oldest */\n  for(i = 1; (i < data->set.general_ssl.max_ssl_sessions) &&\n        data->state.session[i].sessionid; i++) {\n    if(data->state.session[i].age < oldest_age) {\n      oldest_age = data->state.session[i].age;\n      store = &data->state.session[i];\n    }\n  }\n  if(i == data->set.general_ssl.max_ssl_sessions)\n    /* cache is full, we must \"kill\" the oldest entry! */\n    Curl_ssl_kill_session(store);\n  else\n    store = &data->state.session[i]; /* use this slot */\n\n  /* now init the session struct wisely */\n  store->sessionid = ssl_sessionid;\n  store->idsize = idsize;\n  store->age = *general_age;    /* set current age */\n  /* free it if there's one already present */\n  free(store->name);\n  free(store->conn_to_host);\n  store->name = clone_host;               /* clone host name */\n  store->conn_to_host = clone_conn_to_host; /* clone connect to host name */\n  store->conn_to_port = conn_to_port; /* connect to port number */\n  /* port number */\n  store->remote_port = isProxy ? (int)conn->port : conn->remote_port;\n  store->scheme = conn->handler->scheme;\n\n  if(!Curl_clone_primary_ssl_config(ssl_config, &store->ssl_config)) {\n    Curl_free_primary_ssl_config(&store->ssl_config);\n    store->sessionid = NULL; /* let caller free sessionid */\n    free(clone_host);\n    free(clone_conn_to_host);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\n\nvoid Curl_ssl_close_all(struct Curl_easy *data)\n{\n  /* kill the session ID cache if not shared */\n  if(data->state.session && !SSLSESSION_SHARED(data)) {\n    size_t i;\n    for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++)\n      /* the single-killer function handles empty table slots */\n      Curl_ssl_kill_session(&data->state.session[i]);\n\n    /* free the cache data */\n    Curl_safefree(data->state.session);\n  }\n\n  Curl_ssl->close_all(data);\n}\n\nint Curl_ssl_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n\n  if(connssl->connecting_state == ssl_connect_2_writing) {\n    /* write mode */\n    socks[0] = conn->sock[FIRSTSOCKET];\n    return GETSOCK_WRITESOCK(0);\n  }\n  if(connssl->connecting_state == ssl_connect_2_reading) {\n    /* read mode */\n    socks[0] = conn->sock[FIRSTSOCKET];\n    return GETSOCK_READSOCK(0);\n  }\n\n  return GETSOCK_BLANK;\n}\n\nvoid Curl_ssl_close(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex)\n{\n  DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));\n  Curl_ssl->close_one(data, conn, sockindex);\n  conn->ssl[sockindex].state = ssl_connection_none;\n}\n\nCURLcode Curl_ssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(Curl_ssl->shut_down(data, conn, sockindex))\n    return CURLE_SSL_SHUTDOWN_FAILED;\n\n  conn->ssl[sockindex].use = FALSE; /* get back to ordinary socket usage */\n  conn->ssl[sockindex].state = ssl_connection_none;\n\n  conn->recv[sockindex] = Curl_recv_plain;\n  conn->send[sockindex] = Curl_send_plain;\n\n  return CURLE_OK;\n}\n\n/* Selects an SSL crypto engine\n */\nCURLcode Curl_ssl_set_engine(struct Curl_easy *data, const char *engine)\n{\n  return Curl_ssl->set_engine(data, engine);\n}\n\n/* Selects the default SSL crypto engine\n */\nCURLcode Curl_ssl_set_engine_default(struct Curl_easy *data)\n{\n  return Curl_ssl->set_engine_default(data);\n}\n\n/* Return list of OpenSSL crypto engine names. */\nstruct curl_slist *Curl_ssl_engines_list(struct Curl_easy *data)\n{\n  return Curl_ssl->engines_list(data);\n}\n\n/*\n * This sets up a session ID cache to the specified size. Make sure this code\n * is agnostic to what underlying SSL technology we use.\n */\nCURLcode Curl_ssl_initsessions(struct Curl_easy *data, size_t amount)\n{\n  struct Curl_ssl_session *session;\n\n  if(data->state.session)\n    /* this is just a precaution to prevent multiple inits */\n    return CURLE_OK;\n\n  session = calloc(amount, sizeof(struct Curl_ssl_session));\n  if(!session)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* store the info in the SSL section */\n  data->set.general_ssl.max_ssl_sessions = amount;\n  data->state.session = session;\n  data->state.sessionage = 1; /* this is brand new */\n  return CURLE_OK;\n}\n\nstatic size_t multissl_version(char *buffer, size_t size);\n\nsize_t Curl_ssl_version(char *buffer, size_t size)\n{\n#ifdef CURL_WITH_MULTI_SSL\n  return multissl_version(buffer, size);\n#else\n  return Curl_ssl->version(buffer, size);\n#endif\n}\n\n/*\n * This function tries to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nint Curl_ssl_check_cxn(struct connectdata *conn)\n{\n  return Curl_ssl->check_cxn(conn);\n}\n\nbool Curl_ssl_data_pending(const struct connectdata *conn,\n                           int connindex)\n{\n  return Curl_ssl->data_pending(conn, connindex);\n}\n\nvoid Curl_ssl_free_certinfo(struct Curl_easy *data)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n\n  if(ci->num_of_certs) {\n    /* free all individual lists used */\n    int i;\n    for(i = 0; i<ci->num_of_certs; i++) {\n      curl_slist_free_all(ci->certinfo[i]);\n      ci->certinfo[i] = NULL;\n    }\n\n    free(ci->certinfo); /* free the actual array too */\n    ci->certinfo = NULL;\n    ci->num_of_certs = 0;\n  }\n}\n\nCURLcode Curl_ssl_init_certinfo(struct Curl_easy *data, int num)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n  struct curl_slist **table;\n\n  /* Free any previous certificate information structures */\n  Curl_ssl_free_certinfo(data);\n\n  /* Allocate the required certificate information structures */\n  table = calloc((size_t) num, sizeof(struct curl_slist *));\n  if(!table)\n    return CURLE_OUT_OF_MEMORY;\n\n  ci->num_of_certs = num;\n  ci->certinfo = table;\n\n  return CURLE_OK;\n}\n\n/*\n * 'value' is NOT a null-terminated string\n */\nCURLcode Curl_ssl_push_certinfo_len(struct Curl_easy *data,\n                                    int certnum,\n                                    const char *label,\n                                    const char *value,\n                                    size_t valuelen)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n  char *output;\n  struct curl_slist *nl;\n  CURLcode result = CURLE_OK;\n  size_t labellen = strlen(label);\n  size_t outlen = labellen + 1 + valuelen + 1; /* label:value\\0 */\n\n  output = malloc(outlen);\n  if(!output)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* sprintf the label and colon */\n  msnprintf(output, outlen, \"%s:\", label);\n\n  /* memcpy the value (it might not be null-terminated) */\n  memcpy(&output[labellen + 1], value, valuelen);\n\n  /* null-terminate the output */\n  output[labellen + 1 + valuelen] = 0;\n\n  nl = Curl_slist_append_nodup(ci->certinfo[certnum], output);\n  if(!nl) {\n    free(output);\n    curl_slist_free_all(ci->certinfo[certnum]);\n    result = CURLE_OUT_OF_MEMORY;\n  }\n\n  ci->certinfo[certnum] = nl;\n  return result;\n}\n\n/*\n * This is a convenience function for push_certinfo_len that takes a zero\n * terminated value.\n */\nCURLcode Curl_ssl_push_certinfo(struct Curl_easy *data,\n                                int certnum,\n                                const char *label,\n                                const char *value)\n{\n  size_t valuelen = strlen(value);\n\n  return Curl_ssl_push_certinfo_len(data, certnum, label, value, valuelen);\n}\n\nCURLcode Curl_ssl_random(struct Curl_easy *data,\n                         unsigned char *entropy,\n                         size_t length)\n{\n  return Curl_ssl->random(data, entropy, length);\n}\n\n/*\n * Public key pem to der conversion\n */\n\nstatic CURLcode pubkey_pem_to_der(const char *pem,\n                                  unsigned char **der, size_t *der_len)\n{\n  char *stripped_pem, *begin_pos, *end_pos;\n  size_t pem_count, stripped_pem_count = 0, pem_len;\n  CURLcode result;\n\n  /* if no pem, exit. */\n  if(!pem)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  begin_pos = strstr(pem, \"-----BEGIN PUBLIC KEY-----\");\n  if(!begin_pos)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  pem_count = begin_pos - pem;\n  /* Invalid if not at beginning AND not directly following \\n */\n  if(0 != pem_count && '\\n' != pem[pem_count - 1])\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  /* 26 is length of \"-----BEGIN PUBLIC KEY-----\" */\n  pem_count += 26;\n\n  /* Invalid if not directly following \\n */\n  end_pos = strstr(pem + pem_count, \"\\n-----END PUBLIC KEY-----\");\n  if(!end_pos)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  pem_len = end_pos - pem;\n\n  stripped_pem = malloc(pem_len - pem_count + 1);\n  if(!stripped_pem)\n    return CURLE_OUT_OF_MEMORY;\n\n  /*\n   * Here we loop through the pem array one character at a time between the\n   * correct indices, and place each character that is not '\\n' or '\\r'\n   * into the stripped_pem array, which should represent the raw base64 string\n   */\n  while(pem_count < pem_len) {\n    if('\\n' != pem[pem_count] && '\\r' != pem[pem_count])\n      stripped_pem[stripped_pem_count++] = pem[pem_count];\n    ++pem_count;\n  }\n  /* Place the null terminator in the correct place */\n  stripped_pem[stripped_pem_count] = '\\0';\n\n  result = Curl_base64_decode(stripped_pem, der, der_len);\n\n  Curl_safefree(stripped_pem);\n\n  return result;\n}\n\n/*\n * Generic pinned public key check.\n */\n\nCURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,\n                              const char *pinnedpubkey,\n                              const unsigned char *pubkey, size_t pubkeylen)\n{\n  FILE *fp;\n  unsigned char *buf = NULL, *pem_ptr = NULL;\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n  if(!pubkey || !pubkeylen)\n    return result;\n\n  /* only do this if pinnedpubkey starts with \"sha256//\", length 8 */\n  if(strncmp(pinnedpubkey, \"sha256//\", 8) == 0) {\n    CURLcode encode;\n    size_t encodedlen, pinkeylen;\n    char *encoded, *pinkeycopy, *begin_pos, *end_pos;\n    unsigned char *sha256sumdigest;\n\n    if(!Curl_ssl->sha256sum) {\n      /* without sha256 support, this cannot match */\n      return result;\n    }\n\n    /* compute sha256sum of public key */\n    sha256sumdigest = malloc(CURL_SHA256_DIGEST_LENGTH);\n    if(!sha256sumdigest)\n      return CURLE_OUT_OF_MEMORY;\n    encode = Curl_ssl->sha256sum(pubkey, pubkeylen,\n                        sha256sumdigest, CURL_SHA256_DIGEST_LENGTH);\n\n    if(encode != CURLE_OK)\n      return encode;\n\n    encode = Curl_base64_encode(data, (char *)sha256sumdigest,\n                                CURL_SHA256_DIGEST_LENGTH, &encoded,\n                                &encodedlen);\n    Curl_safefree(sha256sumdigest);\n\n    if(encode)\n      return encode;\n\n    infof(data, \"\\t public key hash: sha256//%s\\n\", encoded);\n\n    /* it starts with sha256//, copy so we can modify it */\n    pinkeylen = strlen(pinnedpubkey) + 1;\n    pinkeycopy = malloc(pinkeylen);\n    if(!pinkeycopy) {\n      Curl_safefree(encoded);\n      return CURLE_OUT_OF_MEMORY;\n    }\n    memcpy(pinkeycopy, pinnedpubkey, pinkeylen);\n    /* point begin_pos to the copy, and start extracting keys */\n    begin_pos = pinkeycopy;\n    do {\n      end_pos = strstr(begin_pos, \";sha256//\");\n      /*\n       * if there is an end_pos, null terminate,\n       * otherwise it'll go to the end of the original string\n       */\n      if(end_pos)\n        end_pos[0] = '\\0';\n\n      /* compare base64 sha256 digests, 8 is the length of \"sha256//\" */\n      if(encodedlen == strlen(begin_pos + 8) &&\n         !memcmp(encoded, begin_pos + 8, encodedlen)) {\n        result = CURLE_OK;\n        break;\n      }\n\n      /*\n       * change back the null-terminator we changed earlier,\n       * and look for next begin\n       */\n      if(end_pos) {\n        end_pos[0] = ';';\n        begin_pos = strstr(end_pos, \"sha256//\");\n      }\n    } while(end_pos && begin_pos);\n    Curl_safefree(encoded);\n    Curl_safefree(pinkeycopy);\n    return result;\n  }\n\n  fp = fopen(pinnedpubkey, \"rb\");\n  if(!fp)\n    return result;\n\n  do {\n    long filesize;\n    size_t size, pem_len;\n    CURLcode pem_read;\n\n    /* Determine the file's size */\n    if(fseek(fp, 0, SEEK_END))\n      break;\n    filesize = ftell(fp);\n    if(fseek(fp, 0, SEEK_SET))\n      break;\n    if(filesize < 0 || filesize > MAX_PINNED_PUBKEY_SIZE)\n      break;\n\n    /*\n     * if the size of our certificate is bigger than the file\n     * size then it can't match\n     */\n    size = curlx_sotouz((curl_off_t) filesize);\n    if(pubkeylen > size)\n      break;\n\n    /*\n     * Allocate buffer for the pinned key\n     * With 1 additional byte for null terminator in case of PEM key\n     */\n    buf = malloc(size + 1);\n    if(!buf)\n      break;\n\n    /* Returns number of elements read, which should be 1 */\n    if((int) fread(buf, size, 1, fp) != 1)\n      break;\n\n    /* If the sizes are the same, it can't be base64 encoded, must be der */\n    if(pubkeylen == size) {\n      if(!memcmp(pubkey, buf, pubkeylen))\n        result = CURLE_OK;\n      break;\n    }\n\n    /*\n     * Otherwise we will assume it's PEM and try to decode it\n     * after placing null terminator\n     */\n    buf[size] = '\\0';\n    pem_read = pubkey_pem_to_der((const char *)buf, &pem_ptr, &pem_len);\n    /* if it wasn't read successfully, exit */\n    if(pem_read)\n      break;\n\n    /*\n     * if the size of our certificate doesn't match the size of\n     * the decoded file, they can't be the same, otherwise compare\n     */\n    if(pubkeylen == pem_len && !memcmp(pubkey, pem_ptr, pubkeylen))\n      result = CURLE_OK;\n  } while(0);\n\n  Curl_safefree(buf);\n  Curl_safefree(pem_ptr);\n  fclose(fp);\n\n  return result;\n}\n\n/*\n * Check whether the SSL backend supports the status_request extension.\n */\nbool Curl_ssl_cert_status_request(void)\n{\n  return Curl_ssl->cert_status_request();\n}\n\n/*\n * Check whether the SSL backend supports false start.\n */\nbool Curl_ssl_false_start(void)\n{\n  return Curl_ssl->false_start();\n}\n\n/*\n * Check whether the SSL backend supports setting TLS 1.3 cipher suites\n */\nbool Curl_ssl_tls13_ciphersuites(void)\n{\n  return Curl_ssl->supports & SSLSUPP_TLS13_CIPHERSUITES;\n}\n\n/*\n * Default implementations for unsupported functions.\n */\n\nint Curl_none_init(void)\n{\n  return 1;\n}\n\nvoid Curl_none_cleanup(void)\n{ }\n\nint Curl_none_shutdown(struct Curl_easy *data UNUSED_PARAM,\n                       struct connectdata *conn UNUSED_PARAM,\n                       int sockindex UNUSED_PARAM)\n{\n  (void)data;\n  (void)conn;\n  (void)sockindex;\n  return 0;\n}\n\nint Curl_none_check_cxn(struct connectdata *conn UNUSED_PARAM)\n{\n  (void)conn;\n  return -1;\n}\n\nCURLcode Curl_none_random(struct Curl_easy *data UNUSED_PARAM,\n                          unsigned char *entropy UNUSED_PARAM,\n                          size_t length UNUSED_PARAM)\n{\n  (void)data;\n  (void)entropy;\n  (void)length;\n  return CURLE_NOT_BUILT_IN;\n}\n\nvoid Curl_none_close_all(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n}\n\nvoid Curl_none_session_free(void *ptr UNUSED_PARAM)\n{\n  (void)ptr;\n}\n\nbool Curl_none_data_pending(const struct connectdata *conn UNUSED_PARAM,\n                            int connindex UNUSED_PARAM)\n{\n  (void)conn;\n  (void)connindex;\n  return 0;\n}\n\nbool Curl_none_cert_status_request(void)\n{\n  return FALSE;\n}\n\nCURLcode Curl_none_set_engine(struct Curl_easy *data UNUSED_PARAM,\n                              const char *engine UNUSED_PARAM)\n{\n  (void)data;\n  (void)engine;\n  return CURLE_NOT_BUILT_IN;\n}\n\nCURLcode Curl_none_set_engine_default(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n  return CURLE_NOT_BUILT_IN;\n}\n\nstruct curl_slist *Curl_none_engines_list(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n  return (struct curl_slist *)NULL;\n}\n\nbool Curl_none_false_start(void)\n{\n  return FALSE;\n}\n\nstatic int multissl_init(void)\n{\n  if(multissl_setup(NULL))\n    return 1;\n  return Curl_ssl->init();\n}\n\nstatic CURLcode multissl_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  if(multissl_setup(NULL))\n    return CURLE_FAILED_INIT;\n  return Curl_ssl->connect_blocking(data, conn, sockindex);\n}\n\nstatic CURLcode multissl_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  if(multissl_setup(NULL))\n    return CURLE_FAILED_INIT;\n  return Curl_ssl->connect_nonblocking(data, conn, sockindex, done);\n}\n\nstatic int multissl_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  if(multissl_setup(NULL))\n    return 0;\n  return Curl_ssl->getsock(conn, socks);\n}\n\nstatic void *multissl_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info)\n{\n  if(multissl_setup(NULL))\n    return NULL;\n  return Curl_ssl->get_internals(connssl, info);\n}\n\nstatic void multissl_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(multissl_setup(NULL))\n    return;\n  Curl_ssl->close_one(data, conn, sockindex);\n}\n\nstatic const struct Curl_ssl Curl_ssl_multi = {\n  { CURLSSLBACKEND_NONE, \"multi\" },  /* info */\n  0, /* supports nothing */\n  (size_t)-1, /* something insanely large to be on the safe side */\n\n  multissl_init,                     /* init */\n  Curl_none_cleanup,                 /* cleanup */\n  multissl_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  Curl_none_shutdown,                /* shutdown */\n  Curl_none_data_pending,            /* data_pending */\n  Curl_none_random,                  /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  multissl_connect,                  /* connect */\n  multissl_connect_nonblocking,      /* connect_nonblocking */\n  multissl_getsock,                  /* getsock */\n  multissl_get_internals,            /* get_internals */\n  multissl_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  Curl_none_session_free,            /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  NULL                               /* sha256sum */\n};\n\nconst struct Curl_ssl *Curl_ssl =\n#if defined(CURL_WITH_MULTI_SSL)\n  &Curl_ssl_multi;\n#elif defined(USE_WOLFSSL)\n  &Curl_ssl_wolfssl;\n#elif defined(USE_SECTRANSP)\n  &Curl_ssl_sectransp;\n#elif defined(USE_GNUTLS)\n  &Curl_ssl_gnutls;\n#elif defined(USE_GSKIT)\n  &Curl_ssl_gskit;\n#elif defined(USE_MBEDTLS)\n  &Curl_ssl_mbedtls;\n#elif defined(USE_NSS)\n  &Curl_ssl_nss;\n#elif defined(USE_RUSTLS)\n  &Curl_ssl_rustls;\n#elif defined(USE_OPENSSL)\n  &Curl_ssl_openssl;\n#elif defined(USE_SCHANNEL)\n  &Curl_ssl_schannel;\n#elif defined(USE_MESALINK)\n  &Curl_ssl_mesalink;\n#elif defined(USE_BEARSSL)\n  &Curl_ssl_bearssl;\n#else\n#error \"Missing struct Curl_ssl for selected SSL backend\"\n#endif\n\nstatic const struct Curl_ssl *available_backends[] = {\n#if defined(USE_WOLFSSL)\n  &Curl_ssl_wolfssl,\n#endif\n#if defined(USE_SECTRANSP)\n  &Curl_ssl_sectransp,\n#endif\n#if defined(USE_GNUTLS)\n  &Curl_ssl_gnutls,\n#endif\n#if defined(USE_GSKIT)\n  &Curl_ssl_gskit,\n#endif\n#if defined(USE_MBEDTLS)\n  &Curl_ssl_mbedtls,\n#endif\n#if defined(USE_NSS)\n  &Curl_ssl_nss,\n#endif\n#if defined(USE_OPENSSL)\n  &Curl_ssl_openssl,\n#endif\n#if defined(USE_SCHANNEL)\n  &Curl_ssl_schannel,\n#endif\n#if defined(USE_MESALINK)\n  &Curl_ssl_mesalink,\n#endif\n#if defined(USE_BEARSSL)\n  &Curl_ssl_bearssl,\n#endif\n#if defined(USE_RUSTLS)\n  &Curl_ssl_rustls,\n#endif\n  NULL\n};\n\nstatic size_t multissl_version(char *buffer, size_t size)\n{\n  static const struct Curl_ssl *selected;\n  static char backends[200];\n  static size_t backends_len;\n  const struct Curl_ssl *current;\n\n  current = Curl_ssl == &Curl_ssl_multi ? available_backends[0] : Curl_ssl;\n\n  if(current != selected) {\n    char *p = backends;\n    char *end = backends + sizeof(backends);\n    int i;\n\n    selected = current;\n\n    backends[0] = '\\0';\n\n    for(i = 0; available_backends[i]; ++i) {\n      char vb[200];\n      bool paren = (selected != available_backends[i]);\n\n      if(available_backends[i]->version(vb, sizeof(vb))) {\n        p += msnprintf(p, end - p, \"%s%s%s%s\", (p != backends ? \" \" : \"\"),\n                       (paren ? \"(\" : \"\"), vb, (paren ? \")\" : \"\"));\n      }\n    }\n\n    backends_len = p - backends;\n  }\n\n  if(!size)\n    return 0;\n\n  if(size <= backends_len) {\n    strncpy(buffer, backends, size - 1);\n    buffer[size - 1] = '\\0';\n    return size - 1;\n  }\n\n  strcpy(buffer, backends);\n  return backends_len;\n}\n\nstatic int multissl_setup(const struct Curl_ssl *backend)\n{\n  const char *env;\n  char *env_tmp;\n\n  if(Curl_ssl != &Curl_ssl_multi)\n    return 1;\n\n  if(backend) {\n    Curl_ssl = backend;\n    return 0;\n  }\n\n  if(!available_backends[0])\n    return 1;\n\n  env = env_tmp = curl_getenv(\"CURL_SSL_BACKEND\");\n#ifdef CURL_DEFAULT_SSL_BACKEND\n  if(!env)\n    env = CURL_DEFAULT_SSL_BACKEND;\n#endif\n  if(env) {\n    int i;\n    for(i = 0; available_backends[i]; i++) {\n      if(strcasecompare(env, available_backends[i]->info.name)) {\n        Curl_ssl = available_backends[i];\n        curl_free(env_tmp);\n        return 0;\n      }\n    }\n  }\n\n  /* Fall back to first available backend */\n  Curl_ssl = available_backends[0];\n  curl_free(env_tmp);\n  return 0;\n}\n\nCURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                              const curl_ssl_backend ***avail)\n{\n  int i;\n\n  if(avail)\n    *avail = (const curl_ssl_backend **)&available_backends;\n\n  if(Curl_ssl != &Curl_ssl_multi)\n    return id == Curl_ssl->info.id ||\n           (name && strcasecompare(name, Curl_ssl->info.name)) ?\n           CURLSSLSET_OK :\n#if defined(CURL_WITH_MULTI_SSL)\n           CURLSSLSET_TOO_LATE;\n#else\n           CURLSSLSET_UNKNOWN_BACKEND;\n#endif\n\n  for(i = 0; available_backends[i]; i++) {\n    if(available_backends[i]->info.id == id ||\n       (name && strcasecompare(available_backends[i]->info.name, name))) {\n      multissl_setup(available_backends[i]);\n      return CURLSSLSET_OK;\n    }\n  }\n\n  return CURLSSLSET_UNKNOWN_BACKEND;\n}\n\n#else /* USE_SSL */\nCURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                              const curl_ssl_backend ***avail)\n{\n  (void)id;\n  (void)name;\n  (void)avail;\n  return CURLSSLSET_NO_BACKENDS;\n}\n\n#endif /* !USE_SSL */\n", "#ifndef HEADER_CURL_VTLS_H\n#define HEADER_CURL_VTLS_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\nstruct connectdata;\nstruct ssl_connect_data;\n\n#define SSLSUPP_CA_PATH      (1<<0) /* supports CAPATH */\n#define SSLSUPP_CERTINFO     (1<<1) /* supports CURLOPT_CERTINFO */\n#define SSLSUPP_PINNEDPUBKEY (1<<2) /* supports CURLOPT_PINNEDPUBLICKEY */\n#define SSLSUPP_SSL_CTX      (1<<3) /* supports CURLOPT_SSL_CTX */\n#define SSLSUPP_HTTPS_PROXY  (1<<4) /* supports access via HTTPS proxies */\n#define SSLSUPP_TLS13_CIPHERSUITES (1<<5) /* supports TLS 1.3 ciphersuites */\n#define SSLSUPP_CAINFO_BLOB  (1<<6)\n\nstruct Curl_ssl {\n  /*\n   * This *must* be the first entry to allow returning the list of available\n   * backends in curl_global_sslset().\n   */\n  curl_ssl_backend info;\n  unsigned int supports; /* bitfield, see above */\n  size_t sizeof_ssl_backend_data;\n\n  int (*init)(void);\n  void (*cleanup)(void);\n\n  size_t (*version)(char *buffer, size_t size);\n  int (*check_cxn)(struct connectdata *cxn);\n  int (*shut_down)(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex);\n  bool (*data_pending)(const struct connectdata *conn,\n                       int connindex);\n\n  /* return 0 if a find random is filled in */\n  CURLcode (*random)(struct Curl_easy *data, unsigned char *entropy,\n                     size_t length);\n  bool (*cert_status_request)(void);\n\n  CURLcode (*connect_blocking)(struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex);\n  CURLcode (*connect_nonblocking)(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex,\n                                  bool *done);\n\n  /* If the SSL backend wants to read or write on this connection during a\n     handshake, set socks[0] to the connection's FIRSTSOCKET, and return\n     a bitmap indicating read or write with GETSOCK_WRITESOCK(0) or\n     GETSOCK_READSOCK(0). Otherwise return GETSOCK_BLANK.\n     Mandatory. */\n  int (*getsock)(struct connectdata *conn, curl_socket_t *socks);\n\n  void *(*get_internals)(struct ssl_connect_data *connssl, CURLINFO info);\n  void (*close_one)(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex);\n  void (*close_all)(struct Curl_easy *data);\n  void (*session_free)(void *ptr);\n\n  CURLcode (*set_engine)(struct Curl_easy *data, const char *engine);\n  CURLcode (*set_engine_default)(struct Curl_easy *data);\n  struct curl_slist *(*engines_list)(struct Curl_easy *data);\n\n  bool (*false_start)(void);\n  CURLcode (*sha256sum)(const unsigned char *input, size_t inputlen,\n                    unsigned char *sha256sum, size_t sha256sumlen);\n};\n\n#ifdef USE_SSL\nextern const struct Curl_ssl *Curl_ssl;\n#endif\n\nint Curl_none_init(void);\nvoid Curl_none_cleanup(void);\nint Curl_none_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex);\nint Curl_none_check_cxn(struct connectdata *conn);\nCURLcode Curl_none_random(struct Curl_easy *data, unsigned char *entropy,\n                          size_t length);\nvoid Curl_none_close_all(struct Curl_easy *data);\nvoid Curl_none_session_free(void *ptr);\nbool Curl_none_data_pending(const struct connectdata *conn, int connindex);\nbool Curl_none_cert_status_request(void);\nCURLcode Curl_none_set_engine(struct Curl_easy *data, const char *engine);\nCURLcode Curl_none_set_engine_default(struct Curl_easy *data);\nstruct curl_slist *Curl_none_engines_list(struct Curl_easy *data);\nbool Curl_none_false_start(void);\nbool Curl_ssl_tls13_ciphersuites(void);\n\n#include \"openssl.h\"        /* OpenSSL versions */\n#include \"gtls.h\"           /* GnuTLS versions */\n#include \"nssg.h\"           /* NSS versions */\n#include \"gskit.h\"          /* Global Secure ToolKit versions */\n#include \"wolfssl.h\"        /* wolfSSL versions */\n#include \"schannel.h\"       /* Schannel SSPI version */\n#include \"sectransp.h\"      /* SecureTransport (Darwin) version */\n#include \"mbedtls.h\"        /* mbedTLS versions */\n#include \"mesalink.h\"       /* MesaLink versions */\n#include \"bearssl.h\"        /* BearSSL versions */\n#include \"rustls.h\"         /* rustls versions */\n\n#ifndef MAX_PINNED_PUBKEY_SIZE\n#define MAX_PINNED_PUBKEY_SIZE 1048576 /* 1MB */\n#endif\n\n#ifndef CURL_SHA256_DIGEST_LENGTH\n#define CURL_SHA256_DIGEST_LENGTH 32 /* fixed size */\n#endif\n\n/* see https://www.iana.org/assignments/tls-extensiontype-values/ */\n#define ALPN_HTTP_1_1_LENGTH 8\n#define ALPN_HTTP_1_1 \"http/1.1\"\n#define ALPN_H2_LENGTH 2\n#define ALPN_H2 \"h2\"\n\n/* set of helper macros for the backends to access the correct fields. For the\n   proxy or for the remote host - to properly support HTTPS proxy */\n#ifndef CURL_DISABLE_PROXY\n#define SSL_IS_PROXY()                                                  \\\n  (CURLPROXY_HTTPS == conn->http_proxy.proxytype &&                     \\\n   ssl_connection_complete !=                                           \\\n   conn->proxy_ssl[conn->sock[SECONDARYSOCKET] ==                       \\\n                   CURL_SOCKET_BAD ? FIRSTSOCKET : SECONDARYSOCKET].state)\n#define SSL_SET_OPTION(var)                                             \\\n  (SSL_IS_PROXY() ? data->set.proxy_ssl.var : data->set.ssl.var)\n#define SSL_SET_OPTION_LVALUE(var)                                      \\\n  (*(SSL_IS_PROXY() ? &data->set.proxy_ssl.var : &data->set.ssl.var))\n#define SSL_CONN_CONFIG(var)                                            \\\n  (SSL_IS_PROXY() ? conn->proxy_ssl_config.var : conn->ssl_config.var)\n#define SSL_HOST_NAME()                                                 \\\n  (SSL_IS_PROXY() ? conn->http_proxy.host.name : conn->host.name)\n#define SSL_HOST_DISPNAME()                                             \\\n  (SSL_IS_PROXY() ? conn->http_proxy.host.dispname : conn->host.dispname)\n#define SSL_HOST_PORT()                                                 \\\n  (SSL_IS_PROXY() ? conn->port : conn->remote_port)\n#define SSL_PINNED_PUB_KEY() (SSL_IS_PROXY()                            \\\n  ? data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]                     \\\n  : data->set.str[STRING_SSL_PINNEDPUBLICKEY])\n#else\n#define SSL_IS_PROXY() FALSE\n#define SSL_SET_OPTION(var) data->set.ssl.var\n#define SSL_SET_OPTION_LVALUE(var) data->set.ssl.var\n#define SSL_CONN_CONFIG(var) conn->ssl_config.var\n#define SSL_HOST_NAME() conn->host.name\n#define SSL_HOST_DISPNAME() conn->host.dispname\n#define SSL_HOST_PORT() conn->remote_port\n#define SSL_PINNED_PUB_KEY()                                            \\\n  data->set.str[STRING_SSL_PINNEDPUBLICKEY]\n#endif\n\nbool Curl_ssl_config_matches(struct ssl_primary_config *data,\n                             struct ssl_primary_config *needle);\nbool Curl_clone_primary_ssl_config(struct ssl_primary_config *source,\n                                   struct ssl_primary_config *dest);\nvoid Curl_free_primary_ssl_config(struct ssl_primary_config *sslc);\n/* An implementation of the getsock field of Curl_ssl that relies\n   on the ssl_connect_state enum. Asks for read or write depending\n   on whether conn->state is ssl_connect_2_reading or\n   ssl_connect_2_writing. */\nint Curl_ssl_getsock(struct connectdata *conn, curl_socket_t *socks);\n\nint Curl_ssl_backend(void);\n\n#ifdef USE_SSL\nint Curl_ssl_init(void);\nvoid Curl_ssl_cleanup(void);\nCURLcode Curl_ssl_connect(struct Curl_easy *data, struct connectdata *conn,\n                          int sockindex);\nCURLcode Curl_ssl_connect_nonblocking(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex,\n                                      bool *done);\n/* tell the SSL stuff to close down all open information regarding\n   connections (and thus session ID caching etc) */\nvoid Curl_ssl_close_all(struct Curl_easy *data);\nvoid Curl_ssl_close(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex);\nCURLcode Curl_ssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex);\nCURLcode Curl_ssl_set_engine(struct Curl_easy *data, const char *engine);\n/* Sets engine as default for all SSL operations */\nCURLcode Curl_ssl_set_engine_default(struct Curl_easy *data);\nstruct curl_slist *Curl_ssl_engines_list(struct Curl_easy *data);\n\n/* init the SSL session ID cache */\nCURLcode Curl_ssl_initsessions(struct Curl_easy *, size_t);\nsize_t Curl_ssl_version(char *buffer, size_t size);\nbool Curl_ssl_data_pending(const struct connectdata *conn,\n                           int connindex);\nint Curl_ssl_check_cxn(struct connectdata *conn);\n\n/* Certificate information list handling. */\n\nvoid Curl_ssl_free_certinfo(struct Curl_easy *data);\nCURLcode Curl_ssl_init_certinfo(struct Curl_easy *data, int num);\nCURLcode Curl_ssl_push_certinfo_len(struct Curl_easy *data, int certnum,\n                                    const char *label, const char *value,\n                                    size_t valuelen);\nCURLcode Curl_ssl_push_certinfo(struct Curl_easy *data, int certnum,\n                                const char *label, const char *value);\n\n/* Functions to be used by SSL library adaptation functions */\n\n/* Lock session cache mutex.\n * Call this before calling other Curl_ssl_*session* functions\n * Caller should unlock this mutex as soon as possible, as it may block\n * other SSL connection from making progress.\n * The purpose of explicitly locking SSL session cache data is to allow\n * individual SSL engines to manage session lifetime in their specific way.\n */\nvoid Curl_ssl_sessionid_lock(struct Curl_easy *data);\n\n/* Unlock session cache mutex */\nvoid Curl_ssl_sessionid_unlock(struct Curl_easy *data);\n\n/* extract a session ID\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * Caller must make sure that the ownership of returned sessionid object\n * is properly taken (e.g. its refcount is incremented\n * under sessionid mutex).\n */\nbool Curl_ssl_getsessionid(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           const bool isproxy,\n                           void **ssl_sessionid,\n                           size_t *idsize, /* set 0 if unknown */\n                           int sockindex);\n/* add a new session ID\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * Caller must ensure that it has properly shared ownership of this sessionid\n * object with cache (e.g. incrementing refcount on success)\n */\nCURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               const bool isProxy,\n                               void *ssl_sessionid,\n                               size_t idsize,\n                               int sockindex);\n/* Kill a single session ID entry in the cache\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * This will call engine-specific curlssl_session_free function, which must\n * take sessionid object ownership from sessionid cache\n * (e.g. decrement refcount).\n */\nvoid Curl_ssl_kill_session(struct Curl_ssl_session *session);\n/* delete a session from the cache\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * This will call engine-specific curlssl_session_free function, which must\n * take sessionid object ownership from sessionid cache\n * (e.g. decrement refcount).\n */\nvoid Curl_ssl_delsessionid(struct Curl_easy *data, void *ssl_sessionid);\n\n/* get N random bytes into the buffer */\nCURLcode Curl_ssl_random(struct Curl_easy *data, unsigned char *buffer,\n                         size_t length);\n/* Check pinned public key. */\nCURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,\n                              const char *pinnedpubkey,\n                              const unsigned char *pubkey, size_t pubkeylen);\n\nbool Curl_ssl_cert_status_request(void);\n\nbool Curl_ssl_false_start(void);\n\n#define SSL_SHUTDOWN_TIMEOUT 10000 /* ms */\n\n#else /* if not USE_SSL */\n\n/* When SSL support is not present, just define away these function calls */\n#define Curl_ssl_init() 1\n#define Curl_ssl_cleanup() Curl_nop_stmt\n#define Curl_ssl_connect(x,y,z) CURLE_NOT_BUILT_IN\n#define Curl_ssl_close_all(x) Curl_nop_stmt\n#define Curl_ssl_close(x,y,z) Curl_nop_stmt\n#define Curl_ssl_shutdown(x,y,z) CURLE_NOT_BUILT_IN\n#define Curl_ssl_set_engine(x,y) CURLE_NOT_BUILT_IN\n#define Curl_ssl_set_engine_default(x) CURLE_NOT_BUILT_IN\n#define Curl_ssl_engines_list(x) NULL\n#define Curl_ssl_send(a,b,c,d,e) -1\n#define Curl_ssl_recv(a,b,c,d,e) -1\n#define Curl_ssl_initsessions(x,y) CURLE_OK\n#define Curl_ssl_data_pending(x,y) 0\n#define Curl_ssl_check_cxn(x) 0\n#define Curl_ssl_free_certinfo(x) Curl_nop_stmt\n#define Curl_ssl_connect_nonblocking(x,y,z,w) CURLE_NOT_BUILT_IN\n#define Curl_ssl_kill_session(x) Curl_nop_stmt\n#define Curl_ssl_random(x,y,z) ((void)x, CURLE_NOT_BUILT_IN)\n#define Curl_ssl_cert_status_request() FALSE\n#define Curl_ssl_false_start() FALSE\n#define Curl_ssl_tls13_ciphersuites() FALSE\n#endif\n\n#endif /* HEADER_CURL_VTLS_H */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all wolfSSL specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_WOLFSSL\n\n#define WOLFSSL_OPTIONS_IGNORE_SYS\n#include <wolfssl/version.h>\n#include <wolfssl/options.h>\n\n/* To determine what functions are available we rely on one or both of:\n   - the user's options.h generated by wolfSSL\n   - the symbols detected by curl's configure\n   Since they are markedly different from one another, and one or the other may\n   not be available, we do some checking below to bring things in sync. */\n\n/* HAVE_ALPN is wolfSSL's build time symbol for enabling ALPN in options.h. */\n#ifndef HAVE_ALPN\n#ifdef HAVE_WOLFSSL_USEALPN\n#define HAVE_ALPN\n#endif\n#endif\n\n#include <limits.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"vtls.h\"\n#include \"keylog.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n\n#include <wolfssl/openssl/ssl.h>\n#include <wolfssl/ssl.h>\n#include <wolfssl/error-ssl.h>\n#include \"wolfssl.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* KEEP_PEER_CERT is a product of the presence of build time symbol\n   OPENSSL_EXTRA without NO_CERTS, depending on the version. KEEP_PEER_CERT is\n   in wolfSSL's settings.h, and the latter two are build time symbols in\n   options.h. */\n#ifndef KEEP_PEER_CERT\n#if defined(HAVE_WOLFSSL_GET_PEER_CERTIFICATE) || \\\n    (defined(OPENSSL_EXTRA) && !defined(NO_CERTS))\n#define KEEP_PEER_CERT\n#endif\n#endif\n\nstruct ssl_backend_data {\n  SSL_CTX* ctx;\n  SSL*     handle;\n};\n\nstatic Curl_recv wolfssl_recv;\nstatic Curl_send wolfssl_send;\n\n#ifdef OPENSSL_EXTRA\n/*\n * Availability note:\n * The TLS 1.3 secret callback (wolfSSL_set_tls13_secret_cb) was added in\n * WolfSSL 4.4.0, but requires the -DHAVE_SECRET_CALLBACK build option. If that\n * option is not set, then TLS 1.3 will not be logged.\n * For TLS 1.2 and before, we use wolfSSL_get_keys().\n * SSL_get_client_random and wolfSSL_get_keys require OPENSSL_EXTRA\n * (--enable-opensslextra or --enable-all).\n */\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\nstatic int\nwolfssl_tls13_secret_callback(SSL *ssl, int id, const unsigned char *secret,\n                              int secretSz, void *ctx)\n{\n  const char *label;\n  unsigned char client_random[SSL3_RANDOM_SIZE];\n  (void)ctx;\n\n  if(!ssl || !Curl_tls_keylog_enabled()) {\n    return 0;\n  }\n\n  switch(id) {\n  case CLIENT_EARLY_TRAFFIC_SECRET:\n    label = \"CLIENT_EARLY_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case SERVER_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"SERVER_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_TRAFFIC_SECRET:\n    label = \"CLIENT_TRAFFIC_SECRET_0\";\n    break;\n  case SERVER_TRAFFIC_SECRET:\n    label = \"SERVER_TRAFFIC_SECRET_0\";\n    break;\n  case EARLY_EXPORTER_SECRET:\n    label = \"EARLY_EXPORTER_SECRET\";\n    break;\n  case EXPORTER_SECRET:\n    label = \"EXPORTER_SECRET\";\n    break;\n  default:\n    return 0;\n  }\n\n  if(SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE) == 0) {\n    /* Should never happen as wolfSSL_KeepArrays() was called before. */\n    return 0;\n  }\n\n  Curl_tls_keylog_write(label, client_random, secret, secretSz);\n  return 0;\n}\n#endif /* defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13) */\n\nstatic void\nwolfssl_log_tls12_secret(SSL *ssl)\n{\n  unsigned char *ms, *sr, *cr;\n  unsigned int msLen, srLen, crLen, i, x = 0;\n\n#if LIBWOLFSSL_VERSION_HEX >= 0x0300d000 /* >= 3.13.0 */\n  /* wolfSSL_GetVersion is available since 3.13, we use it instead of\n   * SSL_version since the latter relies on OPENSSL_ALL (--enable-opensslall or\n   * --enable-all). Failing to perform this check could result in an unusable\n   * key log line when TLS 1.3 is actually negotiated. */\n  switch(wolfSSL_GetVersion(ssl)) {\n  case WOLFSSL_SSLV3:\n  case WOLFSSL_TLSV1:\n  case WOLFSSL_TLSV1_1:\n  case WOLFSSL_TLSV1_2:\n    break;\n  default:\n    /* TLS 1.3 does not use this mechanism, the \"master secret\" returned below\n     * is not directly usable. */\n    return;\n  }\n#endif\n\n  if(SSL_get_keys(ssl, &ms, &msLen, &sr, &srLen, &cr, &crLen) != SSL_SUCCESS) {\n    return;\n  }\n\n  /* Check for a missing master secret and skip logging. That can happen if\n   * curl rejects the server certificate and aborts the handshake.\n   */\n  for(i = 0; i < msLen; i++) {\n    x |= ms[i];\n  }\n  if(x == 0) {\n    return;\n  }\n\n  Curl_tls_keylog_write(\"CLIENT_RANDOM\", cr, ms, msLen);\n}\n#endif /* OPENSSL_EXTRA */\n\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  return -1;\n}\n\n/*\n * This function loads all the client/CA certificates and CRLs. Setup the TLS\n * layer and do all necessary magic.\n */\nstatic CURLcode\nwolfssl_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  char *ciphers;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  SSL_METHOD* req_method = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n#ifdef HAVE_SNI\n  bool sni = FALSE;\n#define use_sni(x)  sni = (x)\n#else\n#define use_sni(x)  Curl_nop_stmt\n#endif\n\n  if(connssl->state == ssl_connection_complete)\n    return CURLE_OK;\n\n  if(SSL_CONN_CONFIG(version_max) != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"wolfSSL does not support to set maximum SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX >= 0x03003000 /* >= 3.3.0 */\n    /* minimum protocol version is set later after the CTX object is created */\n    req_method = SSLv23_client_method();\n#else\n    infof(data, \"wolfSSL <3.3.0 cannot be configured to use TLS 1.0-1.2, \"\n          \"TLS 1.0 is used exclusively\\n\");\n    req_method = TLSv1_client_method();\n#endif\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n#if defined(WOLFSSL_ALLOW_TLSV10) && !defined(NO_OLD_TLS)\n    req_method = TLSv1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.0\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n#ifndef NO_OLD_TLS\n    req_method = TLSv1_1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.1\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    req_method = TLSv1_2_client_method();\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_TLSv1_3:\n#ifdef WOLFSSL_TLS13\n    req_method = wolfTLSv1_3_client_method();\n    use_sni(TRUE);\n    break;\n#else\n    failf(data, \"wolfSSL: TLS 1.3 is not yet supported\");\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(!req_method) {\n    failf(data, \"SSL: couldn't create a method!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(backend->ctx)\n    SSL_CTX_free(backend->ctx);\n  backend->ctx = SSL_CTX_new(req_method);\n\n  if(!backend->ctx) {\n    failf(data, \"SSL: couldn't create a context!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX > 0x03004006 /* > 3.4.6 */\n    /* Versions 3.3.0 to 3.4.6 we know the minimum protocol version is\n     * whatever minimum version of TLS was built in and at least TLS 1.0. For\n     * later library versions that could change (eg TLS 1.0 built in but\n     * defaults to TLS 1.1) so we have this short circuit evaluation to find\n     * the minimum supported TLS version.\n    */\n    if((wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_2) != 1)\n#ifdef WOLFSSL_TLS13\n       && (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_3) != 1)\n#endif\n      ) {\n      failf(data, \"SSL: couldn't set the minimum protocol version\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif\n    break;\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n#ifndef NO_FILESYSTEM\n  /* load trusted cacert */\n  if(SSL_CONN_CONFIG(CAfile)) {\n    if(1 != SSL_CTX_load_verify_locations(backend->ctx,\n                                      SSL_CONN_CONFIG(CAfile),\n                                      SSL_CONN_CONFIG(CApath))) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        /* Fail if we insist on successfully verifying the server. */\n        failf(data, \"error setting certificate verify locations:\"\n              \" CAfile: %s CApath: %s\",\n              SSL_CONN_CONFIG(CAfile)?\n              SSL_CONN_CONFIG(CAfile): \"none\",\n              SSL_CONN_CONFIG(CApath)?\n              SSL_CONN_CONFIG(CApath) : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"error setting certificate verify locations,\"\n              \" continuing anyway:\\n\");\n      }\n    }\n    else {\n      /* Everything is fine. */\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\",\n          SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile) : \"none\");\n    infof(data, \" CApath: %s\\n\",\n          SSL_CONN_CONFIG(CApath) ? SSL_CONN_CONFIG(CApath) : \"none\");\n  }\n\n  /* Load the client certificate, and private key */\n  if(SSL_SET_OPTION(primary.clientcert) && SSL_SET_OPTION(key)) {\n    int file_type = do_file_type(SSL_SET_OPTION(cert_type));\n\n    if(SSL_CTX_use_certificate_file(backend->ctx,\n                                    SSL_SET_OPTION(primary.clientcert),\n                                    file_type) != 1) {\n      failf(data, \"unable to use client certificate (no key or wrong pass\"\n            \" phrase?)\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    file_type = do_file_type(SSL_SET_OPTION(key_type));\n    if(SSL_CTX_use_PrivateKey_file(backend->ctx, SSL_SET_OPTION(key),\n                                    file_type) != 1) {\n      failf(data, \"unable to set private key\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* !NO_FILESYSTEM */\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n  SSL_CTX_set_verify(backend->ctx,\n                     SSL_CONN_CONFIG(verifypeer)?SSL_VERIFY_PEER:\n                                                 SSL_VERIFY_NONE,\n                     NULL);\n\n#ifdef HAVE_SNI\n  if(sni) {\n    struct in_addr addr4;\n#ifdef ENABLE_IPV6\n    struct in6_addr addr6;\n#endif\n    const char * const hostname = SSL_HOST_NAME();\n    size_t hostname_len = strlen(hostname);\n    if((hostname_len < USHRT_MAX) &&\n       (0 == Curl_inet_pton(AF_INET, hostname, &addr4)) &&\n#ifdef ENABLE_IPV6\n       (0 == Curl_inet_pton(AF_INET6, hostname, &addr6)) &&\n#endif\n       (wolfSSL_CTX_UseSNI(backend->ctx, WOLFSSL_SNI_HOST_NAME, hostname,\n                          (unsigned short)hostname_len) != 1)) {\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n    }\n  }\n#endif\n\n  /* give application a chance to interfere with SSL set up. */\n  if(data->set.ssl.fsslctx) {\n    CURLcode result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n                                               data->set.ssl.fsslctxp);\n    if(result) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return result;\n    }\n  }\n#ifdef NO_FILESYSTEM\n  else if(SSL_CONN_CONFIG(verifypeer)) {\n    failf(data, \"SSL: Certificates can't be loaded because wolfSSL was built\"\n          \" with \\\"no filesystem\\\". Either disable peer verification\"\n          \" (insecure) or if you are building an application with libcurl you\"\n          \" can load certificates via CURLOPT_SSL_CTX_FUNCTION.\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif\n\n  /* Let's make an SSL structure */\n  if(backend->handle)\n    SSL_free(backend->handle);\n  backend->handle = SSL_new(backend->ctx);\n  if(!backend->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifdef HAVE_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    char protocols[128];\n    *protocols = '\\0';\n\n    /* wolfSSL's ALPN protocol name list format is a comma separated string of\n       protocols in descending order of preference, eg: \"h2,http/1.1\" */\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      strcpy(protocols + strlen(protocols), ALPN_H2 \",\");\n      infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    strcpy(protocols + strlen(protocols), ALPN_HTTP_1_1);\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    if(wolfSSL_UseALPN(backend->handle, protocols,\n                       (unsigned)strlen(protocols),\n                       WOLFSSL_ALPN_CONTINUE_ON_MISMATCH) != SSL_SUCCESS) {\n      failf(data, \"SSL: failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* HAVE_ALPN */\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* Ensure the Client Random is preserved. */\n    wolfSSL_KeepArrays(backend->handle);\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\n    wolfSSL_set_tls13_secret_cb(backend->handle,\n                                wolfssl_tls13_secret_callback, NULL);\n#endif\n  }\n#endif /* OPENSSL_EXTRA */\n\n#ifdef HAVE_SECURE_RENEGOTIATION\n  if(wolfSSL_UseSecureRenegotiation(backend->handle) != SSL_SUCCESS) {\n    failf(data, \"SSL: failed setting secure renegotiation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* HAVE_SECURE_RENEGOTIATION */\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ERR_error_string(SSL_get_error(backend->handle, 0),\n                               error_buffer));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  /* pass the raw socket into the SSL layer */\n  if(!SSL_set_fd(backend->handle, (int)sockfd)) {\n    failf(data, \"SSL: SSL_set_fd failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  int ret = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const char * const hostname = SSL_HOST_NAME();\n  const char * const dispname = SSL_HOST_DISPNAME();\n  const char * const pinnedpubkey = SSL_PINNED_PUB_KEY();\n\n  conn->recv[sockindex] = wolfssl_recv;\n  conn->send[sockindex] = wolfssl_send;\n\n  /* Enable RFC2818 checks */\n  if(SSL_CONN_CONFIG(verifyhost)) {\n    ret = wolfSSL_check_domain_name(backend->handle, hostname);\n    if(ret == SSL_FAILURE)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  ret = SSL_connect(backend->handle);\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* If key logging is enabled, wait for the handshake to complete and then\n     * proceed with logging secrets (for TLS 1.2 or older).\n     *\n     * During the handshake (ret==-1), wolfSSL_want_read() is true as it waits\n     * for the server response. At that point the master secret is not yet\n     * available, so we must not try to read it.\n     * To log the secret on completion with a handshake failure, detect\n     * completion via the observation that there is nothing to read or write.\n     * Note that OpenSSL SSL_want_read() is always true here. If wolfSSL ever\n     * changes, the worst case is that no key is logged on error.\n     */\n    if(ret == SSL_SUCCESS ||\n       (!wolfSSL_want_read(backend->handle) &&\n        !wolfSSL_want_write(backend->handle))) {\n      wolfssl_log_tls12_secret(backend->handle);\n      /* Client Random and master secrets are no longer needed, erase these.\n       * Ignored while the handshake is still in progress. */\n      wolfSSL_FreeArrays(backend->handle);\n    }\n  }\n#endif  /* OPENSSL_EXTRA */\n\n  if(ret != 1) {\n    char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n    int  detail = SSL_get_error(backend->handle, ret);\n\n    if(SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    else if(SSL_ERROR_WANT_WRITE == detail) {\n      connssl->connecting_state = ssl_connect_2_writing;\n      return CURLE_OK;\n    }\n    /* There is no easy way to override only the CN matching.\n     * This will enable the override of both mismatching SubjectAltNames\n     * as also mismatching CN fields */\n    else if(DOMAIN_NAME_MISMATCH == detail) {\n#if 1\n      failf(data, \"\\tsubject alt name(s) or common name do not match \\\"%s\\\"\",\n            dispname);\n      return CURLE_PEER_FAILED_VERIFICATION;\n#else\n      /* When the wolfssl_check_domain_name() is used and you desire to\n       * continue on a DOMAIN_NAME_MISMATCH, i.e. 'conn->ssl_config.verifyhost\n       * == 0', CyaSSL version 2.4.0 will fail with an INCOMPLETE_DATA\n       * error. The only way to do this is currently to switch the\n       * Wolfssl_check_domain_name() in and out based on the\n       * 'conn->ssl_config.verifyhost' value. */\n      if(SSL_CONN_CONFIG(verifyhost)) {\n        failf(data,\n              \"\\tsubject alt name(s) or common name do not match \\\"%s\\\"\\n\",\n              dispname);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else {\n        infof(data,\n              \"\\tsubject alt name(s) and/or common name do not match \\\"%s\\\"\\n\",\n              dispname);\n        return CURLE_OK;\n      }\n#endif\n    }\n#if LIBWOLFSSL_VERSION_HEX >= 0x02007000 /* 2.7.0 */\n    else if(ASN_NO_SIGNER_E == detail) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"\\tCA signer not available for verification\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"CA signer not available for verification, \"\n                    \"continuing anyway\\n\");\n      }\n    }\n#endif\n    else {\n      failf(data, \"SSL_connect failed with error %d: %s\", detail,\n          ERR_error_string(detail, error_buffer));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  if(pinnedpubkey) {\n#ifdef KEEP_PEER_CERT\n    X509 *x509;\n    const char *x509_der;\n    int x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n    CURLcode result;\n\n    x509 = SSL_get_peer_certificate(backend->handle);\n    if(!x509) {\n      failf(data, \"SSL: failed retrieving server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    x509_der = (const char *)wolfSSL_X509_get_der(x509, &x509_der_len);\n    if(!x509_der) {\n      failf(data, \"SSL: failed retrieving ASN.1 server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n#else\n    failf(data, \"Library lacks pinning support built-in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n#ifdef HAVE_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    int rc;\n    char *protocol = NULL;\n    unsigned short protocol_len = 0;\n\n    rc = wolfSSL_ALPN_GetProtocol(backend->handle, &protocol, &protocol_len);\n\n    if(rc == SSL_SUCCESS) {\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", protocol_len,\n            protocol);\n\n      if(protocol_len == ALPN_HTTP_1_1_LENGTH &&\n         !memcmp(protocol, ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH))\n        conn->negnpn = CURL_HTTP_VERSION_1_1;\n#ifdef USE_HTTP2\n      else if(data->state.httpwant >= CURL_HTTP_VERSION_2 &&\n              protocol_len == ALPN_H2_LENGTH &&\n              !memcmp(protocol, ALPN_H2, ALPN_H2_LENGTH))\n        conn->negnpn = CURL_HTTP_VERSION_2;\n#endif\n      else\n        infof(data, \"ALPN, unrecognized protocol %.*s\\n\", protocol_len,\n              protocol);\n      Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                          BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n    }\n    else if(rc == SSL_ALPN_NOT_FOUND)\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    else {\n      failf(data, \"ALPN, failure getting protocol, error %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* HAVE_ALPN */\n\n  connssl->connecting_state = ssl_connect_3;\n#if (LIBWOLFSSL_VERSION_HEX >= 0x03009010)\n  infof(data, \"SSL connection using %s / %s\\n\",\n        wolfSSL_get_version(backend->handle),\n        wolfSSL_get_cipher_name(backend->handle));\n#else\n  infof(data, \"SSL connected\\n\");\n#endif\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    SSL_SESSION *our_ssl_sessionid = SSL_get_session(backend->handle);\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    if(our_ssl_sessionid) {\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                        &old_ssl_sessionid, NULL, sockindex));\n      if(incache) {\n        if(old_ssl_sessionid != our_ssl_sessionid) {\n          infof(data, \"old SSL session ID is stale, removing\\n\");\n          Curl_ssl_delsessionid(data, old_ssl_sessionid);\n          incache = FALSE;\n        }\n      }\n\n      if(!incache) {\n        result = Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid,\n                                       0, sockindex);\n        if(result) {\n          Curl_ssl_sessionid_unlock(data);\n          failf(data, \"failed to store ssl session\");\n          return result;\n        }\n      }\n      Curl_ssl_sessionid_unlock(data);\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\n\nstatic ssize_t wolfssl_send(struct Curl_easy *data,\n                            int sockindex,\n                            const void *mem,\n                            size_t len,\n                            CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  int rc = SSL_write(backend->handle, mem, memlen);\n\n  if(rc <= 0) {\n    int err = SSL_get_error(backend->handle, rc);\n\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_write() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data, \"SSL write: %s, errno %d\",\n            ERR_error_string(err, error_buffer),\n            SOCKERRNO);\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n  return rc;\n}\n\nstatic void wolfssl_close(struct Curl_easy *data, struct connectdata *conn,\n                          int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->handle) {\n    (void)SSL_shutdown(backend->handle);\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  if(backend->ctx) {\n    SSL_CTX_free(backend->ctx);\n    backend->ctx = NULL;\n  }\n}\n\nstatic ssize_t wolfssl_recv(struct Curl_easy *data,\n                            int num,\n                            char *buf,\n                            size_t buffersize,\n                            CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  int nread = SSL_read(backend->handle, buf, buffsize);\n\n  if(nread < 0) {\n    int err = SSL_get_error(backend->handle, nread);\n\n    switch(err) {\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data, \"SSL read: %s, errno %d\",\n            ERR_error_string(err, error_buffer), SOCKERRNO);\n      *curlcode = CURLE_RECV_ERROR;\n      return -1;\n    }\n  }\n  return nread;\n}\n\n\nstatic void wolfssl_session_free(void *ptr)\n{\n  (void)ptr;\n  /* wolfSSL reuses sessions on own, no free */\n}\n\n\nstatic size_t wolfssl_version(char *buffer, size_t size)\n{\n#if LIBWOLFSSL_VERSION_HEX >= 0x03006000\n  return msnprintf(buffer, size, \"wolfSSL/%s\", wolfSSL_lib_version());\n#elif defined(WOLFSSL_VERSION)\n  return msnprintf(buffer, size, \"wolfSSL/%s\", WOLFSSL_VERSION);\n#endif\n}\n\n\nstatic int wolfssl_init(void)\n{\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_open();\n#endif\n  return (wolfSSL_Init() == SSL_SUCCESS);\n}\n\n\nstatic void wolfssl_cleanup(void)\n{\n  wolfSSL_Cleanup();\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_close();\n#endif\n}\n\n\nstatic bool wolfssl_data_pending(const struct connectdata *conn,\n                                 int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->handle)   /* SSL is in use */\n    return (0 != SSL_pending(backend->handle)) ? TRUE : FALSE;\n  else\n    return FALSE;\n}\n\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int wolfssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->handle) {\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  return retval;\n}\n\n\nstatic CURLcode\nwolfssl_connect_common(struct Curl_easy *data,\n                      struct connectdata *conn,\n                      int sockindex,\n                      bool nonblocking,\n                      bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = wolfssl_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = wolfssl_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = wolfssl_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = wolfssl_recv;\n    conn->send[sockindex] = wolfssl_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode wolfssl_connect_nonblocking(struct Curl_easy *data,\n                                            struct connectdata *conn,\n                                            int sockindex, bool *done)\n{\n  return wolfssl_connect_common(data, conn, sockindex, TRUE, done);\n}\n\n\nstatic CURLcode wolfssl_connect(struct Curl_easy *data,\n                                struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = wolfssl_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n  WC_RNG rng;\n  (void)data;\n  if(wc_InitRng(&rng))\n    return CURLE_FAILED_INIT;\n  if(length > UINT_MAX)\n    return CURLE_FAILED_INIT;\n  if(wc_RNG_GenerateBlock(&rng, entropy, (unsigned)length))\n    return CURLE_FAILED_INIT;\n  if(wc_FreeRng(&rng))\n    return CURLE_FAILED_INIT;\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_sha256sum(const unsigned char *tmp, /* input */\n                                  size_t tmplen,\n                                  unsigned char *sha256sum /* output */,\n                                  size_t unused)\n{\n  wc_Sha256 SHA256pw;\n  (void)unused;\n  wc_InitSha256(&SHA256pw);\n  wc_Sha256Update(&SHA256pw, tmp, (word32)tmplen);\n  wc_Sha256Final(&SHA256pw, sha256sum);\n  return CURLE_OK;\n}\n\nstatic void *wolfssl_get_internals(struct ssl_connect_data *connssl,\n                                        CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_wolfssl = {\n  { CURLSSLBACKEND_WOLFSSL, \"WolfSSL\" }, /* info */\n\n#ifdef KEEP_PEER_CERT\n  SSLSUPP_PINNEDPUBKEY |\n#endif\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  wolfssl_init,                    /* init */\n  wolfssl_cleanup,                 /* cleanup */\n  wolfssl_version,                 /* version */\n  Curl_none_check_cxn,             /* check_cxn */\n  wolfssl_shutdown,                /* shutdown */\n  wolfssl_data_pending,            /* data_pending */\n  wolfssl_random,                  /* random */\n  Curl_none_cert_status_request,   /* cert_status_request */\n  wolfssl_connect,                 /* connect */\n  wolfssl_connect_nonblocking,     /* connect_nonblocking */\n  Curl_ssl_getsock,                /* getsock */\n  wolfssl_get_internals,           /* get_internals */\n  wolfssl_close,                   /* close_one */\n  Curl_none_close_all,             /* close_all */\n  wolfssl_session_free,            /* session_free */\n  Curl_none_set_engine,            /* set_engine */\n  Curl_none_set_engine_default,    /* set_engine_default */\n  Curl_none_engines_list,          /* engines_list */\n  Curl_none_false_start,           /* false_start */\n  wolfssl_sha256sum                /* sha256sum */\n};\n\n#endif\n"], "fixing_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#include <curl/curl.h>\n\n#include \"urldata.h\"\n#include \"transfer.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"easyif.h\"\n#include \"share.h\"\n#include \"psl.h\"\n#include \"multiif.h\"\n#include \"sendf.h\"\n#include \"timeval.h\"\n#include \"http.h\"\n#include \"select.h\"\n#include \"warnless.h\"\n#include \"speedcheck.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"sigpipe.h\"\n#include \"vtls/vtls.h\"\n#include \"connect.h\"\n#include \"http_proxy.h\"\n#include \"http2.h\"\n#include \"socketpair.h\"\n#include \"socks.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n  CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97\n  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every\n  CURL handle takes 45-50 K memory, therefore this 3K are not significant.\n*/\n#ifndef CURL_SOCKET_HASH_TABLE_SIZE\n#define CURL_SOCKET_HASH_TABLE_SIZE 911\n#endif\n\n#ifndef CURL_CONNECTION_HASH_SIZE\n#define CURL_CONNECTION_HASH_SIZE 97\n#endif\n\n#define CURL_MULTI_HANDLE 0x000bab1e\n\n#define GOOD_MULTI_HANDLE(x) \\\n  ((x) && (x)->magic == CURL_MULTI_HANDLE)\n\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data);\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d);\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms);\nstatic void process_pending_handles(struct Curl_multi *multi);\n\n#ifdef DEBUGBUILD\nstatic const char * const statename[]={\n  \"INIT\",\n  \"PENDING\",\n  \"CONNECT\",\n  \"RESOLVING\",\n  \"CONNECTING\",\n  \"TUNNELING\",\n  \"PROTOCONNECT\",\n  \"PROTOCONNECTING\",\n  \"DO\",\n  \"DOING\",\n  \"DOING_MORE\",\n  \"DID\",\n  \"PERFORMING\",\n  \"RATELIMITING\",\n  \"DONE\",\n  \"COMPLETED\",\n  \"MSGSENT\",\n};\n#endif\n\n/* function pointer called once when switching TO a state */\ntypedef void (*init_multistate_func)(struct Curl_easy *data);\n\n/* called in DID state, before PERFORMING state */\nstatic void before_perform(struct Curl_easy *data)\n{\n  data->req.chunk = FALSE;\n  Curl_pgrsTime(data, TIMER_PRETRANSFER);\n}\n\nstatic void init_completed(struct Curl_easy *data)\n{\n  /* this is a completed transfer */\n\n  /* Important: reset the conn pointer so that we don't point to memory\n     that could be freed anytime */\n  Curl_detach_connnection(data);\n  Curl_expire_clear(data); /* stop all timers */\n}\n\n/* always use this function to change state, to make debugging easier */\nstatic void mstate(struct Curl_easy *data, CURLMstate state\n#ifdef DEBUGBUILD\n                   , int lineno\n#endif\n)\n{\n  CURLMstate oldstate = data->mstate;\n  static const init_multistate_func finit[MSTATE_LAST] = {\n    NULL,              /* INIT */\n    NULL,              /* PENDING */\n    Curl_init_CONNECT, /* CONNECT */\n    NULL,              /* RESOLVING */\n    NULL,              /* CONNECTING */\n    NULL,              /* TUNNELING */\n    NULL,              /* PROTOCONNECT */\n    NULL,              /* PROTOCONNECTING */\n    Curl_connect_free, /* DO */\n    NULL,              /* DOING */\n    NULL,              /* DOING_MORE */\n    before_perform,    /* DID */\n    NULL,              /* PERFORMING */\n    NULL,              /* RATELIMITING */\n    NULL,              /* DONE */\n    init_completed,    /* COMPLETED */\n    NULL               /* MSGSENT */\n  };\n\n#if defined(DEBUGBUILD) && defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) lineno;\n#endif\n\n  if(oldstate == state)\n    /* don't bother when the new state is the same as the old state */\n    return;\n\n  data->mstate = state;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  if(data->mstate >= MSTATE_PENDING &&\n     data->mstate < MSTATE_COMPLETED) {\n    long connection_id = -5000;\n\n    if(data->conn)\n      connection_id = data->conn->connection_id;\n\n    infof(data,\n          \"STATE: %s => %s handle %p; line %d (connection #%ld)\\n\",\n          statename[oldstate], statename[data->mstate],\n          (void *)data, lineno, connection_id);\n  }\n#endif\n\n  if(state == MSTATE_COMPLETED) {\n    /* changing to COMPLETED means there's one less easy handle 'alive' */\n    DEBUGASSERT(data->multi->num_alive > 0);\n    data->multi->num_alive--;\n  }\n\n  /* if this state has an init-function, run it */\n  if(finit[state])\n    finit[state](data);\n}\n\n#ifndef DEBUGBUILD\n#define multistate(x,y) mstate(x,y)\n#else\n#define multistate(x,y) mstate(x,y, __LINE__)\n#endif\n\n/*\n * We add one of these structs to the sockhash for each socket\n */\n\nstruct Curl_sh_entry {\n  struct Curl_hash transfers; /* hash of transfers using this socket */\n  unsigned int action;  /* what combined action READ/WRITE this socket waits\n                           for */\n  unsigned int users; /* number of transfers using this */\n  void *socketp; /* settable by users with curl_multi_assign() */\n  unsigned int readers; /* this many transfers want to read */\n  unsigned int writers; /* this many transfers want to write */\n};\n/* bits for 'action' having no bits means this socket is not expecting any\n   action */\n#define SH_READ  1\n#define SH_WRITE 2\n\n/* look up a given socket in the socket hash, skip invalid sockets */\nstatic struct Curl_sh_entry *sh_getentry(struct Curl_hash *sh,\n                                         curl_socket_t s)\n{\n  if(s != CURL_SOCKET_BAD) {\n    /* only look for proper sockets */\n    return Curl_hash_pick(sh, (char *)&s, sizeof(curl_socket_t));\n  }\n  return NULL;\n}\n\n#define TRHASH_SIZE 13\nstatic size_t trhash(void *key, size_t key_length, size_t slots_num)\n{\n  size_t keyval = (size_t)*(struct Curl_easy **)key;\n  (void) key_length;\n\n  return (keyval % slots_num);\n}\n\nstatic size_t trhash_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void)k1_len;\n  (void)k2_len;\n\n  return *(struct Curl_easy **)k1 == *(struct Curl_easy **)k2;\n}\n\nstatic void trhash_dtor(void *nada)\n{\n  (void)nada;\n}\n\n\n/* make sure this socket is present in the hash for this handle */\nstatic struct Curl_sh_entry *sh_addentry(struct Curl_hash *sh,\n                                         curl_socket_t s)\n{\n  struct Curl_sh_entry *there = sh_getentry(sh, s);\n  struct Curl_sh_entry *check;\n\n  if(there) {\n    /* it is present, return fine */\n    return there;\n  }\n\n  /* not present, add it */\n  check = calloc(1, sizeof(struct Curl_sh_entry));\n  if(!check)\n    return NULL; /* major failure */\n\n  if(Curl_hash_init(&check->transfers, TRHASH_SIZE, trhash,\n                    trhash_compare, trhash_dtor)) {\n    free(check);\n    return NULL;\n  }\n\n  /* make/add new hash entry */\n  if(!Curl_hash_add(sh, (char *)&s, sizeof(curl_socket_t), check)) {\n    Curl_hash_destroy(&check->transfers);\n    free(check);\n    return NULL; /* major failure */\n  }\n\n  return check; /* things are good in sockhash land */\n}\n\n\n/* delete the given socket + handle from the hash */\nstatic void sh_delentry(struct Curl_sh_entry *entry,\n                        struct Curl_hash *sh, curl_socket_t s)\n{\n  Curl_hash_destroy(&entry->transfers);\n\n  /* We remove the hash entry. This will end up in a call to\n     sh_freeentry(). */\n  Curl_hash_delete(sh, (char *)&s, sizeof(curl_socket_t));\n}\n\n/*\n * free a sockhash entry\n */\nstatic void sh_freeentry(void *freethis)\n{\n  struct Curl_sh_entry *p = (struct Curl_sh_entry *) freethis;\n\n  free(p);\n}\n\nstatic size_t fd_key_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void) k1_len; (void) k2_len;\n\n  return (*((curl_socket_t *) k1)) == (*((curl_socket_t *) k2));\n}\n\nstatic size_t hash_fd(void *key, size_t key_length, size_t slots_num)\n{\n  curl_socket_t fd = *((curl_socket_t *) key);\n  (void) key_length;\n\n  return (fd % slots_num);\n}\n\n/*\n * sh_init() creates a new socket hash and returns the handle for it.\n *\n * Quote from README.multi_socket:\n *\n * \"Some tests at 7000 and 9000 connections showed that the socket hash lookup\n * is somewhat of a bottle neck. Its current implementation may be a bit too\n * limiting. It simply has a fixed-size array, and on each entry in the array\n * it has a linked list with entries. So the hash only checks which list to\n * scan through. The code I had used so for used a list with merely 7 slots\n * (as that is what the DNS hash uses) but with 7000 connections that would\n * make an average of 1000 nodes in each list to run through. I upped that to\n * 97 slots (I believe a prime is suitable) and noticed a significant speed\n * increase.  I need to reconsider the hash implementation or use a rather\n * large default value like this. At 9000 connections I was still below 10us\n * per call.\"\n *\n */\nstatic int sh_init(struct Curl_hash *hash, int hashsize)\n{\n  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,\n                        sh_freeentry);\n}\n\n/*\n * multi_addmsg()\n *\n * Called when a transfer is completed. Adds the given msg pointer to\n * the list kept in the multi handle.\n */\nstatic CURLMcode multi_addmsg(struct Curl_multi *multi,\n                              struct Curl_message *msg)\n{\n  Curl_llist_insert_next(&multi->msglist, multi->msglist.tail, msg,\n                         &msg->list);\n  return CURLM_OK;\n}\n\nstruct Curl_multi *Curl_multi_handle(int hashsize, /* socket hash */\n                                     int chashsize) /* connection hash */\n{\n  struct Curl_multi *multi = calloc(1, sizeof(struct Curl_multi));\n\n  if(!multi)\n    return NULL;\n\n  multi->magic = CURL_MULTI_HANDLE;\n\n  if(Curl_mk_dnscache(&multi->hostcache))\n    goto error;\n\n  if(sh_init(&multi->sockhash, hashsize))\n    goto error;\n\n  if(Curl_conncache_init(&multi->conn_cache, chashsize))\n    goto error;\n\n  Curl_llist_init(&multi->msglist, NULL);\n  Curl_llist_init(&multi->pending, NULL);\n\n  multi->multiplexing = TRUE;\n\n  /* -1 means it not set by user, use the default value */\n  multi->maxconnects = -1;\n  multi->max_concurrent_streams = 100;\n  multi->ipv6_works = Curl_ipv6works(NULL);\n\n#ifdef USE_WINSOCK\n  multi->wsa_event = WSACreateEvent();\n  if(multi->wsa_event == WSA_INVALID_EVENT)\n    goto error;\n#else\n#ifdef ENABLE_WAKEUP\n  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, multi->wakeup_pair) < 0) {\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||\n          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n    multi->wakeup_pair[0] = CURL_SOCKET_BAD;\n    multi->wakeup_pair[1] = CURL_SOCKET_BAD;\n  }\n#endif\n#endif\n\n  return multi;\n\n  error:\n\n  Curl_hash_destroy(&multi->sockhash);\n  Curl_hash_destroy(&multi->hostcache);\n  Curl_conncache_destroy(&multi->conn_cache);\n  Curl_llist_destroy(&multi->msglist, NULL);\n  Curl_llist_destroy(&multi->pending, NULL);\n\n  free(multi);\n  return NULL;\n}\n\nstruct Curl_multi *curl_multi_init(void)\n{\n  return Curl_multi_handle(CURL_SOCKET_HASH_TABLE_SIZE,\n                           CURL_CONNECTION_HASH_SIZE);\n}\n\nCURLMcode curl_multi_add_handle(struct Curl_multi *multi,\n                                struct Curl_easy *data)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from adding same easy handle more than once and prevent\n     adding to more than one multi stack */\n  if(data->multi)\n    return CURLM_ADDED_ALREADY;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  /* Initialize timeout list for this handle */\n  Curl_llist_init(&data->state.timeoutlist, NULL);\n\n  /*\n   * No failure allowed in this function beyond this point. And no\n   * modification of easy nor multi handle allowed before this except for\n   * potential multi's connection cache growing which won't be undone in this\n   * function no matter what.\n   */\n  if(data->set.errorbuffer)\n    data->set.errorbuffer[0] = 0;\n\n  /* set the easy handle */\n  multistate(data, MSTATE_INIT);\n\n  /* for multi interface connections, we share DNS cache automatically if the\n     easy handle's one is currently not set. */\n  if(!data->dns.hostcache ||\n     (data->dns.hostcachetype == HCACHE_NONE)) {\n    data->dns.hostcache = &multi->hostcache;\n    data->dns.hostcachetype = HCACHE_MULTI;\n  }\n\n  /* Point to the shared or multi handle connection cache */\n  if(data->share && (data->share->specifier & (1<< CURL_LOCK_DATA_CONNECT)))\n    data->state.conn_cache = &data->share->conn_cache;\n  else\n    data->state.conn_cache = &multi->conn_cache;\n  data->state.lastconnect_id = -1;\n\n#ifdef USE_LIBPSL\n  /* Do the same for PSL. */\n  if(data->share && (data->share->specifier & (1 << CURL_LOCK_DATA_PSL)))\n    data->psl = &data->share->psl;\n  else\n    data->psl = &multi->psl;\n#endif\n\n  /* We add the new entry last in the list. */\n  data->next = NULL; /* end of the line */\n  if(multi->easyp) {\n    struct Curl_easy *last = multi->easylp;\n    last->next = data;\n    data->prev = last;\n    multi->easylp = data; /* the new last node */\n  }\n  else {\n    /* first node, make prev NULL! */\n    data->prev = NULL;\n    multi->easylp = multi->easyp = data; /* both first and last */\n  }\n\n  /* make the Curl_easy refer back to this multi handle */\n  data->multi = multi;\n\n  /* Set the timeout for this handle to expire really soon so that it will\n     be taken care of even when this handle is added in the midst of operation\n     when only the curl_multi_socket() API is used. During that flow, only\n     sockets that time-out or have actions will be dealt with. Since this\n     handle has no action yet, we make sure it times out to get things to\n     happen. */\n  Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n  /* increase the node-counter */\n  multi->num_easy++;\n\n  /* increase the alive-counter */\n  multi->num_alive++;\n\n  /* A somewhat crude work-around for a little glitch in Curl_update_timer()\n     that happens if the lastcall time is set to the same time when the handle\n     is removed as when the next handle is added, as then the check in\n     Curl_update_timer() that prevents calling the application multiple times\n     with the same timer info will not trigger and then the new handle's\n     timeout will not be notified to the app.\n\n     The work-around is thus simply to clear the 'lastcall' variable to force\n     Curl_update_timer() to always trigger a callback to the app when a new\n     easy handle is added */\n  memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n\n  CONNCACHE_LOCK(data);\n  /* The closure handle only ever has default timeouts set. To improve the\n     state somewhat we clone the timeouts from each added handle so that the\n     closure handle always has the same timeouts as the most recently added\n     easy handle. */\n  data->state.conn_cache->closure_handle->set.timeout = data->set.timeout;\n  data->state.conn_cache->closure_handle->set.server_response_timeout =\n    data->set.server_response_timeout;\n  data->state.conn_cache->closure_handle->set.no_signal =\n    data->set.no_signal;\n  CONNCACHE_UNLOCK(data);\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n#if 0\n/* Debug-function, used like this:\n *\n * Curl_hash_print(multi->sockhash, debug_print_sock_hash);\n *\n * Enable the hash print function first by editing hash.c\n */\nstatic void debug_print_sock_hash(void *p)\n{\n  struct Curl_sh_entry *sh = (struct Curl_sh_entry *)p;\n\n  fprintf(stderr, \" [easy %p/magic %x/socket %d]\",\n          (void *)sh->data, sh->data->magic, (int)sh->socket);\n}\n#endif\n\nstatic CURLcode multi_done(struct Curl_easy *data,\n                           CURLcode status,  /* an error if this is called\n                                                after an error was detected */\n                           bool premature)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  unsigned int i;\n\n  DEBUGF(infof(data, \"multi_done\\n\"));\n\n  if(data->state.done)\n    /* Stop if multi_done() has already been called */\n    return CURLE_OK;\n\n  /* Stop the resolver and free its own resources (but not dns_entry yet). */\n  Curl_resolver_kill(data);\n\n  /* Cleanup possible redirect junk */\n  Curl_safefree(data->req.newurl);\n  Curl_safefree(data->req.location);\n\n  switch(status) {\n  case CURLE_ABORTED_BY_CALLBACK:\n  case CURLE_READ_ERROR:\n  case CURLE_WRITE_ERROR:\n    /* When we're aborted due to a callback return code it basically have to\n       be counted as premature as there is trouble ahead if we don't. We have\n       many callbacks and protocols work differently, we could potentially do\n       this more fine-grained in the future. */\n    premature = TRUE;\n  default:\n    break;\n  }\n\n  /* this calls the protocol-specific function pointer previously set */\n  if(conn->handler->done)\n    result = conn->handler->done(data, status, premature);\n  else\n    result = status;\n\n  if(CURLE_ABORTED_BY_CALLBACK != result) {\n    /* avoid this if we already aborted by callback to avoid this calling\n       another callback */\n    CURLcode rc = Curl_pgrsDone(data);\n    if(!result && rc)\n      result = CURLE_ABORTED_BY_CALLBACK;\n  }\n\n  process_pending_handles(data->multi); /* connection / multiplex */\n\n  CONNCACHE_LOCK(data);\n  Curl_detach_connnection(data);\n  if(CONN_INUSE(conn)) {\n    /* Stop if still used. */\n    CONNCACHE_UNLOCK(data);\n    DEBUGF(infof(data, \"Connection still in use %zu, \"\n                 \"no more multi_done now!\\n\",\n                 conn->easyq.size));\n    return CURLE_OK;\n  }\n\n  data->state.done = TRUE; /* called just now! */\n\n  if(conn->dns_entry) {\n    Curl_resolv_unlock(data, conn->dns_entry); /* done with this */\n    conn->dns_entry = NULL;\n  }\n  Curl_hostcache_prune(data);\n  Curl_safefree(data->state.ulbuf);\n\n  /* if the transfer was completed in a paused state there can be buffered\n     data left to free */\n  for(i = 0; i < data->state.tempcount; i++) {\n    Curl_dyn_free(&data->state.tempwrite[i].b);\n  }\n  data->state.tempcount = 0;\n\n  /* if data->set.reuse_forbid is TRUE, it means the libcurl client has\n     forced us to close this connection. This is ignored for requests taking\n     place in a NTLM/NEGOTIATE authentication handshake\n\n     if conn->bits.close is TRUE, it means that the connection should be\n     closed in spite of all our efforts to be nice, due to protocol\n     restrictions in our or the server's end\n\n     if premature is TRUE, it means this connection was said to be DONE before\n     the entire request operation is complete and thus we can't know in what\n     state it is for re-using, so we're forced to close it. In a perfect world\n     we can add code that keep track of if we really must close it here or not,\n     but currently we have no such detail knowledge.\n  */\n\n  if((data->set.reuse_forbid\n#if defined(USE_NTLM)\n      && !(conn->http_ntlm_state == NTLMSTATE_TYPE2 ||\n           conn->proxy_ntlm_state == NTLMSTATE_TYPE2)\n#endif\n#if defined(USE_SPNEGO)\n      && !(conn->http_negotiate_state == GSS_AUTHRECV ||\n           conn->proxy_negotiate_state == GSS_AUTHRECV)\n#endif\n     ) || conn->bits.close\n       || (premature && !(conn->handler->flags & PROTOPT_STREAM))) {\n    CURLcode res2;\n    connclose(conn, \"disconnecting\");\n    Curl_conncache_remove_conn(data, conn, FALSE);\n    CONNCACHE_UNLOCK(data);\n    res2 = Curl_disconnect(data, conn, premature);\n\n    /* If we had an error already, make sure we return that one. But\n       if we got a new error, return that. */\n    if(!result && res2)\n      result = res2;\n  }\n  else {\n    char buffer[256];\n    const char *host =\n#ifndef CURL_DISABLE_PROXY\n      conn->bits.socksproxy ?\n      conn->socks_proxy.host.dispname :\n      conn->bits.httpproxy ? conn->http_proxy.host.dispname :\n#endif\n      conn->bits.conn_to_host ? conn->conn_to_host.dispname :\n      conn->host.dispname;\n    /* create string before returning the connection */\n    msnprintf(buffer, sizeof(buffer),\n              \"Connection #%ld to host %s left intact\",\n              conn->connection_id, host);\n    /* the connection is no longer in use by this transfer */\n    CONNCACHE_UNLOCK(data);\n    if(Curl_conncache_return_conn(data, conn)) {\n      /* remember the most recently used connection */\n      data->state.lastconnect_id = conn->connection_id;\n      infof(data, \"%s\\n\", buffer);\n    }\n    else\n      data->state.lastconnect_id = -1;\n  }\n\n  Curl_safefree(data->state.buffer);\n  Curl_free_request_state(data);\n  return result;\n}\n\nstatic int close_connect_only(struct Curl_easy *data,\n                              struct connectdata *conn, void *param)\n{\n  (void)param;\n  if(data->state.lastconnect_id != conn->connection_id)\n    return 0;\n\n  if(!conn->bits.connect_only)\n    return 1;\n\n  connclose(conn, \"Removing connect-only easy handle\");\n  conn->bits.connect_only = FALSE;\n\n  return 1;\n}\n\nCURLMcode curl_multi_remove_handle(struct Curl_multi *multi,\n                                   struct Curl_easy *data)\n{\n  struct Curl_easy *easy = data;\n  bool premature;\n  struct Curl_llist_element *e;\n\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  /* Verify that we got a somewhat good easy handle too */\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  /* Prevent users from trying to remove same easy handle more than once */\n  if(!data->multi)\n    return CURLM_OK; /* it is already removed so let's say it is fine! */\n\n  /* Prevent users from trying to remove an easy handle from the wrong multi */\n  if(data->multi != multi)\n    return CURLM_BAD_EASY_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  premature = (data->mstate < MSTATE_COMPLETED) ? TRUE : FALSE;\n\n  /* If the 'state' is not INIT or COMPLETED, we might need to do something\n     nice to put the easy_handle in a good known state when this returns. */\n  if(premature) {\n    /* this handle is \"alive\" so we need to count down the total number of\n       alive connections when this is removed */\n    multi->num_alive--;\n  }\n\n  if(data->conn &&\n     data->mstate > MSTATE_DO &&\n     data->mstate < MSTATE_COMPLETED) {\n    /* Set connection owner so that the DONE function closes it.  We can\n       safely do this here since connection is killed. */\n    streamclose(data->conn, \"Removed with partial response\");\n  }\n\n  if(data->conn) {\n    /* multi_done() clears the association between the easy handle and the\n       connection.\n\n       Note that this ignores the return code simply because there's\n       nothing really useful to do with it anyway! */\n    (void)multi_done(data, data->result, premature);\n  }\n\n  /* The timer must be shut down before data->multi is set to NULL, else the\n     timenode will remain in the splay tree after curl_easy_cleanup is\n     called. Do it after multi_done() in case that sets another time! */\n  Curl_expire_clear(data);\n\n  if(data->connect_queue.ptr)\n    /* the handle was in the pending list waiting for an available connection,\n       so go ahead and remove it */\n    Curl_llist_remove(&multi->pending, &data->connect_queue, NULL);\n\n  if(data->dns.hostcachetype == HCACHE_MULTI) {\n    /* stop using the multi handle's DNS cache, *after* the possible\n       multi_done() call above */\n    data->dns.hostcache = NULL;\n    data->dns.hostcachetype = HCACHE_NONE;\n  }\n\n  Curl_wildcard_dtor(&data->wildcard);\n\n  /* destroy the timeout list that is held in the easy handle, do this *after*\n     multi_done() as that may actually call Curl_expire that uses this */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  /* change state without using multistate(), only to make singlesocket() do\n     what we want */\n  data->mstate = MSTATE_COMPLETED;\n  singlesocket(multi, easy); /* to let the application know what sockets that\n                                vanish with this handle */\n\n  /* Remove the association between the connection and the handle */\n  Curl_detach_connnection(data);\n\n  if(data->state.lastconnect_id != -1) {\n    /* Mark any connect-only connection for closure */\n    Curl_conncache_foreach(data, data->state.conn_cache,\n                           NULL, close_connect_only);\n  }\n\n#ifdef USE_LIBPSL\n  /* Remove the PSL association. */\n  if(data->psl == &multi->psl)\n    data->psl = NULL;\n#endif\n\n  /* as this was using a shared connection cache we clear the pointer to that\n     since we're not part of that multi handle anymore */\n  data->state.conn_cache = NULL;\n\n  data->multi = NULL; /* clear the association to this multi handle */\n\n  /* make sure there's no pending message in the queue sent from this easy\n     handle */\n\n  for(e = multi->msglist.head; e; e = e->next) {\n    struct Curl_message *msg = e->ptr;\n\n    if(msg->extmsg.easy_handle == easy) {\n      Curl_llist_remove(&multi->msglist, e, NULL);\n      /* there can only be one from this specific handle */\n      break;\n    }\n  }\n\n  /* Remove from the pending list if it is there. Otherwise this will\n     remain on the pending list forever due to the state change. */\n  for(e = multi->pending.head; e; e = e->next) {\n    struct Curl_easy *curr_data = e->ptr;\n\n    if(curr_data == data) {\n      Curl_llist_remove(&multi->pending, e, NULL);\n      break;\n    }\n  }\n\n  /* make the previous node point to our next */\n  if(data->prev)\n    data->prev->next = data->next;\n  else\n    multi->easyp = data->next; /* point to first node */\n\n  /* make our next point to our previous node */\n  if(data->next)\n    data->next->prev = data->prev;\n  else\n    multi->easylp = data->prev; /* point to last node */\n\n  /* NOTE NOTE NOTE\n     We do not touch the easy handle here! */\n  multi->num_easy--; /* one less to care about now */\n\n  process_pending_handles(multi);\n\n  Curl_update_timer(multi);\n  return CURLM_OK;\n}\n\n/* Return TRUE if the application asked for multiplexing */\nbool Curl_multiplex_wanted(const struct Curl_multi *multi)\n{\n  return (multi && (multi->multiplexing));\n}\n\n/*\n * Curl_detach_connnection() removes the given transfer from the connection.\n *\n * This is the only function that should clear data->conn. This will\n * occasionally be called with the data->conn pointer already cleared.\n */\nvoid Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}\n\n/*\n * Curl_attach_connnection() attaches this transfer to this connection.\n *\n * This is the only function that should assign data->conn\n */\nvoid Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n  Curl_ssl_associate_conn(data, conn);\n}\n\nstatic int waitconnect_getsock(struct connectdata *conn,\n                               curl_socket_t *sock)\n{\n  int i;\n  int s = 0;\n  int rc = 0;\n\n#ifdef USE_SSL\n#ifndef CURL_DISABLE_PROXY\n  if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n    return Curl_ssl->getsock(conn, sock);\n#endif\n#endif\n\n  if(SOCKS_STATE(conn->cnnct.state))\n    return Curl_SOCKS_getsock(conn, sock, FIRSTSOCKET);\n\n  for(i = 0; i<2; i++) {\n    if(conn->tempsock[i] != CURL_SOCKET_BAD) {\n      sock[s] = conn->tempsock[i];\n      rc |= GETSOCK_WRITESOCK(s);\n#ifdef ENABLE_QUIC\n      if(conn->transport == TRNSPRT_QUIC)\n        /* when connecting QUIC, we want to read the socket too */\n        rc |= GETSOCK_READSOCK(s);\n#endif\n      s++;\n    }\n  }\n\n  return rc;\n}\n\nstatic int waitproxyconnect_getsock(struct connectdata *conn,\n                                    curl_socket_t *sock)\n{\n  sock[0] = conn->sock[FIRSTSOCKET];\n\n  if(conn->connect_state)\n    return Curl_connect_getsock(conn);\n\n  return GETSOCK_WRITESOCK(0);\n}\n\nstatic int domore_getsock(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          curl_socket_t *socks)\n{\n  if(conn && conn->handler->domore_getsock)\n    return conn->handler->domore_getsock(data, conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int doing_getsock(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         curl_socket_t *socks)\n{\n  if(conn && conn->handler->doing_getsock)\n    return conn->handler->doing_getsock(data, conn, socks);\n  return GETSOCK_BLANK;\n}\n\nstatic int protocol_getsock(struct Curl_easy *data,\n                            struct connectdata *conn,\n                            curl_socket_t *socks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(data, conn, socks);\n  /* Backup getsock logic. Since there is a live socket in use, we must wait\n     for it or it will be removed from watching when the multi_socket API is\n     used. */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\n/* returns bitmapped flags for this handle and its sockets. The 'socks[]'\n   array contains MAX_SOCKSPEREASYHANDLE entries. */\nstatic int multi_getsock(struct Curl_easy *data,\n                         curl_socket_t *socks)\n{\n  struct connectdata *conn = data->conn;\n  /* The no connection case can happen when this is called from\n     curl_multi_remove_handle() => singlesocket() => multi_getsock().\n  */\n  if(!conn)\n    return 0;\n\n  switch(data->mstate) {\n  default:\n    return 0;\n\n  case MSTATE_RESOLVING:\n    return Curl_resolv_getsock(data, socks);\n\n  case MSTATE_PROTOCONNECTING:\n  case MSTATE_PROTOCONNECT:\n    return protocol_getsock(data, conn, socks);\n\n  case MSTATE_DO:\n  case MSTATE_DOING:\n    return doing_getsock(data, conn, socks);\n\n  case MSTATE_TUNNELING:\n    return waitproxyconnect_getsock(conn, socks);\n\n  case MSTATE_CONNECTING:\n    return waitconnect_getsock(conn, socks);\n\n  case MSTATE_DOING_MORE:\n    return domore_getsock(data, conn, socks);\n\n  case MSTATE_DID: /* since is set after DO is completed, we switch to\n                        waiting for the same as the PERFORMING state */\n  case MSTATE_PERFORMING:\n    return Curl_single_getsock(data, conn, socks);\n  }\n\n}\n\nCURLMcode curl_multi_fdset(struct Curl_multi *multi,\n                           fd_set *read_fd_set, fd_set *write_fd_set,\n                           fd_set *exc_fd_set, int *max_fd)\n{\n  /* Scan through all the easy handles to get the file descriptors set.\n     Some easy handles may not have connected to the remote host yet,\n     and then we must make sure that is done. */\n  struct Curl_easy *data;\n  int this_max_fd = -1;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  (void)exc_fd_set; /* not used */\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    int bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], read_fd_set);\n        s = sockbunch[i];\n      }\n      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        FD_SET(sockbunch[i], write_fd_set);\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD)\n        /* this socket is unused, break out of loop */\n        break;\n      if((int)s > this_max_fd)\n        this_max_fd = (int)s;\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  *max_fd = this_max_fd;\n\n  return CURLM_OK;\n}\n\n#define NUM_POLLS_ON_STACK 10\n\nstatic CURLMcode multi_wait(struct Curl_multi *multi,\n                            struct curl_waitfd extra_fds[],\n                            unsigned int extra_nfds,\n                            int timeout_ms,\n                            int *ret,\n                            bool extrawait, /* when no socket, wait */\n                            bool use_wakeup)\n{\n  struct Curl_easy *data;\n  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];\n  int bitmap;\n  unsigned int i;\n  unsigned int nfds = 0;\n  unsigned int curlfds;\n  long timeout_internal;\n  int retcode = 0;\n  struct pollfd a_few_on_stack[NUM_POLLS_ON_STACK];\n  struct pollfd *ufds = &a_few_on_stack[0];\n  bool ufds_malloc = FALSE;\n#ifdef USE_WINSOCK\n  WSANETWORKEVENTS wsa_events;\n  DEBUGASSERT(multi->wsa_event != WSA_INVALID_EVENT);\n#endif\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  if(timeout_ms < 0)\n    return CURLM_BAD_FUNCTION_ARGUMENT;\n\n  /* Count up how many fds we have from the multi handle */\n  data = multi->easyp;\n  while(data) {\n    bitmap = multi_getsock(data, sockbunch);\n\n    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {\n      curl_socket_t s = CURL_SOCKET_BAD;\n\n      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK((sockbunch[i]))) {\n        ++nfds;\n        s = sockbunch[i];\n      }\n      if(s == CURL_SOCKET_BAD) {\n        break;\n      }\n    }\n\n    data = data->next; /* check next handle */\n  }\n\n  /* If the internally desired timeout is actually shorter than requested from\n     the outside, then use the shorter time! But only if the internal timer\n     is actually larger than -1! */\n  (void)multi_timeout(multi, &timeout_internal);\n  if((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms))\n    timeout_ms = (int)timeout_internal;\n\n  curlfds = nfds; /* number of internal file descriptors */\n  nfds += extra_nfds; /* add the externally provided ones */\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(use_wakeup) {\n#else\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n#endif\n    ++nfds;\n  }\n#endif\n\n  if(nfds > NUM_POLLS_ON_STACK) {\n    /* 'nfds' is a 32 bit value and 'struct pollfd' is typically 8 bytes\n       big, so at 2^29 sockets this value might wrap. When a process gets\n       the capability to actually handle over 500 million sockets this\n       calculation needs a integer overflow check. */\n    ufds = malloc(nfds * sizeof(struct pollfd));\n    if(!ufds)\n      return CURLM_OUT_OF_MEMORY;\n    ufds_malloc = TRUE;\n  }\n  nfds = 0;\n\n  /* only do the second loop if we found descriptors in the first stage run\n     above */\n\n  if(curlfds) {\n    /* Add the curl handles to our pollfds first */\n    data = multi->easyp;\n    while(data) {\n      bitmap = multi_getsock(data, sockbunch);\n\n      for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n        curl_socket_t s = CURL_SOCKET_BAD;\n#ifdef USE_WINSOCK\n        long mask = 0;\n#endif\n        if(bitmap & GETSOCK_READSOCK(i)) {\n          s = sockbunch[i];\n#ifdef USE_WINSOCK\n          mask |= FD_READ|FD_ACCEPT|FD_CLOSE;\n#endif\n          ufds[nfds].fd = s;\n          ufds[nfds].events = POLLIN;\n          ++nfds;\n        }\n        if(bitmap & GETSOCK_WRITESOCK(i)) {\n          s = sockbunch[i];\n#ifdef USE_WINSOCK\n          mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;\n          send(s, NULL, 0, 0); /* reset FD_WRITE */\n#endif\n          ufds[nfds].fd = s;\n          ufds[nfds].events = POLLOUT;\n          ++nfds;\n        }\n        /* s is only set if either being readable or writable is checked */\n        if(s == CURL_SOCKET_BAD) {\n          /* break on entry not checked for being readable or writable */\n          break;\n        }\n#ifdef USE_WINSOCK\n        if(WSAEventSelect(s, multi->wsa_event, mask) != 0) {\n          if(ufds_malloc)\n            free(ufds);\n          return CURLM_INTERNAL_ERROR;\n        }\n#endif\n      }\n\n      data = data->next; /* check next handle */\n    }\n  }\n\n  /* Add external file descriptions from poll-like struct curl_waitfd */\n  for(i = 0; i < extra_nfds; i++) {\n#ifdef USE_WINSOCK\n    long mask = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN)\n      mask |= FD_READ|FD_ACCEPT|FD_CLOSE;\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI)\n      mask |= FD_OOB;\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT) {\n      mask |= FD_WRITE|FD_CONNECT|FD_CLOSE;\n      send(extra_fds[i].fd, NULL, 0, 0); /* reset FD_WRITE */\n    }\n    if(WSAEventSelect(extra_fds[i].fd, multi->wsa_event, mask) != 0) {\n      if(ufds_malloc)\n        free(ufds);\n      return CURLM_INTERNAL_ERROR;\n    }\n#endif\n    ufds[nfds].fd = extra_fds[i].fd;\n    ufds[nfds].events = 0;\n    if(extra_fds[i].events & CURL_WAIT_POLLIN)\n      ufds[nfds].events |= POLLIN;\n    if(extra_fds[i].events & CURL_WAIT_POLLPRI)\n      ufds[nfds].events |= POLLPRI;\n    if(extra_fds[i].events & CURL_WAIT_POLLOUT)\n      ufds[nfds].events |= POLLOUT;\n    ++nfds;\n  }\n\n#ifdef ENABLE_WAKEUP\n#ifndef USE_WINSOCK\n  if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n    ufds[nfds].fd = multi->wakeup_pair[0];\n    ufds[nfds].events = POLLIN;\n    ++nfds;\n  }\n#endif\n#endif\n\n#if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)\n  if(nfds || use_wakeup) {\n#else\n  if(nfds) {\n#endif\n    int pollrc;\n#ifdef USE_WINSOCK\n    if(nfds)\n      pollrc = Curl_poll(ufds, nfds, 0); /* just pre-check with WinSock */\n    else\n      pollrc = 0;\n    if(pollrc <= 0) /* now wait... if not ready during the pre-check above */\n      WSAWaitForMultipleEvents(1, &multi->wsa_event, FALSE, timeout_ms, FALSE);\n#else\n    pollrc = Curl_poll(ufds, nfds, timeout_ms); /* wait... */\n#endif\n\n    if(pollrc > 0) {\n      retcode = pollrc;\n#ifdef USE_WINSOCK\n    }\n    /* With WinSock, we have to run the following section unconditionally\n       to call WSAEventSelect(fd, event, 0) on all the sockets */\n    {\n#endif\n      /* copy revents results from the poll to the curl_multi_wait poll\n         struct, the bit values of the actual underlying poll() implementation\n         may not be the same as the ones in the public libcurl API! */\n      for(i = 0; i < extra_nfds; i++) {\n        unsigned r = ufds[curlfds + i].revents;\n        unsigned short mask = 0;\n#ifdef USE_WINSOCK\n        wsa_events.lNetworkEvents = 0;\n        if(WSAEnumNetworkEvents(extra_fds[i].fd, NULL, &wsa_events) == 0) {\n          if(wsa_events.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLIN;\n          if(wsa_events.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CLOSE))\n            mask |= CURL_WAIT_POLLOUT;\n          if(wsa_events.lNetworkEvents & FD_OOB)\n            mask |= CURL_WAIT_POLLPRI;\n          if(ret && pollrc <= 0 && wsa_events.lNetworkEvents)\n            retcode++;\n        }\n        WSAEventSelect(extra_fds[i].fd, multi->wsa_event, 0);\n        if(pollrc <= 0)\n          continue;\n#endif\n        if(r & POLLIN)\n          mask |= CURL_WAIT_POLLIN;\n        if(r & POLLOUT)\n          mask |= CURL_WAIT_POLLOUT;\n        if(r & POLLPRI)\n          mask |= CURL_WAIT_POLLPRI;\n        extra_fds[i].revents = mask;\n      }\n\n#ifdef USE_WINSOCK\n      /* Count up all our own sockets that had activity,\n         and remove them from the event. */\n      if(curlfds) {\n        data = multi->easyp;\n        while(data) {\n          bitmap = multi_getsock(data, sockbunch);\n\n          for(i = 0; i < MAX_SOCKSPEREASYHANDLE; i++) {\n            if(bitmap & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i))) {\n              wsa_events.lNetworkEvents = 0;\n              if(WSAEnumNetworkEvents(sockbunch[i], NULL, &wsa_events) == 0) {\n                if(ret && pollrc <= 0 && wsa_events.lNetworkEvents)\n                  retcode++;\n              }\n              WSAEventSelect(sockbunch[i], multi->wsa_event, 0);\n            }\n            else {\n              /* break on entry not checked for being readable or writable */\n              break;\n            }\n          }\n\n          data = data->next;\n        }\n      }\n\n      WSAResetEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n      if(use_wakeup && multi->wakeup_pair[0] != CURL_SOCKET_BAD) {\n        if(ufds[curlfds + extra_nfds].revents & POLLIN) {\n          char buf[64];\n          ssize_t nread;\n          while(1) {\n            /* the reading socket is non-blocking, try to read\n               data from it until it receives an error (except EINTR).\n               In normal cases it will get EAGAIN or EWOULDBLOCK\n               when there is no more data, breaking the loop. */\n            nread = sread(multi->wakeup_pair[0], buf, sizeof(buf));\n            if(nread <= 0) {\n              if(nread < 0 && EINTR == SOCKERRNO)\n                continue;\n              break;\n            }\n          }\n          /* do not count the wakeup socket into the returned value */\n          retcode--;\n        }\n      }\n#endif\n#endif\n    }\n  }\n\n  if(ufds_malloc)\n    free(ufds);\n  if(ret)\n    *ret = retcode;\n#if defined(ENABLE_WAKEUP) && defined(USE_WINSOCK)\n  if(extrawait && !nfds && !use_wakeup) {\n#else\n  if(extrawait && !nfds) {\n#endif\n    long sleep_ms = 0;\n\n    /* Avoid busy-looping when there's nothing particular to wait for */\n    if(!curl_multi_timeout(multi, &sleep_ms) && sleep_ms) {\n      if(sleep_ms > timeout_ms)\n        sleep_ms = timeout_ms;\n      /* when there are no easy handles in the multi, this holds a -1\n         timeout */\n      else if(sleep_ms < 0)\n        sleep_ms = timeout_ms;\n      Curl_wait_ms(sleep_ms);\n    }\n  }\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_wait(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, FALSE,\n                    FALSE);\n}\n\nCURLMcode curl_multi_poll(struct Curl_multi *multi,\n                          struct curl_waitfd extra_fds[],\n                          unsigned int extra_nfds,\n                          int timeout_ms,\n                          int *ret)\n{\n  return multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, TRUE,\n                    TRUE);\n}\n\nCURLMcode curl_multi_wakeup(struct Curl_multi *multi)\n{\n  /* this function is usually called from another thread,\n     it has to be careful only to access parts of the\n     Curl_multi struct that are constant */\n\n  /* GOOD_MULTI_HANDLE can be safely called */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n#ifdef ENABLE_WAKEUP\n#ifdef USE_WINSOCK\n  if(WSASetEvent(multi->wsa_event))\n    return CURLM_OK;\n#else\n  /* the wakeup_pair variable is only written during init and cleanup,\n     making it safe to access from another thread after the init part\n     and before cleanup */\n  if(multi->wakeup_pair[1] != CURL_SOCKET_BAD) {\n    char buf[1];\n    buf[0] = 1;\n    while(1) {\n      /* swrite() is not thread-safe in general, because concurrent calls\n         can have their messages interleaved, but in this case the content\n         of the messages does not matter, which makes it ok to call.\n\n         The write socket is set to non-blocking, this way this function\n         cannot block, making it safe to call even from the same thread\n         that will call curl_multi_wait(). If swrite() returns that it\n         would block, it's considered successful because it means that\n         previous calls to this function will wake up the poll(). */\n      if(swrite(multi->wakeup_pair[1], buf, sizeof(buf)) < 0) {\n        int err = SOCKERRNO;\n        int return_success;\n#ifdef USE_WINSOCK\n        return_success = WSAEWOULDBLOCK == err;\n#else\n        if(EINTR == err)\n          continue;\n        return_success = EWOULDBLOCK == err || EAGAIN == err;\n#endif\n        if(!return_success)\n          return CURLM_WAKEUP_FAILURE;\n      }\n      return CURLM_OK;\n    }\n  }\n#endif\n#endif\n  return CURLM_WAKEUP_FAILURE;\n}\n\n/*\n * multi_ischanged() is called\n *\n * Returns TRUE/FALSE whether the state is changed to trigger a CONNECT_PEND\n * => CONNECT action.\n *\n * Set 'clear' to TRUE to have it also clear the state variable.\n */\nstatic bool multi_ischanged(struct Curl_multi *multi, bool clear)\n{\n  bool retval = multi->recheckstate;\n  if(clear)\n    multi->recheckstate = FALSE;\n  return retval;\n}\n\nCURLMcode Curl_multi_add_perform(struct Curl_multi *multi,\n                                 struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  CURLMcode rc;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  rc = curl_multi_add_handle(multi, data);\n  if(!rc) {\n    struct SingleRequest *k = &data->req;\n\n    /* pass in NULL for 'conn' here since we don't want to init the\n       connection, only this transfer */\n    Curl_init_do(data, NULL);\n\n    /* take this handle to the perform state right away */\n    multistate(data, MSTATE_PERFORMING);\n    Curl_attach_connnection(data, conn);\n    k->keepon |= KEEP_RECV; /* setup to receive! */\n  }\n  return rc;\n}\n\nstatic CURLcode multi_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->handler);\n\n  if(conn->handler->do_it)\n    /* generic protocol-specific function pointer set in curl_connect() */\n    result = conn->handler->do_it(data, done);\n\n  return result;\n}\n\n/*\n * multi_do_more() is called during the DO_MORE multi state. It is basically a\n * second stage DO state which (wrongly) was introduced to support FTP's\n * second connection.\n *\n * 'complete' can return 0 for incomplete, 1 for done and -1 for go back to\n * DOING state there's more work to do!\n */\n\nstatic CURLcode multi_do_more(struct Curl_easy *data, int *complete)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  *complete = 0;\n\n  if(conn->handler->do_more)\n    result = conn->handler->do_more(data, complete);\n\n  return result;\n}\n\n/*\n * We are doing protocol-specific connecting and this is being called over and\n * over from the multi interface until the connection phase is done on\n * protocol layer.\n */\n\nstatic CURLcode protocol_connecting(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(conn && conn->handler->connecting) {\n    *done = FALSE;\n    result = conn->handler->connecting(data, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We are DOING this is being called over and over from the multi interface\n * until the DOING phase is done on protocol layer.\n */\n\nstatic CURLcode protocol_doing(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(conn && conn->handler->doing) {\n    *done = FALSE;\n    result = conn->handler->doing(data, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We have discovered that the TCP connection has been successful, we can now\n * proceed with some action.\n *\n */\nstatic CURLcode protocol_connect(struct Curl_easy *data,\n                                 bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  DEBUGASSERT(conn);\n  DEBUGASSERT(protocol_done);\n\n  *protocol_done = FALSE;\n\n  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {\n    /* We already are connected, get back. This may happen when the connect\n       worked fine in the first call, like when we connect to a local server\n       or proxy. Note that we don't know if the protocol is actually done.\n\n       Unless this protocol doesn't have any protocol-connect callback, as\n       then we know we're done. */\n    if(!conn->handler->connecting)\n      *protocol_done = TRUE;\n\n    return CURLE_OK;\n  }\n\n  if(!conn->bits.protoconnstart) {\n#ifndef CURL_DISABLE_PROXY\n    result = Curl_proxy_connect(data, FIRSTSOCKET);\n    if(result)\n      return result;\n\n    if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n      /* wait for HTTPS proxy SSL initialization to complete */\n      return CURLE_OK;\n\n    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&\n       Curl_connect_ongoing(conn))\n      /* when using an HTTP tunnel proxy, await complete tunnel establishment\n         before proceeding further. Return CURLE_OK so we'll be called again */\n      return CURLE_OK;\n#endif\n    if(conn->handler->connect_it) {\n      /* is there a protocol-specific connect() procedure? */\n\n      /* Call the protocol-specific connect function */\n      result = conn->handler->connect_it(data, protocol_done);\n    }\n    else\n      *protocol_done = TRUE;\n\n    /* it has started, possibly even completed but that knowledge isn't stored\n       in this bit! */\n    if(!result)\n      conn->bits.protoconnstart = TRUE;\n  }\n\n  return result; /* pass back status */\n}\n\n/*\n * Curl_preconnect() is called immediately before a connect starts. When a\n * redirect is followed, this is then called multiple times during a single\n * transfer.\n */\nCURLcode Curl_preconnect(struct Curl_easy *data)\n{\n  if(!data->state.buffer) {\n    data->state.buffer = malloc(data->set.buffer_size + 1);\n    if(!data->state.buffer)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  return CURLE_OK;\n}\n\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime *nowp,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connected = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  timediff_t timeout_ms;\n  timediff_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* multiplexed */\n    }\n\n    if(data->mstate > MSTATE_CONNECT &&\n       data->mstate < MSTATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      DEBUGASSERT(data->conn);\n      if(!data->conn)\n        return CURLM_INTERNAL_ERROR;\n    }\n\n    if(data->conn &&\n       (data->mstate >= MSTATE_CONNECT) &&\n       (data->mstate < MSTATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, nowp,\n                                 (data->mstate <= MSTATE_DO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == MSTATE_RESOLVING)\n          failf(data, \"Resolving timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else if(data->mstate == MSTATE_CONNECTING)\n          failf(data, \"Connection timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                \" milliseconds\",\n                Curl_timediff(*nowp, data->progress.t_startsingle));\n        else {\n          struct SingleRequest *k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %\" CURL_FORMAT_TIMEDIFF_T\n                  \" milliseconds with %\" CURL_FORMAT_CURL_OFF_T\n                  \" bytes received\",\n                  Curl_timediff(*nowp, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > MSTATE_DO) {\n          streamclose(data->conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(data, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case MSTATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, MSTATE_CONNECT);\n        *nowp = Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case MSTATE_PENDING:\n      /* We will stay here until there is a connection available. Then\n         we try again in the MSTATE_CONNECT state. */\n      break;\n\n    case MSTATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      /* init this transfer. */\n      result = Curl_preconnect(data);\n      if(result)\n        break;\n\n      *nowp = Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      if(data->set.timeout)\n        Curl_expire(data, data->set.timeout, EXPIRE_TIMEOUT);\n\n      if(data->set.connecttimeout)\n        Curl_expire(data, data->set.connecttimeout, EXPIRE_CONNECTTIMEOUT);\n\n      result = Curl_connect(data, &async, &protocol_connected);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, MSTATE_PENDING);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n      else if(data->state.previouslypending) {\n        /* this transfer comes from the pending queue so try move another */\n        infof(data, \"Transfer was pending, now try another\\n\");\n        process_pending_handles(data->multi);\n      }\n\n      if(!result) {\n        if(async)\n          /* We're now waiting for an asynchronous name lookup */\n          multistate(data, MSTATE_RESOLVING);\n        else {\n          /* after the connect has been sent off, go WAITCONNECT unless the\n             protocol connect is already done and we can go directly to\n             WAITDO or DO! */\n          rc = CURLM_CALL_MULTI_PERFORM;\n\n          if(protocol_connected)\n            multistate(data, MSTATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, MSTATE_TUNNELING);\n            else\n#endif\n              multistate(data, MSTATE_CONNECTING);\n          }\n        }\n      }\n      break;\n\n    case MSTATE_RESOLVING:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->conn;\n      const char *hostname;\n\n      DEBUGASSERT(conn);\n#ifndef CURL_DISABLE_PROXY\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else\n#endif\n        if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(data, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        data->state.async.dns = dns;\n        data->state.async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolv_check(data, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_once_resolved(data, &protocol_connected);\n\n        if(result)\n          /* if Curl_once_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->conn = NULL; /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connected)\n            multistate(data, MSTATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->conn))\n              multistate(data, MSTATE_TUNNELING);\n            else\n#endif\n              multistate(data, MSTATE_CONNECTING);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case MSTATE_TUNNELING:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      DEBUGASSERT(data->conn);\n      result = Curl_http_connect(data, &protocol_connected);\n#ifndef CURL_DISABLE_PROXY\n      if(data->conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(data, CURLE_OK, FALSE);\n        multistate(data, MSTATE_CONNECT);\n      }\n      else\n#endif\n        if(!result) {\n          if(\n#ifndef CURL_DISABLE_PROXY\n            (data->conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n             data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n#endif\n            Curl_connect_complete(data->conn)) {\n            rc = CURLM_CALL_MULTI_PERFORM;\n            /* initiate protocol connect phase */\n            multistate(data, MSTATE_PROTOCONNECT);\n          }\n        }\n      else\n        stream_error = TRUE;\n      break;\n#endif\n\n    case MSTATE_CONNECTING:\n      /* awaiting a completion of an asynch TCP connect */\n      DEBUGASSERT(data->conn);\n      result = Curl_is_connected(data, data->conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if(\n#ifndef CURL_DISABLE_PROXY\n          (data->conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n           !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n#endif\n          Curl_connect_ongoing(data->conn)) {\n          multistate(data, MSTATE_TUNNELING);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n#ifndef CURL_DISABLE_PROXY\n        multistate(data,\n                   data->conn->bits.tunnel_proxy?\n                   MSTATE_TUNNELING : MSTATE_PROTOCONNECT);\n#else\n        multistate(data, MSTATE_PROTOCONNECT);\n#endif\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case MSTATE_PROTOCONNECT:\n      result = protocol_connect(data, &protocol_connected);\n      if(!result && !protocol_connected)\n        /* switch to waiting state */\n        multistate(data, MSTATE_PROTOCONNECTING);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, MSTATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_PROTOCONNECTING:\n      /* protocol-specific connect phase */\n      result = protocol_connecting(data, &protocol_connected);\n      if(!result && protocol_connected) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, MSTATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->conn, \"CONNECT_ONLY\");\n        multistate(data, MSTATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(data, &dophase_done);\n\n        /* When multi_do() returns failure, data->conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n#ifndef CURL_DISABLE_FTP\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(data, CURLE_OK, FALSE);\n\n                /* if there's no connection left, skip the DONE state */\n                multistate(data, data->conn ?\n                           MSTATE_DONE : MSTATE_COMPLETED);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n#endif\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, MSTATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, MSTATE_DOING_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DID */\n            multistate(data, MSTATE_DID);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n\n          drc = Curl_retry_request(data, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n\n          Curl_posttransfer(data);\n          drc = multi_done(data, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(newurl) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, MSTATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->conn)\n            multi_done(data, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case MSTATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      DEBUGASSERT(data->conn);\n      result = protocol_doing(data, &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->conn->bits.do_more?\n                     MSTATE_DOING_MORE : MSTATE_DID);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DOING_MORE:\n      /*\n       * When we are connected, DOING MORE and then go DID\n       */\n      DEBUGASSERT(data->conn);\n      result = multi_do_more(data, &control);\n\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     MSTATE_DID : MSTATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(data, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case MSTATE_DID:\n      DEBUGASSERT(data->conn);\n      if(data->conn->bits.multiplex)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, MSTATE_PERFORMING);\n      else {\n#ifndef CURL_DISABLE_FTP\n        if(data->state.wildcardmatch &&\n           ((data->conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n          data->wildcard.state = CURLWC_DONE;\n        }\n#endif\n        multistate(data, MSTATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case MSTATE_RATELIMITING: /* limit-rate exceeded in either direction */\n      DEBUGASSERT(data->conn);\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, *nowp);\n\n      if(result) {\n        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n      }\n      else {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   *nowp);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   *nowp);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, MSTATE_PERFORMING);\n          Curl_ratelimit(data, *nowp);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case MSTATE_PERFORMING:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n      DEBUGASSERT(data->state.buffer);\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 *nowp);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 *nowp);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, *nowp);\n        multistate(data, MSTATE_RATELIMITING);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->conn, data, &done, &comeback);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n        else if(!result)\n          result = ret;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n      else if((CURLE_HTTP2_STREAM == result) &&\n              Curl_h2_http_1_1_error(data)) {\n        CURLcode ret = Curl_retry_request(data, &newurl);\n\n        if(!ret) {\n          infof(data, \"Downgrades to HTTP/1.1!\\n\");\n          streamclose(data->conn, \"Disconnect HTTP/2 for HTTP/1\");\n          data->state.httpwant = CURL_HTTP_VERSION_1_1;\n          /* clear the error message bit too as we ignore the one we got */\n          data->state.errorbuf = FALSE;\n          if(!newurl)\n            /* typically for HTTP_1_1_REQUIRED error on first flight */\n            newurl = strdup(data->state.url);\n          /* if we are to retry, set the result to OK and consider the request\n             as done */\n          retry = TRUE;\n          result = CURLE_OK;\n          done = TRUE;\n        }\n        else\n          result = ret;\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(data, result, TRUE);\n      }\n      else if(done) {\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          followtype follow = FOLLOW_NONE;\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          (void)multi_done(data, CURLE_OK, FALSE);\n          /* multi_done() might return CURLE_GOT_NOTHING */\n          result = Curl_follow(data, newurl, follow);\n          if(!result) {\n            multistate(data, MSTATE_CONNECT);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n          free(newurl);\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            free(newurl);\n            if(result) {\n              stream_error = TRUE;\n              result = multi_done(data, result, TRUE);\n            }\n          }\n\n          if(!result) {\n            multistate(data, MSTATE_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n      }\n      else if(comeback) {\n        /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer\n           won't get stuck on this transfer at the expense of other concurrent\n           transfers */\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n        rc = CURLM_OK;\n      }\n      break;\n    }\n\n    case MSTATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->conn) {\n        CURLcode res;\n\n        if(data->conn->bits.multiplex)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(data, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n      }\n\n#ifndef CURL_DISABLE_FTP\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with MSTATE_INIT */\n          multistate(data, MSTATE_INIT);\n          break;\n        }\n      }\n#endif\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, MSTATE_COMPLETED);\n      break;\n\n    case MSTATE_COMPLETED:\n      break;\n\n    case MSTATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < MSTATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->conn) {\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            struct connectdata *conn = data->conn;\n\n            /* This is where we make sure that the conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            Curl_detach_connnection(data);\n\n            /* remove connection from cache */\n            Curl_conncache_remove_conn(data, conn, TRUE);\n\n            /* disconnect properly */\n            Curl_disconnect(data, conn, dead_connection);\n          }\n        }\n        else if(data->mstate == MSTATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, MSTATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->conn && Curl_pgrsUpdate(data)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < MSTATE_DONE)?\n                   MSTATE_DONE: MSTATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(MSTATE_COMPLETED == data->mstate) {\n      if(data->set.fmultidone) {\n        /* signal via callback instead */\n        data->set.fmultidone(data, result);\n      }\n      else {\n        /* now fill in the Curl_message with this info */\n        msg = &data->msg;\n\n        msg->extmsg.msg = CURLMSG_DONE;\n        msg->extmsg.easy_handle = data;\n        msg->extmsg.data.result = result;\n\n        rc = multi_addmsg(multi, msg);\n        DEBUGASSERT(!data->conn);\n      }\n      multistate(data, MSTATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n  return rc;\n}\n\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, &now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    Curl_update_timer(multi);\n\n  return returncode;\n}\n\nCURLMcode curl_multi_cleanup(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  struct Curl_easy *nextdata;\n\n  if(GOOD_MULTI_HANDLE(multi)) {\n    if(multi->in_callback)\n      return CURLM_RECURSIVE_API_CALL;\n\n    multi->magic = 0; /* not good anymore */\n\n    /* Firsrt remove all remaining easy handles */\n    data = multi->easyp;\n    while(data) {\n      nextdata = data->next;\n      if(!data->state.done && data->conn)\n        /* if DONE was never called for this handle */\n        (void)multi_done(data, CURLE_OK, TRUE);\n      if(data->dns.hostcachetype == HCACHE_MULTI) {\n        /* clear out the usage of the shared DNS cache */\n        Curl_hostcache_clean(data, data->dns.hostcache);\n        data->dns.hostcache = NULL;\n        data->dns.hostcachetype = HCACHE_NONE;\n      }\n\n      /* Clear the pointer to the connection cache */\n      data->state.conn_cache = NULL;\n      data->multi = NULL; /* clear the association */\n\n#ifdef USE_LIBPSL\n      if(data->psl == &multi->psl)\n        data->psl = NULL;\n#endif\n\n      data = nextdata;\n    }\n\n    /* Close all the connections in the connection cache */\n    Curl_conncache_close_all_connections(&multi->conn_cache);\n\n    Curl_hash_destroy(&multi->sockhash);\n    Curl_conncache_destroy(&multi->conn_cache);\n    Curl_llist_destroy(&multi->msglist, NULL);\n    Curl_llist_destroy(&multi->pending, NULL);\n\n    Curl_hash_destroy(&multi->hostcache);\n    Curl_psl_destroy(&multi->psl);\n\n#ifdef USE_WINSOCK\n    WSACloseEvent(multi->wsa_event);\n#else\n#ifdef ENABLE_WAKEUP\n    sclose(multi->wakeup_pair[0]);\n    sclose(multi->wakeup_pair[1]);\n#endif\n#endif\n    free(multi);\n\n    return CURLM_OK;\n  }\n  return CURLM_BAD_HANDLE;\n}\n\n/*\n * curl_multi_info_read()\n *\n * This function is the primary way for a multi/multi_socket application to\n * figure out if a transfer has ended. We MUST make this function as fast as\n * possible as it will be polled frequently and we MUST NOT scan any lists in\n * here to figure out things. We must scale fine to thousands of handles and\n * beyond. The current design is fully O(1).\n */\n\nCURLMsg *curl_multi_info_read(struct Curl_multi *multi, int *msgs_in_queue)\n{\n  struct Curl_message *msg;\n\n  *msgs_in_queue = 0; /* default to none */\n\n  if(GOOD_MULTI_HANDLE(multi) &&\n     !multi->in_callback &&\n     Curl_llist_count(&multi->msglist)) {\n    /* there is one or more messages in the list */\n    struct Curl_llist_element *e;\n\n    /* extract the head of the list to return */\n    e = multi->msglist.head;\n\n    msg = e->ptr;\n\n    /* remove the extracted entry */\n    Curl_llist_remove(&multi->msglist, e, NULL);\n\n    *msgs_in_queue = curlx_uztosi(Curl_llist_count(&multi->msglist));\n\n    return &msg->extmsg;\n  }\n  return NULL;\n}\n\n/*\n * singlesocket() checks what sockets we deal with and their \"action state\"\n * and if we have a different state in any of those sockets from last time we\n * call the callback accordingly.\n */\nstatic CURLMcode singlesocket(struct Curl_multi *multi,\n                              struct Curl_easy *data)\n{\n  curl_socket_t socks[MAX_SOCKSPEREASYHANDLE];\n  int i;\n  struct Curl_sh_entry *entry;\n  curl_socket_t s;\n  int num;\n  unsigned int curraction;\n  unsigned char actions[MAX_SOCKSPEREASYHANDLE];\n\n  for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++)\n    socks[i] = CURL_SOCKET_BAD;\n\n  /* Fill in the 'current' struct with the state as it is now: what sockets to\n     supervise and for what actions */\n  curraction = multi_getsock(data, socks);\n\n  /* We have 0 .. N sockets already and we get to know about the 0 .. M\n     sockets we should have from now on. Detect the differences, remove no\n     longer supervised ones and add new ones */\n\n  /* walk over the sockets we got right now */\n  for(i = 0; (i< MAX_SOCKSPEREASYHANDLE) &&\n        (curraction & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i)));\n      i++) {\n    unsigned char action = CURL_POLL_NONE;\n    unsigned char prevaction = 0;\n    int comboaction;\n    bool sincebefore = FALSE;\n\n    s = socks[i];\n\n    /* get it from the hash */\n    entry = sh_getentry(&multi->sockhash, s);\n\n    if(curraction & GETSOCK_READSOCK(i))\n      action |= CURL_POLL_IN;\n    if(curraction & GETSOCK_WRITESOCK(i))\n      action |= CURL_POLL_OUT;\n\n    actions[i] = action;\n    if(entry) {\n      /* check if new for this transfer */\n      int j;\n      for(j = 0; j< data->numsocks; j++) {\n        if(s == data->sockets[j]) {\n          prevaction = data->actions[j];\n          sincebefore = TRUE;\n          break;\n        }\n      }\n    }\n    else {\n      /* this is a socket we didn't have before, add it to the hash! */\n      entry = sh_addentry(&multi->sockhash, s);\n      if(!entry)\n        /* fatal */\n        return CURLM_OUT_OF_MEMORY;\n    }\n    if(sincebefore && (prevaction != action)) {\n      /* Socket was used already, but different action now */\n      if(prevaction & CURL_POLL_IN)\n        entry->readers--;\n      if(prevaction & CURL_POLL_OUT)\n        entry->writers--;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n    }\n    else if(!sincebefore) {\n      /* a new user */\n      entry->users++;\n      if(action & CURL_POLL_IN)\n        entry->readers++;\n      if(action & CURL_POLL_OUT)\n        entry->writers++;\n\n      /* add 'data' to the transfer hash on this socket! */\n      if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */\n                        sizeof(struct Curl_easy *), data))\n        return CURLM_OUT_OF_MEMORY;\n    }\n\n    comboaction = (entry->writers? CURL_POLL_OUT : 0) |\n                   (entry->readers ? CURL_POLL_IN : 0);\n\n    /* socket existed before and has the same action set as before */\n    if(sincebefore && ((int)entry->action == comboaction))\n      /* same, continue */\n      continue;\n\n    if(multi->socket_cb)\n      multi->socket_cb(data, s, comboaction, multi->socket_userp,\n                       entry->socketp);\n\n    entry->action = comboaction; /* store the current action state */\n  }\n\n  num = i; /* number of sockets */\n\n  /* when we've walked over all the sockets we should have right now, we must\n     make sure to detect sockets that are removed */\n  for(i = 0; i< data->numsocks; i++) {\n    int j;\n    bool stillused = FALSE;\n    s = data->sockets[i];\n    for(j = 0; j < num; j++) {\n      if(s == socks[j]) {\n        /* this is still supervised */\n        stillused = TRUE;\n        break;\n      }\n    }\n    if(stillused)\n      continue;\n\n    entry = sh_getentry(&multi->sockhash, s);\n    /* if this is NULL here, the socket has been closed and notified so\n       already by Curl_multi_closed() */\n    if(entry) {\n      unsigned char oldactions = data->actions[i];\n      /* this socket has been removed. Decrease user count */\n      entry->users--;\n      if(oldactions & CURL_POLL_OUT)\n        entry->writers--;\n      if(oldactions & CURL_POLL_IN)\n        entry->readers--;\n      if(!entry->users) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n      else {\n        /* still users, but remove this handle as a user of this socket */\n        if(Curl_hash_delete(&entry->transfers, (char *)&data,\n                            sizeof(struct Curl_easy *))) {\n          DEBUGASSERT(NULL);\n        }\n      }\n    }\n  } /* for loop over numsocks */\n\n  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));\n  memcpy(data->actions, actions, num*sizeof(char));\n  data->numsocks = num;\n  return CURLM_OK;\n}\n\nvoid Curl_updatesocket(struct Curl_easy *data)\n{\n  singlesocket(data->multi, data);\n}\n\n\n/*\n * Curl_multi_closed()\n *\n * Used by the connect code to tell the multi_socket code that one of the\n * sockets we were using is about to be closed.  This function will then\n * remove it from the sockethash for this handle to make the multi_socket API\n * behave properly, especially for the case when libcurl will create another\n * socket again and it gets the same file descriptor number.\n */\n\nvoid Curl_multi_closed(struct Curl_easy *data, curl_socket_t s)\n{\n  if(data) {\n    /* if there's still an easy handle associated with this connection */\n    struct Curl_multi *multi = data->multi;\n    if(multi) {\n      /* this is set if this connection is part of a handle that is added to\n         a multi handle, and only then this is necessary */\n      struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n      if(entry) {\n        if(multi->socket_cb)\n          multi->socket_cb(data, s, CURL_POLL_REMOVE,\n                           multi->socket_userp,\n                           entry->socketp);\n\n        /* now remove it from the socket hash */\n        sh_delentry(entry, &multi->sockhash, s);\n      }\n    }\n  }\n}\n\n/*\n * add_next_timeout()\n *\n * Each Curl_easy has a list of timeouts. The add_next_timeout() is called\n * when it has just been removed from the splay tree because the timeout has\n * expired. This function is then to advance in the list to pick the next\n * timeout to use (skip the already expired ones) and add this node back to\n * the splay tree again.\n *\n * The splay tree only has each sessionhandle as a single node and the nearest\n * timeout is used to sort it on.\n */\nstatic CURLMcode add_next_timeout(struct curltime now,\n                                  struct Curl_multi *multi,\n                                  struct Curl_easy *d)\n{\n  struct curltime *tv = &d->state.expiretime;\n  struct Curl_llist *list = &d->state.timeoutlist;\n  struct Curl_llist_element *e;\n  struct time_node *node = NULL;\n\n  /* move over the timeout list for this specific handle and remove all\n     timeouts that are now passed tense and store the next pending\n     timeout in *tv */\n  for(e = list->head; e;) {\n    struct Curl_llist_element *n = e->next;\n    timediff_t diff;\n    node = (struct time_node *)e->ptr;\n    diff = Curl_timediff(node->time, now);\n    if(diff <= 0)\n      /* remove outdated entry */\n      Curl_llist_remove(list, e, NULL);\n    else\n      /* the list is sorted so get out on the first mismatch */\n      break;\n    e = n;\n  }\n  e = list->head;\n  if(!e) {\n    /* clear the expire times within the handles that we remove from the\n       splay tree */\n    tv->tv_sec = 0;\n    tv->tv_usec = 0;\n  }\n  else {\n    /* copy the first entry to 'tv' */\n    memcpy(tv, &node->time, sizeof(*tv));\n\n    /* Insert this node again into the splay.  Keep the timer in the list in\n       case we need to recompute future timers. */\n    multi->timetree = Curl_splayinsert(*tv, multi->timetree,\n                                       &d->state.timenode);\n  }\n  return CURLM_OK;\n}\n\nstatic CURLMcode multi_socket(struct Curl_multi *multi,\n                              bool checkall,\n                              curl_socket_t s,\n                              int ev_bitmask,\n                              int *running_handles)\n{\n  CURLMcode result = CURLM_OK;\n  struct Curl_easy *data = NULL;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(checkall) {\n    /* *perform() deals with running_handles on its own */\n    result = curl_multi_perform(multi, running_handles);\n\n    /* walk through each easy handle and do the socket state change magic\n       and callbacks */\n    if(result != CURLM_BAD_HANDLE) {\n      data = multi->easyp;\n      while(data && !result) {\n        result = singlesocket(multi, data);\n        data = data->next;\n      }\n    }\n\n    /* or should we fall-through and do the timer-based stuff? */\n    return result;\n  }\n  if(s != CURL_SOCKET_TIMEOUT) {\n    struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n    if(!entry)\n      /* Unmatched socket, we can't act on it but we ignore this fact.  In\n         real-world tests it has been proved that libevent can in fact give\n         the application actions even though the socket was just previously\n         asked to get removed, so thus we better survive stray socket actions\n         and just move on. */\n      ;\n    else {\n      struct Curl_hash_iterator iter;\n      struct Curl_hash_element *he;\n\n      /* the socket can be shared by many transfers, iterate */\n      Curl_hash_start_iterate(&entry->transfers, &iter);\n      for(he = Curl_hash_next_element(&iter); he;\n          he = Curl_hash_next_element(&iter)) {\n        data = (struct Curl_easy *)he->ptr;\n        DEBUGASSERT(data);\n        DEBUGASSERT(data->magic == CURLEASY_MAGIC_NUMBER);\n\n        if(data->conn && !(data->conn->handler->flags & PROTOPT_DIRLOCK))\n          /* set socket event bitmask if they're not locked */\n          data->conn->cselect_bits = ev_bitmask;\n\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n      }\n\n      /* Now we fall-through and do the timer-based stuff, since we don't want\n         to force the user to have to deal with timeouts as long as at least\n         one connection in fact has traffic. */\n\n      data = NULL; /* set data to NULL again to avoid calling\n                      multi_runsingle() in case there's no need to */\n      now = Curl_now(); /* get a newer time since the multi_runsingle() loop\n                           may have taken some time */\n    }\n  }\n  else {\n    /* Asked to run due to time-out. Clear the 'lastcall' variable to force\n       Curl_update_timer() to trigger a callback to the app again even if the\n       same timeout is still the one to run after this call. That handles the\n       case when the application asks libcurl to run the timeout\n       prematurely. */\n    memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));\n  }\n\n  /*\n   * The loop following here will go on as long as there are expire-times left\n   * to process in the splay and 'data' will be re-assigned for every expired\n   * handle we deal with.\n   */\n  do {\n    /* the first loop lap 'data' can be NULL */\n    if(data) {\n      SIGPIPE_VARIABLE(pipe_st);\n\n      sigpipe_ignore(data, &pipe_st);\n      result = multi_runsingle(multi, &now, data);\n      sigpipe_restore(&pipe_st);\n\n      if(CURLM_OK >= result) {\n        /* get the socket(s) and check if the state has been changed since\n           last */\n        result = singlesocket(multi, data);\n        if(result)\n          return result;\n      }\n    }\n\n    /* Check if there's one (more) expired timer to deal with! This function\n       extracts a matching node if there is one */\n\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t) {\n      data = t->payload; /* assign this for next loop */\n      (void)add_next_timeout(now, multi, t->payload);\n    }\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n  return result;\n}\n\n#undef curl_multi_setopt\nCURLMcode curl_multi_setopt(struct Curl_multi *multi,\n                            CURLMoption option, ...)\n{\n  CURLMcode res = CURLM_OK;\n  va_list param;\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  va_start(param, option);\n\n  switch(option) {\n  case CURLMOPT_SOCKETFUNCTION:\n    multi->socket_cb = va_arg(param, curl_socket_callback);\n    break;\n  case CURLMOPT_SOCKETDATA:\n    multi->socket_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PUSHFUNCTION:\n    multi->push_cb = va_arg(param, curl_push_callback);\n    break;\n  case CURLMOPT_PUSHDATA:\n    multi->push_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_PIPELINING:\n    multi->multiplexing = va_arg(param, long) & CURLPIPE_MULTIPLEX;\n    break;\n  case CURLMOPT_TIMERFUNCTION:\n    multi->timer_cb = va_arg(param, curl_multi_timer_callback);\n    break;\n  case CURLMOPT_TIMERDATA:\n    multi->timer_userp = va_arg(param, void *);\n    break;\n  case CURLMOPT_MAXCONNECTS:\n    multi->maxconnects = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_HOST_CONNECTIONS:\n    multi->max_host_connections = va_arg(param, long);\n    break;\n  case CURLMOPT_MAX_TOTAL_CONNECTIONS:\n    multi->max_total_connections = va_arg(param, long);\n    break;\n    /* options formerly used for pipelining */\n  case CURLMOPT_MAX_PIPELINE_LENGTH:\n    break;\n  case CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE:\n    break;\n  case CURLMOPT_PIPELINING_SITE_BL:\n    break;\n  case CURLMOPT_PIPELINING_SERVER_BL:\n    break;\n  case CURLMOPT_MAX_CONCURRENT_STREAMS:\n    {\n      long streams = va_arg(param, long);\n      if(streams < 1)\n        streams = 100;\n      multi->max_concurrent_streams = curlx_sltoui(streams);\n    }\n    break;\n  default:\n    res = CURLM_UNKNOWN_OPTION;\n    break;\n  }\n  va_end(param);\n  return res;\n}\n\n/* we define curl_multi_socket() in the public multi.h header */\n#undef curl_multi_socket\n\nCURLMcode curl_multi_socket(struct Curl_multi *multi, curl_socket_t s,\n                            int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_action(struct Curl_multi *multi, curl_socket_t s,\n                                   int ev_bitmask, int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, FALSE, s, ev_bitmask, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nCURLMcode curl_multi_socket_all(struct Curl_multi *multi, int *running_handles)\n{\n  CURLMcode result;\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n  result = multi_socket(multi, TRUE, CURL_SOCKET_BAD, 0, running_handles);\n  if(CURLM_OK >= result)\n    Curl_update_timer(multi);\n  return result;\n}\n\nstatic CURLMcode multi_timeout(struct Curl_multi *multi,\n                               long *timeout_ms)\n{\n  static struct curltime tv_zero = {0, 0};\n\n  if(multi->timetree) {\n    /* we have a tree of expire times */\n    struct curltime now = Curl_now();\n\n    /* splay the lowest to the bottom */\n    multi->timetree = Curl_splay(tv_zero, multi->timetree);\n\n    if(Curl_splaycomparekeys(multi->timetree->key, now) > 0) {\n      /* some time left before expiration */\n      timediff_t diff = Curl_timediff(multi->timetree->key, now);\n      if(diff <= 0)\n        /*\n         * Since we only provide millisecond resolution on the returned value\n         * and the diff might be less than one millisecond here, we don't\n         * return zero as that may cause short bursts of busyloops on fast\n         * processors while the diff is still present but less than one\n         * millisecond! instead we return 1 until the time is ripe.\n         */\n        *timeout_ms = 1;\n      else\n        /* this should be safe even on 64 bit archs, as we don't use that\n           overly long timeouts */\n        *timeout_ms = (long)diff;\n    }\n    else\n      /* 0 means immediately */\n      *timeout_ms = 0;\n  }\n  else\n    *timeout_ms = -1;\n\n  return CURLM_OK;\n}\n\nCURLMcode curl_multi_timeout(struct Curl_multi *multi,\n                             long *timeout_ms)\n{\n  /* First, make some basic checks that the CURLM handle is a good handle */\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  return multi_timeout(multi, timeout_ms);\n}\n\n/*\n * Tell the application it should update its timers, if it subscribes to the\n * update timer callback.\n */\nvoid Curl_update_timer(struct Curl_multi *multi)\n{\n  long timeout_ms;\n\n  if(!multi->timer_cb)\n    return;\n  if(multi_timeout(multi, &timeout_ms)) {\n    return;\n  }\n  if(timeout_ms < 0) {\n    static const struct curltime none = {0, 0};\n    if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {\n      multi->timer_lastcall = none;\n      /* there's no timeout now but there was one previously, tell the app to\n         disable it */\n      multi->timer_cb(multi, -1, multi->timer_userp);\n      return;\n    }\n    return;\n  }\n\n  /* When multi_timeout() is done, multi->timetree points to the node with the\n   * timeout we got the (relative) time-out time for. We can thus easily check\n   * if this is the same (fixed) time as we got in a previous call and then\n   * avoid calling the callback again. */\n  if(Curl_splaycomparekeys(multi->timetree->key, multi->timer_lastcall) == 0)\n    return;\n\n  multi->timer_lastcall = multi->timetree->key;\n\n  multi->timer_cb(multi, timeout_ms, multi->timer_userp);\n}\n\n/*\n * multi_deltimeout()\n *\n * Remove a given timestamp from the list of timeouts.\n */\nstatic void\nmulti_deltimeout(struct Curl_easy *data, expire_id eid)\n{\n  struct Curl_llist_element *e;\n  struct Curl_llist *timeoutlist = &data->state.timeoutlist;\n  /* find and remove the specific node from the list */\n  for(e = timeoutlist->head; e; e = e->next) {\n    struct time_node *n = (struct time_node *)e->ptr;\n    if(n->eid == eid) {\n      Curl_llist_remove(timeoutlist, e, NULL);\n      return;\n    }\n  }\n}\n\n/*\n * multi_addtimeout()\n *\n * Add a timestamp to the list of timeouts. Keep the list sorted so that head\n * of list is always the timeout nearest in time.\n *\n */\nstatic CURLMcode\nmulti_addtimeout(struct Curl_easy *data,\n                 struct curltime *stamp,\n                 expire_id eid)\n{\n  struct Curl_llist_element *e;\n  struct time_node *node;\n  struct Curl_llist_element *prev = NULL;\n  size_t n;\n  struct Curl_llist *timeoutlist = &data->state.timeoutlist;\n\n  node = &data->state.expires[eid];\n\n  /* copy the timestamp and id */\n  memcpy(&node->time, stamp, sizeof(*stamp));\n  node->eid = eid; /* also marks it as in use */\n\n  n = Curl_llist_count(timeoutlist);\n  if(n) {\n    /* find the correct spot in the list */\n    for(e = timeoutlist->head; e; e = e->next) {\n      struct time_node *check = (struct time_node *)e->ptr;\n      timediff_t diff = Curl_timediff(check->time, node->time);\n      if(diff > 0)\n        break;\n      prev = e;\n    }\n\n  }\n  /* else\n     this is the first timeout on the list */\n\n  Curl_llist_insert_next(timeoutlist, prev, node, &node->list);\n  return CURLM_OK;\n}\n\n/*\n * Curl_expire()\n *\n * given a number of milliseconds from now to use to set the 'act before\n * this'-time for the transfer, to be extracted by curl_multi_timeout()\n *\n * The timeout will be added to a queue of timeouts if it defines a moment in\n * time that is later than the current head of queue.\n *\n * Expire replaces a former timeout using the same id if already set.\n */\nvoid Curl_expire(struct Curl_easy *data, timediff_t milli, expire_id id)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n  struct curltime set;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  DEBUGASSERT(id < EXPIRE_LAST);\n\n  set = Curl_now();\n  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */\n  set.tv_usec += (unsigned int)(milli%1000)*1000;\n\n  if(set.tv_usec >= 1000000) {\n    set.tv_sec++;\n    set.tv_usec -= 1000000;\n  }\n\n  /* Remove any timer with the same id just in case. */\n  multi_deltimeout(data, id);\n\n  /* Add it to the timer list.  It must stay in the list until it has expired\n     in case we need to recompute the minimum timer later. */\n  multi_addtimeout(data, &set, id);\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* This means that the struct is added as a node in the splay tree.\n       Compare if the new time is earlier, and only remove-old/add-new if it\n       is. */\n    timediff_t diff = Curl_timediff(set, *nowp);\n    int rc;\n\n    if(diff > 0) {\n      /* The current splay tree entry is sooner than this new expiry time.\n         We don't need to update our splay tree entry. */\n      return;\n    }\n\n    /* Since this is an updated time, we must remove the previous entry from\n       the splay tree first and then re-add the new value */\n    rc = Curl_splayremove(multi->timetree, &data->state.timenode,\n                          &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error removing splay node = %d\\n\", rc);\n  }\n\n  /* Indicate that we are in the splay tree and insert the new timer expiry\n     value since it is our local minimum. */\n  *nowp = set;\n  data->state.timenode.payload = data;\n  multi->timetree = Curl_splayinsert(*nowp, multi->timetree,\n                                     &data->state.timenode);\n}\n\n/*\n * Curl_expire_done()\n *\n * Removes the expire timer. Marks it as done.\n *\n */\nvoid Curl_expire_done(struct Curl_easy *data, expire_id id)\n{\n  /* remove the timer, if there */\n  multi_deltimeout(data, id);\n}\n\n/*\n * Curl_expire_clear()\n *\n * Clear ALL timeout values for this handle.\n */\nvoid Curl_expire_clear(struct Curl_easy *data)\n{\n  struct Curl_multi *multi = data->multi;\n  struct curltime *nowp = &data->state.expiretime;\n\n  /* this is only interesting while there is still an associated multi struct\n     remaining! */\n  if(!multi)\n    return;\n\n  if(nowp->tv_sec || nowp->tv_usec) {\n    /* Since this is an cleared time, we must remove the previous entry from\n       the splay tree */\n    struct Curl_llist *list = &data->state.timeoutlist;\n    int rc;\n\n    rc = Curl_splayremove(multi->timetree, &data->state.timenode,\n                          &multi->timetree);\n    if(rc)\n      infof(data, \"Internal error clearing splay node = %d\\n\", rc);\n\n    /* flush the timeout list too */\n    while(list->size > 0) {\n      Curl_llist_remove(list, list->tail, NULL);\n    }\n\n#ifdef DEBUGBUILD\n    infof(data, \"Expire cleared (transfer %p)\\n\", data);\n#endif\n    nowp->tv_sec = 0;\n    nowp->tv_usec = 0;\n  }\n}\n\n\n\n\nCURLMcode curl_multi_assign(struct Curl_multi *multi, curl_socket_t s,\n                            void *hashp)\n{\n  struct Curl_sh_entry *there = NULL;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  there = sh_getentry(&multi->sockhash, s);\n\n  if(!there)\n    return CURLM_BAD_SOCKET;\n\n  there->socketp = hashp;\n\n  return CURLM_OK;\n}\n\nsize_t Curl_multi_max_host_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_host_connections : 0;\n}\n\nsize_t Curl_multi_max_total_connections(struct Curl_multi *multi)\n{\n  return multi ? multi->max_total_connections : 0;\n}\n\n/*\n * When information about a connection has appeared, call this!\n */\n\nvoid Curl_multiuse_state(struct Curl_easy *data,\n                         int bundlestate) /* use BUNDLE_* defines */\n{\n  struct connectdata *conn;\n  DEBUGASSERT(data);\n  DEBUGASSERT(data->multi);\n  conn = data->conn;\n  DEBUGASSERT(conn);\n  DEBUGASSERT(conn->bundle);\n\n  conn->bundle->multiuse = bundlestate;\n  process_pending_handles(data->multi);\n}\n\nstatic void process_pending_handles(struct Curl_multi *multi)\n{\n  struct Curl_llist_element *e = multi->pending.head;\n  if(e) {\n    struct Curl_easy *data = e->ptr;\n\n    DEBUGASSERT(data->mstate == MSTATE_PENDING);\n\n    multistate(data, MSTATE_CONNECT);\n\n    /* Remove this node from the list */\n    Curl_llist_remove(&multi->pending, e, NULL);\n\n    /* Make sure that the handle will be processed soonish. */\n    Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n    /* mark this as having been in the pending queue */\n    data->state.previouslypending = TRUE;\n  }\n}\n\nvoid Curl_set_in_callback(struct Curl_easy *data, bool value)\n{\n  /* might get called when there is no data pointer! */\n  if(data) {\n    if(data->multi_easy)\n      data->multi_easy->in_callback = value;\n    else if(data->multi)\n      data->multi->in_callback = value;\n  }\n}\n\nbool Curl_is_in_callback(struct Curl_easy *easy)\n{\n  return ((easy->multi && easy->multi->in_callback) ||\n          (easy->multi_easy && easy->multi_easy->in_callback));\n}\n\n#ifdef DEBUGBUILD\nvoid Curl_multi_dump(struct Curl_multi *multi)\n{\n  struct Curl_easy *data;\n  int i;\n  fprintf(stderr, \"* Multi status: %d handles, %d alive\\n\",\n          multi->num_easy, multi->num_alive);\n  for(data = multi->easyp; data; data = data->next) {\n    if(data->mstate < MSTATE_COMPLETED) {\n      /* only display handles that are not completed */\n      fprintf(stderr, \"handle %p, state %s, %d sockets\\n\",\n              (void *)data,\n              statename[data->mstate], data->numsocks);\n      for(i = 0; i < data->numsocks; i++) {\n        curl_socket_t s = data->sockets[i];\n        struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);\n\n        fprintf(stderr, \"%d \", (int)s);\n        if(!entry) {\n          fprintf(stderr, \"INTERNAL CONFUSION\\n\");\n          continue;\n        }\n        fprintf(stderr, \"[%s %s] \",\n                (entry->action&CURL_POLL_IN)?\"RECVING\":\"\",\n                (entry->action&CURL_POLL_OUT)?\"SENDING\":\"\");\n      }\n      if(data->numsocks)\n        fprintf(stderr, \"\\n\");\n    }\n  }\n}\n#endif\n\nunsigned int Curl_multi_max_concurrent_streams(struct Curl_multi *multi)\n{\n  DEBUGASSERT(multi);\n  return multi->max_concurrent_streams;\n}\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef USE_GSKIT\n\n#include <gskssl.h>\n#include <qsoasync.h>\n#undef HAVE_SOCKETPAIR /* because the native one isn't good enough */\n#include \"socketpair.h\"\n\n/* Some symbols are undefined/unsupported on OS400 versions < V7R1. */\n#ifndef GSK_SSL_EXTN_SERVERNAME_REQUEST\n#define GSK_SSL_EXTN_SERVERNAME_REQUEST         230\n#endif\n\n#ifndef GSK_TLSV10_CIPHER_SPECS\n#define GSK_TLSV10_CIPHER_SPECS                 236\n#endif\n\n#ifndef GSK_TLSV11_CIPHER_SPECS\n#define GSK_TLSV11_CIPHER_SPECS                 237\n#endif\n\n#ifndef GSK_TLSV12_CIPHER_SPECS\n#define GSK_TLSV12_CIPHER_SPECS                 238\n#endif\n\n#ifndef GSK_PROTOCOL_TLSV11\n#define GSK_PROTOCOL_TLSV11                     437\n#endif\n\n#ifndef GSK_PROTOCOL_TLSV12\n#define GSK_PROTOCOL_TLSV12                     438\n#endif\n\n#ifndef GSK_FALSE\n#define GSK_FALSE                               0\n#endif\n\n#ifndef GSK_TRUE\n#define GSK_TRUE                                1\n#endif\n\n\n#include <limits.h>\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"gskit.h\"\n#include \"vtls.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n\n/* Directions. */\n#define SOS_READ        0x01\n#define SOS_WRITE       0x02\n\n/* SSL version flags. */\n#define CURL_GSKPROTO_SSLV2     0\n#define CURL_GSKPROTO_SSLV2_MASK        (1 << CURL_GSKPROTO_SSLV2)\n#define CURL_GSKPROTO_SSLV3     1\n#define CURL_GSKPROTO_SSLV3_MASK        (1 << CURL_GSKPROTO_SSLV3)\n#define CURL_GSKPROTO_TLSV10    2\n#define CURL_GSKPROTO_TLSV10_MASK        (1 << CURL_GSKPROTO_TLSV10)\n#define CURL_GSKPROTO_TLSV11    3\n#define CURL_GSKPROTO_TLSV11_MASK        (1 << CURL_GSKPROTO_TLSV11)\n#define CURL_GSKPROTO_TLSV12    4\n#define CURL_GSKPROTO_TLSV12_MASK        (1 << CURL_GSKPROTO_TLSV12)\n#define CURL_GSKPROTO_LAST      5\n\nstruct ssl_backend_data {\n  gsk_handle handle;\n  int iocport;\n#ifndef CURL_DISABLE_PROXY\n  int localfd;\n  int remotefd;\n#endif\n};\n\n#define BACKEND connssl->backend\n\n/* Supported ciphers. */\nstruct gskit_cipher {\n  const char *name;            /* Cipher name. */\n  const char *gsktoken;        /* Corresponding token for GSKit String. */\n  unsigned int versions;       /* SSL version flags. */\n};\n\nstatic const struct gskit_cipher  ciphertable[] = {\n  { \"null-md5\",         \"01\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"null-sha\",         \"02\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"exp-rc4-md5\",      \"03\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK },\n  { \"rc4-md5\",          \"04\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"rc4-sha\",          \"05\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"exp-rc2-cbc-md5\",  \"06\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK },\n  { \"exp-des-cbc-sha\",  \"09\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK },\n  { \"des-cbc3-sha\",     \"0A\",\n      CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK |\n      CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-sha\",       \"2F\",\n      CURL_GSKPROTO_TLSV10_MASK | CURL_GSKPROTO_TLSV11_MASK |\n      CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-sha\",       \"35\",\n      CURL_GSKPROTO_TLSV10_MASK | CURL_GSKPROTO_TLSV11_MASK |\n      CURL_GSKPROTO_TLSV12_MASK },\n  { \"null-sha256\",      \"3B\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-sha256\",    \"3C\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-sha256\",    \"3D\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes128-gcm-sha256\",\n                        \"9C\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"aes256-gcm-sha384\",\n                        \"9D\",   CURL_GSKPROTO_TLSV12_MASK },\n  { \"rc4-md5\",          \"1\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"exp-rc4-md5\",      \"2\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"rc2-md5\",          \"3\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"exp-rc2-md5\",      \"4\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"des-cbc-md5\",      \"6\",    CURL_GSKPROTO_SSLV2_MASK },\n  { \"des-cbc3-md5\",     \"7\",    CURL_GSKPROTO_SSLV2_MASK },\n  { (const char *) NULL, (const char *) NULL, 0       }\n};\n\n\nstatic bool is_separator(char c)\n{\n  /* Return whether character is a cipher list separator. */\n  switch(c) {\n  case ' ':\n  case '\\t':\n  case ':':\n  case ',':\n  case ';':\n    return true;\n  }\n  return false;\n}\n\n\nstatic CURLcode gskit_status(struct Curl_easy *data, int rc,\n                             const char *procname, CURLcode defcode)\n{\n  /* Process GSKit status and map it to a CURLcode. */\n  switch(rc) {\n  case GSK_OK:\n  case GSK_OS400_ASYNCHRONOUS_SOC_INIT:\n    return CURLE_OK;\n  case GSK_KEYRING_OPEN_ERROR:\n  case GSK_OS400_ERROR_NO_ACCESS:\n    return CURLE_SSL_CACERT_BADFILE;\n  case GSK_INSUFFICIENT_STORAGE:\n    return CURLE_OUT_OF_MEMORY;\n  case GSK_ERROR_BAD_V2_CIPHER:\n  case GSK_ERROR_BAD_V3_CIPHER:\n  case GSK_ERROR_NO_CIPHERS:\n    return CURLE_SSL_CIPHER;\n  case GSK_OS400_ERROR_NOT_TRUSTED_ROOT:\n  case GSK_ERROR_CERT_VALIDATION:\n    return CURLE_PEER_FAILED_VERIFICATION;\n  case GSK_OS400_ERROR_TIMED_OUT:\n    return CURLE_OPERATION_TIMEDOUT;\n  case GSK_WOULD_BLOCK:\n    return CURLE_AGAIN;\n  case GSK_OS400_ERROR_NOT_REGISTERED:\n    break;\n  case GSK_ERROR_IO:\n    switch(errno) {\n    case ENOMEM:\n      return CURLE_OUT_OF_MEMORY;\n    default:\n      failf(data, \"%s I/O error: %s\", procname, strerror(errno));\n      break;\n    }\n    break;\n  default:\n    failf(data, \"%s: %s\", procname, gsk_strerror(rc));\n    break;\n  }\n  return defcode;\n}\n\n\nstatic CURLcode set_enum(struct Curl_easy *data, gsk_handle h,\n                GSK_ENUM_ID id, GSK_ENUM_VALUE value, bool unsupported_ok)\n{\n  int rc = gsk_attribute_set_enum(h, id, value);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_enum() I/O error: %s\", strerror(errno));\n    break;\n  case GSK_ATTRIBUTE_INVALID_ID:\n    if(unsupported_ok)\n      return CURLE_UNSUPPORTED_PROTOCOL;\n  default:\n    failf(data, \"gsk_attribute_set_enum(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_buffer(struct Curl_easy *data, gsk_handle h,\n                        GSK_BUF_ID id, const char *buffer, bool unsupported_ok)\n{\n  int rc = gsk_attribute_set_buffer(h, id, buffer, 0);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_buffer() I/O error: %s\", strerror(errno));\n    break;\n  case GSK_ATTRIBUTE_INVALID_ID:\n    if(unsupported_ok)\n      return CURLE_UNSUPPORTED_PROTOCOL;\n  default:\n    failf(data, \"gsk_attribute_set_buffer(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_numeric(struct Curl_easy *data,\n                            gsk_handle h, GSK_NUM_ID id, int value)\n{\n  int rc = gsk_attribute_set_numeric_value(h, id, value);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_numeric_value() I/O error: %s\",\n          strerror(errno));\n    break;\n  default:\n    failf(data, \"gsk_attribute_set_numeric_value(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_callback(struct Curl_easy *data,\n                             gsk_handle h, GSK_CALLBACK_ID id, void *info)\n{\n  int rc = gsk_attribute_set_callback(h, id, info);\n\n  switch(rc) {\n  case GSK_OK:\n    return CURLE_OK;\n  case GSK_ERROR_IO:\n    failf(data, \"gsk_attribute_set_callback() I/O error: %s\", strerror(errno));\n    break;\n  default:\n    failf(data, \"gsk_attribute_set_callback(): %s\", gsk_strerror(rc));\n    break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n\nstatic CURLcode set_ciphers(struct Curl_easy *data,\n                            gsk_handle h, unsigned int *protoflags)\n{\n  struct connectdata *conn = data->conn;\n  const char *cipherlist = SSL_CONN_CONFIG(cipher_list);\n  const char *clp;\n  const struct gskit_cipher *ctp;\n  int i;\n  int l;\n  bool unsupported;\n  CURLcode result;\n  struct {\n    char *buf;\n    char *ptr;\n  } ciphers[CURL_GSKPROTO_LAST];\n\n  /* Compile cipher list into GSKit-compatible cipher lists. */\n\n  if(!cipherlist)\n    return CURLE_OK;\n  while(is_separator(*cipherlist))     /* Skip initial separators. */\n    cipherlist++;\n  if(!*cipherlist)\n    return CURLE_OK;\n\n  /* We allocate GSKit buffers of the same size as the input string: since\n     GSKit tokens are always shorter than their cipher names, allocated buffers\n     will always be large enough to accommodate the result. */\n  l = strlen(cipherlist) + 1;\n  memset((char *) ciphers, 0, sizeof(ciphers));\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n    ciphers[i].buf = malloc(l);\n    if(!ciphers[i].buf) {\n      while(i--)\n        free(ciphers[i].buf);\n      return CURLE_OUT_OF_MEMORY;\n    }\n    ciphers[i].ptr = ciphers[i].buf;\n    *ciphers[i].ptr = '\\0';\n  }\n\n  /* Process each cipher in input string. */\n  unsupported = FALSE;\n  result = CURLE_OK;\n  for(;;) {\n    for(clp = cipherlist; *cipherlist && !is_separator(*cipherlist);)\n      cipherlist++;\n    l = cipherlist - clp;\n    if(!l)\n      break;\n    /* Search the cipher in our table. */\n    for(ctp = ciphertable; ctp->name; ctp++)\n      if(strncasecompare(ctp->name, clp, l) && !ctp->name[l])\n        break;\n    if(!ctp->name) {\n      failf(data, \"Unknown cipher %.*s\", l, clp);\n      result = CURLE_SSL_CIPHER;\n    }\n    else {\n      unsupported |= !(ctp->versions & (CURL_GSKPROTO_SSLV2_MASK |\n                        CURL_GSKPROTO_SSLV3_MASK | CURL_GSKPROTO_TLSV10_MASK));\n      for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n        if(ctp->versions & (1 << i)) {\n          strcpy(ciphers[i].ptr, ctp->gsktoken);\n          ciphers[i].ptr += strlen(ctp->gsktoken);\n        }\n      }\n    }\n\n   /* Advance to next cipher name or end of string. */\n    while(is_separator(*cipherlist))\n      cipherlist++;\n  }\n\n  /* Disable protocols with empty cipher lists. */\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++) {\n    if(!(*protoflags & (1 << i)) || !ciphers[i].buf[0]) {\n      *protoflags &= ~(1 << i);\n      ciphers[i].buf[0] = '\\0';\n    }\n  }\n\n  /* Try to set-up TLSv1.1 and TLSv2.1 ciphers. */\n  if(*protoflags & CURL_GSKPROTO_TLSV11_MASK) {\n    result = set_buffer(data, h, GSK_TLSV11_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV11].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(unsupported) {\n        failf(data, \"TLSv1.1-only ciphers are not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result && (*protoflags & CURL_GSKPROTO_TLSV12_MASK)) {\n    result = set_buffer(data, h, GSK_TLSV12_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV12].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(unsupported) {\n        failf(data, \"TLSv1.2-only ciphers are not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n\n  /* Try to set-up TLSv1.0 ciphers. If not successful, concatenate them to\n     the SSLv3 ciphers. OS/400 prior to version 7.1 will understand it. */\n  if(!result && (*protoflags & CURL_GSKPROTO_TLSV10_MASK)) {\n    result = set_buffer(data, h, GSK_TLSV10_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_TLSV10].buf, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      strcpy(ciphers[CURL_GSKPROTO_SSLV3].ptr,\n             ciphers[CURL_GSKPROTO_TLSV10].ptr);\n    }\n  }\n\n  /* Set-up other ciphers. */\n  if(!result && (*protoflags & CURL_GSKPROTO_SSLV3_MASK))\n    result = set_buffer(data, h, GSK_V3_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_SSLV3].buf, FALSE);\n  if(!result && (*protoflags & CURL_GSKPROTO_SSLV2_MASK))\n    result = set_buffer(data, h, GSK_V2_CIPHER_SPECS,\n                        ciphers[CURL_GSKPROTO_SSLV2].buf, FALSE);\n\n  /* Clean-up. */\n  for(i = 0; i < CURL_GSKPROTO_LAST; i++)\n    free(ciphers[i].buf);\n\n  return result;\n}\n\n\nstatic int gskit_init(void)\n{\n  /* No initialisation needed. */\n\n  return 1;\n}\n\n\nstatic void gskit_cleanup(void)\n{\n  /* Nothing to do. */\n}\n\n\nstatic CURLcode init_environment(struct Curl_easy *data,\n                                 gsk_handle *envir, const char *appid,\n                                 const char *file, const char *label,\n                                 const char *password)\n{\n  int rc;\n  CURLcode result;\n  gsk_handle h;\n\n  /* Creates the GSKit environment. */\n\n  rc = gsk_environment_open(&h);\n  switch(rc) {\n  case GSK_OK:\n    break;\n  case GSK_INSUFFICIENT_STORAGE:\n    return CURLE_OUT_OF_MEMORY;\n  default:\n    failf(data, \"gsk_environment_open(): %s\", gsk_strerror(rc));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  result = set_enum(data, h, GSK_SESSION_TYPE, GSK_CLIENT_SESSION, FALSE);\n  if(!result && appid)\n    result = set_buffer(data, h, GSK_OS400_APPLICATION_ID, appid, FALSE);\n  if(!result && file)\n    result = set_buffer(data, h, GSK_KEYRING_FILE, file, FALSE);\n  if(!result && label)\n    result = set_buffer(data, h, GSK_KEYRING_LABEL, label, FALSE);\n  if(!result && password)\n    result = set_buffer(data, h, GSK_KEYRING_PW, password, FALSE);\n\n  if(!result) {\n    /* Locate CAs, Client certificate and key according to our settings.\n       Note: this call may be blocking for some tenths of seconds. */\n    result = gskit_status(data, gsk_environment_init(h),\n                          \"gsk_environment_init()\", CURLE_SSL_CERTPROBLEM);\n    if(!result) {\n      *envir = h;\n      return result;\n    }\n  }\n  /* Error: rollback. */\n  gsk_environment_close(&h);\n  return result;\n}\n\n\nstatic void cancel_async_handshake(struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  Qso_OverlappedIO_t cstat;\n\n  if(QsoCancelOperation(conn->sock[sockindex], 0) > 0)\n    QsoWaitForIOCompletion(BACKEND->iocport, &cstat, (struct timeval *) NULL);\n}\n\n\nstatic void close_async_handshake(struct ssl_connect_data *connssl)\n{\n  QsoDestroyIOCompletionPort(BACKEND->iocport);\n  BACKEND->iocport = -1;\n}\n\nstatic int pipe_ssloverssl(struct connectdata *conn, int sockindex,\n                           int directions)\n{\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_connect_data *connproxyssl = &conn->proxy_ssl[sockindex];\n  fd_set fds_read;\n  fd_set fds_write;\n  int n;\n  int m;\n  int i;\n  int ret = 0;\n  char buf[CURL_MAX_WRITE_SIZE];\n\n  if(!connssl->use || !connproxyssl->use)\n    return 0;   /* No SSL over SSL: OK. */\n\n  FD_ZERO(&fds_read);\n  FD_ZERO(&fds_write);\n  n = -1;\n  if(directions & SOS_READ) {\n    FD_SET(BACKEND->remotefd, &fds_write);\n    n = BACKEND->remotefd;\n  }\n  if(directions & SOS_WRITE) {\n    FD_SET(BACKEND->remotefd, &fds_read);\n    n = BACKEND->remotefd;\n    FD_SET(conn->sock[sockindex], &fds_write);\n    if(n < conn->sock[sockindex])\n      n = conn->sock[sockindex];\n  }\n  i = Curl_select(n + 1, &fds_read, &fds_write, NULL, 0);\n  if(i < 0)\n    return -1;  /* Select error. */\n\n  if(FD_ISSET(BACKEND->remotefd, &fds_write)) {\n    /* Try getting data from HTTPS proxy and pipe it upstream. */\n    n = 0;\n    i = gsk_secure_soc_read(connproxyssl->backend->handle,\n                            buf, sizeof(buf), &n);\n    switch(i) {\n    case GSK_OK:\n      if(n) {\n        i = write(BACKEND->remotefd, buf, n);\n        if(i < 0)\n          return -1;\n        ret = 1;\n      }\n      break;\n    case GSK_OS400_ERROR_TIMED_OUT:\n    case GSK_WOULD_BLOCK:\n      break;\n    default:\n      return -1;\n    }\n  }\n\n  if(FD_ISSET(BACKEND->remotefd, &fds_read) &&\n     FD_ISSET(conn->sock[sockindex], &fds_write)) {\n    /* Pipe data to HTTPS proxy. */\n    n = read(BACKEND->remotefd, buf, sizeof(buf));\n    if(n < 0)\n      return -1;\n    if(n) {\n      i = gsk_secure_soc_write(connproxyssl->backend->handle, buf, n, &m);\n      if(i != GSK_OK || n != m)\n        return -1;\n      ret = 1;\n    }\n  }\n\n  return ret;  /* OK */\n#else\n  return 0;\n#endif\n}\n\n\nstatic void close_one(struct ssl_connect_data *connssl, struct Curl_easy *data,\n                      struct connectdata *conn, int sockindex)\n{\n  if(BACKEND->handle) {\n    gskit_status(data, gsk_secure_soc_close(&BACKEND->handle),\n              \"gsk_secure_soc_close()\", 0);\n    /* Last chance to drain output. */\n    while(pipe_ssloverssl(conn, sockindex, SOS_WRITE) > 0)\n      ;\n    BACKEND->handle = (gsk_handle) NULL;\n#ifndef CURL_DISABLE_PROXY\n    if(BACKEND->localfd >= 0) {\n      close(BACKEND->localfd);\n      BACKEND->localfd = -1;\n    }\n    if(BACKEND->remotefd >= 0) {\n      close(BACKEND->remotefd);\n      BACKEND->remotefd = -1;\n    }\n#endif\n  }\n  if(BACKEND->iocport >= 0)\n    close_async_handshake(connssl);\n}\n\n\nstatic ssize_t gskit_send(struct Curl_easy *data, int sockindex,\n                          const void *mem, size_t len, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CURLcode cc = CURLE_SEND_ERROR;\n  int written;\n\n  if(pipe_ssloverssl(conn, sockindex, SOS_WRITE) >= 0) {\n    cc = gskit_status(data,\n                      gsk_secure_soc_write(BACKEND->handle,\n                                           (char *) mem, (int) len, &written),\n                      \"gsk_secure_soc_write()\", CURLE_SEND_ERROR);\n    if(cc == CURLE_OK)\n      if(pipe_ssloverssl(conn, sockindex, SOS_WRITE) < 0)\n        cc = CURLE_SEND_ERROR;\n  }\n  if(cc != CURLE_OK) {\n    *curlcode = cc;\n    written = -1;\n  }\n  return (ssize_t) written; /* number of bytes */\n}\n\n\nstatic ssize_t gskit_recv(struct Curl_easy *data, int num, char *buf,\n                               size_t buffersize, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  int nread;\n  CURLcode cc = CURLE_RECV_ERROR;\n\n  if(pipe_ssloverssl(conn, num, SOS_READ) >= 0) {\n    int buffsize = buffersize > (size_t) INT_MAX? INT_MAX: (int) buffersize;\n    cc = gskit_status(data, gsk_secure_soc_read(BACKEND->handle,\n                                                buf, buffsize, &nread),\n                      \"gsk_secure_soc_read()\", CURLE_RECV_ERROR);\n  }\n  switch(cc) {\n  case CURLE_OK:\n    break;\n  case CURLE_OPERATION_TIMEDOUT:\n    cc = CURLE_AGAIN;\n  default:\n    *curlcode = cc;\n    nread = -1;\n    break;\n  }\n  return (ssize_t) nread;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(unsigned int *protoflags, struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = CURL_SSLVERSION_TLSv1_2;\n      break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n      case CURL_SSLVERSION_TLSv1_0:\n        *protoflags |= CURL_GSKPROTO_TLSV10_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_1:\n        *protoflags |= CURL_GSKPROTO_TLSV11_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_2:\n        *protoflags |= CURL_GSKPROTO_TLSV11_MASK;\n        break;\n      case CURL_SSLVERSION_TLSv1_3:\n        failf(data, \"GSKit: TLS 1.3 is not yet supported\");\n        return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode gskit_connect_step1(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  gsk_handle envir;\n  CURLcode result;\n  const char * const keyringfile = SSL_CONN_CONFIG(CAfile);\n  const char * const keyringpwd = SSL_SET_OPTION(key_passwd);\n  const char * const keyringlabel = SSL_SET_OPTION(primary.clientcert);\n  const long int ssl_version = SSL_CONN_CONFIG(version);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const hostname = SSL_HOST_NAME();\n  const char *sni;\n  unsigned int protoflags = 0;\n  Qso_OverlappedIO_t commarea;\n#ifndef CURL_DISABLE_PROXY\n  int sockpair[2];\n  static const int sobufsize = CURL_MAX_WRITE_SIZE;\n#endif\n\n  /* Create SSL environment, start (preferably asynchronous) handshake. */\n\n  BACKEND->handle = (gsk_handle) NULL;\n  BACKEND->iocport = -1;\n#ifndef CURL_DISABLE_PROXY\n  BACKEND->localfd = -1;\n  BACKEND->remotefd = -1;\n#endif\n\n  /* GSKit supports two ways of specifying an SSL context: either by\n   *  application identifier (that should have been defined at the system\n   *  level) or by keyring file, password and certificate label.\n   * Local certificate name (CURLOPT_SSLCERT) is used to hold either the\n   *  application identifier of the certificate label.\n   * Key password (CURLOPT_KEYPASSWD) holds the keyring password.\n   * It is not possible to have different keyrings for the CAs and the\n   *  local certificate. We thus use the CA file (CURLOPT_CAINFO) to identify\n   *  the keyring file.\n   * If no key password is given and the keyring is the system keyring,\n   *  application identifier mode is tried first, as recommended in IBM doc.\n   */\n\n  envir = (gsk_handle) NULL;\n\n  if(keyringlabel && *keyringlabel && !keyringpwd &&\n      !strcmp(keyringfile, CURL_CA_BUNDLE)) {\n    /* Try application identifier mode. */\n    init_environment(data, &envir, keyringlabel, (const char *) NULL,\n                     (const char *) NULL, (const char *) NULL);\n  }\n\n  if(!envir) {\n    /* Use keyring mode. */\n    result = init_environment(data, &envir, (const char *) NULL,\n                              keyringfile, keyringlabel, keyringpwd);\n    if(result)\n      return result;\n  }\n\n  /* Create secure session. */\n  result = gskit_status(data, gsk_secure_soc_open(envir, &BACKEND->handle),\n                        \"gsk_secure_soc_open()\", CURLE_SSL_CONNECT_ERROR);\n  gsk_environment_close(&envir);\n  if(result)\n    return result;\n\n#ifndef CURL_DISABLE_PROXY\n  /* Establish a pipelining socket pair for SSL over SSL. */\n  if(conn->proxy_ssl[sockindex].use) {\n    if(Curl_socketpair(0, 0, 0, sockpair))\n      return CURLE_SSL_CONNECT_ERROR;\n    BACKEND->localfd = sockpair[0];\n    BACKEND->remotefd = sockpair[1];\n    setsockopt(BACKEND->localfd, SOL_SOCKET, SO_RCVBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->remotefd, SOL_SOCKET, SO_RCVBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->localfd, SOL_SOCKET, SO_SNDBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    setsockopt(BACKEND->remotefd, SOL_SOCKET, SO_SNDBUF,\n               (void *) sobufsize, sizeof(sobufsize));\n    curlx_nonblock(BACKEND->localfd, TRUE);\n    curlx_nonblock(BACKEND->remotefd, TRUE);\n  }\n#endif\n\n  /* Determine which SSL/TLS version should be enabled. */\n  sni = hostname;\n  switch(ssl_version) {\n  case CURL_SSLVERSION_SSLv2:\n    protoflags = CURL_GSKPROTO_SSLV2_MASK;\n    sni = NULL;\n    break;\n  case CURL_SSLVERSION_SSLv3:\n    protoflags = CURL_GSKPROTO_SSLV3_MASK;\n    sni = NULL;\n    break;\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    protoflags = CURL_GSKPROTO_TLSV10_MASK |\n                 CURL_GSKPROTO_TLSV11_MASK | CURL_GSKPROTO_TLSV12_MASK;\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    result = set_ssl_version_min_max(&protoflags, data);\n    if(result != CURLE_OK)\n      return result;\n    break;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* Process SNI. Ignore if not supported (on OS400 < V7R1). */\n  if(sni) {\n    result = set_buffer(data, BACKEND->handle,\n                        GSK_SSL_EXTN_SERVERNAME_REQUEST, sni, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL)\n      result = CURLE_OK;\n  }\n\n  /* Set session parameters. */\n  if(!result) {\n    /* Compute the handshake timeout. Since GSKit granularity is 1 second,\n       we round up the required value. */\n    timediff_t timeout = Curl_timeleft(data, NULL, TRUE);\n    if(timeout < 0)\n      result = CURLE_OPERATION_TIMEDOUT;\n    else\n      result = set_numeric(data, BACKEND->handle, GSK_HANDSHAKE_TIMEOUT,\n                           (timeout + 999) / 1000);\n  }\n  if(!result)\n    result = set_numeric(data, BACKEND->handle, GSK_OS400_READ_TIMEOUT, 1);\n  if(!result)\n#ifndef CURL_DISABLE_PROXY\n    result = set_numeric(data, BACKEND->handle, GSK_FD, BACKEND->localfd >= 0?\n                         BACKEND->localfd: conn->sock[sockindex]);\n#else\n    result = set_numeric(data, BACKEND->handle, GSK_FD,\n                         conn->sock[sockindex]);\n#endif\n  if(!result)\n    result = set_ciphers(data, BACKEND->handle, &protoflags);\n  if(!protoflags) {\n    failf(data, \"No SSL protocol/cipher combination enabled\");\n    result = CURLE_SSL_CIPHER;\n  }\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_SSLV2,\n                      (protoflags & CURL_GSKPROTO_SSLV2_MASK)?\n                      GSK_PROTOCOL_SSLV2_ON: GSK_PROTOCOL_SSLV2_OFF, FALSE);\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_SSLV3,\n                      (protoflags & CURL_GSKPROTO_SSLV3_MASK)?\n                      GSK_PROTOCOL_SSLV3_ON: GSK_PROTOCOL_SSLV3_OFF, FALSE);\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV1,\n                      (protoflags & CURL_GSKPROTO_TLSV10_MASK)?\n                      GSK_PROTOCOL_TLSV1_ON: GSK_PROTOCOL_TLSV1_OFF, FALSE);\n  if(!result) {\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV11,\n                      (protoflags & CURL_GSKPROTO_TLSV11_MASK)?\n                      GSK_TRUE: GSK_FALSE, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(protoflags == CURL_GSKPROTO_TLSV11_MASK) {\n        failf(data, \"TLS 1.1 not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result) {\n    result = set_enum(data, BACKEND->handle, GSK_PROTOCOL_TLSV12,\n                      (protoflags & CURL_GSKPROTO_TLSV12_MASK)?\n                      GSK_TRUE: GSK_FALSE, TRUE);\n    if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n      result = CURLE_OK;\n      if(protoflags == CURL_GSKPROTO_TLSV12_MASK) {\n        failf(data, \"TLS 1.2 not yet supported\");\n        result = CURLE_SSL_CIPHER;\n      }\n    }\n  }\n  if(!result)\n    result = set_enum(data, BACKEND->handle, GSK_SERVER_AUTH_TYPE,\n                      verifypeer? GSK_SERVER_AUTH_FULL:\n                      GSK_SERVER_AUTH_PASSTHRU, FALSE);\n\n  if(!result) {\n    /* Start handshake. Try asynchronous first. */\n    memset(&commarea, 0, sizeof(commarea));\n    BACKEND->iocport = QsoCreateIOCompletionPort();\n    if(BACKEND->iocport != -1) {\n      result = gskit_status(data,\n                            gsk_secure_soc_startInit(BACKEND->handle,\n                                                     BACKEND->iocport,\n                                                     &commarea),\n                            \"gsk_secure_soc_startInit()\",\n                            CURLE_SSL_CONNECT_ERROR);\n      if(!result) {\n        connssl->connecting_state = ssl_connect_2;\n        return CURLE_OK;\n      }\n      else\n        close_async_handshake(connssl);\n    }\n    else if(errno != ENOBUFS)\n      result = gskit_status(data, GSK_ERROR_IO,\n                            \"QsoCreateIOCompletionPort()\", 0);\n#ifndef CURL_DISABLE_PROXY\n    else if(conn->proxy_ssl[sockindex].use) {\n      /* Cannot pipeline while handshaking synchronously. */\n      result = CURLE_SSL_CONNECT_ERROR;\n    }\n#endif\n    else {\n      /* No more completion port available. Use synchronous IO. */\n      result = gskit_status(data, gsk_secure_soc_init(BACKEND->handle),\n                            \"gsk_secure_soc_init()\", CURLE_SSL_CONNECT_ERROR);\n      if(!result) {\n        connssl->connecting_state = ssl_connect_3;\n        return CURLE_OK;\n      }\n    }\n  }\n\n  /* Error: rollback. */\n  close_one(connssl, data, conn, sockindex);\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_step2(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    bool nonblocking)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  Qso_OverlappedIO_t cstat;\n  struct timeval stmv;\n  CURLcode result;\n\n  /* Poll or wait for end of SSL asynchronous handshake. */\n\n  for(;;) {\n    timediff_t timeout_ms = nonblocking? 0: Curl_timeleft(data, NULL, TRUE);\n    if(timeout_ms < 0)\n      timeout_ms = 0;\n    stmv.tv_sec = timeout_ms / 1000;\n    stmv.tv_usec = (timeout_ms - stmv.tv_sec * 1000) * 1000;\n    switch(QsoWaitForIOCompletion(BACKEND->iocport, &cstat, &stmv)) {\n    case 1:             /* Operation complete. */\n      break;\n    case -1:            /* An error occurred: handshake still in progress. */\n      if(errno == EINTR) {\n        if(nonblocking)\n          return CURLE_OK;\n        continue;       /* Retry. */\n      }\n      if(errno != ETIME) {\n        failf(data, \"QsoWaitForIOCompletion() I/O error: %s\", strerror(errno));\n        cancel_async_handshake(conn, sockindex);\n        close_async_handshake(connssl);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* FALL INTO... */\n    case 0:             /* Handshake in progress, timeout occurred. */\n      if(nonblocking)\n        return CURLE_OK;\n      cancel_async_handshake(conn, sockindex);\n      close_async_handshake(connssl);\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    break;\n  }\n  result = gskit_status(data, cstat.returnValue, \"SSL handshake\",\n                        CURLE_SSL_CONNECT_ERROR);\n  if(!result)\n    connssl->connecting_state = ssl_connect_3;\n  close_async_handshake(connssl);\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_step3(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  const gsk_cert_data_elem *cdev;\n  int cdec;\n  const gsk_cert_data_elem *p;\n  const char *cert = (const char *) NULL;\n  const char *certend;\n  const char *ptr;\n  CURLcode result;\n\n  /* SSL handshake done: gather certificate info and verify host. */\n\n  if(gskit_status(data, gsk_attribute_get_cert_info(BACKEND->handle,\n                                                    GSK_PARTNER_CERT_INFO,\n                                                    &cdev, &cdec),\n                  \"gsk_attribute_get_cert_info()\", CURLE_SSL_CONNECT_ERROR) ==\n     CURLE_OK) {\n    int i;\n\n    infof(data, \"Server certificate:\\n\");\n    p = cdev;\n    for(i = 0; i++ < cdec; p++)\n      switch(p->cert_data_id) {\n      case CERT_BODY_DER:\n        cert = p->cert_data_p;\n        certend = cert + cdev->cert_data_l;\n        break;\n      case CERT_DN_PRINTABLE:\n        infof(data, \"\\t subject: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_ISSUER_DN_PRINTABLE:\n        infof(data, \"\\t issuer: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_VALID_FROM:\n        infof(data, \"\\t start date: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n      case CERT_VALID_TO:\n        infof(data, \"\\t expire date: %.*s\\n\", p->cert_data_l, p->cert_data_p);\n        break;\n    }\n  }\n\n  /* Verify host. */\n  result = Curl_verifyhost(data, conn, cert, certend);\n  if(result)\n    return result;\n\n  /* The only place GSKit can get the whole CA chain is a validation\n     callback where no user data pointer is available. Therefore it's not\n     possible to copy this chain into our structures for CAINFO.\n     However the server certificate may be available, thus we can return\n     info about it. */\n  if(data->set.ssl.certinfo) {\n    result = Curl_ssl_init_certinfo(data, 1);\n    if(result)\n      return result;\n\n    if(cert) {\n      result = Curl_extract_certinfo(data, 0, cert, certend);\n      if(result)\n        return result;\n    }\n  }\n\n  /* Check pinned public key. */\n  ptr = SSL_PINNED_PUB_KEY();\n  if(!result && ptr) {\n    curl_X509certificate x509;\n    curl_asn1Element *p;\n\n    if(Curl_parseX509(&x509, cert, certend))\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    p = &x509.subjectPublicKeyInfo;\n    result = Curl_pin_peer_pubkey(data, ptr, p->header, p->end - p->header);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n  return CURLE_OK;\n}\n\n\nstatic CURLcode gskit_connect_common(struct Curl_easy *data,\n                                     struct connectdata *conn, int sockindex,\n                                     bool nonblocking, bool *done)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  timediff_t timeout_ms;\n  CURLcode result = CURLE_OK;\n\n  *done = connssl->state == ssl_connection_complete;\n  if(*done)\n    return CURLE_OK;\n\n  /* Step 1: create session, start handshake. */\n  if(connssl->connecting_state == ssl_connect_1) {\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      result = CURLE_OPERATION_TIMEDOUT;\n    }\n    else\n      result = gskit_connect_step1(data, conn, sockindex);\n  }\n\n  /* Handle handshake pipelining. */\n  if(!result)\n    if(pipe_ssloverssl(conn, sockindex, SOS_READ | SOS_WRITE) < 0)\n      result = CURLE_SSL_CONNECT_ERROR;\n\n  /* Step 2: check if handshake is over. */\n  if(!result && connssl->connecting_state == ssl_connect_2) {\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      result = CURLE_OPERATION_TIMEDOUT;\n    }\n    else\n      result = gskit_connect_step2(data, conn, sockindex, nonblocking);\n  }\n\n  /* Handle handshake pipelining. */\n  if(!result)\n    if(pipe_ssloverssl(conn, sockindex, SOS_READ | SOS_WRITE) < 0)\n      result = CURLE_SSL_CONNECT_ERROR;\n\n  /* Step 3: gather certificate info, verify host. */\n  if(!result && connssl->connecting_state == ssl_connect_3)\n    result = gskit_connect_step3(data, conn, sockindex);\n\n  if(result)\n    close_one(connssl, data, conn, sockindex);\n  else if(connssl->connecting_state == ssl_connect_done) {\n    connssl->state = ssl_connection_complete;\n    connssl->connecting_state = ssl_connect_1;\n    conn->recv[sockindex] = gskit_recv;\n    conn->send[sockindex] = gskit_send;\n    *done = TRUE;\n  }\n\n  return result;\n}\n\n\nstatic CURLcode gskit_connect_nonblocking(struct Curl_easy *data,\n                                          struct connectdata *conn,\n                                          int sockindex, bool *done)\n{\n  CURLcode result;\n\n  result = gskit_connect_common(data, conn, sockindex, TRUE, done);\n  if(*done || result)\n    conn->ssl[sockindex].connecting_state = ssl_connect_1;\n  return result;\n}\n\n\nstatic CURLcode gskit_connect(struct Curl_easy *data,\n                              struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done;\n\n  conn->ssl[sockindex].connecting_state = ssl_connect_1;\n  result = gskit_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\n\nstatic void gskit_close(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  close_one(&conn->ssl[sockindex], data, conn, sockindex);\n#ifndef CURL_DISABLE_PROXY\n  close_one(&conn->proxy_ssl[sockindex], data, conn, sockindex);\n#endif\n}\n\n\nstatic int gskit_shutdown(struct Curl_easy *data,\n                          struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  int what;\n  int rc;\n  char buf[120];\n\n  if(!BACKEND->handle)\n    return 0;\n\n#ifndef CURL_DISABLE_FTP\n  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)\n    return 0;\n#endif\n\n  close_one(connssl, data, conn, sockindex);\n  rc = 0;\n  what = SOCKET_READABLE(conn->sock[sockindex],\n                         SSL_SHUTDOWN_TIMEOUT);\n\n  for(;;) {\n    ssize_t nread;\n\n    if(what < 0) {\n      /* anything that gets here is fatally bad */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      rc = -1;\n      break;\n    }\n\n    if(!what) {                                /* timeout */\n      failf(data, \"SSL shutdown timeout\");\n      break;\n    }\n\n    /* Something to read, let's do it and hope that it is the close\n       notify alert from the server. No way to gsk_secure_soc_read() now, so\n       use read(). */\n\n    nread = read(conn->sock[sockindex], buf, sizeof(buf));\n\n    if(nread < 0) {\n      failf(data, \"read: %s\", strerror(errno));\n      rc = -1;\n    }\n\n    if(nread <= 0)\n      break;\n\n    what = SOCKET_READABLE(conn->sock[sockindex], 0);\n  }\n\n  return rc;\n}\n\n\nstatic size_t gskit_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"GSKit\");\n}\n\n\nstatic int gskit_check_cxn(struct connectdata *cxn)\n{\n  struct ssl_connect_data *connssl = &cxn->ssl[FIRSTSOCKET];\n  int err;\n  int errlen;\n\n  /* The only thing that can be tested here is at the socket level. */\n\n  if(!BACKEND->handle)\n    return 0; /* connection has been closed */\n\n  err = 0;\n  errlen = sizeof(err);\n\n  if(getsockopt(cxn->sock[FIRSTSOCKET], SOL_SOCKET, SO_ERROR,\n                 (unsigned char *) &err, &errlen) ||\n     errlen != sizeof(err) || err)\n    return 0; /* connection has been closed */\n\n  return -1;  /* connection status unknown */\n}\n\nstatic void *gskit_get_internals(struct ssl_connect_data *connssl,\n                                 CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return BACKEND->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_gskit = {\n  { CURLSSLBACKEND_GSKIT, \"gskit\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  gskit_init,                     /* init */\n  gskit_cleanup,                  /* cleanup */\n  gskit_version,                  /* version */\n  gskit_check_cxn,                /* check_cxn */\n  gskit_shutdown,                 /* shutdown */\n  Curl_none_data_pending,         /* data_pending */\n  Curl_none_random,               /* random */\n  Curl_none_cert_status_request,  /* cert_status_request */\n  gskit_connect,                  /* connect */\n  gskit_connect_nonblocking,      /* connect_nonblocking */\n  gskit_get_internals,            /* get_internals */\n  gskit_close,                    /* close_one */\n  Curl_none_close_all,            /* close_all */\n  /* No session handling for GSKit */\n  Curl_none_session_free,         /* session_free */\n  Curl_none_set_engine,           /* set_engine */\n  Curl_none_set_engine_default,   /* set_engine_default */\n  Curl_none_engines_list,         /* engines_list */\n  Curl_none_false_start,          /* false_start */\n  NULL,                           /* sha256sum */\n  NULL,                           /* associate_connection */\n  NULL                            /* disassociate_connection */\n};\n\n#endif /* USE_GSKIT */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all GnuTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n * Note: don't use the GnuTLS' *_t variable type names in this source code,\n * since they were not present in 1.0.X.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_GNUTLS\n\n#include <gnutls/abstract.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <nettle/sha2.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"gtls.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"multiif.h\"\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n/* Enable GnuTLS debugging by defining GTLSDEBUG */\n/*#define GTLSDEBUG */\n\n#ifdef GTLSDEBUG\nstatic void tls_log_func(int level, const char *str)\n{\n    fprintf(stderr, \"|<%d>| %s\", level, str);\n}\n#endif\nstatic bool gtls_inited = FALSE;\n\n#if !defined(GNUTLS_VERSION_NUMBER) || (GNUTLS_VERSION_NUMBER < 0x03010a)\n#error \"too old GnuTLS version\"\n#endif\n\n# include <gnutls/ocsp.h>\n\nstruct ssl_backend_data {\n  gnutls_session_t session;\n  gnutls_certificate_credentials_t cred;\n#ifdef HAVE_GNUTLS_SRP\n  gnutls_srp_client_credentials_t srp_client_cred;\n#endif\n};\n\nstatic ssize_t gtls_push(void *s, const void *buf, size_t len)\n{\n  curl_socket_t sock = *(curl_socket_t *)s;\n  ssize_t ret = swrite(sock, buf, len);\n  return ret;\n}\n\nstatic ssize_t gtls_pull(void *s, void *buf, size_t len)\n{\n  curl_socket_t sock = *(curl_socket_t *)s;\n  ssize_t ret = sread(sock, buf, len);\n  return ret;\n}\n\nstatic ssize_t gtls_push_ssl(void *s, const void *buf, size_t len)\n{\n  return gnutls_record_send((gnutls_session_t) s, buf, len);\n}\n\nstatic ssize_t gtls_pull_ssl(void *s, void *buf, size_t len)\n{\n  return gnutls_record_recv((gnutls_session_t) s, buf, len);\n}\n\n/* gtls_init()\n *\n * Global GnuTLS init, called from Curl_ssl_init(). This calls functions that\n * are not thread-safe and thus this function itself is not thread-safe and\n * must only be called from within curl_global_init() to keep the thread\n * situation under control!\n */\nstatic int gtls_init(void)\n{\n  int ret = 1;\n  if(!gtls_inited) {\n    ret = gnutls_global_init()?0:1;\n#ifdef GTLSDEBUG\n    gnutls_global_set_log_function(tls_log_func);\n    gnutls_global_set_log_level(2);\n#endif\n    gtls_inited = TRUE;\n  }\n  return ret;\n}\n\nstatic void gtls_cleanup(void)\n{\n  if(gtls_inited) {\n    gnutls_global_deinit();\n    gtls_inited = FALSE;\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void showtime(struct Curl_easy *data,\n                     const char *text,\n                     time_t stamp)\n{\n  struct tm buffer;\n  const struct tm *tm = &buffer;\n  char str[96];\n  CURLcode result = Curl_gmtime(stamp, &buffer);\n  if(result)\n    return;\n\n  msnprintf(str,\n            sizeof(str),\n            \"\\t %s: %s, %02d %s %4d %02d:%02d:%02d GMT\",\n            text,\n            Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],\n            tm->tm_mday,\n            Curl_month[tm->tm_mon],\n            tm->tm_year + 1900,\n            tm->tm_hour,\n            tm->tm_min,\n            tm->tm_sec);\n  infof(data, \"%s\\n\", str);\n}\n#endif\n\nstatic gnutls_datum_t load_file(const char *file)\n{\n  FILE *f;\n  gnutls_datum_t loaded_file = { NULL, 0 };\n  long filelen;\n  void *ptr;\n\n  f = fopen(file, \"rb\");\n  if(!f)\n    return loaded_file;\n  if(fseek(f, 0, SEEK_END) != 0\n     || (filelen = ftell(f)) < 0\n     || fseek(f, 0, SEEK_SET) != 0\n     || !(ptr = malloc((size_t)filelen)))\n    goto out;\n  if(fread(ptr, 1, (size_t)filelen, f) < (size_t)filelen) {\n    free(ptr);\n    goto out;\n  }\n\n  loaded_file.data = ptr;\n  loaded_file.size = (unsigned int)filelen;\nout:\n  fclose(f);\n  return loaded_file;\n}\n\nstatic void unload_file(gnutls_datum_t data)\n{\n  free(data.data);\n}\n\n\n/* this function does a SSL/TLS (re-)handshake */\nstatic CURLcode handshake(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          int sockindex,\n                          bool duringconnect,\n                          bool nonblocking)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  gnutls_session_t session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n\n  for(;;) {\n    timediff_t timeout_ms;\n    int rc;\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, duringconnect);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n      int what;\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:\n                               timeout_ms?timeout_ms:1000);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking)\n          return CURLE_OK;\n        else if(timeout_ms) {\n          /* timeout */\n          failf(data, \"SSL connection timeout at %ld\", (long)timeout_ms);\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    rc = gnutls_handshake(session);\n\n    if((rc == GNUTLS_E_AGAIN) || (rc == GNUTLS_E_INTERRUPTED)) {\n      connssl->connecting_state =\n        gnutls_record_get_direction(session)?\n        ssl_connect_2_writing:ssl_connect_2_reading;\n      continue;\n    }\n    else if((rc < 0) && !gnutls_error_is_fatal(rc)) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      infof(data, \"gnutls_handshake() warning: %s\\n\", strerr);\n      continue;\n    }\n    else if(rc < 0) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      failf(data, \"gnutls_handshake() failed: %s\", strerr);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* Reset our connect state machine */\n    connssl->connecting_state = ssl_connect_1;\n    return CURLE_OK;\n  }\n}\n\nstatic gnutls_x509_crt_fmt_t do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return GNUTLS_X509_FMT_DER;\n  return GNUTLS_X509_FMT_PEM; /* default to PEM */\n}\n\n#define GNUTLS_CIPHERS \"NORMAL:-ARCFOUR-128:-CTYPE-ALL:+CTYPE-X509\"\n/* If GnuTLS was compiled without support for SRP it will error out if SRP is\n   requested in the priority string, so treat it specially\n */\n#define GNUTLS_SRP \"+SRP\"\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data,\n                        const char **prioritylist,\n                        const char *tls13support)\n{\n  struct connectdata *conn = data->conn;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  if((ssl_version == CURL_SSLVERSION_DEFAULT) ||\n     (ssl_version == CURL_SSLVERSION_TLSv1))\n    ssl_version = CURL_SSLVERSION_TLSv1_0;\n  if(ssl_version_max == CURL_SSLVERSION_MAX_NONE)\n    ssl_version_max = CURL_SSLVERSION_MAX_DEFAULT;\n  if(!tls13support) {\n    /* If the running GnuTLS doesn't support TLS 1.3, we must not specify a\n       prioritylist involving that since it will make GnuTLS return an en\n       error back at us */\n    if((ssl_version_max == CURL_SSLVERSION_MAX_TLSv1_3) ||\n       (ssl_version_max == CURL_SSLVERSION_MAX_DEFAULT)) {\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    }\n  }\n\n  switch(ssl_version | ssl_version_max) {\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_0:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1:+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1:+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0:+VERS-TLS1.1:+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1:+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3 | CURL_SSLVERSION_MAX_DEFAULT:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\"\n      \":+VERS-TLS1.3\";\n    return CURLE_OK;\n  }\n\n  failf(data, \"GnuTLS: cannot set ssl protocol\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic CURLcode\ngtls_connect_step1(struct Curl_easy *data,\n                   struct connectdata *conn,\n                   int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  unsigned int init_flags;\n  gnutls_session_t session;\n  int rc;\n  bool sni = TRUE; /* default is SNI enabled */\n  void *transport_ptr = NULL;\n  gnutls_push_func gnutls_transport_push = NULL;\n  gnutls_pull_func gnutls_transport_pull = NULL;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  const char *prioritylist;\n  const char *err = NULL;\n  const char * const hostname = SSL_HOST_NAME();\n  long * const certverifyresult = &SSL_SET_OPTION_LVALUE(certverifyresult);\n  const char *tls13support;\n\n  if(connssl->state == ssl_connection_complete)\n    /* to make us tolerant against being called more than once for the\n       same connection */\n    return CURLE_OK;\n\n  if(!gtls_inited)\n    gtls_init();\n\n  /* Initialize certverifyresult to OK */\n  *certverifyresult = 0;\n\n  if(SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"GnuTLS does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n  /* allocate a cred struct */\n  rc = gnutls_certificate_allocate_credentials(&backend->cred);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_cert_all_cred() failed: %s\", gnutls_strerror(rc));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    infof(data, \"Using TLS-SRP username: %s\\n\", SSL_SET_OPTION(username));\n\n    rc = gnutls_srp_allocate_client_credentials(\n           &backend->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_allocate_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    rc = gnutls_srp_set_client_credentials(backend->srp_client_cred,\n                                           SSL_SET_OPTION(username),\n                                           SSL_SET_OPTION(password));\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_set_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n  }\n#endif\n\n  if(SSL_CONN_CONFIG(CAfile)) {\n    /* set the trusted CA cert bundle file */\n    gnutls_certificate_set_verify_flags(backend->cred,\n                                        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n\n    rc = gnutls_certificate_set_x509_trust_file(backend->cred,\n                                                SSL_CONN_CONFIG(CAfile),\n                                                GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      infof(data, \"error reading ca cert file %s (%s)\\n\",\n            SSL_CONN_CONFIG(CAfile), gnutls_strerror(rc));\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        *certverifyresult = rc;\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n    }\n    else\n      infof(data, \"found %d certificates in %s\\n\", rc,\n            SSL_CONN_CONFIG(CAfile));\n  }\n\n  if(SSL_CONN_CONFIG(CApath)) {\n    /* set the trusted CA cert directory */\n    rc = gnutls_certificate_set_x509_trust_dir(backend->cred,\n                                               SSL_CONN_CONFIG(CApath),\n                                               GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      infof(data, \"error reading ca cert file %s (%s)\\n\",\n            SSL_CONN_CONFIG(CApath), gnutls_strerror(rc));\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        *certverifyresult = rc;\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n    }\n    else\n      infof(data, \"found %d certificates in %s\\n\",\n            rc, SSL_CONN_CONFIG(CApath));\n  }\n\n#ifdef CURL_CA_FALLBACK\n  /* use system ca certificate store as fallback */\n  if(SSL_CONN_CONFIG(verifypeer) &&\n     !(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(CApath))) {\n    gnutls_certificate_set_x509_system_trust(backend->cred);\n  }\n#endif\n\n  if(SSL_SET_OPTION(CRLfile)) {\n    /* set the CRL list file */\n    rc = gnutls_certificate_set_x509_crl_file(backend->cred,\n                                              SSL_SET_OPTION(CRLfile),\n                                              GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      failf(data, \"error reading crl file %s (%s)\",\n            SSL_SET_OPTION(CRLfile), gnutls_strerror(rc));\n      return CURLE_SSL_CRL_BADFILE;\n    }\n    else\n      infof(data, \"found %d CRL in %s\\n\",\n            rc, SSL_SET_OPTION(CRLfile));\n  }\n\n  /* Initialize TLS session as a client */\n  init_flags = GNUTLS_CLIENT;\n\n#if defined(GNUTLS_FORCE_CLIENT_CERT)\n  init_flags |= GNUTLS_FORCE_CLIENT_CERT;\n#endif\n\n#if defined(GNUTLS_NO_TICKETS)\n  /* Disable TLS session tickets */\n  init_flags |= GNUTLS_NO_TICKETS;\n#endif\n\n  rc = gnutls_init(&backend->session, init_flags);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_init() failed: %d\", rc);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* convenient assign */\n  session = backend->session;\n\n  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&\n#ifdef ENABLE_IPV6\n     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&\n#endif\n     sni &&\n     (gnutls_server_name_set(session, GNUTLS_NAME_DNS, hostname,\n                             strlen(hostname)) < 0))\n    infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n          \"TLS extension\\n\");\n\n  /* Use default priorities */\n  rc = gnutls_set_default_priority(session);\n  if(rc != GNUTLS_E_SUCCESS)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* \"In GnuTLS 3.6.5, TLS 1.3 is enabled by default\" */\n  tls13support = gnutls_check_version(\"3.6.5\");\n\n  /* Ensure +SRP comes at the *end* of all relevant strings so that it can be\n   * removed if a run-time error indicates that SRP is not supported by this\n   * GnuTLS version */\n  switch(SSL_CONN_CONFIG(version)) {\n    case CURL_SSLVERSION_TLSv1_3:\n      if(!tls13support) {\n        failf(data, \"This GnuTLS installation does not support TLS 1.3\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2: {\n      CURLcode result = set_ssl_version_min_max(data, &prioritylist,\n                                                tls13support);\n      if(result)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv2:\n    case CURL_SSLVERSION_SSLv3:\n    default:\n      failf(data, \"GnuTLS does not support SSLv2 or SSLv3\");\n      return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  /* Only add SRP to the cipher list if SRP is requested. Otherwise\n   * GnuTLS will disable TLS 1.3 support. */\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    size_t len = strlen(prioritylist);\n\n    char *prioritysrp = malloc(len + sizeof(GNUTLS_SRP) + 1);\n    if(!prioritysrp)\n      return CURLE_OUT_OF_MEMORY;\n    strcpy(prioritysrp, prioritylist);\n    strcpy(prioritysrp + len, \":\" GNUTLS_SRP);\n    rc = gnutls_priority_set_direct(session, prioritysrp, &err);\n    free(prioritysrp);\n\n    if((rc == GNUTLS_E_INVALID_REQUEST) && err) {\n      infof(data, \"This GnuTLS does not support SRP\\n\");\n    }\n  }\n  else {\n#endif\n    rc = gnutls_priority_set_direct(session, prioritylist, &err);\n#ifdef HAVE_GNUTLS_SRP\n  }\n#endif\n\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"Error %d setting GnuTLS cipher list starting with %s\",\n          rc, err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    gnutls_datum_t protocols[2];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n       ) {\n      protocols[cur].data = (unsigned char *)ALPN_H2;\n      protocols[cur].size = ALPN_H2_LENGTH;\n      cur++;\n      infof(data, \"ALPN, offering %.*s\\n\", ALPN_H2_LENGTH, ALPN_H2);\n    }\n#endif\n\n    protocols[cur].data = (unsigned char *)ALPN_HTTP_1_1;\n    protocols[cur].size = ALPN_HTTP_1_1_LENGTH;\n    cur++;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    gnutls_alpn_set_protocols(session, protocols, cur, 0);\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert)) {\n    if(SSL_SET_OPTION(key_passwd)) {\n      const unsigned int supported_key_encryption_algorithms =\n        GNUTLS_PKCS_USE_PKCS12_3DES | GNUTLS_PKCS_USE_PKCS12_ARCFOUR |\n        GNUTLS_PKCS_USE_PKCS12_RC2_40 | GNUTLS_PKCS_USE_PBES2_3DES |\n        GNUTLS_PKCS_USE_PBES2_AES_128 | GNUTLS_PKCS_USE_PBES2_AES_192 |\n        GNUTLS_PKCS_USE_PBES2_AES_256;\n      rc = gnutls_certificate_set_x509_key_file2(\n           backend->cred,\n           SSL_SET_OPTION(primary.clientcert),\n           SSL_SET_OPTION(key) ?\n           SSL_SET_OPTION(key) : SSL_SET_OPTION(primary.clientcert),\n           do_file_type(SSL_SET_OPTION(cert_type)),\n           SSL_SET_OPTION(key_passwd),\n           supported_key_encryption_algorithms);\n      if(rc != GNUTLS_E_SUCCESS) {\n        failf(data,\n              \"error reading X.509 potentially-encrypted key file: %s\",\n              gnutls_strerror(rc));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    else {\n      if(gnutls_certificate_set_x509_key_file(\n           backend->cred,\n           SSL_SET_OPTION(primary.clientcert),\n           SSL_SET_OPTION(key) ?\n           SSL_SET_OPTION(key) : SSL_SET_OPTION(primary.clientcert),\n           do_file_type(SSL_SET_OPTION(cert_type)) ) !=\n         GNUTLS_E_SUCCESS) {\n        failf(data, \"error reading X.509 key or certificate file\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n#ifdef HAVE_GNUTLS_SRP\n  /* put the credentials to the current session */\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n    rc = gnutls_credentials_set(session, GNUTLS_CRD_SRP,\n                                backend->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else\n#endif\n  {\n    rc = gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,\n                                backend->cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    transport_ptr = conn->proxy_ssl[sockindex].backend->session;\n    gnutls_transport_push = gtls_push_ssl;\n    gnutls_transport_pull = gtls_pull_ssl;\n  }\n  else\n#endif\n  {\n    /* file descriptor for the socket */\n    transport_ptr = &conn->sock[sockindex];\n    gnutls_transport_push = gtls_push;\n    gnutls_transport_pull = gtls_pull;\n  }\n\n  /* set the connection handle */\n  gnutls_transport_set_ptr(session, transport_ptr);\n\n  /* register callback functions to send and receive data. */\n  gnutls_transport_set_push_function(session, gnutls_transport_push);\n  gnutls_transport_set_pull_function(session, gnutls_transport_pull);\n\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    rc = gnutls_ocsp_status_request_enable_client(session, NULL, 0, NULL);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_ocsp_status_request_enable_client() failed: %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* This might be a reconnect, so we check for a session ID in the cache\n     to speed up things */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid;\n    size_t ssl_idsize;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, &ssl_idsize, sockindex)) {\n      /* we got a session id, use it! */\n      gnutls_session_set_data(session, ssl_sessionid, ssl_idsize);\n\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    gnutls_x509_crt_t cert,\n                                    const char *pinnedpubkey)\n{\n  /* Scratch */\n  size_t len1 = 0, len2 = 0;\n  unsigned char *buff1 = NULL;\n\n  gnutls_pubkey_t key = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(NULL == pinnedpubkey)\n    return CURLE_OK;\n\n  if(NULL == cert)\n    return result;\n\n  do {\n    int ret;\n\n    /* Begin Gyrations to get the public key     */\n    gnutls_pubkey_init(&key);\n\n    ret = gnutls_pubkey_import_x509(key, cert, 0);\n    if(ret < 0)\n      break; /* failed */\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, NULL, &len1);\n    if(ret != GNUTLS_E_SHORT_MEMORY_BUFFER || len1 == 0)\n      break; /* failed */\n\n    buff1 = malloc(len1);\n    if(NULL == buff1)\n      break; /* failed */\n\n    len2 = len1;\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, buff1, &len2);\n    if(ret < 0 || len1 != len2)\n      break; /* failed */\n\n    /* End Gyrations */\n\n    /* The one good exit point */\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, buff1, len1);\n  } while(0);\n\n  if(NULL != key)\n    gnutls_pubkey_deinit(key);\n\n  Curl_safefree(buff1);\n\n  return result;\n}\n\nstatic Curl_recv gtls_recv;\nstatic Curl_send gtls_send;\n\nstatic CURLcode\ngtls_connect_step3(struct Curl_easy *data,\n                   struct connectdata *conn,\n                   int sockindex)\n{\n  unsigned int cert_list_size;\n  const gnutls_datum_t *chainp;\n  unsigned int verify_status = 0;\n  gnutls_x509_crt_t x509_cert, x509_issuer;\n  gnutls_datum_t issuerp;\n  gnutls_datum_t certfields;\n  char certname[65] = \"\"; /* limited to 64 chars by ASN.1 */\n  size_t size;\n  time_t certclock;\n  const char *ptr;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  gnutls_session_t session = backend->session;\n  int rc;\n  gnutls_datum_t proto;\n  CURLcode result = CURLE_OK;\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  unsigned int algo;\n  unsigned int bits;\n  gnutls_protocol_t version = gnutls_protocol_get_version(session);\n#endif\n  const char * const hostname = SSL_HOST_NAME();\n  long * const certverifyresult = &SSL_SET_OPTION_LVALUE(certverifyresult);\n\n  /* the name of the cipher suite used, e.g. ECDHE_RSA_AES_256_GCM_SHA384. */\n  ptr = gnutls_cipher_suite_get_name(gnutls_kx_get(session),\n                                     gnutls_cipher_get(session),\n                                     gnutls_mac_get(session));\n\n  infof(data, \"SSL connection using %s / %s\\n\",\n        gnutls_protocol_get_name(version), ptr);\n\n  /* This function will return the peer's raw certificate (chain) as sent by\n     the peer. These certificates are in raw format (DER encoded for\n     X.509). In case of a X.509 then a certificate list may be present. The\n     first certificate in the list is the peer's certificate, following the\n     issuer's certificate, then the issuer's issuer etc. */\n\n  chainp = gnutls_certificate_get_peers(session, &cert_list_size);\n  if(!chainp) {\n    if(SSL_CONN_CONFIG(verifypeer) ||\n       SSL_CONN_CONFIG(verifyhost) ||\n       SSL_SET_OPTION(issuercert)) {\n#ifdef HAVE_GNUTLS_SRP\n      if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n         && SSL_SET_OPTION(username) != NULL\n         && !SSL_CONN_CONFIG(verifypeer)\n         && gnutls_cipher_get(session)) {\n        /* no peer cert, but auth is ok if we have SRP user and cipher and no\n           peer verify */\n      }\n      else {\n#endif\n        failf(data, \"failed to get server cert\");\n        *certverifyresult = GNUTLS_E_NO_CERTIFICATE_FOUND;\n        return CURLE_PEER_FAILED_VERIFICATION;\n#ifdef HAVE_GNUTLS_SRP\n      }\n#endif\n    }\n    infof(data, \"\\t common name: WARNING couldn't obtain\\n\");\n  }\n\n  if(data->set.ssl.certinfo && chainp) {\n    unsigned int i;\n\n    result = Curl_ssl_init_certinfo(data, cert_list_size);\n    if(result)\n      return result;\n\n    for(i = 0; i < cert_list_size; i++) {\n      const char *beg = (const char *) chainp[i].data;\n      const char *end = beg + chainp[i].size;\n\n      result = Curl_extract_certinfo(data, i, beg, end);\n      if(result)\n        return result;\n    }\n  }\n\n  if(SSL_CONN_CONFIG(verifypeer)) {\n    /* This function will try to verify the peer's certificate and return its\n       status (trusted, invalid etc.). The value of status should be one or\n       more of the gnutls_certificate_status_t enumerated elements bitwise\n       or'd. To avoid denial of service attacks some default upper limits\n       regarding the certificate key size and chain size are set. To override\n       them use gnutls_certificate_set_verify_limits(). */\n\n    rc = gnutls_certificate_verify_peers2(session, &verify_status);\n    if(rc < 0) {\n      failf(data, \"server cert verify failed: %d\", rc);\n      *certverifyresult = rc;\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    *certverifyresult = verify_status;\n\n    /* verify_status is a bitmask of gnutls_certificate_status bits */\n    if(verify_status & GNUTLS_CERT_INVALID) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate verification failed. CAfile: %s \"\n              \"CRLfile: %s\", SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile):\n              \"none\",\n              SSL_SET_OPTION(CRLfile)?SSL_SET_OPTION(CRLfile):\"none\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate verification FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate verification OK\\n\");\n  }\n  else\n    infof(data, \"\\t server certificate verification SKIPPED\\n\");\n\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    if(gnutls_ocsp_status_request_is_checked(session, 0) == 0) {\n      gnutls_datum_t status_request;\n      gnutls_ocsp_resp_t ocsp_resp;\n\n      gnutls_ocsp_cert_status_t status;\n      gnutls_x509_crl_reason_t reason;\n\n      rc = gnutls_ocsp_status_request_get(session, &status_request);\n\n      infof(data, \"\\t server certificate status verification FAILED\\n\");\n\n      if(rc == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n        failf(data, \"No OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      gnutls_ocsp_resp_init(&ocsp_resp);\n\n      rc = gnutls_ocsp_resp_import(ocsp_resp, &status_request);\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      (void)gnutls_ocsp_resp_get_single(ocsp_resp, 0, NULL, NULL, NULL, NULL,\n                                        &status, NULL, NULL, NULL, &reason);\n\n      switch(status) {\n      case GNUTLS_OCSP_CERT_GOOD:\n        break;\n\n      case GNUTLS_OCSP_CERT_REVOKED: {\n        const char *crl_reason;\n\n        switch(reason) {\n          default:\n          case GNUTLS_X509_CRLREASON_UNSPECIFIED:\n            crl_reason = \"unspecified reason\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_KEYCOMPROMISE:\n            crl_reason = \"private key compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CACOMPROMISE:\n            crl_reason = \"CA compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AFFILIATIONCHANGED:\n            crl_reason = \"affiliation has changed\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_SUPERSEDED:\n            crl_reason = \"certificate superseded\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CESSATIONOFOPERATION:\n            crl_reason = \"operation has ceased\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CERTIFICATEHOLD:\n            crl_reason = \"certificate is on hold\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_REMOVEFROMCRL:\n            crl_reason = \"will be removed from delta CRL\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_PRIVILEGEWITHDRAWN:\n            crl_reason = \"privilege withdrawn\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AACOMPROMISE:\n            crl_reason = \"AA compromised\";\n            break;\n        }\n\n        failf(data, \"Server certificate was revoked: %s\", crl_reason);\n        break;\n      }\n\n      default:\n      case GNUTLS_OCSP_CERT_UNKNOWN:\n        failf(data, \"Server certificate status is unknown\");\n        break;\n      }\n\n      gnutls_ocsp_resp_deinit(ocsp_resp);\n\n      return CURLE_SSL_INVALIDCERTSTATUS;\n    }\n    else\n      infof(data, \"\\t server certificate status verification OK\\n\");\n  }\n  else\n    infof(data, \"\\t server certificate status verification SKIPPED\\n\");\n\n  /* initialize an X.509 certificate structure. */\n  gnutls_x509_crt_init(&x509_cert);\n\n  if(chainp)\n    /* convert the given DER or PEM encoded Certificate to the native\n       gnutls_x509_crt_t format */\n    gnutls_x509_crt_import(x509_cert, chainp, GNUTLS_X509_FMT_DER);\n\n  if(SSL_SET_OPTION(issuercert)) {\n    gnutls_x509_crt_init(&x509_issuer);\n    issuerp = load_file(SSL_SET_OPTION(issuercert));\n    gnutls_x509_crt_import(x509_issuer, &issuerp, GNUTLS_X509_FMT_PEM);\n    rc = gnutls_x509_crt_check_issuer(x509_cert, x509_issuer);\n    gnutls_x509_crt_deinit(x509_issuer);\n    unload_file(issuerp);\n    if(rc <= 0) {\n      failf(data, \"server certificate issuer check failed (IssuerCert: %s)\",\n            SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"none\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_ISSUER_ERROR;\n    }\n    infof(data, \"\\t server certificate issuer check OK (Issuer Cert: %s)\\n\",\n          SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"none\");\n  }\n\n  size = sizeof(certname);\n  rc = gnutls_x509_crt_get_dn_by_oid(x509_cert, GNUTLS_OID_X520_COMMON_NAME,\n                                     0, /* the first and only one */\n                                     FALSE,\n                                     certname,\n                                     &size);\n  if(rc) {\n    infof(data, \"error fetching CN from cert:%s\\n\",\n          gnutls_strerror(rc));\n  }\n\n  /* This function will check if the given certificate's subject matches the\n     given hostname. This is a basic implementation of the matching described\n     in RFC2818 (HTTPS), which takes into account wildcards, and the subject\n     alternative name PKIX extension. Returns non zero on success, and zero on\n     failure. */\n  rc = gnutls_x509_crt_check_hostname(x509_cert, hostname);\n#if GNUTLS_VERSION_NUMBER < 0x030306\n  /* Before 3.3.6, gnutls_x509_crt_check_hostname() didn't check IP\n     addresses. */\n  if(!rc) {\n#ifdef ENABLE_IPV6\n    #define use_addr in6_addr\n#else\n    #define use_addr in_addr\n#endif\n    unsigned char addrbuf[sizeof(struct use_addr)];\n    size_t addrlen = 0;\n\n    if(Curl_inet_pton(AF_INET, hostname, addrbuf) > 0)\n      addrlen = 4;\n#ifdef ENABLE_IPV6\n    else if(Curl_inet_pton(AF_INET6, hostname, addrbuf) > 0)\n      addrlen = 16;\n#endif\n\n    if(addrlen) {\n      unsigned char certaddr[sizeof(struct use_addr)];\n      int i;\n\n      for(i = 0; ; i++) {\n        size_t certaddrlen = sizeof(certaddr);\n        int ret = gnutls_x509_crt_get_subject_alt_name(x509_cert, i, certaddr,\n                                                       &certaddrlen, NULL);\n        /* If this happens, it wasn't an IP address. */\n        if(ret == GNUTLS_E_SHORT_MEMORY_BUFFER)\n          continue;\n        if(ret < 0)\n          break;\n        if(ret != GNUTLS_SAN_IPADDRESS)\n          continue;\n        if(certaddrlen == addrlen && !memcmp(addrbuf, certaddr, addrlen)) {\n          rc = 1;\n          break;\n        }\n      }\n    }\n  }\n#endif\n  if(!rc) {\n    if(SSL_CONN_CONFIG(verifyhost)) {\n      failf(data, \"SSL: certificate subject name (%s) does not match \"\n            \"target host name '%s'\", certname, SSL_HOST_DISPNAME());\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else\n      infof(data, \"\\t common name: %s (does not match '%s')\\n\",\n            certname, SSL_HOST_DISPNAME());\n  }\n  else\n    infof(data, \"\\t common name: %s (matched)\\n\", certname);\n\n  /* Check for time-based validity */\n  certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(SSL_CONN_CONFIG(verifypeer)) {\n      failf(data, \"server cert expiration date verify failed\");\n      *certverifyresult = GNUTLS_CERT_EXPIRED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"\\t server certificate expiration date verify FAILED\\n\");\n  }\n  else {\n    if(certclock < time(NULL)) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate expiration date has passed.\");\n        *certverifyresult = GNUTLS_CERT_EXPIRED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate expiration date FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate expiration date OK\\n\");\n  }\n\n  certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(SSL_CONN_CONFIG(verifypeer)) {\n      failf(data, \"server cert activation date verify failed\");\n      *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"\\t server certificate activation date verify FAILED\\n\");\n  }\n  else {\n    if(certclock > time(NULL)) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"server certificate not activated yet.\");\n        *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"\\t server certificate activation date FAILED\\n\");\n    }\n    else\n      infof(data, \"\\t server certificate activation date OK\\n\");\n  }\n\n  ptr = SSL_PINNED_PUB_KEY();\n  if(ptr) {\n    result = pkp_pin_peer_pubkey(data, x509_cert, ptr);\n    if(result != CURLE_OK) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return result;\n    }\n  }\n\n  /* Show:\n\n  - subject\n  - start date\n  - expire date\n  - common name\n  - issuer\n\n  */\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  /* public key algorithm's parameters */\n  algo = gnutls_x509_crt_get_pk_algorithm(x509_cert, &bits);\n  infof(data, \"\\t certificate public key: %s\\n\",\n        gnutls_pk_algorithm_get_name(algo));\n\n  /* version of the X.509 certificate. */\n  infof(data, \"\\t certificate version: #%d\\n\",\n        gnutls_x509_crt_get_version(x509_cert));\n\n\n  rc = gnutls_x509_crt_get_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate name\\n\");\n  else {\n    infof(data, \"\\t subject: %s\\n\", certfields.data);\n\n    certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n    showtime(data, \"start date\", certclock);\n\n    certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n    showtime(data, \"expire date\", certclock);\n\n    gnutls_free(certfields.data);\n  }\n\n  rc = gnutls_x509_crt_get_issuer_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate issuer\\n\");\n  else {\n    infof(data, \"\\t issuer: %s\\n\", certfields.data);\n\n    gnutls_free(certfields.data);\n  }\n#endif\n\n  gnutls_x509_crt_deinit(x509_cert);\n\n  if(conn->bits.tls_enable_alpn) {\n    rc = gnutls_alpn_get_selected_protocol(session, &proto);\n    if(rc == 0) {\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", proto.size,\n          proto.data);\n\n#ifdef USE_HTTP2\n      if(proto.size == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, proto.data,\n                 ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n      if(proto.size == ALPN_HTTP_1_1_LENGTH &&\n         !memcmp(ALPN_HTTP_1_1, proto.data, ALPN_HTTP_1_1_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_1_1;\n      }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n\n  conn->ssl[sockindex].state = ssl_connection_complete;\n  conn->recv[sockindex] = gtls_recv;\n  conn->send[sockindex] = gtls_send;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    /* we always unconditionally get the session id here, as even if we\n       already got it from the cache and asked to use it in the connection, it\n       might've been rejected and then a new one is in use now and we need to\n       detect that. */\n    void *connect_sessionid;\n    size_t connect_idsize = 0;\n\n    /* get the session ID data size */\n    gnutls_session_get_data(session, NULL, &connect_idsize);\n    connect_sessionid = malloc(connect_idsize); /* get a buffer for it */\n\n    if(connect_sessionid) {\n      bool incache;\n      void *ssl_sessionid;\n\n      /* extract session ID to the allocated buffer */\n      gnutls_session_get_data(session, connect_sessionid, &connect_idsize);\n\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(data, conn,\n                                        SSL_IS_PROXY() ? TRUE : FALSE,\n                                        &ssl_sessionid, NULL, sockindex));\n      if(incache) {\n        /* there was one before in the cache, so instead of risking that the\n           previous one was rejected, we just kill that and store the new */\n        Curl_ssl_delsessionid(data, ssl_sessionid);\n      }\n\n      /* store this session id */\n      result = Curl_ssl_addsessionid(data, conn,\n                                     SSL_IS_PROXY() ? TRUE : FALSE,\n                                     connect_sessionid, connect_idsize,\n                                     sockindex);\n      Curl_ssl_sessionid_unlock(data);\n      if(result) {\n        free(connect_sessionid);\n        result = CURLE_OUT_OF_MEMORY;\n      }\n    }\n    else\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  return result;\n}\n\n\n/*\n * This function is called after the TCP connect has completed. Setup the TLS\n * layer and do all necessary magic.\n */\n/* We use connssl->connecting_state to keep track of the connection status;\n   there are three states: 'ssl_connect_1' (not started yet or complete),\n   'ssl_connect_2_reading' (waiting for data from server), and\n   'ssl_connect_2_writing' (waiting to be able to write).\n */\nstatic CURLcode\ngtls_connect_common(struct Curl_easy *data,\n                    struct connectdata *conn,\n                    int sockindex,\n                    bool nonblocking,\n                    bool *done)\n{\n  int rc;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  /* Initiate the connection, if not already done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    rc = gtls_connect_step1(data, conn, sockindex);\n    if(rc)\n      return rc;\n  }\n\n  rc = handshake(data, conn, sockindex, TRUE, nonblocking);\n  if(rc)\n    /* handshake() sets its own error message with failf() */\n    return rc;\n\n  /* Finish connecting once the handshake is done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    rc = gtls_connect_step3(data, conn, sockindex);\n    if(rc)\n      return rc;\n  }\n\n  *done = ssl_connect_1 == connssl->connecting_state;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode gtls_connect_nonblocking(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex, bool *done)\n{\n  return gtls_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode gtls_connect(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = gtls_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool gtls_data_pending(const struct connectdata *conn,\n                              int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  bool res = FALSE;\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->session &&\n     0 != gnutls_record_check_pending(backend->session))\n    res = TRUE;\n\n#ifndef CURL_DISABLE_PROXY\n  connssl = &conn->proxy_ssl[connindex];\n  backend = connssl->backend;\n  if(backend->session &&\n     0 != gnutls_record_check_pending(backend->session))\n    res = TRUE;\n#endif\n\n  return res;\n}\n\nstatic ssize_t gtls_send(struct Curl_easy *data,\n                         int sockindex,\n                         const void *mem,\n                         size_t len,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t rc = gnutls_record_send(backend->session, mem, len);\n\n  if(rc < 0) {\n    *curlcode = (rc == GNUTLS_E_AGAIN)\n      ? CURLE_AGAIN\n      : CURLE_SEND_ERROR;\n\n    rc = -1;\n  }\n\n  return rc;\n}\n\nstatic void close_one(struct ssl_connect_data *connssl)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->session) {\n    gnutls_bye(backend->session, GNUTLS_SHUT_WR);\n    gnutls_deinit(backend->session);\n    backend->session = NULL;\n  }\n  if(backend->cred) {\n    gnutls_certificate_free_credentials(backend->cred);\n    backend->cred = NULL;\n  }\n#ifdef HAVE_GNUTLS_SRP\n  if(backend->srp_client_cred) {\n    gnutls_srp_free_client_credentials(backend->srp_client_cred);\n    backend->srp_client_cred = NULL;\n  }\n#endif\n}\n\nstatic void gtls_close(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  (void) data;\n  close_one(&conn->ssl[sockindex]);\n#ifndef CURL_DISABLE_PROXY\n  close_one(&conn->proxy_ssl[sockindex]);\n#endif\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int gtls_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int retval = 0;\n\n#ifndef CURL_DISABLE_FTP\n  /* This has only been tested on the proftpd server, and the mod_tls code\n     sends a close notify alert without waiting for a close notify alert in\n     response. Thus we wait for a close notify alert from the server, but\n     we do not send one. Let's hope other servers do the same... */\n\n  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)\n    gnutls_bye(backend->session, GNUTLS_SHUT_WR);\n#endif\n\n  if(backend->session) {\n    ssize_t result;\n    bool done = FALSE;\n    char buf[120];\n\n    while(!done) {\n      int what = SOCKET_READABLE(conn->sock[sockindex],\n                                 SSL_SHUTDOWN_TIMEOUT);\n      if(what > 0) {\n        /* Something to read, let's do it and hope that it is the close\n           notify alert from the server */\n        result = gnutls_record_recv(backend->session,\n                                    buf, sizeof(buf));\n        switch(result) {\n        case 0:\n          /* This is the expected response. There was no data but only\n             the close notify alert */\n          done = TRUE;\n          break;\n        case GNUTLS_E_AGAIN:\n        case GNUTLS_E_INTERRUPTED:\n          infof(data, \"GNUTLS_E_AGAIN || GNUTLS_E_INTERRUPTED\\n\");\n          break;\n        default:\n          retval = -1;\n          done = TRUE;\n          break;\n        }\n      }\n      else if(0 == what) {\n        /* timeout */\n        failf(data, \"SSL shutdown timeout\");\n        done = TRUE;\n      }\n      else {\n        /* anything that gets here is fatally bad */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        retval = -1;\n        done = TRUE;\n      }\n    }\n    gnutls_deinit(backend->session);\n  }\n  gnutls_certificate_free_credentials(backend->cred);\n\n#ifdef HAVE_GNUTLS_SRP\n  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n     && SSL_SET_OPTION(username) != NULL)\n    gnutls_srp_free_client_credentials(backend->srp_client_cred);\n#endif\n\n  backend->cred = NULL;\n  backend->session = NULL;\n\n  return retval;\n}\n\nstatic ssize_t gtls_recv(struct Curl_easy *data, /* connection data */\n                         int num,                  /* socketindex */\n                         char *buf,                /* store read data here */\n                         size_t buffersize,        /* max amount to read */\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t ret;\n\n  ret = gnutls_record_recv(backend->session, buf, buffersize);\n  if((ret == GNUTLS_E_AGAIN) || (ret == GNUTLS_E_INTERRUPTED)) {\n    *curlcode = CURLE_AGAIN;\n    return -1;\n  }\n\n  if(ret == GNUTLS_E_REHANDSHAKE) {\n    /* BLOCKING call, this is bad but a work-around for now. Fixing this \"the\n       proper way\" takes a whole lot of work. */\n    CURLcode result = handshake(data, conn, num, FALSE, FALSE);\n    if(result)\n      /* handshake() writes error message on its own */\n      *curlcode = result;\n    else\n      *curlcode = CURLE_AGAIN; /* then return as if this was a wouldblock */\n    return -1;\n  }\n\n  if(ret < 0) {\n    failf(data, \"GnuTLS recv error (%d): %s\",\n\n          (int)ret, gnutls_strerror((int)ret));\n    *curlcode = CURLE_RECV_ERROR;\n    return -1;\n  }\n\n  return ret;\n}\n\nstatic void gtls_session_free(void *ptr)\n{\n  free(ptr);\n}\n\nstatic size_t gtls_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"GnuTLS/%s\", gnutls_check_version(NULL));\n}\n\n/* data might be NULL! */\nstatic CURLcode gtls_random(struct Curl_easy *data,\n                            unsigned char *entropy, size_t length)\n{\n  int rc;\n  (void)data;\n  rc = gnutls_rnd(GNUTLS_RND_RANDOM, entropy, length);\n  return rc?CURLE_FAILED_INIT:CURLE_OK;\n}\n\nstatic CURLcode gtls_sha256sum(const unsigned char *tmp, /* input */\n                               size_t tmplen,\n                               unsigned char *sha256sum, /* output */\n                               size_t sha256len)\n{\n  struct sha256_ctx SHA256pw;\n  sha256_init(&SHA256pw);\n  sha256_update(&SHA256pw, (unsigned int)tmplen, tmp);\n  sha256_digest(&SHA256pw, (unsigned int)sha256len, sha256sum);\n  return CURLE_OK;\n}\n\nstatic bool gtls_cert_status_request(void)\n{\n  return TRUE;\n}\n\nstatic void *gtls_get_internals(struct ssl_connect_data *connssl,\n                                     CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->session;\n}\n\nconst struct Curl_ssl Curl_ssl_gnutls = {\n  { CURLSSLBACKEND_GNUTLS, \"gnutls\" }, /* info */\n\n  SSLSUPP_CA_PATH  |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  gtls_init,                     /* init */\n  gtls_cleanup,                  /* cleanup */\n  gtls_version,                  /* version */\n  Curl_none_check_cxn,           /* check_cxn */\n  gtls_shutdown,                 /* shutdown */\n  gtls_data_pending,             /* data_pending */\n  gtls_random,                   /* random */\n  gtls_cert_status_request,      /* cert_status_request */\n  gtls_connect,                  /* connect */\n  gtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,              /* getsock */\n  gtls_get_internals,            /* get_internals */\n  gtls_close,                    /* close_one */\n  Curl_none_close_all,           /* close_all */\n  gtls_session_free,             /* session_free */\n  Curl_none_set_engine,          /* set_engine */\n  Curl_none_set_engine_default,  /* set_engine_default */\n  Curl_none_engines_list,        /* engines_list */\n  Curl_none_false_start,         /* false_start */\n  gtls_sha256sum,                /* sha256sum */\n  NULL,                          /* associate_connection */\n  NULL                           /* disassociate_connection */\n};\n\n#endif /* USE_GNUTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2010 - 2011, Hoi-Ho Chan, <hoiho.chan@gmail.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all mbedTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_MBEDTLS\n\n/* Define this to enable lots of debugging for mbedTLS */\n/* #define MBEDTLS_DEBUG */\n\n#include <mbedtls/version.h>\n#if MBEDTLS_VERSION_NUMBER >= 0x02040000\n#include <mbedtls/net_sockets.h>\n#else\n#include <mbedtls/net.h>\n#endif\n#include <mbedtls/ssl.h>\n#include <mbedtls/certs.h>\n#include <mbedtls/x509.h>\n\n#include <mbedtls/error.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/sha256.h>\n\n#if MBEDTLS_VERSION_MAJOR >= 2\n#  ifdef MBEDTLS_DEBUG\n#    include <mbedtls/debug.h>\n#  endif\n#endif\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"mbedtls.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"mbedtls_threadlock.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\nstruct ssl_backend_data {\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_context entropy;\n  mbedtls_ssl_context ssl;\n  int server_fd;\n  mbedtls_x509_crt cacert;\n  mbedtls_x509_crt clicert;\n  mbedtls_x509_crl crl;\n  mbedtls_pk_context pk;\n  mbedtls_ssl_config config;\n  const char *protocols[3];\n};\n\n/* apply threading? */\n#if defined(USE_THREADS_POSIX) || defined(USE_THREADS_WIN32)\n#define THREADING_SUPPORT\n#endif\n\n#if defined(THREADING_SUPPORT)\nstatic mbedtls_entropy_context ts_entropy;\n\nstatic int entropy_init_initialized = 0;\n\n/* start of entropy_init_mutex() */\nstatic void entropy_init_mutex(mbedtls_entropy_context *ctx)\n{\n  /* lock 0 = entropy_init_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(0);\n  if(entropy_init_initialized == 0) {\n    mbedtls_entropy_init(ctx);\n    entropy_init_initialized = 1;\n  }\n  Curl_mbedtlsthreadlock_unlock_function(0);\n}\n/* end of entropy_init_mutex() */\n\n/* start of entropy_func_mutex() */\nstatic int entropy_func_mutex(void *data, unsigned char *output, size_t len)\n{\n  int ret;\n  /* lock 1 = entropy_func_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(1);\n  ret = mbedtls_entropy_func(data, output, len);\n  Curl_mbedtlsthreadlock_unlock_function(1);\n\n  return ret;\n}\n/* end of entropy_func_mutex() */\n\n#endif /* THREADING_SUPPORT */\n\n#ifdef MBEDTLS_DEBUG\nstatic void mbed_debug(void *context, int level, const char *f_name,\n                       int line_nb, const char *line)\n{\n  struct Curl_easy *data = NULL;\n\n  if(!context)\n    return;\n\n  data = (struct Curl_easy *)context;\n\n  infof(data, \"%s\", line);\n  (void) level;\n}\n#else\n#endif\n\n/* ALPN for http2? */\n#ifdef USE_NGHTTP2\n#  undef HAS_ALPN\n#  ifdef MBEDTLS_SSL_ALPN\n#    define HAS_ALPN\n#  endif\n#endif\n\n\n/*\n *  profile\n */\nstatic const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_fr =\n{\n  /* Hashes from SHA-1 and above */\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA1) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_RIPEMD160) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA224) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),\n  0xFFFFFFF, /* Any PK alg    */\n  0xFFFFFFF, /* Any curve     */\n  1024,      /* RSA min key len */\n};\n\n/* See https://tls.mbed.org/discussions/generic/\n   howto-determine-exact-buffer-len-for-mbedtls_pk_write_pubkey_der\n*/\n#define RSA_PUB_DER_MAX_BYTES   (38 + 2 * MBEDTLS_MPI_MAX_SIZE)\n#define ECP_PUB_DER_MAX_BYTES   (30 + 2 * MBEDTLS_ECP_MAX_BYTES)\n\n#define PUB_DER_MAX_BYTES   (RSA_PUB_DER_MAX_BYTES > ECP_PUB_DER_MAX_BYTES ? \\\n                             RSA_PUB_DER_MAX_BYTES : ECP_PUB_DER_MAX_BYTES)\n\nstatic Curl_recv mbed_recv;\nstatic Curl_send mbed_send;\n\nstatic CURLcode mbedtls_version_from_curl(int *mbedver, long version)\n{\n  switch(version) {\n    case CURL_SSLVERSION_TLSv1_0:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_1;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_1:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_2;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_2:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_3;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int mbedtls_ver_min = MBEDTLS_SSL_MINOR_VERSION_1;\n  int mbedtls_ver_max = MBEDTLS_SSL_MINOR_VERSION_1;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  CURLcode result = CURLE_OK;\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      ssl_version = CURL_SSLVERSION_TLSv1_0;\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n      break;\n  }\n\n  result = mbedtls_version_from_curl(&mbedtls_ver_min, ssl_version);\n  if(result) {\n    failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n  result = mbedtls_version_from_curl(&mbedtls_ver_max, ssl_version_max >> 16);\n  if(result) {\n    failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n\n  mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_min);\n  mbedtls_ssl_conf_max_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_max);\n\n  return result;\n}\n\nstatic CURLcode\nmbed_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const char * const ssl_cafile = SSL_CONN_CONFIG(CAfile);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n  const char * const hostname = SSL_HOST_NAME();\n  const long int port = SSL_HOST_PORT();\n  int ret = -1;\n  char errorbuf[128];\n  errorbuf[0] = 0;\n\n  if((SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv2) ||\n     (SSL_CONN_CONFIG(version) == CURL_SSLVERSION_SSLv3)) {\n    failf(data, \"Not supported SSL version\");\n    return CURLE_NOT_BUILT_IN;\n  }\n\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&ts_entropy);\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, entropy_func_mutex,\n                              &ts_entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n#else\n  mbedtls_entropy_init(&backend->entropy);\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, mbedtls_entropy_func,\n                              &backend->entropy, NULL, 0);\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  mbedtls_x509_crt_init(&backend->cacert);\n\n  if(ssl_cafile) {\n    ret = mbedtls_x509_crt_parse_file(&backend->cacert, ssl_cafile);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cafile, -ret, errorbuf);\n\n      if(verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  if(ssl_capath) {\n    ret = mbedtls_x509_crt_parse_path(&backend->cacert, ssl_capath);\n\n    if(ret<0) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading ca cert path %s - mbedTLS: (-0x%04X) %s\",\n            ssl_capath, -ret, errorbuf);\n\n      if(verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Load the client certificate */\n  mbedtls_x509_crt_init(&backend->clicert);\n\n  if(ssl_cert) {\n    ret = mbedtls_x509_crt_parse_file(&backend->clicert, ssl_cert);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading client cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cert, -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  mbedtls_pk_init(&backend->pk);\n\n  if(SSL_SET_OPTION(key)) {\n    ret = mbedtls_pk_parse_keyfile(&backend->pk, SSL_SET_OPTION(key),\n                                   SSL_SET_OPTION(key_passwd));\n    if(ret == 0 && !(mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_RSA) ||\n                     mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_ECKEY)))\n      ret = MBEDTLS_ERR_PK_TYPE_MISMATCH;\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n            SSL_SET_OPTION(key), -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the CRL */\n  mbedtls_x509_crl_init(&backend->crl);\n\n  if(ssl_crlfile) {\n    ret = mbedtls_x509_crl_parse_file(&backend->crl, ssl_crlfile);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"Error reading CRL file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_crlfile, -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n  }\n\n  infof(data, \"mbedTLS: Connecting to %s:%ld\\n\", hostname, port);\n\n  mbedtls_ssl_config_init(&backend->config);\n\n  mbedtls_ssl_init(&backend->ssl);\n  if(mbedtls_ssl_setup(&backend->ssl, &backend->config)) {\n    failf(data, \"mbedTLS: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  ret = mbedtls_ssl_config_defaults(&backend->config,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT);\n  if(ret) {\n    failf(data, \"mbedTLS: ssl_config failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* new profile with RSA min key len = 1024 ... */\n  mbedtls_ssl_conf_cert_profile(&backend->config,\n                                &mbedtls_x509_crt_profile_fr);\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n    mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set min SSL version to TLS 1.0\\n\");\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    {\n      CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_conf_authmode(&backend->config, MBEDTLS_SSL_VERIFY_OPTIONAL);\n\n  mbedtls_ssl_conf_rng(&backend->config, mbedtls_ctr_drbg_random,\n                       &backend->ctr_drbg);\n  mbedtls_ssl_set_bio(&backend->ssl, &conn->sock[sockindex],\n                      mbedtls_net_send,\n                      mbedtls_net_recv,\n                      NULL /*  rev_timeout() */);\n\n  mbedtls_ssl_conf_ciphersuites(&backend->config,\n                                mbedtls_ssl_list_ciphersuites());\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n  mbedtls_ssl_conf_renegotiation(&backend->config,\n                                 MBEDTLS_SSL_RENEGOTIATION_ENABLED);\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n  mbedtls_ssl_conf_session_tickets(&backend->config,\n                                   MBEDTLS_SSL_SESSION_TICKETS_DISABLED);\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *old_session = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &old_session, NULL, sockindex)) {\n      ret = mbedtls_ssl_set_session(&backend->ssl, old_session);\n      if(ret) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"mbedtls_ssl_set_session returned -0x%x\", -ret);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      infof(data, \"mbedTLS re-using session\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  mbedtls_ssl_conf_ca_chain(&backend->config,\n                            &backend->cacert,\n                            &backend->crl);\n\n  if(SSL_SET_OPTION(key)) {\n    mbedtls_ssl_conf_own_cert(&backend->config,\n                              &backend->clicert, &backend->pk);\n  }\n  if(mbedtls_ssl_set_hostname(&backend->ssl, hostname)) {\n    /* mbedtls_ssl_set_hostname() sets the name to use in CN/SAN checks *and*\n       the name to set in the SNI extension. So even if curl connects to a\n       host specified as an IP address, this function must be used. */\n    failf(data, \"couldn't set hostname in mbedTLS\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char **p = &backend->protocols[0];\n#ifdef USE_NGHTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2)\n      *p++ = NGHTTP2_PROTO_VERSION_ID;\n#endif\n    *p++ = ALPN_HTTP_1_1;\n    *p = NULL;\n    /* this function doesn't clone the protocols array, which is why we need\n       to keep it around */\n    if(mbedtls_ssl_conf_alpn_protocols(&backend->config,\n                                       &backend->protocols[0])) {\n      failf(data, \"Failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    for(p = &backend->protocols[0]; *p; ++p)\n      infof(data, \"ALPN, offering %s\\n\", *p);\n  }\n#endif\n\n#ifdef MBEDTLS_DEBUG\n  /* In order to make that work in mbedtls MBEDTLS_DEBUG_C must be defined. */\n  mbedtls_ssl_conf_dbg(&backend->config, mbed_debug, data);\n  /* - 0 No debug\n   * - 1 Error\n   * - 2 State change\n   * - 3 Informational\n   * - 4 Verbose\n   */\n  mbedtls_debug_set_threshold(4);\n#endif\n\n  /* give application a chance to interfere with mbedTLS set up. */\n  if(data->set.ssl.fsslctx) {\n    ret = (*data->set.ssl.fsslctx)(data, &backend->config,\n                                   data->set.ssl.fsslctxp);\n    if(ret) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return ret;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  int ret;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const mbedtls_x509_crt *peercert;\n  const char * const pinnedpubkey = SSL_PINNED_PUB_KEY();\n\n  conn->recv[sockindex] = mbed_recv;\n  conn->send[sockindex] = mbed_send;\n\n  ret = mbedtls_ssl_handshake(&backend->ssl);\n\n  if(ret == MBEDTLS_ERR_SSL_WANT_READ) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n  else if(ret == MBEDTLS_ERR_SSL_WANT_WRITE) {\n    connssl->connecting_state = ssl_connect_2_writing;\n    return CURLE_OK;\n  }\n  else if(ret) {\n    char errorbuf[128];\n    errorbuf[0] = 0;\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"ssl_handshake returned - mbedTLS: (-0x%04X) %s\",\n          -ret, errorbuf);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  infof(data, \"mbedTLS: Handshake complete, cipher is %s\\n\",\n        mbedtls_ssl_get_ciphersuite(&backend->ssl)\n    );\n\n  ret = mbedtls_ssl_get_verify_result(&backend->ssl);\n\n  if(!SSL_CONN_CONFIG(verifyhost))\n    /* Ignore hostname errors if verifyhost is disabled */\n    ret &= ~MBEDTLS_X509_BADCERT_CN_MISMATCH;\n\n  if(ret && SSL_CONN_CONFIG(verifypeer)) {\n    if(ret & MBEDTLS_X509_BADCERT_EXPIRED)\n      failf(data, \"Cert verify failed: BADCERT_EXPIRED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_REVOKED)\n      failf(data, \"Cert verify failed: BADCERT_REVOKED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_CN_MISMATCH)\n      failf(data, \"Cert verify failed: BADCERT_CN_MISMATCH\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_NOT_TRUSTED)\n      failf(data, \"Cert verify failed: BADCERT_NOT_TRUSTED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_FUTURE)\n      failf(data, \"Cert verify failed: BADCERT_FUTURE\");\n\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  peercert = mbedtls_ssl_get_peer_cert(&backend->ssl);\n\n  if(peercert && data->set.verbose) {\n    const size_t bufsize = 16384;\n    char *buffer = malloc(bufsize);\n\n    if(!buffer)\n      return CURLE_OUT_OF_MEMORY;\n\n    if(mbedtls_x509_crt_info(buffer, bufsize, \"* \", peercert) > 0)\n      infof(data, \"Dumping cert info:\\n%s\\n\", buffer);\n    else\n      infof(data, \"Unable to dump certificate information.\\n\");\n\n    free(buffer);\n  }\n\n  if(pinnedpubkey) {\n    int size;\n    CURLcode result;\n    mbedtls_x509_crt *p;\n    unsigned char pubkey[PUB_DER_MAX_BYTES];\n\n    if(!peercert || !peercert->raw.p || !peercert->raw.len) {\n      failf(data, \"Failed due to missing peer certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    p = calloc(1, sizeof(*p));\n\n    if(!p)\n      return CURLE_OUT_OF_MEMORY;\n\n    mbedtls_x509_crt_init(p);\n\n    /* Make a copy of our const peercert because mbedtls_pk_write_pubkey_der\n       needs a non-const key, for now.\n       https://github.com/ARMmbed/mbedtls/issues/396 */\n    if(mbedtls_x509_crt_parse_der(p, peercert->raw.p, peercert->raw.len)) {\n      failf(data, \"Failed copying peer certificate\");\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    size = mbedtls_pk_write_pubkey_der(&p->pk, pubkey, PUB_DER_MAX_BYTES);\n\n    if(size <= 0) {\n      failf(data, \"Failed copying public key from peer certificate\");\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    /* mbedtls_pk_write_pubkey_der writes data at the end of the buffer. */\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  &pubkey[PUB_DER_MAX_BYTES - size], size);\n    if(result) {\n      mbedtls_x509_crt_free(p);\n      free(p);\n      return result;\n    }\n\n    mbedtls_x509_crt_free(p);\n    free(p);\n  }\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    const char *next_protocol = mbedtls_ssl_get_alpn_protocol(&backend->ssl);\n\n    if(next_protocol) {\n      infof(data, \"ALPN, server accepted to use %s\\n\", next_protocol);\n#ifdef USE_NGHTTP2\n      if(!strncmp(next_protocol, NGHTTP2_PROTO_VERSION_ID,\n                  NGHTTP2_PROTO_VERSION_ID_LEN) &&\n         !next_protocol[NGHTTP2_PROTO_VERSION_ID_LEN]) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(!strncmp(next_protocol, ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH) &&\n           !next_protocol[ALPN_HTTP_1_1_LENGTH]) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else {\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    }\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  connssl->connecting_state = ssl_connect_3;\n  infof(data, \"SSL connected\\n\");\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex)\n{\n  CURLcode retcode = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int ret;\n    mbedtls_ssl_session *our_ssl_sessionid;\n    void *old_ssl_sessionid = NULL;\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    our_ssl_sessionid = malloc(sizeof(mbedtls_ssl_session));\n    if(!our_ssl_sessionid)\n      return CURLE_OUT_OF_MEMORY;\n\n    mbedtls_ssl_session_init(our_ssl_sessionid);\n\n    ret = mbedtls_ssl_get_session(&backend->ssl, our_ssl_sessionid);\n    if(ret) {\n      if(ret != MBEDTLS_ERR_SSL_ALLOC_FAILED)\n        mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n      failf(data, \"mbedtls_ssl_get_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* If there's already a matching session in the cache, delete it */\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, isproxy, &old_ssl_sessionid, NULL,\n                              sockindex))\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n\n    retcode = Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid,\n                                    0, sockindex);\n    Curl_ssl_sessionid_unlock(data);\n    if(retcode) {\n      mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n      failf(data, \"failed to store ssl session\");\n      return retcode;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t mbed_send(struct Curl_easy *data, int sockindex,\n                         const void *mem, size_t len,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  int ret = -1;\n\n  ret = mbedtls_ssl_write(&backend->ssl, (unsigned char *)mem, len);\n\n  if(ret < 0) {\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_WRITE) ?\n      CURLE_AGAIN : CURLE_SEND_ERROR;\n    ret = -1;\n  }\n\n  return ret;\n}\n\nstatic void mbedtls_close_all(struct Curl_easy *data)\n{\n  (void)data;\n}\n\nstatic void mbedtls_close(struct Curl_easy *data,\n                          struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n  mbedtls_pk_free(&backend->pk);\n  mbedtls_x509_crt_free(&backend->clicert);\n  mbedtls_x509_crt_free(&backend->cacert);\n  mbedtls_x509_crl_free(&backend->crl);\n  mbedtls_ssl_config_free(&backend->config);\n  mbedtls_ssl_free(&backend->ssl);\n  mbedtls_ctr_drbg_free(&backend->ctr_drbg);\n#ifndef THREADING_SUPPORT\n  mbedtls_entropy_free(&backend->entropy);\n#endif /* THREADING_SUPPORT */\n}\n\nstatic ssize_t mbed_recv(struct Curl_easy *data, int num,\n                         char *buf, size_t buffersize,\n                         CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  int ret = -1;\n  ssize_t len = -1;\n\n  ret = mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf,\n                         buffersize);\n\n  if(ret <= 0) {\n    if(ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)\n      return 0;\n\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_READ) ?\n      CURLE_AGAIN : CURLE_RECV_ERROR;\n    return -1;\n  }\n\n  len = ret;\n\n  return len;\n}\n\nstatic void mbedtls_session_free(void *ptr)\n{\n  mbedtls_ssl_session_free(ptr);\n  free(ptr);\n}\n\nstatic size_t mbedtls_version(char *buffer, size_t size)\n{\n#ifdef MBEDTLS_VERSION_C\n  /* if mbedtls_version_get_number() is available it is better */\n  unsigned int version = mbedtls_version_get_number();\n  return msnprintf(buffer, size, \"mbedTLS/%u.%u.%u\", version>>24,\n                   (version>>16)&0xff, (version>>8)&0xff);\n#else\n  return msnprintf(buffer, size, \"mbedTLS/%s\", MBEDTLS_VERSION_STRING);\n#endif\n}\n\nstatic CURLcode mbedtls_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n#if defined(MBEDTLS_CTR_DRBG_C)\n  int ret = -1;\n  char errorbuf[128];\n  mbedtls_entropy_context ctr_entropy;\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_init(&ctr_entropy);\n  mbedtls_ctr_drbg_init(&ctr_drbg);\n  errorbuf[0] = 0;\n\n  ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func,\n                              &ctr_entropy, NULL, 0);\n\n  if(ret) {\n#ifdef MBEDTLS_ERROR_C\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n    failf(data, \"Failed - mbedTLS: ctr_drbg_seed returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n  else {\n    ret = mbedtls_ctr_drbg_random(&ctr_drbg, entropy, length);\n\n    if(ret) {\n#ifdef MBEDTLS_ERROR_C\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n#endif /* MBEDTLS_ERROR_C */\n      failf(data, \"mbedTLS: ctr_drbg_init returned (-0x%04X) %s\",\n            -ret, errorbuf);\n    }\n  }\n\n  mbedtls_ctr_drbg_free(&ctr_drbg);\n  mbedtls_entropy_free(&ctr_entropy);\n\n  return ret == 0 ? CURLE_OK : CURLE_FAILED_INIT;\n#elif defined(MBEDTLS_HAVEGE_C)\n  mbedtls_havege_state hs;\n  mbedtls_havege_init(&hs);\n  mbedtls_havege_random(&hs, entropy, length);\n  mbedtls_havege_free(&hs);\n  return CURLE_OK;\n#else\n  return CURLE_NOT_BUILT_IN;\n#endif\n}\n\nstatic CURLcode\nmbed_connect_common(struct Curl_easy *data,\n                    struct connectdata *conn,\n                    int sockindex,\n                    bool nonblocking,\n                    bool *done)\n{\n  CURLcode retcode;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    retcode = mbed_connect_step1(data, conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    retcode = mbed_connect_step2(data, conn, sockindex);\n    if(retcode || (nonblocking &&\n                   (ssl_connect_2 == connssl->connecting_state ||\n                    ssl_connect_2_reading == connssl->connecting_state ||\n                    ssl_connect_2_writing == connssl->connecting_state)))\n      return retcode;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    retcode = mbed_connect_step3(data, conn, sockindex);\n    if(retcode)\n      return retcode;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = mbed_recv;\n    conn->send[sockindex] = mbed_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode mbedtls_connect_nonblocking(struct Curl_easy *data,\n                                            struct connectdata *conn,\n                                            int sockindex, bool *done)\n{\n  return mbed_connect_common(data, conn, sockindex, TRUE, done);\n}\n\n\nstatic CURLcode mbedtls_connect(struct Curl_easy *data,\n                                struct connectdata *conn, int sockindex)\n{\n  CURLcode retcode;\n  bool done = FALSE;\n\n  retcode = mbed_connect_common(data, conn, sockindex, FALSE, &done);\n  if(retcode)\n    return retcode;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\n/*\n * return 0 error initializing SSL\n * return 1 SSL initialized successfully\n */\nstatic int mbedtls_init(void)\n{\n  return Curl_mbedtlsthreadlock_thread_setup();\n}\n\nstatic void mbedtls_cleanup(void)\n{\n  (void)Curl_mbedtlsthreadlock_thread_cleanup();\n}\n\nstatic bool mbedtls_data_pending(const struct connectdata *conn,\n                                 int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  return mbedtls_ssl_get_bytes_avail(&backend->ssl) != 0;\n}\n\nstatic CURLcode mbedtls_sha256sum(const unsigned char *input,\n                                  size_t inputlen,\n                                  unsigned char *sha256sum,\n                                  size_t sha256len UNUSED_PARAM)\n{\n  (void)sha256len;\n#if MBEDTLS_VERSION_NUMBER < 0x02070000\n  mbedtls_sha256(input, inputlen, sha256sum, 0);\n#else\n  /* returns 0 on success, otherwise failure */\n  if(mbedtls_sha256_ret(input, inputlen, sha256sum, 0) != 0)\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n#endif\n  return CURLE_OK;\n}\n\nstatic void *mbedtls_get_internals(struct ssl_connect_data *connssl,\n                                   CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return &backend->ssl;\n}\n\nconst struct Curl_ssl Curl_ssl_mbedtls = {\n  { CURLSSLBACKEND_MBEDTLS, \"mbedtls\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  mbedtls_init,                     /* init */\n  mbedtls_cleanup,                  /* cleanup */\n  mbedtls_version,                  /* version */\n  Curl_none_check_cxn,              /* check_cxn */\n  Curl_none_shutdown,               /* shutdown */\n  mbedtls_data_pending,             /* data_pending */\n  mbedtls_random,                   /* random */\n  Curl_none_cert_status_request,    /* cert_status_request */\n  mbedtls_connect,                  /* connect */\n  mbedtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                 /* getsock */\n  mbedtls_get_internals,            /* get_internals */\n  mbedtls_close,                    /* close_one */\n  mbedtls_close_all,                /* close_all */\n  mbedtls_session_free,             /* session_free */\n  Curl_none_set_engine,             /* set_engine */\n  Curl_none_set_engine_default,     /* set_engine_default */\n  Curl_none_engines_list,           /* engines_list */\n  Curl_none_false_start,            /* false_start */\n  mbedtls_sha256sum,                /* sha256sum */\n  NULL,                             /* associate_connection */\n  NULL                              /* disassociate_connection */\n};\n\n#endif /* USE_MBEDTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2017 - 2018, Yiming Jing, <jingyiming@baidu.com>\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all MesaLink-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n/*\n * Based upon the CyaSSL implementation in cyassl.c and cyassl.h:\n *   Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * Thanks for code and inspiration!\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_MESALINK\n\n#include <mesalink/options.h>\n#include <mesalink/version.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"vtls.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n\n#include \"mesalink.h\"\n#include <mesalink/openssl/ssl.h>\n#include <mesalink/openssl/err.h>\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define MESALINK_MAX_ERROR_SZ 80\n\nstruct ssl_backend_data\n{\n  SSL_CTX *ctx;\n  SSL *handle;\n};\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv mesalink_recv;\nstatic Curl_send mesalink_send;\n\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  return -1;\n}\n\n/*\n * This function loads all the client/CA certificates and CRLs. Setup the TLS\n * layer and do all necessary magic.\n */\nstatic CURLcode\nmesalink_connect_step1(struct Curl_easy *data,\n                       struct connectdata *conn, int sockindex)\n{\n  char *ciphers;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct in_addr addr4;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  const char * const hostname = SSL_HOST_NAME();\n  size_t hostname_len = strlen(hostname);\n\n  SSL_METHOD *req_method = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n\n  if(connssl->state == ssl_connection_complete)\n    return CURLE_OK;\n\n  if(SSL_CONN_CONFIG(version_max) != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"MesaLink does not support to set maximum SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_SSLv3:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n    failf(data, \"MesaLink does not support SSL 3.0, TLS 1.0, or TLS 1.1\");\n    return CURLE_NOT_BUILT_IN;\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1_2:\n    req_method = TLSv1_2_client_method();\n    break;\n  case CURL_SSLVERSION_TLSv1_3:\n    req_method = TLSv1_3_client_method();\n    break;\n  case CURL_SSLVERSION_SSLv2:\n    failf(data, \"MesaLink does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(!req_method) {\n    failf(data, \"SSL: couldn't create a method!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(BACKEND->ctx)\n    SSL_CTX_free(BACKEND->ctx);\n  BACKEND->ctx = SSL_CTX_new(req_method);\n\n  if(!BACKEND->ctx) {\n    failf(data, \"SSL: couldn't create a context!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  SSL_CTX_set_verify(\n    BACKEND->ctx, SSL_CONN_CONFIG(verifypeer) ?\n      SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);\n\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(CApath)) {\n    if(!SSL_CTX_load_verify_locations(BACKEND->ctx, SSL_CONN_CONFIG(CAfile),\n                                                    SSL_CONN_CONFIG(CApath))) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data,\n              \"error setting certificate verify locations: \"\n              \" CAfile: %s CApath: %s\",\n              SSL_CONN_CONFIG(CAfile) ?\n              SSL_CONN_CONFIG(CAfile) : \"none\",\n              SSL_CONN_CONFIG(CApath) ?\n              SSL_CONN_CONFIG(CApath) : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      infof(data,\n          \"error setting certificate verify locations,\"\n          \" continuing anyway:\\n\");\n    }\n    else {\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\",\n          SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile): \"none\");\n    infof(data, \" CApath: %s\\n\",\n          SSL_CONN_CONFIG(CApath) ? SSL_CONN_CONFIG(CApath): \"none\");\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert) && SSL_SET_OPTION(key)) {\n    int file_type = do_file_type(SSL_SET_OPTION(cert_type));\n\n    if(SSL_CTX_use_certificate_chain_file(BACKEND->ctx,\n                                          SSL_SET_OPTION(primary.clientcert),\n                                          file_type) != 1) {\n      failf(data, \"unable to use client certificate (no key or wrong pass\"\n            \" phrase?)\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    file_type = do_file_type(SSL_SET_OPTION(key_type));\n    if(SSL_CTX_use_PrivateKey_file(BACKEND->ctx, SSL_SET_OPTION(key),\n                                    file_type) != 1) {\n      failf(data, \"unable to set private key\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data,\n          \"client cert: %s\\n\",\n          SSL_CONN_CONFIG(clientcert)?\n          SSL_CONN_CONFIG(clientcert): \"none\");\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n#ifdef MESALINK_HAVE_CIPHER\n    if(!SSL_CTX_set_cipher_list(BACKEND->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n#endif\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n  if(BACKEND->handle)\n    SSL_free(BACKEND->handle);\n  BACKEND->handle = SSL_new(BACKEND->ctx);\n  if(!BACKEND->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if((hostname_len < USHRT_MAX) &&\n     (0 == Curl_inet_pton(AF_INET, hostname, &addr4))\n#ifdef ENABLE_IPV6\n     && (0 == Curl_inet_pton(AF_INET6, hostname, &addr6))\n#endif\n  ) {\n    /* hostname is not a valid IP address */\n    if(SSL_set_tlsext_host_name(BACKEND->handle, hostname) != SSL_SUCCESS) {\n      failf(data,\n            \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#ifdef CURLDEBUG\n    /* Check if the hostname is 127.0.0.1 or [::1];\n     * otherwise reject because MesaLink always wants a valid DNS Name\n     * specified in RFC 5280 Section 7.2 */\n    if(strncmp(hostname, \"127.0.0.1\", 9) == 0\n#ifdef ENABLE_IPV6\n       || strncmp(hostname, \"[::1]\", 5) == 0\n#endif\n    ) {\n      SSL_set_tlsext_host_name(BACKEND->handle, \"localhost\");\n    }\n    else\n#endif\n    {\n      failf(data,\n            \"ERROR: MesaLink does not accept an IP address as a hostname\\n\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n#ifdef MESALINK_HAVE_SESSION\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(BACKEND->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(\n          data,\n          \"SSL: SSL_set_session failed: %s\",\n          ERR_error_string(SSL_get_error(BACKEND->handle, 0), error_buffer));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n#endif /* MESALINK_HAVE_SESSION */\n\n  if(SSL_set_fd(BACKEND->handle, (int)sockfd) != SSL_SUCCESS) {\n    failf(data, \"SSL: SSL_set_fd failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_step2(struct Curl_easy *data,\n                       struct connectdata *conn, int sockindex)\n{\n  int ret = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  conn->recv[sockindex] = mesalink_recv;\n  conn->send[sockindex] = mesalink_send;\n\n  ret = SSL_connect(BACKEND->handle);\n  if(ret != SSL_SUCCESS) {\n    int detail = SSL_get_error(BACKEND->handle, ret);\n\n    if(SSL_ERROR_WANT_CONNECT == detail || SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    else {\n      char error_buffer[MESALINK_MAX_ERROR_SZ];\n      failf(data,\n            \"SSL_connect failed with error %d: %s\",\n            detail,\n            ERR_error_string_n(detail, error_buffer, sizeof(error_buffer)));\n      ERR_print_errors_fp(stderr);\n      if(detail && SSL_CONN_CONFIG(verifypeer)) {\n        detail &= ~0xFF;\n        if(detail == TLS_ERROR_WEBPKI_ERRORS) {\n          failf(data, \"Cert verify failed\");\n          return CURLE_PEER_FAILED_VERIFICATION;\n        }\n      }\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_3;\n  infof(data,\n        \"SSL connection using %s / %s\\n\",\n        SSL_get_version(BACKEND->handle),\n        SSL_get_cipher_name(BACKEND->handle));\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_step3(struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n#ifdef MESALINK_HAVE_SESSION\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    SSL_SESSION *our_ssl_sessionid;\n    void *old_ssl_sessionid = NULL;\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    our_ssl_sessionid = SSL_get_session(BACKEND->handle);\n\n    Curl_ssl_sessionid_lock(data);\n    incache =\n      !(Curl_ssl_getsessionid(data, conn, isproxy, &old_ssl_sessionid, NULL,\n                              sockindex));\n    if(incache) {\n      if(old_ssl_sessionid != our_ssl_sessionid) {\n        infof(data, \"old SSL session ID is stale, removing\\n\");\n        Curl_ssl_delsessionid(data, old_ssl_sessionid);\n        incache = FALSE;\n      }\n    }\n\n    if(!incache) {\n      result =\n        Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid, 0,\n                              sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"failed to store ssl session\");\n        return result;\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n#endif /* MESALINK_HAVE_SESSION */\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic ssize_t\nmesalink_send(struct Curl_easy *data, int sockindex, const void *mem,\n              size_t len, CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char error_buffer[MESALINK_MAX_ERROR_SZ];\n  int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  int rc = SSL_write(BACKEND->handle, mem, memlen);\n\n  if(rc < 0) {\n    int err = SSL_get_error(BACKEND->handle, rc);\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_write() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data,\n            \"SSL write: %s, errno %d\",\n            ERR_error_string_n(err, error_buffer, sizeof(error_buffer)),\n            SOCKERRNO);\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n  return rc;\n}\n\nstatic void\nmesalink_close(struct Curl_easy *data, struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  (void) data;\n\n  if(BACKEND->handle) {\n    (void)SSL_shutdown(BACKEND->handle);\n    SSL_free(BACKEND->handle);\n    BACKEND->handle = NULL;\n  }\n  if(BACKEND->ctx) {\n    SSL_CTX_free(BACKEND->ctx);\n    BACKEND->ctx = NULL;\n  }\n}\n\nstatic ssize_t\nmesalink_recv(struct Curl_easy *data, int num, char *buf, size_t buffersize,\n              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  char error_buffer[MESALINK_MAX_ERROR_SZ];\n  int buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  int nread = SSL_read(BACKEND->handle, buf, buffsize);\n\n  if(nread <= 0) {\n    int err = SSL_get_error(BACKEND->handle, nread);\n\n    switch(err) {\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n    case IO_ERROR_CONNECTION_ABORTED:\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data,\n            \"SSL read: %s, errno %d\",\n            ERR_error_string_n(err, error_buffer, sizeof(error_buffer)),\n            SOCKERRNO);\n      *curlcode = CURLE_RECV_ERROR;\n      return -1;\n    }\n  }\n  return nread;\n}\n\nstatic size_t\nmesalink_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"MesaLink/%s\", MESALINK_VERSION_STRING);\n}\n\nstatic int\nmesalink_init(void)\n{\n  return (SSL_library_init() == SSL_SUCCESS);\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int\nmesalink_shutdown(struct Curl_easy *data,\n                  struct connectdata *conn, int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  (void) data;\n\n  if(BACKEND->handle) {\n    SSL_free(BACKEND->handle);\n    BACKEND->handle = NULL;\n  }\n  return retval;\n}\n\nstatic CURLcode\nmesalink_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = mesalink_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd =\n        ssl_connect_2_writing == connssl->connecting_state ? sockfd\n                                                           : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading == connssl->connecting_state\n                               ? sockfd\n                               : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = mesalink_connect_step2(data, conn, sockindex);\n\n    if(result ||\n       (nonblocking && (ssl_connect_2 == connssl->connecting_state ||\n                        ssl_connect_2_reading == connssl->connecting_state ||\n                        ssl_connect_2_writing == connssl->connecting_state))) {\n      return result;\n    }\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = mesalink_connect_step3(conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = mesalink_recv;\n    conn->send[sockindex] = mesalink_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmesalink_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, bool *done)\n{\n  return mesalink_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode\nmesalink_connect(struct Curl_easy *data, struct connectdata *conn,\n                 int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = mesalink_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic void *\nmesalink_get_internals(struct ssl_connect_data *connssl,\n                       CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return BACKEND->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_mesalink = {\n  { CURLSSLBACKEND_MESALINK, \"MesaLink\" }, /* info */\n\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  mesalink_init,                 /* init */\n  Curl_none_cleanup,             /* cleanup */\n  mesalink_version,              /* version */\n  Curl_none_check_cxn,           /* check_cxn */\n  mesalink_shutdown,             /* shutdown */\n  Curl_none_data_pending,        /* data_pending */\n  Curl_none_random,              /* random */\n  Curl_none_cert_status_request, /* cert_status_request */\n  mesalink_connect,              /* connect */\n  mesalink_connect_nonblocking,  /* connect_nonblocking */\n  Curl_ssl_getsock,              /* getsock */\n  mesalink_get_internals,        /* get_internals */\n  mesalink_close,                /* close_one */\n  Curl_none_close_all,           /* close_all */\n  Curl_none_session_free,        /* session_free */\n  Curl_none_set_engine,          /* set_engine */\n  Curl_none_set_engine_default,  /* set_engine_default */\n  Curl_none_engines_list,        /* engines_list */\n  Curl_none_false_start,         /* false_start */\n  NULL,                          /* sha256sum */\n  NULL,                          /* associate_connection */\n  NULL                           /* disassociate_connection */\n};\n\n#endif\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all NSS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_NSS\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"formdata.h\" /* for the boundary function */\n#include \"url.h\" /* for the ssl config check function */\n#include \"connect.h\"\n#include \"strcase.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"llist.h\"\n#include \"multiif.h\"\n#include \"curl_printf.h\"\n#include \"nssg.h\"\n#include <nspr.h>\n#include <nss.h>\n#include <ssl.h>\n#include <sslerr.h>\n#include <secerr.h>\n#include <secmod.h>\n#include <sslproto.h>\n#include <prtypes.h>\n#include <pk11pub.h>\n#include <prio.h>\n#include <secitem.h>\n#include <secport.h>\n#include <certdb.h>\n#include <base64.h>\n#include <cert.h>\n#include <prerror.h>\n#include <keyhi.h>         /* for SECKEY_DestroyPublicKey() */\n#include <private/pprio.h> /* for PR_ImportTCPSocket */\n\n#define NSSVERNUM ((NSS_VMAJOR<<16)|(NSS_VMINOR<<8)|NSS_VPATCH)\n\n#if NSSVERNUM >= 0x030f00 /* 3.15.0 */\n#include <ocsp.h>\n#endif\n\n#include \"strcase.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#define SSL_DIR \"/etc/pki/nssdb\"\n\n/* enough to fit the string \"PEM Token #[0|1]\" */\n#define SLOTSIZE 13\n\nstruct ssl_backend_data {\n  PRFileDesc *handle;\n  char *client_nickname;\n  struct Curl_easy *data;\n  struct Curl_llist obj_list;\n  PK11GenericObject *obj_clicert;\n};\n\nstatic PRLock *nss_initlock = NULL;\nstatic PRLock *nss_crllock = NULL;\nstatic PRLock *nss_findslot_lock = NULL;\nstatic PRLock *nss_trustload_lock = NULL;\nstatic struct Curl_llist nss_crl_list;\nstatic NSSInitContext *nss_context = NULL;\nstatic volatile int initialized = 0;\n\n/* type used to wrap pointers as list nodes */\nstruct ptr_list_wrap {\n  void *ptr;\n  struct Curl_llist_element node;\n};\n\nstruct cipher_s {\n  const char *name;\n  int num;\n};\n\n#define PK11_SETATTRS(_attr, _idx, _type, _val, _len) do {  \\\n  CK_ATTRIBUTE *ptr = (_attr) + ((_idx)++);                 \\\n  ptr->type = (_type);                                      \\\n  ptr->pValue = (_val);                                     \\\n  ptr->ulValueLen = (_len);                                 \\\n} while(0)\n\n#define CERT_NewTempCertificate __CERT_NewTempCertificate\n\n#define NUM_OF_CIPHERS sizeof(cipherlist)/sizeof(cipherlist[0])\nstatic const struct cipher_s cipherlist[] = {\n  /* SSL2 cipher suites */\n  {\"rc4\",                        SSL_EN_RC4_128_WITH_MD5},\n  {\"rc4-md5\",                    SSL_EN_RC4_128_WITH_MD5},\n  {\"rc4export\",                  SSL_EN_RC4_128_EXPORT40_WITH_MD5},\n  {\"rc2\",                        SSL_EN_RC2_128_CBC_WITH_MD5},\n  {\"rc2export\",                  SSL_EN_RC2_128_CBC_EXPORT40_WITH_MD5},\n  {\"des\",                        SSL_EN_DES_64_CBC_WITH_MD5},\n  {\"desede3\",                    SSL_EN_DES_192_EDE3_CBC_WITH_MD5},\n  /* SSL3/TLS cipher suites */\n  {\"rsa_rc4_128_md5\",            SSL_RSA_WITH_RC4_128_MD5},\n  {\"rsa_rc4_128_sha\",            SSL_RSA_WITH_RC4_128_SHA},\n  {\"rsa_3des_sha\",               SSL_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"rsa_des_sha\",                SSL_RSA_WITH_DES_CBC_SHA},\n  {\"rsa_rc4_40_md5\",             SSL_RSA_EXPORT_WITH_RC4_40_MD5},\n  {\"rsa_rc2_40_md5\",             SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5},\n  {\"rsa_null_md5\",               SSL_RSA_WITH_NULL_MD5},\n  {\"rsa_null_sha\",               SSL_RSA_WITH_NULL_SHA},\n  {\"fips_3des_sha\",              SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA},\n  {\"fips_des_sha\",               SSL_RSA_FIPS_WITH_DES_CBC_SHA},\n  {\"fortezza\",                   SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA},\n  {\"fortezza_rc4_128_sha\",       SSL_FORTEZZA_DMS_WITH_RC4_128_SHA},\n  {\"fortezza_null\",              SSL_FORTEZZA_DMS_WITH_NULL_SHA},\n  {\"dhe_rsa_3des_sha\",           SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"dhe_dss_3des_sha\",           SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA},\n  {\"dhe_rsa_des_sha\",            SSL_DHE_RSA_WITH_DES_CBC_SHA},\n  {\"dhe_dss_des_sha\",            SSL_DHE_DSS_WITH_DES_CBC_SHA},\n  /* TLS 1.0: Exportable 56-bit Cipher Suites. */\n  {\"rsa_des_56_sha\",             TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA},\n  {\"rsa_rc4_56_sha\",             TLS_RSA_EXPORT1024_WITH_RC4_56_SHA},\n  /* Ephemeral DH with RC4 bulk encryption */\n  {\"dhe_dss_rc4_128_sha\",    TLS_DHE_DSS_WITH_RC4_128_SHA},\n  /* AES ciphers. */\n  {\"dhe_dss_aes_128_cbc_sha\",    TLS_DHE_DSS_WITH_AES_128_CBC_SHA},\n  {\"dhe_dss_aes_256_cbc_sha\",    TLS_DHE_DSS_WITH_AES_256_CBC_SHA},\n  {\"dhe_rsa_aes_128_cbc_sha\",    TLS_DHE_RSA_WITH_AES_128_CBC_SHA},\n  {\"dhe_rsa_aes_256_cbc_sha\",    TLS_DHE_RSA_WITH_AES_256_CBC_SHA},\n  {\"rsa_aes_128_sha\",            TLS_RSA_WITH_AES_128_CBC_SHA},\n  {\"rsa_aes_256_sha\",            TLS_RSA_WITH_AES_256_CBC_SHA},\n  /* ECC ciphers. */\n  {\"ecdh_ecdsa_null_sha\",        TLS_ECDH_ECDSA_WITH_NULL_SHA},\n  {\"ecdh_ecdsa_rc4_128_sha\",     TLS_ECDH_ECDSA_WITH_RC4_128_SHA},\n  {\"ecdh_ecdsa_3des_sha\",        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_ecdsa_aes_128_sha\",     TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA},\n  {\"ecdh_ecdsa_aes_256_sha\",     TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA},\n  {\"ecdhe_ecdsa_null_sha\",       TLS_ECDHE_ECDSA_WITH_NULL_SHA},\n  {\"ecdhe_ecdsa_rc4_128_sha\",    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA},\n  {\"ecdhe_ecdsa_3des_sha\",       TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdhe_ecdsa_aes_128_sha\",    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA},\n  {\"ecdhe_ecdsa_aes_256_sha\",    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA},\n  {\"ecdh_rsa_null_sha\",          TLS_ECDH_RSA_WITH_NULL_SHA},\n  {\"ecdh_rsa_128_sha\",           TLS_ECDH_RSA_WITH_RC4_128_SHA},\n  {\"ecdh_rsa_3des_sha\",          TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_rsa_aes_128_sha\",       TLS_ECDH_RSA_WITH_AES_128_CBC_SHA},\n  {\"ecdh_rsa_aes_256_sha\",       TLS_ECDH_RSA_WITH_AES_256_CBC_SHA},\n  {\"ecdhe_rsa_null\",             TLS_ECDHE_RSA_WITH_NULL_SHA},\n  {\"ecdhe_rsa_rc4_128_sha\",      TLS_ECDHE_RSA_WITH_RC4_128_SHA},\n  {\"ecdhe_rsa_3des_sha\",         TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdhe_rsa_aes_128_sha\",      TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA},\n  {\"ecdhe_rsa_aes_256_sha\",      TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA},\n  {\"ecdh_anon_null_sha\",         TLS_ECDH_anon_WITH_NULL_SHA},\n  {\"ecdh_anon_rc4_128sha\",       TLS_ECDH_anon_WITH_RC4_128_SHA},\n  {\"ecdh_anon_3des_sha\",         TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA},\n  {\"ecdh_anon_aes_128_sha\",      TLS_ECDH_anon_WITH_AES_128_CBC_SHA},\n  {\"ecdh_anon_aes_256_sha\",      TLS_ECDH_anon_WITH_AES_256_CBC_SHA},\n#ifdef TLS_RSA_WITH_NULL_SHA256\n  /* new HMAC-SHA256 cipher suites specified in RFC */\n  {\"rsa_null_sha_256\",                TLS_RSA_WITH_NULL_SHA256},\n  {\"rsa_aes_128_cbc_sha_256\",         TLS_RSA_WITH_AES_128_CBC_SHA256},\n  {\"rsa_aes_256_cbc_sha_256\",         TLS_RSA_WITH_AES_256_CBC_SHA256},\n  {\"dhe_rsa_aes_128_cbc_sha_256\",     TLS_DHE_RSA_WITH_AES_128_CBC_SHA256},\n  {\"dhe_rsa_aes_256_cbc_sha_256\",     TLS_DHE_RSA_WITH_AES_256_CBC_SHA256},\n  {\"ecdhe_ecdsa_aes_128_cbc_sha_256\", TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256},\n  {\"ecdhe_rsa_aes_128_cbc_sha_256\",   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256},\n#endif\n#ifdef TLS_RSA_WITH_AES_128_GCM_SHA256\n  /* AES GCM cipher suites in RFC 5288 and RFC 5289 */\n  {\"rsa_aes_128_gcm_sha_256\",         TLS_RSA_WITH_AES_128_GCM_SHA256},\n  {\"dhe_rsa_aes_128_gcm_sha_256\",     TLS_DHE_RSA_WITH_AES_128_GCM_SHA256},\n  {\"dhe_dss_aes_128_gcm_sha_256\",     TLS_DHE_DSS_WITH_AES_128_GCM_SHA256},\n  {\"ecdhe_ecdsa_aes_128_gcm_sha_256\", TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdh_ecdsa_aes_128_gcm_sha_256\",  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdhe_rsa_aes_128_gcm_sha_256\",   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256},\n  {\"ecdh_rsa_aes_128_gcm_sha_256\",    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256},\n#endif\n#ifdef TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n  /* cipher suites using SHA384 */\n  {\"rsa_aes_256_gcm_sha_384\",         TLS_RSA_WITH_AES_256_GCM_SHA384},\n  {\"dhe_rsa_aes_256_gcm_sha_384\",     TLS_DHE_RSA_WITH_AES_256_GCM_SHA384},\n  {\"dhe_dss_aes_256_gcm_sha_384\",     TLS_DHE_DSS_WITH_AES_256_GCM_SHA384},\n  {\"ecdhe_ecdsa_aes_256_sha_384\",     TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384},\n  {\"ecdhe_rsa_aes_256_sha_384\",       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384},\n  {\"ecdhe_ecdsa_aes_256_gcm_sha_384\", TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384},\n  {\"ecdhe_rsa_aes_256_gcm_sha_384\",   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384},\n#endif\n#ifdef TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n  /* chacha20-poly1305 cipher suites */\n {\"ecdhe_rsa_chacha20_poly1305_sha_256\",\n     TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256},\n {\"ecdhe_ecdsa_chacha20_poly1305_sha_256\",\n     TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256},\n {\"dhe_rsa_chacha20_poly1305_sha_256\",\n     TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256},\n#endif\n#ifdef TLS_AES_256_GCM_SHA384\n {\"aes_128_gcm_sha_256\",              TLS_AES_128_GCM_SHA256},\n {\"aes_256_gcm_sha_384\",              TLS_AES_256_GCM_SHA384},\n {\"chacha20_poly1305_sha_256\",        TLS_CHACHA20_POLY1305_SHA256},\n#endif\n#ifdef TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\n  /* AES CBC cipher suites in RFC 5246. Introduced in NSS release 3.20 */\n  {\"dhe_dss_aes_128_sha_256\",         TLS_DHE_DSS_WITH_AES_128_CBC_SHA256},\n  {\"dhe_dss_aes_256_sha_256\",         TLS_DHE_DSS_WITH_AES_256_CBC_SHA256},\n#endif\n#ifdef TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\n  /* Camellia cipher suites in RFC 4132/5932.\n     Introduced in NSS release 3.12 */\n  {\"dhe_rsa_camellia_128_sha\",        TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA},\n  {\"dhe_dss_camellia_128_sha\",        TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA},\n  {\"dhe_rsa_camellia_256_sha\",        TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA},\n  {\"dhe_dss_camellia_256_sha\",        TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA},\n  {\"rsa_camellia_128_sha\",            TLS_RSA_WITH_CAMELLIA_128_CBC_SHA},\n  {\"rsa_camellia_256_sha\",            TLS_RSA_WITH_CAMELLIA_256_CBC_SHA},\n#endif\n#ifdef TLS_RSA_WITH_SEED_CBC_SHA\n  /* SEED cipher suite in RFC 4162. Introduced in NSS release 3.12.3 */\n  {\"rsa_seed_sha\",                    TLS_RSA_WITH_SEED_CBC_SHA},\n#endif\n};\n\n#if defined(WIN32)\nstatic const char *pem_library = \"nsspem.dll\";\nstatic const char *trust_library = \"nssckbi.dll\";\n#elif defined(__APPLE__)\nstatic const char *pem_library = \"libnsspem.dylib\";\nstatic const char *trust_library = \"libnssckbi.dylib\";\n#else\nstatic const char *pem_library = \"libnsspem.so\";\nstatic const char *trust_library = \"libnssckbi.so\";\n#endif\n\nstatic SECMODModule *pem_module = NULL;\nstatic SECMODModule *trust_module = NULL;\n\n/* NSPR I/O layer we use to detect blocking direction during SSL handshake */\nstatic PRDescIdentity nspr_io_identity = PR_INVALID_IO_LAYER;\nstatic PRIOMethods nspr_io_methods;\n\nstatic const char *nss_error_to_name(PRErrorCode code)\n{\n  const char *name = PR_ErrorToName(code);\n  if(name)\n    return name;\n\n  return \"unknown error\";\n}\n\nstatic void nss_print_error_message(struct Curl_easy *data, PRUint32 err)\n{\n  failf(data, \"%s\", PR_ErrorToString(err, PR_LANGUAGE_I_DEFAULT));\n}\n\nstatic char *nss_sslver_to_name(PRUint16 nssver)\n{\n  switch(nssver) {\n  case SSL_LIBRARY_VERSION_2:\n    return strdup(\"SSLv2\");\n  case SSL_LIBRARY_VERSION_3_0:\n    return strdup(\"SSLv3\");\n  case SSL_LIBRARY_VERSION_TLS_1_0:\n    return strdup(\"TLSv1.0\");\n#ifdef SSL_LIBRARY_VERSION_TLS_1_1\n  case SSL_LIBRARY_VERSION_TLS_1_1:\n    return strdup(\"TLSv1.1\");\n#endif\n#ifdef SSL_LIBRARY_VERSION_TLS_1_2\n  case SSL_LIBRARY_VERSION_TLS_1_2:\n    return strdup(\"TLSv1.2\");\n#endif\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n  case SSL_LIBRARY_VERSION_TLS_1_3:\n    return strdup(\"TLSv1.3\");\n#endif\n  default:\n    return curl_maprintf(\"0x%04x\", nssver);\n  }\n}\n\nstatic SECStatus set_ciphers(struct Curl_easy *data, PRFileDesc * model,\n                             char *cipher_list)\n{\n  unsigned int i;\n  PRBool cipher_state[NUM_OF_CIPHERS];\n  PRBool found;\n  char *cipher;\n\n  /* use accessors to avoid dynamic linking issues after an update of NSS */\n  const PRUint16 num_implemented_ciphers = SSL_GetNumImplementedCiphers();\n  const PRUint16 *implemented_ciphers = SSL_GetImplementedCiphers();\n  if(!implemented_ciphers)\n    return SECFailure;\n\n  /* First disable all ciphers. This uses a different max value in case\n   * NSS adds more ciphers later we don't want them available by\n   * accident\n   */\n  for(i = 0; i < num_implemented_ciphers; i++) {\n    SSL_CipherPrefSet(model, implemented_ciphers[i], PR_FALSE);\n  }\n\n  /* Set every entry in our list to false */\n  for(i = 0; i < NUM_OF_CIPHERS; i++) {\n    cipher_state[i] = PR_FALSE;\n  }\n\n  cipher = cipher_list;\n\n  while(cipher_list && (cipher_list[0])) {\n    while((*cipher) && (ISSPACE(*cipher)))\n      ++cipher;\n\n    cipher_list = strpbrk(cipher, \":, \");\n    if(cipher_list) {\n      *cipher_list++ = '\\0';\n    }\n\n    found = PR_FALSE;\n\n    for(i = 0; i<NUM_OF_CIPHERS; i++) {\n      if(strcasecompare(cipher, cipherlist[i].name)) {\n        cipher_state[i] = PR_TRUE;\n        found = PR_TRUE;\n        break;\n      }\n    }\n\n    if(found == PR_FALSE) {\n      failf(data, \"Unknown cipher in list: %s\", cipher);\n      return SECFailure;\n    }\n\n    if(cipher_list) {\n      cipher = cipher_list;\n    }\n  }\n\n  /* Finally actually enable the selected ciphers */\n  for(i = 0; i<NUM_OF_CIPHERS; i++) {\n    if(!cipher_state[i])\n      continue;\n\n    if(SSL_CipherPrefSet(model, cipherlist[i].num, PR_TRUE) != SECSuccess) {\n      failf(data, \"cipher-suite not supported by NSS: %s\", cipherlist[i].name);\n      return SECFailure;\n    }\n  }\n\n  return SECSuccess;\n}\n\n/*\n * Return true if at least one cipher-suite is enabled. Used to determine\n * if we need to call NSS_SetDomesticPolicy() to enable the default ciphers.\n */\nstatic bool any_cipher_enabled(void)\n{\n  unsigned int i;\n\n  for(i = 0; i<NUM_OF_CIPHERS; i++) {\n    PRInt32 policy = 0;\n    SSL_CipherPolicyGet(cipherlist[i].num, &policy);\n    if(policy)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n/*\n * Determine whether the nickname passed in is a filename that needs to\n * be loaded as a PEM or a regular NSS nickname.\n *\n * returns 1 for a file\n * returns 0 for not a file (NSS nickname)\n */\nstatic int is_file(const char *filename)\n{\n  struct_stat st;\n\n  if(!filename)\n    return 0;\n\n  if(stat(filename, &st) == 0)\n    if(S_ISREG(st.st_mode) || S_ISFIFO(st.st_mode) || S_ISCHR(st.st_mode))\n      return 1;\n\n  return 0;\n}\n\n/* Check if the given string is filename or nickname of a certificate.  If the\n * given string is recognized as filename, return NULL.  If the given string is\n * recognized as nickname, return a duplicated string.  The returned string\n * should be later deallocated using free().  If the OOM failure occurs, we\n * return NULL, too.\n */\nstatic char *dup_nickname(struct Curl_easy *data, const char *str)\n{\n  const char *n;\n\n  if(!is_file(str))\n    /* no such file exists, use the string as nickname */\n    return strdup(str);\n\n  /* search the first slash; we require at least one slash in a file name */\n  n = strchr(str, '/');\n  if(!n) {\n    infof(data, \"warning: certificate file name \\\"%s\\\" handled as nickname; \"\n          \"please use \\\"./%s\\\" to force file name\\n\", str, str);\n    return strdup(str);\n  }\n\n  /* we'll use the PEM reader to read the certificate from file */\n  return NULL;\n}\n\n/* Lock/unlock wrapper for PK11_FindSlotByName() to work around race condition\n * in nssSlot_IsTokenPresent() causing spurious SEC_ERROR_NO_TOKEN.  For more\n * details, go to <https://bugzilla.mozilla.org/1297397>.\n */\nstatic PK11SlotInfo* nss_find_slot_by_name(const char *slot_name)\n{\n  PK11SlotInfo *slot;\n  PR_Lock(nss_findslot_lock);\n  slot = PK11_FindSlotByName(slot_name);\n  PR_Unlock(nss_findslot_lock);\n  return slot;\n}\n\n/* wrap 'ptr' as list node and tail-insert into 'list' */\nstatic CURLcode insert_wrapped_ptr(struct Curl_llist *list, void *ptr)\n{\n  struct ptr_list_wrap *wrap = malloc(sizeof(*wrap));\n  if(!wrap)\n    return CURLE_OUT_OF_MEMORY;\n\n  wrap->ptr = ptr;\n  Curl_llist_insert_next(list, list->tail, wrap, &wrap->node);\n  return CURLE_OK;\n}\n\n/* Call PK11_CreateGenericObject() with the given obj_class and filename.  If\n * the call succeeds, append the object handle to the list of objects so that\n * the object can be destroyed in nss_close(). */\nstatic CURLcode nss_create_object(struct ssl_connect_data *connssl,\n                                  CK_OBJECT_CLASS obj_class,\n                                  const char *filename, bool cacert)\n{\n  PK11SlotInfo *slot;\n  PK11GenericObject *obj;\n  CK_BBOOL cktrue = CK_TRUE;\n  CK_BBOOL ckfalse = CK_FALSE;\n  CK_ATTRIBUTE attrs[/* max count of attributes */ 4];\n  int attr_cnt = 0;\n  CURLcode result = (cacert)\n    ? CURLE_SSL_CACERT_BADFILE\n    : CURLE_SSL_CERTPROBLEM;\n\n  const int slot_id = (cacert) ? 0 : 1;\n  char *slot_name = aprintf(\"PEM Token #%d\", slot_id);\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!slot_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  slot = nss_find_slot_by_name(slot_name);\n  free(slot_name);\n  if(!slot)\n    return result;\n\n  PK11_SETATTRS(attrs, attr_cnt, CKA_CLASS, &obj_class, sizeof(obj_class));\n  PK11_SETATTRS(attrs, attr_cnt, CKA_TOKEN, &cktrue, sizeof(CK_BBOOL));\n  PK11_SETATTRS(attrs, attr_cnt, CKA_LABEL, (unsigned char *)filename,\n                (CK_ULONG)strlen(filename) + 1);\n\n  if(CKO_CERTIFICATE == obj_class) {\n    CK_BBOOL *pval = (cacert) ? (&cktrue) : (&ckfalse);\n    PK11_SETATTRS(attrs, attr_cnt, CKA_TRUST, pval, sizeof(*pval));\n  }\n\n  /* PK11_CreateManagedGenericObject() was introduced in NSS 3.34 because\n   * PK11_DestroyGenericObject() does not release resources allocated by\n   * PK11_CreateGenericObject() early enough.  */\n  obj =\n#ifdef HAVE_PK11_CREATEMANAGEDGENERICOBJECT\n    PK11_CreateManagedGenericObject\n#else\n    PK11_CreateGenericObject\n#endif\n    (slot, attrs, attr_cnt, PR_FALSE);\n\n  PK11_FreeSlot(slot);\n  if(!obj)\n    return result;\n\n  if(insert_wrapped_ptr(&backend->obj_list, obj) != CURLE_OK) {\n    PK11_DestroyGenericObject(obj);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(!cacert && CKO_CERTIFICATE == obj_class)\n    /* store reference to a client certificate */\n    backend->obj_clicert = obj;\n\n  return CURLE_OK;\n}\n\n/* Destroy the NSS object whose handle is given by ptr.  This function is\n * a callback of Curl_llist_alloc() used by Curl_llist_destroy() to destroy\n * NSS objects in nss_close() */\nstatic void nss_destroy_object(void *user, void *ptr)\n{\n  struct ptr_list_wrap *wrap = (struct ptr_list_wrap *) ptr;\n  PK11GenericObject *obj = (PK11GenericObject *) wrap->ptr;\n  (void) user;\n  PK11_DestroyGenericObject(obj);\n  free(wrap);\n}\n\n/* same as nss_destroy_object() but for CRL items */\nstatic void nss_destroy_crl_item(void *user, void *ptr)\n{\n  struct ptr_list_wrap *wrap = (struct ptr_list_wrap *) ptr;\n  SECItem *crl_der = (SECItem *) wrap->ptr;\n  (void) user;\n  SECITEM_FreeItem(crl_der, PR_TRUE);\n  free(wrap);\n}\n\nstatic CURLcode nss_load_cert(struct ssl_connect_data *ssl,\n                              const char *filename, PRBool cacert)\n{\n  CURLcode result = (cacert)\n    ? CURLE_SSL_CACERT_BADFILE\n    : CURLE_SSL_CERTPROBLEM;\n\n  /* libnsspem.so leaks memory if the requested file does not exist.  For more\n   * details, go to <https://bugzilla.redhat.com/734760>. */\n  if(is_file(filename))\n    result = nss_create_object(ssl, CKO_CERTIFICATE, filename, cacert);\n\n  if(!result && !cacert) {\n    /* we have successfully loaded a client certificate */\n    char *nickname = NULL;\n    char *n = strrchr(filename, '/');\n    if(n)\n      n++;\n\n    /* The following undocumented magic helps to avoid a SIGSEGV on call\n     * of PK11_ReadRawAttribute() from SelectClientCert() when using an\n     * immature version of libnsspem.so.  For more details, go to\n     * <https://bugzilla.redhat.com/733685>. */\n    nickname = aprintf(\"PEM Token #1:%s\", n);\n    if(nickname) {\n      CERTCertificate *cert = PK11_FindCertFromNickname(nickname, NULL);\n      if(cert)\n        CERT_DestroyCertificate(cert);\n\n      free(nickname);\n    }\n  }\n\n  return result;\n}\n\n/* add given CRL to cache if it is not already there */\nstatic CURLcode nss_cache_crl(SECItem *crl_der)\n{\n  CERTCertDBHandle *db = CERT_GetDefaultCertDB();\n  CERTSignedCrl *crl = SEC_FindCrlByDERCert(db, crl_der, 0);\n  if(crl) {\n    /* CRL already cached */\n    SEC_DestroyCrl(crl);\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    return CURLE_OK;\n  }\n\n  /* acquire lock before call of CERT_CacheCRL() and accessing nss_crl_list */\n  PR_Lock(nss_crllock);\n\n  if(SECSuccess != CERT_CacheCRL(db, crl_der)) {\n    /* unable to cache CRL */\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_SSL_CRL_BADFILE;\n  }\n\n  /* store the CRL item so that we can free it in nss_cleanup() */\n  if(insert_wrapped_ptr(&nss_crl_list, crl_der) != CURLE_OK) {\n    if(SECSuccess == CERT_UncacheCRL(db, crl_der))\n      SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  /* we need to clear session cache, so that the CRL could take effect */\n  SSL_ClearSessionCache();\n  PR_Unlock(nss_crllock);\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_load_crl(const char *crlfilename)\n{\n  PRFileDesc *infile;\n  PRFileInfo  info;\n  SECItem filedata = { 0, NULL, 0 };\n  SECItem *crl_der = NULL;\n  char *body;\n\n  infile = PR_Open(crlfilename, PR_RDONLY, 0);\n  if(!infile)\n    return CURLE_SSL_CRL_BADFILE;\n\n  if(PR_SUCCESS != PR_GetOpenFileInfo(infile, &info))\n    goto fail;\n\n  if(!SECITEM_AllocItem(NULL, &filedata, info.size + /* zero ended */ 1))\n    goto fail;\n\n  if(info.size != PR_Read(infile, filedata.data, info.size))\n    goto fail;\n\n  crl_der = SECITEM_AllocItem(NULL, NULL, 0U);\n  if(!crl_der)\n    goto fail;\n\n  /* place a trailing zero right after the visible data */\n  body = (char *)filedata.data;\n  body[--filedata.len] = '\\0';\n\n  body = strstr(body, \"-----BEGIN\");\n  if(body) {\n    /* assume ASCII */\n    char *trailer;\n    char *begin = PORT_Strchr(body, '\\n');\n    if(!begin)\n      begin = PORT_Strchr(body, '\\r');\n    if(!begin)\n      goto fail;\n\n    trailer = strstr(++begin, \"-----END\");\n    if(!trailer)\n      goto fail;\n\n    /* retrieve DER from ASCII */\n    *trailer = '\\0';\n    if(ATOB_ConvertAsciiToItem(crl_der, begin))\n      goto fail;\n\n    SECITEM_FreeItem(&filedata, PR_FALSE);\n  }\n  else\n    /* assume DER */\n    *crl_der = filedata;\n\n  PR_Close(infile);\n  return nss_cache_crl(crl_der);\n\nfail:\n  PR_Close(infile);\n  SECITEM_FreeItem(crl_der, PR_TRUE);\n  SECITEM_FreeItem(&filedata, PR_FALSE);\n  return CURLE_SSL_CRL_BADFILE;\n}\n\nstatic CURLcode nss_load_key(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, char *key_file)\n{\n  PK11SlotInfo *slot, *tmp;\n  SECStatus status;\n  CURLcode result;\n  struct ssl_connect_data *ssl = conn->ssl;\n\n  (void)sockindex; /* unused */\n\n  result = nss_create_object(ssl, CKO_PRIVATE_KEY, key_file, FALSE);\n  if(result) {\n    PR_SetError(SEC_ERROR_BAD_KEY, 0);\n    return result;\n  }\n\n  slot = nss_find_slot_by_name(\"PEM Token #1\");\n  if(!slot)\n    return CURLE_SSL_CERTPROBLEM;\n\n  /* This will force the token to be seen as re-inserted */\n  tmp = SECMOD_WaitForAnyTokenEvent(pem_module, 0, 0);\n  if(tmp)\n    PK11_FreeSlot(tmp);\n  if(!PK11_IsPresent(slot)) {\n    PK11_FreeSlot(slot);\n    return CURLE_SSL_CERTPROBLEM;\n  }\n\n  status = PK11_Authenticate(slot, PR_TRUE, SSL_SET_OPTION(key_passwd));\n  PK11_FreeSlot(slot);\n\n  return (SECSuccess == status) ? CURLE_OK : CURLE_SSL_CERTPROBLEM;\n}\n\nstatic int display_error(struct Curl_easy *data, PRInt32 err,\n                         const char *filename)\n{\n  switch(err) {\n  case SEC_ERROR_BAD_PASSWORD:\n    failf(data, \"Unable to load client key: Incorrect password\");\n    return 1;\n  case SEC_ERROR_UNKNOWN_CERT:\n    failf(data, \"Unable to load certificate %s\", filename);\n    return 1;\n  default:\n    break;\n  }\n  return 0; /* The caller will print a generic error */\n}\n\nstatic CURLcode cert_stuff(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex, char *cert_file, char *key_file)\n{\n  CURLcode result;\n\n  if(cert_file) {\n    result = nss_load_cert(&conn->ssl[sockindex], cert_file, PR_FALSE);\n    if(result) {\n      const PRErrorCode err = PR_GetError();\n      if(!display_error(data, err, cert_file)) {\n        const char *err_name = nss_error_to_name(err);\n        failf(data, \"unable to load client cert: %d (%s)\", err, err_name);\n      }\n\n      return result;\n    }\n  }\n\n  if(key_file || (is_file(cert_file))) {\n    if(key_file)\n      result = nss_load_key(data, conn, sockindex, key_file);\n    else\n      /* In case the cert file also has the key */\n      result = nss_load_key(data, conn, sockindex, cert_file);\n    if(result) {\n      const PRErrorCode err = PR_GetError();\n      if(!display_error(data, err, key_file)) {\n        const char *err_name = nss_error_to_name(err);\n        failf(data, \"unable to load client key: %d (%s)\", err, err_name);\n      }\n\n      return result;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic char *nss_get_password(PK11SlotInfo *slot, PRBool retry, void *arg)\n{\n  (void)slot; /* unused */\n\n  if(retry || NULL == arg)\n    return NULL;\n  else\n    return (char *)PORT_Strdup((char *)arg);\n}\n\n/* bypass the default SSL_AuthCertificate() hook in case we do not want to\n * verify peer */\nstatic SECStatus nss_auth_cert_hook(void *arg, PRFileDesc *fd, PRBool checksig,\n                                    PRBool isServer)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    SECStatus cacheResult;\n\n    const SECItemArray *csa = SSL_PeerStapledOCSPResponses(fd);\n    if(!csa) {\n      failf(data, \"Invalid OCSP response\");\n      return SECFailure;\n    }\n\n    if(csa->len == 0) {\n      failf(data, \"No OCSP response received\");\n      return SECFailure;\n    }\n\n    cacheResult = CERT_CacheOCSPResponseFromSideChannel(\n      CERT_GetDefaultCertDB(), SSL_PeerCertificate(fd),\n      PR_Now(), &csa->items[0], arg\n    );\n\n    if(cacheResult != SECSuccess) {\n      failf(data, \"Invalid OCSP response\");\n      return cacheResult;\n    }\n  }\n#endif\n\n  if(!SSL_CONN_CONFIG(verifypeer)) {\n    infof(data, \"skipping SSL peer certificate verification\\n\");\n    return SECSuccess;\n  }\n\n  return SSL_AuthCertificate(CERT_GetDefaultCertDB(), fd, checksig, isServer);\n}\n\n/**\n * Inform the application that the handshake is complete.\n */\nstatic void HandshakeCallback(PRFileDesc *sock, void *arg)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  unsigned int buflenmax = 50;\n  unsigned char buf[50];\n  unsigned int buflen;\n  SSLNextProtoState state;\n\n  if(!conn->bits.tls_enable_npn && !conn->bits.tls_enable_alpn) {\n    return;\n  }\n\n  if(SSL_GetNextProto(sock, &state, buf, &buflen, buflenmax) == SECSuccess) {\n\n    switch(state) {\n#if NSSVERNUM >= 0x031a00 /* 3.26.0 */\n    /* used by NSS internally to implement 0-RTT */\n    case SSL_NEXT_PROTO_EARLY_VALUE:\n      /* fall through! */\n#endif\n    case SSL_NEXT_PROTO_NO_SUPPORT:\n    case SSL_NEXT_PROTO_NO_OVERLAP:\n      infof(data, \"ALPN/NPN, server did not agree to a protocol\\n\");\n      return;\n#ifdef SSL_ENABLE_ALPN\n    case SSL_NEXT_PROTO_SELECTED:\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", buflen, buf);\n      break;\n#endif\n    case SSL_NEXT_PROTO_NEGOTIATED:\n      infof(data, \"NPN, server accepted to use %.*s\\n\", buflen, buf);\n      break;\n    }\n\n#ifdef USE_NGHTTP2\n    if(buflen == ALPN_H2_LENGTH &&\n       !memcmp(ALPN_H2, buf, ALPN_H2_LENGTH)) {\n      conn->negnpn = CURL_HTTP_VERSION_2;\n    }\n    else\n#endif\n    if(buflen == ALPN_HTTP_1_1_LENGTH &&\n       !memcmp(ALPN_HTTP_1_1, buf, ALPN_HTTP_1_1_LENGTH)) {\n      conn->negnpn = CURL_HTTP_VERSION_1_1;\n    }\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n}\n\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\nstatic SECStatus CanFalseStartCallback(PRFileDesc *sock, void *client_data,\n                                       PRBool *canFalseStart)\n{\n  struct Curl_easy *data = (struct Curl_easy *)client_data;\n\n  SSLChannelInfo channelInfo;\n  SSLCipherSuiteInfo cipherInfo;\n\n  SECStatus rv;\n  PRBool negotiatedExtension;\n\n  *canFalseStart = PR_FALSE;\n\n  if(SSL_GetChannelInfo(sock, &channelInfo, sizeof(channelInfo)) != SECSuccess)\n    return SECFailure;\n\n  if(SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherInfo,\n                            sizeof(cipherInfo)) != SECSuccess)\n    return SECFailure;\n\n  /* Prevent version downgrade attacks from TLS 1.2, and avoid False Start for\n   * TLS 1.3 and later. See https://bugzilla.mozilla.org/show_bug.cgi?id=861310\n   */\n  if(channelInfo.protocolVersion != SSL_LIBRARY_VERSION_TLS_1_2)\n    goto end;\n\n  /* Only allow ECDHE key exchange algorithm.\n   * See https://bugzilla.mozilla.org/show_bug.cgi?id=952863 */\n  if(cipherInfo.keaType != ssl_kea_ecdh)\n    goto end;\n\n  /* Prevent downgrade attacks on the symmetric cipher. We do not allow CBC\n   * mode due to BEAST, POODLE, and other attacks on the MAC-then-Encrypt\n   * design. See https://bugzilla.mozilla.org/show_bug.cgi?id=1109766 */\n  if(cipherInfo.symCipher != ssl_calg_aes_gcm)\n    goto end;\n\n  /* Enforce ALPN or NPN to do False Start, as an indicator of server\n   * compatibility. */\n  rv = SSL_HandshakeNegotiatedExtension(sock, ssl_app_layer_protocol_xtn,\n                                        &negotiatedExtension);\n  if(rv != SECSuccess || !negotiatedExtension) {\n    rv = SSL_HandshakeNegotiatedExtension(sock, ssl_next_proto_nego_xtn,\n                                          &negotiatedExtension);\n  }\n\n  if(rv != SECSuccess || !negotiatedExtension)\n    goto end;\n\n  *canFalseStart = PR_TRUE;\n\n  infof(data, \"Trying TLS False Start\\n\");\n\nend:\n  return SECSuccess;\n}\n#endif\n\nstatic void display_cert_info(struct Curl_easy *data,\n                              CERTCertificate *cert)\n{\n  char *subject, *issuer, *common_name;\n  PRExplodedTime printableTime;\n  char timeString[256];\n  PRTime notBefore, notAfter;\n\n  subject = CERT_NameToAscii(&cert->subject);\n  issuer = CERT_NameToAscii(&cert->issuer);\n  common_name = CERT_GetCommonName(&cert->subject);\n  infof(data, \"\\tsubject: %s\\n\", subject);\n\n  CERT_GetCertTimes(cert, &notBefore, &notAfter);\n  PR_ExplodeTime(notBefore, PR_GMTParameters, &printableTime);\n  PR_FormatTime(timeString, 256, \"%b %d %H:%M:%S %Y GMT\", &printableTime);\n  infof(data, \"\\tstart date: %s\\n\", timeString);\n  PR_ExplodeTime(notAfter, PR_GMTParameters, &printableTime);\n  PR_FormatTime(timeString, 256, \"%b %d %H:%M:%S %Y GMT\", &printableTime);\n  infof(data, \"\\texpire date: %s\\n\", timeString);\n  infof(data, \"\\tcommon name: %s\\n\", common_name);\n  infof(data, \"\\tissuer: %s\\n\", issuer);\n\n  PR_Free(subject);\n  PR_Free(issuer);\n  PR_Free(common_name);\n}\n\nstatic CURLcode display_conn_info(struct Curl_easy *data, PRFileDesc *sock)\n{\n  CURLcode result = CURLE_OK;\n  SSLChannelInfo channel;\n  SSLCipherSuiteInfo suite;\n  CERTCertificate *cert;\n  CERTCertificate *cert2;\n  CERTCertificate *cert3;\n  PRTime now;\n\n  if(SSL_GetChannelInfo(sock, &channel, sizeof(channel)) ==\n     SECSuccess && channel.length == sizeof(channel) &&\n     channel.cipherSuite) {\n    if(SSL_GetCipherSuiteInfo(channel.cipherSuite,\n                              &suite, sizeof(suite)) == SECSuccess) {\n      infof(data, \"SSL connection using %s\\n\", suite.cipherSuiteName);\n    }\n  }\n\n  cert = SSL_PeerCertificate(sock);\n  if(cert) {\n    infof(data, \"Server certificate:\\n\");\n\n    if(!data->set.ssl.certinfo) {\n      display_cert_info(data, cert);\n      CERT_DestroyCertificate(cert);\n    }\n    else {\n      /* Count certificates in chain. */\n      int i = 1;\n      now = PR_Now();\n      if(!cert->isRoot) {\n        cert2 = CERT_FindCertIssuer(cert, now, certUsageSSLCA);\n        while(cert2) {\n          i++;\n          if(cert2->isRoot) {\n            CERT_DestroyCertificate(cert2);\n            break;\n          }\n          cert3 = CERT_FindCertIssuer(cert2, now, certUsageSSLCA);\n          CERT_DestroyCertificate(cert2);\n          cert2 = cert3;\n        }\n      }\n\n      result = Curl_ssl_init_certinfo(data, i);\n      if(!result) {\n        for(i = 0; cert; cert = cert2) {\n          result = Curl_extract_certinfo(data, i++, (char *)cert->derCert.data,\n                                         (char *)cert->derCert.data +\n                                                 cert->derCert.len);\n          if(result)\n            break;\n\n          if(cert->isRoot) {\n            CERT_DestroyCertificate(cert);\n            break;\n          }\n\n          cert2 = CERT_FindCertIssuer(cert, now, certUsageSSLCA);\n          CERT_DestroyCertificate(cert);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nstatic SECStatus BadCertHandler(void *arg, PRFileDesc *sock)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  PRErrorCode err = PR_GetError();\n  CERTCertificate *cert;\n\n  /* remember the cert verification result */\n  SSL_SET_OPTION_LVALUE(certverifyresult) = err;\n\n  if(err == SSL_ERROR_BAD_CERT_DOMAIN && !SSL_CONN_CONFIG(verifyhost))\n    /* we are asked not to verify the host name */\n    return SECSuccess;\n\n  /* print only info about the cert, the error is printed off the callback */\n  cert = SSL_PeerCertificate(sock);\n  if(cert) {\n    infof(data, \"Server certificate:\\n\");\n    display_cert_info(data, cert);\n    CERT_DestroyCertificate(cert);\n  }\n\n  return SECFailure;\n}\n\n/**\n *\n * Check that the Peer certificate's issuer certificate matches the one found\n * by issuer_nickname.  This is not exactly the way OpenSSL and GNU TLS do the\n * issuer check, so we provide comments that mimic the OpenSSL\n * X509_check_issued function (in x509v3/v3_purp.c)\n */\nstatic SECStatus check_issuer_cert(PRFileDesc *sock,\n                                   char *issuer_nickname)\n{\n  CERTCertificate *cert, *cert_issuer, *issuer;\n  SECStatus res = SECSuccess;\n  void *proto_win = NULL;\n\n  cert = SSL_PeerCertificate(sock);\n  cert_issuer = CERT_FindCertIssuer(cert, PR_Now(), certUsageObjectSigner);\n\n  proto_win = SSL_RevealPinArg(sock);\n  issuer = PK11_FindCertFromNickname(issuer_nickname, proto_win);\n\n  if((!cert_issuer) || (!issuer))\n    res = SECFailure;\n  else if(SECITEM_CompareItem(&cert_issuer->derCert,\n                              &issuer->derCert) != SECEqual)\n    res = SECFailure;\n\n  CERT_DestroyCertificate(cert);\n  CERT_DestroyCertificate(issuer);\n  CERT_DestroyCertificate(cert_issuer);\n  return res;\n}\n\nstatic CURLcode cmp_peer_pubkey(struct ssl_connect_data *connssl,\n                                const char *pinnedpubkey)\n{\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->data;\n  CERTCertificate *cert;\n\n  if(!pinnedpubkey)\n    /* no pinned public key specified */\n    return CURLE_OK;\n\n  /* get peer certificate */\n  cert = SSL_PeerCertificate(backend->handle);\n  if(cert) {\n    /* extract public key from peer certificate */\n    SECKEYPublicKey *pubkey = CERT_ExtractPublicKey(cert);\n    if(pubkey) {\n      /* encode the public key as DER */\n      SECItem *cert_der = PK11_DEREncodePublicKey(pubkey);\n      if(cert_der) {\n        /* compare the public key with the pinned public key */\n        result = Curl_pin_peer_pubkey(data, pinnedpubkey, cert_der->data,\n                                      cert_der->len);\n        SECITEM_FreeItem(cert_der, PR_TRUE);\n      }\n      SECKEY_DestroyPublicKey(pubkey);\n    }\n    CERT_DestroyCertificate(cert);\n  }\n\n  /* report the resulting status */\n  switch(result) {\n  case CURLE_OK:\n    infof(data, \"pinned public key verified successfully!\\n\");\n    break;\n  case CURLE_SSL_PINNEDPUBKEYNOTMATCH:\n    failf(data, \"failed to verify pinned public key\");\n    break;\n  default:\n    /* OOM, etc. */\n    break;\n  }\n\n  return result;\n}\n\n/**\n *\n * Callback to pick the SSL client certificate.\n */\nstatic SECStatus SelectClientCert(void *arg, PRFileDesc *sock,\n                                  struct CERTDistNamesStr *caNames,\n                                  struct CERTCertificateStr **pRetCert,\n                                  struct SECKEYPrivateKeyStr **pRetKey)\n{\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg;\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->data;\n  const char *nickname = backend->client_nickname;\n  static const char pem_slotname[] = \"PEM Token #1\";\n\n  if(backend->obj_clicert) {\n    /* use the cert/key provided by PEM reader */\n    SECItem cert_der = { 0, NULL, 0 };\n    void *proto_win = SSL_RevealPinArg(sock);\n    struct CERTCertificateStr *cert;\n    struct SECKEYPrivateKeyStr *key;\n\n    PK11SlotInfo *slot = nss_find_slot_by_name(pem_slotname);\n    if(NULL == slot) {\n      failf(data, \"NSS: PK11 slot not found: %s\", pem_slotname);\n      return SECFailure;\n    }\n\n    if(PK11_ReadRawAttribute(PK11_TypeGeneric, backend->obj_clicert, CKA_VALUE,\n                             &cert_der) != SECSuccess) {\n      failf(data, \"NSS: CKA_VALUE not found in PK11 generic object\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    cert = PK11_FindCertFromDERCertItem(slot, &cert_der, proto_win);\n    SECITEM_FreeItem(&cert_der, PR_FALSE);\n    if(NULL == cert) {\n      failf(data, \"NSS: client certificate from file not found\");\n      PK11_FreeSlot(slot);\n      return SECFailure;\n    }\n\n    key = PK11_FindPrivateKeyFromCert(slot, cert, NULL);\n    PK11_FreeSlot(slot);\n    if(NULL == key) {\n      failf(data, \"NSS: private key from file not found\");\n      CERT_DestroyCertificate(cert);\n      return SECFailure;\n    }\n\n    infof(data, \"NSS: client certificate from file\\n\");\n    display_cert_info(data, cert);\n\n    *pRetCert = cert;\n    *pRetKey = key;\n    return SECSuccess;\n  }\n\n  /* use the default NSS hook */\n  if(SECSuccess != NSS_GetClientAuthData((void *)nickname, sock, caNames,\n                                          pRetCert, pRetKey)\n      || NULL == *pRetCert) {\n\n    if(NULL == nickname)\n      failf(data, \"NSS: client certificate not found (nickname not \"\n            \"specified)\");\n    else\n      failf(data, \"NSS: client certificate not found: %s\", nickname);\n\n    return SECFailure;\n  }\n\n  /* get certificate nickname if any */\n  nickname = (*pRetCert)->nickname;\n  if(NULL == nickname)\n    nickname = \"[unknown]\";\n\n  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) {\n    failf(data, \"NSS: refusing previously loaded certificate from file: %s\",\n          nickname);\n    return SECFailure;\n  }\n\n  if(NULL == *pRetKey) {\n    failf(data, \"NSS: private key not found for certificate: %s\", nickname);\n    return SECFailure;\n  }\n\n  infof(data, \"NSS: using client certificate: %s\\n\", nickname);\n  display_cert_info(data, *pRetCert);\n  return SECSuccess;\n}\n\n/* update blocking direction in case of PR_WOULD_BLOCK_ERROR */\nstatic void nss_update_connecting_state(ssl_connect_state state, void *secret)\n{\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)secret;\n  if(PR_GetError() != PR_WOULD_BLOCK_ERROR)\n    /* an unrelated error is passing by */\n    return;\n\n  switch(connssl->connecting_state) {\n  case ssl_connect_2:\n  case ssl_connect_2_reading:\n  case ssl_connect_2_writing:\n    break;\n  default:\n    /* we are not called from an SSL handshake */\n    return;\n  }\n\n  /* update the state accordingly */\n  connssl->connecting_state = state;\n}\n\n/* recv() wrapper we use to detect blocking direction during SSL handshake */\nstatic PRInt32 nspr_io_recv(PRFileDesc *fd, void *buf, PRInt32 amount,\n                            PRIntn flags, PRIntervalTime timeout)\n{\n  const PRRecvFN recv_fn = fd->lower->methods->recv;\n  const PRInt32 rv = recv_fn(fd->lower, buf, amount, flags, timeout);\n  if(rv < 0)\n    /* check for PR_WOULD_BLOCK_ERROR and update blocking direction */\n    nss_update_connecting_state(ssl_connect_2_reading, fd->secret);\n  return rv;\n}\n\n/* send() wrapper we use to detect blocking direction during SSL handshake */\nstatic PRInt32 nspr_io_send(PRFileDesc *fd, const void *buf, PRInt32 amount,\n                            PRIntn flags, PRIntervalTime timeout)\n{\n  const PRSendFN send_fn = fd->lower->methods->send;\n  const PRInt32 rv = send_fn(fd->lower, buf, amount, flags, timeout);\n  if(rv < 0)\n    /* check for PR_WOULD_BLOCK_ERROR and update blocking direction */\n    nss_update_connecting_state(ssl_connect_2_writing, fd->secret);\n  return rv;\n}\n\n/* close() wrapper to avoid assertion failure due to fd->secret != NULL */\nstatic PRStatus nspr_io_close(PRFileDesc *fd)\n{\n  const PRCloseFN close_fn = PR_GetDefaultIOMethods()->close;\n  fd->secret = NULL;\n  return close_fn(fd);\n}\n\n/* load a PKCS #11 module */\nstatic CURLcode nss_load_module(SECMODModule **pmod, const char *library,\n                                const char *name)\n{\n  char *config_string;\n  SECMODModule *module = *pmod;\n  if(module)\n    /* already loaded */\n    return CURLE_OK;\n\n  config_string = aprintf(\"library=%s name=%s\", library, name);\n  if(!config_string)\n    return CURLE_OUT_OF_MEMORY;\n\n  module = SECMOD_LoadUserModule(config_string, NULL, PR_FALSE);\n  free(config_string);\n\n  if(module && module->loaded) {\n    /* loaded successfully */\n    *pmod = module;\n    return CURLE_OK;\n  }\n\n  if(module)\n    SECMOD_DestroyModule(module);\n  return CURLE_FAILED_INIT;\n}\n\n/* unload a PKCS #11 module */\nstatic void nss_unload_module(SECMODModule **pmod)\n{\n  SECMODModule *module = *pmod;\n  if(!module)\n    /* not loaded */\n    return;\n\n  if(SECMOD_UnloadUserModule(module) != SECSuccess)\n    /* unload failed */\n    return;\n\n  SECMOD_DestroyModule(module);\n  *pmod = NULL;\n}\n\n/* data might be NULL */\nstatic CURLcode nss_init_core(struct Curl_easy *data, const char *cert_dir)\n{\n  NSSInitParameters initparams;\n  PRErrorCode err;\n  const char *err_name;\n\n  if(nss_context != NULL)\n    return CURLE_OK;\n\n  memset((void *) &initparams, '\\0', sizeof(initparams));\n  initparams.length = sizeof(initparams);\n\n  if(cert_dir) {\n    char *certpath = aprintf(\"sql:%s\", cert_dir);\n    if(!certpath)\n      return CURLE_OUT_OF_MEMORY;\n\n    infof(data, \"Initializing NSS with certpath: %s\\n\", certpath);\n    nss_context = NSS_InitContext(certpath, \"\", \"\", \"\", &initparams,\n                                  NSS_INIT_READONLY | NSS_INIT_PK11RELOAD);\n    free(certpath);\n\n    if(nss_context != NULL)\n      return CURLE_OK;\n\n    err = PR_GetError();\n    err_name = nss_error_to_name(err);\n    infof(data, \"Unable to initialize NSS database: %d (%s)\\n\", err, err_name);\n  }\n\n  infof(data, \"Initializing NSS with certpath: none\\n\");\n  nss_context = NSS_InitContext(\"\", \"\", \"\", \"\", &initparams, NSS_INIT_READONLY\n         | NSS_INIT_NOCERTDB   | NSS_INIT_NOMODDB       | NSS_INIT_FORCEOPEN\n         | NSS_INIT_NOROOTINIT | NSS_INIT_OPTIMIZESPACE | NSS_INIT_PK11RELOAD);\n  if(nss_context != NULL)\n    return CURLE_OK;\n\n  err = PR_GetError();\n  err_name = nss_error_to_name(err);\n  failf(data, \"Unable to initialize NSS: %d (%s)\", err, err_name);\n  return CURLE_SSL_CACERT_BADFILE;\n}\n\n/* data might be NULL */\nstatic CURLcode nss_setup(struct Curl_easy *data)\n{\n  char *cert_dir;\n  struct_stat st;\n  CURLcode result;\n\n  if(initialized)\n    return CURLE_OK;\n\n  /* list of all CRL items we need to destroy in nss_cleanup() */\n  Curl_llist_init(&nss_crl_list, nss_destroy_crl_item);\n\n  /* First we check if $SSL_DIR points to a valid dir */\n  cert_dir = getenv(\"SSL_DIR\");\n  if(cert_dir) {\n    if((stat(cert_dir, &st) != 0) ||\n        (!S_ISDIR(st.st_mode))) {\n      cert_dir = NULL;\n    }\n  }\n\n  /* Now we check if the default location is a valid dir */\n  if(!cert_dir) {\n    if((stat(SSL_DIR, &st) == 0) &&\n        (S_ISDIR(st.st_mode))) {\n      cert_dir = (char *)SSL_DIR;\n    }\n  }\n\n  if(nspr_io_identity == PR_INVALID_IO_LAYER) {\n    /* allocate an identity for our own NSPR I/O layer */\n    nspr_io_identity = PR_GetUniqueIdentity(\"libcurl\");\n    if(nspr_io_identity == PR_INVALID_IO_LAYER)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* the default methods just call down to the lower I/O layer */\n    memcpy(&nspr_io_methods, PR_GetDefaultIOMethods(),\n           sizeof(nspr_io_methods));\n\n    /* override certain methods in the table by our wrappers */\n    nspr_io_methods.recv  = nspr_io_recv;\n    nspr_io_methods.send  = nspr_io_send;\n    nspr_io_methods.close = nspr_io_close;\n  }\n\n  result = nss_init_core(data, cert_dir);\n  if(result)\n    return result;\n\n  if(!any_cipher_enabled())\n    NSS_SetDomesticPolicy();\n\n  initialized = 1;\n\n  return CURLE_OK;\n}\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nstatic int nss_init(void)\n{\n  /* curl_global_init() is not thread-safe so this test is ok */\n  if(!nss_initlock) {\n    PR_Init(PR_USER_THREAD, PR_PRIORITY_NORMAL, 0);\n    nss_initlock = PR_NewLock();\n    nss_crllock = PR_NewLock();\n    nss_findslot_lock = PR_NewLock();\n    nss_trustload_lock = PR_NewLock();\n  }\n\n  /* We will actually initialize NSS later */\n\n  return 1;\n}\n\n/* data might be NULL */\nCURLcode Curl_nss_force_init(struct Curl_easy *data)\n{\n  CURLcode result;\n  if(!nss_initlock) {\n    if(data)\n      failf(data, \"unable to initialize NSS, curl_global_init() should have \"\n                  \"been called with CURL_GLOBAL_SSL or CURL_GLOBAL_ALL\");\n    return CURLE_FAILED_INIT;\n  }\n\n  PR_Lock(nss_initlock);\n  result = nss_setup(data);\n  PR_Unlock(nss_initlock);\n\n  return result;\n}\n\n/* Global cleanup */\nstatic void nss_cleanup(void)\n{\n  /* This function isn't required to be threadsafe and this is only done\n   * as a safety feature.\n   */\n  PR_Lock(nss_initlock);\n  if(initialized) {\n    /* Free references to client certificates held in the SSL session cache.\n     * Omitting this hampers destruction of the security module owning\n     * the certificates. */\n    SSL_ClearSessionCache();\n\n    nss_unload_module(&pem_module);\n    nss_unload_module(&trust_module);\n    NSS_ShutdownContext(nss_context);\n    nss_context = NULL;\n  }\n\n  /* destroy all CRL items */\n  Curl_llist_destroy(&nss_crl_list, NULL);\n\n  PR_Unlock(nss_initlock);\n\n  PR_DestroyLock(nss_initlock);\n  PR_DestroyLock(nss_crllock);\n  PR_DestroyLock(nss_findslot_lock);\n  PR_DestroyLock(nss_trustload_lock);\n  nss_initlock = NULL;\n\n  initialized = 0;\n}\n\n/*\n * This function uses SSL_peek to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int nss_check_cxn(struct connectdata *conn)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n  struct ssl_backend_data *backend = connssl->backend;\n  int rc;\n  char buf;\n\n  rc =\n    PR_Recv(backend->handle, (void *)&buf, 1, PR_MSG_PEEK,\n            PR_SecondsToInterval(1));\n  if(rc > 0)\n    return 1; /* connection still in place */\n\n  if(rc == 0)\n    return 0; /* connection has been closed */\n\n  return -1;  /* connection status unknown */\n}\n\nstatic void close_one(struct ssl_connect_data *connssl)\n{\n  /* before the cleanup, check whether we are using a client certificate */\n  struct ssl_backend_data *backend = connssl->backend;\n  const bool client_cert = (backend->client_nickname != NULL)\n    || (backend->obj_clicert != NULL);\n\n  free(backend->client_nickname);\n  backend->client_nickname = NULL;\n\n  /* destroy all NSS objects in order to avoid failure of NSS shutdown */\n  Curl_llist_destroy(&backend->obj_list, NULL);\n  backend->obj_clicert = NULL;\n\n  if(backend->handle) {\n    if(client_cert)\n      /* A server might require different authentication based on the\n       * particular path being requested by the client.  To support this\n       * scenario, we must ensure that a connection will never reuse the\n       * authentication data from a previous connection. */\n      SSL_InvalidateSession(backend->handle);\n\n    PR_Close(backend->handle);\n    backend->handle = NULL;\n  }\n}\n\n/*\n * This function is called when an SSL connection is closed.\n */\nstatic void nss_close(struct Curl_easy *data, struct connectdata *conn,\n                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_connect_data *connssl_proxy = &conn->proxy_ssl[sockindex];\n#endif\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void)data;\n  if(backend->handle\n#ifndef CURL_DISABLE_PROXY\n    || connssl_proxy->backend->handle\n#endif\n    ) {\n    /* NSS closes the socket we previously handed to it, so we must mark it\n       as closed to avoid double close */\n    fake_sclose(conn->sock[sockindex]);\n    conn->sock[sockindex] = CURL_SOCKET_BAD;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(backend->handle)\n    /* nss_close(connssl) will transitively close also\n       connssl_proxy->backend->handle if both are used. Clear it to avoid\n       a double close leading to crash. */\n    connssl_proxy->backend->handle = NULL;\n\n  close_one(connssl_proxy);\n#endif\n  close_one(connssl);\n}\n\n/* return true if NSS can provide error code (and possibly msg) for the\n   error */\nstatic bool is_nss_error(CURLcode err)\n{\n  switch(err) {\n  case CURLE_PEER_FAILED_VERIFICATION:\n  case CURLE_SSL_CERTPROBLEM:\n  case CURLE_SSL_CONNECT_ERROR:\n  case CURLE_SSL_ISSUER_ERROR:\n    return true;\n\n  default:\n    return false;\n  }\n}\n\n/* return true if the given error code is related to a client certificate */\nstatic bool is_cc_error(PRInt32 err)\n{\n  switch(err) {\n  case SSL_ERROR_BAD_CERT_ALERT:\n  case SSL_ERROR_EXPIRED_CERT_ALERT:\n  case SSL_ERROR_REVOKED_CERT_ALERT:\n    return true;\n\n  default:\n    return false;\n  }\n}\n\nstatic Curl_recv nss_recv;\nstatic Curl_send nss_send;\n\nstatic CURLcode nss_load_ca_certificates(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex)\n{\n  const char *cafile = SSL_CONN_CONFIG(CAfile);\n  const char *capath = SSL_CONN_CONFIG(CApath);\n  bool use_trust_module;\n  CURLcode result = CURLE_OK;\n\n  /* treat empty string as unset */\n  if(cafile && !cafile[0])\n    cafile = NULL;\n  if(capath && !capath[0])\n    capath = NULL;\n\n  infof(data, \" CAfile: %s\\n\", cafile ? cafile : \"none\");\n  infof(data, \" CApath: %s\\n\", capath ? capath : \"none\");\n\n  /* load libnssckbi.so if no other trust roots were specified */\n  use_trust_module = !cafile && !capath;\n\n  PR_Lock(nss_trustload_lock);\n  if(use_trust_module && !trust_module) {\n    /* libnssckbi.so needed but not yet loaded --> load it! */\n    result = nss_load_module(&trust_module, trust_library, \"trust\");\n    infof(data, \"%s %s\\n\", (result) ? \"failed to load\" : \"loaded\",\n          trust_library);\n    if(result == CURLE_FAILED_INIT)\n      /* If libnssckbi.so is not available (or fails to load), one can still\n         use CA certificates stored in NSS database.  Ignore the failure. */\n      result = CURLE_OK;\n  }\n  else if(!use_trust_module && trust_module) {\n    /* libnssckbi.so not needed but already loaded --> unload it! */\n    infof(data, \"unloading %s\\n\", trust_library);\n    nss_unload_module(&trust_module);\n  }\n  PR_Unlock(nss_trustload_lock);\n\n  if(cafile)\n    result = nss_load_cert(&conn->ssl[sockindex], cafile, PR_TRUE);\n\n  if(result)\n    return result;\n\n  if(capath) {\n    struct_stat st;\n    if(stat(capath, &st) == -1)\n      return CURLE_SSL_CACERT_BADFILE;\n\n    if(S_ISDIR(st.st_mode)) {\n      PRDirEntry *entry;\n      PRDir *dir = PR_OpenDir(capath);\n      if(!dir)\n        return CURLE_SSL_CACERT_BADFILE;\n\n      while((entry =\n             PR_ReadDir(dir, (PRDirFlags)(PR_SKIP_BOTH | PR_SKIP_HIDDEN)))) {\n        char *fullpath = aprintf(\"%s/%s\", capath, entry->name);\n        if(!fullpath) {\n          PR_CloseDir(dir);\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        if(CURLE_OK != nss_load_cert(&conn->ssl[sockindex], fullpath, PR_TRUE))\n          /* This is purposefully tolerant of errors so non-PEM files can\n           * be in the same directory */\n          infof(data, \"failed to load '%s' from CURLOPT_CAPATH\\n\", fullpath);\n\n        free(fullpath);\n      }\n\n      PR_CloseDir(dir);\n    }\n    else\n      infof(data, \"warning: CURLOPT_CAPATH not a directory (%s)\\n\", capath);\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_sslver_from_curl(PRUint16 *nssver, long version)\n{\n  switch(version) {\n  case CURL_SSLVERSION_SSLv2:\n    *nssver = SSL_LIBRARY_VERSION_2;\n    return CURLE_OK;\n\n  case CURL_SSLVERSION_SSLv3:\n    return CURLE_NOT_BUILT_IN;\n\n  case CURL_SSLVERSION_TLSv1_0:\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_0;\n    return CURLE_OK;\n\n  case CURL_SSLVERSION_TLSv1_1:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_1\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_1;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  case CURL_SSLVERSION_TLSv1_2:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_2\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_2;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  case CURL_SSLVERSION_TLSv1_3:\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n    *nssver = SSL_LIBRARY_VERSION_TLS_1_3;\n    return CURLE_OK;\n#else\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n\n  default:\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n}\n\nstatic CURLcode nss_init_sslver(SSLVersionRange *sslver,\n                                struct Curl_easy *data,\n                                struct connectdata *conn)\n{\n  CURLcode result;\n  const long min = SSL_CONN_CONFIG(version);\n  const long max = SSL_CONN_CONFIG(version_max);\n  SSLVersionRange vrange;\n\n  switch(min) {\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_DEFAULT:\n    /* Bump our minimum TLS version if NSS has stricter requirements. */\n    if(SSL_VersionRangeGetDefault(ssl_variant_stream, &vrange) != SECSuccess)\n      return CURLE_SSL_CONNECT_ERROR;\n    if(sslver->min < vrange.min)\n      sslver->min = vrange.min;\n    break;\n  default:\n    result = nss_sslver_from_curl(&sslver->min, min);\n    if(result) {\n      failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n  }\n\n  switch(max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    break;\n  default:\n    result = nss_sslver_from_curl(&sslver->max, max >> 16);\n    if(result) {\n      failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_fail_connect(struct ssl_connect_data *connssl,\n                                 struct Curl_easy *data,\n                                 CURLcode curlerr)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n\n  if(is_nss_error(curlerr)) {\n    /* read NSPR error code */\n    PRErrorCode err = PR_GetError();\n    if(is_cc_error(err))\n      curlerr = CURLE_SSL_CERTPROBLEM;\n\n    /* print the error number and error string */\n    infof(data, \"NSS error %d (%s)\\n\", err, nss_error_to_name(err));\n\n    /* print a human-readable message describing the error if available */\n    nss_print_error_message(data, err);\n  }\n\n  /* cleanup on connection failure */\n  Curl_llist_destroy(&backend->obj_list, NULL);\n\n  return curlerr;\n}\n\n/* Switch the SSL socket into blocking or non-blocking mode. */\nstatic CURLcode nss_set_blocking(struct ssl_connect_data *connssl,\n                                 struct Curl_easy *data,\n                                 bool blocking)\n{\n  PRSocketOptionData sock_opt;\n  struct ssl_backend_data *backend = connssl->backend;\n  sock_opt.option = PR_SockOpt_Nonblocking;\n  sock_opt.value.non_blocking = !blocking;\n\n  if(PR_SetSocketOption(backend->handle, &sock_opt) != PR_SUCCESS)\n    return nss_fail_connect(connssl, data, CURLE_SSL_CONNECT_ERROR);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_setup_connect(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex)\n{\n  PRFileDesc *model = NULL;\n  PRFileDesc *nspr_io = NULL;\n  PRFileDesc *nspr_io_stub = NULL;\n  PRBool ssl_no_cache;\n  PRBool ssl_cbc_random_iv;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode result;\n  bool second_layer = FALSE;\n  SSLVersionRange sslver_supported;\n\n  SSLVersionRange sslver = {\n    SSL_LIBRARY_VERSION_TLS_1_0,  /* min */\n#ifdef SSL_LIBRARY_VERSION_TLS_1_3\n    SSL_LIBRARY_VERSION_TLS_1_3   /* max */\n#elif defined SSL_LIBRARY_VERSION_TLS_1_2\n    SSL_LIBRARY_VERSION_TLS_1_2\n#elif defined SSL_LIBRARY_VERSION_TLS_1_1\n    SSL_LIBRARY_VERSION_TLS_1_1\n#else\n    SSL_LIBRARY_VERSION_TLS_1_0\n#endif\n  };\n\n  backend->data = data;\n\n  /* list of all NSS objects we need to destroy in nss_do_close() */\n  Curl_llist_init(&backend->obj_list, nss_destroy_object);\n\n  PR_Lock(nss_initlock);\n  result = nss_setup(data);\n  if(result) {\n    PR_Unlock(nss_initlock);\n    goto error;\n  }\n\n  PK11_SetPasswordFunc(nss_get_password);\n\n  result = nss_load_module(&pem_module, pem_library, \"PEM\");\n  PR_Unlock(nss_initlock);\n  if(result == CURLE_FAILED_INIT)\n    infof(data, \"WARNING: failed to load NSS PEM library %s. Using \"\n                \"OpenSSL PEM certificates will not work.\\n\", pem_library);\n  else if(result)\n    goto error;\n\n  result = CURLE_SSL_CONNECT_ERROR;\n\n  model = PR_NewTCPSocket();\n  if(!model)\n    goto error;\n  model = SSL_ImportFD(NULL, model);\n\n  if(SSL_OptionSet(model, SSL_SECURITY, PR_TRUE) != SECSuccess)\n    goto error;\n  if(SSL_OptionSet(model, SSL_HANDSHAKE_AS_SERVER, PR_FALSE) != SECSuccess)\n    goto error;\n  if(SSL_OptionSet(model, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE) != SECSuccess)\n    goto error;\n\n  /* do not use SSL cache if disabled or we are not going to verify peer */\n  ssl_no_cache = (SSL_SET_OPTION(primary.sessionid)\n                  && SSL_CONN_CONFIG(verifypeer)) ? PR_FALSE : PR_TRUE;\n  if(SSL_OptionSet(model, SSL_NO_CACHE, ssl_no_cache) != SECSuccess)\n    goto error;\n\n  /* enable/disable the requested SSL version(s) */\n  if(nss_init_sslver(&sslver, data, conn) != CURLE_OK)\n    goto error;\n  if(SSL_VersionRangeGetSupported(ssl_variant_stream,\n                                  &sslver_supported) != SECSuccess)\n    goto error;\n  if(sslver_supported.max < sslver.max && sslver_supported.max >= sslver.min) {\n    char *sslver_req_str, *sslver_supp_str;\n    sslver_req_str = nss_sslver_to_name(sslver.max);\n    sslver_supp_str = nss_sslver_to_name(sslver_supported.max);\n    if(sslver_req_str && sslver_supp_str)\n      infof(data, \"Falling back from %s to max supported SSL version (%s)\\n\",\n                  sslver_req_str, sslver_supp_str);\n    free(sslver_req_str);\n    free(sslver_supp_str);\n    sslver.max = sslver_supported.max;\n  }\n  if(SSL_VersionRangeSet(model, &sslver) != SECSuccess)\n    goto error;\n\n  ssl_cbc_random_iv = !SSL_SET_OPTION(enable_beast);\n#ifdef SSL_CBC_RANDOM_IV\n  /* unless the user explicitly asks to allow the protocol vulnerability, we\n     use the work-around */\n  if(SSL_OptionSet(model, SSL_CBC_RANDOM_IV, ssl_cbc_random_iv) != SECSuccess)\n    infof(data, \"warning: failed to set SSL_CBC_RANDOM_IV = %d\\n\",\n          ssl_cbc_random_iv);\n#else\n  if(ssl_cbc_random_iv)\n    infof(data, \"warning: support for SSL_CBC_RANDOM_IV not compiled in\\n\");\n#endif\n\n  if(SSL_CONN_CONFIG(cipher_list)) {\n    if(set_ciphers(data, model, SSL_CONN_CONFIG(cipher_list)) != SECSuccess) {\n      result = CURLE_SSL_CIPHER;\n      goto error;\n    }\n  }\n\n  if(!SSL_CONN_CONFIG(verifypeer) && SSL_CONN_CONFIG(verifyhost))\n    infof(data, \"warning: ignoring value of ssl.verifyhost\\n\");\n\n  /* bypass the default SSL_AuthCertificate() hook in case we do not want to\n   * verify peer */\n  if(SSL_AuthCertificateHook(model, nss_auth_cert_hook, data) != SECSuccess)\n    goto error;\n\n  /* not checked yet */\n  SSL_SET_OPTION_LVALUE(certverifyresult) = 0;\n\n  if(SSL_BadCertHook(model, BadCertHandler, data) != SECSuccess)\n    goto error;\n\n  if(SSL_HandshakeCallback(model, HandshakeCallback, data) != SECSuccess)\n    goto error;\n\n  {\n    const CURLcode rv = nss_load_ca_certificates(data, conn, sockindex);\n    if((rv == CURLE_SSL_CACERT_BADFILE) && !SSL_CONN_CONFIG(verifypeer))\n      /* not a fatal error because we are not going to verify the peer */\n      infof(data, \"warning: CA certificates failed to load\\n\");\n    else if(rv) {\n      result = rv;\n      goto error;\n    }\n  }\n\n  if(SSL_SET_OPTION(CRLfile)) {\n    const CURLcode rv = nss_load_crl(SSL_SET_OPTION(CRLfile));\n    if(rv) {\n      result = rv;\n      goto error;\n    }\n    infof(data, \"  CRLfile: %s\\n\", SSL_SET_OPTION(CRLfile));\n  }\n\n  if(SSL_SET_OPTION(primary.clientcert)) {\n    char *nickname = dup_nickname(data, SSL_SET_OPTION(primary.clientcert));\n    if(nickname) {\n      /* we are not going to use libnsspem.so to read the client cert */\n      backend->obj_clicert = NULL;\n    }\n    else {\n      CURLcode rv = cert_stuff(data, conn, sockindex,\n                               SSL_SET_OPTION(primary.clientcert),\n                               SSL_SET_OPTION(key));\n      if(rv) {\n        /* failf() is already done in cert_stuff() */\n        result = rv;\n        goto error;\n      }\n    }\n\n    /* store the nickname for SelectClientCert() called during handshake */\n    backend->client_nickname = nickname;\n  }\n  else\n    backend->client_nickname = NULL;\n\n  if(SSL_GetClientAuthDataHook(model, SelectClientCert,\n                               (void *)connssl) != SECSuccess) {\n    result = CURLE_SSL_CERTPROBLEM;\n    goto error;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(conn->proxy_ssl[sockindex].backend->handle != NULL);\n    nspr_io = conn->proxy_ssl[sockindex].backend->handle;\n    second_layer = TRUE;\n  }\n#endif\n  else {\n    /* wrap OS file descriptor by NSPR's file descriptor abstraction */\n    nspr_io = PR_ImportTCPSocket(sockfd);\n    if(!nspr_io)\n      goto error;\n  }\n\n  /* create our own NSPR I/O layer */\n  nspr_io_stub = PR_CreateIOLayerStub(nspr_io_identity, &nspr_io_methods);\n  if(!nspr_io_stub) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    goto error;\n  }\n\n  /* make the per-connection data accessible from NSPR I/O callbacks */\n  nspr_io_stub->secret = (void *)connssl;\n\n  /* push our new layer to the NSPR I/O stack */\n  if(PR_PushIOLayer(nspr_io, PR_TOP_IO_LAYER, nspr_io_stub) != PR_SUCCESS) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    PR_Close(nspr_io_stub);\n    goto error;\n  }\n\n  /* import our model socket onto the current I/O stack */\n  backend->handle = SSL_ImportFD(model, nspr_io);\n  if(!backend->handle) {\n    if(!second_layer)\n      PR_Close(nspr_io);\n    goto error;\n  }\n\n  PR_Close(model); /* We don't need this any more */\n  model = NULL;\n\n  /* This is the password associated with the cert that we're using */\n  if(SSL_SET_OPTION(key_passwd)) {\n    SSL_SetPKCS11PinArg(backend->handle, SSL_SET_OPTION(key_passwd));\n  }\n\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    if(SSL_OptionSet(backend->handle, SSL_ENABLE_OCSP_STAPLING, PR_TRUE)\n        != SECSuccess)\n      goto error;\n  }\n#endif\n\n#ifdef SSL_ENABLE_NPN\n  if(SSL_OptionSet(backend->handle, SSL_ENABLE_NPN, conn->bits.tls_enable_npn\n                   ? PR_TRUE : PR_FALSE) != SECSuccess)\n    goto error;\n#endif\n\n#ifdef SSL_ENABLE_ALPN\n  if(SSL_OptionSet(backend->handle, SSL_ENABLE_ALPN, conn->bits.tls_enable_alpn\n                   ? PR_TRUE : PR_FALSE) != SECSuccess)\n    goto error;\n#endif\n\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\n  if(data->set.ssl.falsestart) {\n    if(SSL_OptionSet(backend->handle, SSL_ENABLE_FALSE_START, PR_TRUE)\n        != SECSuccess)\n      goto error;\n\n    if(SSL_SetCanFalseStartCallback(backend->handle, CanFalseStartCallback,\n        data) != SECSuccess)\n      goto error;\n  }\n#endif\n\n#if defined(SSL_ENABLE_NPN) || defined(SSL_ENABLE_ALPN)\n  if(conn->bits.tls_enable_npn || conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    unsigned char protocols[128];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n      && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n      ) {\n      protocols[cur++] = ALPN_H2_LENGTH;\n      memcpy(&protocols[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n    }\n#endif\n    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n\n    if(SSL_SetNextProtoNego(backend->handle, protocols, cur) != SECSuccess)\n      goto error;\n  }\n#endif\n\n\n  /* Force handshake on next I/O */\n  if(SSL_ResetHandshake(backend->handle, /* asServer */ PR_FALSE)\n      != SECSuccess)\n    goto error;\n\n  /* propagate hostname to the TLS layer */\n  if(SSL_SetURL(backend->handle, SSL_HOST_NAME()) != SECSuccess)\n    goto error;\n\n  /* prevent NSS from re-using the session for a different hostname */\n  if(SSL_SetSockPeerID(backend->handle, SSL_HOST_NAME()) != SECSuccess)\n    goto error;\n\n  return CURLE_OK;\n\nerror:\n  if(model)\n    PR_Close(model);\n\n  return nss_fail_connect(connssl, data, result);\n}\n\nstatic CURLcode nss_do_connect(struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode result = CURLE_SSL_CONNECT_ERROR;\n  PRUint32 timeout;\n\n  /* check timeout situation */\n  const timediff_t time_left = Curl_timeleft(data, NULL, TRUE);\n  if(time_left < 0) {\n    failf(data, \"timed out before SSL handshake\");\n    result = CURLE_OPERATION_TIMEDOUT;\n    goto error;\n  }\n\n  /* Force the handshake now */\n  timeout = PR_MillisecondsToInterval((PRUint32) time_left);\n  if(SSL_ForceHandshakeWithTimeout(backend->handle, timeout) != SECSuccess) {\n    if(PR_GetError() == PR_WOULD_BLOCK_ERROR)\n      /* blocking direction is updated by nss_update_connecting_state() */\n      return CURLE_AGAIN;\n    else if(SSL_SET_OPTION(certverifyresult) == SSL_ERROR_BAD_CERT_DOMAIN)\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    else if(SSL_SET_OPTION(certverifyresult) != 0)\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    goto error;\n  }\n\n  result = display_conn_info(data, backend->handle);\n  if(result)\n    goto error;\n\n  if(SSL_SET_OPTION(issuercert)) {\n    SECStatus ret = SECFailure;\n    char *nickname = dup_nickname(data, SSL_SET_OPTION(issuercert));\n    if(nickname) {\n      /* we support only nicknames in case of issuercert for now */\n      ret = check_issuer_cert(backend->handle, nickname);\n      free(nickname);\n    }\n\n    if(SECFailure == ret) {\n      infof(data, \"SSL certificate issuer check failed\\n\");\n      result = CURLE_SSL_ISSUER_ERROR;\n      goto error;\n    }\n    else {\n      infof(data, \"SSL certificate issuer check ok\\n\");\n    }\n  }\n\n  result = cmp_peer_pubkey(connssl, SSL_PINNED_PUB_KEY());\n  if(result)\n    /* status already printed */\n    goto error;\n\n  return CURLE_OK;\n\nerror:\n  return nss_fail_connect(connssl, data, result);\n}\n\nstatic CURLcode nss_connect_common(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex,\n                                   bool *done)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  const bool blocking = (done == NULL);\n  CURLcode result;\n\n  if(connssl->state == ssl_connection_complete) {\n    if(!blocking)\n      *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(connssl->connecting_state == ssl_connect_1) {\n    result = nss_setup_connect(data, conn, sockindex);\n    if(result)\n      /* we do not expect CURLE_AGAIN from nss_setup_connect() */\n      return result;\n\n    connssl->connecting_state = ssl_connect_2;\n  }\n\n  /* enable/disable blocking mode before handshake */\n  result = nss_set_blocking(connssl, data, blocking);\n  if(result)\n    return result;\n\n  result = nss_do_connect(data, conn, sockindex);\n  switch(result) {\n  case CURLE_OK:\n    break;\n  case CURLE_AGAIN:\n    if(!blocking)\n      /* CURLE_AGAIN in non-blocking mode is not an error */\n      return CURLE_OK;\n    /* FALLTHROUGH */\n  default:\n    return result;\n  }\n\n  if(blocking) {\n    /* in blocking mode, set NSS non-blocking mode _after_ SSL handshake */\n    result = nss_set_blocking(connssl, data, /* blocking */ FALSE);\n    if(result)\n      return result;\n  }\n  else\n    /* signal completed SSL handshake */\n    *done = TRUE;\n\n  connssl->state = ssl_connection_complete;\n  conn->recv[sockindex] = nss_recv;\n  conn->send[sockindex] = nss_send;\n\n  /* ssl_connect_done is never used outside, go back to the initial state */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_connect(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  return nss_connect_common(data, conn, sockindex, /* blocking */ NULL);\n}\n\nstatic CURLcode nss_connect_nonblocking(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        int sockindex, bool *done)\n{\n  return nss_connect_common(data, conn, sockindex, done);\n}\n\nstatic ssize_t nss_send(struct Curl_easy *data,    /* transfer */\n                        int sockindex,             /* socketindex */\n                        const void *mem,           /* send this data */\n                        size_t len,                /* amount to write */\n                        CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t rc;\n\n  /* The SelectClientCert() hook uses this for infof() and failf() but the\n     handle stored in nss_setup_connect() could have already been freed. */\n  backend->data = data;\n\n  rc = PR_Send(backend->handle, mem, (int)len, 0, PR_INTERVAL_NO_WAIT);\n  if(rc < 0) {\n    PRInt32 err = PR_GetError();\n    if(err == PR_WOULD_BLOCK_ERROR)\n      *curlcode = CURLE_AGAIN;\n    else {\n      /* print the error number and error string */\n      const char *err_name = nss_error_to_name(err);\n      infof(data, \"SSL write: error %d (%s)\\n\", err, err_name);\n\n      /* print a human-readable message describing the error if available */\n      nss_print_error_message(data, err);\n\n      *curlcode = (is_cc_error(err))\n        ? CURLE_SSL_CERTPROBLEM\n        : CURLE_SEND_ERROR;\n    }\n\n    return -1;\n  }\n\n  return rc; /* number of bytes */\n}\n\nstatic ssize_t nss_recv(struct Curl_easy *data,    /* transfer */\n                        int sockindex,             /* socketindex */\n                        char *buf,             /* store read data here */\n                        size_t buffersize,     /* max amount to read */\n                        CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t nread;\n\n  /* The SelectClientCert() hook uses this for infof() and failf() but the\n     handle stored in nss_setup_connect() could have already been freed. */\n  backend->data = data;\n\n  nread = PR_Recv(backend->handle, buf, (int)buffersize, 0,\n                  PR_INTERVAL_NO_WAIT);\n  if(nread < 0) {\n    /* failed SSL read */\n    PRInt32 err = PR_GetError();\n\n    if(err == PR_WOULD_BLOCK_ERROR)\n      *curlcode = CURLE_AGAIN;\n    else {\n      /* print the error number and error string */\n      const char *err_name = nss_error_to_name(err);\n      infof(data, \"SSL read: errno %d (%s)\\n\", err, err_name);\n\n      /* print a human-readable message describing the error if available */\n      nss_print_error_message(data, err);\n\n      *curlcode = (is_cc_error(err))\n        ? CURLE_SSL_CERTPROBLEM\n        : CURLE_RECV_ERROR;\n    }\n\n    return -1;\n  }\n\n  return nread;\n}\n\nstatic size_t nss_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"NSS/%s\", NSS_GetVersion());\n}\n\n/* data might be NULL */\nstatic int Curl_nss_seed(struct Curl_easy *data)\n{\n  /* make sure that NSS is initialized */\n  return !!Curl_nss_force_init(data);\n}\n\n/* data might be NULL */\nstatic CURLcode nss_random(struct Curl_easy *data,\n                           unsigned char *entropy,\n                           size_t length)\n{\n  Curl_nss_seed(data);  /* Initiate the seed if not already done */\n\n  if(SECSuccess != PK11_GenerateRandom(entropy, curlx_uztosi(length)))\n    /* signal a failure */\n    return CURLE_FAILED_INIT;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode nss_sha256sum(const unsigned char *tmp, /* input */\n                              size_t tmplen,\n                              unsigned char *sha256sum, /* output */\n                              size_t sha256len)\n{\n  PK11Context *SHA256pw = PK11_CreateDigestContext(SEC_OID_SHA256);\n  unsigned int SHA256out;\n\n  if(!SHA256pw)\n    return CURLE_NOT_BUILT_IN;\n\n  PK11_DigestOp(SHA256pw, tmp, curlx_uztoui(tmplen));\n  PK11_DigestFinal(SHA256pw, sha256sum, &SHA256out, curlx_uztoui(sha256len));\n  PK11_DestroyContext(SHA256pw, PR_TRUE);\n\n  return CURLE_OK;\n}\n\nstatic bool nss_cert_status_request(void)\n{\n#ifdef SSL_ENABLE_OCSP_STAPLING\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic bool nss_false_start(void)\n{\n#if NSSVERNUM >= 0x030f04 /* 3.15.4 */\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic void *nss_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_nss = {\n  { CURLSSLBACKEND_NSS, \"nss\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  nss_init,                     /* init */\n  nss_cleanup,                  /* cleanup */\n  nss_version,                  /* version */\n  nss_check_cxn,                /* check_cxn */\n  /* NSS has no shutdown function provided and thus always fail */\n  Curl_none_shutdown,           /* shutdown */\n  Curl_none_data_pending,       /* data_pending */\n  nss_random,                   /* random */\n  nss_cert_status_request,      /* cert_status_request */\n  nss_connect,                  /* connect */\n  nss_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,             /* getsock */\n  nss_get_internals,            /* get_internals */\n  nss_close,                    /* close_one */\n  Curl_none_close_all,          /* close_all */\n  /* NSS has its own session ID cache */\n  Curl_none_session_free,       /* session_free */\n  Curl_none_set_engine,         /* set_engine */\n  Curl_none_set_engine_default, /* set_engine_default */\n  Curl_none_engines_list,       /* engines_list */\n  nss_false_start,              /* false_start */\n  nss_sha256sum,                /* sha256sum */\n  NULL,                         /* associate_connection */\n  NULL                          /* disassociate_connection */\n};\n\n#endif /* USE_NSS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all OpenSSL-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_OPENSSL\n\n#include <limits.h>\n\n/* Wincrypt must be included before anything that could include OpenSSL. */\n#if defined(USE_WIN32_CRYPTO)\n#include <wincrypt.h>\n/* Undefine wincrypt conflicting symbols for BoringSSL. */\n#undef X509_NAME\n#undef X509_EXTENSIONS\n#undef PKCS7_ISSUER_AND_SERIAL\n#undef PKCS7_SIGNER_INFO\n#undef OCSP_REQUEST\n#undef OCSP_RESPONSE\n#endif\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"formdata.h\" /* for the boundary function */\n#include \"url.h\" /* for the ssl config check function */\n#include \"inet_pton.h\"\n#include \"openssl.h\"\n#include \"connect.h\"\n#include \"slist.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"keylog.h\"\n#include \"strcase.h\"\n#include \"hostcheck.h\"\n#include \"multiif.h\"\n#include \"strerror.h\"\n#include \"curl_printf.h\"\n\n#include <openssl/ssl.h>\n#include <openssl/rand.h>\n#include <openssl/x509v3.h>\n#ifndef OPENSSL_NO_DSA\n#include <openssl/dsa.h>\n#endif\n#include <openssl/dh.h>\n#include <openssl/err.h>\n#include <openssl/md5.h>\n#include <openssl/conf.h>\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/bio.h>\n#include <openssl/buffer.h>\n#include <openssl/pkcs12.h>\n\n#ifdef USE_AMISSL\n#include \"amigaos.h\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_OCSP)\n#include <openssl/ocsp.h>\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090700fL) && /* 0.9.7 or later */     \\\n  !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_UI_CONSOLE)\n#define USE_OPENSSL_ENGINE\n#include <openssl/engine.h>\n#endif\n\n#include \"warnless.h\"\n#include \"non-ascii.h\" /* for Curl_convert_from_utf8 prototype */\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* Uncomment the ALLOW_RENEG line to a real #define if you want to allow TLS\n   renegotiations when built with BoringSSL. Renegotiating is non-compliant\n   with HTTP/2 and \"an extremely dangerous protocol feature\". Beware.\n\n#define ALLOW_RENEG 1\n */\n\n#ifndef OPENSSL_VERSION_NUMBER\n#error \"OPENSSL_VERSION_NUMBER not defined\"\n#endif\n\n#ifdef USE_OPENSSL_ENGINE\n#include <openssl/ui.h>\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n#define SSL_METHOD_QUAL const\n#else\n#define SSL_METHOD_QUAL\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n#define HAVE_ERR_REMOVE_THREAD_STATE 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && /* OpenSSL 1.1.0+ */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n#define SSLEAY_VERSION_NUMBER OPENSSL_VERSION_NUMBER\n#define HAVE_X509_GET0_EXTENSIONS 1 /* added in 1.1.0 -pre1 */\n#define HAVE_OPAQUE_EVP_PKEY 1 /* since 1.1.0 -pre3 */\n#define HAVE_OPAQUE_RSA_DSA_DH 1 /* since 1.1.0 -pre5 */\n#define CONST_EXTS const\n#define HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED 1\n\n/* funny typecast define due to difference in API */\n#ifdef LIBRESSL_VERSION_NUMBER\n#define ARG2_X509_signature_print (X509_ALGOR *)\n#else\n#define ARG2_X509_signature_print\n#endif\n\n#else\n/* For OpenSSL before 1.1.0 */\n#define ASN1_STRING_get0_data(x) ASN1_STRING_data(x)\n#define X509_get0_notBefore(x) X509_get_notBefore(x)\n#define X509_get0_notAfter(x) X509_get_notAfter(x)\n#define CONST_EXTS /* nope */\n#ifndef LIBRESSL_VERSION_NUMBER\n#define OpenSSL_version_num() SSLeay()\n#endif\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) && /* 1.0.2 or later */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n#define HAVE_X509_GET0_SIGNATURE 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) /* 1.0.2 or later */\n#define HAVE_SSL_GET_SHUTDOWN 1\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10002003L && \\\n  OPENSSL_VERSION_NUMBER <= 0x10002FFFL && \\\n  !defined(OPENSSL_NO_COMP)\n#define HAVE_SSL_COMP_FREE_COMPRESSION_METHODS 1\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x0090808fL)\n/* not present in older OpenSSL */\n#define OPENSSL_load_builtin_modules(x)\n#endif\n\n/*\n * Whether SSL_CTX_set_keylog_callback is available.\n * OpenSSL: supported since 1.1.1 https://github.com/openssl/openssl/pull/2287\n * BoringSSL: supported since d28f59c27bac (committed 2015-11-19)\n * LibreSSL: unsupported in at least 2.7.2 (explicitly check for it since it\n *           lies and pretends to be OpenSSL 2.0.0).\n */\n#if (OPENSSL_VERSION_NUMBER >= 0x10101000L && \\\n     !defined(LIBRESSL_VERSION_NUMBER)) || \\\n    defined(OPENSSL_IS_BORINGSSL)\n#define HAVE_KEYLOG_CALLBACK\n#endif\n\n/* Whether SSL_CTX_set_ciphersuites is available.\n * OpenSSL: supported since 1.1.1 (commit a53b5be6a05)\n * BoringSSL: no\n * LibreSSL: no\n */\n#if ((OPENSSL_VERSION_NUMBER >= 0x10101000L) && \\\n     !defined(LIBRESSL_VERSION_NUMBER) &&       \\\n     !defined(OPENSSL_IS_BORINGSSL))\n#define HAVE_SSL_CTX_SET_CIPHERSUITES\n#define HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH\n/* SET_EC_CURVES available under the same preconditions: see\n * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html\n */\n#define HAVE_SSL_CTX_SET_EC_CURVES\n#endif\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#define OSSL_PACKAGE \"LibreSSL\"\n#elif defined(OPENSSL_IS_BORINGSSL)\n#define OSSL_PACKAGE \"BoringSSL\"\n#else\n#define OSSL_PACKAGE \"OpenSSL\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n/* up2date versions of OpenSSL maintain the default reasonably secure without\n * breaking compatibility, so it is better not to override the default by curl\n */\n#define DEFAULT_CIPHER_SELECTION NULL\n#else\n/* ... but it is not the case with old versions of OpenSSL */\n#define DEFAULT_CIPHER_SELECTION \\\n  \"ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH\"\n#endif\n\n#ifdef HAVE_OPENSSL_SRP\n/* the function exists */\n#ifdef USE_TLS_SRP\n/* the functionality is not disabled */\n#define USE_OPENSSL_SRP\n#endif\n#endif\n\nstruct ssl_backend_data {\n  struct Curl_easy *logger; /* transfer handle to pass trace logs to, only\n                               using sockindex 0 */\n  /* these ones requires specific SSL-types */\n  SSL_CTX* ctx;\n  SSL*     handle;\n  X509*    server_cert;\n#ifndef HAVE_KEYLOG_CALLBACK\n  /* Set to true once a valid keylog entry has been created to avoid dupes. */\n  bool     keylog_done;\n#endif\n};\n\nstatic void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex);\n\n/*\n * Number of bytes to read from the random number seed file. This must be\n * a finite value (because some entropy \"files\" like /dev/urandom have\n * an infinite length), but must be large enough to provide enough\n * entropy to properly seed OpenSSL's PRNG.\n */\n#define RAND_LOAD_LENGTH 1024\n\n#ifdef HAVE_KEYLOG_CALLBACK\nstatic void ossl_keylog_callback(const SSL *ssl, const char *line)\n{\n  (void)ssl;\n\n  Curl_tls_keylog_write_line(line);\n}\n#else\n/*\n * ossl_log_tls12_secret is called by libcurl to make the CLIENT_RANDOMs if the\n * OpenSSL being used doesn't have native support for doing that.\n */\nstatic void\nossl_log_tls12_secret(const SSL *ssl, bool *keylog_done)\n{\n  const SSL_SESSION *session = SSL_get_session(ssl);\n  unsigned char client_random[SSL3_RANDOM_SIZE];\n  unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];\n  int master_key_length = 0;\n\n  if(!session || *keylog_done)\n    return;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      LIBRESSL_VERSION_NUMBER < 0x20700000L)\n  /* ssl->s3 is not checked in openssl 1.1.0-pre6, but let's assume that\n   * we have a valid SSL context if we have a non-NULL session. */\n  SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE);\n  master_key_length = (int)\n    SSL_SESSION_get_master_key(session, master_key, SSL_MAX_MASTER_KEY_LENGTH);\n#else\n  if(ssl->s3 && session->master_key_length > 0) {\n    master_key_length = session->master_key_length;\n    memcpy(master_key, session->master_key, session->master_key_length);\n    memcpy(client_random, ssl->s3->client_random, SSL3_RANDOM_SIZE);\n  }\n#endif\n\n  /* The handshake has not progressed sufficiently yet, or this is a TLS 1.3\n   * session (when curl was built with older OpenSSL headers and running with\n   * newer OpenSSL runtime libraries). */\n  if(master_key_length <= 0)\n    return;\n\n  *keylog_done = true;\n  Curl_tls_keylog_write(\"CLIENT_RANDOM\", client_random,\n                        master_key, master_key_length);\n}\n#endif /* !HAVE_KEYLOG_CALLBACK */\n\nstatic const char *SSL_ERROR_to_str(int err)\n{\n  switch(err) {\n  case SSL_ERROR_NONE:\n    return \"SSL_ERROR_NONE\";\n  case SSL_ERROR_SSL:\n    return \"SSL_ERROR_SSL\";\n  case SSL_ERROR_WANT_READ:\n    return \"SSL_ERROR_WANT_READ\";\n  case SSL_ERROR_WANT_WRITE:\n    return \"SSL_ERROR_WANT_WRITE\";\n  case SSL_ERROR_WANT_X509_LOOKUP:\n    return \"SSL_ERROR_WANT_X509_LOOKUP\";\n  case SSL_ERROR_SYSCALL:\n    return \"SSL_ERROR_SYSCALL\";\n  case SSL_ERROR_ZERO_RETURN:\n    return \"SSL_ERROR_ZERO_RETURN\";\n  case SSL_ERROR_WANT_CONNECT:\n    return \"SSL_ERROR_WANT_CONNECT\";\n  case SSL_ERROR_WANT_ACCEPT:\n    return \"SSL_ERROR_WANT_ACCEPT\";\n#if defined(SSL_ERROR_WANT_ASYNC)\n  case SSL_ERROR_WANT_ASYNC:\n    return \"SSL_ERROR_WANT_ASYNC\";\n#endif\n#if defined(SSL_ERROR_WANT_ASYNC_JOB)\n  case SSL_ERROR_WANT_ASYNC_JOB:\n    return \"SSL_ERROR_WANT_ASYNC_JOB\";\n#endif\n#if defined(SSL_ERROR_WANT_EARLY)\n  case SSL_ERROR_WANT_EARLY:\n    return \"SSL_ERROR_WANT_EARLY\";\n#endif\n  default:\n    return \"SSL_ERROR unknown\";\n  }\n}\n\n/* Return error string for last OpenSSL error\n */\nstatic char *ossl_strerror(unsigned long error, char *buf, size_t size)\n{\n  if(size)\n    *buf = '\\0';\n\n#ifdef OPENSSL_IS_BORINGSSL\n  ERR_error_string_n((uint32_t)error, buf, size);\n#else\n  ERR_error_string_n(error, buf, size);\n#endif\n\n  if(size > 1 && !*buf) {\n    strncpy(buf, (error ? \"Unknown error\" : \"No error\"), size);\n    buf[size - 1] = '\\0';\n  }\n\n  return buf;\n}\n\n/* Return an extra data index for the transfer data.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_data_index(void)\n{\n  static int ssl_ex_data_data_index = -1;\n  if(ssl_ex_data_data_index < 0) {\n    ssl_ex_data_data_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return ssl_ex_data_data_index;\n}\n\n/* Return an extra data index for the connection data.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_conn_index(void)\n{\n  static int ssl_ex_data_conn_index = -1;\n  if(ssl_ex_data_conn_index < 0) {\n    ssl_ex_data_conn_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return ssl_ex_data_conn_index;\n}\n\n/* Return an extra data index for the sockindex.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_ssl_sockindex_index(void)\n{\n  static int sockindex_index = -1;\n  if(sockindex_index < 0) {\n    sockindex_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return sockindex_index;\n}\n\n/* Return an extra data index for proxy boolean.\n * This index can be used with SSL_get_ex_data() and SSL_set_ex_data().\n */\nstatic int ossl_get_proxy_index(void)\n{\n  static int proxy_index = -1;\n  if(proxy_index < 0) {\n    proxy_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n  }\n  return proxy_index;\n}\n\nstatic int passwd_callback(char *buf, int num, int encrypting,\n                           void *global_passwd)\n{\n  DEBUGASSERT(0 == encrypting);\n\n  if(!encrypting) {\n    int klen = curlx_uztosi(strlen((char *)global_passwd));\n    if(num > klen) {\n      memcpy(buf, global_passwd, klen + 1);\n      return klen;\n    }\n  }\n  return 0;\n}\n\n/*\n * rand_enough() returns TRUE if we have seeded the random engine properly.\n */\nstatic bool rand_enough(void)\n{\n  return (0 != RAND_status()) ? TRUE : FALSE;\n}\n\nstatic CURLcode ossl_seed(struct Curl_easy *data)\n{\n  /* we have the \"SSL is seeded\" boolean static to prevent multiple\n     time-consuming seedings in vain */\n  static bool ssl_seeded = FALSE;\n  char fname[256];\n\n  if(ssl_seeded)\n    return CURLE_OK;\n\n  if(rand_enough()) {\n    /* OpenSSL 1.1.0+ will return here */\n    ssl_seeded = TRUE;\n    return CURLE_OK;\n  }\n\n#ifndef RANDOM_FILE\n  /* if RANDOM_FILE isn't defined, we only perform this if an option tells\n     us to! */\n  if(data->set.str[STRING_SSL_RANDOM_FILE])\n#define RANDOM_FILE \"\" /* doesn't matter won't be used */\n#endif\n  {\n    /* let the option override the define */\n    RAND_load_file((data->set.str[STRING_SSL_RANDOM_FILE]?\n                    data->set.str[STRING_SSL_RANDOM_FILE]:\n                    RANDOM_FILE),\n                   RAND_LOAD_LENGTH);\n    if(rand_enough())\n      return CURLE_OK;\n  }\n\n#if defined(HAVE_RAND_EGD)\n  /* only available in OpenSSL 0.9.5 and later */\n  /* EGD_SOCKET is set at configure time or not at all */\n#ifndef EGD_SOCKET\n  /* If we don't have the define set, we only do this if the egd-option\n     is set */\n  if(data->set.str[STRING_SSL_EGDSOCKET])\n#define EGD_SOCKET \"\" /* doesn't matter won't be used */\n#endif\n  {\n    /* If there's an option and a define, the option overrides the\n       define */\n    int ret = RAND_egd(data->set.str[STRING_SSL_EGDSOCKET]?\n                       data->set.str[STRING_SSL_EGDSOCKET]:EGD_SOCKET);\n    if(-1 != ret) {\n      if(rand_enough())\n        return CURLE_OK;\n    }\n  }\n#endif\n\n  /* fallback to a custom seeding of the PRNG using a hash based on a current\n     time */\n  do {\n    unsigned char randb[64];\n    size_t len = sizeof(randb);\n    size_t i, i_max;\n    for(i = 0, i_max = len / sizeof(struct curltime); i < i_max; ++i) {\n      struct curltime tv = Curl_now();\n      Curl_wait_ms(1);\n      tv.tv_sec *= i + 1;\n      tv.tv_usec *= (unsigned int)i + 2;\n      tv.tv_sec ^= ((Curl_now().tv_sec + Curl_now().tv_usec) *\n                    (i + 3)) << 8;\n      tv.tv_usec ^= (unsigned int) ((Curl_now().tv_sec +\n                                     Curl_now().tv_usec) *\n                                    (i + 4)) << 16;\n      memcpy(&randb[i * sizeof(struct curltime)], &tv,\n             sizeof(struct curltime));\n    }\n    RAND_add(randb, (int)len, (double)len/2);\n  } while(!rand_enough());\n\n  /* generates a default path for the random seed file */\n  fname[0] = 0; /* blank it first */\n  RAND_file_name(fname, sizeof(fname));\n  if(fname[0]) {\n    /* we got a file name to try */\n    RAND_load_file(fname, RAND_LOAD_LENGTH);\n    if(rand_enough())\n      return CURLE_OK;\n  }\n\n  infof(data, \"libcurl is now using a weak random seed!\\n\");\n  return (rand_enough() ? CURLE_OK :\n    CURLE_SSL_CONNECT_ERROR /* confusing error code */);\n}\n\n#ifndef SSL_FILETYPE_ENGINE\n#define SSL_FILETYPE_ENGINE 42\n#endif\n#ifndef SSL_FILETYPE_PKCS12\n#define SSL_FILETYPE_PKCS12 43\n#endif\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  if(strcasecompare(type, \"ENG\"))\n    return SSL_FILETYPE_ENGINE;\n  if(strcasecompare(type, \"P12\"))\n    return SSL_FILETYPE_PKCS12;\n  return -1;\n}\n\n#ifdef USE_OPENSSL_ENGINE\n/*\n * Supply default password to the engine user interface conversation.\n * The password is passed by OpenSSL engine from ENGINE_load_private_key()\n * last argument to the ui and can be obtained by UI_get0_user_data(ui) here.\n */\nstatic int ssl_ui_reader(UI *ui, UI_STRING *uis)\n{\n  const char *password;\n  switch(UI_get_string_type(uis)) {\n  case UIT_PROMPT:\n  case UIT_VERIFY:\n    password = (const char *)UI_get0_user_data(ui);\n    if(password && (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD)) {\n      UI_set_result(ui, uis, password);\n      return 1;\n    }\n  default:\n    break;\n  }\n  return (UI_method_get_reader(UI_OpenSSL()))(ui, uis);\n}\n\n/*\n * Suppress interactive request for a default password if available.\n */\nstatic int ssl_ui_writer(UI *ui, UI_STRING *uis)\n{\n  switch(UI_get_string_type(uis)) {\n  case UIT_PROMPT:\n  case UIT_VERIFY:\n    if(UI_get0_user_data(ui) &&\n       (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD)) {\n      return 1;\n    }\n  default:\n    break;\n  }\n  return (UI_method_get_writer(UI_OpenSSL()))(ui, uis);\n}\n\n/*\n * Check if a given string is a PKCS#11 URI\n */\nstatic bool is_pkcs11_uri(const char *string)\n{\n  return (string && strncasecompare(string, \"pkcs11:\", 7));\n}\n\n#endif\n\nstatic CURLcode ossl_set_engine(struct Curl_easy *data, const char *engine);\n\nstatic int\nSSL_CTX_use_certificate_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                             int type, const char *key_passwd)\n{\n  int ret = 0;\n  X509 *x = NULL;\n  /* the typecast of blob->len is fine since it is guaranteed to never be\n     larger than CURL_MAX_INPUT_LENGTH */\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(type == SSL_FILETYPE_ASN1) {\n    /* j = ERR_R_ASN1_LIB; */\n    x = d2i_X509_bio(in, NULL);\n  }\n  else if(type == SSL_FILETYPE_PEM) {\n    /* ERR_R_PEM_LIB; */\n    x = PEM_read_bio_X509(in, NULL,\n                          passwd_callback, (void *)key_passwd);\n  }\n  else {\n    ret = 0;\n    goto end;\n  }\n\n  if(!x) {\n    ret = 0;\n    goto end;\n  }\n\n  ret = SSL_CTX_use_certificate(ctx, x);\n end:\n  X509_free(x);\n  BIO_free(in);\n  return ret;\n}\n\nstatic int\nSSL_CTX_use_PrivateKey_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                           int type, const char *key_passwd)\n{\n  int ret = 0;\n  EVP_PKEY *pkey = NULL;\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(type == SSL_FILETYPE_PEM)\n    pkey = PEM_read_bio_PrivateKey(in, NULL, passwd_callback,\n                                   (void *)key_passwd);\n  else if(type == SSL_FILETYPE_ASN1)\n    pkey = d2i_PrivateKey_bio(in, NULL);\n  else {\n    ret = 0;\n    goto end;\n  }\n  if(!pkey) {\n    ret = 0;\n    goto end;\n  }\n  ret = SSL_CTX_use_PrivateKey(ctx, pkey);\n  EVP_PKEY_free(pkey);\n  end:\n  BIO_free(in);\n  return ret;\n}\n\nstatic int\nSSL_CTX_use_certificate_chain_blob(SSL_CTX *ctx, const struct curl_blob *blob,\n                                   const char *key_passwd)\n{\n/* SSL_CTX_add1_chain_cert introduced in OpenSSL 1.0.2 */\n#if (OPENSSL_VERSION_NUMBER >= 0x1000200fL) && /* OpenSSL 1.0.2 or later */ \\\n    !(defined(LIBRESSL_VERSION_NUMBER) && \\\n      (LIBRESSL_VERSION_NUMBER < 0x2090100fL)) /* LibreSSL 2.9.1 or later */\n  int ret = 0;\n  X509 *x = NULL;\n  void *passwd_callback_userdata = (void *)key_passwd;\n  BIO *in = BIO_new_mem_buf(blob->data, (int)(blob->len));\n  if(!in)\n    return CURLE_OUT_OF_MEMORY;\n\n  ERR_clear_error();\n\n  x = PEM_read_bio_X509_AUX(in, NULL,\n                            passwd_callback, (void *)key_passwd);\n\n  if(!x) {\n    ret = 0;\n    goto end;\n  }\n\n  ret = SSL_CTX_use_certificate(ctx, x);\n\n  if(ERR_peek_error() != 0)\n    ret = 0;\n\n  if(ret) {\n    X509 *ca;\n    unsigned long err;\n\n    if(!SSL_CTX_clear_chain_certs(ctx)) {\n      ret = 0;\n      goto end;\n    }\n\n    while((ca = PEM_read_bio_X509(in, NULL, passwd_callback,\n                                  passwd_callback_userdata))\n          != NULL) {\n\n      if(!SSL_CTX_add0_chain_cert(ctx, ca)) {\n        X509_free(ca);\n        ret = 0;\n        goto end;\n      }\n    }\n\n    err = ERR_peek_last_error();\n    if((ERR_GET_LIB(err) == ERR_LIB_PEM) &&\n       (ERR_GET_REASON(err) == PEM_R_NO_START_LINE))\n      ERR_clear_error();\n    else\n      ret = 0;\n  }\n\n end:\n  X509_free(x);\n  BIO_free(in);\n  return ret;\n#else\n  (void)ctx; /* unused */\n  (void)blob; /* unused */\n  (void)key_passwd; /* unused */\n  return 0;\n#endif\n}\n\nstatic\nint cert_stuff(struct Curl_easy *data,\n               SSL_CTX* ctx,\n               char *cert_file,\n               const struct curl_blob *cert_blob,\n               const char *cert_type,\n               char *key_file,\n               const struct curl_blob *key_blob,\n               const char *key_type,\n               char *key_passwd)\n{\n  char error_buffer[256];\n  bool check_privkey = TRUE;\n\n  int file_type = do_file_type(cert_type);\n\n  if(cert_file || cert_blob || (file_type == SSL_FILETYPE_ENGINE)) {\n    SSL *ssl;\n    X509 *x509;\n    int cert_done = 0;\n    int cert_use_result;\n\n    if(key_passwd) {\n      /* set the password in the callback userdata */\n      SSL_CTX_set_default_passwd_cb_userdata(ctx, key_passwd);\n      /* Set passwd callback: */\n      SSL_CTX_set_default_passwd_cb(ctx, passwd_callback);\n    }\n\n\n    switch(file_type) {\n    case SSL_FILETYPE_PEM:\n      /* SSL_CTX_use_certificate_chain_file() only works on PEM files */\n      cert_use_result = cert_blob ?\n        SSL_CTX_use_certificate_chain_blob(ctx, cert_blob, key_passwd) :\n        SSL_CTX_use_certificate_chain_file(ctx, cert_file);\n      if(cert_use_result != 1) {\n        failf(data,\n              \"could not load PEM client certificate, \" OSSL_PACKAGE\n              \" error %s, \"\n              \"(no key found, wrong pass phrase, or wrong file format?)\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        return 0;\n      }\n      break;\n\n    case SSL_FILETYPE_ASN1:\n      /* SSL_CTX_use_certificate_file() works with either PEM or ASN1, but\n         we use the case above for PEM so this can only be performed with\n         ASN1 files. */\n\n      cert_use_result = cert_blob ?\n        SSL_CTX_use_certificate_blob(ctx, cert_blob,\n                                     file_type, key_passwd) :\n        SSL_CTX_use_certificate_file(ctx, cert_file, file_type);\n      if(cert_use_result != 1) {\n        failf(data,\n              \"could not load ASN1 client certificate, \" OSSL_PACKAGE\n              \" error %s, \"\n              \"(no key found, wrong pass phrase, or wrong file format?)\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        return 0;\n      }\n      break;\n    case SSL_FILETYPE_ENGINE:\n#if defined(USE_OPENSSL_ENGINE) && defined(ENGINE_CTRL_GET_CMD_FROM_NAME)\n      {\n        /* Implicitly use pkcs11 engine if none was provided and the\n         * cert_file is a PKCS#11 URI */\n        if(!data->state.engine) {\n          if(is_pkcs11_uri(cert_file)) {\n            if(ossl_set_engine(data, \"pkcs11\") != CURLE_OK) {\n              return 0;\n            }\n          }\n        }\n\n        if(data->state.engine) {\n          const char *cmd_name = \"LOAD_CERT_CTRL\";\n          struct {\n            const char *cert_id;\n            X509 *cert;\n          } params;\n\n          params.cert_id = cert_file;\n          params.cert = NULL;\n\n          /* Does the engine supports LOAD_CERT_CTRL ? */\n          if(!ENGINE_ctrl(data->state.engine, ENGINE_CTRL_GET_CMD_FROM_NAME,\n                          0, (void *)cmd_name, NULL)) {\n            failf(data, \"ssl engine does not support loading certificates\");\n            return 0;\n          }\n\n          /* Load the certificate from the engine */\n          if(!ENGINE_ctrl_cmd(data->state.engine, cmd_name,\n                              0, &params, NULL, 1)) {\n            failf(data, \"ssl engine cannot load client cert with id\"\n                  \" '%s' [%s]\", cert_file,\n                  ossl_strerror(ERR_get_error(), error_buffer,\n                                sizeof(error_buffer)));\n            return 0;\n          }\n\n          if(!params.cert) {\n            failf(data, \"ssl engine didn't initialized the certificate \"\n                  \"properly.\");\n            return 0;\n          }\n\n          if(SSL_CTX_use_certificate(ctx, params.cert) != 1) {\n            failf(data, \"unable to set client certificate\");\n            X509_free(params.cert);\n            return 0;\n          }\n          X509_free(params.cert); /* we don't need the handle any more... */\n        }\n        else {\n          failf(data, \"crypto engine not set, can't load certificate\");\n          return 0;\n        }\n      }\n      break;\n#else\n      failf(data, \"file type ENG for certificate not implemented\");\n      return 0;\n#endif\n\n    case SSL_FILETYPE_PKCS12:\n    {\n      BIO *cert_bio = NULL;\n      PKCS12 *p12 = NULL;\n      EVP_PKEY *pri;\n      STACK_OF(X509) *ca = NULL;\n      if(cert_blob) {\n        cert_bio = BIO_new_mem_buf(cert_blob->data, (int)(cert_blob->len));\n        if(!cert_bio) {\n          failf(data,\n                \"BIO_new_mem_buf NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          return 0;\n        }\n      }\n      else {\n        cert_bio = BIO_new(BIO_s_file());\n        if(!cert_bio) {\n          failf(data,\n                \"BIO_new return NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          return 0;\n        }\n\n        if(BIO_read_filename(cert_bio, cert_file) <= 0) {\n          failf(data, \"could not open PKCS12 file '%s'\", cert_file);\n          BIO_free(cert_bio);\n          return 0;\n        }\n      }\n\n      p12 = d2i_PKCS12_bio(cert_bio, NULL);\n      BIO_free(cert_bio);\n\n      if(!p12) {\n        failf(data, \"error reading PKCS12 file '%s'\",\n              cert_blob ? \"(memory blob)\" : cert_file);\n        return 0;\n      }\n\n      PKCS12_PBE_add();\n\n      if(!PKCS12_parse(p12, key_passwd, &pri, &x509,\n                       &ca)) {\n        failf(data,\n              \"could not parse PKCS12 file, check password, \" OSSL_PACKAGE\n              \" error %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        PKCS12_free(p12);\n        return 0;\n      }\n\n      PKCS12_free(p12);\n\n      if(SSL_CTX_use_certificate(ctx, x509) != 1) {\n        failf(data,\n              \"could not load PKCS12 client certificate, \" OSSL_PACKAGE\n              \" error %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)) );\n        goto fail;\n      }\n\n      if(SSL_CTX_use_PrivateKey(ctx, pri) != 1) {\n        failf(data, \"unable to use private key from PKCS12 file '%s'\",\n              cert_file);\n        goto fail;\n      }\n\n      if(!SSL_CTX_check_private_key (ctx)) {\n        failf(data, \"private key from PKCS12 file '%s' \"\n              \"does not match certificate in same file\", cert_file);\n        goto fail;\n      }\n      /* Set Certificate Verification chain */\n      if(ca) {\n        while(sk_X509_num(ca)) {\n          /*\n           * Note that sk_X509_pop() is used below to make sure the cert is\n           * removed from the stack properly before getting passed to\n           * SSL_CTX_add_extra_chain_cert(), which takes ownership. Previously\n           * we used sk_X509_value() instead, but then we'd clean it in the\n           * subsequent sk_X509_pop_free() call.\n           */\n          X509 *x = sk_X509_pop(ca);\n          if(!SSL_CTX_add_client_CA(ctx, x)) {\n            X509_free(x);\n            failf(data, \"cannot add certificate to client CA list\");\n            goto fail;\n          }\n          if(!SSL_CTX_add_extra_chain_cert(ctx, x)) {\n            X509_free(x);\n            failf(data, \"cannot add certificate to certificate chain\");\n            goto fail;\n          }\n        }\n      }\n\n      cert_done = 1;\n  fail:\n      EVP_PKEY_free(pri);\n      X509_free(x509);\n#ifdef USE_AMISSL\n      sk_X509_pop_free(ca, Curl_amiga_X509_free);\n#else\n      sk_X509_pop_free(ca, X509_free);\n#endif\n      if(!cert_done)\n        return 0; /* failure! */\n      break;\n    }\n    default:\n      failf(data, \"not supported file type '%s' for certificate\", cert_type);\n      return 0;\n    }\n\n    if((!key_file) && (!key_blob)) {\n      key_file = cert_file;\n      key_blob = cert_blob;\n    }\n    else\n      file_type = do_file_type(key_type);\n\n    switch(file_type) {\n    case SSL_FILETYPE_PEM:\n      if(cert_done)\n        break;\n      /* FALLTHROUGH */\n    case SSL_FILETYPE_ASN1:\n      cert_use_result = key_blob ?\n        SSL_CTX_use_PrivateKey_blob(ctx, key_blob, file_type, key_passwd) :\n        SSL_CTX_use_PrivateKey_file(ctx, key_file, file_type);\n      if(cert_use_result != 1) {\n        failf(data, \"unable to set private key file: '%s' type %s\",\n              key_file?key_file:\"(memory blob)\", key_type?key_type:\"PEM\");\n        return 0;\n      }\n      break;\n    case SSL_FILETYPE_ENGINE:\n#ifdef USE_OPENSSL_ENGINE\n      {                         /* XXXX still needs some work */\n        EVP_PKEY *priv_key = NULL;\n\n        /* Implicitly use pkcs11 engine if none was provided and the\n         * key_file is a PKCS#11 URI */\n        if(!data->state.engine) {\n          if(is_pkcs11_uri(key_file)) {\n            if(ossl_set_engine(data, \"pkcs11\") != CURLE_OK) {\n              return 0;\n            }\n          }\n        }\n\n        if(data->state.engine) {\n          UI_METHOD *ui_method =\n            UI_create_method((char *)\"curl user interface\");\n          if(!ui_method) {\n            failf(data, \"unable do create \" OSSL_PACKAGE\n                  \" user-interface method\");\n            return 0;\n          }\n          UI_method_set_opener(ui_method, UI_method_get_opener(UI_OpenSSL()));\n          UI_method_set_closer(ui_method, UI_method_get_closer(UI_OpenSSL()));\n          UI_method_set_reader(ui_method, ssl_ui_reader);\n          UI_method_set_writer(ui_method, ssl_ui_writer);\n          /* the typecast below was added to please mingw32 */\n          priv_key = (EVP_PKEY *)\n            ENGINE_load_private_key(data->state.engine, key_file,\n                                    ui_method,\n                                    key_passwd);\n          UI_destroy_method(ui_method);\n          if(!priv_key) {\n            failf(data, \"failed to load private key from crypto engine\");\n            return 0;\n          }\n          if(SSL_CTX_use_PrivateKey(ctx, priv_key) != 1) {\n            failf(data, \"unable to set private key\");\n            EVP_PKEY_free(priv_key);\n            return 0;\n          }\n          EVP_PKEY_free(priv_key);  /* we don't need the handle any more... */\n        }\n        else {\n          failf(data, \"crypto engine not set, can't load private key\");\n          return 0;\n        }\n      }\n      break;\n#else\n      failf(data, \"file type ENG for private key not supported\");\n      return 0;\n#endif\n    case SSL_FILETYPE_PKCS12:\n      if(!cert_done) {\n        failf(data, \"file type P12 for private key not supported\");\n        return 0;\n      }\n      break;\n    default:\n      failf(data, \"not supported file type for private key\");\n      return 0;\n    }\n\n    ssl = SSL_new(ctx);\n    if(!ssl) {\n      failf(data, \"unable to create an SSL structure\");\n      return 0;\n    }\n\n    x509 = SSL_get_certificate(ssl);\n\n    /* This version was provided by Evan Jordan and is supposed to not\n       leak memory as the previous version: */\n    if(x509) {\n      EVP_PKEY *pktmp = X509_get_pubkey(x509);\n      EVP_PKEY_copy_parameters(pktmp, SSL_get_privatekey(ssl));\n      EVP_PKEY_free(pktmp);\n    }\n\n#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_IS_BORINGSSL)\n    {\n      /* If RSA is used, don't check the private key if its flags indicate\n       * it doesn't support it. */\n      EVP_PKEY *priv_key = SSL_get_privatekey(ssl);\n      int pktype;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n      pktype = EVP_PKEY_id(priv_key);\n#else\n      pktype = priv_key->type;\n#endif\n      if(pktype == EVP_PKEY_RSA) {\n        RSA *rsa = EVP_PKEY_get1_RSA(priv_key);\n        if(RSA_flags(rsa) & RSA_METHOD_FLAG_NO_CHECK)\n          check_privkey = FALSE;\n        RSA_free(rsa); /* Decrement reference count */\n      }\n    }\n#endif\n\n    SSL_free(ssl);\n\n    /* If we are using DSA, we can copy the parameters from\n     * the private key */\n\n    if(check_privkey == TRUE) {\n      /* Now we know that a key and cert have been set against\n       * the SSL context */\n      if(!SSL_CTX_check_private_key(ctx)) {\n        failf(data, \"Private key does not match the certificate public key\");\n        return 0;\n      }\n    }\n  }\n  return 1;\n}\n\n/* returns non-zero on failure */\nstatic int x509_name_oneline(X509_NAME *a, char *buf, size_t size)\n{\n  BIO *bio_out = BIO_new(BIO_s_mem());\n  BUF_MEM *biomem;\n  int rc;\n\n  if(!bio_out)\n    return 1; /* alloc failed! */\n\n  rc = X509_NAME_print_ex(bio_out, a, 0, XN_FLAG_SEP_SPLUS_SPC);\n  BIO_get_mem_ptr(bio_out, &biomem);\n\n  if((size_t)biomem->length < size)\n    size = biomem->length;\n  else\n    size--; /* don't overwrite the buffer end */\n\n  memcpy(buf, biomem->data, size);\n  buf[size] = 0;\n\n  BIO_free(bio_out);\n\n  return !rc;\n}\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nstatic int ossl_init(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) &&  \\\n  !defined(LIBRESSL_VERSION_NUMBER)\n  const uint64_t flags =\n#ifdef OPENSSL_INIT_ENGINE_ALL_BUILTIN\n    /* not present in BoringSSL */\n    OPENSSL_INIT_ENGINE_ALL_BUILTIN |\n#endif\n#ifdef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG\n    OPENSSL_INIT_NO_LOAD_CONFIG |\n#else\n    OPENSSL_INIT_LOAD_CONFIG |\n#endif\n    0;\n  OPENSSL_init_ssl(flags, NULL);\n#else\n  OPENSSL_load_builtin_modules();\n\n#ifdef USE_OPENSSL_ENGINE\n  ENGINE_load_builtin_engines();\n#endif\n\n/* CONF_MFLAGS_DEFAULT_SECTION was introduced some time between 0.9.8b and\n   0.9.8e */\n#ifndef CONF_MFLAGS_DEFAULT_SECTION\n#define CONF_MFLAGS_DEFAULT_SECTION 0x0\n#endif\n\n#ifndef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG\n  CONF_modules_load_file(NULL, NULL,\n                         CONF_MFLAGS_DEFAULT_SECTION|\n                         CONF_MFLAGS_IGNORE_MISSING_FILE);\n#endif\n\n  /* Lets get nice error messages */\n  SSL_load_error_strings();\n\n  /* Init the global ciphers and digests */\n  if(!SSLeay_add_ssl_algorithms())\n    return 0;\n\n  OpenSSL_add_all_algorithms();\n#endif\n\n  Curl_tls_keylog_open();\n\n  /* Initialize the extra data indexes */\n  if(ossl_get_ssl_data_index() < 0 || ossl_get_ssl_conn_index() < 0 ||\n     ossl_get_ssl_sockindex_index() < 0 || ossl_get_proxy_index() < 0)\n    return 0;\n\n  return 1;\n}\n\n/* Global cleanup */\nstatic void ossl_cleanup(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && \\\n    !defined(LIBRESSL_VERSION_NUMBER)\n  /* OpenSSL 1.1 deprecates all these cleanup functions and\n     turns them into no-ops in OpenSSL 1.0 compatibility mode */\n#else\n  /* Free ciphers and digests lists */\n  EVP_cleanup();\n\n#ifdef USE_OPENSSL_ENGINE\n  /* Free engine list */\n  ENGINE_cleanup();\n#endif\n\n  /* Free OpenSSL error strings */\n  ERR_free_strings();\n\n  /* Free thread local error state, destroying hash upon zero refcount */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n  ERR_remove_thread_state(NULL);\n#else\n  ERR_remove_state(0);\n#endif\n\n  /* Free all memory allocated by all configuration modules */\n  CONF_modules_free();\n\n#ifdef HAVE_SSL_COMP_FREE_COMPRESSION_METHODS\n  SSL_COMP_free_compression_methods();\n#endif\n#endif\n\n  Curl_tls_keylog_close();\n}\n\n/*\n * This function is used to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int ossl_check_cxn(struct connectdata *conn)\n{\n  /* SSL_peek takes data out of the raw recv buffer without peeking so we use\n     recv MSG_PEEK instead. Bug #795 */\n#ifdef MSG_PEEK\n  char buf;\n  ssize_t nread;\n  nread = recv((RECV_TYPE_ARG1)conn->sock[FIRSTSOCKET], (RECV_TYPE_ARG2)&buf,\n               (RECV_TYPE_ARG3)1, (RECV_TYPE_ARG4)MSG_PEEK);\n  if(nread == 0)\n    return 0; /* connection has been closed */\n  if(nread == 1)\n    return 1; /* connection still in place */\n  else if(nread == -1) {\n      int err = SOCKERRNO;\n      if(err == EINPROGRESS ||\n#if defined(EAGAIN) && (EAGAIN != EWOULDBLOCK)\n         err == EAGAIN ||\n#endif\n         err == EWOULDBLOCK)\n        return 1; /* connection still in place */\n      if(err == ECONNRESET ||\n#ifdef ECONNABORTED\n         err == ECONNABORTED ||\n#endif\n#ifdef ENETDOWN\n         err == ENETDOWN ||\n#endif\n#ifdef ENETRESET\n         err == ENETRESET ||\n#endif\n#ifdef ESHUTDOWN\n         err == ESHUTDOWN ||\n#endif\n#ifdef ETIMEDOUT\n         err == ETIMEDOUT ||\n#endif\n         err == ENOTCONN)\n        return 0; /* connection has been closed */\n  }\n#endif\n  return -1; /* connection status unknown */\n}\n\n/* Selects an OpenSSL crypto engine\n */\nstatic CURLcode ossl_set_engine(struct Curl_easy *data, const char *engine)\n{\n#ifdef USE_OPENSSL_ENGINE\n  ENGINE *e;\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n  e = ENGINE_by_id(engine);\n#else\n  /* avoid memory leak */\n  for(e = ENGINE_get_first(); e; e = ENGINE_get_next(e)) {\n    const char *e_id = ENGINE_get_id(e);\n    if(!strcmp(engine, e_id))\n      break;\n  }\n#endif\n\n  if(!e) {\n    failf(data, \"SSL Engine '%s' not found\", engine);\n    return CURLE_SSL_ENGINE_NOTFOUND;\n  }\n\n  if(data->state.engine) {\n    ENGINE_finish(data->state.engine);\n    ENGINE_free(data->state.engine);\n    data->state.engine = NULL;\n  }\n  if(!ENGINE_init(e)) {\n    char buf[256];\n\n    ENGINE_free(e);\n    failf(data, \"Failed to initialise SSL Engine '%s': %s\",\n          engine, ossl_strerror(ERR_get_error(), buf, sizeof(buf)));\n    return CURLE_SSL_ENGINE_INITFAILED;\n  }\n  data->state.engine = e;\n  return CURLE_OK;\n#else\n  (void)engine;\n  failf(data, \"SSL Engine not supported\");\n  return CURLE_SSL_ENGINE_NOTFOUND;\n#endif\n}\n\n/* Sets engine as default for all SSL operations\n */\nstatic CURLcode ossl_set_engine_default(struct Curl_easy *data)\n{\n#ifdef USE_OPENSSL_ENGINE\n  if(data->state.engine) {\n    if(ENGINE_set_default(data->state.engine, ENGINE_METHOD_ALL) > 0) {\n      infof(data, \"set default crypto engine '%s'\\n\",\n            ENGINE_get_id(data->state.engine));\n    }\n    else {\n      failf(data, \"set default crypto engine '%s' failed\",\n            ENGINE_get_id(data->state.engine));\n      return CURLE_SSL_ENGINE_SETFAILED;\n    }\n  }\n#else\n  (void) data;\n#endif\n  return CURLE_OK;\n}\n\n/* Return list of OpenSSL crypto engine names.\n */\nstatic struct curl_slist *ossl_engines_list(struct Curl_easy *data)\n{\n  struct curl_slist *list = NULL;\n#ifdef USE_OPENSSL_ENGINE\n  struct curl_slist *beg;\n  ENGINE *e;\n\n  for(e = ENGINE_get_first(); e; e = ENGINE_get_next(e)) {\n    beg = curl_slist_append(list, ENGINE_get_id(e));\n    if(!beg) {\n      curl_slist_free_all(list);\n      return NULL;\n    }\n    list = beg;\n  }\n#endif\n  (void) data;\n  return list;\n}\n\n#define set_logger(conn, data)                  \\\n  conn->ssl[0].backend->logger = data\n\nstatic void ossl_closeone(struct Curl_easy *data,\n                          struct connectdata *conn,\n                          struct ssl_connect_data *connssl)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->handle) {\n    set_logger(conn, data);\n    (void)SSL_shutdown(backend->handle);\n    SSL_set_connect_state(backend->handle);\n\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  if(backend->ctx) {\n    SSL_CTX_free(backend->ctx);\n    backend->ctx = NULL;\n  }\n}\n\n/*\n * This function is called when an SSL connection is closed.\n */\nstatic void ossl_close(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ossl_closeone(data, conn, &conn->ssl[sockindex]);\n#ifndef CURL_DISABLE_PROXY\n  ossl_closeone(data, conn, &conn->proxy_ssl[sockindex]);\n#endif\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int ossl_shutdown(struct Curl_easy *data,\n                         struct connectdata *conn, int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char buf[256]; /* We will use this for the OpenSSL error buffer, so it has\n                    to be at least 256 bytes long. */\n  unsigned long sslerror;\n  ssize_t nread;\n  int buffsize;\n  int err;\n  bool done = FALSE;\n  struct ssl_backend_data *backend = connssl->backend;\n\n#ifndef CURL_DISABLE_FTP\n  /* This has only been tested on the proftpd server, and the mod_tls code\n     sends a close notify alert without waiting for a close notify alert in\n     response. Thus we wait for a close notify alert from the server, but\n     we do not send one. Let's hope other servers do the same... */\n\n  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)\n      (void)SSL_shutdown(backend->handle);\n#endif\n\n  if(backend->handle) {\n    buffsize = (int)sizeof(buf);\n    while(!done) {\n      int what = SOCKET_READABLE(conn->sock[sockindex],\n                                 SSL_SHUTDOWN_TIMEOUT);\n      if(what > 0) {\n        ERR_clear_error();\n\n        /* Something to read, let's do it and hope that it is the close\n           notify alert from the server */\n        nread = (ssize_t)SSL_read(backend->handle, buf, buffsize);\n        err = SSL_get_error(backend->handle, (int)nread);\n\n        switch(err) {\n        case SSL_ERROR_NONE: /* this is not an error */\n        case SSL_ERROR_ZERO_RETURN: /* no more data */\n          /* This is the expected response. There was no data but only\n             the close notify alert */\n          done = TRUE;\n          break;\n        case SSL_ERROR_WANT_READ:\n          /* there's data pending, re-invoke SSL_read() */\n          infof(data, \"SSL_ERROR_WANT_READ\\n\");\n          break;\n        case SSL_ERROR_WANT_WRITE:\n          /* SSL wants a write. Really odd. Let's bail out. */\n          infof(data, \"SSL_ERROR_WANT_WRITE\\n\");\n          done = TRUE;\n          break;\n        default:\n          /* openssl/ssl.h says \"look at error stack/return value/errno\" */\n          sslerror = ERR_get_error();\n          failf(data, OSSL_PACKAGE \" SSL_read on shutdown: %s, errno %d\",\n                (sslerror ?\n                 ossl_strerror(sslerror, buf, sizeof(buf)) :\n                 SSL_ERROR_to_str(err)),\n                SOCKERRNO);\n          done = TRUE;\n          break;\n        }\n      }\n      else if(0 == what) {\n        /* timeout */\n        failf(data, \"SSL shutdown timeout\");\n        done = TRUE;\n      }\n      else {\n        /* anything that gets here is fatally bad */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        retval = -1;\n        done = TRUE;\n      }\n    } /* while()-loop for the select() */\n\n    if(data->set.verbose) {\n#ifdef HAVE_SSL_GET_SHUTDOWN\n      switch(SSL_get_shutdown(backend->handle)) {\n      case SSL_SENT_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_SENT_SHUTDOWN\\n\");\n        break;\n      case SSL_RECEIVED_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_RECEIVED_SHUTDOWN\\n\");\n        break;\n      case SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN:\n        infof(data, \"SSL_get_shutdown() returned SSL_SENT_SHUTDOWN|\"\n              \"SSL_RECEIVED__SHUTDOWN\\n\");\n        break;\n      }\n#endif\n    }\n\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  return retval;\n}\n\nstatic void ossl_session_free(void *ptr)\n{\n  /* free the ID */\n  SSL_SESSION_free(ptr);\n}\n\n/*\n * This function is called when the 'data' struct is going away. Close\n * down everything and free all resources!\n */\nstatic void ossl_close_all(struct Curl_easy *data)\n{\n#ifdef USE_OPENSSL_ENGINE\n  if(data->state.engine) {\n    ENGINE_finish(data->state.engine);\n    ENGINE_free(data->state.engine);\n    data->state.engine = NULL;\n  }\n#else\n  (void)data;\n#endif\n#if !defined(HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED) && \\\n  defined(HAVE_ERR_REMOVE_THREAD_STATE)\n  /* OpenSSL 1.0.1 and 1.0.2 build an error queue that is stored per-thread\n     so we need to clean it here in case the thread will be killed. All OpenSSL\n     code should extract the error in association with the error so clearing\n     this queue here should be harmless at worst. */\n  ERR_remove_thread_state(NULL);\n#endif\n}\n\n/* ====================================================== */\n\n/*\n * Match subjectAltName against the host name. This requires a conversion\n * in CURL_DOES_CONVERSIONS builds.\n */\nstatic bool subj_alt_hostcheck(struct Curl_easy *data,\n                               const char *match_pattern, const char *hostname,\n                               const char *dispname)\n#ifdef CURL_DOES_CONVERSIONS\n{\n  bool res = FALSE;\n\n  /* Curl_cert_hostcheck uses host encoding, but we get ASCII from\n     OpenSSl.\n   */\n  char *match_pattern2 = strdup(match_pattern);\n\n  if(match_pattern2) {\n    if(Curl_convert_from_network(data, match_pattern2,\n                                strlen(match_pattern2)) == CURLE_OK) {\n      if(Curl_cert_hostcheck(match_pattern2, hostname)) {\n        res = TRUE;\n        infof(data,\n                \" subjectAltName: host \\\"%s\\\" matched cert's \\\"%s\\\"\\n\",\n                dispname, match_pattern2);\n      }\n    }\n    free(match_pattern2);\n  }\n  else {\n    failf(data,\n        \"SSL: out of memory when allocating temporary for subjectAltName\");\n  }\n  return res;\n}\n#else\n{\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n  (void)dispname;\n  (void)data;\n#endif\n  if(Curl_cert_hostcheck(match_pattern, hostname)) {\n    infof(data, \" subjectAltName: host \\\"%s\\\" matched cert's \\\"%s\\\"\\n\",\n                  dispname, match_pattern);\n    return TRUE;\n  }\n  return FALSE;\n}\n#endif\n\n\n/* Quote from RFC2818 section 3.1 \"Server Identity\"\n\n   If a subjectAltName extension of type dNSName is present, that MUST\n   be used as the identity. Otherwise, the (most specific) Common Name\n   field in the Subject field of the certificate MUST be used. Although\n   the use of the Common Name is existing practice, it is deprecated and\n   Certification Authorities are encouraged to use the dNSName instead.\n\n   Matching is performed using the matching rules specified by\n   [RFC2459].  If more than one identity of a given type is present in\n   the certificate (e.g., more than one dNSName name, a match in any one\n   of the set is considered acceptable.) Names may contain the wildcard\n   character * which is considered to match any single domain name\n   component or component fragment. E.g., *.a.com matches foo.a.com but\n   not bar.foo.a.com. f*.com matches foo.com but not bar.com.\n\n   In some cases, the URI is specified as an IP address rather than a\n   hostname. In this case, the iPAddress subjectAltName must be present\n   in the certificate and must exactly match the IP in the URI.\n\n*/\nstatic CURLcode verifyhost(struct Curl_easy *data, struct connectdata *conn,\n                           X509 *server_cert)\n{\n  bool matched = FALSE;\n  int target = GEN_DNS; /* target type, GEN_DNS or GEN_IPADD */\n  size_t addrlen = 0;\n  STACK_OF(GENERAL_NAME) *altnames;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n  CURLcode result = CURLE_OK;\n  bool dNSName = FALSE; /* if a dNSName field exists in the cert */\n  bool iPAddress = FALSE; /* if a iPAddress field exists in the cert */\n  const char * const hostname = SSL_HOST_NAME();\n  const char * const dispname = SSL_HOST_DISPNAME();\n\n#ifdef ENABLE_IPV6\n  if(conn->bits.ipv6_ip &&\n     Curl_inet_pton(AF_INET6, hostname, &addr)) {\n    target = GEN_IPADD;\n    addrlen = sizeof(struct in6_addr);\n  }\n  else\n#endif\n    if(Curl_inet_pton(AF_INET, hostname, &addr)) {\n      target = GEN_IPADD;\n      addrlen = sizeof(struct in_addr);\n    }\n\n  /* get a \"list\" of alternative names */\n  altnames = X509_get_ext_d2i(server_cert, NID_subject_alt_name, NULL, NULL);\n\n  if(altnames) {\n#ifdef OPENSSL_IS_BORINGSSL\n    size_t numalts;\n    size_t i;\n#else\n    int numalts;\n    int i;\n#endif\n    bool dnsmatched = FALSE;\n    bool ipmatched = FALSE;\n\n    /* get amount of alternatives, RFC2459 claims there MUST be at least\n       one, but we don't depend on it... */\n    numalts = sk_GENERAL_NAME_num(altnames);\n\n    /* loop through all alternatives - until a dnsmatch */\n    for(i = 0; (i < numalts) && !dnsmatched; i++) {\n      /* get a handle to alternative name number i */\n      const GENERAL_NAME *check = sk_GENERAL_NAME_value(altnames, i);\n\n      if(check->type == GEN_DNS)\n        dNSName = TRUE;\n      else if(check->type == GEN_IPADD)\n        iPAddress = TRUE;\n\n      /* only check alternatives of the same type the target is */\n      if(check->type == target) {\n        /* get data and length */\n        const char *altptr = (char *)ASN1_STRING_get0_data(check->d.ia5);\n        size_t altlen = (size_t) ASN1_STRING_length(check->d.ia5);\n\n        switch(target) {\n        case GEN_DNS: /* name/pattern comparison */\n          /* The OpenSSL man page explicitly says: \"In general it cannot be\n             assumed that the data returned by ASN1_STRING_data() is null\n             terminated or does not contain embedded nulls.\" But also that\n             \"The actual format of the data will depend on the actual string\n             type itself: for example for an IA5String the data will be ASCII\"\n\n             It has been however verified that in 0.9.6 and 0.9.7, IA5String\n             is always null-terminated.\n          */\n          if((altlen == strlen(altptr)) &&\n             /* if this isn't true, there was an embedded zero in the name\n                string and we cannot match it. */\n             subj_alt_hostcheck(data, altptr, hostname, dispname)) {\n            dnsmatched = TRUE;\n          }\n          break;\n\n        case GEN_IPADD: /* IP address comparison */\n          /* compare alternative IP address if the data chunk is the same size\n             our server IP address is */\n          if((altlen == addrlen) && !memcmp(altptr, &addr, altlen)) {\n            ipmatched = TRUE;\n            infof(data,\n                  \" subjectAltName: host \\\"%s\\\" matched cert's IP address!\\n\",\n                  dispname);\n          }\n          break;\n        }\n      }\n    }\n    GENERAL_NAMES_free(altnames);\n\n    if(dnsmatched || ipmatched)\n      matched = TRUE;\n  }\n\n  if(matched)\n    /* an alternative name matched */\n    ;\n  else if(dNSName || iPAddress) {\n    infof(data, \" subjectAltName does not match %s\\n\", dispname);\n    failf(data, \"SSL: no alternative certificate subject name matches \"\n          \"target host name '%s'\", dispname);\n    result = CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else {\n    /* we have to look to the last occurrence of a commonName in the\n       distinguished one to get the most significant one. */\n    int j, i = -1;\n\n    /* The following is done because of a bug in 0.9.6b */\n\n    unsigned char *nulstr = (unsigned char *)\"\";\n    unsigned char *peer_CN = nulstr;\n\n    X509_NAME *name = X509_get_subject_name(server_cert);\n    if(name)\n      while((j = X509_NAME_get_index_by_NID(name, NID_commonName, i)) >= 0)\n        i = j;\n\n    /* we have the name entry and we will now convert this to a string\n       that we can use for comparison. Doing this we support BMPstring,\n       UTF8 etc. */\n\n    if(i >= 0) {\n      ASN1_STRING *tmp =\n        X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, i));\n\n      /* In OpenSSL 0.9.7d and earlier, ASN1_STRING_to_UTF8 fails if the input\n         is already UTF-8 encoded. We check for this case and copy the raw\n         string manually to avoid the problem. This code can be made\n         conditional in the future when OpenSSL has been fixed. */\n      if(tmp) {\n        if(ASN1_STRING_type(tmp) == V_ASN1_UTF8STRING) {\n          j = ASN1_STRING_length(tmp);\n          if(j >= 0) {\n            peer_CN = OPENSSL_malloc(j + 1);\n            if(peer_CN) {\n              memcpy(peer_CN, ASN1_STRING_get0_data(tmp), j);\n              peer_CN[j] = '\\0';\n            }\n          }\n        }\n        else /* not a UTF8 name */\n          j = ASN1_STRING_to_UTF8(&peer_CN, tmp);\n\n        if(peer_CN && (curlx_uztosi(strlen((char *)peer_CN)) != j)) {\n          /* there was a terminating zero before the end of string, this\n             cannot match and we return failure! */\n          failf(data, \"SSL: illegal cert name field\");\n          result = CURLE_PEER_FAILED_VERIFICATION;\n        }\n      }\n    }\n\n    if(peer_CN == nulstr)\n       peer_CN = NULL;\n    else {\n      /* convert peer_CN from UTF8 */\n      CURLcode rc = Curl_convert_from_utf8(data, (char *)peer_CN,\n                                           strlen((char *)peer_CN));\n      /* Curl_convert_from_utf8 calls failf if unsuccessful */\n      if(rc) {\n        OPENSSL_free(peer_CN);\n        return rc;\n      }\n    }\n\n    if(result)\n      /* error already detected, pass through */\n      ;\n    else if(!peer_CN) {\n      failf(data,\n            \"SSL: unable to obtain common name from peer certificate\");\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else if(!Curl_cert_hostcheck((const char *)peer_CN, hostname)) {\n      failf(data, \"SSL: certificate subject name '%s' does not match \"\n            \"target host name '%s'\", peer_CN, dispname);\n      result = CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else {\n      infof(data, \" common name: %s (matched)\\n\", peer_CN);\n    }\n    if(peer_CN)\n      OPENSSL_free(peer_CN);\n  }\n\n  return result;\n}\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\nstatic CURLcode verifystatus(struct Curl_easy *data,\n                             struct ssl_connect_data *connssl)\n{\n  int i, ocsp_status;\n  unsigned char *status;\n  const unsigned char *p;\n  CURLcode result = CURLE_OK;\n  OCSP_RESPONSE *rsp = NULL;\n  OCSP_BASICRESP *br = NULL;\n  X509_STORE     *st = NULL;\n  STACK_OF(X509) *ch = NULL;\n  struct ssl_backend_data *backend = connssl->backend;\n  X509 *cert;\n  OCSP_CERTID *id = NULL;\n  int cert_status, crl_reason;\n  ASN1_GENERALIZEDTIME *rev, *thisupd, *nextupd;\n  int ret;\n\n  long len = SSL_get_tlsext_status_ocsp_resp(backend->handle, &status);\n\n  if(!status) {\n    failf(data, \"No OCSP response received\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n  p = status;\n  rsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n  if(!rsp) {\n    failf(data, \"Invalid OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  ocsp_status = OCSP_response_status(rsp);\n  if(ocsp_status != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n    failf(data, \"Invalid OCSP response status: %s (%d)\",\n          OCSP_response_status_str(ocsp_status), ocsp_status);\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  br = OCSP_response_get1_basic(rsp);\n  if(!br) {\n    failf(data, \"Invalid OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  ch = SSL_get_peer_cert_chain(backend->handle);\n  st = SSL_CTX_get_cert_store(backend->ctx);\n\n#if ((OPENSSL_VERSION_NUMBER <= 0x1000201fL) /* Fixed after 1.0.2a */ || \\\n     (defined(LIBRESSL_VERSION_NUMBER) &&                               \\\n      LIBRESSL_VERSION_NUMBER <= 0x2040200fL))\n  /* The authorized responder cert in the OCSP response MUST be signed by the\n     peer cert's issuer (see RFC6960 section 4.2.2.2). If that's a root cert,\n     no problem, but if it's an intermediate cert OpenSSL has a bug where it\n     expects this issuer to be present in the chain embedded in the OCSP\n     response. So we add it if necessary. */\n\n  /* First make sure the peer cert chain includes both a peer and an issuer,\n     and the OCSP response contains a responder cert. */\n  if(sk_X509_num(ch) >= 2 && sk_X509_num(br->certs) >= 1) {\n    X509 *responder = sk_X509_value(br->certs, sk_X509_num(br->certs) - 1);\n\n    /* Find issuer of responder cert and add it to the OCSP response chain */\n    for(i = 0; i < sk_X509_num(ch); i++) {\n      X509 *issuer = sk_X509_value(ch, i);\n      if(X509_check_issued(issuer, responder) == X509_V_OK) {\n        if(!OCSP_basic_add1_cert(br, issuer)) {\n          failf(data, \"Could not add issuer cert to OCSP response\");\n          result = CURLE_SSL_INVALIDCERTSTATUS;\n          goto end;\n        }\n      }\n    }\n  }\n#endif\n\n  if(OCSP_basic_verify(br, ch, st, 0) <= 0) {\n    failf(data, \"OCSP response verification failed\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Compute the certificate's ID */\n  cert = SSL_get_peer_certificate(backend->handle);\n  if(!cert) {\n    failf(data, \"Error getting peer certificate\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  for(i = 0; i < sk_X509_num(ch); i++) {\n    X509 *issuer = sk_X509_value(ch, i);\n    if(X509_check_issued(issuer, cert) == X509_V_OK) {\n      id = OCSP_cert_to_id(EVP_sha1(), cert, issuer);\n      break;\n    }\n  }\n  X509_free(cert);\n\n  if(!id) {\n    failf(data, \"Error computing OCSP ID\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Find the single OCSP response corresponding to the certificate ID */\n  ret = OCSP_resp_find_status(br, id, &cert_status, &crl_reason, &rev,\n                              &thisupd, &nextupd);\n  OCSP_CERTID_free(id);\n  if(ret != 1) {\n    failf(data, \"Could not find certificate ID in OCSP response\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  /* Validate the corresponding single OCSP response */\n  if(!OCSP_check_validity(thisupd, nextupd, 300L, -1L)) {\n    failf(data, \"OCSP response has expired\");\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\n  infof(data, \"SSL certificate status: %s (%d)\\n\",\n        OCSP_cert_status_str(cert_status), cert_status);\n\n  switch(cert_status) {\n  case V_OCSP_CERTSTATUS_GOOD:\n    break;\n\n  case V_OCSP_CERTSTATUS_REVOKED:\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    failf(data, \"SSL certificate revocation reason: %s (%d)\",\n          OCSP_crl_reason_str(crl_reason), crl_reason);\n    goto end;\n\n  case V_OCSP_CERTSTATUS_UNKNOWN:\n  default:\n    result = CURLE_SSL_INVALIDCERTSTATUS;\n    goto end;\n  }\n\nend:\n  if(br)\n    OCSP_BASICRESP_free(br);\n  OCSP_RESPONSE_free(rsp);\n\n  return result;\n}\n#endif\n\n#endif /* USE_OPENSSL */\n\n/* The SSL_CTRL_SET_MSG_CALLBACK doesn't exist in ancient OpenSSL versions\n   and thus this cannot be done there. */\n#ifdef SSL_CTRL_SET_MSG_CALLBACK\n\nstatic const char *ssl_msg_type(int ssl_ver, int msg)\n{\n#ifdef SSL2_VERSION_MAJOR\n  if(ssl_ver == SSL2_VERSION_MAJOR) {\n    switch(msg) {\n      case SSL2_MT_ERROR:\n        return \"Error\";\n      case SSL2_MT_CLIENT_HELLO:\n        return \"Client hello\";\n      case SSL2_MT_CLIENT_MASTER_KEY:\n        return \"Client key\";\n      case SSL2_MT_CLIENT_FINISHED:\n        return \"Client finished\";\n      case SSL2_MT_SERVER_HELLO:\n        return \"Server hello\";\n      case SSL2_MT_SERVER_VERIFY:\n        return \"Server verify\";\n      case SSL2_MT_SERVER_FINISHED:\n        return \"Server finished\";\n      case SSL2_MT_REQUEST_CERTIFICATE:\n        return \"Request CERT\";\n      case SSL2_MT_CLIENT_CERTIFICATE:\n        return \"Client CERT\";\n    }\n  }\n  else\n#endif\n  if(ssl_ver == SSL3_VERSION_MAJOR) {\n    switch(msg) {\n      case SSL3_MT_HELLO_REQUEST:\n        return \"Hello request\";\n      case SSL3_MT_CLIENT_HELLO:\n        return \"Client hello\";\n      case SSL3_MT_SERVER_HELLO:\n        return \"Server hello\";\n#ifdef SSL3_MT_NEWSESSION_TICKET\n      case SSL3_MT_NEWSESSION_TICKET:\n        return \"Newsession Ticket\";\n#endif\n      case SSL3_MT_CERTIFICATE:\n        return \"Certificate\";\n      case SSL3_MT_SERVER_KEY_EXCHANGE:\n        return \"Server key exchange\";\n      case SSL3_MT_CLIENT_KEY_EXCHANGE:\n        return \"Client key exchange\";\n      case SSL3_MT_CERTIFICATE_REQUEST:\n        return \"Request CERT\";\n      case SSL3_MT_SERVER_DONE:\n        return \"Server finished\";\n      case SSL3_MT_CERTIFICATE_VERIFY:\n        return \"CERT verify\";\n      case SSL3_MT_FINISHED:\n        return \"Finished\";\n#ifdef SSL3_MT_CERTIFICATE_STATUS\n      case SSL3_MT_CERTIFICATE_STATUS:\n        return \"Certificate Status\";\n#endif\n#ifdef SSL3_MT_ENCRYPTED_EXTENSIONS\n      case SSL3_MT_ENCRYPTED_EXTENSIONS:\n        return \"Encrypted Extensions\";\n#endif\n#ifdef SSL3_MT_END_OF_EARLY_DATA\n      case SSL3_MT_END_OF_EARLY_DATA:\n        return \"End of early data\";\n#endif\n#ifdef SSL3_MT_KEY_UPDATE\n      case SSL3_MT_KEY_UPDATE:\n        return \"Key update\";\n#endif\n#ifdef SSL3_MT_NEXT_PROTO\n      case SSL3_MT_NEXT_PROTO:\n        return \"Next protocol\";\n#endif\n#ifdef SSL3_MT_MESSAGE_HASH\n      case SSL3_MT_MESSAGE_HASH:\n        return \"Message hash\";\n#endif\n    }\n  }\n  return \"Unknown\";\n}\n\nstatic const char *tls_rt_type(int type)\n{\n  switch(type) {\n#ifdef SSL3_RT_HEADER\n  case SSL3_RT_HEADER:\n    return \"TLS header\";\n#endif\n  case SSL3_RT_CHANGE_CIPHER_SPEC:\n    return \"TLS change cipher\";\n  case SSL3_RT_ALERT:\n    return \"TLS alert\";\n  case SSL3_RT_HANDSHAKE:\n    return \"TLS handshake\";\n  case SSL3_RT_APPLICATION_DATA:\n    return \"TLS app data\";\n  default:\n    return \"TLS Unknown\";\n  }\n}\n\n/*\n * Our callback from the SSL/TLS layers.\n */\nstatic void ossl_trace(int direction, int ssl_ver, int content_type,\n                       const void *buf, size_t len, SSL *ssl,\n                       void *userp)\n{\n  char unknown[32];\n  const char *verstr = NULL;\n  struct connectdata *conn = userp;\n  struct ssl_connect_data *connssl = &conn->ssl[0];\n  struct ssl_backend_data *backend = connssl->backend;\n  struct Curl_easy *data = backend->logger;\n\n  if(!conn || !data || !data->set.fdebug ||\n     (direction != 0 && direction != 1))\n    return;\n\n  switch(ssl_ver) {\n#ifdef SSL2_VERSION /* removed in recent versions */\n  case SSL2_VERSION:\n    verstr = \"SSLv2\";\n    break;\n#endif\n#ifdef SSL3_VERSION\n  case SSL3_VERSION:\n    verstr = \"SSLv3\";\n    break;\n#endif\n  case TLS1_VERSION:\n    verstr = \"TLSv1.0\";\n    break;\n#ifdef TLS1_1_VERSION\n  case TLS1_1_VERSION:\n    verstr = \"TLSv1.1\";\n    break;\n#endif\n#ifdef TLS1_2_VERSION\n  case TLS1_2_VERSION:\n    verstr = \"TLSv1.2\";\n    break;\n#endif\n#ifdef TLS1_3_VERSION\n  case TLS1_3_VERSION:\n    verstr = \"TLSv1.3\";\n    break;\n#endif\n  case 0:\n    break;\n  default:\n    msnprintf(unknown, sizeof(unknown), \"(%x)\", ssl_ver);\n    verstr = unknown;\n    break;\n  }\n\n  /* Log progress for interesting records only (like Handshake or Alert), skip\n   * all raw record headers (content_type == SSL3_RT_HEADER or ssl_ver == 0).\n   * For TLS 1.3, skip notification of the decrypted inner Content Type.\n   */\n  if(ssl_ver\n#ifdef SSL3_RT_INNER_CONTENT_TYPE\n     && content_type != SSL3_RT_INNER_CONTENT_TYPE\n#endif\n    ) {\n    const char *msg_name, *tls_rt_name;\n    char ssl_buf[1024];\n    int msg_type, txt_len;\n\n    /* the info given when the version is zero is not that useful for us */\n\n    ssl_ver >>= 8; /* check the upper 8 bits only below */\n\n    /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL\n     * always pass-up content-type as 0. But the interesting message-type\n     * is at 'buf[0]'.\n     */\n    if(ssl_ver == SSL3_VERSION_MAJOR && content_type)\n      tls_rt_name = tls_rt_type(content_type);\n    else\n      tls_rt_name = \"\";\n\n    if(content_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n      msg_type = *(char *)buf;\n      msg_name = \"Change cipher spec\";\n    }\n    else if(content_type == SSL3_RT_ALERT) {\n      msg_type = (((char *)buf)[0] << 8) + ((char *)buf)[1];\n      msg_name = SSL_alert_desc_string_long(msg_type);\n    }\n    else {\n      msg_type = *(char *)buf;\n      msg_name = ssl_msg_type(ssl_ver, msg_type);\n    }\n\n    txt_len = msnprintf(ssl_buf, sizeof(ssl_buf), \"%s (%s), %s, %s (%d):\\n\",\n                        verstr, direction?\"OUT\":\"IN\",\n                        tls_rt_name, msg_name, msg_type);\n    if(0 <= txt_len && (unsigned)txt_len < sizeof(ssl_buf)) {\n      Curl_debug(data, CURLINFO_TEXT, ssl_buf, (size_t)txt_len);\n    }\n  }\n\n  Curl_debug(data, (direction == 1) ? CURLINFO_SSL_DATA_OUT :\n             CURLINFO_SSL_DATA_IN, (char *)buf, len);\n  (void) ssl;\n}\n#endif\n\n#ifdef USE_OPENSSL\n/* ====================================================== */\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n#  define use_sni(x)  sni = (x)\n#else\n#  define use_sni(x)  Curl_nop_stmt\n#endif\n\n/* Check for OpenSSL 1.0.2 which has ALPN support. */\n#undef HAS_ALPN\n#if OPENSSL_VERSION_NUMBER >= 0x10002000L \\\n    && !defined(OPENSSL_NO_TLSEXT)\n#  define HAS_ALPN 1\n#endif\n\n/* Check for OpenSSL 1.0.1 which has NPN support. */\n#undef HAS_NPN\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L \\\n    && !defined(OPENSSL_NO_TLSEXT) \\\n    && !defined(OPENSSL_NO_NEXTPROTONEG)\n#  define HAS_NPN 1\n#endif\n\n#ifdef HAS_NPN\n\n/*\n * in is a list of length prefixed strings. this function has to select\n * the protocol we want to use from the list and write its string into out.\n */\n\nstatic int\nselect_next_protocol(unsigned char **out, unsigned char *outlen,\n                     const unsigned char *in, unsigned int inlen,\n                     const char *key, unsigned int keylen)\n{\n  unsigned int i;\n  for(i = 0; i + keylen <= inlen; i += in[i] + 1) {\n    if(memcmp(&in[i + 1], key, keylen) == 0) {\n      *out = (unsigned char *) &in[i + 1];\n      *outlen = in[i];\n      return 0;\n    }\n  }\n  return -1;\n}\n\nstatic int\nselect_next_proto_cb(SSL *ssl,\n                     unsigned char **out, unsigned char *outlen,\n                     const unsigned char *in, unsigned int inlen,\n                     void *arg)\n{\n  struct Curl_easy *data = (struct Curl_easy *)arg;\n  struct connectdata *conn = data->conn;\n  (void)ssl;\n\n#ifdef USE_HTTP2\n  if(data->state.httpwant >= CURL_HTTP_VERSION_2 &&\n     !select_next_protocol(out, outlen, in, inlen, ALPN_H2, ALPN_H2_LENGTH)) {\n    infof(data, \"NPN, negotiated HTTP2 (%s)\\n\", ALPN_H2);\n    conn->negnpn = CURL_HTTP_VERSION_2;\n    return SSL_TLSEXT_ERR_OK;\n  }\n#endif\n\n  if(!select_next_protocol(out, outlen, in, inlen, ALPN_HTTP_1_1,\n                           ALPN_HTTP_1_1_LENGTH)) {\n    infof(data, \"NPN, negotiated HTTP1.1\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_1_1;\n    return SSL_TLSEXT_ERR_OK;\n  }\n\n  infof(data, \"NPN, no overlap, use HTTP1.1\\n\");\n  *out = (unsigned char *)ALPN_HTTP_1_1;\n  *outlen = ALPN_HTTP_1_1_LENGTH;\n  conn->negnpn = CURL_HTTP_VERSION_1_1;\n\n  return SSL_TLSEXT_ERR_OK;\n}\n#endif /* HAS_NPN */\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */\nstatic CURLcode\nset_ssl_version_min_max(SSL_CTX *ctx, struct connectdata *conn)\n{\n  /* first, TLS min version... */\n  long curl_ssl_version_min = SSL_CONN_CONFIG(version);\n  long curl_ssl_version_max;\n\n  /* convert cURL min SSL version option to OpenSSL constant */\n#if defined(OPENSSL_IS_BORINGSSL) || defined(LIBRESSL_VERSION_NUMBER)\n  uint16_t ossl_ssl_version_min = 0;\n  uint16_t ossl_ssl_version_max = 0;\n#else\n  long ossl_ssl_version_min = 0;\n  long ossl_ssl_version_max = 0;\n#endif\n  switch(curl_ssl_version_min) {\n    case CURL_SSLVERSION_TLSv1: /* TLS 1.x */\n    case CURL_SSLVERSION_TLSv1_0:\n      ossl_ssl_version_min = TLS1_VERSION;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      ossl_ssl_version_min = TLS1_1_VERSION;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      ossl_ssl_version_min = TLS1_2_VERSION;\n      break;\n#ifdef TLS1_3_VERSION\n    case CURL_SSLVERSION_TLSv1_3:\n      ossl_ssl_version_min = TLS1_3_VERSION;\n      break;\n#endif\n  }\n\n  /* CURL_SSLVERSION_DEFAULT means that no option was selected.\n     We don't want to pass 0 to SSL_CTX_set_min_proto_version as\n     it would enable all versions down to the lowest supported by\n     the library.\n     So we skip this, and stay with the OS default\n  */\n  if(curl_ssl_version_min != CURL_SSLVERSION_DEFAULT) {\n    if(!SSL_CTX_set_min_proto_version(ctx, ossl_ssl_version_min)) {\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* ... then, TLS max version */\n  curl_ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  /* convert cURL max SSL version option to OpenSSL constant */\n  switch(curl_ssl_version_max) {\n    case CURL_SSLVERSION_MAX_TLSv1_0:\n      ossl_ssl_version_max = TLS1_VERSION;\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_1:\n      ossl_ssl_version_max = TLS1_1_VERSION;\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_2:\n      ossl_ssl_version_max = TLS1_2_VERSION;\n      break;\n#ifdef TLS1_3_VERSION\n    case CURL_SSLVERSION_MAX_TLSv1_3:\n      ossl_ssl_version_max = TLS1_3_VERSION;\n      break;\n#endif\n    case CURL_SSLVERSION_MAX_NONE:  /* none selected */\n    case CURL_SSLVERSION_MAX_DEFAULT:  /* max selected */\n    default:\n      /* SSL_CTX_set_max_proto_version states that:\n        setting the maximum to 0 will enable\n        protocol versions up to the highest version\n        supported by the library */\n      ossl_ssl_version_max = 0;\n      break;\n  }\n\n  if(!SSL_CTX_set_max_proto_version(ctx, ossl_ssl_version_max)) {\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  return CURLE_OK;\n}\n#endif\n\n#ifdef OPENSSL_IS_BORINGSSL\ntypedef uint32_t ctx_option_t;\n#else\ntypedef long ctx_option_t;\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) /* 1.1.0 */\nstatic CURLcode\nset_ssl_version_min_max_legacy(ctx_option_t *ctx_options,\n                               struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n\n  (void) data; /* In case it's unused. */\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_TLSv1_3:\n#ifdef TLS1_3_VERSION\n    {\n      struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n      SSL_CTX_set_max_proto_version(backend->ctx, TLS1_3_VERSION);\n      *ctx_options |= SSL_OP_NO_TLSv1_2;\n    }\n#else\n      (void)sockindex;\n      (void)ctx_options;\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.3 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_2:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_1;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.2 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_1:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.1 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1:\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_TLSv1_0:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_1;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_MAX_TLSv1_1:\n#if OPENSSL_VERSION_NUMBER >= 0x1000100FL\n      *ctx_options |= SSL_OP_NO_TLSv1_2;\n#endif\n      /* FALLTHROUGH */\n    case CURL_SSLVERSION_MAX_TLSv1_2:\n#ifdef TLS1_3_VERSION\n      *ctx_options |= SSL_OP_NO_TLSv1_3;\n#endif\n      break;\n    case CURL_SSLVERSION_MAX_TLSv1_3:\n#ifdef TLS1_3_VERSION\n      break;\n#else\n      failf(data, OSSL_PACKAGE \" was built without TLS 1.3 support\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n  }\n  return CURLE_OK;\n}\n#endif\n\n/* The \"new session\" callback must return zero if the session can be removed\n * or non-zero if the session has been put into the session cache.\n */\nstatic int ossl_new_session_cb(SSL *ssl, SSL_SESSION *ssl_sessionid)\n{\n  int res = 0;\n  struct connectdata *conn;\n  struct Curl_easy *data;\n  int sockindex;\n  curl_socket_t *sockindex_ptr;\n  int data_idx = ossl_get_ssl_data_index();\n  int connectdata_idx = ossl_get_ssl_conn_index();\n  int sockindex_idx = ossl_get_ssl_sockindex_index();\n  int proxy_idx = ossl_get_proxy_index();\n  bool isproxy;\n\n  if(data_idx < 0 || connectdata_idx < 0 || sockindex_idx < 0 || proxy_idx < 0)\n    return 0;\n\n  conn = (struct connectdata*) SSL_get_ex_data(ssl, connectdata_idx);\n  if(!conn)\n    return 0;\n\n  data = (struct Curl_easy *) SSL_get_ex_data(ssl, data_idx);\n\n  /* The sockindex has been stored as a pointer to an array element */\n  sockindex_ptr = (curl_socket_t*) SSL_get_ex_data(ssl, sockindex_idx);\n  sockindex = (int)(sockindex_ptr - conn->sock);\n\n  isproxy = SSL_get_ex_data(ssl, proxy_idx) ? TRUE : FALSE;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(isproxy)\n      incache = FALSE;\n    else\n      incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                        &old_ssl_sessionid, NULL, sockindex));\n    if(incache) {\n      if(old_ssl_sessionid != ssl_sessionid) {\n        infof(data, \"old SSL session ID is stale, removing\\n\");\n        Curl_ssl_delsessionid(data, old_ssl_sessionid);\n        incache = FALSE;\n      }\n    }\n\n    if(!incache) {\n      if(!Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n                                0 /* unknown size */, sockindex)) {\n        /* the session has been put into the session cache */\n        res = 1;\n      }\n      else\n        failf(data, \"failed to store ssl session\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  return res;\n}\n\nstatic CURLcode load_cacert_from_memory(SSL_CTX *ctx,\n                                        const struct curl_blob *ca_info_blob)\n{\n  /* these need freed at the end */\n  BIO *cbio = NULL;\n  STACK_OF(X509_INFO) *inf = NULL;\n\n  /* everything else is just a reference */\n  int i, count = 0;\n  X509_STORE *cts = NULL;\n  X509_INFO *itmp = NULL;\n\n  if(ca_info_blob->len > (size_t)INT_MAX)\n    return CURLE_SSL_CACERT_BADFILE;\n\n  cts = SSL_CTX_get_cert_store(ctx);\n  if(!cts)\n    return CURLE_OUT_OF_MEMORY;\n\n  cbio = BIO_new_mem_buf(ca_info_blob->data, (int)ca_info_blob->len);\n  if(!cbio)\n    return CURLE_OUT_OF_MEMORY;\n\n  inf = PEM_X509_INFO_read_bio(cbio, NULL, NULL, NULL);\n  if(!inf) {\n    BIO_free(cbio);\n    return CURLE_SSL_CACERT_BADFILE;\n  }\n\n  /* add each entry from PEM file to x509_store */\n  for(i = 0; i < (int)sk_X509_INFO_num(inf); ++i) {\n    itmp = sk_X509_INFO_value(inf, i);\n    if(itmp->x509) {\n      if(X509_STORE_add_cert(cts, itmp->x509)) {\n        ++count;\n      }\n      else {\n        /* set count to 0 to return an error */\n        count = 0;\n        break;\n      }\n    }\n    if(itmp->crl) {\n      if(X509_STORE_add_crl(cts, itmp->crl)) {\n        ++count;\n      }\n      else {\n        /* set count to 0 to return an error */\n        count = 0;\n        break;\n      }\n    }\n  }\n\n  sk_X509_INFO_pop_free(inf, X509_INFO_free);\n  BIO_free(cbio);\n\n  /* if we didn't end up importing anything, treat that as an error */\n  return (count > 0 ? CURLE_OK : CURLE_SSL_CACERT_BADFILE);\n}\n\nstatic CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n  void *ssl_sessionid = NULL;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n#endif\n  const long int ssl_version = SSL_CONN_CONFIG(version);\n#ifdef USE_OPENSSL_SRP\n  const enum CURL_TLSAUTH ssl_authtype = SSL_SET_OPTION(authtype);\n#endif\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n  const struct curl_blob *ca_info_blob = SSL_CONN_CONFIG(ca_info_blob);\n  const char * const ssl_cert_type = SSL_SET_OPTION(cert_type);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ca_info_blob ? NULL : SSL_CONN_CONFIG(CAfile));\n  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n  char error_buffer[256];\n  struct ssl_backend_data *backend = connssl->backend;\n  bool imported_native_ca = false;\n\n  DEBUGASSERT(ssl_connect_1 == connssl->connecting_state);\n\n  /* Make funny stuff to get random input */\n  result = ossl_seed(data);\n  if(result)\n    return result;\n\n  SSL_SET_OPTION_LVALUE(certverifyresult) = !X509_V_OK;\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n\n  switch(ssl_version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    /* it will be handled later with the context options */\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n    req_method = TLS_client_method();\n#else\n    req_method = SSLv23_client_method();\n#endif\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_SSLv2:\n    failf(data, \"No SSLv2 support\");\n    return CURLE_NOT_BUILT_IN;\n  case CURL_SSLVERSION_SSLv3:\n    failf(data, \"No SSLv3 support\");\n    return CURLE_NOT_BUILT_IN;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(backend->ctx)\n    SSL_CTX_free(backend->ctx);\n  backend->ctx = SSL_CTX_new(req_method);\n\n  if(!backend->ctx) {\n    failf(data, \"SSL: couldn't create a context: %s\",\n          ossl_strerror(ERR_peek_error(), error_buffer, sizeof(error_buffer)));\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(backend->ctx, SSL_MODE_RELEASE_BUFFERS);\n#endif\n\n#ifdef SSL_CTRL_SET_MSG_CALLBACK\n  if(data->set.fdebug && data->set.verbose) {\n    /* the SSL trace callback is only used for verbose logging */\n    SSL_CTX_set_msg_callback(backend->ctx, ossl_trace);\n    SSL_CTX_set_msg_callback_arg(backend->ctx, conn);\n    set_logger(conn, data);\n  }\n#endif\n\n  /* OpenSSL contains code to work-around lots of bugs and flaws in various\n     SSL-implementations. SSL_CTX_set_options() is used to enabled those\n     work-arounds. The man page for this option states that SSL_OP_ALL enables\n     all the work-arounds and that \"It is usually safe to use SSL_OP_ALL to\n     enable the bug workaround options if compatibility with somewhat broken\n     implementations is desired.\"\n\n     The \"-no_ticket\" option was introduced in Openssl0.9.8j. It's a flag to\n     disable \"rfc4507bis session ticket support\".  rfc4507bis was later turned\n     into the proper RFC5077 it seems: https://tools.ietf.org/html/rfc5077\n\n     The enabled extension concerns the session management. I wonder how often\n     libcurl stops a connection and then resumes a TLS session. also, sending\n     the session data is some overhead. .I suggest that you just use your\n     proposed patch (which explicitly disables TICKET).\n\n     If someone writes an application with libcurl and openssl who wants to\n     enable the feature, one can do this in the SSL callback.\n\n     SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG option enabling allowed proper\n     interoperability with web server Netscape Enterprise Server 2.0.1 which\n     was released back in 1996.\n\n     Due to CVE-2010-4180, option SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG has\n     become ineffective as of OpenSSL 0.9.8q and 1.0.0c. In order to mitigate\n     CVE-2010-4180 when using previous OpenSSL versions we no longer enable\n     this option regardless of OpenSSL version and SSL_OP_ALL definition.\n\n     OpenSSL added a work-around for a SSL 3.0/TLS 1.0 CBC vulnerability\n     (https://www.openssl.org/~bodo/tls-cbc.txt). In 0.9.6e they added a bit to\n     SSL_OP_ALL that _disables_ that work-around despite the fact that\n     SSL_OP_ALL is documented to do \"rather harmless\" workarounds. In order to\n     keep the secure work-around, the SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS bit\n     must not be set.\n  */\n\n  ctx_options = SSL_OP_ALL;\n\n#ifdef SSL_OP_NO_TICKET\n  ctx_options |= SSL_OP_NO_TICKET;\n#endif\n\n#ifdef SSL_OP_NO_COMPRESSION\n  ctx_options |= SSL_OP_NO_COMPRESSION;\n#endif\n\n#ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\n  /* mitigate CVE-2010-4180 */\n  ctx_options &= ~SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;\n#endif\n\n#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n  /* unless the user explicitly ask to allow the protocol vulnerability we\n     use the work-around */\n  if(!SSL_SET_OPTION(enable_beast))\n    ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_SSLv2:\n    case CURL_SSLVERSION_SSLv3:\n      return CURLE_NOT_BUILT_IN;\n\n    /* \"--tlsv<x.y>\" options mean TLS >= version <x.y> */\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1: /* TLS >= version 1.0 */\n    case CURL_SSLVERSION_TLSv1_0: /* TLS >= version 1.0 */\n    case CURL_SSLVERSION_TLSv1_1: /* TLS >= version 1.1 */\n    case CURL_SSLVERSION_TLSv1_2: /* TLS >= version 1.2 */\n    case CURL_SSLVERSION_TLSv1_3: /* TLS >= version 1.3 */\n      /* asking for any TLS version as the minimum, means no SSL versions\n        allowed */\n      ctx_options |= SSL_OP_NO_SSLv2;\n      ctx_options |= SSL_OP_NO_SSLv3;\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */\n      result = set_ssl_version_min_max(backend->ctx, conn);\n#else\n      result = set_ssl_version_min_max_legacy(&ctx_options, data, conn,\n                                              sockindex);\n#endif\n      if(result != CURLE_OK)\n        return result;\n      break;\n\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  SSL_CTX_set_options(backend->ctx, ctx_options);\n\n#ifdef HAS_NPN\n  if(conn->bits.tls_enable_npn)\n    SSL_CTX_set_next_proto_select_cb(backend->ctx, select_next_proto_cb, data);\n#endif\n\n#ifdef HAS_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    int cur = 0;\n    unsigned char protocols[128];\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)\n#endif\n      ) {\n      protocols[cur++] = ALPN_H2_LENGTH;\n\n      memcpy(&protocols[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    /* expects length prefixed preference ordered list of protocols in wire\n     * format\n     */\n    if(SSL_CTX_set_alpn_protos(backend->ctx, protocols, cur)) {\n      failf(data, \"Error setting ALPN\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif\n\n  if(ssl_cert || ssl_cert_blob || ssl_cert_type) {\n    if(!result &&\n       !cert_stuff(data, backend->ctx,\n                   ssl_cert, ssl_cert_blob, ssl_cert_type,\n                   SSL_SET_OPTION(key), SSL_SET_OPTION(key_blob),\n                   SSL_SET_OPTION(key_type), SSL_SET_OPTION(key_passwd)))\n      result = CURLE_SSL_CERTPROBLEM;\n    if(result)\n      /* failf() is already done in cert_stuff() */\n      return result;\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(!ciphers)\n    ciphers = (char *)DEFAULT_CIPHER_SELECTION;\n  if(ciphers) {\n    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES\n  {\n    char *ciphers13 = SSL_CONN_CONFIG(cipher_list13);\n    if(ciphers13) {\n      if(!SSL_CTX_set_ciphersuites(backend->ctx, ciphers13)) {\n        failf(data, \"failed setting TLS 1.3 cipher suite: %s\", ciphers13);\n        return CURLE_SSL_CIPHER;\n      }\n      infof(data, \"TLS 1.3 cipher selection: %s\\n\", ciphers13);\n    }\n  }\n#endif\n\n#ifdef HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH\n  /* OpenSSL 1.1.1 requires clients to opt-in for PHA */\n  SSL_CTX_set_post_handshake_auth(backend->ctx, 1);\n#endif\n\n#ifdef HAVE_SSL_CTX_SET_EC_CURVES\n  {\n    char *curves = SSL_CONN_CONFIG(curves);\n    if(curves) {\n      if(!SSL_CTX_set1_curves_list(backend->ctx, curves)) {\n        failf(data, \"failed setting curves list: '%s'\", curves);\n        return CURLE_SSL_CIPHER;\n      }\n    }\n  }\n#endif\n\n#ifdef USE_OPENSSL_SRP\n  if(ssl_authtype == CURL_TLSAUTH_SRP) {\n    char * const ssl_username = SSL_SET_OPTION(username);\n\n    infof(data, \"Using TLS-SRP username: %s\\n\", ssl_username);\n\n    if(!SSL_CTX_set_srp_username(backend->ctx, ssl_username)) {\n      failf(data, \"Unable to set SRP user name\");\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n    if(!SSL_CTX_set_srp_password(backend->ctx, SSL_SET_OPTION(password))) {\n      failf(data, \"failed setting SRP password\");\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n    if(!SSL_CONN_CONFIG(cipher_list)) {\n      infof(data, \"Setting cipher list SRP\\n\");\n\n      if(!SSL_CTX_set_cipher_list(backend->ctx, \"SRP\")) {\n        failf(data, \"failed setting SRP cipher list\");\n        return CURLE_SSL_CIPHER;\n      }\n    }\n  }\n#endif\n\n\n#if defined(USE_WIN32_CRYPTO)\n  /* Import certificates from the Windows root certificate store if requested.\n     https://stackoverflow.com/questions/9507184/\n     https://github.com/d3x0r/SACK/blob/master/src/netlib/ssl_layer.c#L1037\n     https://tools.ietf.org/html/rfc5280 */\n  if((SSL_CONN_CONFIG(verifypeer) || SSL_CONN_CONFIG(verifyhost)) &&\n     (SSL_SET_OPTION(native_ca_store))) {\n    X509_STORE *store = SSL_CTX_get_cert_store(backend->ctx);\n    HCERTSTORE hStore = CertOpenSystemStore(0, TEXT(\"ROOT\"));\n\n    if(hStore) {\n      PCCERT_CONTEXT pContext = NULL;\n      /* The array of enhanced key usage OIDs will vary per certificate and is\n         declared outside of the loop so that rather than malloc/free each\n         iteration we can grow it with realloc, when necessary. */\n      CERT_ENHKEY_USAGE *enhkey_usage = NULL;\n      DWORD enhkey_usage_size = 0;\n\n      /* This loop makes a best effort to import all valid certificates from\n         the MS root store. If a certificate cannot be imported it is skipped.\n         'result' is used to store only hard-fail conditions (such as out of\n         memory) that cause an early break. */\n      result = CURLE_OK;\n      for(;;) {\n        X509 *x509;\n        FILETIME now;\n        BYTE key_usage[2];\n        DWORD req_size;\n        const unsigned char *encoded_cert;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n        char cert_name[256];\n#endif\n\n        pContext = CertEnumCertificatesInStore(hStore, pContext);\n        if(!pContext)\n          break;\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n        if(!CertGetNameStringA(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0,\n                               NULL, cert_name, sizeof(cert_name))) {\n          strcpy(cert_name, \"Unknown\");\n        }\n        infof(data, \"SSL: Checking cert \\\"%s\\\"\\n\", cert_name);\n#endif\n\n        encoded_cert = (const unsigned char *)pContext->pbCertEncoded;\n        if(!encoded_cert)\n          continue;\n\n        GetSystemTimeAsFileTime(&now);\n        if(CompareFileTime(&pContext->pCertInfo->NotBefore, &now) > 0 ||\n           CompareFileTime(&now, &pContext->pCertInfo->NotAfter) > 0)\n          continue;\n\n        /* If key usage exists check for signing attribute */\n        if(CertGetIntendedKeyUsage(pContext->dwCertEncodingType,\n                                   pContext->pCertInfo,\n                                   key_usage, sizeof(key_usage))) {\n          if(!(key_usage[0] & CERT_KEY_CERT_SIGN_KEY_USAGE))\n            continue;\n        }\n        else if(GetLastError())\n          continue;\n\n        /* If enhanced key usage exists check for server auth attribute.\n         *\n         * Note \"In a Microsoft environment, a certificate might also have EKU\n         * extended properties that specify valid uses for the certificate.\"\n         * The call below checks both, and behavior varies depending on what is\n         * found. For more details see CertGetEnhancedKeyUsage doc.\n         */\n        if(CertGetEnhancedKeyUsage(pContext, 0, NULL, &req_size)) {\n          if(req_size && req_size > enhkey_usage_size) {\n            void *tmp = realloc(enhkey_usage, req_size);\n\n            if(!tmp) {\n              failf(data, \"SSL: Out of memory allocating for OID list\");\n              result = CURLE_OUT_OF_MEMORY;\n              break;\n            }\n\n            enhkey_usage = (CERT_ENHKEY_USAGE *)tmp;\n            enhkey_usage_size = req_size;\n          }\n\n          if(CertGetEnhancedKeyUsage(pContext, 0, enhkey_usage, &req_size)) {\n            if(!enhkey_usage->cUsageIdentifier) {\n              /* \"If GetLastError returns CRYPT_E_NOT_FOUND, the certificate is\n                 good for all uses. If it returns zero, the certificate has no\n                 valid uses.\" */\n              if((HRESULT)GetLastError() != CRYPT_E_NOT_FOUND)\n                continue;\n            }\n            else {\n              DWORD i;\n              bool found = false;\n\n              for(i = 0; i < enhkey_usage->cUsageIdentifier; ++i) {\n                if(!strcmp(\"1.3.6.1.5.5.7.3.1\" /* OID server auth */,\n                           enhkey_usage->rgpszUsageIdentifier[i])) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if(!found)\n                continue;\n            }\n          }\n          else\n            continue;\n        }\n        else\n          continue;\n\n        x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);\n        if(!x509)\n          continue;\n\n        /* Try to import the certificate. This may fail for legitimate reasons\n           such as duplicate certificate, which is allowed by MS but not\n           OpenSSL. */\n        if(X509_STORE_add_cert(store, x509) == 1) {\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n          infof(data, \"SSL: Imported cert \\\"%s\\\"\\n\", cert_name);\n#endif\n          imported_native_ca = true;\n        }\n        X509_free(x509);\n      }\n\n      free(enhkey_usage);\n      CertFreeCertificateContext(pContext);\n      CertCloseStore(hStore, 0);\n\n      if(result)\n        return result;\n    }\n    if(imported_native_ca)\n      infof(data, \"successfully imported windows ca store\\n\");\n    else\n      infof(data, \"error importing windows ca store, continuing anyway\\n\");\n  }\n#endif\n\n  if(ca_info_blob) {\n    result = load_cacert_from_memory(backend->ctx, ca_info_blob);\n    if(result) {\n      if(result == CURLE_OUT_OF_MEMORY ||\n         (verifypeer && !imported_native_ca)) {\n        failf(data, \"error importing CA certificate blob\");\n        return result;\n      }\n      /* Only warning if no certificate verification is required. */\n      infof(data, \"error importing CA certificate blob, continuing anyway\\n\");\n    }\n  }\n\n#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)\n  /* OpenSSL 3.0.0 has deprecated SSL_CTX_load_verify_locations */\n  {\n    if(ssl_cafile) {\n      if(!SSL_CTX_load_verify_file(backend->ctx, ssl_cafile)) {\n        if(verifypeer && !imported_native_ca) {\n          /* Fail if we insist on successfully verifying the server. */\n          failf(data, \"error setting certificate file: %s\", ssl_cafile);\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n        /* Continue with a warning if no certificate verif is required. */\n        infof(data, \"error setting certificate file, continuing anyway\\n\");\n      }\n      infof(data, \" CAfile: %s\\n\", ssl_cafile);\n    }\n    if(ssl_capath) {\n      if(!SSL_CTX_load_verify_dir(backend->ctx, ssl_capath)) {\n        if(verifypeer && !imported_native_ca) {\n          /* Fail if we insist on successfully verifying the server. */\n          failf(data, \"error setting certificate path: %s\", ssl_capath);\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n        /* Continue with a warning if no certificate verif is required. */\n        infof(data, \"error setting certificate path, continuing anyway\\n\");\n      }\n      infof(data, \" CApath: %s\\n\", ssl_capath);\n    }\n  }\n#else\n  if(ssl_cafile || ssl_capath) {\n    /* tell SSL where to find CA certificates that are used to verify\n       the servers certificate. */\n    if(!SSL_CTX_load_verify_locations(backend->ctx, ssl_cafile, ssl_capath)) {\n      if(verifypeer && !imported_native_ca) {\n        /* Fail if we insist on successfully verifying the server. */\n        failf(data, \"error setting certificate verify locations:\"\n              \"  CAfile: %s CApath: %s\",\n              ssl_cafile ? ssl_cafile : \"none\",\n              ssl_capath ? ssl_capath : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      /* Just continue with a warning if no strict certificate verification\n         is required. */\n      infof(data, \"error setting certificate verify locations,\"\n            \" continuing anyway:\\n\");\n    }\n    else {\n      /* Everything is fine. */\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\", ssl_cafile ? ssl_cafile : \"none\");\n    infof(data, \" CApath: %s\\n\", ssl_capath ? ssl_capath : \"none\");\n  }\n#endif\n\n#ifdef CURL_CA_FALLBACK\n  if(verifypeer &&\n     !ca_info_blob && !ssl_cafile && !ssl_capath && !imported_native_ca) {\n    /* verifying the peer without any CA certificates won't\n       work so use openssl's built in default as fallback */\n    SSL_CTX_set_default_verify_paths(backend->ctx);\n  }\n#endif\n\n  if(ssl_crlfile) {\n    /* tell SSL where to find CRL file that is used to check certificate\n     * revocation */\n    lookup = X509_STORE_add_lookup(SSL_CTX_get_cert_store(backend->ctx),\n                                 X509_LOOKUP_file());\n    if(!lookup ||\n       (!X509_load_crl_file(lookup, ssl_crlfile, X509_FILETYPE_PEM)) ) {\n      failf(data, \"error loading CRL file: %s\", ssl_crlfile);\n      return CURLE_SSL_CRL_BADFILE;\n    }\n    /* Everything is fine. */\n    infof(data, \"successfully load CRL file:\\n\");\n    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                         X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);\n\n    infof(data, \"  CRLfile: %s\\n\", ssl_crlfile);\n  }\n\n  if(verifypeer) {\n    /* Try building a chain using issuers in the trusted store first to avoid\n       problems with server-sent legacy intermediates.  Newer versions of\n       OpenSSL do alternate chain checking by default but we do not know how to\n       determine that in a reliable manner.\n       https://rt.openssl.org/Ticket/Display.html?id=3621&user=guest&pass=guest\n    */\n#if defined(X509_V_FLAG_TRUSTED_FIRST)\n    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                         X509_V_FLAG_TRUSTED_FIRST);\n#endif\n#ifdef X509_V_FLAG_PARTIAL_CHAIN\n    if(!SSL_SET_OPTION(no_partialchain) && !ssl_crlfile) {\n      /* Have intermediate certificates in the trust store be treated as\n         trust-anchors, in the same way as self-signed root CA certificates\n         are. This allows users to verify servers using the intermediate cert\n         only, instead of needing the whole chain.\n\n         Due to OpenSSL bug https://github.com/openssl/openssl/issues/5081 we\n         cannot do partial chains with CRL check.\n      */\n      X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),\n                           X509_V_FLAG_PARTIAL_CHAIN);\n    }\n#endif\n  }\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n  SSL_CTX_set_verify(backend->ctx,\n                     verifypeer ? SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);\n\n  /* Enable logging of secrets to the file specified in env SSLKEYLOGFILE. */\n#ifdef HAVE_KEYLOG_CALLBACK\n  if(Curl_tls_keylog_enabled()) {\n    SSL_CTX_set_keylog_callback(backend->ctx, ossl_keylog_callback);\n  }\n#endif\n\n  /* Enable the session cache because it's a prerequisite for the \"new session\"\n   * callback. Use the \"external storage\" mode to avoid that OpenSSL creates\n   * an internal session cache.\n   */\n  SSL_CTX_set_session_cache_mode(backend->ctx,\n      SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL);\n  SSL_CTX_sess_set_new_cb(backend->ctx, ossl_new_session_cb);\n\n  /* give application a chance to interfere with SSL set up. */\n  if(data->set.ssl.fsslctx) {\n    Curl_set_in_callback(data, true);\n    result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n                                      data->set.ssl.fsslctxp);\n    Curl_set_in_callback(data, false);\n    if(result) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return result;\n    }\n  }\n\n  /* Lets make an SSL structure */\n  if(backend->handle)\n    SSL_free(backend->handle);\n  backend->handle = SSL_new(backend->ctx);\n  if(!backend->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  if(SSL_CONN_CONFIG(verifystatus))\n    SSL_set_tlsext_status_type(backend->handle, TLSEXT_STATUSTYPE_ocsp);\n#endif\n\n#if defined(OPENSSL_IS_BORINGSSL) && defined(ALLOW_RENEG)\n  SSL_set_renegotiate_mode(backend->handle, ssl_renegotiate_freely);\n#endif\n\n  SSL_set_connect_state(backend->handle);\n\n  backend->server_cert = 0x0;\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&\n#ifdef ENABLE_IPV6\n     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&\n#endif\n     sni) {\n    size_t nlen = strlen(hostname);\n    if((long)nlen >= data->set.buffer_size)\n      /* this is seriously messed up */\n      return CURLE_SSL_CONNECT_ERROR;\n\n    /* RFC 6066 section 3 says the SNI field is case insensitive, but browsers\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased */\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  ossl_associate_connection(data, conn, sockindex);\n\n  Curl_ssl_sessionid_lock(data);\n  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                            &ssl_sessionid, NULL, sockindex)) {\n    /* we got a session id, use it! */\n    if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n      Curl_ssl_sessionid_unlock(data);\n      failf(data, \"SSL: SSL_set_session failed: %s\",\n            ossl_strerror(ERR_get_error(), error_buffer,\n                          sizeof(error_buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    /* Informational message */\n    infof(data, \"SSL re-using session ID\\n\");\n  }\n  Curl_ssl_sessionid_unlock(data);\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);\n  }\n  else\n#endif\n    if(!SSL_set_fd(backend->handle, (int)sockfd)) {\n    /* pass the raw socket into the SSL layers */\n    failf(data, \"SSL: SSL_set_fd failed: %s\",\n          ossl_strerror(ERR_get_error(), error_buffer, sizeof(error_buffer)));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode ossl_connect_step2(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  int err;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state\n              || ssl_connect_2_reading == connssl->connecting_state\n              || ssl_connect_2_writing == connssl->connecting_state);\n\n  ERR_clear_error();\n\n  err = SSL_connect(backend->handle);\n#ifndef HAVE_KEYLOG_CALLBACK\n  if(Curl_tls_keylog_enabled()) {\n    /* If key logging is enabled, wait for the handshake to complete and then\n     * proceed with logging secrets (for TLS 1.2 or older).\n     */\n    ossl_log_tls12_secret(backend->handle, &backend->keylog_done);\n  }\n#endif\n\n  /* 1  is fine\n     0  is \"not successful but was shut down controlled\"\n     <0 is \"handshake was not successful, because a fatal error occurred\" */\n  if(1 != err) {\n    int detail = SSL_get_error(backend->handle, err);\n\n    if(SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    if(SSL_ERROR_WANT_WRITE == detail) {\n      connssl->connecting_state = ssl_connect_2_writing;\n      return CURLE_OK;\n    }\n#ifdef SSL_ERROR_WANT_ASYNC\n    if(SSL_ERROR_WANT_ASYNC == detail) {\n      connssl->connecting_state = ssl_connect_2;\n      return CURLE_OK;\n    }\n#endif\n    else {\n      /* untreated error */\n      unsigned long errdetail;\n      char error_buffer[256]=\"\";\n      CURLcode result;\n      long lerr;\n      int lib;\n      int reason;\n\n      /* the connection failed, we're not waiting for anything else. */\n      connssl->connecting_state = ssl_connect_2;\n\n      /* Get the earliest error code from the thread's error queue and removes\n         the entry. */\n      errdetail = ERR_get_error();\n\n      /* Extract which lib and reason */\n      lib = ERR_GET_LIB(errdetail);\n      reason = ERR_GET_REASON(errdetail);\n\n      if((lib == ERR_LIB_SSL) &&\n         ((reason == SSL_R_CERTIFICATE_VERIFY_FAILED) ||\n          (reason == SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED))) {\n        result = CURLE_PEER_FAILED_VERIFICATION;\n\n        lerr = SSL_get_verify_result(backend->handle);\n        if(lerr != X509_V_OK) {\n          SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;\n          msnprintf(error_buffer, sizeof(error_buffer),\n                    \"SSL certificate problem: %s\",\n                    X509_verify_cert_error_string(lerr));\n        }\n        else\n          /* strcpy() is fine here as long as the string fits within\n             error_buffer */\n          strcpy(error_buffer, \"SSL certificate verification failed\");\n      }\n#if (OPENSSL_VERSION_NUMBER >= 0x10101000L && \\\n    !defined(LIBRESSL_VERSION_NUMBER) && \\\n    !defined(OPENSSL_IS_BORINGSSL))\n      /* SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED is only available on\n         OpenSSL version above v1.1.1, not Libre SSL nor BoringSSL */\n      else if((lib == ERR_LIB_SSL) &&\n              (reason == SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED)) {\n          /* If client certificate is required, communicate the\n             error to client */\n          result = CURLE_SSL_CLIENTCERT;\n          ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));\n      }\n#endif\n      else {\n        result = CURLE_SSL_CONNECT_ERROR;\n        ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));\n      }\n\n      /* detail is already set to the SSL error above */\n\n      /* If we e.g. use SSLv2 request-method and the server doesn't like us\n       * (RST connection etc.), OpenSSL gives no explanation whatsoever and\n       * the SO_ERROR is also lost.\n       */\n      if(CURLE_SSL_CONNECT_ERROR == result && errdetail == 0) {\n        const char * const hostname = SSL_HOST_NAME();\n        const long int port = SSL_HOST_PORT();\n        char extramsg[80]=\"\";\n        int sockerr = SOCKERRNO;\n        if(sockerr && detail == SSL_ERROR_SYSCALL)\n          Curl_strerror(sockerr, extramsg, sizeof(extramsg));\n        failf(data, OSSL_PACKAGE \" SSL_connect: %s in connection to %s:%ld \",\n              extramsg[0] ? extramsg : SSL_ERROR_to_str(detail),\n              hostname, port);\n        return result;\n      }\n\n      /* Could be a CERT problem */\n      failf(data, \"%s\", error_buffer);\n\n      return result;\n    }\n  }\n  else {\n    /* we have been connected fine, we're not waiting for anything else. */\n    connssl->connecting_state = ssl_connect_3;\n\n    /* Informational message */\n    infof(data, \"SSL connection using %s / %s\\n\",\n          SSL_get_version(backend->handle),\n          SSL_get_cipher(backend->handle));\n\n#ifdef HAS_ALPN\n    /* Sets data and len to negotiated protocol, len is 0 if no protocol was\n     * negotiated\n     */\n    if(conn->bits.tls_enable_alpn) {\n      const unsigned char *neg_protocol;\n      unsigned int len;\n      SSL_get0_alpn_selected(backend->handle, &neg_protocol, &len);\n      if(len) {\n        infof(data, \"ALPN, server accepted to use %.*s\\n\", len, neg_protocol);\n\n#ifdef USE_HTTP2\n        if(len == ALPN_H2_LENGTH &&\n           !memcmp(ALPN_H2, neg_protocol, len)) {\n          conn->negnpn = CURL_HTTP_VERSION_2;\n        }\n        else\n#endif\n        if(len == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, neg_protocol, ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n      }\n      else\n        infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n      Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                          BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n    }\n#endif\n\n    return CURLE_OK;\n  }\n}\n\nstatic int asn1_object_dump(ASN1_OBJECT *a, char *buf, size_t len)\n{\n  int i, ilen;\n\n  ilen = (int)len;\n  if(ilen < 0)\n    return 1; /* buffer too big */\n\n  i = i2t_ASN1_OBJECT(buf, ilen, a);\n\n  if(i >= ilen)\n    return 1; /* buffer too small */\n\n  return 0;\n}\n\n#define push_certinfo(_label, _num) \\\ndo {                              \\\n  long info_len = BIO_get_mem_data(mem, &ptr); \\\n  Curl_ssl_push_certinfo_len(data, _num, _label, ptr, info_len); \\\n  if(1 != BIO_reset(mem))                                        \\\n    break;                                                       \\\n} while(0)\n\nstatic void pubkey_show(struct Curl_easy *data,\n                        BIO *mem,\n                        int num,\n                        const char *type,\n                        const char *name,\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n                        const\n#endif\n                        BIGNUM *bn)\n{\n  char *ptr;\n  char namebuf[32];\n\n  msnprintf(namebuf, sizeof(namebuf), \"%s(%s)\", type, name);\n\n  if(bn)\n    BN_print(mem, bn);\n  push_certinfo(namebuf, num);\n}\n\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n#define print_pubkey_BN(_type, _name, _num)              \\\n  pubkey_show(data, mem, _num, #_type, #_name, _name)\n\n#else\n#define print_pubkey_BN(_type, _name, _num)    \\\ndo {                              \\\n  if(_type->_name) { \\\n    pubkey_show(data, mem, _num, #_type, #_name, _type->_name); \\\n  } \\\n} while(0)\n#endif\n\nstatic void X509V3_ext(struct Curl_easy *data,\n                      int certnum,\n                      CONST_EXTS STACK_OF(X509_EXTENSION) *exts)\n{\n  int i;\n\n  if((int)sk_X509_EXTENSION_num(exts) <= 0)\n    /* no extensions, bail out */\n    return;\n\n  for(i = 0; i < (int)sk_X509_EXTENSION_num(exts); i++) {\n    ASN1_OBJECT *obj;\n    X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);\n    BUF_MEM *biomem;\n    char namebuf[128];\n    BIO *bio_out = BIO_new(BIO_s_mem());\n\n    if(!bio_out)\n      return;\n\n    obj = X509_EXTENSION_get_object(ext);\n\n    asn1_object_dump(obj, namebuf, sizeof(namebuf));\n\n    if(!X509V3_EXT_print(bio_out, ext, 0, 0))\n      ASN1_STRING_print(bio_out, (ASN1_STRING *)X509_EXTENSION_get_data(ext));\n\n    BIO_get_mem_ptr(bio_out, &biomem);\n    Curl_ssl_push_certinfo_len(data, certnum, namebuf, biomem->data,\n                               biomem->length);\n    BIO_free(bio_out);\n  }\n}\n\n#ifdef OPENSSL_IS_BORINGSSL\ntypedef size_t numcert_t;\n#else\ntypedef int numcert_t;\n#endif\n\n#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)\n#define OSSL3_CONST const\n#else\n#define OSSL3_CONST\n#endif\n\nstatic CURLcode get_cert_chain(struct Curl_easy *data,\n                               struct ssl_connect_data *connssl)\n{\n  CURLcode result;\n  STACK_OF(X509) *sk;\n  int i;\n  numcert_t numcerts;\n  BIO *mem;\n  struct ssl_backend_data *backend = connssl->backend;\n\n  sk = SSL_get_peer_cert_chain(backend->handle);\n  if(!sk) {\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  numcerts = sk_X509_num(sk);\n\n  result = Curl_ssl_init_certinfo(data, (int)numcerts);\n  if(result) {\n    return result;\n  }\n\n  mem = BIO_new(BIO_s_mem());\n\n  for(i = 0; i < (int)numcerts; i++) {\n    ASN1_INTEGER *num;\n    X509 *x = sk_X509_value(sk, i);\n    EVP_PKEY *pubkey = NULL;\n    int j;\n    char *ptr;\n    const ASN1_BIT_STRING *psig = NULL;\n\n    X509_NAME_print_ex(mem, X509_get_subject_name(x), 0, XN_FLAG_ONELINE);\n    push_certinfo(\"Subject\", i);\n\n    X509_NAME_print_ex(mem, X509_get_issuer_name(x), 0, XN_FLAG_ONELINE);\n    push_certinfo(\"Issuer\", i);\n\n    BIO_printf(mem, \"%lx\", X509_get_version(x));\n    push_certinfo(\"Version\", i);\n\n    num = X509_get_serialNumber(x);\n    if(num->type == V_ASN1_NEG_INTEGER)\n      BIO_puts(mem, \"-\");\n    for(j = 0; j < num->length; j++)\n      BIO_printf(mem, \"%02x\", num->data[j]);\n    push_certinfo(\"Serial Number\", i);\n\n#if defined(HAVE_X509_GET0_SIGNATURE) && defined(HAVE_X509_GET0_EXTENSIONS)\n    {\n      const X509_ALGOR *sigalg = NULL;\n      X509_PUBKEY *xpubkey = NULL;\n      ASN1_OBJECT *pubkeyoid = NULL;\n\n      X509_get0_signature(&psig, &sigalg, x);\n      if(sigalg) {\n        i2a_ASN1_OBJECT(mem, sigalg->algorithm);\n        push_certinfo(\"Signature Algorithm\", i);\n      }\n\n      xpubkey = X509_get_X509_PUBKEY(x);\n      if(xpubkey) {\n        X509_PUBKEY_get0_param(&pubkeyoid, NULL, NULL, NULL, xpubkey);\n        if(pubkeyoid) {\n          i2a_ASN1_OBJECT(mem, pubkeyoid);\n          push_certinfo(\"Public Key Algorithm\", i);\n        }\n      }\n\n      X509V3_ext(data, i, X509_get0_extensions(x));\n    }\n#else\n    {\n      /* before OpenSSL 1.0.2 */\n      X509_CINF *cinf = x->cert_info;\n\n      i2a_ASN1_OBJECT(mem, cinf->signature->algorithm);\n      push_certinfo(\"Signature Algorithm\", i);\n\n      i2a_ASN1_OBJECT(mem, cinf->key->algor->algorithm);\n      push_certinfo(\"Public Key Algorithm\", i);\n\n      X509V3_ext(data, i, cinf->extensions);\n\n      psig = x->signature;\n    }\n#endif\n\n    ASN1_TIME_print(mem, X509_get0_notBefore(x));\n    push_certinfo(\"Start date\", i);\n\n    ASN1_TIME_print(mem, X509_get0_notAfter(x));\n    push_certinfo(\"Expire date\", i);\n\n    pubkey = X509_get_pubkey(x);\n    if(!pubkey)\n      infof(data, \"   Unable to load public key\\n\");\n    else {\n      int pktype;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n      pktype = EVP_PKEY_id(pubkey);\n#else\n      pktype = pubkey->type;\n#endif\n      switch(pktype) {\n      case EVP_PKEY_RSA:\n      {\n        OSSL3_CONST RSA *rsa;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        rsa = EVP_PKEY_get0_RSA(pubkey);\n#else\n        rsa = pubkey->pkey.rsa;\n#endif\n\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *n;\n          const BIGNUM *e;\n\n          RSA_get0_key(rsa, &n, &e, NULL);\n          BIO_printf(mem, \"%d\", BN_num_bits(n));\n          push_certinfo(\"RSA Public Key\", i);\n          print_pubkey_BN(rsa, n, i);\n          print_pubkey_BN(rsa, e, i);\n        }\n#else\n        BIO_printf(mem, \"%d\", BN_num_bits(rsa->n));\n        push_certinfo(\"RSA Public Key\", i);\n        print_pubkey_BN(rsa, n, i);\n        print_pubkey_BN(rsa, e, i);\n#endif\n\n        break;\n      }\n      case EVP_PKEY_DSA:\n      {\n#ifndef OPENSSL_NO_DSA\n        OSSL3_CONST DSA *dsa;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        dsa = EVP_PKEY_get0_DSA(pubkey);\n#else\n        dsa = pubkey->pkey.dsa;\n#endif\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *p;\n          const BIGNUM *q;\n          const BIGNUM *g;\n          const BIGNUM *pub_key;\n\n          DSA_get0_pqg(dsa, &p, &q, &g);\n          DSA_get0_key(dsa, &pub_key, NULL);\n\n          print_pubkey_BN(dsa, p, i);\n          print_pubkey_BN(dsa, q, i);\n          print_pubkey_BN(dsa, g, i);\n          print_pubkey_BN(dsa, pub_key, i);\n        }\n#else\n        print_pubkey_BN(dsa, p, i);\n        print_pubkey_BN(dsa, q, i);\n        print_pubkey_BN(dsa, g, i);\n        print_pubkey_BN(dsa, pub_key, i);\n#endif\n#endif /* !OPENSSL_NO_DSA */\n        break;\n      }\n      case EVP_PKEY_DH:\n      {\n        OSSL3_CONST DH *dh;\n#ifdef HAVE_OPAQUE_EVP_PKEY\n        dh = EVP_PKEY_get0_DH(pubkey);\n#else\n        dh = pubkey->pkey.dh;\n#endif\n#ifdef HAVE_OPAQUE_RSA_DSA_DH\n        {\n          const BIGNUM *p;\n          const BIGNUM *q;\n          const BIGNUM *g;\n          const BIGNUM *pub_key;\n          DH_get0_pqg(dh, &p, &q, &g);\n          DH_get0_key(dh, &pub_key, NULL);\n          print_pubkey_BN(dh, p, i);\n          print_pubkey_BN(dh, q, i);\n          print_pubkey_BN(dh, g, i);\n          print_pubkey_BN(dh, pub_key, i);\n       }\n#else\n        print_pubkey_BN(dh, p, i);\n        print_pubkey_BN(dh, g, i);\n        print_pubkey_BN(dh, pub_key, i);\n#endif\n        break;\n      }\n      }\n      EVP_PKEY_free(pubkey);\n    }\n\n    if(psig) {\n      for(j = 0; j < psig->length; j++)\n        BIO_printf(mem, \"%02x:\", psig->data[j]);\n      push_certinfo(\"Signature\", i);\n    }\n\n    PEM_write_bio_X509(mem, x);\n    push_certinfo(\"Cert\", i);\n  }\n\n  BIO_free(mem);\n\n  return CURLE_OK;\n}\n\n/*\n * Heavily modified from:\n * https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#OpenSSL\n */\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data, X509* cert,\n                                    const char *pinnedpubkey)\n{\n  /* Scratch */\n  int len1 = 0, len2 = 0;\n  unsigned char *buff1 = NULL, *temp = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  if(!cert)\n    return result;\n\n  do {\n    /* Begin Gyrations to get the subjectPublicKeyInfo     */\n    /* Thanks to Viktor Dukhovni on the OpenSSL mailing list */\n\n    /* https://groups.google.com/group/mailing.openssl.users/browse_thread\n     /thread/d61858dae102c6c7 */\n    len1 = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), NULL);\n    if(len1 < 1)\n      break; /* failed */\n\n    buff1 = temp = malloc(len1);\n    if(!buff1)\n      break; /* failed */\n\n    /* https://www.openssl.org/docs/crypto/d2i_X509.html */\n    len2 = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), &temp);\n\n    /*\n     * These checks are verifying we got back the same values as when we\n     * sized the buffer. It's pretty weak since they should always be the\n     * same. But it gives us something to test.\n     */\n    if((len1 != len2) || !temp || ((temp - buff1) != len1))\n      break; /* failed */\n\n    /* End Gyrations */\n\n    /* The one good exit point */\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, buff1, len1);\n  } while(0);\n\n  if(buff1)\n    free(buff1);\n\n  return result;\n}\n\n/*\n * Get the server cert, verify it and show it etc, only call failf() if the\n * 'strict' argument is TRUE as otherwise all this is for informational\n * purposes only!\n *\n * We check certificates to authenticate the server; otherwise we risk\n * man-in-the-middle attack.\n */\nstatic CURLcode servercert(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           struct ssl_connect_data *connssl,\n                           bool strict)\n{\n  CURLcode result = CURLE_OK;\n  int rc;\n  long lerr;\n  X509 *issuer;\n  BIO *fp = NULL;\n  char error_buffer[256]=\"\";\n  char buffer[2048];\n  const char *ptr;\n  BIO *mem = BIO_new(BIO_s_mem());\n  struct ssl_backend_data *backend = connssl->backend;\n\n  if(data->set.ssl.certinfo)\n    /* we've been asked to gather certificate info! */\n    (void)get_cert_chain(data, connssl);\n\n  backend->server_cert = SSL_get_peer_certificate(backend->handle);\n  if(!backend->server_cert) {\n    BIO_free(mem);\n    if(!strict)\n      return CURLE_OK;\n\n    failf(data, \"SSL: couldn't get peer certificate!\");\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  infof(data, \"%s certificate:\\n\", SSL_IS_PROXY() ? \"Proxy\" : \"Server\");\n\n  rc = x509_name_oneline(X509_get_subject_name(backend->server_cert),\n                         buffer, sizeof(buffer));\n  infof(data, \" subject: %s\\n\", rc?\"[NONE]\":buffer);\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  {\n    long len;\n    ASN1_TIME_print(mem, X509_get0_notBefore(backend->server_cert));\n    len = BIO_get_mem_data(mem, (char **) &ptr);\n    infof(data, \" start date: %.*s\\n\", len, ptr);\n    (void)BIO_reset(mem);\n\n    ASN1_TIME_print(mem, X509_get0_notAfter(backend->server_cert));\n    len = BIO_get_mem_data(mem, (char **) &ptr);\n    infof(data, \" expire date: %.*s\\n\", len, ptr);\n    (void)BIO_reset(mem);\n  }\n#endif\n\n  BIO_free(mem);\n\n  if(SSL_CONN_CONFIG(verifyhost)) {\n    result = verifyhost(data, conn, backend->server_cert);\n    if(result) {\n      X509_free(backend->server_cert);\n      backend->server_cert = NULL;\n      return result;\n    }\n  }\n\n  rc = x509_name_oneline(X509_get_issuer_name(backend->server_cert),\n                         buffer, sizeof(buffer));\n  if(rc) {\n    if(strict)\n      failf(data, \"SSL: couldn't get X509-issuer name!\");\n    result = CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else {\n    infof(data, \" issuer: %s\\n\", buffer);\n\n    /* We could do all sorts of certificate verification stuff here before\n       deallocating the certificate. */\n\n    /* e.g. match issuer name with provided issuer certificate */\n    if(SSL_SET_OPTION(issuercert) || SSL_SET_OPTION(issuercert_blob)) {\n      if(SSL_SET_OPTION(issuercert_blob))\n        fp = BIO_new_mem_buf(SSL_SET_OPTION(issuercert_blob)->data,\n                             (int)SSL_SET_OPTION(issuercert_blob)->len);\n      else {\n        fp = BIO_new(BIO_s_file());\n        if(!fp) {\n          failf(data,\n                \"BIO_new return NULL, \" OSSL_PACKAGE\n                \" error %s\",\n                ossl_strerror(ERR_get_error(), error_buffer,\n                              sizeof(error_buffer)) );\n          X509_free(backend->server_cert);\n          backend->server_cert = NULL;\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        if(BIO_read_filename(fp, SSL_SET_OPTION(issuercert)) <= 0) {\n          if(strict)\n            failf(data, \"SSL: Unable to open issuer cert (%s)\",\n                  SSL_SET_OPTION(issuercert));\n          BIO_free(fp);\n          X509_free(backend->server_cert);\n          backend->server_cert = NULL;\n          return CURLE_SSL_ISSUER_ERROR;\n        }\n      }\n\n      issuer = PEM_read_bio_X509(fp, NULL, ZERO_NULL, NULL);\n      if(!issuer) {\n        if(strict)\n          failf(data, \"SSL: Unable to read issuer cert (%s)\",\n                SSL_SET_OPTION(issuercert));\n        BIO_free(fp);\n        X509_free(issuer);\n        X509_free(backend->server_cert);\n        backend->server_cert = NULL;\n        return CURLE_SSL_ISSUER_ERROR;\n      }\n\n      if(X509_check_issued(issuer, backend->server_cert) != X509_V_OK) {\n        if(strict)\n          failf(data, \"SSL: Certificate issuer check failed (%s)\",\n                SSL_SET_OPTION(issuercert));\n        BIO_free(fp);\n        X509_free(issuer);\n        X509_free(backend->server_cert);\n        backend->server_cert = NULL;\n        return CURLE_SSL_ISSUER_ERROR;\n      }\n\n      infof(data, \" SSL certificate issuer check ok (%s)\\n\",\n            SSL_SET_OPTION(issuercert));\n      BIO_free(fp);\n      X509_free(issuer);\n    }\n\n    lerr = SSL_get_verify_result(backend->handle);\n    SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;\n    if(lerr != X509_V_OK) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        /* We probably never reach this, because SSL_connect() will fail\n           and we return earlier if verifypeer is set? */\n        if(strict)\n          failf(data, \"SSL certificate verify result: %s (%ld)\",\n                X509_verify_cert_error_string(lerr), lerr);\n        result = CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \" SSL certificate verify result: %s (%ld),\"\n              \" continuing anyway.\\n\",\n              X509_verify_cert_error_string(lerr), lerr);\n    }\n    else\n      infof(data, \" SSL certificate verify ok.\\n\");\n  }\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  if(SSL_CONN_CONFIG(verifystatus)) {\n    result = verifystatus(data, connssl);\n    if(result) {\n      X509_free(backend->server_cert);\n      backend->server_cert = NULL;\n      return result;\n    }\n  }\n#endif\n\n  if(!strict)\n    /* when not strict, we don't bother about the verify cert problems */\n    result = CURLE_OK;\n\n  ptr = SSL_PINNED_PUB_KEY();\n  if(!result && ptr) {\n    result = pkp_pin_peer_pubkey(data, backend->server_cert, ptr);\n    if(result)\n      failf(data, \"SSL: public key does not match pinned public key!\");\n  }\n\n  X509_free(backend->server_cert);\n  backend->server_cert = NULL;\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic CURLcode ossl_connect_step3(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  /*\n   * We check certificates to authenticate the server; otherwise we risk\n   * man-in-the-middle attack; NEVERTHELESS, if we're told explicitly not to\n   * verify the peer ignore faults and failures from the server cert\n   * operations.\n   */\n\n  result = servercert(data, conn, connssl, (SSL_CONN_CONFIG(verifypeer) ||\n                                            SSL_CONN_CONFIG(verifyhost)));\n\n  if(!result)\n    connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\nstatic Curl_recv ossl_recv;\nstatic Curl_send ossl_send;\n\nstatic CURLcode ossl_connect_common(struct Curl_easy *data,\n                                    struct connectdata *conn,\n                                    int sockindex,\n                                    bool nonblocking,\n                                    bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = ossl_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        /* timeout */\n        failf(data, \"SSL connection timeout\");\n        return CURLE_OPERATION_TIMEDOUT;\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if this\n     * connection is done nonblocking and this loop would execute again. This\n     * permits the owner of a multi handle to abort a connection attempt\n     * before step2 has completed while ensuring that a client using select()\n     * or epoll() will always have a valid fdset to wait on.\n     */\n    result = ossl_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = ossl_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = ossl_recv;\n    conn->send[sockindex] = ossl_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode ossl_connect_nonblocking(struct Curl_easy *data,\n                                         struct connectdata *conn,\n                                         int sockindex,\n                                         bool *done)\n{\n  return ossl_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode ossl_connect(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = ossl_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool ossl_data_pending(const struct connectdata *conn,\n                              int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  if(connssl->backend->handle && SSL_pending(connssl->backend->handle))\n    return TRUE;\n#ifndef CURL_DISABLE_PROXY\n  {\n    const struct ssl_connect_data *proxyssl = &conn->proxy_ssl[connindex];\n    if(proxyssl->backend->handle && SSL_pending(proxyssl->backend->handle))\n      return TRUE;\n  }\n#endif\n  return FALSE;\n}\n\nstatic size_t ossl_version(char *buffer, size_t size);\n\nstatic ssize_t ossl_send(struct Curl_easy *data,\n                         int sockindex,\n                         const void *mem,\n                         size_t len,\n                         CURLcode *curlcode)\n{\n  /* SSL_write() is said to return 'int' while write() and send() returns\n     'size_t' */\n  int err;\n  char error_buffer[256];\n  unsigned long sslerror;\n  int memlen;\n  int rc;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  ERR_clear_error();\n\n  memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  set_logger(conn, data);\n  rc = SSL_write(backend->handle, mem, memlen);\n\n  if(rc <= 0) {\n    err = SSL_get_error(backend->handle, rc);\n\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* The operation did not complete; the same TLS/SSL I/O function\n         should be called again later. This is basically an EWOULDBLOCK\n         equivalent. */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    case SSL_ERROR_SYSCALL:\n      {\n        int sockerr = SOCKERRNO;\n        sslerror = ERR_get_error();\n        if(sslerror)\n          ossl_strerror(sslerror, error_buffer, sizeof(error_buffer));\n        else if(sockerr)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          strncpy(error_buffer, SSL_ERROR_to_str(err), sizeof(error_buffer));\n          error_buffer[sizeof(error_buffer) - 1] = '\\0';\n        }\n        failf(data, OSSL_PACKAGE \" SSL_write: %s, errno %d\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_SEND_ERROR;\n        return -1;\n      }\n    case SSL_ERROR_SSL:\n      /*  A failure in the SSL library occurred, usually a protocol error.\n          The OpenSSL error queue contains more information on the error. */\n      sslerror = ERR_get_error();\n      if(ERR_GET_LIB(sslerror) == ERR_LIB_SSL &&\n         ERR_GET_REASON(sslerror) == SSL_R_BIO_NOT_SET &&\n         conn->ssl[sockindex].state == ssl_connection_complete\n#ifndef CURL_DISABLE_PROXY\n         && conn->proxy_ssl[sockindex].state == ssl_connection_complete\n#endif\n        ) {\n        char ver[120];\n        ossl_version(ver, 120);\n        failf(data, \"Error: %s does not support double SSL tunneling.\", ver);\n      }\n      else\n        failf(data, \"SSL_write() error: %s\",\n              ossl_strerror(sslerror, error_buffer, sizeof(error_buffer)));\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n    /* a true error */\n    failf(data, OSSL_PACKAGE \" SSL_write: %s, errno %d\",\n          SSL_ERROR_to_str(err), SOCKERRNO);\n    *curlcode = CURLE_SEND_ERROR;\n    return -1;\n  }\n  *curlcode = CURLE_OK;\n  return (ssize_t)rc; /* number of bytes */\n}\n\nstatic ssize_t ossl_recv(struct Curl_easy *data,   /* transfer */\n                         int num,                  /* socketindex */\n                         char *buf,                /* store read data here */\n                         size_t buffersize,        /* max amount to read */\n                         CURLcode *curlcode)\n{\n  char error_buffer[256];\n  unsigned long sslerror;\n  ssize_t nread;\n  int buffsize;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  ERR_clear_error();\n\n  buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  set_logger(conn, data);\n  nread = (ssize_t)SSL_read(backend->handle, buf, buffsize);\n  if(nread <= 0) {\n    /* failed SSL_read */\n    int err = SSL_get_error(backend->handle, (int)nread);\n\n    switch(err) {\n    case SSL_ERROR_NONE: /* this is not an error */\n      break;\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n      /* close_notify alert */\n      if(num == FIRSTSOCKET)\n        /* mark the connection for close if it is indeed the control\n           connection */\n        connclose(conn, \"TLS close_notify\");\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      /* openssl/ssl.h for SSL_ERROR_SYSCALL says \"look at error stack/return\n         value/errno\" */\n      /* https://www.openssl.org/docs/crypto/ERR_get_error.html */\n      sslerror = ERR_get_error();\n      if((nread < 0) || sslerror) {\n        /* If the return code was negative or there actually is an error in the\n           queue */\n        int sockerr = SOCKERRNO;\n        if(sslerror)\n          ossl_strerror(sslerror, error_buffer, sizeof(error_buffer));\n        else if(sockerr && err == SSL_ERROR_SYSCALL)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          strncpy(error_buffer, SSL_ERROR_to_str(err), sizeof(error_buffer));\n          error_buffer[sizeof(error_buffer) - 1] = '\\0';\n        }\n        failf(data, OSSL_PACKAGE \" SSL_read: %s, errno %d\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1;\n      }\n      /* For debug builds be a little stricter and error on any\n         SSL_ERROR_SYSCALL. For example a server may have closed the connection\n         abruptly without a close_notify alert. For compatibility with older\n         peers we don't do this by default. #4624\n\n         We can use this to gauge how many users may be affected, and\n         if it goes ok eventually transition to allow in dev and release with\n         the newest OpenSSL: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) */\n#ifdef DEBUGBUILD\n      if(err == SSL_ERROR_SYSCALL) {\n        int sockerr = SOCKERRNO;\n        if(sockerr)\n          Curl_strerror(sockerr, error_buffer, sizeof(error_buffer));\n        else {\n          msnprintf(error_buffer, sizeof(error_buffer),\n                    \"Connection closed abruptly\");\n        }\n        failf(data, OSSL_PACKAGE \" SSL_read: %s, errno %d\"\n              \" (Fatal because this is a curl debug build)\",\n              error_buffer, sockerr);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1;\n      }\n#endif\n    }\n  }\n  return nread;\n}\n\nstatic size_t ossl_version(char *buffer, size_t size)\n{\n#ifdef LIBRESSL_VERSION_NUMBER\n#if LIBRESSL_VERSION_NUMBER < 0x2070100fL\n  return msnprintf(buffer, size, \"%s/%lx.%lx.%lx\",\n                   OSSL_PACKAGE,\n                   (LIBRESSL_VERSION_NUMBER>>28)&0xf,\n                   (LIBRESSL_VERSION_NUMBER>>20)&0xff,\n                   (LIBRESSL_VERSION_NUMBER>>12)&0xff);\n#else /* OpenSSL_version() first appeared in LibreSSL 2.7.1 */\n  char *p;\n  int count;\n  const char *ver = OpenSSL_version(OPENSSL_VERSION);\n  const char expected[] = OSSL_PACKAGE \" \"; /* ie \"LibreSSL \" */\n  if(Curl_strncasecompare(ver, expected, sizeof(expected) - 1)) {\n    ver += sizeof(expected) - 1;\n  }\n  count = msnprintf(buffer, size, \"%s/%s\", OSSL_PACKAGE, ver);\n  for(p = buffer; *p; ++p) {\n    if(ISSPACE(*p))\n      *p = '_';\n  }\n  return count;\n#endif\n#elif defined(OPENSSL_IS_BORINGSSL)\n  return msnprintf(buffer, size, OSSL_PACKAGE);\n#elif defined(HAVE_OPENSSL_VERSION) && defined(OPENSSL_VERSION_STRING)\n  return msnprintf(buffer, size, \"%s/%s\",\n                   OSSL_PACKAGE, OpenSSL_version(OPENSSL_VERSION_STRING));\n#else\n  /* not LibreSSL, BoringSSL and not using OpenSSL_version */\n\n  char sub[3];\n  unsigned long ssleay_value;\n  sub[2]='\\0';\n  sub[1]='\\0';\n  ssleay_value = OpenSSL_version_num();\n  if(ssleay_value < 0x906000) {\n    ssleay_value = SSLEAY_VERSION_NUMBER;\n    sub[0]='\\0';\n  }\n  else {\n    if(ssleay_value&0xff0) {\n      int minor_ver = (ssleay_value >> 4) & 0xff;\n      if(minor_ver > 26) {\n        /* handle extended version introduced for 0.9.8za */\n        sub[1] = (char) ((minor_ver - 1) % 26 + 'a' + 1);\n        sub[0] = 'z';\n      }\n      else {\n        sub[0] = (char) (minor_ver + 'a' - 1);\n      }\n    }\n    else\n      sub[0]='\\0';\n  }\n\n  return msnprintf(buffer, size, \"%s/%lx.%lx.%lx%s\"\n#ifdef OPENSSL_FIPS\n                   \"-fips\"\n#endif\n                   ,\n                   OSSL_PACKAGE,\n                   (ssleay_value>>28)&0xf,\n                   (ssleay_value>>20)&0xff,\n                   (ssleay_value>>12)&0xff,\n                   sub);\n#endif /* OPENSSL_IS_BORINGSSL */\n}\n\n/* can be called with data == NULL */\nstatic CURLcode ossl_random(struct Curl_easy *data,\n                            unsigned char *entropy, size_t length)\n{\n  int rc;\n  if(data) {\n    if(ossl_seed(data)) /* Initiate the seed if not already done */\n      return CURLE_FAILED_INIT; /* couldn't seed for some reason */\n  }\n  else {\n    if(!rand_enough())\n      return CURLE_FAILED_INIT;\n  }\n  /* RAND_bytes() returns 1 on success, 0 otherwise.  */\n  rc = RAND_bytes(entropy, curlx_uztosi(length));\n  return (rc == 1 ? CURLE_OK : CURLE_FAILED_INIT);\n}\n\n#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\nstatic CURLcode ossl_sha256sum(const unsigned char *tmp, /* input */\n                               size_t tmplen,\n                               unsigned char *sha256sum /* output */,\n                               size_t unused)\n{\n  EVP_MD_CTX *mdctx;\n  unsigned int len = 0;\n  (void) unused;\n\n  mdctx = EVP_MD_CTX_create();\n  if(!mdctx)\n    return CURLE_OUT_OF_MEMORY;\n  EVP_DigestInit(mdctx, EVP_sha256());\n  EVP_DigestUpdate(mdctx, tmp, tmplen);\n  EVP_DigestFinal_ex(mdctx, sha256sum, &len);\n  EVP_MD_CTX_destroy(mdctx);\n  return CURLE_OK;\n}\n#endif\n\nstatic bool ossl_cert_status_request(void)\n{\n#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \\\n    !defined(OPENSSL_NO_OCSP)\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic void *ossl_get_internals(struct ssl_connect_data *connssl,\n                                CURLINFO info)\n{\n  /* Legacy: CURLINFO_TLS_SESSION must return an SSL_CTX pointer. */\n  struct ssl_backend_data *backend = connssl->backend;\n  return info == CURLINFO_TLS_SESSION ?\n         (void *)backend->ctx : (void *)backend->handle;\n}\n\nstatic void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  /* If we don't have SSL context, do nothing. */\n  if(!backend->handle)\n    return;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      /* Store the data needed for the \"new session\" callback.\n       * The sockindex is stored as a pointer to an array element. */\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}\n\n/*\n * Starting with TLS 1.3, the ossl_new_session_cb callback gets called after\n * the handshake. If the transfer that sets up the callback gets killed before\n * this callback arrives, we must make sure to properly clear the data to\n * avoid UAF problems. A future optimization could be to instead store another\n * transfer that might still be using the same connection.\n */\n\nstatic void ossl_disassociate_connection(struct Curl_easy *data,\n                                         int sockindex)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  /* If we don't have SSL context, do nothing. */\n  if(!backend->handle)\n    return;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool isproxy = FALSE;\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      /* Invalidate the session cache entry, if any */\n      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n\n      /* Disable references to data in \"new session\" callback to avoid\n       * accessing a stale pointer. */\n      SSL_set_ex_data(backend->handle, data_idx, NULL);\n      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n    }\n\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                      &old_ssl_sessionid, NULL, sockindex));\n    if(incache)\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n    Curl_ssl_sessionid_unlock(data);\n  }\n}\n\nconst struct Curl_ssl Curl_ssl_openssl = {\n  { CURLSSLBACKEND_OPENSSL, \"openssl\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CAINFO_BLOB |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_SSL_CTX |\n#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES\n  SSLSUPP_TLS13_CIPHERSUITES |\n#endif\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct ssl_backend_data),\n\n  ossl_init,                /* init */\n  ossl_cleanup,             /* cleanup */\n  ossl_version,             /* version */\n  ossl_check_cxn,           /* check_cxn */\n  ossl_shutdown,            /* shutdown */\n  ossl_data_pending,        /* data_pending */\n  ossl_random,              /* random */\n  ossl_cert_status_request, /* cert_status_request */\n  ossl_connect,             /* connect */\n  ossl_connect_nonblocking, /* connect_nonblocking */\n  Curl_ssl_getsock,         /* getsock */\n  ossl_get_internals,       /* get_internals */\n  ossl_close,               /* close_one */\n  ossl_close_all,           /* close_all */\n  ossl_session_free,        /* session_free */\n  ossl_set_engine,          /* set_engine */\n  ossl_set_engine_default,  /* set_engine_default */\n  ossl_engines_list,        /* engines_list */\n  Curl_none_false_start,    /* false_start */\n#if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\n  ossl_sha256sum,           /* sha256sum */\n#else\n  NULL,                     /* sha256sum */\n#endif\n  ossl_associate_connection, /* associate_connection */\n  ossl_disassociate_connection /* disassociate_connection */\n};\n\n#endif /* USE_OPENSSL */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2020 - 2021, Jacob Hoffman-Andrews,\n * <github@hoffman-andrews.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\n#ifdef USE_RUSTLS\n\n#include \"curl_printf.h\"\n\n#include <errno.h>\n#include <crustls.h>\n\n#include \"inet_pton.h\"\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"vtls.h\"\n#include \"select.h\"\n\n#include \"multiif.h\"\n\n/* Per https://www.bearssl.org/api1.html, max TLS record size plus max\n   per-record overhead. */\n#define TLSBUF_SIZE (16384 + 325)\n\nstruct ssl_backend_data\n{\n  const struct rustls_client_config *config;\n  struct rustls_client_session *session;\n  bool data_pending;\n  uint8_t *tlsbuf;\n};\n\n/* For a given rustls_result error code, return the best-matching CURLcode. */\nstatic CURLcode map_error(rustls_result r)\n{\n  if(rustls_result_is_cert_error(r)) {\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  switch(r) {\n    case RUSTLS_RESULT_OK:\n      return CURLE_OK;\n    case RUSTLS_RESULT_NULL_PARAMETER:\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    default:\n      return CURLE_READ_ERROR;\n  }\n}\n\nstatic bool\ncr_data_pending(const struct connectdata *conn, int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  return backend->data_pending;\n}\n\nstatic CURLcode\ncr_connect(struct Curl_easy *data UNUSED_PARAM,\n                    struct connectdata *conn UNUSED_PARAM,\n                    int sockindex UNUSED_PARAM)\n{\n  infof(data, \"rustls_connect: unimplemented\\n\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\n/*\n * On each run:\n *  - Read a chunk of bytes from the socket into rustls' TLS input buffer.\n *  - Tell rustls to process any new packets.\n *  - Read out as many plaintext bytes from rustls as possible, until hitting\n *    error, EOF, or EAGAIN/EWOULDBLOCK, or plainbuf/plainlen is filled up.\n *\n * It's okay to call this function with plainbuf == NULL and plainlen == 0.\n * In that case, it will copy bytes from the socket into rustls' TLS input\n * buffer, and process packets, but won't consume bytes from rustls' plaintext\n * output buffer.\n */\nstatic ssize_t\ncr_recv(struct Curl_easy *data, int sockindex,\n            char *plainbuf, size_t plainlen, CURLcode *err)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *const session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  size_t n = 0;\n  ssize_t tls_bytes_read = 0;\n  size_t tls_bytes_processed = 0;\n  size_t plain_bytes_copied = 0;\n  rustls_result rresult = 0;\n  char errorbuf[255];\n\n  tls_bytes_read = sread(sockfd, backend->tlsbuf, TLSBUF_SIZE);\n  if(tls_bytes_read == 0) {\n    failf(data, \"connection closed without TLS close_notify alert\");\n    *err = CURLE_READ_ERROR;\n    return -1;\n  }\n  else if(tls_bytes_read < 0) {\n    if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {\n      infof(data, \"sread: EAGAIN or EWOULDBLOCK\\n\");\n      /* There is no data in the socket right now, but there could still be\n         some data in the rustls session, so we need to read from it below. */\n      tls_bytes_read = 0;\n    }\n    else {\n      failf(data, \"reading from socket: %s\", strerror(SOCKERRNO));\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n  }\n\n  /*\n  * Now pull those bytes from the buffer into ClientSession.\n  */\n  DEBUGASSERT(tls_bytes_read >= 0);\n  while(tls_bytes_processed < (size_t)tls_bytes_read) {\n    rresult = rustls_client_session_read_tls(session,\n      backend->tlsbuf + tls_bytes_processed,\n      tls_bytes_read - tls_bytes_processed,\n      &n);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_read_tls\");\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n    else if(n == 0) {\n      infof(data, \"EOF from rustls_client_session_read_tls\\n\");\n      break;\n    }\n\n    rresult = rustls_client_session_process_new_packets(session);\n    if(rresult != RUSTLS_RESULT_OK) {\n      rustls_error(rresult, errorbuf, sizeof(errorbuf), &n);\n      failf(data, \"%.*s\", n, errorbuf);\n      *err = map_error(rresult);\n      return -1;\n    }\n\n    tls_bytes_processed += n;\n    backend->data_pending = TRUE;\n  }\n\n  while(plain_bytes_copied < plainlen) {\n    rresult = rustls_client_session_read(session,\n      (uint8_t *)plainbuf + plain_bytes_copied,\n      plainlen - plain_bytes_copied,\n      &n);\n    if(rresult == RUSTLS_RESULT_ALERT_CLOSE_NOTIFY) {\n      *err = CURLE_OK;\n      return 0;\n    }\n    else if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_read\");\n      *err = CURLE_READ_ERROR;\n      return -1;\n    }\n    else if(n == 0) {\n      /* rustls returns 0 from client_session_read to mean \"all currently\n        available data has been read.\" If we bring in more ciphertext with\n        read_tls, more plaintext will become available. So don't tell curl\n        this is an EOF. Instead, say \"come back later.\" */\n      infof(data, \"EOF from rustls_client_session_read\\n\");\n      backend->data_pending = FALSE;\n      break;\n    }\n    else {\n      plain_bytes_copied += n;\n    }\n  }\n\n  /* If we wrote out 0 plaintext bytes, it might just mean we haven't yet\n     read a full TLS record. Return CURLE_AGAIN so curl doesn't treat this\n     as EOF. */\n  if(plain_bytes_copied == 0) {\n    *err = CURLE_AGAIN;\n    return -1;\n  }\n\n  return plain_bytes_copied;\n}\n\n/*\n * On each call:\n *  - Copy `plainlen` bytes into rustls' plaintext input buffer (if > 0).\n *  - Fully drain rustls' plaintext output buffer into the socket until\n *    we get either an error or EAGAIN/EWOULDBLOCK.\n *\n * It's okay to call this function with plainbuf == NULL and plainlen == 0.\n * In that case, it won't read anything into rustls' plaintext input buffer.\n * It will only drain rustls' plaintext output buffer into the socket.\n */\nstatic ssize_t\ncr_send(struct Curl_easy *data, int sockindex,\n        const void *plainbuf, size_t plainlen, CURLcode *err)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *const session = backend->session;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  ssize_t n = 0;\n  size_t plainwritten = 0;\n  size_t tlslen = 0;\n  size_t tlswritten = 0;\n  rustls_result rresult;\n\n  if(plainlen > 0) {\n    rresult = rustls_client_session_write(session,\n                                          plainbuf, plainlen, &plainwritten);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_write\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n    else if(plainwritten == 0) {\n      failf(data, \"EOF in rustls_client_session_write\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n  }\n\n  while(rustls_client_session_wants_write(session)) {\n    rresult = rustls_client_session_write_tls(\n      session, backend->tlsbuf, TLSBUF_SIZE, &tlslen);\n    if(rresult != RUSTLS_RESULT_OK) {\n      failf(data, \"error in rustls_client_session_write_tls\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n    else if(tlslen == 0) {\n      failf(data, \"EOF in rustls_client_session_write_tls\");\n      *err = CURLE_WRITE_ERROR;\n      return -1;\n    }\n\n    tlswritten = 0;\n\n    while(tlswritten < tlslen) {\n      n = swrite(sockfd, backend->tlsbuf + tlswritten, tlslen - tlswritten);\n      if(n < 0) {\n        if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {\n          /* Since recv is called from poll, there should be room to\n             write at least some bytes before hitting EAGAIN. */\n          infof(data, \"swrite: EAGAIN after %ld bytes\\n\", tlswritten);\n          DEBUGASSERT(tlswritten > 0);\n          break;\n        }\n        failf(data, \"error in swrite\");\n        *err = CURLE_WRITE_ERROR;\n        return -1;\n      }\n      if(n == 0) {\n        failf(data, \"EOF in swrite\");\n        *err = CURLE_WRITE_ERROR;\n        return -1;\n      }\n      tlswritten += n;\n    }\n\n    DEBUGASSERT(tlswritten <= tlslen);\n  }\n\n  return plainwritten;\n}\n\n/* A server certificate verify callback for rustls that always returns\n   RUSTLS_RESULT_OK, or in other words disable certificate verification. */\nstatic enum rustls_result\ncr_verify_none(void *userdata UNUSED_PARAM,\n               const rustls_verify_server_cert_params *params UNUSED_PARAM)\n{\n  return RUSTLS_RESULT_OK;\n}\n\nstatic bool\ncr_hostname_is_ip(const char *hostname)\n{\n  struct in_addr in;\n#ifdef ENABLE_IPV6\n  struct in6_addr in6;\n  if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0) {\n    return true;\n  }\n#endif /* ENABLE_IPV6 */\n  if(Curl_inet_pton(AF_INET, hostname, &in) > 0) {\n    return true;\n  }\n  return false;\n}\n\nstatic CURLcode\ncr_init_backend(struct Curl_easy *data, struct connectdata *conn,\n                struct ssl_backend_data *const backend)\n{\n  struct rustls_client_session *session = backend->session;\n  struct rustls_client_config_builder *config_builder = NULL;\n  const char *const ssl_cafile = SSL_CONN_CONFIG(CAfile);\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  const char *hostname = conn->host.name;\n  char errorbuf[256];\n  size_t errorlen;\n  int result;\n  rustls_slice_bytes alpn[2] = {\n    { (const uint8_t *)ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH },\n    { (const uint8_t *)ALPN_H2, ALPN_H2_LENGTH },\n  };\n\n  backend->tlsbuf = calloc(TLSBUF_SIZE, 1);\n  if(!backend->tlsbuf) {\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  config_builder = rustls_client_config_builder_new();\n#ifdef USE_HTTP2\n  infof(data, \"offering ALPN for HTTP/1.1 and HTTP/2\\n\");\n  rustls_client_config_builder_set_protocols(config_builder, alpn, 2);\n#else\n  infof(data, \"offering ALPN for HTTP/1.1 only\\n\");\n  rustls_client_config_builder_set_protocols(config_builder, alpn, 1);\n#endif\n  if(!verifypeer) {\n    rustls_client_config_builder_dangerous_set_certificate_verifier(\n      config_builder, cr_verify_none, NULL);\n    /* rustls doesn't support IP addresses (as of 0.19.0), and will reject\n     * sessions created with an IP address, even when certificate verification\n     * is turned off. Set a placeholder hostname and disable SNI. */\n    if(cr_hostname_is_ip(hostname)) {\n      rustls_client_config_builder_set_enable_sni(config_builder, false);\n      hostname = \"example.invalid\";\n    }\n  }\n  else if(ssl_cafile) {\n    result = rustls_client_config_builder_load_roots_from_file(\n      config_builder, ssl_cafile);\n    if(result != RUSTLS_RESULT_OK) {\n      failf(data, \"failed to load trusted certificates\");\n      rustls_client_config_free(\n        rustls_client_config_builder_build(config_builder));\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else {\n    result = rustls_client_config_builder_load_native_roots(config_builder);\n    if(result != RUSTLS_RESULT_OK) {\n      failf(data, \"failed to load trusted certificates\");\n      rustls_client_config_free(\n        rustls_client_config_builder_build(config_builder));\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  backend->config = rustls_client_config_builder_build(config_builder);\n  DEBUGASSERT(session == NULL);\n  result = rustls_client_session_new(\n    backend->config, hostname, &session);\n  if(result != RUSTLS_RESULT_OK) {\n    rustls_error(result, errorbuf, sizeof(errorbuf), &errorlen);\n    failf(data, \"failed to create client session: %.*s\", errorlen, errorbuf);\n    return CURLE_COULDNT_CONNECT;\n  }\n  backend->session = session;\n  return CURLE_OK;\n}\n\nstatic void\ncr_set_negotiated_alpn(struct Curl_easy *data, struct connectdata *conn,\n  const struct rustls_client_session *session)\n{\n  const uint8_t *protocol = NULL;\n  size_t len = 0;\n\n  rustls_client_session_get_alpn_protocol(session, &protocol, &len);\n  if(NULL == protocol) {\n    infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    return;\n  }\n\n#ifdef USE_HTTP2\n  if(len == ALPN_H2_LENGTH && 0 == memcmp(ALPN_H2, protocol, len)) {\n    infof(data, \"ALPN, negotiated h2\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_2;\n  }\n  else\n#endif\n  if(len == ALPN_HTTP_1_1_LENGTH &&\n      0 == memcmp(ALPN_HTTP_1_1, protocol, len)) {\n    infof(data, \"ALPN, negotiated http/1.1\\n\");\n    conn->negnpn = CURL_HTTP_VERSION_1_1;\n  }\n  else {\n    infof(data, \"ALPN, negotiated an unrecognized protocol\\n\");\n  }\n\n  Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                      BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n}\n\nstatic CURLcode\ncr_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex, bool *done)\n{\n  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *session = NULL;\n  CURLcode tmperr = CURLE_OK;\n  int result;\n  int what;\n  bool wants_read;\n  bool wants_write;\n  curl_socket_t writefd;\n  curl_socket_t readfd;\n\n  if(ssl_connection_none == connssl->state) {\n    result = cr_init_backend(data, conn, connssl->backend);\n    if(result != CURLE_OK) {\n      return result;\n    }\n    connssl->state = ssl_connection_negotiating;\n  }\n\n  session = backend->session;\n\n  /* Read/write data until the handshake is done or the socket would block. */\n  for(;;) {\n    /*\n    * Connection has been established according to rustls. Set send/recv\n    * handlers, and update the state machine.\n    * This check has to come last because is_handshaking starts out false,\n    * then becomes true when we first write data, then becomes false again\n    * once the handshake is done.\n    */\n    if(!rustls_client_session_is_handshaking(session)) {\n      infof(data, \"Done handshaking\\n\");\n      /* Done with the handshake. Set up callbacks to send/receive data. */\n      connssl->state = ssl_connection_complete;\n\n      cr_set_negotiated_alpn(data, conn, session);\n\n      conn->recv[sockindex] = cr_recv;\n      conn->send[sockindex] = cr_send;\n      *done = TRUE;\n      return CURLE_OK;\n    }\n\n    wants_read = rustls_client_session_wants_read(session);\n    wants_write = rustls_client_session_wants_write(session);\n    DEBUGASSERT(wants_read || wants_write);\n    writefd = wants_write?sockfd:CURL_SOCKET_BAD;\n    readfd = wants_read?sockfd:CURL_SOCKET_BAD;\n\n    what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd, 0);\n    if(what < 0) {\n      /* fatal error */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    if(0 == what) {\n      infof(data, \"Curl_socket_check: %s would block\\n\",\n          wants_read&&wants_write ?\n            \"writing and reading\" :\n            wants_write ?\n              \"writing\" :\n              \"reading\");\n      *done = FALSE;\n      return CURLE_OK;\n    }\n    /* socket is readable or writable */\n\n    if(wants_write) {\n      infof(data, \"ClientSession wants us to write_tls.\\n\");\n      cr_send(data, sockindex, NULL, 0, &tmperr);\n      if(tmperr == CURLE_AGAIN) {\n        infof(data, \"writing would block\\n\");\n        /* fall through */\n      }\n      else if(tmperr != CURLE_OK) {\n        return tmperr;\n      }\n    }\n\n    if(wants_read) {\n      infof(data, \"ClientSession wants us to read_tls.\\n\");\n\n      cr_recv(data, sockindex, NULL, 0, &tmperr);\n      if(tmperr == CURLE_AGAIN) {\n        infof(data, \"reading would block\\n\");\n        /* fall through */\n      }\n      else if(tmperr != CURLE_OK) {\n        if(tmperr == CURLE_READ_ERROR) {\n          return CURLE_SSL_CONNECT_ERROR;\n        }\n        else {\n          return tmperr;\n        }\n      }\n    }\n  }\n\n  /* We should never fall through the loop. We should return either because\n     the handshake is done or because we can't read/write without blocking. */\n  DEBUGASSERT(false);\n}\n\n/* returns a bitmap of flags for this connection's first socket indicating\n   whether we want to read or write */\nstatic int\ncr_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  struct ssl_connect_data *const connssl = &conn->ssl[FIRSTSOCKET];\n  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];\n  struct ssl_backend_data *const backend = connssl->backend;\n  struct rustls_client_session *session = backend->session;\n\n  if(rustls_client_session_wants_write(session)) {\n    socks[0] = sockfd;\n    return GETSOCK_WRITESOCK(0);\n  }\n  if(rustls_client_session_wants_read(session)) {\n    socks[0] = sockfd;\n    return GETSOCK_READSOCK(0);\n  }\n\n  return GETSOCK_BLANK;\n}\n\nstatic void *\ncr_get_internals(struct ssl_connect_data *connssl,\n                 CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  return &backend->session;\n}\n\nstatic void\ncr_close(struct Curl_easy *data, struct connectdata *conn,\n         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CURLcode tmperr = CURLE_OK;\n  ssize_t n = 0;\n\n  if(backend->session) {\n    rustls_client_session_send_close_notify(backend->session);\n    n = cr_send(data, sockindex, NULL, 0, &tmperr);\n    if(n < 0) {\n      failf(data, \"error sending close notify: %d\", tmperr);\n    }\n\n    rustls_client_session_free(backend->session);\n    backend->session = NULL;\n  }\n  if(backend->config) {\n    rustls_client_config_free(backend->config);\n    backend->config = NULL;\n  }\n  free(backend->tlsbuf);\n}\n\nconst struct Curl_ssl Curl_ssl_rustls = {\n  { CURLSSLBACKEND_RUSTLS, \"rustls\" },\n  SSLSUPP_TLS13_CIPHERSUITES,      /* supports */\n  sizeof(struct ssl_backend_data),\n\n  Curl_none_init,                  /* init */\n  Curl_none_cleanup,               /* cleanup */\n  rustls_version,                  /* version */\n  Curl_none_check_cxn,             /* check_cxn */\n  Curl_none_shutdown,              /* shutdown */\n  cr_data_pending,                 /* data_pending */\n  Curl_none_random,                /* random */\n  Curl_none_cert_status_request,   /* cert_status_request */\n  cr_connect,                      /* connect */\n  cr_connect_nonblocking,          /* connect_nonblocking */\n  cr_getsock,                      /* cr_getsock */\n  cr_get_internals,                /* get_internals */\n  cr_close,                        /* close_one */\n  Curl_none_close_all,             /* close_all */\n  Curl_none_session_free,          /* session_free */\n  Curl_none_set_engine,            /* set_engine */\n  Curl_none_set_engine_default,    /* set_engine_default */\n  Curl_none_engines_list,          /* engines_list */\n  Curl_none_false_start,           /* false_start */\n  NULL,                            /* sha256sum */\n  NULL,                            /* associate_connection */\n  NULL                             /* disassociate_connection */\n};\n\n#endif /* USE_RUSTLS */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2016, Marc Hoersken, <info@marc-hoersken.de>\n * Copyright (C) 2012, Mark Salisbury, <mark.salisbury@hp.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all Schannel-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_SCHANNEL\n\n#define EXPOSE_SCHANNEL_INTERNAL_STRUCTS\n\n#ifndef USE_WINDOWS_SSPI\n#  error \"Can't compile SCHANNEL support without SSPI.\"\n#endif\n\n#include \"schannel.h\"\n#include \"vtls.h\"\n#include \"strcase.h\"\n#include \"sendf.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"strerror.h\"\n#include \"select.h\" /* for the socket readiness */\n#include \"inet_pton.h\" /* for IP addr SNI check */\n#include \"curl_multibyte.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n#include \"version_win32.h\"\n\n/* The last #include file should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* ALPN requires version 8.1 of the Windows SDK, which was\n   shipped with Visual Studio 2013, aka _MSC_VER 1800:\n\n   https://technet.microsoft.com/en-us/library/hh831771%28v=ws.11%29.aspx\n*/\n#if defined(_MSC_VER) && (_MSC_VER >= 1800) && !defined(_USING_V110_SDK71_)\n#  define HAS_ALPN 1\n#endif\n\n#ifndef UNISP_NAME_A\n#define UNISP_NAME_A \"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME_W\n#define UNISP_NAME_W L\"Microsoft Unified Security Protocol Provider\"\n#endif\n\n#ifndef UNISP_NAME\n#ifdef UNICODE\n#define UNISP_NAME  UNISP_NAME_W\n#else\n#define UNISP_NAME  UNISP_NAME_A\n#endif\n#endif\n\n#if defined(CryptStringToBinary) && defined(CRYPT_STRING_HEX)\n#define HAS_CLIENT_CERT_PATH\n#endif\n\n#ifdef HAS_CLIENT_CERT_PATH\n#ifdef UNICODE\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_W\n#else\n#define CURL_CERT_STORE_PROV_SYSTEM CERT_STORE_PROV_SYSTEM_A\n#endif\n#endif\n\n#ifndef SP_PROT_SSL2_CLIENT\n#define SP_PROT_SSL2_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_SSL3_CLIENT\n#define SP_PROT_SSL3_CLIENT             0x00000008\n#endif\n\n#ifndef SP_PROT_TLS1_CLIENT\n#define SP_PROT_TLS1_CLIENT             0x00000080\n#endif\n\n#ifndef SP_PROT_TLS1_0_CLIENT\n#define SP_PROT_TLS1_0_CLIENT           SP_PROT_TLS1_CLIENT\n#endif\n\n#ifndef SP_PROT_TLS1_1_CLIENT\n#define SP_PROT_TLS1_1_CLIENT           0x00000200\n#endif\n\n#ifndef SP_PROT_TLS1_2_CLIENT\n#define SP_PROT_TLS1_2_CLIENT           0x00000800\n#endif\n\n#ifndef SCH_USE_STRONG_CRYPTO\n#define SCH_USE_STRONG_CRYPTO           0x00400000\n#endif\n\n#ifndef SECBUFFER_ALERT\n#define SECBUFFER_ALERT                 17\n#endif\n\n/* Both schannel buffer sizes must be > 0 */\n#define CURL_SCHANNEL_BUFFER_INIT_SIZE   4096\n#define CURL_SCHANNEL_BUFFER_FREE_SIZE   1024\n\n#define CERT_THUMBPRINT_STR_LEN 40\n#define CERT_THUMBPRINT_DATA_LEN 20\n\n/* Uncomment to force verbose output\n * #define infof(x, y, ...) printf(y, __VA_ARGS__)\n * #define failf(x, y, ...) printf(y, __VA_ARGS__)\n */\n\n#ifndef CALG_SHA_256\n#  define CALG_SHA_256 0x0000800c\n#endif\n\n#define BACKEND connssl->backend\n\nstatic Curl_recv schannel_recv;\nstatic Curl_send schannel_send;\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey);\n\nstatic void InitSecBuffer(SecBuffer *buffer, unsigned long BufType,\n                          void *BufDataPtr, unsigned long BufByteSize)\n{\n  buffer->cbBuffer = BufByteSize;\n  buffer->BufferType = BufType;\n  buffer->pvBuffer = BufDataPtr;\n}\n\nstatic void InitSecBufferDesc(SecBufferDesc *desc, SecBuffer *BufArr,\n                              unsigned long NumArrElem)\n{\n  desc->ulVersion = SECBUFFER_VERSION;\n  desc->pBuffers = BufArr;\n  desc->cBuffers = NumArrElem;\n}\n\nstatic CURLcode\nset_ssl_version_min_max(SCHANNEL_CRED *schannel_cred, struct Curl_easy *data,\n                        struct connectdata *conn)\n{\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long i = ssl_version;\n\n  switch(ssl_version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    break;\n  }\n  for(; i <= (ssl_version_max >> 16); ++i) {\n    switch(i) {\n    case CURL_SSLVERSION_TLSv1_0:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_0_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_1:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_1_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_2:\n      schannel_cred->grbitEnabledProtocols |= SP_PROT_TLS1_2_CLIENT;\n      break;\n    case CURL_SSLVERSION_TLSv1_3:\n      failf(data, \"schannel: TLS 1.3 is not yet supported\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  return CURLE_OK;\n}\n\n/*longest is 26, buffer is slightly bigger*/\n#define LONGEST_ALG_ID 32\n#define CIPHEROPTION(X)                         \\\n  if(strcmp(#X, tmp) == 0)                      \\\n    return X\n\nstatic int\nget_alg_id_by_name(char *name)\n{\n  char tmp[LONGEST_ALG_ID] = { 0 };\n  char *nameEnd = strchr(name, ':');\n  size_t n = nameEnd ? min((size_t)(nameEnd - name), LONGEST_ALG_ID - 1) : \\\n    min(strlen(name), LONGEST_ALG_ID - 1);\n  strncpy(tmp, name, n);\n  tmp[n] = 0;\n  CIPHEROPTION(CALG_MD2);\n  CIPHEROPTION(CALG_MD4);\n  CIPHEROPTION(CALG_MD5);\n  CIPHEROPTION(CALG_SHA);\n  CIPHEROPTION(CALG_SHA1);\n  CIPHEROPTION(CALG_MAC);\n  CIPHEROPTION(CALG_RSA_SIGN);\n  CIPHEROPTION(CALG_DSS_SIGN);\n/*ifdefs for the options that are defined conditionally in wincrypt.h*/\n#ifdef CALG_NO_SIGN\n  CIPHEROPTION(CALG_NO_SIGN);\n#endif\n  CIPHEROPTION(CALG_RSA_KEYX);\n  CIPHEROPTION(CALG_DES);\n#ifdef CALG_3DES_112\n  CIPHEROPTION(CALG_3DES_112);\n#endif\n  CIPHEROPTION(CALG_3DES);\n  CIPHEROPTION(CALG_DESX);\n  CIPHEROPTION(CALG_RC2);\n  CIPHEROPTION(CALG_RC4);\n  CIPHEROPTION(CALG_SEAL);\n#ifdef CALG_DH_SF\n  CIPHEROPTION(CALG_DH_SF);\n#endif\n  CIPHEROPTION(CALG_DH_EPHEM);\n#ifdef CALG_AGREEDKEY_ANY\n  CIPHEROPTION(CALG_AGREEDKEY_ANY);\n#endif\n#ifdef CALG_HUGHES_MD5\n  CIPHEROPTION(CALG_HUGHES_MD5);\n#endif\n  CIPHEROPTION(CALG_SKIPJACK);\n#ifdef CALG_TEK\n  CIPHEROPTION(CALG_TEK);\n#endif\n  CIPHEROPTION(CALG_CYLINK_MEK);\n  CIPHEROPTION(CALG_SSL3_SHAMD5);\n#ifdef CALG_SSL3_MASTER\n  CIPHEROPTION(CALG_SSL3_MASTER);\n#endif\n#ifdef CALG_SCHANNEL_MASTER_HASH\n  CIPHEROPTION(CALG_SCHANNEL_MASTER_HASH);\n#endif\n#ifdef CALG_SCHANNEL_MAC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_MAC_KEY);\n#endif\n#ifdef CALG_SCHANNEL_ENC_KEY\n  CIPHEROPTION(CALG_SCHANNEL_ENC_KEY);\n#endif\n#ifdef CALG_PCT1_MASTER\n  CIPHEROPTION(CALG_PCT1_MASTER);\n#endif\n#ifdef CALG_SSL2_MASTER\n  CIPHEROPTION(CALG_SSL2_MASTER);\n#endif\n#ifdef CALG_TLS1_MASTER\n  CIPHEROPTION(CALG_TLS1_MASTER);\n#endif\n#ifdef CALG_RC5\n  CIPHEROPTION(CALG_RC5);\n#endif\n#ifdef CALG_HMAC\n  CIPHEROPTION(CALG_HMAC);\n#endif\n#if !defined(__W32API_MAJOR_VERSION) ||                                 \\\n  !defined(__W32API_MINOR_VERSION) ||                                   \\\n  defined(__MINGW64_VERSION_MAJOR) ||                                   \\\n  (__W32API_MAJOR_VERSION > 5)     ||                                   \\\n  ((__W32API_MAJOR_VERSION == 5) && (__W32API_MINOR_VERSION > 0))\n  /* CALG_TLS1PRF has a syntax error in MinGW's w32api up to version 5.0,\n     see https://osdn.net/projects/mingw/ticket/38391 */\n  CIPHEROPTION(CALG_TLS1PRF);\n#endif\n#ifdef CALG_HASH_REPLACE_OWF\n  CIPHEROPTION(CALG_HASH_REPLACE_OWF);\n#endif\n#ifdef CALG_AES_128\n  CIPHEROPTION(CALG_AES_128);\n#endif\n#ifdef CALG_AES_192\n  CIPHEROPTION(CALG_AES_192);\n#endif\n#ifdef CALG_AES_256\n  CIPHEROPTION(CALG_AES_256);\n#endif\n#ifdef CALG_AES\n  CIPHEROPTION(CALG_AES);\n#endif\n#ifdef CALG_SHA_256\n  CIPHEROPTION(CALG_SHA_256);\n#endif\n#ifdef CALG_SHA_384\n  CIPHEROPTION(CALG_SHA_384);\n#endif\n#ifdef CALG_SHA_512\n  CIPHEROPTION(CALG_SHA_512);\n#endif\n#ifdef CALG_ECDH\n  CIPHEROPTION(CALG_ECDH);\n#endif\n#ifdef CALG_ECMQV\n  CIPHEROPTION(CALG_ECMQV);\n#endif\n#ifdef CALG_ECDSA\n  CIPHEROPTION(CALG_ECDSA);\n#endif\n#ifdef CALG_ECDH_EPHEM\n  CIPHEROPTION(CALG_ECDH_EPHEM);\n#endif\n  return 0;\n}\n\nstatic CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}\n\n#ifdef HAS_CLIENT_CERT_PATH\n\n/* Function allocates memory for store_path only if CURLE_OK is returned */\nstatic CURLcode\nget_cert_location(TCHAR *path, DWORD *store_name, TCHAR **store_path,\n                  TCHAR **thumbprint)\n{\n  TCHAR *sep;\n  TCHAR *store_path_start;\n  size_t store_name_len;\n\n  sep = _tcschr(path, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_name_len = sep - path;\n\n  if(_tcsnccmp(path, TEXT(\"CurrentUser\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachine\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE;\n  else if(_tcsnccmp(path, TEXT(\"CurrentService\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_SERVICE;\n  else if(_tcsnccmp(path, TEXT(\"Services\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_SERVICES;\n  else if(_tcsnccmp(path, TEXT(\"Users\"), store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_USERS;\n  else if(_tcsnccmp(path, TEXT(\"CurrentUserGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineGroupPolicy\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;\n  else if(_tcsnccmp(path, TEXT(\"LocalMachineEnterprise\"),\n                    store_name_len) == 0)\n    *store_name = CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;\n  else\n    return CURLE_SSL_CERTPROBLEM;\n\n  store_path_start = sep + 1;\n\n  sep = _tcschr(store_path_start, TEXT('\\\\'));\n  if(!sep)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *thumbprint = sep + 1;\n  if(_tcslen(*thumbprint) != CERT_THUMBPRINT_STR_LEN)\n    return CURLE_SSL_CERTPROBLEM;\n\n  *sep = TEXT('\\0');\n  *store_path = _tcsdup(store_path_start);\n  *sep = TEXT('\\\\');\n  if(!*store_path)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}\n#endif\n\nstatic CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  int i;\n  ssize_t nread = -1, written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  SecBuffer outbuf[3];\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf[2];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n  bool doread;\n  char * const hostname = SSL_HOST_NAME();\n  const char *pubkey_ptr;\n\n  doread = (connssl->connecting_state != ssl_connect_2_writing) ? TRUE : FALSE;\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 2/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred || !BACKEND->ctxt)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* buffer to store previously received and decrypted data */\n  if(!BACKEND->decdata_buffer) {\n    BACKEND->decdata_offset = 0;\n    BACKEND->decdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->decdata_buffer = malloc(BACKEND->decdata_length);\n    if(!BACKEND->decdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* buffer to store previously received and encrypted data */\n  if(!BACKEND->encdata_buffer) {\n    BACKEND->encdata_is_incomplete = false;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_length = CURL_SCHANNEL_BUFFER_INIT_SIZE;\n    BACKEND->encdata_buffer = malloc(BACKEND->encdata_length);\n    if(!BACKEND->encdata_buffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* if we need a bigger buffer to read a full message, increase buffer now */\n  if(BACKEND->encdata_length - BACKEND->encdata_offset <\n     CURL_SCHANNEL_BUFFER_FREE_SIZE) {\n    /* increase internal encrypted data buffer */\n    size_t reallocated_length = BACKEND->encdata_offset +\n      CURL_SCHANNEL_BUFFER_FREE_SIZE;\n    reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                 reallocated_length);\n\n    if(!reallocated_buffer) {\n      failf(data, \"schannel: unable to re-allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n    }\n  }\n\n  for(;;) {\n    TCHAR *host_name;\n    if(doread) {\n      /* read encrypted handshake data from socket */\n      result = Curl_read_plain(conn->sock[sockindex],\n                               (char *) (BACKEND->encdata_buffer +\n                                         BACKEND->encdata_offset),\n                               BACKEND->encdata_length -\n                               BACKEND->encdata_offset,\n                               &nread);\n      if(result == CURLE_AGAIN) {\n        if(connssl->connecting_state != ssl_connect_2_writing)\n          connssl->connecting_state = ssl_connect_2_reading;\n        DEBUGF(infof(data, \"schannel: failed to receive handshake, \"\n                     \"need more data\\n\"));\n        return CURLE_OK;\n      }\n      else if((result != CURLE_OK) || (nread == 0)) {\n        failf(data, \"schannel: failed to receive handshake, \"\n              \"SSL/TLS connection failed\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      /* increase encrypted data buffer offset */\n      BACKEND->encdata_offset += nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* setup input buffers */\n    InitSecBuffer(&inbuf[0], SECBUFFER_TOKEN, malloc(BACKEND->encdata_offset),\n                  curlx_uztoul(BACKEND->encdata_offset));\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 2);\n\n    /* setup output buffers */\n    InitSecBuffer(&outbuf[0], SECBUFFER_TOKEN, NULL, 0);\n    InitSecBuffer(&outbuf[1], SECBUFFER_ALERT, NULL, 0);\n    InitSecBuffer(&outbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, outbuf, 3);\n\n    if(!inbuf[0].pvBuffer) {\n      failf(data, \"schannel: unable to allocate memory\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    /* copy received handshake data into input buffer */\n    memcpy(inbuf[0].pvBuffer, BACKEND->encdata_buffer,\n           BACKEND->encdata_offset);\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n     */\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle, &BACKEND->ctxt->ctxt_handle,\n      host_name, BACKEND->req_flags, 0, 0, &inbuf_desc, 0, NULL,\n      &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    /* free buffer for received handshake data */\n    Curl_safefree(inbuf[0].pvBuffer);\n\n    /* check if the handshake was incomplete */\n    if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      connssl->connecting_state = ssl_connect_2_reading;\n      DEBUGF(infof(data,\n                   \"schannel: received incomplete message, need more data\\n\"));\n      return CURLE_OK;\n    }\n\n    /* If the server has requested a client certificate, attempt to continue\n       the handshake without one. This will allow connections to servers which\n       request a client certificate but do not require it. */\n    if(sspi_status == SEC_I_INCOMPLETE_CREDENTIALS &&\n       !(BACKEND->req_flags & ISC_REQ_USE_SUPPLIED_CREDS)) {\n      BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n      connssl->connecting_state = ssl_connect_2_writing;\n      DEBUGF(infof(data,\n                   \"schannel: a client certificate has been requested\\n\"));\n      return CURLE_OK;\n    }\n\n    /* check if the handshake needs to be continued */\n    if(sspi_status == SEC_I_CONTINUE_NEEDED || sspi_status == SEC_E_OK) {\n      for(i = 0; i < 3; i++) {\n        /* search for handshake tokens that need to be send */\n        if(outbuf[i].BufferType == SECBUFFER_TOKEN && outbuf[i].cbBuffer > 0) {\n          DEBUGF(infof(data, \"schannel: sending next handshake data: \"\n                       \"sending %lu bytes...\\n\", outbuf[i].cbBuffer));\n\n          /* send handshake token to server */\n          result = Curl_write_plain(data, conn->sock[sockindex],\n                                    outbuf[i].pvBuffer, outbuf[i].cbBuffer,\n                                    &written);\n          if((result != CURLE_OK) ||\n             (outbuf[i].cbBuffer != (size_t) written)) {\n            failf(data, \"schannel: failed to send next handshake data: \"\n                  \"sent %zd of %lu bytes\", written, outbuf[i].cbBuffer);\n            return CURLE_SSL_CONNECT_ERROR;\n          }\n        }\n\n        /* free obsolete buffer */\n        if(outbuf[i].pvBuffer != NULL) {\n          s_pSecFn->FreeContextBuffer(outbuf[i].pvBuffer);\n        }\n      }\n    }\n    else {\n      char buffer[STRERROR_LEN];\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_WRONG_PRINCIPAL:\n        failf(data, \"schannel: SNI or certificate check failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case SEC_E_UNTRUSTED_ROOT:\n        failf(data, \"schannel: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_PEER_FAILED_VERIFICATION;\n        /*\n          case SEC_E_INVALID_HANDLE:\n          case SEC_E_INVALID_TOKEN:\n          case SEC_E_LOGON_DENIED:\n          case SEC_E_TARGET_UNKNOWN:\n          case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n          case SEC_E_INTERNAL_ERROR:\n          case SEC_E_NO_CREDENTIALS:\n          case SEC_E_UNSUPPORTED_FUNCTION:\n          case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n        */\n      default:\n        failf(data, \"schannel: next InitializeSecurityContext failed: %s\",\n              Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n\n    /* check if there was additional remaining encrypted data */\n    if(inbuf[1].BufferType == SECBUFFER_EXTRA && inbuf[1].cbBuffer > 0) {\n      DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                   inbuf[1].cbBuffer));\n      /*\n        There are two cases where we could be getting extra data here:\n        1) If we're renegotiating a connection and the handshake is already\n        complete (from the server perspective), it can encrypted app data\n        (not handshake data) in an extra buffer at this point.\n        2) (sspi_status == SEC_I_CONTINUE_NEEDED) We are negotiating a\n        connection and this extra data is part of the handshake.\n        We should process the data immediately; waiting for the socket to\n        be ready may fail since the server is done sending handshake data.\n      */\n      /* check if the remaining data is less than the total amount\n         and therefore begins after the already processed data */\n      if(BACKEND->encdata_offset > inbuf[1].cbBuffer) {\n        memmove(BACKEND->encdata_buffer,\n                (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                inbuf[1].cbBuffer, inbuf[1].cbBuffer);\n        BACKEND->encdata_offset = inbuf[1].cbBuffer;\n        if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n          doread = FALSE;\n          continue;\n        }\n      }\n    }\n    else {\n      BACKEND->encdata_offset = 0;\n    }\n    break;\n  }\n\n  /* check if the handshake needs to be continued */\n  if(sspi_status == SEC_I_CONTINUE_NEEDED) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n\n  /* check if the handshake is complete */\n  if(sspi_status == SEC_E_OK) {\n    connssl->connecting_state = ssl_connect_3;\n    DEBUGF(infof(data, \"schannel: SSL/TLS handshake complete\\n\"));\n  }\n\n  pubkey_ptr = SSL_PINNED_PUB_KEY();\n  if(pubkey_ptr) {\n    result = pkp_pin_peer_pubkey(data, conn, sockindex, pubkey_ptr);\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n  }\n\n#ifdef HAS_MANUAL_VERIFY_API\n  if(conn->ssl_config.verifypeer && BACKEND->use_manual_cred_validation) {\n    return Curl_verify_certificate(data, conn, sockindex);\n  }\n#endif\n\n  return CURLE_OK;\n}\n\nstatic bool\nvalid_cert_encoding(const CERT_CONTEXT *cert_context)\n{\n  return (cert_context != NULL) &&\n    ((cert_context->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n    (cert_context->pbCertEncoded != NULL) &&\n    (cert_context->cbCertEncoded > 0);\n}\n\ntypedef bool(*Read_crt_func)(const CERT_CONTEXT *ccert_context, void *arg);\n\nstatic void\ntraverse_cert_store(const CERT_CONTEXT *context, Read_crt_func func,\n                    void *arg)\n{\n  const CERT_CONTEXT *current_context = NULL;\n  bool should_continue = true;\n  while(should_continue &&\n        (current_context = CertEnumCertificatesInStore(\n          context->hCertStore,\n          current_context)) != NULL)\n    should_continue = func(current_context, arg);\n\n  if(current_context)\n    CertFreeCertificateContext(current_context);\n}\n\nstatic bool\ncert_counter_callback(const CERT_CONTEXT *ccert_context, void *certs_count)\n{\n  if(valid_cert_encoding(ccert_context))\n    (*(int *)certs_count)++;\n  return true;\n}\n\nstruct Adder_args\n{\n  struct Curl_easy *data;\n  CURLcode result;\n  int idx;\n  int certs_count;\n};\n\nstatic bool\nadd_cert_to_certinfo(const CERT_CONTEXT *ccert_context, void *raw_arg)\n{\n  struct Adder_args *args = (struct Adder_args*)raw_arg;\n  args->result = CURLE_OK;\n  if(valid_cert_encoding(ccert_context)) {\n    const char *beg = (const char *) ccert_context->pbCertEncoded;\n    const char *end = beg + ccert_context->cbCertEncoded;\n    int insert_index = (args->certs_count - 1) - args->idx;\n    args->result = Curl_extract_certinfo(args->data, insert_index,\n                                         beg, end);\n    args->idx++;\n  }\n  return args->result == CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CERT_CONTEXT *ccert_context = NULL;\n  bool isproxy = SSL_IS_PROXY();\n#ifdef DEBUGBUILD\n  const char * const hostname = SSL_HOST_NAME();\n#endif\n#ifdef HAS_ALPN\n  SecPkgContext_ApplicationProtocol alpn_result;\n#endif\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 3/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(!BACKEND->cred)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* check if the required context attributes are met */\n  if(BACKEND->ret_flags != BACKEND->req_flags) {\n    if(!(BACKEND->ret_flags & ISC_RET_SEQUENCE_DETECT))\n      failf(data, \"schannel: failed to setup sequence detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_REPLAY_DETECT))\n      failf(data, \"schannel: failed to setup replay detection\");\n    if(!(BACKEND->ret_flags & ISC_RET_CONFIDENTIALITY))\n      failf(data, \"schannel: failed to setup confidentiality\");\n    if(!(BACKEND->ret_flags & ISC_RET_ALLOCATED_MEMORY))\n      failf(data, \"schannel: failed to setup memory allocation\");\n    if(!(BACKEND->ret_flags & ISC_RET_STREAM))\n      failf(data, \"schannel: failed to setup stream orientation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_APPLICATION_PROTOCOL,\n                                       &alpn_result);\n\n    if(sspi_status != SEC_E_OK) {\n      failf(data, \"schannel: failed to retrieve ALPN result\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(alpn_result.ProtoNegoStatus ==\n       SecApplicationProtocolNegotiationStatus_Success) {\n\n      infof(data, \"schannel: ALPN, server accepted to use %.*s\\n\",\n            alpn_result.ProtocolIdSize, alpn_result.ProtocolId);\n\n#ifdef USE_HTTP2\n      if(alpn_result.ProtocolIdSize == ALPN_H2_LENGTH &&\n         !memcmp(ALPN_H2, alpn_result.ProtocolId, ALPN_H2_LENGTH)) {\n        conn->negnpn = CURL_HTTP_VERSION_2;\n      }\n      else\n#endif\n        if(alpn_result.ProtocolIdSize == ALPN_HTTP_1_1_LENGTH &&\n           !memcmp(ALPN_HTTP_1_1, alpn_result.ProtocolId,\n                   ALPN_HTTP_1_1_LENGTH)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n    }\n    else\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                        BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n  }\n#endif\n\n  /* save the current session data for possible re-use */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    struct Curl_schannel_cred *old_cred = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy, (void **)&old_cred,\n                                      NULL, sockindex));\n    if(incache) {\n      if(old_cred != BACKEND->cred) {\n        DEBUGF(infof(data,\n                     \"schannel: old credential handle is stale, removing\\n\"));\n        /* we're not taking old_cred ownership here, no refcount++ is needed */\n        Curl_ssl_delsessionid(data, (void *)old_cred);\n        incache = FALSE;\n      }\n    }\n    if(!incache) {\n      result = Curl_ssl_addsessionid(data, conn, isproxy, BACKEND->cred,\n                                     sizeof(struct Curl_schannel_cred),\n                                     sockindex);\n      if(result) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"schannel: failed to store credential handle\");\n        return result;\n      }\n      else {\n        /* this cred session is now also referenced by sessionid cache */\n        BACKEND->cred->refcount++;\n        DEBUGF(infof(data,\n                     \"schannel: stored credential handle in session cache\\n\"));\n      }\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(data->set.ssl.certinfo) {\n    int certs_count = 0;\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &ccert_context);\n\n    if((sspi_status != SEC_E_OK) || !ccert_context) {\n      failf(data, \"schannel: failed to retrieve remote cert context\");\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n\n    traverse_cert_store(ccert_context, cert_counter_callback, &certs_count);\n\n    result = Curl_ssl_init_certinfo(data, certs_count);\n    if(!result) {\n      struct Adder_args args;\n      args.data = data;\n      args.idx = 0;\n      args.certs_count = certs_count;\n      traverse_cert_store(ccert_context, add_cert_to_certinfo, &args);\n      result = args.result;\n    }\n    CertFreeCertificateContext(ccert_context);\n    if(result)\n      return result;\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nschannel_connect_common(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex, bool nonblocking, bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = schannel_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL/TLS connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state ? sockfd : CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL/TLS socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL/TLS connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = schannel_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = schannel_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = schannel_recv;\n    conn->send[sockindex] = schannel_send;\n\n#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS\n    /* When SSPI is used in combination with Schannel\n     * we need the Schannel context to create the Schannel\n     * binding to pass the IIS extended protection checks.\n     * Available on Windows 7 or later.\n     */\n    conn->sslContext = &BACKEND->ctxt->ctxt_handle;\n#endif\n\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* reset our connection state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t\nschannel_send(struct Curl_easy *data, int sockindex,\n              const void *buf, size_t len, CURLcode *err)\n{\n  ssize_t written = -1;\n  size_t data_len = 0;\n  unsigned char *ptr = NULL;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf[4];\n  SecBufferDesc outbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  CURLcode result;\n\n  /* check if the maximum stream sizes were queried */\n  if(BACKEND->stream_sizes.cbMaximumMessage == 0) {\n    sspi_status = s_pSecFn->QueryContextAttributes(\n      &BACKEND->ctxt->ctxt_handle,\n      SECPKG_ATTR_STREAM_SIZES,\n      &BACKEND->stream_sizes);\n    if(sspi_status != SEC_E_OK) {\n      *err = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n\n  /* check if the buffer is longer than the maximum message length */\n  if(len > BACKEND->stream_sizes.cbMaximumMessage) {\n    len = BACKEND->stream_sizes.cbMaximumMessage;\n  }\n\n  /* calculate the complete message length and allocate a buffer for it */\n  data_len = BACKEND->stream_sizes.cbHeader + len +\n    BACKEND->stream_sizes.cbTrailer;\n  ptr = (unsigned char *) malloc(data_len);\n  if(!ptr) {\n    *err = CURLE_OUT_OF_MEMORY;\n    return -1;\n  }\n\n  /* setup output buffers (header, data, trailer, empty) */\n  InitSecBuffer(&outbuf[0], SECBUFFER_STREAM_HEADER,\n                ptr, BACKEND->stream_sizes.cbHeader);\n  InitSecBuffer(&outbuf[1], SECBUFFER_DATA,\n                ptr + BACKEND->stream_sizes.cbHeader, curlx_uztoul(len));\n  InitSecBuffer(&outbuf[2], SECBUFFER_STREAM_TRAILER,\n                ptr + BACKEND->stream_sizes.cbHeader + len,\n                BACKEND->stream_sizes.cbTrailer);\n  InitSecBuffer(&outbuf[3], SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, outbuf, 4);\n\n  /* copy data into output buffer */\n  memcpy(outbuf[1].pvBuffer, buf, len);\n\n  /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375390.aspx */\n  sspi_status = s_pSecFn->EncryptMessage(&BACKEND->ctxt->ctxt_handle, 0,\n                                         &outbuf_desc, 0);\n\n  /* check if the message was encrypted */\n  if(sspi_status == SEC_E_OK) {\n    written = 0;\n\n    /* send the encrypted message including header, data and trailer */\n    len = outbuf[0].cbBuffer + outbuf[1].cbBuffer + outbuf[2].cbBuffer;\n\n    /*\n      It's important to send the full message which includes the header,\n      encrypted payload, and trailer.  Until the client receives all the\n      data a coherent message has not been delivered and the client\n      can't read any of it.\n\n      If we wanted to buffer the unwritten encrypted bytes, we would\n      tell the client that all data it has requested to be sent has been\n      sent. The unwritten encrypted bytes would be the first bytes to\n      send on the next invocation.\n      Here's the catch with this - if we tell the client that all the\n      bytes have been sent, will the client call this method again to\n      send the buffered data?  Looking at who calls this function, it\n      seems the answer is NO.\n    */\n\n    /* send entire message or fail */\n    while(len > (size_t)written) {\n      ssize_t this_write = 0;\n      int what;\n      timediff_t timeout_ms = Curl_timeleft(data, NULL, FALSE);\n      if(timeout_ms < 0) {\n        /* we already got the timeout */\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      else if(!timeout_ms)\n        timeout_ms = TIMEDIFF_T_MAX;\n      what = SOCKET_WRITABLE(conn->sock[sockindex], timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        *err = CURLE_SEND_ERROR;\n        written = -1;\n        break;\n      }\n      else if(0 == what) {\n        failf(data, \"schannel: timed out sending data \"\n              \"(bytes sent: %zd)\", written);\n        *err = CURLE_OPERATION_TIMEDOUT;\n        written = -1;\n        break;\n      }\n      /* socket is writable */\n\n      result = Curl_write_plain(data, conn->sock[sockindex], ptr + written,\n                                len - written, &this_write);\n      if(result == CURLE_AGAIN)\n        continue;\n      else if(result != CURLE_OK) {\n        *err = result;\n        written = -1;\n        break;\n      }\n\n      written += this_write;\n    }\n  }\n  else if(sspi_status == SEC_E_INSUFFICIENT_MEMORY) {\n    *err = CURLE_OUT_OF_MEMORY;\n  }\n  else{\n    *err = CURLE_SEND_ERROR;\n  }\n\n  Curl_safefree(ptr);\n\n  if(len == (size_t)written)\n    /* Encrypted message including header, data and trailer entirely sent.\n       The return value is the number of unencrypted bytes that were sent. */\n    written = outbuf[1].cbBuffer;\n\n  return written;\n}\n\nstatic ssize_t\nschannel_recv(struct Curl_easy *data, int sockindex,\n              char *buf, size_t len, CURLcode *err)\n{\n  size_t size = 0;\n  ssize_t nread = -1;\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  unsigned char *reallocated_buffer;\n  size_t reallocated_length;\n  bool done = FALSE;\n  SecBuffer inbuf[4];\n  SecBufferDesc inbuf_desc;\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  /* we want the length of the encrypted buffer to be at least large enough\n     that it can hold all the bytes requested and some TLS record overhead. */\n  size_t min_encdata_length = len + CURL_SCHANNEL_BUFFER_FREE_SIZE;\n\n  /****************************************************************************\n   * Don't return or set BACKEND->recv_unrecoverable_err unless in the cleanup.\n   * The pattern for return error is set *err, optional infof, goto cleanup.\n   *\n   * Our priority is to always return as much decrypted data to the caller as\n   * possible, even if an error occurs. The state of the decrypted buffer must\n   * always be valid. Transfer of decrypted data to the caller's buffer is\n   * handled in the cleanup.\n   */\n\n  DEBUGF(infof(data, \"schannel: client wants to read %zu bytes\\n\", len));\n  *err = CURLE_OK;\n\n  if(len && len <= BACKEND->decdata_offset) {\n    infof(data, \"schannel: enough decrypted data is already available\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_unrecoverable_err) {\n    *err = BACKEND->recv_unrecoverable_err;\n    infof(data, \"schannel: an unrecoverable error occurred in a prior call\\n\");\n    goto cleanup;\n  }\n  else if(BACKEND->recv_sspi_close_notify) {\n    /* once a server has indicated shutdown there is no more encrypted data */\n    infof(data, \"schannel: server indicated shutdown in a prior call\\n\");\n    goto cleanup;\n  }\n\n  /* It's debatable what to return when !len. Regardless we can't return\n     immediately because there may be data to decrypt (in the case we want to\n     decrypt all encrypted cached data) so handle !len later in cleanup.\n  */\n  else if(len && !BACKEND->recv_connection_closed) {\n    /* increase enc buffer in order to fit the requested amount of data */\n    size = BACKEND->encdata_length - BACKEND->encdata_offset;\n    if(size < CURL_SCHANNEL_BUFFER_FREE_SIZE ||\n       BACKEND->encdata_length < min_encdata_length) {\n      reallocated_length = BACKEND->encdata_offset +\n        CURL_SCHANNEL_BUFFER_FREE_SIZE;\n      if(reallocated_length < min_encdata_length) {\n        reallocated_length = min_encdata_length;\n      }\n      reallocated_buffer = realloc(BACKEND->encdata_buffer,\n                                   reallocated_length);\n      if(!reallocated_buffer) {\n        *err = CURLE_OUT_OF_MEMORY;\n        failf(data, \"schannel: unable to re-allocate memory\");\n        goto cleanup;\n      }\n\n      BACKEND->encdata_buffer = reallocated_buffer;\n      BACKEND->encdata_length = reallocated_length;\n      size = BACKEND->encdata_length - BACKEND->encdata_offset;\n      DEBUGF(infof(data, \"schannel: encdata_buffer resized %zu\\n\",\n                   BACKEND->encdata_length));\n    }\n\n    DEBUGF(infof(data,\n                 \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->encdata_offset, BACKEND->encdata_length));\n\n    /* read encrypted data from socket */\n    *err = Curl_read_plain(conn->sock[sockindex],\n                           (char *)(BACKEND->encdata_buffer +\n                                    BACKEND->encdata_offset),\n                           size, &nread);\n    if(*err) {\n      nread = -1;\n      if(*err == CURLE_AGAIN)\n        DEBUGF(infof(data,\n                     \"schannel: Curl_read_plain returned CURLE_AGAIN\\n\"));\n      else if(*err == CURLE_RECV_ERROR)\n        infof(data, \"schannel: Curl_read_plain returned CURLE_RECV_ERROR\\n\");\n      else\n        infof(data, \"schannel: Curl_read_plain returned error %d\\n\", *err);\n    }\n    else if(nread == 0) {\n      BACKEND->recv_connection_closed = true;\n      DEBUGF(infof(data, \"schannel: server closed the connection\\n\"));\n    }\n    else if(nread > 0) {\n      BACKEND->encdata_offset += (size_t)nread;\n      BACKEND->encdata_is_incomplete = false;\n      DEBUGF(infof(data, \"schannel: encrypted data got %zd\\n\", nread));\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  /* decrypt loop */\n  while(BACKEND->encdata_offset > 0 && sspi_status == SEC_E_OK &&\n        (!len || BACKEND->decdata_offset < len ||\n         BACKEND->recv_connection_closed)) {\n    /* prepare data buffer for DecryptMessage call */\n    InitSecBuffer(&inbuf[0], SECBUFFER_DATA, BACKEND->encdata_buffer,\n                  curlx_uztoul(BACKEND->encdata_offset));\n\n    /* we need 3 more empty input buffers for possible output */\n    InitSecBuffer(&inbuf[1], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[2], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBuffer(&inbuf[3], SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, inbuf, 4);\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa375348.aspx\n     */\n    sspi_status = s_pSecFn->DecryptMessage(&BACKEND->ctxt->ctxt_handle,\n                                           &inbuf_desc, 0, NULL);\n\n    /* check if everything went fine (server may want to renegotiate\n       or shutdown the connection context) */\n    if(sspi_status == SEC_E_OK || sspi_status == SEC_I_RENEGOTIATE ||\n       sspi_status == SEC_I_CONTEXT_EXPIRED) {\n      /* check for successfully decrypted data, even before actual\n         renegotiation or shutdown of the connection context */\n      if(inbuf[1].BufferType == SECBUFFER_DATA) {\n        DEBUGF(infof(data, \"schannel: decrypted data length: %lu\\n\",\n                     inbuf[1].cbBuffer));\n\n        /* increase buffer in order to fit the received amount of data */\n        size = inbuf[1].cbBuffer > CURL_SCHANNEL_BUFFER_FREE_SIZE ?\n          inbuf[1].cbBuffer : CURL_SCHANNEL_BUFFER_FREE_SIZE;\n        if(BACKEND->decdata_length - BACKEND->decdata_offset < size ||\n           BACKEND->decdata_length < len) {\n          /* increase internal decrypted data buffer */\n          reallocated_length = BACKEND->decdata_offset + size;\n          /* make sure that the requested amount of data fits */\n          if(reallocated_length < len) {\n            reallocated_length = len;\n          }\n          reallocated_buffer = realloc(BACKEND->decdata_buffer,\n                                       reallocated_length);\n          if(!reallocated_buffer) {\n            *err = CURLE_OUT_OF_MEMORY;\n            failf(data, \"schannel: unable to re-allocate memory\");\n            goto cleanup;\n          }\n          BACKEND->decdata_buffer = reallocated_buffer;\n          BACKEND->decdata_length = reallocated_length;\n        }\n\n        /* copy decrypted data to internal buffer */\n        size = inbuf[1].cbBuffer;\n        if(size) {\n          memcpy(BACKEND->decdata_buffer + BACKEND->decdata_offset,\n                 inbuf[1].pvBuffer, size);\n          BACKEND->decdata_offset += size;\n        }\n\n        DEBUGF(infof(data, \"schannel: decrypted data added: %zu\\n\", size));\n        DEBUGF(infof(data,\n                     \"schannel: decrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->decdata_offset, BACKEND->decdata_length));\n      }\n\n      /* check for remaining encrypted data */\n      if(inbuf[3].BufferType == SECBUFFER_EXTRA && inbuf[3].cbBuffer > 0) {\n        DEBUGF(infof(data, \"schannel: encrypted data length: %lu\\n\",\n                     inbuf[3].cbBuffer));\n\n        /* check if the remaining data is less than the total amount\n         * and therefore begins after the already processed data\n         */\n        if(BACKEND->encdata_offset > inbuf[3].cbBuffer) {\n          /* move remaining encrypted data forward to the beginning of\n             buffer */\n          memmove(BACKEND->encdata_buffer,\n                  (BACKEND->encdata_buffer + BACKEND->encdata_offset) -\n                  inbuf[3].cbBuffer, inbuf[3].cbBuffer);\n          BACKEND->encdata_offset = inbuf[3].cbBuffer;\n        }\n\n        DEBUGF(infof(data,\n                     \"schannel: encrypted cached: offset %zu length %zu\\n\",\n                     BACKEND->encdata_offset, BACKEND->encdata_length));\n      }\n      else {\n        /* reset encrypted buffer offset, because there is no data remaining */\n        BACKEND->encdata_offset = 0;\n      }\n\n      /* check if server wants to renegotiate the connection context */\n      if(sspi_status == SEC_I_RENEGOTIATE) {\n        infof(data, \"schannel: remote party requests renegotiation\\n\");\n        if(*err && *err != CURLE_AGAIN) {\n          infof(data, \"schannel: can't renogotiate, an error is pending\\n\");\n          goto cleanup;\n        }\n        if(BACKEND->encdata_offset) {\n          *err = CURLE_RECV_ERROR;\n          infof(data, \"schannel: can't renogotiate, \"\n                \"encrypted data available\\n\");\n          goto cleanup;\n        }\n        /* begin renegotiation */\n        infof(data, \"schannel: renegotiating SSL/TLS connection\\n\");\n        connssl->state = ssl_connection_negotiating;\n        connssl->connecting_state = ssl_connect_2_writing;\n        *err = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n        if(*err) {\n          infof(data, \"schannel: renegotiation failed\\n\");\n          goto cleanup;\n        }\n        /* now retry receiving data */\n        sspi_status = SEC_E_OK;\n        infof(data, \"schannel: SSL/TLS connection renegotiated\\n\");\n        continue;\n      }\n      /* check if the server closed the connection */\n      else if(sspi_status == SEC_I_CONTEXT_EXPIRED) {\n        /* In Windows 2000 SEC_I_CONTEXT_EXPIRED (close_notify) is not\n           returned so we have to work around that in cleanup. */\n        BACKEND->recv_sspi_close_notify = true;\n        if(!BACKEND->recv_connection_closed) {\n          BACKEND->recv_connection_closed = true;\n          infof(data, \"schannel: server closed the connection\\n\");\n        }\n        goto cleanup;\n      }\n    }\n    else if(sspi_status == SEC_E_INCOMPLETE_MESSAGE) {\n      BACKEND->encdata_is_incomplete = true;\n      if(!*err)\n        *err = CURLE_AGAIN;\n      infof(data, \"schannel: failed to decrypt data, need more data\\n\");\n      goto cleanup;\n    }\n    else {\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      char buffer[STRERROR_LEN];\n#endif\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: failed to read data from server: %s\\n\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      goto cleanup;\n    }\n  }\n\n  DEBUGF(infof(data,\n               \"schannel: encrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->encdata_offset, BACKEND->encdata_length));\n\n  DEBUGF(infof(data,\n               \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n               BACKEND->decdata_offset, BACKEND->decdata_length));\n\n  cleanup:\n  /* Warning- there is no guarantee the encdata state is valid at this point */\n  DEBUGF(infof(data, \"schannel: schannel_recv cleanup\\n\"));\n\n  /* Error if the connection has closed without a close_notify.\n\n     The behavior here is a matter of debate. We don't want to be vulnerable\n     to a truncation attack however there's some browser precedent for\n     ignoring the close_notify for compatibility reasons.\n\n     Additionally, Windows 2000 (v5.0) is a special case since it seems it\n     doesn't return close_notify. In that case if the connection was closed we\n     assume it was graceful (close_notify) since there doesn't seem to be a\n     way to tell.\n  */\n  if(len && !BACKEND->decdata_offset && BACKEND->recv_connection_closed &&\n     !BACKEND->recv_sspi_close_notify) {\n    bool isWin2k = curlx_verify_windows_version(5, 0, PLATFORM_WINNT,\n                                                VERSION_EQUAL);\n\n    if(isWin2k && sspi_status == SEC_E_OK)\n      BACKEND->recv_sspi_close_notify = true;\n    else {\n      *err = CURLE_RECV_ERROR;\n      infof(data, \"schannel: server closed abruptly (missing close_notify)\\n\");\n    }\n  }\n\n  /* Any error other than CURLE_AGAIN is an unrecoverable error. */\n  if(*err && *err != CURLE_AGAIN)\n    BACKEND->recv_unrecoverable_err = *err;\n\n  size = len < BACKEND->decdata_offset ? len : BACKEND->decdata_offset;\n  if(size) {\n    memcpy(buf, BACKEND->decdata_buffer, size);\n    memmove(BACKEND->decdata_buffer, BACKEND->decdata_buffer + size,\n            BACKEND->decdata_offset - size);\n    BACKEND->decdata_offset -= size;\n    DEBUGF(infof(data, \"schannel: decrypted data returned %zu\\n\", size));\n    DEBUGF(infof(data,\n                 \"schannel: decrypted data buffer: offset %zu length %zu\\n\",\n                 BACKEND->decdata_offset, BACKEND->decdata_length));\n    *err = CURLE_OK;\n    return (ssize_t)size;\n  }\n\n  if(!*err && !BACKEND->recv_connection_closed)\n    *err = CURLE_AGAIN;\n\n  /* It's debatable what to return when !len. We could return whatever error\n     we got from decryption but instead we override here so the return is\n     consistent.\n  */\n  if(!len)\n    *err = CURLE_OK;\n\n  return *err ? -1 : 0;\n}\n\nstatic CURLcode schannel_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  return schannel_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode schannel_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = schannel_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool schannel_data_pending(const struct connectdata *conn,\n                                  int sockindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  if(connssl->use) /* SSL/TLS is in use */\n    return (BACKEND->decdata_offset > 0 ||\n            (BACKEND->encdata_offset > 0 && !BACKEND->encdata_is_incomplete));\n  else\n    return FALSE;\n}\n\nstatic void schannel_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(conn->ssl[sockindex].use)\n    /* if the SSL/TLS channel hasn't been shut down yet, do that now. */\n    Curl_ssl_shutdown(data, conn, sockindex);\n}\n\nstatic void schannel_session_free(void *ptr)\n{\n  /* this is expected to be called under sessionid lock */\n  struct Curl_schannel_cred *cred = ptr;\n\n  cred->refcount--;\n  if(cred->refcount == 0) {\n    s_pSecFn->FreeCredentialsHandle(&cred->cred_handle);\n    Curl_safefree(cred);\n  }\n}\n\nstatic int schannel_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex)\n{\n  /* See https://msdn.microsoft.com/en-us/library/windows/desktop/aa380138.aspx\n   * Shutting Down an Schannel Connection\n   */\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(data);\n\n  infof(data, \"schannel: shutting down SSL/TLS connection with %s port %hu\\n\",\n        hostname, conn->remote_port);\n\n  if(BACKEND->cred && BACKEND->ctxt) {\n    SecBufferDesc BuffDesc;\n    SecBuffer Buffer;\n    SECURITY_STATUS sspi_status;\n    SecBuffer outbuf;\n    SecBufferDesc outbuf_desc;\n    CURLcode result;\n    TCHAR *host_name;\n    DWORD dwshut = SCHANNEL_SHUTDOWN;\n\n    InitSecBuffer(&Buffer, SECBUFFER_TOKEN, &dwshut, sizeof(dwshut));\n    InitSecBufferDesc(&BuffDesc, &Buffer, 1);\n\n    sspi_status = s_pSecFn->ApplyControlToken(&BACKEND->ctxt->ctxt_handle,\n                                              &BuffDesc);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: ApplyControlToken failure: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n    }\n\n    host_name = curlx_convert_UTF8_to_tchar(hostname);\n    if(!host_name)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* setup output buffer */\n    InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n    sspi_status = s_pSecFn->InitializeSecurityContext(\n      &BACKEND->cred->cred_handle,\n      &BACKEND->ctxt->ctxt_handle,\n      host_name,\n      BACKEND->req_flags,\n      0,\n      0,\n      NULL,\n      0,\n      &BACKEND->ctxt->ctxt_handle,\n      &outbuf_desc,\n      &BACKEND->ret_flags,\n      &BACKEND->ctxt->time_stamp);\n\n    curlx_unicodefree(host_name);\n\n    if((sspi_status == SEC_E_OK) || (sspi_status == SEC_I_CONTEXT_EXPIRED)) {\n      /* send close message which is in output buffer */\n      ssize_t written;\n      result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                                outbuf.cbBuffer, &written);\n\n      s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n      if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n        infof(data, \"schannel: failed to send close msg: %s\"\n              \" (bytes written: %zd)\\n\", curl_easy_strerror(result), written);\n      }\n    }\n  }\n\n  /* free SSPI Schannel API security context handle */\n  if(BACKEND->ctxt) {\n    DEBUGF(infof(data, \"schannel: clear security context handle\\n\"));\n    s_pSecFn->DeleteSecurityContext(&BACKEND->ctxt->ctxt_handle);\n    Curl_safefree(BACKEND->ctxt);\n  }\n\n  /* free SSPI Schannel API credential handle */\n  if(BACKEND->cred) {\n    Curl_ssl_sessionid_lock(data);\n    schannel_session_free(BACKEND->cred);\n    Curl_ssl_sessionid_unlock(data);\n    BACKEND->cred = NULL;\n  }\n\n  /* free internal buffer for received encrypted data */\n  if(BACKEND->encdata_buffer != NULL) {\n    Curl_safefree(BACKEND->encdata_buffer);\n    BACKEND->encdata_length = 0;\n    BACKEND->encdata_offset = 0;\n    BACKEND->encdata_is_incomplete = false;\n  }\n\n  /* free internal buffer for received decrypted data */\n  if(BACKEND->decdata_buffer != NULL) {\n    Curl_safefree(BACKEND->decdata_buffer);\n    BACKEND->decdata_length = 0;\n    BACKEND->decdata_offset = 0;\n  }\n\n  return CURLE_OK;\n}\n\nstatic int schannel_init(void)\n{\n  return (Curl_sspi_global_init() == CURLE_OK ? 1 : 0);\n}\n\nstatic void schannel_cleanup(void)\n{\n  Curl_sspi_global_cleanup();\n}\n\nstatic size_t schannel_version(char *buffer, size_t size)\n{\n  size = msnprintf(buffer, size, \"Schannel\");\n\n  return size;\n}\n\nstatic CURLcode schannel_random(struct Curl_easy *data UNUSED_PARAM,\n                                unsigned char *entropy, size_t length)\n{\n  HCRYPTPROV hCryptProv = 0;\n\n  (void)data;\n\n  if(!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return CURLE_FAILED_INIT;\n\n  if(!CryptGenRandom(hCryptProv, (DWORD)length, entropy)) {\n    CryptReleaseContext(hCryptProv, 0UL);\n    return CURLE_FAILED_INIT;\n  }\n\n  CryptReleaseContext(hCryptProv, 0UL);\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    struct connectdata *conn, int sockindex,\n                                    const char *pinnedpubkey)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  CERT_CONTEXT *pCertContextServer = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  do {\n    SECURITY_STATUS sspi_status;\n    const char *x509_der;\n    DWORD x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n\n    sspi_status =\n      s_pSecFn->QueryContextAttributes(&BACKEND->ctxt->ctxt_handle,\n                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,\n                                       &pCertContextServer);\n\n    if((sspi_status != SEC_E_OK) || !pCertContextServer) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: Failed to read remote certificate context: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      break; /* failed */\n    }\n\n\n    if(!(((pCertContextServer->dwCertEncodingType & X509_ASN_ENCODING) != 0) &&\n         (pCertContextServer->cbCertEncoded > 0)))\n      break;\n\n    x509_der = (const char *)pCertContextServer->pbCertEncoded;\n    x509_der_len = pCertContextServer->cbCertEncoded;\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      break;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      break;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n    }\n  } while(0);\n\n  if(pCertContextServer)\n    CertFreeCertificateContext(pCertContextServer);\n\n  return result;\n}\n\nstatic void schannel_checksum(const unsigned char *input,\n                              size_t inputlen,\n                              unsigned char *checksum,\n                              size_t checksumlen,\n                              DWORD provType,\n                              const unsigned int algId)\n{\n  HCRYPTPROV hProv = 0;\n  HCRYPTHASH hHash = 0;\n  DWORD cbHashSize = 0;\n  DWORD dwHashSizeLen = (DWORD)sizeof(cbHashSize);\n  DWORD dwChecksumLen = (DWORD)checksumlen;\n\n  /* since this can fail in multiple ways, zero memory first so we never\n   * return old data\n   */\n  memset(checksum, 0, checksumlen);\n\n  if(!CryptAcquireContext(&hProv, NULL, NULL, provType,\n                          CRYPT_VERIFYCONTEXT | CRYPT_SILENT))\n    return; /* failed */\n\n  do {\n    if(!CryptCreateHash(hProv, algId, 0, 0, &hHash))\n      break; /* failed */\n\n    /* workaround for original MinGW, should be (const BYTE*) */\n    if(!CryptHashData(hHash, (BYTE*)input, (DWORD)inputlen, 0))\n      break; /* failed */\n\n    /* get hash size */\n    if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&cbHashSize,\n                          &dwHashSizeLen, 0))\n      break; /* failed */\n\n    /* check hash size */\n    if(checksumlen < cbHashSize)\n      break; /* failed */\n\n    if(CryptGetHashParam(hHash, HP_HASHVAL, checksum, &dwChecksumLen, 0))\n      break; /* failed */\n  } while(0);\n\n  if(hHash)\n    CryptDestroyHash(hHash);\n\n  if(hProv)\n    CryptReleaseContext(hProv, 0);\n}\n\nstatic CURLcode schannel_sha256sum(const unsigned char *input,\n                                   size_t inputlen,\n                                   unsigned char *sha256sum,\n                                   size_t sha256len)\n{\n  schannel_checksum(input, inputlen, sha256sum, sha256len,\n                    PROV_RSA_AES, CALG_SHA_256);\n  return CURLE_OK;\n}\n\nstatic void *schannel_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info UNUSED_PARAM)\n{\n  (void)info;\n  return &BACKEND->ctxt->ctxt_handle;\n}\n\nconst struct Curl_ssl Curl_ssl_schannel = {\n  { CURLSSLBACKEND_SCHANNEL, \"schannel\" }, /* info */\n\n  SSLSUPP_CERTINFO |\n#ifdef HAS_MANUAL_VERIFY_API\n  SSLSUPP_CAINFO_BLOB |\n#endif\n  SSLSUPP_PINNEDPUBKEY,\n\n  sizeof(struct ssl_backend_data),\n\n  schannel_init,                     /* init */\n  schannel_cleanup,                  /* cleanup */\n  schannel_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  schannel_shutdown,                 /* shutdown */\n  schannel_data_pending,             /* data_pending */\n  schannel_random,                   /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  schannel_connect,                  /* connect */\n  schannel_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                  /* getsock */\n  schannel_get_internals,            /* get_internals */\n  schannel_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  schannel_session_free,             /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  schannel_sha256sum,                /* sha256sum */\n  NULL,                              /* associate_connection */\n  NULL                               /* disassociate_connection */\n};\n\n#endif /* USE_SCHANNEL */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 2012 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) 2012 - 2017, Nick Zitzmann, <nickzman@gmail.com>.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all iOS and macOS SecureTransport-specific code for the\n * TLS/SSL layer. No code but vtls.c should ever call or use these functions.\n */\n\n#include \"curl_setup.h\"\n\n#include \"urldata.h\" /* for the Curl_easy definition */\n#include \"curl_base64.h\"\n#include \"strtok.h\"\n#include \"multiif.h\"\n\n#ifdef USE_SECTRANSP\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wtautological-pointer-compare\"\n#endif /* __clang__ */\n\n#include <limits.h>\n\n#include <Security/Security.h>\n/* For some reason, when building for iOS, the omnibus header above does\n * not include SecureTransport.h as of iOS SDK 5.1. */\n#include <Security/SecureTransport.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include <CommonCrypto/CommonDigest.h>\n\n/* The Security framework has changed greatly between iOS and different macOS\n   versions, and we will try to support as many of them as we can (back to\n   Leopard and iOS 5) by using macros and weak-linking.\n\n   In general, you want to build this using the most recent OS SDK, since some\n   features require curl to be built against the latest SDK. TLS 1.1 and 1.2\n   support, for instance, require the macOS 10.8 SDK or later. TLS 1.3\n   requires the macOS 10.13 or iOS 11 SDK or later. */\n#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050\n#error \"The Secure Transport back-end requires Leopard or later.\"\n#endif /* MAC_OS_X_VERSION_MAX_ALLOWED < 1050 */\n\n#define CURL_BUILD_IOS 0\n#define CURL_BUILD_IOS_7 0\n#define CURL_BUILD_IOS_9 0\n#define CURL_BUILD_IOS_11 0\n#define CURL_BUILD_IOS_13 0\n#define CURL_BUILD_MAC 1\n/* This is the maximum API level we are allowed to use when building: */\n#define CURL_BUILD_MAC_10_5 MAC_OS_X_VERSION_MAX_ALLOWED >= 1050\n#define CURL_BUILD_MAC_10_6 MAC_OS_X_VERSION_MAX_ALLOWED >= 1060\n#define CURL_BUILD_MAC_10_7 MAC_OS_X_VERSION_MAX_ALLOWED >= 1070\n#define CURL_BUILD_MAC_10_8 MAC_OS_X_VERSION_MAX_ALLOWED >= 1080\n#define CURL_BUILD_MAC_10_9 MAC_OS_X_VERSION_MAX_ALLOWED >= 1090\n#define CURL_BUILD_MAC_10_11 MAC_OS_X_VERSION_MAX_ALLOWED >= 101100\n#define CURL_BUILD_MAC_10_13 MAC_OS_X_VERSION_MAX_ALLOWED >= 101300\n#define CURL_BUILD_MAC_10_15 MAC_OS_X_VERSION_MAX_ALLOWED >= 101500\n/* These macros mean \"the following code is present to allow runtime backward\n   compatibility with at least this cat or earlier\":\n   (You set this at build-time using the compiler command line option\n   \"-mmacosx-version-min.\") */\n#define CURL_SUPPORT_MAC_10_5 MAC_OS_X_VERSION_MIN_REQUIRED <= 1050\n#define CURL_SUPPORT_MAC_10_6 MAC_OS_X_VERSION_MIN_REQUIRED <= 1060\n#define CURL_SUPPORT_MAC_10_7 MAC_OS_X_VERSION_MIN_REQUIRED <= 1070\n#define CURL_SUPPORT_MAC_10_8 MAC_OS_X_VERSION_MIN_REQUIRED <= 1080\n#define CURL_SUPPORT_MAC_10_9 MAC_OS_X_VERSION_MIN_REQUIRED <= 1090\n\n#elif TARGET_OS_EMBEDDED || TARGET_OS_IPHONE\n#define CURL_BUILD_IOS 1\n#define CURL_BUILD_IOS_7 __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000\n#define CURL_BUILD_IOS_9 __IPHONE_OS_VERSION_MAX_ALLOWED >= 90000\n#define CURL_BUILD_IOS_11 __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000\n#define CURL_BUILD_IOS_13 __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000\n#define CURL_BUILD_MAC 0\n#define CURL_BUILD_MAC_10_5 0\n#define CURL_BUILD_MAC_10_6 0\n#define CURL_BUILD_MAC_10_7 0\n#define CURL_BUILD_MAC_10_8 0\n#define CURL_BUILD_MAC_10_9 0\n#define CURL_BUILD_MAC_10_11 0\n#define CURL_BUILD_MAC_10_13 0\n#define CURL_BUILD_MAC_10_15 0\n#define CURL_SUPPORT_MAC_10_5 0\n#define CURL_SUPPORT_MAC_10_6 0\n#define CURL_SUPPORT_MAC_10_7 0\n#define CURL_SUPPORT_MAC_10_8 0\n#define CURL_SUPPORT_MAC_10_9 0\n\n#else\n#error \"The Secure Transport back-end requires iOS or macOS.\"\n#endif /* (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) */\n\n#if CURL_BUILD_MAC\n#include <sys/sysctl.h>\n#endif /* CURL_BUILD_MAC */\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"connect.h\"\n#include \"select.h\"\n#include \"vtls.h\"\n#include \"sectransp.h\"\n#include \"curl_printf.h\"\n#include \"strdup.h\"\n\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n/* From MacTypes.h (which we can't include because it isn't present in iOS: */\n#define ioErr -36\n#define paramErr -50\n\nstruct ssl_backend_data {\n  SSLContextRef ssl_ctx;\n  curl_socket_t ssl_sockfd;\n  bool ssl_direction; /* true if writing, false if reading */\n  size_t ssl_write_buffered_length;\n};\n\nstruct st_cipher {\n  const char *name; /* Cipher suite IANA name. It starts with \"TLS_\" prefix */\n  const char *alias_name; /* Alias name is the same as OpenSSL cipher name */\n  SSLCipherSuite num; /* Cipher suite code/number defined in IANA registry */\n  bool weak; /* Flag to mark cipher as weak based on previous implementation\n                of Secure Transport back-end by CURL */\n};\n\n/* Macro to initialize st_cipher data structure: stringify id to name, cipher\n   number/id, 'weak' suite flag\n */\n#define CIPHER_DEF(num, alias, weak) \\\n  { #num, alias, num, weak }\n\n/*\n Macro to initialize st_cipher data structure with name, code (IANA cipher\n number/id value), and 'weak' suite flag. The first 28 cipher suite numbers\n have the same IANA code for both SSL and TLS standards: numbers 0x0000 to\n 0x001B. They have different names though. The first 4 letters of the cipher\n suite name are the protocol name: \"SSL_\" or \"TLS_\", rest of the IANA name is\n the same for both SSL and TLS cipher suite name.\n The second part of the problem is that macOS/iOS SDKs don't define all TLS\n codes but only 12 of them. The SDK defines all SSL codes though, i.e. SSL_NUM\n constant is always defined for those 28 ciphers while TLS_NUM is defined only\n for 12 of the first 28 ciphers. Those 12 TLS cipher codes match to\n corresponding SSL enum value and represent the same cipher suite. Therefore\n we'll use the SSL enum value for those cipher suites because it is defined\n for all 28 of them.\n We make internal data consistent and based on TLS names, i.e. all st_cipher\n item names start with the \"TLS_\" prefix.\n Summarizing all the above, those 28 first ciphers are presented in our table\n with both TLS and SSL names. Their cipher numbers are assigned based on the\n SDK enum value for the SSL cipher, which matches to IANA TLS number.\n */\n#define CIPHER_DEF_SSLTLS(num_wo_prefix, alias, weak) \\\n  { \"TLS_\" #num_wo_prefix, alias, SSL_##num_wo_prefix, weak }\n\n/*\n Cipher suites were marked as weak based on the following:\n RC4 encryption - rfc7465, the document contains a list of deprecated ciphers.\n     Marked in the code below as weak.\n RC2 encryption - many mentions, was found vulnerable to a relatively easy\n     attack https://link.springer.com/chapter/10.1007%2F3-540-69710-1_14\n     Marked in the code below as weak.\n DES and IDEA encryption - rfc5469, has a list of deprecated ciphers.\n     Marked in the code below as weak.\n Anonymous Diffie-Hellman authentication and anonymous elliptic curve\n     Diffie-Hellman - vulnerable to a man-in-the-middle attack. Deprecated by\n     RFC 4346 aka TLS 1.1 (section A.5, page 60)\n Null bulk encryption suites - not encrypted communication\n Export ciphers, i.e. ciphers with restrictions to be used outside the US for\n     software exported to some countries, they were excluded from TLS 1.1\n     version. More precisely, they were noted as ciphers which MUST NOT be\n     negotiated in RFC 4346 aka TLS 1.1 (section A.5, pages 60 and 61).\n     All of those filters were considered weak because they contain a weak\n     algorithm like DES, RC2 or RC4, and already considered weak by other\n     criteria.\n 3DES - NIST deprecated it and is going to retire it by 2023\n https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA\n     OpenSSL https://www.openssl.org/blog/blog/2016/08/24/sweet32/ also\n     deprecated those ciphers. Some other libraries also consider it\n     vulnerable or at least not strong enough.\n\n CBC ciphers are vulnerable with SSL3.0 and TLS1.0:\n https://www.cisco.com/c/en/us/support/docs/security/email-security-appliance\n /118518-technote-esa-00.html\n     We don't take care of this issue because it is resolved by later TLS\n     versions and for us, it requires more complicated checks, we need to\n     check a protocol version also. Vulnerability doesn't look very critical\n     and we do not filter out those cipher suites.\n */\n\n#define CIPHER_WEAK_NOT_ENCRYPTED   TRUE\n#define CIPHER_WEAK_RC_ENCRYPTION   TRUE\n#define CIPHER_WEAK_DES_ENCRYPTION  TRUE\n#define CIPHER_WEAK_IDEA_ENCRYPTION TRUE\n#define CIPHER_WEAK_ANON_AUTH       TRUE\n#define CIPHER_WEAK_3DES_ENCRYPTION TRUE\n#define CIPHER_STRONG_ENOUGH        FALSE\n\n/* Please do not change the order of the first ciphers available for SSL.\n   Do not insert and do not delete any of them. Code below\n   depends on their order and continuity.\n   If you add a new cipher, please maintain order by number, i.e.\n   insert in between existing items to appropriate place based on\n   cipher suite IANA number\n*/\nconst static struct st_cipher ciphertable[] = {\n  /* SSL version 3.0 and initial TLS 1.0 cipher suites.\n     Defined since SDK 10.2.8 */\n  CIPHER_DEF_SSLTLS(NULL_WITH_NULL_NULL,                           /* 0x0000 */\n                    NULL,\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_MD5,                             /* 0x0001 */\n                    \"NULL-MD5\",\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_WITH_NULL_SHA,                             /* 0x0002 */\n                    \"NULL-SHA\",\n                    CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC4_40_MD5,                    /* 0x0003 */\n                    \"EXP-RC4-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_MD5,                          /* 0x0004 */\n                    \"RC4-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_RC4_128_SHA,                          /* 0x0005 */\n                    \"RC4-SHA\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_RC2_CBC_40_MD5,                /* 0x0006 */\n                    \"EXP-RC2-CBC-MD5\",\n                    CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_IDEA_CBC_SHA,                         /* 0x0007 */\n                    \"IDEA-CBC-SHA\",\n                    CIPHER_WEAK_IDEA_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_EXPORT_WITH_DES40_CBC_SHA,                 /* 0x0008 */\n                    \"EXP-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_DES_CBC_SHA,                          /* 0x0009 */\n                    \"DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(RSA_WITH_3DES_EDE_CBC_SHA,                     /* 0x000A */\n                    \"DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000B */\n                    \"EXP-DH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_WITH_DES_CBC_SHA,                       /* 0x000C */\n                    \"DH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_DSS_WITH_3DES_EDE_CBC_SHA,                  /* 0x000D */\n                    \"DH-DSS-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_EXPORT_WITH_DES40_CBC_SHA,              /* 0x000E */\n                    \"EXP-DH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_WITH_DES_CBC_SHA,                       /* 0x000F */\n                    \"DH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0x0010 */\n                    \"DH-RSA-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0011 */\n                    \"EXP-EDH-DSS-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_DES_CBC_SHA,                      /* 0x0012 */\n                    \"EDH-DSS-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_DSS_WITH_3DES_EDE_CBC_SHA,                 /* 0x0013 */\n                    \"DHE-DSS-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0014 */\n                    \"EXP-EDH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_DES_CBC_SHA,                      /* 0x0015 */\n                    \"EDH-RSA-DES-CBC-SHA\",\n                    CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DHE_RSA_WITH_3DES_EDE_CBC_SHA,                 /* 0x0016 */\n                    \"DHE-RSA-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_RC4_40_MD5,                /* 0x0017 */\n                    \"EXP-ADH-RC4-MD5\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_RC4_128_MD5,                      /* 0x0018 */\n                    \"ADH-RC4-MD5\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_EXPORT_WITH_DES40_CBC_SHA,             /* 0x0019 */\n                    \"EXP-ADH-DES-CBC-SHA\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_DES_CBC_SHA,                      /* 0x001A */\n                    \"ADH-DES-CBC-SHA\",\n                    CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF_SSLTLS(DH_anon_WITH_3DES_EDE_CBC_SHA,                 /* 0x001B */\n                    \"ADH-DES-CBC3-SHA\",\n                    CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_NULL_SHA,                       /* 0x001C */\n             NULL,\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA,               /* 0x001D */\n             NULL,\n             CIPHER_STRONG_ENOUGH),\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* RFC 4785 - Pre-Shared Key (PSK) Ciphersuites with NULL Encryption */\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA,                                /* 0x002C */\n             \"PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA,                            /* 0x002D */\n             \"DHE-PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA,                            /* 0x002E */\n             \"RSA-PSK-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* TLS addenda using AES, per RFC 3268. Defined since SDK 10.4u */\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA,                         /* 0x002F */\n             \"AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA,                      /* 0x0030 */\n             \"DH-DSS-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA,                      /* 0x0031 */\n             \"DH-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA,                     /* 0x0032 */\n             \"DHE-DSS-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA,                     /* 0x0033 */\n             \"DHE-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA,                     /* 0x0034 */\n             \"ADH-AES128-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA,                         /* 0x0035 */\n             \"AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA,                      /* 0x0036 */\n             \"DH-DSS-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA,                      /* 0x0037 */\n             \"DH-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA,                     /* 0x0038 */\n             \"DHE-DSS-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA,                     /* 0x0039 */\n             \"DHE-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA,                     /* 0x003A */\n             \"ADH-AES256-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* TLS 1.2 addenda, RFC 5246 */\n  /* Server provided RSA certificate for key exchange. */\n  CIPHER_DEF(TLS_RSA_WITH_NULL_SHA256,                             /* 0x003B */\n             \"NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_CBC_SHA256,                      /* 0x003C */\n             \"AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_CBC_SHA256,                      /* 0x003D */\n             \"AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  /* Server-authenticated (and optionally client-authenticated)\n     Diffie-Hellman. */\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_CBC_SHA256,                   /* 0x003E */\n             \"DH-DSS-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_CBC_SHA256,                   /* 0x003F */\n             \"DH-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,                  /* 0x0040 */\n             \"DHE-DSS-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n\n  /* TLS 1.2 addenda, RFC 5246 */\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,                  /* 0x0067 */\n             \"DHE-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_CBC_SHA256,                   /* 0x0068 */\n             \"DH-DSS-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_CBC_SHA256,                   /* 0x0069 */\n             \"DH-RSA-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,                  /* 0x006A */\n             \"DHE-DSS-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,                  /* 0x006B */\n             \"DHE-RSA-AES256-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_CBC_SHA256,                  /* 0x006C */\n             \"ADH-AES128-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_CBC_SHA256,                  /* 0x006D */\n             \"ADH-AES256-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* Addendum from RFC 4279, TLS PSK */\n  CIPHER_DEF(TLS_PSK_WITH_RC4_128_SHA,                             /* 0x008A */\n             \"PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_PSK_WITH_3DES_EDE_CBC_SHA,                        /* 0x008B */\n             \"PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA,                         /* 0x008C */\n             \"PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA,                         /* 0x008D */\n             \"PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_RC4_128_SHA,                         /* 0x008E */\n             \"DHE-PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x008F */\n             \"DHE-PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0090 */\n             \"DHE-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0091 */\n             \"DHE-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_RC4_128_SHA,                         /* 0x0092 */\n             \"RSA-PSK-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,                    /* 0x0093 */\n             \"RSA-PSK-3DES-EDE-CBC-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA,                     /* 0x0094 */\n             \"RSA-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA,                     /* 0x0095 */\n             \"RSA-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* Addenda from rfc 5288 AES Galois Counter Mode (GCM) Cipher Suites\n     for TLS. */\n  CIPHER_DEF(TLS_RSA_WITH_AES_128_GCM_SHA256,                      /* 0x009C */\n             \"AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_WITH_AES_256_GCM_SHA384,                      /* 0x009D */\n             \"AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,                  /* 0x009E */\n             \"DHE-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,                  /* 0x009F */\n             \"DHE-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_128_GCM_SHA256,                   /* 0x00A0 */\n             \"DH-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_RSA_WITH_AES_256_GCM_SHA384,                   /* 0x00A1 */\n             \"DH-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,                  /* 0x00A2 */\n             \"DHE-DSS-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_DSS_WITH_AES_256_GCM_SHA384,                  /* 0x00A3 */\n             \"DHE-DSS-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_128_GCM_SHA256,                   /* 0x00A4 */\n             \"DH-DSS-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_DSS_WITH_AES_256_GCM_SHA384,                   /* 0x00A5 */\n             \"DH-DSS-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_128_GCM_SHA256,                  /* 0x00A6 */\n             \"ADH-AES128-GCM-SHA256\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_DH_anon_WITH_AES_256_GCM_SHA384,                  /* 0x00A7 */\n             \"ADH-AES256-GCM-SHA384\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* RFC 5487 - PSK with SHA-256/384 and AES GCM */\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_GCM_SHA256,                      /* 0x00A8 */\n             \"PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_GCM_SHA384,                      /* 0x00A9 */\n             \"PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AA */\n             \"DHE-PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AB */\n             \"DHE-PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,                  /* 0x00AC */\n             \"RSA-PSK-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,                  /* 0x00AD */\n             \"RSA-PSK-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_128_CBC_SHA256,                      /* 0x00AE */\n             \"PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_AES_256_CBC_SHA384,                      /* 0x00AF */\n             \"PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA256,                             /* 0x00B0 */\n             \"PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_PSK_WITH_NULL_SHA384,                             /* 0x00B1 */\n             \"PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B2 */\n             \"DHE-PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B3 */\n             \"DHE-PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA256,                         /* 0x00B4 */\n             \"DHE-PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_DHE_PSK_WITH_NULL_SHA384,                         /* 0x00B5 */\n             \"DHE-PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,                  /* 0x00B6 */\n             \"RSA-PSK-AES128-CBC-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,                  /* 0x00B7 */\n             \"RSA-PSK-AES256-CBC-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA256,                         /* 0x00B8 */\n             \"RSA-PSK-NULL-SHA256\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_RSA_PSK_WITH_NULL_SHA384,                         /* 0x00B9 */\n             \"RSA-PSK-NULL-SHA384\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* RFC 5746 - Secure Renegotiation. This is not a real suite,\n     it is a response to initiate negotiation again */\n  CIPHER_DEF(TLS_EMPTY_RENEGOTIATION_INFO_SCSV,                    /* 0x00FF */\n             NULL,\n             CIPHER_STRONG_ENOUGH),\n\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n  /* TLS 1.3 standard cipher suites for ChaCha20+Poly1305.\n     Note: TLS 1.3 ciphersuites do not specify the key exchange\n     algorithm -- they only specify the symmetric ciphers.\n     Cipher alias name matches to OpenSSL cipher name, and for\n     TLS 1.3 ciphers */\n  CIPHER_DEF(TLS_AES_128_GCM_SHA256,                               /* 0x1301 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_256_GCM_SHA384,                               /* 0x1302 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_CHACHA20_POLY1305_SHA256,                         /* 0x1303 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_128_CCM_SHA256,                               /* 0x1304 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_AES_128_CCM_8_SHA256,                             /* 0x1305 */\n             NULL,  /* The OpenSSL cipher name matches to the IANA name */\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n\n#if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS\n  /* ECDSA addenda, RFC 4492 */\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_NULL_SHA,                         /* 0xC001 */\n             \"ECDH-ECDSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_RC4_128_SHA,                      /* 0xC002 */\n             \"ECDH-ECDSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,                 /* 0xC003 */\n             \"ECDH-ECDSA-DES-CBC3-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,                  /* 0xC004 */\n             \"ECDH-ECDSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,                  /* 0xC005 */\n             \"ECDH-ECDSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_NULL_SHA,                        /* 0xC006 */\n             \"ECDHE-ECDSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,                     /* 0xC007 */\n             \"ECDHE-ECDSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,                /* 0xC008 */\n             \"ECDHE-ECDSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,                 /* 0xC009 */\n             \"ECDHE-ECDSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,                 /* 0xC00A */\n             \"ECDHE-ECDSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_NULL_SHA,                           /* 0xC00B */\n             \"ECDH-RSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_RC4_128_SHA,                        /* 0xC00C */\n             \"ECDH-RSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,                   /* 0xC00D */\n             \"ECDH-RSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,                    /* 0xC00E */\n             \"ECDH-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,                    /* 0xC00F */\n             \"ECDH-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_NULL_SHA,                          /* 0xC010 */\n             \"ECDHE-RSA-NULL-SHA\",\n             CIPHER_WEAK_NOT_ENCRYPTED),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_RC4_128_SHA,                       /* 0xC011 */\n             \"ECDHE-RSA-RC4-SHA\",\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,                  /* 0xC012 */\n             \"ECDHE-RSA-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,                   /* 0xC013 */\n             \"ECDHE-RSA-AES128-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,                   /* 0xC014 */\n             \"ECDHE-RSA-AES256-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_NULL_SHA,                          /* 0xC015 */\n             \"AECDH-NULL-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_RC4_128_SHA,                       /* 0xC016 */\n             \"AECDH-RC4-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,                  /* 0xC017 */\n             \"AECDH-DES-CBC3-SHA\",\n             CIPHER_WEAK_3DES_ENCRYPTION),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_128_CBC_SHA,                   /* 0xC018 */\n             \"AECDH-AES128-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n  CIPHER_DEF(TLS_ECDH_anon_WITH_AES_256_CBC_SHA,                   /* 0xC019 */\n             \"AECDH-AES256-SHA\",\n             CIPHER_WEAK_ANON_AUTH),\n#endif /* CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with\n     HMAC SHA-256/384. */\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,              /* 0xC023 */\n             \"ECDHE-ECDSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,              /* 0xC024 */\n             \"ECDHE-ECDSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,               /* 0xC025 */\n             \"ECDH-ECDSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,               /* 0xC026 */\n             \"ECDH-ECDSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,                /* 0xC027 */\n             \"ECDHE-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,                /* 0xC028 */\n             \"ECDHE-RSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,                 /* 0xC029 */\n             \"ECDH-RSA-AES128-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,                 /* 0xC02A */\n             \"ECDH-RSA-AES256-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  /* Addenda from rfc 5289  Elliptic Curve Cipher Suites with\n     SHA-256/384 and AES Galois Counter Mode (GCM) */\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,              /* 0xC02B */\n             \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,              /* 0xC02C */\n             \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,               /* 0xC02D */\n             \"ECDH-ECDSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,               /* 0xC02E */\n             \"ECDH-ECDSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,                /* 0xC02F */\n             \"ECDHE-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,                /* 0xC030 */\n             \"ECDHE-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,                 /* 0xC031 */\n             \"ECDH-RSA-AES128-GCM-SHA256\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,                 /* 0xC032 */\n             \"ECDH-RSA-AES256-GCM-SHA384\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13\n  /* ECDHE_PSK Cipher Suites for Transport Layer Security (TLS), RFC 5489 */\n  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,                   /* 0xC035 */\n             \"ECDHE-PSK-AES128-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,                   /* 0xC036 */\n             \"ECDHE-PSK-AES256-CBC-SHA\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */\n\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n  /* Addenda from rfc 7905  ChaCha20-Poly1305 Cipher Suites for\n     Transport Layer Security (TLS). */\n  CIPHER_DEF(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,          /* 0xCCA8 */\n             \"ECDHE-RSA-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n  CIPHER_DEF(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,        /* 0xCCA9 */\n             \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n\n#if CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13\n  /* ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS),\n     RFC 7905 */\n  CIPHER_DEF(TLS_PSK_WITH_CHACHA20_POLY1305_SHA256,                /* 0xCCAB */\n             \"PSK-CHACHA20-POLY1305\",\n             CIPHER_STRONG_ENOUGH),\n#endif /* CURL_BUILD_MAC_10_15 || CURL_BUILD_IOS_13 */\n\n  /* Tags for SSL 2 cipher kinds which are not specified for SSL 3.\n     Defined since SDK 10.2.8 */\n  CIPHER_DEF(SSL_RSA_WITH_RC2_CBC_MD5,                             /* 0xFF80 */\n             NULL,\n             CIPHER_WEAK_RC_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_IDEA_CBC_MD5,                            /* 0xFF81 */\n             NULL,\n             CIPHER_WEAK_IDEA_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_DES_CBC_MD5,                             /* 0xFF82 */\n             NULL,\n             CIPHER_WEAK_DES_ENCRYPTION),\n  CIPHER_DEF(SSL_RSA_WITH_3DES_EDE_CBC_MD5,                        /* 0xFF83 */\n             NULL,\n             CIPHER_WEAK_3DES_ENCRYPTION),\n};\n\n#define NUM_OF_CIPHERS sizeof(ciphertable)/sizeof(ciphertable[0])\n\n\n/* pinned public key support tests */\n\n/* version 1 supports macOS 10.12+ and iOS 10+ */\n#if ((TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MIN_REQUIRED >= 100000) || \\\n    (!TARGET_OS_IPHONE && __MAC_OS_X_VERSION_MIN_REQUIRED  >= 101200))\n#define SECTRANSP_PINNEDPUBKEY_V1 1\n#endif\n\n/* version 2 supports MacOSX 10.7+ */\n#if (!TARGET_OS_IPHONE && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)\n#define SECTRANSP_PINNEDPUBKEY_V2 1\n#endif\n\n#if defined(SECTRANSP_PINNEDPUBKEY_V1) || defined(SECTRANSP_PINNEDPUBKEY_V2)\n/* this backend supports CURLOPT_PINNEDPUBLICKEY */\n#define SECTRANSP_PINNEDPUBKEY 1\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n#ifdef SECTRANSP_PINNEDPUBKEY\n/* both new and old APIs return rsa keys missing the spki header (not DER) */\nstatic const unsigned char rsa4096SpkiHeader[] = {\n                                       0x30, 0x82, 0x02, 0x22, 0x30, 0x0d,\n                                       0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n                                       0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,\n                                       0x00, 0x03, 0x82, 0x02, 0x0f, 0x00};\n\nstatic const unsigned char rsa2048SpkiHeader[] = {\n                                       0x30, 0x82, 0x01, 0x22, 0x30, 0x0d,\n                                       0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,\n                                       0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,\n                                       0x00, 0x03, 0x82, 0x01, 0x0f, 0x00};\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n/* the *new* version doesn't return DER encoded ecdsa certs like the old... */\nstatic const unsigned char ecDsaSecp256r1SpkiHeader[] = {\n                                       0x30, 0x59, 0x30, 0x13, 0x06, 0x07,\n                                       0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,\n                                       0x01, 0x06, 0x08, 0x2a, 0x86, 0x48,\n                                       0xce, 0x3d, 0x03, 0x01, 0x07, 0x03,\n                                       0x42, 0x00};\n\nstatic const unsigned char ecDsaSecp384r1SpkiHeader[] = {\n                                       0x30, 0x76, 0x30, 0x10, 0x06, 0x07,\n                                       0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,\n                                       0x01, 0x06, 0x05, 0x2b, 0x81, 0x04,\n                                       0x00, 0x22, 0x03, 0x62, 0x00};\n#endif /* SECTRANSP_PINNEDPUBKEY_V1 */\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n/* The following two functions were ripped from Apple sample code,\n * with some modifications: */\nstatic OSStatus SocketRead(SSLConnectionRef connection,\n                           void *data,          /* owned by\n                                                 * caller, data\n                                                 * RETURNED */\n                           size_t *dataLength)  /* IN/OUT */\n{\n  size_t bytesToGo = *dataLength;\n  size_t initLen = bytesToGo;\n  UInt8 *currData = (UInt8 *)data;\n  /*int sock = *(int *)connection;*/\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)connection;\n  struct ssl_backend_data *backend = connssl->backend;\n  int sock = backend->ssl_sockfd;\n  OSStatus rtn = noErr;\n  size_t bytesRead;\n  ssize_t rrtn;\n  int theErr;\n\n  *dataLength = 0;\n\n  for(;;) {\n    bytesRead = 0;\n    rrtn = read(sock, currData, bytesToGo);\n    if(rrtn <= 0) {\n      /* this is guesswork... */\n      theErr = errno;\n      if(rrtn == 0) { /* EOF = server hung up */\n        /* the framework will turn this into errSSLClosedNoNotify */\n        rtn = errSSLClosedGraceful;\n      }\n      else /* do the switch */\n        switch(theErr) {\n          case ENOENT:\n            /* connection closed */\n            rtn = errSSLClosedGraceful;\n            break;\n          case ECONNRESET:\n            rtn = errSSLClosedAbort;\n            break;\n          case EAGAIN:\n            rtn = errSSLWouldBlock;\n            backend->ssl_direction = false;\n            break;\n          default:\n            rtn = ioErr;\n            break;\n        }\n      break;\n    }\n    else {\n      bytesRead = rrtn;\n    }\n    bytesToGo -= bytesRead;\n    currData  += bytesRead;\n\n    if(bytesToGo == 0) {\n      /* filled buffer with incoming data, done */\n      break;\n    }\n  }\n  *dataLength = initLen - bytesToGo;\n\n  return rtn;\n}\n\nstatic OSStatus SocketWrite(SSLConnectionRef connection,\n                            const void *data,\n                            size_t *dataLength)  /* IN/OUT */\n{\n  size_t bytesSent = 0;\n  /*int sock = *(int *)connection;*/\n  struct ssl_connect_data *connssl = (struct ssl_connect_data *)connection;\n  struct ssl_backend_data *backend = connssl->backend;\n  int sock = backend->ssl_sockfd;\n  ssize_t length;\n  size_t dataLen = *dataLength;\n  const UInt8 *dataPtr = (UInt8 *)data;\n  OSStatus ortn;\n  int theErr;\n\n  *dataLength = 0;\n\n  do {\n    length = write(sock,\n                   (char *)dataPtr + bytesSent,\n                   dataLen - bytesSent);\n  } while((length > 0) &&\n           ( (bytesSent += length) < dataLen) );\n\n  if(length <= 0) {\n    theErr = errno;\n    if(theErr == EAGAIN) {\n      ortn = errSSLWouldBlock;\n      backend->ssl_direction = true;\n    }\n    else {\n      ortn = ioErr;\n    }\n  }\n  else {\n    ortn = noErr;\n  }\n  *dataLength = bytesSent;\n  return ortn;\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nCF_INLINE const char *TLSCipherNameForNumber(SSLCipherSuite cipher)\n{\n  /* The first ciphers in the ciphertable are continuos. Here we do small\n     optimization and instead of loop directly get SSL name by cipher number.\n   */\n  if(cipher <= SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA) {\n    return ciphertable[cipher].name;\n  }\n  /* Iterate through the rest of the ciphers */\n  for(size_t i = SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA + 1;\n      i < NUM_OF_CIPHERS;\n      ++i) {\n    if(ciphertable[i].num == cipher) {\n      return ciphertable[i].name;\n    }\n  }\n  return ciphertable[SSL_NULL_WITH_NULL_NULL].name;\n}\n#endif /* !CURL_DISABLE_VERBOSE_STRINGS */\n\n#if CURL_BUILD_MAC\nCF_INLINE void GetDarwinVersionNumber(int *major, int *minor)\n{\n  int mib[2];\n  char *os_version;\n  size_t os_version_len;\n  char *os_version_major, *os_version_minor;\n  char *tok_buf;\n\n  /* Get the Darwin kernel version from the kernel using sysctl(): */\n  mib[0] = CTL_KERN;\n  mib[1] = KERN_OSRELEASE;\n  if(sysctl(mib, 2, NULL, &os_version_len, NULL, 0) == -1)\n    return;\n  os_version = malloc(os_version_len*sizeof(char));\n  if(!os_version)\n    return;\n  if(sysctl(mib, 2, os_version, &os_version_len, NULL, 0) == -1) {\n    free(os_version);\n    return;\n  }\n\n  /* Parse the version: */\n  os_version_major = strtok_r(os_version, \".\", &tok_buf);\n  os_version_minor = strtok_r(NULL, \".\", &tok_buf);\n  *major = atoi(os_version_major);\n  *minor = atoi(os_version_minor);\n  free(os_version);\n}\n#endif /* CURL_BUILD_MAC */\n\n/* Apple provides a myriad of ways of getting information about a certificate\n   into a string. Some aren't available under iOS or newer cats. So here's\n   a unified function for getting a string describing the certificate that\n   ought to work in all cats starting with Leopard. */\nCF_INLINE CFStringRef getsubject(SecCertificateRef cert)\n{\n  CFStringRef server_cert_summary = CFSTR(\"(null)\");\n\n#if CURL_BUILD_IOS\n  /* iOS: There's only one way to do this. */\n  server_cert_summary = SecCertificateCopySubjectSummary(cert);\n#else\n#if CURL_BUILD_MAC_10_7\n  /* Lion & later: Get the long description if we can. */\n  if(SecCertificateCopyLongDescription != NULL)\n    server_cert_summary =\n      SecCertificateCopyLongDescription(NULL, cert, NULL);\n  else\n#endif /* CURL_BUILD_MAC_10_7 */\n#if CURL_BUILD_MAC_10_6\n  /* Snow Leopard: Get the certificate summary. */\n  if(SecCertificateCopySubjectSummary != NULL)\n    server_cert_summary = SecCertificateCopySubjectSummary(cert);\n  else\n#endif /* CURL_BUILD_MAC_10_6 */\n  /* Leopard is as far back as we go... */\n  (void)SecCertificateCopyCommonName(cert, &server_cert_summary);\n#endif /* CURL_BUILD_IOS */\n  return server_cert_summary;\n}\n\nstatic CURLcode CopyCertSubject(struct Curl_easy *data,\n                                SecCertificateRef cert, char **certp)\n{\n  CFStringRef c = getsubject(cert);\n  CURLcode result = CURLE_OK;\n  const char *direct;\n  char *cbuf = NULL;\n  *certp = NULL;\n\n  if(!c) {\n    failf(data, \"SSL: invalid CA certificate subject\");\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  /* If the subject is already available as UTF-8 encoded (ie 'direct') then\n     use that, else convert it. */\n  direct = CFStringGetCStringPtr(c, kCFStringEncodingUTF8);\n  if(direct) {\n    *certp = strdup(direct);\n    if(!*certp) {\n      failf(data, \"SSL: out of memory\");\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n  else {\n    size_t cbuf_size = ((size_t)CFStringGetLength(c) * 4) + 1;\n    cbuf = calloc(cbuf_size, 1);\n    if(cbuf) {\n      if(!CFStringGetCString(c, cbuf, cbuf_size,\n                             kCFStringEncodingUTF8)) {\n        failf(data, \"SSL: invalid CA certificate subject\");\n        result = CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        /* pass back the buffer */\n        *certp = cbuf;\n    }\n    else {\n      failf(data, \"SSL: couldn't allocate %zu bytes of memory\", cbuf_size);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n  if(result)\n    free(cbuf);\n  CFRelease(c);\n  return result;\n}\n\n#if CURL_SUPPORT_MAC_10_6\n/* The SecKeychainSearch API was deprecated in Lion, and using it will raise\n   deprecation warnings, so let's not compile this unless it's necessary: */\nstatic OSStatus CopyIdentityWithLabelOldSchool(char *label,\n                                               SecIdentityRef *out_c_a_k)\n{\n  OSStatus status = errSecItemNotFound;\n  SecKeychainAttributeList attr_list;\n  SecKeychainAttribute attr;\n  SecKeychainSearchRef search = NULL;\n  SecCertificateRef cert = NULL;\n\n  /* Set up the attribute list: */\n  attr_list.count = 1L;\n  attr_list.attr = &attr;\n\n  /* Set up our lone search criterion: */\n  attr.tag = kSecLabelItemAttr;\n  attr.data = label;\n  attr.length = (UInt32)strlen(label);\n\n  /* Start searching: */\n  status = SecKeychainSearchCreateFromAttributes(NULL,\n                                                 kSecCertificateItemClass,\n                                                 &attr_list,\n                                                 &search);\n  if(status == noErr) {\n    status = SecKeychainSearchCopyNext(search,\n                                       (SecKeychainItemRef *)&cert);\n    if(status == noErr && cert) {\n      /* If we found a certificate, does it have a private key? */\n      status = SecIdentityCreateWithCertificate(NULL, cert, out_c_a_k);\n      CFRelease(cert);\n    }\n  }\n\n  if(search)\n    CFRelease(search);\n  return status;\n}\n#endif /* CURL_SUPPORT_MAC_10_6 */\n\nstatic OSStatus CopyIdentityWithLabel(char *label,\n                                      SecIdentityRef *out_cert_and_key)\n{\n  OSStatus status = errSecItemNotFound;\n\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n  CFArrayRef keys_list;\n  CFIndex keys_list_count;\n  CFIndex i;\n  CFStringRef common_name;\n\n  /* SecItemCopyMatching() was introduced in iOS and Snow Leopard.\n     kSecClassIdentity was introduced in Lion. If both exist, let's use them\n     to find the certificate. */\n  if(SecItemCopyMatching != NULL && kSecClassIdentity != NULL) {\n    CFTypeRef keys[5];\n    CFTypeRef values[5];\n    CFDictionaryRef query_dict;\n    CFStringRef label_cf = CFStringCreateWithCString(NULL, label,\n      kCFStringEncodingUTF8);\n\n    /* Set up our search criteria and expected results: */\n    values[0] = kSecClassIdentity; /* we want a certificate and a key */\n    keys[0] = kSecClass;\n    values[1] = kCFBooleanTrue;    /* we want a reference */\n    keys[1] = kSecReturnRef;\n    values[2] = kSecMatchLimitAll; /* kSecMatchLimitOne would be better if the\n                                    * label matching below worked correctly */\n    keys[2] = kSecMatchLimit;\n    /* identity searches need a SecPolicyRef in order to work */\n    values[3] = SecPolicyCreateSSL(false, NULL);\n    keys[3] = kSecMatchPolicy;\n    /* match the name of the certificate (doesn't work in macOS 10.12.1) */\n    values[4] = label_cf;\n    keys[4] = kSecAttrLabel;\n    query_dict = CFDictionaryCreate(NULL, (const void **)keys,\n                                    (const void **)values, 5L,\n                                    &kCFCopyStringDictionaryKeyCallBacks,\n                                    &kCFTypeDictionaryValueCallBacks);\n    CFRelease(values[3]);\n\n    /* Do we have a match? */\n    status = SecItemCopyMatching(query_dict, (CFTypeRef *) &keys_list);\n\n    /* Because kSecAttrLabel matching doesn't work with kSecClassIdentity,\n     * we need to find the correct identity ourselves */\n    if(status == noErr) {\n      keys_list_count = CFArrayGetCount(keys_list);\n      *out_cert_and_key = NULL;\n      status = 1;\n      for(i = 0; i<keys_list_count; i++) {\n        OSStatus err = noErr;\n        SecCertificateRef cert = NULL;\n        SecIdentityRef identity =\n          (SecIdentityRef) CFArrayGetValueAtIndex(keys_list, i);\n        err = SecIdentityCopyCertificate(identity, &cert);\n        if(err == noErr) {\n#if CURL_BUILD_IOS\n          common_name = SecCertificateCopySubjectSummary(cert);\n#elif CURL_BUILD_MAC_10_7\n          SecCertificateCopyCommonName(cert, &common_name);\n#endif\n          if(CFStringCompare(common_name, label_cf, 0) == kCFCompareEqualTo) {\n            CFRelease(cert);\n            CFRelease(common_name);\n            CFRetain(identity);\n            *out_cert_and_key = identity;\n            status = noErr;\n            break;\n          }\n          CFRelease(common_name);\n        }\n        CFRelease(cert);\n      }\n    }\n\n    if(keys_list)\n      CFRelease(keys_list);\n    CFRelease(query_dict);\n    CFRelease(label_cf);\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_6\n    /* On Leopard and Snow Leopard, fall back to SecKeychainSearch. */\n    status = CopyIdentityWithLabelOldSchool(label, out_cert_and_key);\n#endif /* CURL_SUPPORT_MAC_10_6 */\n  }\n#elif CURL_SUPPORT_MAC_10_6\n  /* For developers building on older cats, we have no choice but to fall back\n     to SecKeychainSearch. */\n  status = CopyIdentityWithLabelOldSchool(label, out_cert_and_key);\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n  return status;\n}\n\nstatic OSStatus CopyIdentityFromPKCS12File(const char *cPath,\n                                           const struct curl_blob *blob,\n                                           const char *cPassword,\n                                           SecIdentityRef *out_cert_and_key)\n{\n  OSStatus status = errSecItemNotFound;\n  CFURLRef pkcs_url = NULL;\n  CFStringRef password = cPassword ? CFStringCreateWithCString(NULL,\n    cPassword, kCFStringEncodingUTF8) : NULL;\n  CFDataRef pkcs_data = NULL;\n\n  /* We can import P12 files on iOS or OS X 10.7 or later: */\n  /* These constants are documented as having first appeared in 10.6 but they\n     raise linker errors when used on that cat for some reason. */\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n  bool resource_imported;\n\n  if(blob) {\n    pkcs_data = CFDataCreate(kCFAllocatorDefault,\n                             (const unsigned char *)blob->data, blob->len);\n    status = (pkcs_data != NULL) ? errSecSuccess : errSecAllocate;\n    resource_imported = (pkcs_data != NULL);\n  }\n  else {\n    pkcs_url =\n      CFURLCreateFromFileSystemRepresentation(NULL,\n                                              (const UInt8 *)cPath,\n                                              strlen(cPath), false);\n    resource_imported =\n      CFURLCreateDataAndPropertiesFromResource(NULL,\n                                               pkcs_url, &pkcs_data,\n                                               NULL, NULL, &status);\n  }\n\n  if(resource_imported) {\n    CFArrayRef items = NULL;\n\n  /* On iOS SecPKCS12Import will never add the client certificate to the\n   * Keychain.\n   *\n   * It gives us back a SecIdentityRef that we can use directly. */\n#if CURL_BUILD_IOS\n    const void *cKeys[] = {kSecImportExportPassphrase};\n    const void *cValues[] = {password};\n    CFDictionaryRef options = CFDictionaryCreate(NULL, cKeys, cValues,\n      password ? 1L : 0L, NULL, NULL);\n\n    if(options != NULL) {\n      status = SecPKCS12Import(pkcs_data, options, &items);\n      CFRelease(options);\n    }\n\n\n  /* On macOS SecPKCS12Import will always add the client certificate to\n   * the Keychain.\n   *\n   * As this doesn't match iOS, and apps may not want to see their client\n   * certificate saved in the user's keychain, we use SecItemImport\n   * with a NULL keychain to avoid importing it.\n   *\n   * This returns a SecCertificateRef from which we can construct a\n   * SecIdentityRef.\n   */\n#elif CURL_BUILD_MAC_10_7\n    SecItemImportExportKeyParameters keyParams;\n    SecExternalFormat inputFormat = kSecFormatPKCS12;\n    SecExternalItemType inputType = kSecItemTypeCertificate;\n\n    memset(&keyParams, 0x00, sizeof(keyParams));\n    keyParams.version    = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n    keyParams.passphrase = password;\n\n    status = SecItemImport(pkcs_data, NULL, &inputFormat, &inputType,\n                           0, &keyParams, NULL, &items);\n#endif\n\n\n    /* Extract the SecIdentityRef */\n    if(status == errSecSuccess && items && CFArrayGetCount(items)) {\n      CFIndex i, count;\n      count = CFArrayGetCount(items);\n\n      for(i = 0; i < count; i++) {\n        CFTypeRef item = (CFTypeRef) CFArrayGetValueAtIndex(items, i);\n        CFTypeID  itemID = CFGetTypeID(item);\n\n        if(itemID == CFDictionaryGetTypeID()) {\n          CFTypeRef identity = (CFTypeRef) CFDictionaryGetValue(\n                                                 (CFDictionaryRef) item,\n                                                 kSecImportItemIdentity);\n          CFRetain(identity);\n          *out_cert_and_key = (SecIdentityRef) identity;\n          break;\n        }\n#if CURL_BUILD_MAC_10_7\n        else if(itemID == SecCertificateGetTypeID()) {\n          status = SecIdentityCreateWithCertificate(NULL,\n                                                 (SecCertificateRef) item,\n                                                 out_cert_and_key);\n          break;\n        }\n#endif\n      }\n    }\n\n    if(items)\n      CFRelease(items);\n    CFRelease(pkcs_data);\n  }\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n  if(password)\n    CFRelease(password);\n  if(pkcs_url)\n    CFRelease(pkcs_url);\n  return status;\n}\n\n/* This code was borrowed from nss.c, with some modifications:\n * Determine whether the nickname passed in is a filename that needs to\n * be loaded as a PEM or a regular NSS nickname.\n *\n * returns 1 for a file\n * returns 0 for not a file\n */\nCF_INLINE bool is_file(const char *filename)\n{\n  struct_stat st;\n\n  if(!filename)\n    return false;\n\n  if(stat(filename, &st) == 0)\n    return S_ISREG(st.st_mode);\n  return false;\n}\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\nstatic CURLcode sectransp_version_from_curl(SSLProtocol *darwinver,\n                                            long ssl_version)\n{\n  switch(ssl_version) {\n    case CURL_SSLVERSION_TLSv1_0:\n      *darwinver = kTLSProtocol1;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_1:\n      *darwinver = kTLSProtocol11;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_2:\n      *darwinver = kTLSProtocol12;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      /* TLS 1.3 support first appeared in iOS 11 and macOS 10.13 */\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n      if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n        *darwinver = kTLSProtocol13;\n        return CURLE_OK;\n      }\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n      break;\n  }\n  return CURLE_SSL_CONNECT_ERROR;\n}\n#endif\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  long ssl_version = SSL_CONN_CONFIG(version);\n  long ssl_version_max = SSL_CONN_CONFIG(version_max);\n  long max_supported_version_by_os;\n\n  /* macOS 10.5-10.7 supported TLS 1.0 only.\n     macOS 10.8 and later, and iOS 5 and later, added TLS 1.1 and 1.2.\n     macOS 10.13 and later, and iOS 11 and later, added TLS 1.3. */\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n  if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n    max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_3;\n  }\n  else {\n    max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_2;\n  }\n#else\n  max_supported_version_by_os = CURL_SSLVERSION_MAX_TLSv1_2;\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      ssl_version = CURL_SSLVERSION_TLSv1_0;\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = max_supported_version_by_os;\n      break;\n  }\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLSetProtocolVersionMax != NULL) {\n    SSLProtocol darwin_ver_min = kTLSProtocol1;\n    SSLProtocol darwin_ver_max = kTLSProtocol1;\n    CURLcode result = sectransp_version_from_curl(&darwin_ver_min,\n                                                  ssl_version);\n    if(result) {\n      failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n    result = sectransp_version_from_curl(&darwin_ver_max,\n                                         ssl_version_max >> 16);\n    if(result) {\n      failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n      return result;\n    }\n\n    (void)SSLSetProtocolVersionMin(backend->ssl_ctx, darwin_ver_min);\n    (void)SSLSetProtocolVersionMax(backend->ssl_ctx, darwin_ver_max);\n    return result;\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    long i = ssl_version;\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kSSLProtocolAll,\n                                       false);\n    for(; i <= (ssl_version_max >> 16); i++) {\n      switch(i) {\n        case CURL_SSLVERSION_TLSv1_0:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol1,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_1:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol11,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_2:\n          (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                            kTLSProtocol12,\n                                            true);\n          break;\n        case CURL_SSLVERSION_TLSv1_3:\n          failf(data, \"Your version of the OS does not support TLSv1.3\");\n          return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    return CURLE_OK;\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n  }\n#endif  /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n  failf(data, \"Secure Transport: cannot set SSL protocol\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nstatic bool is_cipher_suite_strong(SSLCipherSuite suite_num)\n{\n  for(size_t i = 0; i < NUM_OF_CIPHERS; ++i) {\n    if(ciphertable[i].num == suite_num) {\n      return !ciphertable[i].weak;\n    }\n  }\n  /* If the cipher is not in our list, assume it is a new one\n     and therefore strong. Previous implementation was the same,\n     if cipher suite is not in the list, it was considered strong enough */\n  return true;\n}\n\nstatic bool is_separator(char c)\n{\n  /* Return whether character is a cipher list separator. */\n  switch(c) {\n  case ' ':\n  case '\\t':\n  case ':':\n  case ',':\n  case ';':\n    return true;\n  }\n  return false;\n}\n\nstatic CURLcode sectransp_set_default_ciphers(struct Curl_easy *data,\n                                              SSLContextRef ssl_ctx)\n{\n  size_t all_ciphers_count = 0UL, allowed_ciphers_count = 0UL, i;\n  SSLCipherSuite *all_ciphers = NULL, *allowed_ciphers = NULL;\n  OSStatus err = noErr;\n\n#if CURL_BUILD_MAC\n  int darwinver_maj = 0, darwinver_min = 0;\n\n  GetDarwinVersionNumber(&darwinver_maj, &darwinver_min);\n#endif /* CURL_BUILD_MAC */\n\n  /* Disable cipher suites that ST supports but are not safe. These ciphers\n     are unlikely to be used in any case since ST gives other ciphers a much\n     higher priority, but it's probably better that we not connect at all than\n     to give the user a false sense of security if the server only supports\n     insecure ciphers. (Note: We don't care about SSLv2-only ciphers.) */\n  err = SSLGetNumberSupportedCiphers(ssl_ctx, &all_ciphers_count);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLGetNumberSupportedCiphers() failed: OSStatus %d\",\n          err);\n    return CURLE_SSL_CIPHER;\n  }\n  all_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));\n  if(!all_ciphers) {\n    failf(data, \"SSL: Failed to allocate memory for all ciphers\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n  allowed_ciphers = malloc(all_ciphers_count*sizeof(SSLCipherSuite));\n  if(!allowed_ciphers) {\n    Curl_safefree(all_ciphers);\n    failf(data, \"SSL: Failed to allocate memory for allowed ciphers\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n  err = SSLGetSupportedCiphers(ssl_ctx, all_ciphers,\n                               &all_ciphers_count);\n  if(err != noErr) {\n    Curl_safefree(all_ciphers);\n    Curl_safefree(allowed_ciphers);\n    return CURLE_SSL_CIPHER;\n  }\n  for(i = 0UL ; i < all_ciphers_count ; i++) {\n#if CURL_BUILD_MAC\n   /* There's a known bug in early versions of Mountain Lion where ST's ECC\n      ciphers (cipher suite 0xC001 through 0xC032) simply do not work.\n      Work around the problem here by disabling those ciphers if we are\n      running in an affected version of OS X. */\n    if(darwinver_maj == 12 && darwinver_min <= 3 &&\n       all_ciphers[i] >= 0xC001 && all_ciphers[i] <= 0xC032) {\n      continue;\n    }\n#endif /* CURL_BUILD_MAC */\n    if(is_cipher_suite_strong(all_ciphers[i])) {\n      allowed_ciphers[allowed_ciphers_count++] = all_ciphers[i];\n    }\n  }\n  err = SSLSetEnabledCiphers(ssl_ctx, allowed_ciphers,\n                             allowed_ciphers_count);\n  Curl_safefree(all_ciphers);\n  Curl_safefree(allowed_ciphers);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnabledCiphers() failed: OSStatus %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_set_selected_ciphers(struct Curl_easy *data,\n                                               SSLContextRef ssl_ctx,\n                                               const char *ciphers)\n{\n  size_t ciphers_count = 0;\n  const char *cipher_start = ciphers;\n  OSStatus err = noErr;\n  SSLCipherSuite selected_ciphers[NUM_OF_CIPHERS];\n\n  if(!ciphers)\n    return CURLE_OK;\n\n  while(is_separator(*ciphers))     /* Skip initial separators. */\n    ciphers++;\n  if(!*ciphers)\n    return CURLE_OK;\n\n  cipher_start = ciphers;\n  while(*cipher_start && ciphers_count < NUM_OF_CIPHERS) {\n    bool cipher_found = FALSE;\n    size_t cipher_len = 0;\n    const char *cipher_end = NULL;\n    bool tls_name = FALSE;\n\n    /* Skip separators */\n    while(is_separator(*cipher_start))\n       cipher_start++;\n    if(*cipher_start == '\\0') {\n      break;\n    }\n    /* Find last position of a cipher in the ciphers string */\n    cipher_end = cipher_start;\n    while (*cipher_end != '\\0' && !is_separator(*cipher_end)) {\n      ++cipher_end;\n    }\n\n    /* IANA cipher names start with the TLS_ or SSL_ prefix.\n       If the 4th symbol of the cipher is '_' we look for a cipher in the\n       table by its (TLS) name.\n       Otherwise, we try to match cipher by an alias. */\n    if(cipher_start[3] == '_') {\n      tls_name = TRUE;\n    }\n    /* Iterate through the cipher table and look for the cipher, starting\n       the cipher number 0x01 because the 0x00 is not the real cipher */\n    cipher_len = cipher_end - cipher_start;\n    for(size_t i = 1; i < NUM_OF_CIPHERS; ++i) {\n      const char *table_cipher_name = NULL;\n      if(tls_name) {\n        table_cipher_name = ciphertable[i].name;\n      }\n      else if(ciphertable[i].alias_name != NULL) {\n        table_cipher_name = ciphertable[i].alias_name;\n      }\n      else {\n        continue;\n      }\n      /* Compare a part of the string between separators with a cipher name\n         in the table and make sure we matched the whole cipher name */\n      if(strncmp(cipher_start, table_cipher_name, cipher_len) == 0\n          && table_cipher_name[cipher_len] == '\\0') {\n        selected_ciphers[ciphers_count] = ciphertable[i].num;\n        ++ciphers_count;\n        cipher_found = TRUE;\n        break;\n      }\n    }\n    if(!cipher_found) {\n      /* It would be more human-readable if we print the wrong cipher name\n         but we don't want to allocate any additional memory and copy the name\n         into it, then add it into logs.\n         Also, we do not modify an original cipher list string. We just point\n         to positions where cipher starts and ends in the cipher list string.\n         The message is a bit cryptic and longer than necessary but can be\n         understood by humans. */\n      failf(data, \"SSL: cipher string \\\"%s\\\" contains unsupported cipher name\"\n            \" starting position %d and ending position %d\",\n            ciphers,\n            cipher_start - ciphers,\n            cipher_end - ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    if(*cipher_end) {\n      cipher_start = cipher_end + 1;\n    }\n    else {\n      break;\n    }\n  }\n  /* All cipher suites in the list are found. Report to logs as-is */\n  infof(data, \"SSL: Setting cipher suites list \\\"%s\\\"\\n\", ciphers);\n\n  err = SSLSetEnabledCiphers(ssl_ctx, selected_ciphers, ciphers_count);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnabledCiphers() failed: OSStatus %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_connect_step1(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        int sockindex)\n{\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const struct curl_blob *ssl_cablob = SSL_CONN_CONFIG(ca_info_blob);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ssl_cablob ? NULL : SSL_CONN_CONFIG(CAfile));\n  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);\n  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n  bool isproxy = SSL_IS_PROXY();\n  const char * const hostname = SSL_HOST_NAME();\n  const long int port = SSL_HOST_PORT();\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif /* ENABLE_IPV6 */\n  char *ciphers;\n  OSStatus err = noErr;\n#if CURL_BUILD_MAC\n  int darwinver_maj = 0, darwinver_min = 0;\n\n  GetDarwinVersionNumber(&darwinver_maj, &darwinver_min);\n#endif /* CURL_BUILD_MAC */\n\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLCreateContext != NULL) {  /* use the newer API if available */\n    if(backend->ssl_ctx)\n      CFRelease(backend->ssl_ctx);\n    backend->ssl_ctx = SSLCreateContext(NULL, kSSLClientSide, kSSLStreamType);\n    if(!backend->ssl_ctx) {\n      failf(data, \"SSL: couldn't create a context!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  else {\n  /* The old ST API does not exist under iOS, so don't compile it: */\n#if CURL_SUPPORT_MAC_10_8\n    if(backend->ssl_ctx)\n      (void)SSLDisposeContext(backend->ssl_ctx);\n    err = SSLNewContext(false, &(backend->ssl_ctx));\n    if(err != noErr) {\n      failf(data, \"SSL: couldn't create a context: OSStatus %d\", err);\n      return CURLE_OUT_OF_MEMORY;\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  if(backend->ssl_ctx)\n    (void)SSLDisposeContext(backend->ssl_ctx);\n  err = SSLNewContext(false, &(backend->ssl_ctx));\n  if(err != noErr) {\n    failf(data, \"SSL: couldn't create a context: OSStatus %d\", err);\n    return CURLE_OUT_OF_MEMORY;\n  }\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n  backend->ssl_write_buffered_length = 0UL; /* reset buffered write length */\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n  if(SSLSetProtocolVersionMax != NULL) {\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_TLSv1:\n      (void)SSLSetProtocolVersionMin(backend->ssl_ctx, kTLSProtocol1);\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n      if(__builtin_available(macOS 10.13, iOS 11.0, *)) {\n        (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol13);\n      }\n      else {\n        (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol12);\n      }\n#else\n      (void)SSLSetProtocolVersionMax(backend->ssl_ctx, kTLSProtocol12);\n#endif /* (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) &&\n          HAVE_BUILTIN_AVAILABLE == 1 */\n      break;\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n      {\n        CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n        if(result != CURLE_OK)\n          return result;\n        break;\n      }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kSSLProtocolAll,\n                                       false);\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol1,\n                                         true);\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol11,\n                                         true);\n      (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                         kTLSProtocol12,\n                                         true);\n      break;\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n      {\n        CURLcode result = set_ssl_version_min_max(data, conn, sockindex);\n        if(result != CURLE_OK)\n          return result;\n        break;\n      }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  if(conn->ssl_config.version_max != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"Your version of the OS does not support to set maximum\"\n                \" SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx, kSSLProtocolAll, false);\n  switch(conn->ssl_config.version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n  case CURL_SSLVERSION_TLSv1_0:\n    (void)SSLSetProtocolVersionEnabled(backend->ssl_ctx,\n                                       kTLSProtocol1,\n                                       true);\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n    failf(data, \"Your version of the OS does not support TLSv1.1\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_TLSv1_2:\n    failf(data, \"Your version of the OS does not support TLSv1.2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_TLSv1_3:\n    failf(data, \"Your version of the OS does not support TLSv1.3\");\n    return CURLE_SSL_CONNECT_ERROR;\n  case CURL_SSLVERSION_SSLv2:\n  case CURL_SSLVERSION_SSLv3:\n    failf(data, \"SSL versions not supported\");\n    return CURLE_NOT_BUILT_IN;\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n\n#if (CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n  if(conn->bits.tls_enable_alpn) {\n    if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {\n      CFMutableArrayRef alpnArr = CFArrayCreateMutable(NULL, 0,\n                                                       &kCFTypeArrayCallBacks);\n\n#ifdef USE_HTTP2\n      if(data->state.httpwant >= CURL_HTTP_VERSION_2\n#ifndef CURL_DISABLE_PROXY\n         && (!isproxy || !conn->bits.tunnel_proxy)\n#endif\n        ) {\n        CFArrayAppendValue(alpnArr, CFSTR(ALPN_H2));\n        infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n      }\n#endif\n\n      CFArrayAppendValue(alpnArr, CFSTR(ALPN_HTTP_1_1));\n      infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n      /* expects length prefixed preference ordered list of protocols in wire\n       * format\n       */\n      err = SSLSetALPNProtocols(backend->ssl_ctx, alpnArr);\n      if(err != noErr)\n        infof(data, \"WARNING: failed to set ALPN protocols; OSStatus %d\\n\",\n              err);\n      CFRelease(alpnArr);\n    }\n  }\n#endif\n\n  if(SSL_SET_OPTION(key)) {\n    infof(data, \"WARNING: SSL: CURLOPT_SSLKEY is ignored by Secure \"\n          \"Transport. The private key must be in the Keychain.\\n\");\n  }\n\n  if(ssl_cert || ssl_cert_blob) {\n    bool is_cert_data = ssl_cert_blob != NULL;\n    bool is_cert_file = (!is_cert_data) && is_file(ssl_cert);\n    SecIdentityRef cert_and_key = NULL;\n\n    /* User wants to authenticate with a client cert. Look for it:\n       If we detect that this is a file on disk, then let's load it.\n       Otherwise, assume that the user wants to use an identity loaded\n       from the Keychain. */\n    if(is_cert_file || is_cert_data) {\n      if(!SSL_SET_OPTION(cert_type))\n        infof(data, \"WARNING: SSL: Certificate type not set, assuming \"\n                    \"PKCS#12 format.\\n\");\n      else if(strncmp(SSL_SET_OPTION(cert_type), \"P12\",\n        strlen(SSL_SET_OPTION(cert_type))) != 0)\n        infof(data, \"WARNING: SSL: The Security framework only supports \"\n                    \"loading identities that are in PKCS#12 format.\\n\");\n\n      err = CopyIdentityFromPKCS12File(ssl_cert, ssl_cert_blob,\n        SSL_SET_OPTION(key_passwd), &cert_and_key);\n    }\n    else\n      err = CopyIdentityWithLabel(ssl_cert, &cert_and_key);\n\n    if(err == noErr && cert_and_key) {\n      SecCertificateRef cert = NULL;\n      CFTypeRef certs_c[1];\n      CFArrayRef certs;\n\n      /* If we found one, print it out: */\n      err = SecIdentityCopyCertificate(cert_and_key, &cert);\n      if(err == noErr) {\n        char *certp;\n        CURLcode result = CopyCertSubject(data, cert, &certp);\n        if(!result) {\n          infof(data, \"Client certificate: %s\\n\", certp);\n          free(certp);\n        }\n\n        CFRelease(cert);\n        if(result == CURLE_PEER_FAILED_VERIFICATION)\n          return CURLE_SSL_CERTPROBLEM;\n        if(result)\n          return result;\n      }\n      certs_c[0] = cert_and_key;\n      certs = CFArrayCreate(NULL, (const void **)certs_c, 1L,\n                            &kCFTypeArrayCallBacks);\n      err = SSLSetCertificate(backend->ssl_ctx, certs);\n      if(certs)\n        CFRelease(certs);\n      if(err != noErr) {\n        failf(data, \"SSL: SSLSetCertificate() failed: OSStatus %d\", err);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n      CFRelease(cert_and_key);\n    }\n    else {\n      const char *cert_showfilename_error =\n        is_cert_data ? \"(memory blob)\" : ssl_cert;\n\n      switch(err) {\n      case errSecAuthFailed: case -25264: /* errSecPkcs12VerifyFailure */\n        failf(data, \"SSL: Incorrect password for the certificate \\\"%s\\\" \"\n                    \"and its private key.\", cert_showfilename_error);\n        break;\n      case -26275: /* errSecDecode */ case -25257: /* errSecUnknownFormat */\n        failf(data, \"SSL: Couldn't make sense of the data in the \"\n                    \"certificate \\\"%s\\\" and its private key.\",\n                    cert_showfilename_error);\n        break;\n      case -25260: /* errSecPassphraseRequired */\n        failf(data, \"SSL The certificate \\\"%s\\\" requires a password.\",\n                    cert_showfilename_error);\n        break;\n      case errSecItemNotFound:\n        failf(data, \"SSL: Can't find the certificate \\\"%s\\\" and its private \"\n                    \"key in the Keychain.\", cert_showfilename_error);\n        break;\n      default:\n        failf(data, \"SSL: Can't load the certificate \\\"%s\\\" and its private \"\n                    \"key: OSStatus %d\", cert_showfilename_error, err);\n        break;\n      }\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n#if CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS\n  /* Snow Leopard introduced the SSLSetSessionOption() function, but due to\n     a library bug with the way the kSSLSessionOptionBreakOnServerAuth flag\n     works, it doesn't work as expected under Snow Leopard, Lion or\n     Mountain Lion.\n     So we need to call SSLSetEnableCertVerify() on those older cats in order\n     to disable certificate validation if the user turned that off.\n     (SecureTransport will always validate the certificate chain by\n     default.)\n  Note:\n  Darwin 11.x.x is Lion (10.7)\n  Darwin 12.x.x is Mountain Lion (10.8)\n  Darwin 13.x.x is Mavericks (10.9)\n  Darwin 14.x.x is Yosemite (10.10)\n  Darwin 15.x.x is El Capitan (10.11)\n  */\n#if CURL_BUILD_MAC\n  if(SSLSetSessionOption != NULL && darwinver_maj >= 13) {\n#else\n  if(SSLSetSessionOption != NULL) {\n#endif /* CURL_BUILD_MAC */\n    bool break_on_auth = !conn->ssl_config.verifypeer ||\n      ssl_cafile || ssl_cablob;\n    err = SSLSetSessionOption(backend->ssl_ctx,\n                              kSSLSessionOptionBreakOnServerAuth,\n                              break_on_auth);\n    if(err != noErr) {\n      failf(data, \"SSL: SSLSetSessionOption() failed: OSStatus %d\", err);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    err = SSLSetEnableCertVerify(backend->ssl_ctx,\n                                 conn->ssl_config.verifypeer?true:false);\n    if(err != noErr) {\n      failf(data, \"SSL: SSLSetEnableCertVerify() failed: OSStatus %d\", err);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#else\n  err = SSLSetEnableCertVerify(backend->ssl_ctx,\n                               conn->ssl_config.verifypeer?true:false);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetEnableCertVerify() failed: OSStatus %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* CURL_BUILD_MAC_10_6 || CURL_BUILD_IOS */\n\n  if((ssl_cafile || ssl_cablob) && verifypeer) {\n    bool is_cert_data = ssl_cablob != NULL;\n    bool is_cert_file = (!is_cert_data) && is_file(ssl_cafile);\n\n    if(!(is_cert_file || is_cert_data)) {\n      failf(data, \"SSL: can't load CA certificate file %s\",\n            ssl_cafile ? ssl_cafile : \"(blob memory)\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n\n  /* Configure hostname check. SNI is used if available.\n   * Both hostname check and SNI require SSLSetPeerDomainName().\n   * Also: the verifyhost setting influences SNI usage */\n  if(conn->ssl_config.verifyhost) {\n    err = SSLSetPeerDomainName(backend->ssl_ctx, hostname,\n    strlen(hostname));\n\n    if(err != noErr) {\n      infof(data, \"WARNING: SSL: SSLSetPeerDomainName() failed: OSStatus %d\\n\",\n            err);\n    }\n\n    if((Curl_inet_pton(AF_INET, hostname, &addr))\n  #ifdef ENABLE_IPV6\n    || (Curl_inet_pton(AF_INET6, hostname, &addr))\n  #endif\n       ) {\n      infof(data, \"WARNING: using IP address, SNI is being disabled by \"\n            \"the OS.\\n\");\n    }\n  }\n  else {\n    infof(data, \"WARNING: disabling hostname validation also disables SNI.\\n\");\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n    err = sectransp_set_selected_ciphers(data, backend->ssl_ctx, ciphers);\n  }\n  else {\n    err = sectransp_set_default_ciphers(data, backend->ssl_ctx);\n  }\n  if(err != noErr) {\n    failf(data, \"SSL: Unable to set ciphers for SSL/TLS handshake. \"\n          \"Error code: %d\", err);\n    return CURLE_SSL_CIPHER;\n  }\n\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  /* We want to enable 1/n-1 when using a CBC cipher unless the user\n     specifically doesn't want us doing that: */\n  if(SSLSetSessionOption != NULL) {\n    SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionSendOneByteRecord,\n                        !SSL_SET_OPTION(enable_beast));\n    SSLSetSessionOption(backend->ssl_ctx, kSSLSessionOptionFalseStart,\n                      data->set.ssl.falsestart); /* false start support */\n  }\n#endif /* CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7 */\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    char *ssl_sessionid;\n    size_t ssl_sessionid_len;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, isproxy, (void **)&ssl_sessionid,\n                              &ssl_sessionid_len, sockindex)) {\n      /* we got a session id, use it! */\n      err = SSLSetPeerID(backend->ssl_ctx, ssl_sessionid, ssl_sessionid_len);\n      Curl_ssl_sessionid_unlock(data);\n      if(err != noErr) {\n        failf(data, \"SSL: SSLSetPeerID() failed: OSStatus %d\", err);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    /* If there isn't one, then let's make one up! This has to be done prior\n       to starting the handshake. */\n    else {\n      CURLcode result;\n      ssl_sessionid =\n        aprintf(\"%s:%d:%d:%s:%ld\",\n                ssl_cafile ? ssl_cafile : \"(blob memory)\",\n                verifypeer, SSL_CONN_CONFIG(verifyhost), hostname, port);\n      ssl_sessionid_len = strlen(ssl_sessionid);\n\n      err = SSLSetPeerID(backend->ssl_ctx, ssl_sessionid, ssl_sessionid_len);\n      if(err != noErr) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSLSetPeerID() failed: OSStatus %d\", err);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n\n      result = Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n                                     ssl_sessionid_len, sockindex);\n      Curl_ssl_sessionid_unlock(data);\n      if(result) {\n        failf(data, \"failed to store ssl session\");\n        return result;\n      }\n    }\n  }\n\n  err = SSLSetIOFuncs(backend->ssl_ctx, SocketRead, SocketWrite);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetIOFuncs() failed: OSStatus %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* pass the raw socket into the SSL layers */\n  /* We need to store the FD in a constant memory address, because\n   * SSLSetConnection() will not copy that address. I've found that\n   * conn->sock[sockindex] may change on its own. */\n  backend->ssl_sockfd = sockfd;\n  err = SSLSetConnection(backend->ssl_ctx, connssl);\n  if(err != noErr) {\n    failf(data, \"SSL: SSLSetConnection() failed: %d\", err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\nstatic long pem_to_der(const char *in, unsigned char **out, size_t *outlen)\n{\n  char *sep_start, *sep_end, *cert_start, *cert_end;\n  size_t i, j, err;\n  size_t len;\n  unsigned char *b64;\n\n  /* Jump through the separators at the beginning of the certificate. */\n  sep_start = strstr(in, \"-----\");\n  if(!sep_start)\n    return 0;\n  cert_start = strstr(sep_start + 1, \"-----\");\n  if(!cert_start)\n    return -1;\n\n  cert_start += 5;\n\n  /* Find separator after the end of the certificate. */\n  cert_end = strstr(cert_start, \"-----\");\n  if(!cert_end)\n    return -1;\n\n  sep_end = strstr(cert_end + 1, \"-----\");\n  if(!sep_end)\n    return -1;\n  sep_end += 5;\n\n  len = cert_end - cert_start;\n  b64 = malloc(len + 1);\n  if(!b64)\n    return -1;\n\n  /* Create base64 string without linefeeds. */\n  for(i = 0, j = 0; i < len; i++) {\n    if(cert_start[i] != '\\r' && cert_start[i] != '\\n')\n      b64[j++] = cert_start[i];\n  }\n  b64[j] = '\\0';\n\n  err = Curl_base64_decode((const char *)b64, out, outlen);\n  free(b64);\n  if(err) {\n    free(*out);\n    return -1;\n  }\n\n  return sep_end - in;\n}\n\nstatic int read_cert(const char *file, unsigned char **out, size_t *outlen)\n{\n  int fd;\n  ssize_t n, len = 0, cap = 512;\n  unsigned char buf[512], *data;\n\n  fd = open(file, 0);\n  if(fd < 0)\n    return -1;\n\n  data = malloc(cap);\n  if(!data) {\n    close(fd);\n    return -1;\n  }\n\n  for(;;) {\n    n = read(fd, buf, sizeof(buf));\n    if(n < 0) {\n      close(fd);\n      free(data);\n      return -1;\n    }\n    else if(n == 0) {\n      close(fd);\n      break;\n    }\n\n    if(len + n >= cap) {\n      cap *= 2;\n      data = Curl_saferealloc(data, cap);\n      if(!data) {\n        close(fd);\n        return -1;\n      }\n    }\n\n    memcpy(data + len, buf, n);\n    len += n;\n  }\n  data[len] = '\\0';\n\n  *out = data;\n  *outlen = len;\n\n  return 0;\n}\n\nstatic int append_cert_to_array(struct Curl_easy *data,\n                                const unsigned char *buf, size_t buflen,\n                                CFMutableArrayRef array)\n{\n    CFDataRef certdata = CFDataCreate(kCFAllocatorDefault, buf, buflen);\n    char *certp;\n    CURLcode result;\n    if(!certdata) {\n      failf(data, \"SSL: failed to allocate array for CA certificate\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    SecCertificateRef cacert =\n      SecCertificateCreateWithData(kCFAllocatorDefault, certdata);\n    CFRelease(certdata);\n    if(!cacert) {\n      failf(data, \"SSL: failed to create SecCertificate from CA certificate\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n\n    /* Check if cacert is valid. */\n    result = CopyCertSubject(data, cacert, &certp);\n    switch(result) {\n      case CURLE_OK:\n        break;\n      case CURLE_PEER_FAILED_VERIFICATION:\n        return CURLE_SSL_CACERT_BADFILE;\n      case CURLE_OUT_OF_MEMORY:\n      default:\n        return result;\n    }\n    free(certp);\n\n    CFArrayAppendValue(array, cacert);\n    CFRelease(cacert);\n\n    return CURLE_OK;\n}\n\nstatic CURLcode verify_cert_buf(struct Curl_easy *data,\n                                const unsigned char *certbuf, size_t buflen,\n                                SSLContextRef ctx)\n{\n  int n = 0, rc;\n  long res;\n  unsigned char *der;\n  size_t derlen, offset = 0;\n\n  /*\n   * Certbuf now contains the contents of the certificate file, which can be\n   * - a single DER certificate,\n   * - a single PEM certificate or\n   * - a bunch of PEM certificates (certificate bundle).\n   *\n   * Go through certbuf, and convert any PEM certificate in it into DER\n   * format.\n   */\n  CFMutableArrayRef array = CFArrayCreateMutable(kCFAllocatorDefault, 0,\n                                                 &kCFTypeArrayCallBacks);\n  if(!array) {\n    failf(data, \"SSL: out of memory creating CA certificate array\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  while(offset < buflen) {\n    n++;\n\n    /*\n     * Check if the certificate is in PEM format, and convert it to DER. If\n     * this fails, we assume the certificate is in DER format.\n     */\n    res = pem_to_der((const char *)certbuf + offset, &der, &derlen);\n    if(res < 0) {\n      CFRelease(array);\n      failf(data, \"SSL: invalid CA certificate #%d (offset %zu) in bundle\",\n            n, offset);\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n    offset += res;\n\n    if(res == 0 && offset == 0) {\n      /* This is not a PEM file, probably a certificate in DER format. */\n      rc = append_cert_to_array(data, certbuf, buflen, array);\n      if(rc != CURLE_OK) {\n        CFRelease(array);\n        return rc;\n      }\n      break;\n    }\n    else if(res == 0) {\n      /* No more certificates in the bundle. */\n      break;\n    }\n\n    rc = append_cert_to_array(data, der, derlen, array);\n    free(der);\n    if(rc != CURLE_OK) {\n      CFRelease(array);\n      return rc;\n    }\n  }\n\n  SecTrustRef trust;\n  OSStatus ret = SSLCopyPeerTrust(ctx, &trust);\n  if(!trust) {\n    failf(data, \"SSL: error getting certificate chain\");\n    CFRelease(array);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  else if(ret != noErr) {\n    CFRelease(array);\n    failf(data, \"SSLCopyPeerTrust() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  ret = SecTrustSetAnchorCertificates(trust, array);\n  if(ret != noErr) {\n    CFRelease(array);\n    CFRelease(trust);\n    failf(data, \"SecTrustSetAnchorCertificates() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n  ret = SecTrustSetAnchorCertificatesOnly(trust, true);\n  if(ret != noErr) {\n    CFRelease(array);\n    CFRelease(trust);\n    failf(data, \"SecTrustSetAnchorCertificatesOnly() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  SecTrustResultType trust_eval = 0;\n  ret = SecTrustEvaluate(trust, &trust_eval);\n  CFRelease(array);\n  CFRelease(trust);\n  if(ret != noErr) {\n    failf(data, \"SecTrustEvaluate() returned error %d\", ret);\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  switch(trust_eval) {\n    case kSecTrustResultUnspecified:\n    case kSecTrustResultProceed:\n      return CURLE_OK;\n\n    case kSecTrustResultRecoverableTrustFailure:\n    case kSecTrustResultDeny:\n    default:\n      failf(data, \"SSL: certificate verification failed (result: %d)\",\n            trust_eval);\n      return CURLE_PEER_FAILED_VERIFICATION;\n  }\n}\n\nstatic CURLcode verify_cert(struct Curl_easy *data, const char *cafile,\n                            const struct curl_blob *ca_info_blob,\n                            SSLContextRef ctx)\n{\n  int result;\n  unsigned char *certbuf;\n  size_t buflen;\n\n  if(ca_info_blob) {\n    certbuf = (unsigned char *)malloc(ca_info_blob->len + 1);\n    if(!certbuf) {\n      return CURLE_OUT_OF_MEMORY;\n    }\n    buflen = ca_info_blob->len;\n    memcpy(certbuf, ca_info_blob->data, ca_info_blob->len);\n    certbuf[ca_info_blob->len]='\\0';\n  }\n  else if(cafile) {\n    if(read_cert(cafile, &certbuf, &buflen) < 0) {\n      failf(data, \"SSL: failed to read or invalid CA certificate\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    return CURLE_SSL_CACERT_BADFILE;\n\n  result = verify_cert_buf(data, certbuf, buflen, ctx);\n  free(certbuf);\n  return result;\n}\n\n\n#ifdef SECTRANSP_PINNEDPUBKEY\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    SSLContextRef ctx,\n                                    const char *pinnedpubkey)\n{  /* Scratch */\n  size_t pubkeylen, realpubkeylen, spkiHeaderLength = 24;\n  unsigned char *pubkey = NULL, *realpubkey = NULL;\n  const unsigned char *spkiHeader = NULL;\n  CFDataRef publicKeyBits = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n\n  if(!ctx)\n    return result;\n\n  do {\n    SecTrustRef trust;\n    OSStatus ret = SSLCopyPeerTrust(ctx, &trust);\n    if(ret != noErr || !trust)\n      break;\n\n    SecKeyRef keyRef = SecTrustCopyPublicKey(trust);\n    CFRelease(trust);\n    if(!keyRef)\n      break;\n\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n\n    publicKeyBits = SecKeyCopyExternalRepresentation(keyRef, NULL);\n    CFRelease(keyRef);\n    if(!publicKeyBits)\n      break;\n\n#elif SECTRANSP_PINNEDPUBKEY_V2\n\n    OSStatus success = SecItemExport(keyRef, kSecFormatOpenSSL, 0, NULL,\n                                     &publicKeyBits);\n    CFRelease(keyRef);\n    if(success != errSecSuccess || !publicKeyBits)\n      break;\n\n#endif /* SECTRANSP_PINNEDPUBKEY_V2 */\n\n    pubkeylen = CFDataGetLength(publicKeyBits);\n    pubkey = (unsigned char *)CFDataGetBytePtr(publicKeyBits);\n\n    switch(pubkeylen) {\n      case 526:\n        /* 4096 bit RSA pubkeylen == 526 */\n        spkiHeader = rsa4096SpkiHeader;\n        break;\n      case 270:\n        /* 2048 bit RSA pubkeylen == 270 */\n        spkiHeader = rsa2048SpkiHeader;\n        break;\n#ifdef SECTRANSP_PINNEDPUBKEY_V1\n      case 65:\n        /* ecDSA secp256r1 pubkeylen == 65 */\n        spkiHeader = ecDsaSecp256r1SpkiHeader;\n        spkiHeaderLength = 26;\n        break;\n      case 97:\n        /* ecDSA secp384r1 pubkeylen == 97 */\n        spkiHeader = ecDsaSecp384r1SpkiHeader;\n        spkiHeaderLength = 23;\n        break;\n      default:\n        infof(data, \"SSL: unhandled public key length: %d\\n\", pubkeylen);\n#elif SECTRANSP_PINNEDPUBKEY_V2\n      default:\n        /* ecDSA secp256r1 pubkeylen == 91 header already included?\n         * ecDSA secp384r1 header already included too\n         * we assume rest of algorithms do same, so do nothing\n         */\n        result = Curl_pin_peer_pubkey(data, pinnedpubkey, pubkey,\n                                    pubkeylen);\n#endif /* SECTRANSP_PINNEDPUBKEY_V2 */\n        continue; /* break from loop */\n    }\n\n    realpubkeylen = pubkeylen + spkiHeaderLength;\n    realpubkey = malloc(realpubkeylen);\n    if(!realpubkey)\n      break;\n\n    memcpy(realpubkey, spkiHeader, spkiHeaderLength);\n    memcpy(realpubkey + spkiHeaderLength, pubkey, pubkeylen);\n\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, realpubkey,\n                                  realpubkeylen);\n\n  } while(0);\n\n  Curl_safefree(realpubkey);\n  if(publicKeyBits != NULL)\n    CFRelease(publicKeyBits);\n\n  return result;\n}\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\nstatic CURLcode\nsectransp_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  SSLCipherSuite cipher;\n  SSLProtocol protocol = 0;\n  const char * const hostname = SSL_HOST_NAME();\n\n  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state\n              || ssl_connect_2_reading == connssl->connecting_state\n              || ssl_connect_2_writing == connssl->connecting_state);\n\n  /* Here goes nothing: */\n  err = SSLHandshake(backend->ssl_ctx);\n\n  if(err != noErr) {\n    switch(err) {\n      case errSSLWouldBlock:  /* they're not done with us yet */\n        connssl->connecting_state = backend->ssl_direction ?\n            ssl_connect_2_writing : ssl_connect_2_reading;\n        return CURLE_OK;\n\n      /* The below is errSSLServerAuthCompleted; it's not defined in\n        Leopard's headers */\n      case -9841:\n        if((SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) &&\n           SSL_CONN_CONFIG(verifypeer)) {\n          CURLcode result = verify_cert(data, SSL_CONN_CONFIG(CAfile),\n                                        SSL_CONN_CONFIG(ca_info_blob),\n                                        backend->ssl_ctx);\n          if(result)\n            return result;\n        }\n        /* the documentation says we need to call SSLHandshake() again */\n        return sectransp_connect_step2(data, conn, sockindex);\n\n      /* Problem with encrypt / decrypt */\n      case errSSLPeerDecodeError:\n        failf(data, \"Decode failed\");\n        break;\n      case errSSLDecryptionFail:\n      case errSSLPeerDecryptionFail:\n        failf(data, \"Decryption failed\");\n        break;\n      case errSSLPeerDecryptError:\n        failf(data, \"A decryption error occurred\");\n        break;\n      case errSSLBadCipherSuite:\n        failf(data, \"A bad SSL cipher suite was encountered\");\n        break;\n      case errSSLCrypto:\n        failf(data, \"An underlying cryptographic error was encountered\");\n        break;\n#if CURL_BUILD_MAC_10_11 || CURL_BUILD_IOS_9\n      case errSSLWeakPeerEphemeralDHKey:\n        failf(data, \"Indicates a weak ephemeral Diffie-Hellman key\");\n        break;\n#endif\n\n      /* Problem with the message record validation */\n      case errSSLBadRecordMac:\n      case errSSLPeerBadRecordMac:\n        failf(data, \"A record with a bad message authentication code (MAC) \"\n                    \"was encountered\");\n        break;\n      case errSSLRecordOverflow:\n      case errSSLPeerRecordOverflow:\n        failf(data, \"A record overflow occurred\");\n        break;\n\n      /* Problem with zlib decompression */\n      case errSSLPeerDecompressFail:\n        failf(data, \"Decompression failed\");\n        break;\n\n      /* Problem with access */\n      case errSSLPeerAccessDenied:\n        failf(data, \"Access was denied\");\n        break;\n      case errSSLPeerInsufficientSecurity:\n        failf(data, \"There is insufficient security for this operation\");\n        break;\n\n      /* These are all certificate problems with the server: */\n      case errSSLXCertChainInvalid:\n        failf(data, \"SSL certificate problem: Invalid certificate chain\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLUnknownRootCert:\n        failf(data, \"SSL certificate problem: Untrusted root certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLNoRootCert:\n        failf(data, \"SSL certificate problem: No root certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLCertNotYetValid:\n        failf(data, \"SSL certificate problem: The certificate chain had a \"\n                    \"certificate that is not yet valid\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLCertExpired:\n      case errSSLPeerCertExpired:\n        failf(data, \"SSL certificate problem: Certificate chain had an \"\n              \"expired certificate\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLBadCert:\n      case errSSLPeerBadCert:\n        failf(data, \"SSL certificate problem: Couldn't understand the server \"\n              \"certificate format\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerUnsupportedCert:\n        failf(data, \"SSL certificate problem: An unsupported certificate \"\n                    \"format was encountered\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerCertRevoked:\n        failf(data, \"SSL certificate problem: The certificate was revoked\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      case errSSLPeerCertUnknown:\n        failf(data, \"SSL certificate problem: The certificate is unknown\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n\n      /* These are all certificate problems with the client: */\n      case errSecAuthFailed:\n        failf(data, \"SSL authentication failed\");\n        break;\n      case errSSLPeerHandshakeFail:\n        failf(data, \"SSL peer handshake failed, the server most likely \"\n              \"requires a client certificate to connect\");\n        break;\n      case errSSLPeerUnknownCA:\n        failf(data, \"SSL server rejected the client certificate due to \"\n              \"the certificate being signed by an unknown certificate \"\n              \"authority\");\n        break;\n\n      /* This error is raised if the server's cert didn't match the server's\n         host name: */\n      case errSSLHostNameMismatch:\n        failf(data, \"SSL certificate peer verification failed, the \"\n              \"certificate did not match \\\"%s\\\"\\n\", conn->host.dispname);\n        return CURLE_PEER_FAILED_VERIFICATION;\n\n      /* Problem with SSL / TLS negotiation */\n      case errSSLNegotiation:\n        failf(data, \"Could not negotiate an SSL cipher suite with the server\");\n        break;\n      case errSSLBadConfiguration:\n        failf(data, \"A configuration error occurred\");\n        break;\n      case errSSLProtocol:\n        failf(data, \"SSL protocol error\");\n        break;\n      case errSSLPeerProtocolVersion:\n        failf(data, \"A bad protocol version was encountered\");\n        break;\n      case errSSLPeerNoRenegotiation:\n        failf(data, \"No renegotiation is allowed\");\n        break;\n\n      /* Generic handshake errors: */\n      case errSSLConnectionRefused:\n        failf(data, \"Server dropped the connection during the SSL handshake\");\n        break;\n      case errSSLClosedAbort:\n        failf(data, \"Server aborted the SSL handshake\");\n        break;\n      case errSSLClosedGraceful:\n        failf(data, \"The connection closed gracefully\");\n        break;\n      case errSSLClosedNoNotify:\n        failf(data, \"The server closed the session with no notification\");\n        break;\n      /* Sometimes paramErr happens with buggy ciphers: */\n      case paramErr:\n      case errSSLInternal:\n      case errSSLPeerInternalError:\n        failf(data, \"Internal SSL engine error encountered during the \"\n              \"SSL handshake\");\n        break;\n      case errSSLFatalAlert:\n        failf(data, \"Fatal SSL engine error encountered during the SSL \"\n              \"handshake\");\n        break;\n      /* Unclassified error */\n      case errSSLBufferOverflow:\n        failf(data, \"An insufficient buffer was provided\");\n        break;\n      case errSSLIllegalParam:\n        failf(data, \"An illegal parameter was encountered\");\n        break;\n      case errSSLModuleAttach:\n        failf(data, \"Module attach failure\");\n        break;\n      case errSSLSessionNotFound:\n        failf(data, \"An attempt to restore an unknown session failed\");\n        break;\n      case errSSLPeerExportRestriction:\n        failf(data, \"An export restriction occurred\");\n        break;\n      case errSSLPeerUserCancelled:\n        failf(data, \"The user canceled the operation\");\n        break;\n      case errSSLPeerUnexpectedMsg:\n        failf(data, \"Peer rejected unexpected message\");\n        break;\n#if CURL_BUILD_MAC_10_11 || CURL_BUILD_IOS_9\n      /* Treaing non-fatal error as fatal like before */\n      case errSSLClientHelloReceived:\n        failf(data, \"A non-fatal result for providing a server name \"\n                    \"indication\");\n        break;\n#endif\n\n      /* Error codes defined in the enum but should never be returned.\n         We list them here just in case. */\n#if CURL_BUILD_MAC_10_6\n      /* Only returned when kSSLSessionOptionBreakOnCertRequested is set */\n      case errSSLClientCertRequested:\n        failf(data, \"Server requested a client certificate during the \"\n              \"handshake\");\n        return CURLE_SSL_CLIENTCERT;\n#endif\n#if CURL_BUILD_MAC_10_9\n      /* Alias for errSSLLast, end of error range */\n      case errSSLUnexpectedRecord:\n        failf(data, \"Unexpected (skipped) record in DTLS\");\n        break;\n#endif\n      default:\n        /* May also return codes listed in Security Framework Result Codes */\n        failf(data, \"Unknown SSL protocol error in connection to %s:%d\",\n              hostname, err);\n        break;\n    }\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else {\n    /* we have been connected fine, we're not waiting for anything else. */\n    connssl->connecting_state = ssl_connect_3;\n\n#ifdef SECTRANSP_PINNEDPUBKEY\n    if(data->set.str[STRING_SSL_PINNEDPUBLICKEY]) {\n      CURLcode result =\n        pkp_pin_peer_pubkey(data, backend->ssl_ctx,\n                            data->set.str[STRING_SSL_PINNEDPUBLICKEY]);\n      if(result) {\n        failf(data, \"SSL: public key does not match pinned public key!\");\n        return result;\n      }\n    }\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n    /* Informational message */\n    (void)SSLGetNegotiatedCipher(backend->ssl_ctx, &cipher);\n    (void)SSLGetNegotiatedProtocolVersion(backend->ssl_ctx, &protocol);\n    switch(protocol) {\n      case kSSLProtocol2:\n        infof(data, \"SSL 2.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kSSLProtocol3:\n        infof(data, \"SSL 3.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kTLSProtocol1:\n        infof(data, \"TLS 1.0 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n      case kTLSProtocol11:\n        infof(data, \"TLS 1.1 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n      case kTLSProtocol12:\n        infof(data, \"TLS 1.2 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n#if CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11\n      case kTLSProtocol13:\n        infof(data, \"TLS 1.3 connection using %s\\n\",\n              TLSCipherNameForNumber(cipher));\n        break;\n#endif /* CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11 */\n      default:\n        infof(data, \"Unknown protocol connection\\n\");\n        break;\n    }\n\n#if(CURL_BUILD_MAC_10_13 || CURL_BUILD_IOS_11) && HAVE_BUILTIN_AVAILABLE == 1\n    if(conn->bits.tls_enable_alpn) {\n      if(__builtin_available(macOS 10.13.4, iOS 11, tvOS 11, *)) {\n        CFArrayRef alpnArr = NULL;\n        CFStringRef chosenProtocol = NULL;\n        err = SSLCopyALPNProtocols(backend->ssl_ctx, &alpnArr);\n\n        if(err == noErr && alpnArr && CFArrayGetCount(alpnArr) >= 1)\n          chosenProtocol = CFArrayGetValueAtIndex(alpnArr, 0);\n\n#ifdef USE_HTTP2\n        if(chosenProtocol &&\n           !CFStringCompare(chosenProtocol, CFSTR(ALPN_H2), 0)) {\n          conn->negnpn = CURL_HTTP_VERSION_2;\n        }\n        else\n#endif\n        if(chosenProtocol &&\n           !CFStringCompare(chosenProtocol, CFSTR(ALPN_HTTP_1_1), 0)) {\n          conn->negnpn = CURL_HTTP_VERSION_1_1;\n        }\n        else\n          infof(data, \"ALPN, server did not agree to a protocol\\n\");\n\n        Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                            BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n\n        /* chosenProtocol is a reference to the string within alpnArr\n           and doesn't need to be freed separately */\n        if(alpnArr)\n          CFRelease(alpnArr);\n      }\n    }\n#endif\n\n    return CURLE_OK;\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n/* This should be called during step3 of the connection at the earliest */\nstatic void\nshow_verbose_server_cert(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  CFArrayRef server_certs = NULL;\n  SecCertificateRef server_cert;\n  OSStatus err;\n  CFIndex i, count;\n  SecTrustRef trust = NULL;\n\n  if(!backend->ssl_ctx)\n    return;\n\n#if CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS\n#if CURL_BUILD_IOS\n#pragma unused(server_certs)\n  err = SSLCopyPeerTrust(backend->ssl_ctx, &trust);\n  /* For some reason, SSLCopyPeerTrust() can return noErr and yet return\n     a null trust, so be on guard for that: */\n  if(err == noErr && trust) {\n    count = SecTrustGetCertificateCount(trust);\n    for(i = 0L ; i < count ; i++) {\n      CURLcode result;\n      char *certp;\n      server_cert = SecTrustGetCertificateAtIndex(trust, i);\n      result = CopyCertSubject(data, server_cert, &certp);\n      if(!result) {\n        infof(data, \"Server certificate: %s\\n\", certp);\n        free(certp);\n      }\n    }\n    CFRelease(trust);\n  }\n#else\n  /* SSLCopyPeerCertificates() is deprecated as of Mountain Lion.\n     The function SecTrustGetCertificateAtIndex() is officially present\n     in Lion, but it is unfortunately also present in Snow Leopard as\n     private API and doesn't work as expected. So we have to look for\n     a different symbol to make sure this code is only executed under\n     Lion or later. */\n  if(SecTrustEvaluateAsync != NULL) {\n#pragma unused(server_certs)\n    err = SSLCopyPeerTrust(backend->ssl_ctx, &trust);\n    /* For some reason, SSLCopyPeerTrust() can return noErr and yet return\n       a null trust, so be on guard for that: */\n    if(err == noErr && trust) {\n      count = SecTrustGetCertificateCount(trust);\n      for(i = 0L ; i < count ; i++) {\n        char *certp;\n        CURLcode result;\n        server_cert = SecTrustGetCertificateAtIndex(trust, i);\n        result = CopyCertSubject(data, server_cert, &certp);\n        if(!result) {\n          infof(data, \"Server certificate: %s\\n\", certp);\n          free(certp);\n        }\n      }\n      CFRelease(trust);\n    }\n  }\n  else {\n#if CURL_SUPPORT_MAC_10_8\n    err = SSLCopyPeerCertificates(backend->ssl_ctx, &server_certs);\n    /* Just in case SSLCopyPeerCertificates() returns null too... */\n    if(err == noErr && server_certs) {\n      count = CFArrayGetCount(server_certs);\n      for(i = 0L ; i < count ; i++) {\n        char *certp;\n        CURLcode result;\n        server_cert = (SecCertificateRef)CFArrayGetValueAtIndex(server_certs,\n                                                                i);\n        result = CopyCertSubject(data, server_cert, &certp);\n        if(!result) {\n          infof(data, \"Server certificate: %s\\n\", certp);\n          free(certp);\n        }\n      }\n      CFRelease(server_certs);\n    }\n#endif /* CURL_SUPPORT_MAC_10_8 */\n  }\n#endif /* CURL_BUILD_IOS */\n#else\n#pragma unused(trust)\n  err = SSLCopyPeerCertificates(backend->ssl_ctx, &server_certs);\n  if(err == noErr) {\n    count = CFArrayGetCount(server_certs);\n    for(i = 0L ; i < count ; i++) {\n      CURLcode result;\n      char *certp;\n      server_cert = (SecCertificateRef)CFArrayGetValueAtIndex(server_certs, i);\n      result = CopyCertSubject(data, server_cert, &certp);\n      if(!result) {\n        infof(data, \"Server certificate: %s\\n\", certp);\n        free(certp);\n      }\n    }\n    CFRelease(server_certs);\n  }\n#endif /* CURL_BUILD_MAC_10_7 || CURL_BUILD_IOS */\n}\n#endif /* !CURL_DISABLE_VERBOSE_STRINGS */\n\nstatic CURLcode\nsectransp_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                        int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\n  /* There is no step 3!\n   * Well, okay, if verbose mode is on, let's print the details of the\n   * server certificates. */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  if(data->set.verbose)\n    show_verbose_server_cert(data, conn, sockindex);\n#endif\n\n  connssl->connecting_state = ssl_connect_done;\n  return CURLE_OK;\n}\n\nstatic Curl_recv sectransp_recv;\nstatic Curl_send sectransp_send;\n\nstatic CURLcode\nsectransp_connect_common(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         int sockindex,\n                         bool nonblocking,\n                         bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = sectransp_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading ||\n       connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n      connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if this\n     * connection is done nonblocking and this loop would execute again. This\n     * permits the owner of a multi handle to abort a connection attempt\n     * before step2 has completed while ensuring that a client using select()\n     * or epoll() will always have a valid fdset to wait on.\n     */\n    result = sectransp_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n\n  } /* repeat step2 until all transactions are done. */\n\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = sectransp_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = sectransp_recv;\n    conn->send[sockindex] = sectransp_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_connect_nonblocking(struct Curl_easy *data,\n                                              struct connectdata *conn,\n                                              int sockindex, bool *done)\n{\n  return sectransp_connect_common(data, conn, sockindex, TRUE, done);\n}\n\nstatic CURLcode sectransp_connect(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = sectransp_connect_common(data, conn, sockindex, FALSE, &done);\n\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic void sectransp_close(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->ssl_ctx) {\n    (void)SSLClose(backend->ssl_ctx);\n#if CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS\n    if(SSLCreateContext != NULL)\n      CFRelease(backend->ssl_ctx);\n#if CURL_SUPPORT_MAC_10_8\n    else\n      (void)SSLDisposeContext(backend->ssl_ctx);\n#endif  /* CURL_SUPPORT_MAC_10_8 */\n#else\n    (void)SSLDisposeContext(backend->ssl_ctx);\n#endif /* CURL_BUILD_MAC_10_8 || CURL_BUILD_IOS */\n    backend->ssl_ctx = NULL;\n  }\n  backend->ssl_sockfd = 0;\n}\n\nstatic int sectransp_shutdown(struct Curl_easy *data,\n                              struct connectdata *conn, int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  ssize_t nread;\n  int what;\n  int rc;\n  char buf[120];\n\n  if(!backend->ssl_ctx)\n    return 0;\n\n#ifndef CURL_DISABLE_FTP\n  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)\n    return 0;\n#endif\n\n  sectransp_close(data, conn, sockindex);\n\n  rc = 0;\n\n  what = SOCKET_READABLE(conn->sock[sockindex], SSL_SHUTDOWN_TIMEOUT);\n\n  for(;;) {\n    if(what < 0) {\n      /* anything that gets here is fatally bad */\n      failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n      rc = -1;\n      break;\n    }\n\n    if(!what) {                                /* timeout */\n      failf(data, \"SSL shutdown timeout\");\n      break;\n    }\n\n    /* Something to read, let's do it and hope that it is the close\n     notify alert from the server. No way to SSL_Read now, so use read(). */\n\n    nread = read(conn->sock[sockindex], buf, sizeof(buf));\n\n    if(nread < 0) {\n      failf(data, \"read: %s\", strerror(errno));\n      rc = -1;\n    }\n\n    if(nread <= 0)\n      break;\n\n    what = SOCKET_READABLE(conn->sock[sockindex], 0);\n  }\n\n  return rc;\n}\n\nstatic void sectransp_session_free(void *ptr)\n{\n  /* ST, as of iOS 5 and Mountain Lion, has no public method of deleting a\n     cached session ID inside the Security framework. There is a private\n     function that does this, but I don't want to have to explain to you why I\n     got your application rejected from the App Store due to the use of a\n     private API, so the best we can do is free up our own char array that we\n     created way back in sectransp_connect_step1... */\n  Curl_safefree(ptr);\n}\n\nstatic size_t sectransp_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"SecureTransport\");\n}\n\n/*\n * This function uses SSLGetSessionState to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nstatic int sectransp_check_cxn(struct connectdata *conn)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  SSLSessionState state;\n\n  if(backend->ssl_ctx) {\n    err = SSLGetSessionState(backend->ssl_ctx, &state);\n    if(err == noErr)\n      return state == kSSLConnected || state == kSSLHandshake;\n    return -1;\n  }\n  return 0;\n}\n\nstatic bool sectransp_data_pending(const struct connectdata *conn,\n                                   int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  OSStatus err;\n  size_t buffer;\n\n  if(backend->ssl_ctx) {  /* SSL is in use */\n    err = SSLGetBufferedReadSize(backend->ssl_ctx, &buffer);\n    if(err == noErr)\n      return buffer > 0UL;\n    return false;\n  }\n  else\n    return false;\n}\n\nstatic CURLcode sectransp_random(struct Curl_easy *data UNUSED_PARAM,\n                                 unsigned char *entropy, size_t length)\n{\n  /* arc4random_buf() isn't available on cats older than Lion, so let's\n     do this manually for the benefit of the older cats. */\n  size_t i;\n  u_int32_t random_number = 0;\n\n  (void)data;\n\n  for(i = 0 ; i < length ; i++) {\n    if(i % sizeof(u_int32_t) == 0)\n      random_number = arc4random();\n    entropy[i] = random_number & 0xFF;\n    random_number >>= 8;\n  }\n  i = random_number = 0;\n  return CURLE_OK;\n}\n\nstatic CURLcode sectransp_sha256sum(const unsigned char *tmp, /* input */\n                                    size_t tmplen,\n                                    unsigned char *sha256sum, /* output */\n                                    size_t sha256len)\n{\n  assert(sha256len >= CURL_SHA256_DIGEST_LENGTH);\n  (void)CC_SHA256(tmp, (CC_LONG)tmplen, sha256sum);\n  return CURLE_OK;\n}\n\nstatic bool sectransp_false_start(void)\n{\n#if CURL_BUILD_MAC_10_9 || CURL_BUILD_IOS_7\n  if(SSLSetSessionOption != NULL)\n    return TRUE;\n#endif\n  return FALSE;\n}\n\nstatic ssize_t sectransp_send(struct Curl_easy *data,\n                              int sockindex,\n                              const void *mem,\n                              size_t len,\n                              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  size_t processed = 0UL;\n  OSStatus err;\n\n  /* The SSLWrite() function works a little differently than expected. The\n     fourth argument (processed) is currently documented in Apple's\n     documentation as: \"On return, the length, in bytes, of the data actually\n     written.\"\n\n     Now, one could interpret that as \"written to the socket,\" but actually,\n     it returns the amount of data that was written to a buffer internal to\n     the SSLContextRef instead. So it's possible for SSLWrite() to return\n     errSSLWouldBlock and a number of bytes \"written\" because those bytes were\n     encrypted and written to a buffer, not to the socket.\n\n     So if this happens, then we need to keep calling SSLWrite() over and\n     over again with no new data until it quits returning errSSLWouldBlock. */\n\n  /* Do we have buffered data to write from the last time we were called? */\n  if(backend->ssl_write_buffered_length) {\n    /* Write the buffered data: */\n    err = SSLWrite(backend->ssl_ctx, NULL, 0UL, &processed);\n    switch(err) {\n      case noErr:\n        /* processed is always going to be 0 because we didn't write to\n           the buffer, so return how much was written to the socket */\n        processed = backend->ssl_write_buffered_length;\n        backend->ssl_write_buffered_length = 0UL;\n        break;\n      case errSSLWouldBlock: /* argh, try again */\n        *curlcode = CURLE_AGAIN;\n        return -1L;\n      default:\n        failf(data, \"SSLWrite() returned error %d\", err);\n        *curlcode = CURLE_SEND_ERROR;\n        return -1L;\n    }\n  }\n  else {\n    /* We've got new data to write: */\n    err = SSLWrite(backend->ssl_ctx, mem, len, &processed);\n    if(err != noErr) {\n      switch(err) {\n        case errSSLWouldBlock:\n          /* Data was buffered but not sent, we have to tell the caller\n             to try sending again, and remember how much was buffered */\n          backend->ssl_write_buffered_length = len;\n          *curlcode = CURLE_AGAIN;\n          return -1L;\n        default:\n          failf(data, \"SSLWrite() returned error %d\", err);\n          *curlcode = CURLE_SEND_ERROR;\n          return -1L;\n      }\n    }\n  }\n  return (ssize_t)processed;\n}\n\nstatic ssize_t sectransp_recv(struct Curl_easy *data,\n                              int num,\n                              char *buf,\n                              size_t buffersize,\n                              CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  size_t processed = 0UL;\n  OSStatus err;\n\n  again:\n  err = SSLRead(backend->ssl_ctx, buf, buffersize, &processed);\n\n  if(err != noErr) {\n    switch(err) {\n      case errSSLWouldBlock:  /* return how much we read (if anything) */\n        if(processed)\n          return (ssize_t)processed;\n        *curlcode = CURLE_AGAIN;\n        return -1L;\n        break;\n\n      /* errSSLClosedGraceful - server gracefully shut down the SSL session\n         errSSLClosedNoNotify - server hung up on us instead of sending a\n           closure alert notice, read() is returning 0\n         Either way, inform the caller that the server disconnected. */\n      case errSSLClosedGraceful:\n      case errSSLClosedNoNotify:\n        *curlcode = CURLE_OK;\n        return -1L;\n        break;\n\n        /* The below is errSSLPeerAuthCompleted; it's not defined in\n           Leopard's headers */\n      case -9841:\n        if((SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) &&\n           SSL_CONN_CONFIG(verifypeer)) {\n          CURLcode result = verify_cert(data, SSL_CONN_CONFIG(CAfile),\n                                        SSL_CONN_CONFIG(ca_info_blob),\n                                        backend->ssl_ctx);\n          if(result)\n            return result;\n        }\n        goto again;\n      default:\n        failf(data, \"SSLRead() return error %d\", err);\n        *curlcode = CURLE_RECV_ERROR;\n        return -1L;\n        break;\n    }\n  }\n  return (ssize_t)processed;\n}\n\nstatic void *sectransp_get_internals(struct ssl_connect_data *connssl,\n                                     CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->ssl_ctx;\n}\n\nconst struct Curl_ssl Curl_ssl_sectransp = {\n  { CURLSSLBACKEND_SECURETRANSPORT, \"secure-transport\" }, /* info */\n\n  SSLSUPP_CAINFO_BLOB |\n#ifdef SECTRANSP_PINNEDPUBKEY\n  SSLSUPP_PINNEDPUBKEY,\n#else\n  0,\n#endif /* SECTRANSP_PINNEDPUBKEY */\n\n  sizeof(struct ssl_backend_data),\n\n  Curl_none_init,                     /* init */\n  Curl_none_cleanup,                  /* cleanup */\n  sectransp_version,                  /* version */\n  sectransp_check_cxn,                /* check_cxn */\n  sectransp_shutdown,                 /* shutdown */\n  sectransp_data_pending,             /* data_pending */\n  sectransp_random,                   /* random */\n  Curl_none_cert_status_request,      /* cert_status_request */\n  sectransp_connect,                  /* connect */\n  sectransp_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_getsock,                   /* getsock */\n  sectransp_get_internals,            /* get_internals */\n  sectransp_close,                    /* close_one */\n  Curl_none_close_all,                /* close_all */\n  sectransp_session_free,             /* session_free */\n  Curl_none_set_engine,               /* set_engine */\n  Curl_none_set_engine_default,       /* set_engine_default */\n  Curl_none_engines_list,             /* engines_list */\n  sectransp_false_start,              /* false_start */\n  sectransp_sha256sum                 /* sha256sum */\n  NULL,                               /* associate_connection */\n  NULL                                /* disassociate_connection */\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif /* USE_SECTRANSP */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/* This file is for implementing all \"generic\" SSL functions that all libcurl\n   internals should use. It is then responsible for calling the proper\n   \"backend\" function.\n\n   SSL-functions in libcurl should call functions in this source file, and not\n   to any specific SSL-layer.\n\n   Curl_ssl_ - prefix for generic ones\n\n   Note that this source code uses the functions of the configured SSL\n   backend via the global Curl_ssl instance.\n\n   \"SSL/TLS Strong Encryption: An Introduction\"\n   https://httpd.apache.org/docs/2.0/ssl/ssl_intro.html\n*/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#include \"urldata.h\"\n\n#include \"vtls.h\" /* generic SSL protos etc */\n#include \"slist.h\"\n#include \"sendf.h\"\n#include \"strcase.h\"\n#include \"url.h\"\n#include \"progress.h\"\n#include \"share.h\"\n#include \"multiif.h\"\n#include \"timeval.h\"\n#include \"curl_md5.h\"\n#include \"warnless.h\"\n#include \"curl_base64.h\"\n#include \"curl_printf.h\"\n#include \"strdup.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* convenience macro to check if this handle is using a shared SSL session */\n#define SSLSESSION_SHARED(data) (data->share &&                        \\\n                                 (data->share->specifier &             \\\n                                  (1<<CURL_LOCK_DATA_SSL_SESSION)))\n\n#define CLONE_STRING(var)                    \\\n  do {                                       \\\n    if(source->var) {                        \\\n      dest->var = strdup(source->var);       \\\n      if(!dest->var)                         \\\n        return FALSE;                        \\\n    }                                        \\\n    else                                     \\\n      dest->var = NULL;                      \\\n  } while(0)\n\n#define CLONE_BLOB(var)                        \\\n  do {                                         \\\n    if(blobdup(&dest->var, source->var))       \\\n      return FALSE;                            \\\n  } while(0)\n\nstatic CURLcode blobdup(struct curl_blob **dest,\n                        struct curl_blob *src)\n{\n  DEBUGASSERT(dest);\n  DEBUGASSERT(!*dest);\n  if(src) {\n    /* only if there's data to dupe! */\n    struct curl_blob *d;\n    d = malloc(sizeof(struct curl_blob) + src->len);\n    if(!d)\n      return CURLE_OUT_OF_MEMORY;\n    d->len = src->len;\n    /* Always duplicate because the connection may survive longer than the\n       handle that passed in the blob. */\n    d->flags = CURL_BLOB_COPY;\n    d->data = (void *)((char *)d + sizeof(struct curl_blob));\n    memcpy(d->data, src->data, src->len);\n    *dest = d;\n  }\n  return CURLE_OK;\n}\n\n/* returns TRUE if the blobs are identical */\nstatic bool blobcmp(struct curl_blob *first, struct curl_blob *second)\n{\n  if(!first && !second) /* both are NULL */\n    return TRUE;\n  if(!first || !second) /* one is NULL */\n    return FALSE;\n  if(first->len != second->len) /* different sizes */\n    return FALSE;\n  return !memcmp(first->data, second->data, first->len); /* same data */\n}\n\nbool\nCurl_ssl_config_matches(struct ssl_primary_config *data,\n                        struct ssl_primary_config *needle)\n{\n  if((data->version == needle->version) &&\n     (data->version_max == needle->version_max) &&\n     (data->verifypeer == needle->verifypeer) &&\n     (data->verifyhost == needle->verifyhost) &&\n     (data->verifystatus == needle->verifystatus) &&\n     blobcmp(data->cert_blob, needle->cert_blob) &&\n     blobcmp(data->ca_info_blob, needle->ca_info_blob) &&\n     Curl_safe_strcasecompare(data->CApath, needle->CApath) &&\n     Curl_safe_strcasecompare(data->CAfile, needle->CAfile) &&\n     Curl_safe_strcasecompare(data->clientcert, needle->clientcert) &&\n     Curl_safe_strcasecompare(data->random_file, needle->random_file) &&\n     Curl_safe_strcasecompare(data->egdsocket, needle->egdsocket) &&\n     Curl_safe_strcasecompare(data->cipher_list, needle->cipher_list) &&\n     Curl_safe_strcasecompare(data->cipher_list13, needle->cipher_list13) &&\n     Curl_safe_strcasecompare(data->curves, needle->curves) &&\n     Curl_safe_strcasecompare(data->pinned_key, needle->pinned_key))\n    return TRUE;\n\n  return FALSE;\n}\n\nbool\nCurl_clone_primary_ssl_config(struct ssl_primary_config *source,\n                              struct ssl_primary_config *dest)\n{\n  dest->version = source->version;\n  dest->version_max = source->version_max;\n  dest->verifypeer = source->verifypeer;\n  dest->verifyhost = source->verifyhost;\n  dest->verifystatus = source->verifystatus;\n  dest->sessionid = source->sessionid;\n\n  CLONE_BLOB(cert_blob);\n  CLONE_BLOB(ca_info_blob);\n  CLONE_STRING(CApath);\n  CLONE_STRING(CAfile);\n  CLONE_STRING(clientcert);\n  CLONE_STRING(random_file);\n  CLONE_STRING(egdsocket);\n  CLONE_STRING(cipher_list);\n  CLONE_STRING(cipher_list13);\n  CLONE_STRING(pinned_key);\n  CLONE_STRING(curves);\n\n  return TRUE;\n}\n\nvoid Curl_free_primary_ssl_config(struct ssl_primary_config *sslc)\n{\n  Curl_safefree(sslc->CApath);\n  Curl_safefree(sslc->CAfile);\n  Curl_safefree(sslc->clientcert);\n  Curl_safefree(sslc->random_file);\n  Curl_safefree(sslc->egdsocket);\n  Curl_safefree(sslc->cipher_list);\n  Curl_safefree(sslc->cipher_list13);\n  Curl_safefree(sslc->pinned_key);\n  Curl_safefree(sslc->cert_blob);\n  Curl_safefree(sslc->ca_info_blob);\n  Curl_safefree(sslc->curves);\n}\n\n#ifdef USE_SSL\nstatic int multissl_setup(const struct Curl_ssl *backend);\n#endif\n\nint Curl_ssl_backend(void)\n{\n#ifdef USE_SSL\n  multissl_setup(NULL);\n  return Curl_ssl->info.id;\n#else\n  return (int)CURLSSLBACKEND_NONE;\n#endif\n}\n\n#ifdef USE_SSL\n\n/* \"global\" init done? */\nstatic bool init_ssl = FALSE;\n\n/**\n * Global SSL init\n *\n * @retval 0 error initializing SSL\n * @retval 1 SSL initialized successfully\n */\nint Curl_ssl_init(void)\n{\n  /* make sure this is only done once */\n  if(init_ssl)\n    return 1;\n  init_ssl = TRUE; /* never again */\n\n  return Curl_ssl->init();\n}\n\n#if defined(CURL_WITH_MULTI_SSL)\nstatic const struct Curl_ssl Curl_ssl_multi;\n#endif\n\n/* Global cleanup */\nvoid Curl_ssl_cleanup(void)\n{\n  if(init_ssl) {\n    /* only cleanup if we did a previous init */\n    Curl_ssl->cleanup();\n#if defined(CURL_WITH_MULTI_SSL)\n    Curl_ssl = &Curl_ssl_multi;\n#endif\n    init_ssl = FALSE;\n  }\n}\n\nstatic bool ssl_prefs_check(struct Curl_easy *data)\n{\n  /* check for CURLOPT_SSLVERSION invalid parameter value */\n  const long sslver = data->set.ssl.primary.version;\n  if((sslver < 0) || (sslver >= CURL_SSLVERSION_LAST)) {\n    failf(data, \"Unrecognized parameter value passed via CURLOPT_SSLVERSION\");\n    return FALSE;\n  }\n\n  switch(data->set.ssl.primary.version_max) {\n  case CURL_SSLVERSION_MAX_NONE:\n  case CURL_SSLVERSION_MAX_DEFAULT:\n    break;\n\n  default:\n    if((data->set.ssl.primary.version_max >> 16) < sslver) {\n      failf(data, \"CURL_SSLVERSION_MAX incompatible with CURL_SSLVERSION\");\n      return FALSE;\n    }\n  }\n\n  return TRUE;\n}\n\n#ifndef CURL_DISABLE_PROXY\nstatic CURLcode\nssl_connect_init_proxy(struct connectdata *conn, int sockindex)\n{\n  DEBUGASSERT(conn->bits.proxy_ssl_connected[sockindex]);\n  if(ssl_connection_complete == conn->ssl[sockindex].state &&\n     !conn->proxy_ssl[sockindex].use) {\n    struct ssl_backend_data *pbdata;\n\n    if(!(Curl_ssl->supports & SSLSUPP_HTTPS_PROXY))\n      return CURLE_NOT_BUILT_IN;\n\n    /* The pointers to the ssl backend data, which is opaque here, are swapped\n       rather than move the contents. */\n    pbdata = conn->proxy_ssl[sockindex].backend;\n    conn->proxy_ssl[sockindex] = conn->ssl[sockindex];\n\n    memset(&conn->ssl[sockindex], 0, sizeof(conn->ssl[sockindex]));\n    memset(pbdata, 0, Curl_ssl->sizeof_ssl_backend_data);\n\n    conn->ssl[sockindex].backend = pbdata;\n  }\n  return CURLE_OK;\n}\n#endif\n\nCURLcode\nCurl_ssl_connect(struct Curl_easy *data, struct connectdata *conn,\n                 int sockindex)\n{\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_ssl_connected[sockindex]) {\n    result = ssl_connect_init_proxy(conn, sockindex);\n    if(result)\n      return result;\n  }\n#endif\n\n  if(!ssl_prefs_check(data))\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* mark this is being ssl-enabled from here on. */\n  conn->ssl[sockindex].use = TRUE;\n  conn->ssl[sockindex].state = ssl_connection_negotiating;\n\n  result = Curl_ssl->connect_blocking(data, conn, sockindex);\n\n  if(!result)\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSL is connected */\n  else\n    conn->ssl[sockindex].use = FALSE;\n\n  return result;\n}\n\nCURLcode\nCurl_ssl_connect_nonblocking(struct Curl_easy *data, struct connectdata *conn,\n                             int sockindex, bool *done)\n{\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_ssl_connected[sockindex]) {\n    result = ssl_connect_init_proxy(conn, sockindex);\n    if(result)\n      return result;\n  }\n#endif\n  if(!ssl_prefs_check(data))\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* mark this is being ssl requested from here on. */\n  conn->ssl[sockindex].use = TRUE;\n  result = Curl_ssl->connect_nonblocking(data, conn, sockindex, done);\n  if(result)\n    conn->ssl[sockindex].use = FALSE;\n  else if(*done)\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSL is connected */\n  return result;\n}\n\n/*\n * Lock shared SSL session data\n */\nvoid Curl_ssl_sessionid_lock(struct Curl_easy *data)\n{\n  if(SSLSESSION_SHARED(data))\n    Curl_share_lock(data, CURL_LOCK_DATA_SSL_SESSION, CURL_LOCK_ACCESS_SINGLE);\n}\n\n/*\n * Unlock shared SSL session data\n */\nvoid Curl_ssl_sessionid_unlock(struct Curl_easy *data)\n{\n  if(SSLSESSION_SHARED(data))\n    Curl_share_unlock(data, CURL_LOCK_DATA_SSL_SESSION);\n}\n\n/*\n * Check if there's a session ID for the given connection in the cache, and if\n * there's one suitable, it is provided. Returns TRUE when no entry matched.\n */\nbool Curl_ssl_getsessionid(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           const bool isProxy,\n                           void **ssl_sessionid,\n                           size_t *idsize, /* set 0 if unknown */\n                           int sockindex)\n{\n  struct Curl_ssl_session *check;\n  size_t i;\n  long *general_age;\n  bool no_match = TRUE;\n\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config * const ssl_config = isProxy ?\n    &conn->proxy_ssl_config :\n    &conn->ssl_config;\n  const char * const name = isProxy ?\n    conn->http_proxy.host.name : conn->host.name;\n  int port = isProxy ? (int)conn->port : conn->remote_port;\n#else\n  /* no proxy support */\n  struct ssl_primary_config * const ssl_config = &conn->ssl_config;\n  const char * const name = conn->host.name;\n  int port = conn->remote_port;\n#endif\n  (void)sockindex;\n  *ssl_sessionid = NULL;\n\n#ifdef CURL_DISABLE_PROXY\n  if(isProxy)\n    return TRUE;\n#endif\n\n  DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n\n  if(!SSL_SET_OPTION(primary.sessionid))\n    /* session ID re-use is disabled */\n    return TRUE;\n\n  /* Lock if shared */\n  if(SSLSESSION_SHARED(data))\n    general_age = &data->share->sessionage;\n  else\n    general_age = &data->state.sessionage;\n\n  for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++) {\n    check = &data->state.session[i];\n    if(!check->sessionid)\n      /* not session ID means blank entry */\n      continue;\n    if(strcasecompare(name, check->name) &&\n       ((!conn->bits.conn_to_host && !check->conn_to_host) ||\n        (conn->bits.conn_to_host && check->conn_to_host &&\n         strcasecompare(conn->conn_to_host.name, check->conn_to_host))) &&\n       ((!conn->bits.conn_to_port && check->conn_to_port == -1) ||\n        (conn->bits.conn_to_port && check->conn_to_port != -1 &&\n         conn->conn_to_port == check->conn_to_port)) &&\n       (port == check->remote_port) &&\n       strcasecompare(conn->handler->scheme, check->scheme) &&\n       Curl_ssl_config_matches(ssl_config, &check->ssl_config)) {\n      /* yes, we have a session ID! */\n      (*general_age)++;          /* increase general age */\n      check->age = *general_age; /* set this as used in this age */\n      *ssl_sessionid = check->sessionid;\n      if(idsize)\n        *idsize = check->idsize;\n      no_match = FALSE;\n      break;\n    }\n  }\n\n  return no_match;\n}\n\n/*\n * Kill a single session ID entry in the cache.\n */\nvoid Curl_ssl_kill_session(struct Curl_ssl_session *session)\n{\n  if(session->sessionid) {\n    /* defensive check */\n\n    /* free the ID the SSL-layer specific way */\n    Curl_ssl->session_free(session->sessionid);\n\n    session->sessionid = NULL;\n    session->age = 0; /* fresh */\n\n    Curl_free_primary_ssl_config(&session->ssl_config);\n\n    Curl_safefree(session->name);\n    Curl_safefree(session->conn_to_host);\n  }\n}\n\n/*\n * Delete the given session ID from the cache.\n */\nvoid Curl_ssl_delsessionid(struct Curl_easy *data, void *ssl_sessionid)\n{\n  size_t i;\n\n  for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++) {\n    struct Curl_ssl_session *check = &data->state.session[i];\n\n    if(check->sessionid == ssl_sessionid) {\n      Curl_ssl_kill_session(check);\n      break;\n    }\n  }\n}\n\n/*\n * Store session id in the session cache. The ID passed on to this function\n * must already have been extracted and allocated the proper way for the SSL\n * layer. Curl_XXXX_session_free() will be called to free/kill the session ID\n * later on.\n */\nCURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool isProxy,\n                               void *ssl_sessionid,\n                               size_t idsize,\n                               int sockindex)\n{\n  size_t i;\n  struct Curl_ssl_session *store = &data->state.session[0];\n  long oldest_age = data->state.session[0].age; /* zero if unused */\n  char *clone_host;\n  char *clone_conn_to_host;\n  int conn_to_port;\n  long *general_age;\n#ifndef CURL_DISABLE_PROXY\n  struct ssl_primary_config * const ssl_config = isProxy ?\n    &conn->proxy_ssl_config :\n    &conn->ssl_config;\n  const char *hostname = isProxy ? conn->http_proxy.host.name :\n    conn->host.name;\n#else\n  struct ssl_primary_config * const ssl_config = &conn->ssl_config;\n  const char *hostname = conn->host.name;\n#endif\n  (void)sockindex;\n  DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n\n  clone_host = strdup(hostname);\n  if(!clone_host)\n    return CURLE_OUT_OF_MEMORY; /* bail out */\n\n  if(conn->bits.conn_to_host) {\n    clone_conn_to_host = strdup(conn->conn_to_host.name);\n    if(!clone_conn_to_host) {\n      free(clone_host);\n      return CURLE_OUT_OF_MEMORY; /* bail out */\n    }\n  }\n  else\n    clone_conn_to_host = NULL;\n\n  if(conn->bits.conn_to_port)\n    conn_to_port = conn->conn_to_port;\n  else\n    conn_to_port = -1;\n\n  /* Now we should add the session ID and the host name to the cache, (remove\n     the oldest if necessary) */\n\n  /* If using shared SSL session, lock! */\n  if(SSLSESSION_SHARED(data)) {\n    general_age = &data->share->sessionage;\n  }\n  else {\n    general_age = &data->state.sessionage;\n  }\n\n  /* find an empty slot for us, or find the oldest */\n  for(i = 1; (i < data->set.general_ssl.max_ssl_sessions) &&\n        data->state.session[i].sessionid; i++) {\n    if(data->state.session[i].age < oldest_age) {\n      oldest_age = data->state.session[i].age;\n      store = &data->state.session[i];\n    }\n  }\n  if(i == data->set.general_ssl.max_ssl_sessions)\n    /* cache is full, we must \"kill\" the oldest entry! */\n    Curl_ssl_kill_session(store);\n  else\n    store = &data->state.session[i]; /* use this slot */\n\n  /* now init the session struct wisely */\n  store->sessionid = ssl_sessionid;\n  store->idsize = idsize;\n  store->age = *general_age;    /* set current age */\n  /* free it if there's one already present */\n  free(store->name);\n  free(store->conn_to_host);\n  store->name = clone_host;               /* clone host name */\n  store->conn_to_host = clone_conn_to_host; /* clone connect to host name */\n  store->conn_to_port = conn_to_port; /* connect to port number */\n  /* port number */\n  store->remote_port = isProxy ? (int)conn->port : conn->remote_port;\n  store->scheme = conn->handler->scheme;\n\n  if(!Curl_clone_primary_ssl_config(ssl_config, &store->ssl_config)) {\n    Curl_free_primary_ssl_config(&store->ssl_config);\n    store->sessionid = NULL; /* let caller free sessionid */\n    free(clone_host);\n    free(clone_conn_to_host);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\nvoid Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  if(Curl_ssl->associate_connection) {\n    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n  }\n}\n\nvoid Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  if(Curl_ssl->disassociate_connection) {\n    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n  }\n}\n\nvoid Curl_ssl_close_all(struct Curl_easy *data)\n{\n  /* kill the session ID cache if not shared */\n  if(data->state.session && !SSLSESSION_SHARED(data)) {\n    size_t i;\n    for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++)\n      /* the single-killer function handles empty table slots */\n      Curl_ssl_kill_session(&data->state.session[i]);\n\n    /* free the cache data */\n    Curl_safefree(data->state.session);\n  }\n\n  Curl_ssl->close_all(data);\n}\n\nint Curl_ssl_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];\n\n  if(connssl->connecting_state == ssl_connect_2_writing) {\n    /* write mode */\n    socks[0] = conn->sock[FIRSTSOCKET];\n    return GETSOCK_WRITESOCK(0);\n  }\n  if(connssl->connecting_state == ssl_connect_2_reading) {\n    /* read mode */\n    socks[0] = conn->sock[FIRSTSOCKET];\n    return GETSOCK_READSOCK(0);\n  }\n\n  return GETSOCK_BLANK;\n}\n\nvoid Curl_ssl_close(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex)\n{\n  DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));\n  Curl_ssl->close_one(data, conn, sockindex);\n  conn->ssl[sockindex].state = ssl_connection_none;\n}\n\nCURLcode Curl_ssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(Curl_ssl->shut_down(data, conn, sockindex))\n    return CURLE_SSL_SHUTDOWN_FAILED;\n\n  conn->ssl[sockindex].use = FALSE; /* get back to ordinary socket usage */\n  conn->ssl[sockindex].state = ssl_connection_none;\n\n  conn->recv[sockindex] = Curl_recv_plain;\n  conn->send[sockindex] = Curl_send_plain;\n\n  return CURLE_OK;\n}\n\n/* Selects an SSL crypto engine\n */\nCURLcode Curl_ssl_set_engine(struct Curl_easy *data, const char *engine)\n{\n  return Curl_ssl->set_engine(data, engine);\n}\n\n/* Selects the default SSL crypto engine\n */\nCURLcode Curl_ssl_set_engine_default(struct Curl_easy *data)\n{\n  return Curl_ssl->set_engine_default(data);\n}\n\n/* Return list of OpenSSL crypto engine names. */\nstruct curl_slist *Curl_ssl_engines_list(struct Curl_easy *data)\n{\n  return Curl_ssl->engines_list(data);\n}\n\n/*\n * This sets up a session ID cache to the specified size. Make sure this code\n * is agnostic to what underlying SSL technology we use.\n */\nCURLcode Curl_ssl_initsessions(struct Curl_easy *data, size_t amount)\n{\n  struct Curl_ssl_session *session;\n\n  if(data->state.session)\n    /* this is just a precaution to prevent multiple inits */\n    return CURLE_OK;\n\n  session = calloc(amount, sizeof(struct Curl_ssl_session));\n  if(!session)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* store the info in the SSL section */\n  data->set.general_ssl.max_ssl_sessions = amount;\n  data->state.session = session;\n  data->state.sessionage = 1; /* this is brand new */\n  return CURLE_OK;\n}\n\nstatic size_t multissl_version(char *buffer, size_t size);\n\nsize_t Curl_ssl_version(char *buffer, size_t size)\n{\n#ifdef CURL_WITH_MULTI_SSL\n  return multissl_version(buffer, size);\n#else\n  return Curl_ssl->version(buffer, size);\n#endif\n}\n\n/*\n * This function tries to determine connection status.\n *\n * Return codes:\n *     1 means the connection is still in place\n *     0 means the connection has been closed\n *    -1 means the connection status is unknown\n */\nint Curl_ssl_check_cxn(struct connectdata *conn)\n{\n  return Curl_ssl->check_cxn(conn);\n}\n\nbool Curl_ssl_data_pending(const struct connectdata *conn,\n                           int connindex)\n{\n  return Curl_ssl->data_pending(conn, connindex);\n}\n\nvoid Curl_ssl_free_certinfo(struct Curl_easy *data)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n\n  if(ci->num_of_certs) {\n    /* free all individual lists used */\n    int i;\n    for(i = 0; i<ci->num_of_certs; i++) {\n      curl_slist_free_all(ci->certinfo[i]);\n      ci->certinfo[i] = NULL;\n    }\n\n    free(ci->certinfo); /* free the actual array too */\n    ci->certinfo = NULL;\n    ci->num_of_certs = 0;\n  }\n}\n\nCURLcode Curl_ssl_init_certinfo(struct Curl_easy *data, int num)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n  struct curl_slist **table;\n\n  /* Free any previous certificate information structures */\n  Curl_ssl_free_certinfo(data);\n\n  /* Allocate the required certificate information structures */\n  table = calloc((size_t) num, sizeof(struct curl_slist *));\n  if(!table)\n    return CURLE_OUT_OF_MEMORY;\n\n  ci->num_of_certs = num;\n  ci->certinfo = table;\n\n  return CURLE_OK;\n}\n\n/*\n * 'value' is NOT a null-terminated string\n */\nCURLcode Curl_ssl_push_certinfo_len(struct Curl_easy *data,\n                                    int certnum,\n                                    const char *label,\n                                    const char *value,\n                                    size_t valuelen)\n{\n  struct curl_certinfo *ci = &data->info.certs;\n  char *output;\n  struct curl_slist *nl;\n  CURLcode result = CURLE_OK;\n  size_t labellen = strlen(label);\n  size_t outlen = labellen + 1 + valuelen + 1; /* label:value\\0 */\n\n  output = malloc(outlen);\n  if(!output)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* sprintf the label and colon */\n  msnprintf(output, outlen, \"%s:\", label);\n\n  /* memcpy the value (it might not be null-terminated) */\n  memcpy(&output[labellen + 1], value, valuelen);\n\n  /* null-terminate the output */\n  output[labellen + 1 + valuelen] = 0;\n\n  nl = Curl_slist_append_nodup(ci->certinfo[certnum], output);\n  if(!nl) {\n    free(output);\n    curl_slist_free_all(ci->certinfo[certnum]);\n    result = CURLE_OUT_OF_MEMORY;\n  }\n\n  ci->certinfo[certnum] = nl;\n  return result;\n}\n\n/*\n * This is a convenience function for push_certinfo_len that takes a zero\n * terminated value.\n */\nCURLcode Curl_ssl_push_certinfo(struct Curl_easy *data,\n                                int certnum,\n                                const char *label,\n                                const char *value)\n{\n  size_t valuelen = strlen(value);\n\n  return Curl_ssl_push_certinfo_len(data, certnum, label, value, valuelen);\n}\n\nCURLcode Curl_ssl_random(struct Curl_easy *data,\n                         unsigned char *entropy,\n                         size_t length)\n{\n  return Curl_ssl->random(data, entropy, length);\n}\n\n/*\n * Public key pem to der conversion\n */\n\nstatic CURLcode pubkey_pem_to_der(const char *pem,\n                                  unsigned char **der, size_t *der_len)\n{\n  char *stripped_pem, *begin_pos, *end_pos;\n  size_t pem_count, stripped_pem_count = 0, pem_len;\n  CURLcode result;\n\n  /* if no pem, exit. */\n  if(!pem)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  begin_pos = strstr(pem, \"-----BEGIN PUBLIC KEY-----\");\n  if(!begin_pos)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  pem_count = begin_pos - pem;\n  /* Invalid if not at beginning AND not directly following \\n */\n  if(0 != pem_count && '\\n' != pem[pem_count - 1])\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  /* 26 is length of \"-----BEGIN PUBLIC KEY-----\" */\n  pem_count += 26;\n\n  /* Invalid if not directly following \\n */\n  end_pos = strstr(pem + pem_count, \"\\n-----END PUBLIC KEY-----\");\n  if(!end_pos)\n    return CURLE_BAD_CONTENT_ENCODING;\n\n  pem_len = end_pos - pem;\n\n  stripped_pem = malloc(pem_len - pem_count + 1);\n  if(!stripped_pem)\n    return CURLE_OUT_OF_MEMORY;\n\n  /*\n   * Here we loop through the pem array one character at a time between the\n   * correct indices, and place each character that is not '\\n' or '\\r'\n   * into the stripped_pem array, which should represent the raw base64 string\n   */\n  while(pem_count < pem_len) {\n    if('\\n' != pem[pem_count] && '\\r' != pem[pem_count])\n      stripped_pem[stripped_pem_count++] = pem[pem_count];\n    ++pem_count;\n  }\n  /* Place the null terminator in the correct place */\n  stripped_pem[stripped_pem_count] = '\\0';\n\n  result = Curl_base64_decode(stripped_pem, der, der_len);\n\n  Curl_safefree(stripped_pem);\n\n  return result;\n}\n\n/*\n * Generic pinned public key check.\n */\n\nCURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,\n                              const char *pinnedpubkey,\n                              const unsigned char *pubkey, size_t pubkeylen)\n{\n  FILE *fp;\n  unsigned char *buf = NULL, *pem_ptr = NULL;\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n  if(!pubkey || !pubkeylen)\n    return result;\n\n  /* only do this if pinnedpubkey starts with \"sha256//\", length 8 */\n  if(strncmp(pinnedpubkey, \"sha256//\", 8) == 0) {\n    CURLcode encode;\n    size_t encodedlen, pinkeylen;\n    char *encoded, *pinkeycopy, *begin_pos, *end_pos;\n    unsigned char *sha256sumdigest;\n\n    if(!Curl_ssl->sha256sum) {\n      /* without sha256 support, this cannot match */\n      return result;\n    }\n\n    /* compute sha256sum of public key */\n    sha256sumdigest = malloc(CURL_SHA256_DIGEST_LENGTH);\n    if(!sha256sumdigest)\n      return CURLE_OUT_OF_MEMORY;\n    encode = Curl_ssl->sha256sum(pubkey, pubkeylen,\n                        sha256sumdigest, CURL_SHA256_DIGEST_LENGTH);\n\n    if(encode != CURLE_OK)\n      return encode;\n\n    encode = Curl_base64_encode(data, (char *)sha256sumdigest,\n                                CURL_SHA256_DIGEST_LENGTH, &encoded,\n                                &encodedlen);\n    Curl_safefree(sha256sumdigest);\n\n    if(encode)\n      return encode;\n\n    infof(data, \"\\t public key hash: sha256//%s\\n\", encoded);\n\n    /* it starts with sha256//, copy so we can modify it */\n    pinkeylen = strlen(pinnedpubkey) + 1;\n    pinkeycopy = malloc(pinkeylen);\n    if(!pinkeycopy) {\n      Curl_safefree(encoded);\n      return CURLE_OUT_OF_MEMORY;\n    }\n    memcpy(pinkeycopy, pinnedpubkey, pinkeylen);\n    /* point begin_pos to the copy, and start extracting keys */\n    begin_pos = pinkeycopy;\n    do {\n      end_pos = strstr(begin_pos, \";sha256//\");\n      /*\n       * if there is an end_pos, null terminate,\n       * otherwise it'll go to the end of the original string\n       */\n      if(end_pos)\n        end_pos[0] = '\\0';\n\n      /* compare base64 sha256 digests, 8 is the length of \"sha256//\" */\n      if(encodedlen == strlen(begin_pos + 8) &&\n         !memcmp(encoded, begin_pos + 8, encodedlen)) {\n        result = CURLE_OK;\n        break;\n      }\n\n      /*\n       * change back the null-terminator we changed earlier,\n       * and look for next begin\n       */\n      if(end_pos) {\n        end_pos[0] = ';';\n        begin_pos = strstr(end_pos, \"sha256//\");\n      }\n    } while(end_pos && begin_pos);\n    Curl_safefree(encoded);\n    Curl_safefree(pinkeycopy);\n    return result;\n  }\n\n  fp = fopen(pinnedpubkey, \"rb\");\n  if(!fp)\n    return result;\n\n  do {\n    long filesize;\n    size_t size, pem_len;\n    CURLcode pem_read;\n\n    /* Determine the file's size */\n    if(fseek(fp, 0, SEEK_END))\n      break;\n    filesize = ftell(fp);\n    if(fseek(fp, 0, SEEK_SET))\n      break;\n    if(filesize < 0 || filesize > MAX_PINNED_PUBKEY_SIZE)\n      break;\n\n    /*\n     * if the size of our certificate is bigger than the file\n     * size then it can't match\n     */\n    size = curlx_sotouz((curl_off_t) filesize);\n    if(pubkeylen > size)\n      break;\n\n    /*\n     * Allocate buffer for the pinned key\n     * With 1 additional byte for null terminator in case of PEM key\n     */\n    buf = malloc(size + 1);\n    if(!buf)\n      break;\n\n    /* Returns number of elements read, which should be 1 */\n    if((int) fread(buf, size, 1, fp) != 1)\n      break;\n\n    /* If the sizes are the same, it can't be base64 encoded, must be der */\n    if(pubkeylen == size) {\n      if(!memcmp(pubkey, buf, pubkeylen))\n        result = CURLE_OK;\n      break;\n    }\n\n    /*\n     * Otherwise we will assume it's PEM and try to decode it\n     * after placing null terminator\n     */\n    buf[size] = '\\0';\n    pem_read = pubkey_pem_to_der((const char *)buf, &pem_ptr, &pem_len);\n    /* if it wasn't read successfully, exit */\n    if(pem_read)\n      break;\n\n    /*\n     * if the size of our certificate doesn't match the size of\n     * the decoded file, they can't be the same, otherwise compare\n     */\n    if(pubkeylen == pem_len && !memcmp(pubkey, pem_ptr, pubkeylen))\n      result = CURLE_OK;\n  } while(0);\n\n  Curl_safefree(buf);\n  Curl_safefree(pem_ptr);\n  fclose(fp);\n\n  return result;\n}\n\n/*\n * Check whether the SSL backend supports the status_request extension.\n */\nbool Curl_ssl_cert_status_request(void)\n{\n  return Curl_ssl->cert_status_request();\n}\n\n/*\n * Check whether the SSL backend supports false start.\n */\nbool Curl_ssl_false_start(void)\n{\n  return Curl_ssl->false_start();\n}\n\n/*\n * Check whether the SSL backend supports setting TLS 1.3 cipher suites\n */\nbool Curl_ssl_tls13_ciphersuites(void)\n{\n  return Curl_ssl->supports & SSLSUPP_TLS13_CIPHERSUITES;\n}\n\n/*\n * Default implementations for unsupported functions.\n */\n\nint Curl_none_init(void)\n{\n  return 1;\n}\n\nvoid Curl_none_cleanup(void)\n{ }\n\nint Curl_none_shutdown(struct Curl_easy *data UNUSED_PARAM,\n                       struct connectdata *conn UNUSED_PARAM,\n                       int sockindex UNUSED_PARAM)\n{\n  (void)data;\n  (void)conn;\n  (void)sockindex;\n  return 0;\n}\n\nint Curl_none_check_cxn(struct connectdata *conn UNUSED_PARAM)\n{\n  (void)conn;\n  return -1;\n}\n\nCURLcode Curl_none_random(struct Curl_easy *data UNUSED_PARAM,\n                          unsigned char *entropy UNUSED_PARAM,\n                          size_t length UNUSED_PARAM)\n{\n  (void)data;\n  (void)entropy;\n  (void)length;\n  return CURLE_NOT_BUILT_IN;\n}\n\nvoid Curl_none_close_all(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n}\n\nvoid Curl_none_session_free(void *ptr UNUSED_PARAM)\n{\n  (void)ptr;\n}\n\nbool Curl_none_data_pending(const struct connectdata *conn UNUSED_PARAM,\n                            int connindex UNUSED_PARAM)\n{\n  (void)conn;\n  (void)connindex;\n  return 0;\n}\n\nbool Curl_none_cert_status_request(void)\n{\n  return FALSE;\n}\n\nCURLcode Curl_none_set_engine(struct Curl_easy *data UNUSED_PARAM,\n                              const char *engine UNUSED_PARAM)\n{\n  (void)data;\n  (void)engine;\n  return CURLE_NOT_BUILT_IN;\n}\n\nCURLcode Curl_none_set_engine_default(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n  return CURLE_NOT_BUILT_IN;\n}\n\nstruct curl_slist *Curl_none_engines_list(struct Curl_easy *data UNUSED_PARAM)\n{\n  (void)data;\n  return (struct curl_slist *)NULL;\n}\n\nbool Curl_none_false_start(void)\n{\n  return FALSE;\n}\n\nstatic int multissl_init(void)\n{\n  if(multissl_setup(NULL))\n    return 1;\n  return Curl_ssl->init();\n}\n\nstatic CURLcode multissl_connect(struct Curl_easy *data,\n                                 struct connectdata *conn, int sockindex)\n{\n  if(multissl_setup(NULL))\n    return CURLE_FAILED_INIT;\n  return Curl_ssl->connect_blocking(data, conn, sockindex);\n}\n\nstatic CURLcode multissl_connect_nonblocking(struct Curl_easy *data,\n                                             struct connectdata *conn,\n                                             int sockindex, bool *done)\n{\n  if(multissl_setup(NULL))\n    return CURLE_FAILED_INIT;\n  return Curl_ssl->connect_nonblocking(data, conn, sockindex, done);\n}\n\nstatic int multissl_getsock(struct connectdata *conn, curl_socket_t *socks)\n{\n  if(multissl_setup(NULL))\n    return 0;\n  return Curl_ssl->getsock(conn, socks);\n}\n\nstatic void *multissl_get_internals(struct ssl_connect_data *connssl,\n                                    CURLINFO info)\n{\n  if(multissl_setup(NULL))\n    return NULL;\n  return Curl_ssl->get_internals(connssl, info);\n}\n\nstatic void multissl_close(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex)\n{\n  if(multissl_setup(NULL))\n    return;\n  Curl_ssl->close_one(data, conn, sockindex);\n}\n\nstatic const struct Curl_ssl Curl_ssl_multi = {\n  { CURLSSLBACKEND_NONE, \"multi\" },  /* info */\n  0, /* supports nothing */\n  (size_t)-1, /* something insanely large to be on the safe side */\n\n  multissl_init,                     /* init */\n  Curl_none_cleanup,                 /* cleanup */\n  multissl_version,                  /* version */\n  Curl_none_check_cxn,               /* check_cxn */\n  Curl_none_shutdown,                /* shutdown */\n  Curl_none_data_pending,            /* data_pending */\n  Curl_none_random,                  /* random */\n  Curl_none_cert_status_request,     /* cert_status_request */\n  multissl_connect,                  /* connect */\n  multissl_connect_nonblocking,      /* connect_nonblocking */\n  multissl_getsock,                  /* getsock */\n  multissl_get_internals,            /* get_internals */\n  multissl_close,                    /* close_one */\n  Curl_none_close_all,               /* close_all */\n  Curl_none_session_free,            /* session_free */\n  Curl_none_set_engine,              /* set_engine */\n  Curl_none_set_engine_default,      /* set_engine_default */\n  Curl_none_engines_list,            /* engines_list */\n  Curl_none_false_start,             /* false_start */\n  NULL,                              /* sha256sum */\n  NULL,                              /* associate_connection */\n  NULL                               /* disassociate_connection */\n};\n\nconst struct Curl_ssl *Curl_ssl =\n#if defined(CURL_WITH_MULTI_SSL)\n  &Curl_ssl_multi;\n#elif defined(USE_WOLFSSL)\n  &Curl_ssl_wolfssl;\n#elif defined(USE_SECTRANSP)\n  &Curl_ssl_sectransp;\n#elif defined(USE_GNUTLS)\n  &Curl_ssl_gnutls;\n#elif defined(USE_GSKIT)\n  &Curl_ssl_gskit;\n#elif defined(USE_MBEDTLS)\n  &Curl_ssl_mbedtls;\n#elif defined(USE_NSS)\n  &Curl_ssl_nss;\n#elif defined(USE_RUSTLS)\n  &Curl_ssl_rustls;\n#elif defined(USE_OPENSSL)\n  &Curl_ssl_openssl;\n#elif defined(USE_SCHANNEL)\n  &Curl_ssl_schannel;\n#elif defined(USE_MESALINK)\n  &Curl_ssl_mesalink;\n#elif defined(USE_BEARSSL)\n  &Curl_ssl_bearssl;\n#else\n#error \"Missing struct Curl_ssl for selected SSL backend\"\n#endif\n\nstatic const struct Curl_ssl *available_backends[] = {\n#if defined(USE_WOLFSSL)\n  &Curl_ssl_wolfssl,\n#endif\n#if defined(USE_SECTRANSP)\n  &Curl_ssl_sectransp,\n#endif\n#if defined(USE_GNUTLS)\n  &Curl_ssl_gnutls,\n#endif\n#if defined(USE_GSKIT)\n  &Curl_ssl_gskit,\n#endif\n#if defined(USE_MBEDTLS)\n  &Curl_ssl_mbedtls,\n#endif\n#if defined(USE_NSS)\n  &Curl_ssl_nss,\n#endif\n#if defined(USE_OPENSSL)\n  &Curl_ssl_openssl,\n#endif\n#if defined(USE_SCHANNEL)\n  &Curl_ssl_schannel,\n#endif\n#if defined(USE_MESALINK)\n  &Curl_ssl_mesalink,\n#endif\n#if defined(USE_BEARSSL)\n  &Curl_ssl_bearssl,\n#endif\n#if defined(USE_RUSTLS)\n  &Curl_ssl_rustls,\n#endif\n  NULL\n};\n\nstatic size_t multissl_version(char *buffer, size_t size)\n{\n  static const struct Curl_ssl *selected;\n  static char backends[200];\n  static size_t backends_len;\n  const struct Curl_ssl *current;\n\n  current = Curl_ssl == &Curl_ssl_multi ? available_backends[0] : Curl_ssl;\n\n  if(current != selected) {\n    char *p = backends;\n    char *end = backends + sizeof(backends);\n    int i;\n\n    selected = current;\n\n    backends[0] = '\\0';\n\n    for(i = 0; available_backends[i]; ++i) {\n      char vb[200];\n      bool paren = (selected != available_backends[i]);\n\n      if(available_backends[i]->version(vb, sizeof(vb))) {\n        p += msnprintf(p, end - p, \"%s%s%s%s\", (p != backends ? \" \" : \"\"),\n                       (paren ? \"(\" : \"\"), vb, (paren ? \")\" : \"\"));\n      }\n    }\n\n    backends_len = p - backends;\n  }\n\n  if(!size)\n    return 0;\n\n  if(size <= backends_len) {\n    strncpy(buffer, backends, size - 1);\n    buffer[size - 1] = '\\0';\n    return size - 1;\n  }\n\n  strcpy(buffer, backends);\n  return backends_len;\n}\n\nstatic int multissl_setup(const struct Curl_ssl *backend)\n{\n  const char *env;\n  char *env_tmp;\n\n  if(Curl_ssl != &Curl_ssl_multi)\n    return 1;\n\n  if(backend) {\n    Curl_ssl = backend;\n    return 0;\n  }\n\n  if(!available_backends[0])\n    return 1;\n\n  env = env_tmp = curl_getenv(\"CURL_SSL_BACKEND\");\n#ifdef CURL_DEFAULT_SSL_BACKEND\n  if(!env)\n    env = CURL_DEFAULT_SSL_BACKEND;\n#endif\n  if(env) {\n    int i;\n    for(i = 0; available_backends[i]; i++) {\n      if(strcasecompare(env, available_backends[i]->info.name)) {\n        Curl_ssl = available_backends[i];\n        curl_free(env_tmp);\n        return 0;\n      }\n    }\n  }\n\n  /* Fall back to first available backend */\n  Curl_ssl = available_backends[0];\n  curl_free(env_tmp);\n  return 0;\n}\n\nCURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                              const curl_ssl_backend ***avail)\n{\n  int i;\n\n  if(avail)\n    *avail = (const curl_ssl_backend **)&available_backends;\n\n  if(Curl_ssl != &Curl_ssl_multi)\n    return id == Curl_ssl->info.id ||\n           (name && strcasecompare(name, Curl_ssl->info.name)) ?\n           CURLSSLSET_OK :\n#if defined(CURL_WITH_MULTI_SSL)\n           CURLSSLSET_TOO_LATE;\n#else\n           CURLSSLSET_UNKNOWN_BACKEND;\n#endif\n\n  for(i = 0; available_backends[i]; i++) {\n    if(available_backends[i]->info.id == id ||\n       (name && strcasecompare(available_backends[i]->info.name, name))) {\n      multissl_setup(available_backends[i]);\n      return CURLSSLSET_OK;\n    }\n  }\n\n  return CURLSSLSET_UNKNOWN_BACKEND;\n}\n\n#else /* USE_SSL */\nCURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                              const curl_ssl_backend ***avail)\n{\n  (void)id;\n  (void)name;\n  (void)avail;\n  return CURLSSLSET_NO_BACKENDS;\n}\n\n#endif /* !USE_SSL */\n", "#ifndef HEADER_CURL_VTLS_H\n#define HEADER_CURL_VTLS_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n#include \"curl_setup.h\"\n\nstruct connectdata;\nstruct ssl_connect_data;\n\n#define SSLSUPP_CA_PATH      (1<<0) /* supports CAPATH */\n#define SSLSUPP_CERTINFO     (1<<1) /* supports CURLOPT_CERTINFO */\n#define SSLSUPP_PINNEDPUBKEY (1<<2) /* supports CURLOPT_PINNEDPUBLICKEY */\n#define SSLSUPP_SSL_CTX      (1<<3) /* supports CURLOPT_SSL_CTX */\n#define SSLSUPP_HTTPS_PROXY  (1<<4) /* supports access via HTTPS proxies */\n#define SSLSUPP_TLS13_CIPHERSUITES (1<<5) /* supports TLS 1.3 ciphersuites */\n#define SSLSUPP_CAINFO_BLOB  (1<<6)\n\nstruct Curl_ssl {\n  /*\n   * This *must* be the first entry to allow returning the list of available\n   * backends in curl_global_sslset().\n   */\n  curl_ssl_backend info;\n  unsigned int supports; /* bitfield, see above */\n  size_t sizeof_ssl_backend_data;\n\n  int (*init)(void);\n  void (*cleanup)(void);\n\n  size_t (*version)(char *buffer, size_t size);\n  int (*check_cxn)(struct connectdata *cxn);\n  int (*shut_down)(struct Curl_easy *data, struct connectdata *conn,\n                   int sockindex);\n  bool (*data_pending)(const struct connectdata *conn,\n                       int connindex);\n\n  /* return 0 if a find random is filled in */\n  CURLcode (*random)(struct Curl_easy *data, unsigned char *entropy,\n                     size_t length);\n  bool (*cert_status_request)(void);\n\n  CURLcode (*connect_blocking)(struct Curl_easy *data,\n                               struct connectdata *conn, int sockindex);\n  CURLcode (*connect_nonblocking)(struct Curl_easy *data,\n                                  struct connectdata *conn, int sockindex,\n                                  bool *done);\n\n  /* If the SSL backend wants to read or write on this connection during a\n     handshake, set socks[0] to the connection's FIRSTSOCKET, and return\n     a bitmap indicating read or write with GETSOCK_WRITESOCK(0) or\n     GETSOCK_READSOCK(0). Otherwise return GETSOCK_BLANK.\n     Mandatory. */\n  int (*getsock)(struct connectdata *conn, curl_socket_t *socks);\n\n  void *(*get_internals)(struct ssl_connect_data *connssl, CURLINFO info);\n  void (*close_one)(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex);\n  void (*close_all)(struct Curl_easy *data);\n  void (*session_free)(void *ptr);\n\n  CURLcode (*set_engine)(struct Curl_easy *data, const char *engine);\n  CURLcode (*set_engine_default)(struct Curl_easy *data);\n  struct curl_slist *(*engines_list)(struct Curl_easy *data);\n\n  bool (*false_start)(void);\n  CURLcode (*sha256sum)(const unsigned char *input, size_t inputlen,\n                    unsigned char *sha256sum, size_t sha256sumlen);\n\n  void (*associate_connection)(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               int sockindex);\n  void (*disassociate_connection)(struct Curl_easy *data, int sockindex);\n};\n\n#ifdef USE_SSL\nextern const struct Curl_ssl *Curl_ssl;\n#endif\n\nint Curl_none_init(void);\nvoid Curl_none_cleanup(void);\nint Curl_none_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex);\nint Curl_none_check_cxn(struct connectdata *conn);\nCURLcode Curl_none_random(struct Curl_easy *data, unsigned char *entropy,\n                          size_t length);\nvoid Curl_none_close_all(struct Curl_easy *data);\nvoid Curl_none_session_free(void *ptr);\nbool Curl_none_data_pending(const struct connectdata *conn, int connindex);\nbool Curl_none_cert_status_request(void);\nCURLcode Curl_none_set_engine(struct Curl_easy *data, const char *engine);\nCURLcode Curl_none_set_engine_default(struct Curl_easy *data);\nstruct curl_slist *Curl_none_engines_list(struct Curl_easy *data);\nbool Curl_none_false_start(void);\nbool Curl_ssl_tls13_ciphersuites(void);\n\n#include \"openssl.h\"        /* OpenSSL versions */\n#include \"gtls.h\"           /* GnuTLS versions */\n#include \"nssg.h\"           /* NSS versions */\n#include \"gskit.h\"          /* Global Secure ToolKit versions */\n#include \"wolfssl.h\"        /* wolfSSL versions */\n#include \"schannel.h\"       /* Schannel SSPI version */\n#include \"sectransp.h\"      /* SecureTransport (Darwin) version */\n#include \"mbedtls.h\"        /* mbedTLS versions */\n#include \"mesalink.h\"       /* MesaLink versions */\n#include \"bearssl.h\"        /* BearSSL versions */\n#include \"rustls.h\"         /* rustls versions */\n\n#ifndef MAX_PINNED_PUBKEY_SIZE\n#define MAX_PINNED_PUBKEY_SIZE 1048576 /* 1MB */\n#endif\n\n#ifndef CURL_SHA256_DIGEST_LENGTH\n#define CURL_SHA256_DIGEST_LENGTH 32 /* fixed size */\n#endif\n\n/* see https://www.iana.org/assignments/tls-extensiontype-values/ */\n#define ALPN_HTTP_1_1_LENGTH 8\n#define ALPN_HTTP_1_1 \"http/1.1\"\n#define ALPN_H2_LENGTH 2\n#define ALPN_H2 \"h2\"\n\n/* set of helper macros for the backends to access the correct fields. For the\n   proxy or for the remote host - to properly support HTTPS proxy */\n#ifndef CURL_DISABLE_PROXY\n#define SSL_IS_PROXY()                                                  \\\n  (CURLPROXY_HTTPS == conn->http_proxy.proxytype &&                     \\\n   ssl_connection_complete !=                                           \\\n   conn->proxy_ssl[conn->sock[SECONDARYSOCKET] ==                       \\\n                   CURL_SOCKET_BAD ? FIRSTSOCKET : SECONDARYSOCKET].state)\n#define SSL_SET_OPTION(var)                                             \\\n  (SSL_IS_PROXY() ? data->set.proxy_ssl.var : data->set.ssl.var)\n#define SSL_SET_OPTION_LVALUE(var)                                      \\\n  (*(SSL_IS_PROXY() ? &data->set.proxy_ssl.var : &data->set.ssl.var))\n#define SSL_CONN_CONFIG(var)                                            \\\n  (SSL_IS_PROXY() ? conn->proxy_ssl_config.var : conn->ssl_config.var)\n#define SSL_HOST_NAME()                                                 \\\n  (SSL_IS_PROXY() ? conn->http_proxy.host.name : conn->host.name)\n#define SSL_HOST_DISPNAME()                                             \\\n  (SSL_IS_PROXY() ? conn->http_proxy.host.dispname : conn->host.dispname)\n#define SSL_HOST_PORT()                                                 \\\n  (SSL_IS_PROXY() ? conn->port : conn->remote_port)\n#define SSL_PINNED_PUB_KEY() (SSL_IS_PROXY()                            \\\n  ? data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]                     \\\n  : data->set.str[STRING_SSL_PINNEDPUBLICKEY])\n#else\n#define SSL_IS_PROXY() FALSE\n#define SSL_SET_OPTION(var) data->set.ssl.var\n#define SSL_SET_OPTION_LVALUE(var) data->set.ssl.var\n#define SSL_CONN_CONFIG(var) conn->ssl_config.var\n#define SSL_HOST_NAME() conn->host.name\n#define SSL_HOST_DISPNAME() conn->host.dispname\n#define SSL_HOST_PORT() conn->remote_port\n#define SSL_PINNED_PUB_KEY()                                            \\\n  data->set.str[STRING_SSL_PINNEDPUBLICKEY]\n#endif\n\nbool Curl_ssl_config_matches(struct ssl_primary_config *data,\n                             struct ssl_primary_config *needle);\nbool Curl_clone_primary_ssl_config(struct ssl_primary_config *source,\n                                   struct ssl_primary_config *dest);\nvoid Curl_free_primary_ssl_config(struct ssl_primary_config *sslc);\n/* An implementation of the getsock field of Curl_ssl that relies\n   on the ssl_connect_state enum. Asks for read or write depending\n   on whether conn->state is ssl_connect_2_reading or\n   ssl_connect_2_writing. */\nint Curl_ssl_getsock(struct connectdata *conn, curl_socket_t *socks);\n\nint Curl_ssl_backend(void);\n\n#ifdef USE_SSL\nint Curl_ssl_init(void);\nvoid Curl_ssl_cleanup(void);\nCURLcode Curl_ssl_connect(struct Curl_easy *data, struct connectdata *conn,\n                          int sockindex);\nCURLcode Curl_ssl_connect_nonblocking(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex,\n                                      bool *done);\n/* tell the SSL stuff to close down all open information regarding\n   connections (and thus session ID caching etc) */\nvoid Curl_ssl_close_all(struct Curl_easy *data);\nvoid Curl_ssl_close(struct Curl_easy *data, struct connectdata *conn,\n                    int sockindex);\nCURLcode Curl_ssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                           int sockindex);\nCURLcode Curl_ssl_set_engine(struct Curl_easy *data, const char *engine);\n/* Sets engine as default for all SSL operations */\nCURLcode Curl_ssl_set_engine_default(struct Curl_easy *data);\nstruct curl_slist *Curl_ssl_engines_list(struct Curl_easy *data);\n\n/* init the SSL session ID cache */\nCURLcode Curl_ssl_initsessions(struct Curl_easy *, size_t);\nsize_t Curl_ssl_version(char *buffer, size_t size);\nbool Curl_ssl_data_pending(const struct connectdata *conn,\n                           int connindex);\nint Curl_ssl_check_cxn(struct connectdata *conn);\n\n/* Certificate information list handling. */\n\nvoid Curl_ssl_free_certinfo(struct Curl_easy *data);\nCURLcode Curl_ssl_init_certinfo(struct Curl_easy *data, int num);\nCURLcode Curl_ssl_push_certinfo_len(struct Curl_easy *data, int certnum,\n                                    const char *label, const char *value,\n                                    size_t valuelen);\nCURLcode Curl_ssl_push_certinfo(struct Curl_easy *data, int certnum,\n                                const char *label, const char *value);\n\n/* Functions to be used by SSL library adaptation functions */\n\n/* Lock session cache mutex.\n * Call this before calling other Curl_ssl_*session* functions\n * Caller should unlock this mutex as soon as possible, as it may block\n * other SSL connection from making progress.\n * The purpose of explicitly locking SSL session cache data is to allow\n * individual SSL engines to manage session lifetime in their specific way.\n */\nvoid Curl_ssl_sessionid_lock(struct Curl_easy *data);\n\n/* Unlock session cache mutex */\nvoid Curl_ssl_sessionid_unlock(struct Curl_easy *data);\n\n/* extract a session ID\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * Caller must make sure that the ownership of returned sessionid object\n * is properly taken (e.g. its refcount is incremented\n * under sessionid mutex).\n */\nbool Curl_ssl_getsessionid(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           const bool isproxy,\n                           void **ssl_sessionid,\n                           size_t *idsize, /* set 0 if unknown */\n                           int sockindex);\n/* add a new session ID\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * Caller must ensure that it has properly shared ownership of this sessionid\n * object with cache (e.g. incrementing refcount on success)\n */\nCURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               const bool isProxy,\n                               void *ssl_sessionid,\n                               size_t idsize,\n                               int sockindex);\n/* Kill a single session ID entry in the cache\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * This will call engine-specific curlssl_session_free function, which must\n * take sessionid object ownership from sessionid cache\n * (e.g. decrement refcount).\n */\nvoid Curl_ssl_kill_session(struct Curl_ssl_session *session);\n/* delete a session from the cache\n * Sessionid mutex must be locked (see Curl_ssl_sessionid_lock).\n * This will call engine-specific curlssl_session_free function, which must\n * take sessionid object ownership from sessionid cache\n * (e.g. decrement refcount).\n */\nvoid Curl_ssl_delsessionid(struct Curl_easy *data, void *ssl_sessionid);\n\n/* get N random bytes into the buffer */\nCURLcode Curl_ssl_random(struct Curl_easy *data, unsigned char *buffer,\n                         size_t length);\n/* Check pinned public key. */\nCURLcode Curl_pin_peer_pubkey(struct Curl_easy *data,\n                              const char *pinnedpubkey,\n                              const unsigned char *pubkey, size_t pubkeylen);\n\nbool Curl_ssl_cert_status_request(void);\n\nbool Curl_ssl_false_start(void);\n\nvoid Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn);\nvoid Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn);\n\n#define SSL_SHUTDOWN_TIMEOUT 10000 /* ms */\n\n#else /* if not USE_SSL */\n\n/* When SSL support is not present, just define away these function calls */\n#define Curl_ssl_init() 1\n#define Curl_ssl_cleanup() Curl_nop_stmt\n#define Curl_ssl_connect(x,y,z) CURLE_NOT_BUILT_IN\n#define Curl_ssl_close_all(x) Curl_nop_stmt\n#define Curl_ssl_close(x,y,z) Curl_nop_stmt\n#define Curl_ssl_shutdown(x,y,z) CURLE_NOT_BUILT_IN\n#define Curl_ssl_set_engine(x,y) CURLE_NOT_BUILT_IN\n#define Curl_ssl_set_engine_default(x) CURLE_NOT_BUILT_IN\n#define Curl_ssl_engines_list(x) NULL\n#define Curl_ssl_send(a,b,c,d,e) -1\n#define Curl_ssl_recv(a,b,c,d,e) -1\n#define Curl_ssl_initsessions(x,y) CURLE_OK\n#define Curl_ssl_data_pending(x,y) 0\n#define Curl_ssl_check_cxn(x) 0\n#define Curl_ssl_free_certinfo(x) Curl_nop_stmt\n#define Curl_ssl_connect_nonblocking(x,y,z,w) CURLE_NOT_BUILT_IN\n#define Curl_ssl_kill_session(x) Curl_nop_stmt\n#define Curl_ssl_random(x,y,z) ((void)x, CURLE_NOT_BUILT_IN)\n#define Curl_ssl_cert_status_request() FALSE\n#define Curl_ssl_false_start() FALSE\n#define Curl_ssl_tls13_ciphersuites() FALSE\n#define Curl_ssl_associate_conn(a,b) Curl_nop_stmt\n#define Curl_ssl_detach_conn(a,b) Curl_nop_stmt\n#endif\n\n#endif /* HEADER_CURL_VTLS_H */\n", "/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n/*\n * Source file for all wolfSSL specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_WOLFSSL\n\n#define WOLFSSL_OPTIONS_IGNORE_SYS\n#include <wolfssl/version.h>\n#include <wolfssl/options.h>\n\n/* To determine what functions are available we rely on one or both of:\n   - the user's options.h generated by wolfSSL\n   - the symbols detected by curl's configure\n   Since they are markedly different from one another, and one or the other may\n   not be available, we do some checking below to bring things in sync. */\n\n/* HAVE_ALPN is wolfSSL's build time symbol for enabling ALPN in options.h. */\n#ifndef HAVE_ALPN\n#ifdef HAVE_WOLFSSL_USEALPN\n#define HAVE_ALPN\n#endif\n#endif\n\n#include <limits.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"vtls.h\"\n#include \"keylog.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n\n#include <wolfssl/openssl/ssl.h>\n#include <wolfssl/ssl.h>\n#include <wolfssl/error-ssl.h>\n#include \"wolfssl.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* KEEP_PEER_CERT is a product of the presence of build time symbol\n   OPENSSL_EXTRA without NO_CERTS, depending on the version. KEEP_PEER_CERT is\n   in wolfSSL's settings.h, and the latter two are build time symbols in\n   options.h. */\n#ifndef KEEP_PEER_CERT\n#if defined(HAVE_WOLFSSL_GET_PEER_CERTIFICATE) || \\\n    (defined(OPENSSL_EXTRA) && !defined(NO_CERTS))\n#define KEEP_PEER_CERT\n#endif\n#endif\n\nstruct ssl_backend_data {\n  SSL_CTX* ctx;\n  SSL*     handle;\n};\n\nstatic Curl_recv wolfssl_recv;\nstatic Curl_send wolfssl_send;\n\n#ifdef OPENSSL_EXTRA\n/*\n * Availability note:\n * The TLS 1.3 secret callback (wolfSSL_set_tls13_secret_cb) was added in\n * WolfSSL 4.4.0, but requires the -DHAVE_SECRET_CALLBACK build option. If that\n * option is not set, then TLS 1.3 will not be logged.\n * For TLS 1.2 and before, we use wolfSSL_get_keys().\n * SSL_get_client_random and wolfSSL_get_keys require OPENSSL_EXTRA\n * (--enable-opensslextra or --enable-all).\n */\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\nstatic int\nwolfssl_tls13_secret_callback(SSL *ssl, int id, const unsigned char *secret,\n                              int secretSz, void *ctx)\n{\n  const char *label;\n  unsigned char client_random[SSL3_RANDOM_SIZE];\n  (void)ctx;\n\n  if(!ssl || !Curl_tls_keylog_enabled()) {\n    return 0;\n  }\n\n  switch(id) {\n  case CLIENT_EARLY_TRAFFIC_SECRET:\n    label = \"CLIENT_EARLY_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case SERVER_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"SERVER_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_TRAFFIC_SECRET:\n    label = \"CLIENT_TRAFFIC_SECRET_0\";\n    break;\n  case SERVER_TRAFFIC_SECRET:\n    label = \"SERVER_TRAFFIC_SECRET_0\";\n    break;\n  case EARLY_EXPORTER_SECRET:\n    label = \"EARLY_EXPORTER_SECRET\";\n    break;\n  case EXPORTER_SECRET:\n    label = \"EXPORTER_SECRET\";\n    break;\n  default:\n    return 0;\n  }\n\n  if(SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE) == 0) {\n    /* Should never happen as wolfSSL_KeepArrays() was called before. */\n    return 0;\n  }\n\n  Curl_tls_keylog_write(label, client_random, secret, secretSz);\n  return 0;\n}\n#endif /* defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13) */\n\nstatic void\nwolfssl_log_tls12_secret(SSL *ssl)\n{\n  unsigned char *ms, *sr, *cr;\n  unsigned int msLen, srLen, crLen, i, x = 0;\n\n#if LIBWOLFSSL_VERSION_HEX >= 0x0300d000 /* >= 3.13.0 */\n  /* wolfSSL_GetVersion is available since 3.13, we use it instead of\n   * SSL_version since the latter relies on OPENSSL_ALL (--enable-opensslall or\n   * --enable-all). Failing to perform this check could result in an unusable\n   * key log line when TLS 1.3 is actually negotiated. */\n  switch(wolfSSL_GetVersion(ssl)) {\n  case WOLFSSL_SSLV3:\n  case WOLFSSL_TLSV1:\n  case WOLFSSL_TLSV1_1:\n  case WOLFSSL_TLSV1_2:\n    break;\n  default:\n    /* TLS 1.3 does not use this mechanism, the \"master secret\" returned below\n     * is not directly usable. */\n    return;\n  }\n#endif\n\n  if(SSL_get_keys(ssl, &ms, &msLen, &sr, &srLen, &cr, &crLen) != SSL_SUCCESS) {\n    return;\n  }\n\n  /* Check for a missing master secret and skip logging. That can happen if\n   * curl rejects the server certificate and aborts the handshake.\n   */\n  for(i = 0; i < msLen; i++) {\n    x |= ms[i];\n  }\n  if(x == 0) {\n    return;\n  }\n\n  Curl_tls_keylog_write(\"CLIENT_RANDOM\", cr, ms, msLen);\n}\n#endif /* OPENSSL_EXTRA */\n\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  return -1;\n}\n\n/*\n * This function loads all the client/CA certificates and CRLs. Setup the TLS\n * layer and do all necessary magic.\n */\nstatic CURLcode\nwolfssl_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  char *ciphers;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  SSL_METHOD* req_method = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n#ifdef HAVE_SNI\n  bool sni = FALSE;\n#define use_sni(x)  sni = (x)\n#else\n#define use_sni(x)  Curl_nop_stmt\n#endif\n\n  if(connssl->state == ssl_connection_complete)\n    return CURLE_OK;\n\n  if(SSL_CONN_CONFIG(version_max) != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"wolfSSL does not support to set maximum SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX >= 0x03003000 /* >= 3.3.0 */\n    /* minimum protocol version is set later after the CTX object is created */\n    req_method = SSLv23_client_method();\n#else\n    infof(data, \"wolfSSL <3.3.0 cannot be configured to use TLS 1.0-1.2, \"\n          \"TLS 1.0 is used exclusively\\n\");\n    req_method = TLSv1_client_method();\n#endif\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n#if defined(WOLFSSL_ALLOW_TLSV10) && !defined(NO_OLD_TLS)\n    req_method = TLSv1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.0\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n#ifndef NO_OLD_TLS\n    req_method = TLSv1_1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.1\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n    req_method = TLSv1_2_client_method();\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_TLSv1_3:\n#ifdef WOLFSSL_TLS13\n    req_method = wolfTLSv1_3_client_method();\n    use_sni(TRUE);\n    break;\n#else\n    failf(data, \"wolfSSL: TLS 1.3 is not yet supported\");\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(!req_method) {\n    failf(data, \"SSL: couldn't create a method!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(backend->ctx)\n    SSL_CTX_free(backend->ctx);\n  backend->ctx = SSL_CTX_new(req_method);\n\n  if(!backend->ctx) {\n    failf(data, \"SSL: couldn't create a context!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  switch(SSL_CONN_CONFIG(version)) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX > 0x03004006 /* > 3.4.6 */\n    /* Versions 3.3.0 to 3.4.6 we know the minimum protocol version is\n     * whatever minimum version of TLS was built in and at least TLS 1.0. For\n     * later library versions that could change (eg TLS 1.0 built in but\n     * defaults to TLS 1.1) so we have this short circuit evaluation to find\n     * the minimum supported TLS version.\n    */\n    if((wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_2) != 1)\n#ifdef WOLFSSL_TLS13\n       && (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_3) != 1)\n#endif\n      ) {\n      failf(data, \"SSL: couldn't set the minimum protocol version\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif\n    break;\n  }\n\n  ciphers = SSL_CONN_CONFIG(cipher_list);\n  if(ciphers) {\n    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    infof(data, \"Cipher selection: %s\\n\", ciphers);\n  }\n\n#ifndef NO_FILESYSTEM\n  /* load trusted cacert */\n  if(SSL_CONN_CONFIG(CAfile)) {\n    if(1 != SSL_CTX_load_verify_locations(backend->ctx,\n                                      SSL_CONN_CONFIG(CAfile),\n                                      SSL_CONN_CONFIG(CApath))) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        /* Fail if we insist on successfully verifying the server. */\n        failf(data, \"error setting certificate verify locations:\"\n              \" CAfile: %s CApath: %s\",\n              SSL_CONN_CONFIG(CAfile)?\n              SSL_CONN_CONFIG(CAfile): \"none\",\n              SSL_CONN_CONFIG(CApath)?\n              SSL_CONN_CONFIG(CApath) : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"error setting certificate verify locations,\"\n              \" continuing anyway:\\n\");\n      }\n    }\n    else {\n      /* Everything is fine. */\n      infof(data, \"successfully set certificate verify locations:\\n\");\n    }\n    infof(data, \" CAfile: %s\\n\",\n          SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile) : \"none\");\n    infof(data, \" CApath: %s\\n\",\n          SSL_CONN_CONFIG(CApath) ? SSL_CONN_CONFIG(CApath) : \"none\");\n  }\n\n  /* Load the client certificate, and private key */\n  if(SSL_SET_OPTION(primary.clientcert) && SSL_SET_OPTION(key)) {\n    int file_type = do_file_type(SSL_SET_OPTION(cert_type));\n\n    if(SSL_CTX_use_certificate_file(backend->ctx,\n                                    SSL_SET_OPTION(primary.clientcert),\n                                    file_type) != 1) {\n      failf(data, \"unable to use client certificate (no key or wrong pass\"\n            \" phrase?)\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    file_type = do_file_type(SSL_SET_OPTION(key_type));\n    if(SSL_CTX_use_PrivateKey_file(backend->ctx, SSL_SET_OPTION(key),\n                                    file_type) != 1) {\n      failf(data, \"unable to set private key\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* !NO_FILESYSTEM */\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n  SSL_CTX_set_verify(backend->ctx,\n                     SSL_CONN_CONFIG(verifypeer)?SSL_VERIFY_PEER:\n                                                 SSL_VERIFY_NONE,\n                     NULL);\n\n#ifdef HAVE_SNI\n  if(sni) {\n    struct in_addr addr4;\n#ifdef ENABLE_IPV6\n    struct in6_addr addr6;\n#endif\n    const char * const hostname = SSL_HOST_NAME();\n    size_t hostname_len = strlen(hostname);\n    if((hostname_len < USHRT_MAX) &&\n       (0 == Curl_inet_pton(AF_INET, hostname, &addr4)) &&\n#ifdef ENABLE_IPV6\n       (0 == Curl_inet_pton(AF_INET6, hostname, &addr6)) &&\n#endif\n       (wolfSSL_CTX_UseSNI(backend->ctx, WOLFSSL_SNI_HOST_NAME, hostname,\n                          (unsigned short)hostname_len) != 1)) {\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n    }\n  }\n#endif\n\n  /* give application a chance to interfere with SSL set up. */\n  if(data->set.ssl.fsslctx) {\n    CURLcode result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n                                               data->set.ssl.fsslctxp);\n    if(result) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return result;\n    }\n  }\n#ifdef NO_FILESYSTEM\n  else if(SSL_CONN_CONFIG(verifypeer)) {\n    failf(data, \"SSL: Certificates can't be loaded because wolfSSL was built\"\n          \" with \\\"no filesystem\\\". Either disable peer verification\"\n          \" (insecure) or if you are building an application with libcurl you\"\n          \" can load certificates via CURLOPT_SSL_CTX_FUNCTION.\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif\n\n  /* Let's make an SSL structure */\n  if(backend->handle)\n    SSL_free(backend->handle);\n  backend->handle = SSL_new(backend->ctx);\n  if(!backend->handle) {\n    failf(data, \"SSL: couldn't create a context (handle)!\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifdef HAVE_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    char protocols[128];\n    *protocols = '\\0';\n\n    /* wolfSSL's ALPN protocol name list format is a comma separated string of\n       protocols in descending order of preference, eg: \"h2,http/1.1\" */\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      strcpy(protocols + strlen(protocols), ALPN_H2 \",\");\n      infof(data, \"ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    strcpy(protocols + strlen(protocols), ALPN_HTTP_1_1);\n    infof(data, \"ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    if(wolfSSL_UseALPN(backend->handle, protocols,\n                       (unsigned)strlen(protocols),\n                       WOLFSSL_ALPN_CONTINUE_ON_MISMATCH) != SSL_SUCCESS) {\n      failf(data, \"SSL: failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* HAVE_ALPN */\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* Ensure the Client Random is preserved. */\n    wolfSSL_KeepArrays(backend->handle);\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\n    wolfSSL_set_tls13_secret_cb(backend->handle,\n                                wolfssl_tls13_secret_callback, NULL);\n#endif\n  }\n#endif /* OPENSSL_EXTRA */\n\n#ifdef HAVE_SECURE_RENEGOTIATION\n  if(wolfSSL_UseSecureRenegotiation(backend->handle) != SSL_SUCCESS) {\n    failf(data, \"SSL: failed setting secure renegotiation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* HAVE_SECURE_RENEGOTIATION */\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ERR_error_string(SSL_get_error(backend->handle, 0),\n                               error_buffer));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  /* pass the raw socket into the SSL layer */\n  if(!SSL_set_fd(backend->handle, (int)sockfd)) {\n    failf(data, \"SSL: SSL_set_fd failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step2(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  int ret = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  const char * const hostname = SSL_HOST_NAME();\n  const char * const dispname = SSL_HOST_DISPNAME();\n  const char * const pinnedpubkey = SSL_PINNED_PUB_KEY();\n\n  conn->recv[sockindex] = wolfssl_recv;\n  conn->send[sockindex] = wolfssl_send;\n\n  /* Enable RFC2818 checks */\n  if(SSL_CONN_CONFIG(verifyhost)) {\n    ret = wolfSSL_check_domain_name(backend->handle, hostname);\n    if(ret == SSL_FAILURE)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  ret = SSL_connect(backend->handle);\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* If key logging is enabled, wait for the handshake to complete and then\n     * proceed with logging secrets (for TLS 1.2 or older).\n     *\n     * During the handshake (ret==-1), wolfSSL_want_read() is true as it waits\n     * for the server response. At that point the master secret is not yet\n     * available, so we must not try to read it.\n     * To log the secret on completion with a handshake failure, detect\n     * completion via the observation that there is nothing to read or write.\n     * Note that OpenSSL SSL_want_read() is always true here. If wolfSSL ever\n     * changes, the worst case is that no key is logged on error.\n     */\n    if(ret == SSL_SUCCESS ||\n       (!wolfSSL_want_read(backend->handle) &&\n        !wolfSSL_want_write(backend->handle))) {\n      wolfssl_log_tls12_secret(backend->handle);\n      /* Client Random and master secrets are no longer needed, erase these.\n       * Ignored while the handshake is still in progress. */\n      wolfSSL_FreeArrays(backend->handle);\n    }\n  }\n#endif  /* OPENSSL_EXTRA */\n\n  if(ret != 1) {\n    char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n    int  detail = SSL_get_error(backend->handle, ret);\n\n    if(SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    else if(SSL_ERROR_WANT_WRITE == detail) {\n      connssl->connecting_state = ssl_connect_2_writing;\n      return CURLE_OK;\n    }\n    /* There is no easy way to override only the CN matching.\n     * This will enable the override of both mismatching SubjectAltNames\n     * as also mismatching CN fields */\n    else if(DOMAIN_NAME_MISMATCH == detail) {\n#if 1\n      failf(data, \"\\tsubject alt name(s) or common name do not match \\\"%s\\\"\",\n            dispname);\n      return CURLE_PEER_FAILED_VERIFICATION;\n#else\n      /* When the wolfssl_check_domain_name() is used and you desire to\n       * continue on a DOMAIN_NAME_MISMATCH, i.e. 'conn->ssl_config.verifyhost\n       * == 0', CyaSSL version 2.4.0 will fail with an INCOMPLETE_DATA\n       * error. The only way to do this is currently to switch the\n       * Wolfssl_check_domain_name() in and out based on the\n       * 'conn->ssl_config.verifyhost' value. */\n      if(SSL_CONN_CONFIG(verifyhost)) {\n        failf(data,\n              \"\\tsubject alt name(s) or common name do not match \\\"%s\\\"\\n\",\n              dispname);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else {\n        infof(data,\n              \"\\tsubject alt name(s) and/or common name do not match \\\"%s\\\"\\n\",\n              dispname);\n        return CURLE_OK;\n      }\n#endif\n    }\n#if LIBWOLFSSL_VERSION_HEX >= 0x02007000 /* 2.7.0 */\n    else if(ASN_NO_SIGNER_E == detail) {\n      if(SSL_CONN_CONFIG(verifypeer)) {\n        failf(data, \"\\tCA signer not available for verification\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"CA signer not available for verification, \"\n                    \"continuing anyway\\n\");\n      }\n    }\n#endif\n    else {\n      failf(data, \"SSL_connect failed with error %d: %s\", detail,\n          ERR_error_string(detail, error_buffer));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  if(pinnedpubkey) {\n#ifdef KEEP_PEER_CERT\n    X509 *x509;\n    const char *x509_der;\n    int x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n    CURLcode result;\n\n    x509 = SSL_get_peer_certificate(backend->handle);\n    if(!x509) {\n      failf(data, \"SSL: failed retrieving server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    x509_der = (const char *)wolfSSL_X509_get_der(x509, &x509_der_len);\n    if(!x509_der) {\n      failf(data, \"SSL: failed retrieving ASN.1 server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key!\");\n      return result;\n    }\n#else\n    failf(data, \"Library lacks pinning support built-in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n#ifdef HAVE_ALPN\n  if(conn->bits.tls_enable_alpn) {\n    int rc;\n    char *protocol = NULL;\n    unsigned short protocol_len = 0;\n\n    rc = wolfSSL_ALPN_GetProtocol(backend->handle, &protocol, &protocol_len);\n\n    if(rc == SSL_SUCCESS) {\n      infof(data, \"ALPN, server accepted to use %.*s\\n\", protocol_len,\n            protocol);\n\n      if(protocol_len == ALPN_HTTP_1_1_LENGTH &&\n         !memcmp(protocol, ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH))\n        conn->negnpn = CURL_HTTP_VERSION_1_1;\n#ifdef USE_HTTP2\n      else if(data->state.httpwant >= CURL_HTTP_VERSION_2 &&\n              protocol_len == ALPN_H2_LENGTH &&\n              !memcmp(protocol, ALPN_H2, ALPN_H2_LENGTH))\n        conn->negnpn = CURL_HTTP_VERSION_2;\n#endif\n      else\n        infof(data, \"ALPN, unrecognized protocol %.*s\\n\", protocol_len,\n              protocol);\n      Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?\n                          BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);\n    }\n    else if(rc == SSL_ALPN_NOT_FOUND)\n      infof(data, \"ALPN, server did not agree to a protocol\\n\");\n    else {\n      failf(data, \"ALPN, failure getting protocol, error %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* HAVE_ALPN */\n\n  connssl->connecting_state = ssl_connect_3;\n#if (LIBWOLFSSL_VERSION_HEX >= 0x03009010)\n  infof(data, \"SSL connection using %s / %s\\n\",\n        wolfSSL_get_version(backend->handle),\n        wolfSSL_get_cipher_name(backend->handle));\n#else\n  infof(data, \"SSL connected\\n\");\n#endif\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n                     int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    SSL_SESSION *our_ssl_sessionid = SSL_get_session(backend->handle);\n    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\n    if(our_ssl_sessionid) {\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                        &old_ssl_sessionid, NULL, sockindex));\n      if(incache) {\n        if(old_ssl_sessionid != our_ssl_sessionid) {\n          infof(data, \"old SSL session ID is stale, removing\\n\");\n          Curl_ssl_delsessionid(data, old_ssl_sessionid);\n          incache = FALSE;\n        }\n      }\n\n      if(!incache) {\n        result = Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid,\n                                       0, sockindex);\n        if(result) {\n          Curl_ssl_sessionid_unlock(data);\n          failf(data, \"failed to store ssl session\");\n          return result;\n        }\n      }\n      Curl_ssl_sessionid_unlock(data);\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\n\nstatic ssize_t wolfssl_send(struct Curl_easy *data,\n                            int sockindex,\n                            const void *mem,\n                            size_t len,\n                            CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  int rc = SSL_write(backend->handle, mem, memlen);\n\n  if(rc <= 0) {\n    int err = SSL_get_error(backend->handle, rc);\n\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_write() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data, \"SSL write: %s, errno %d\",\n            ERR_error_string(err, error_buffer),\n            SOCKERRNO);\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n  return rc;\n}\n\nstatic void wolfssl_close(struct Curl_easy *data, struct connectdata *conn,\n                          int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->handle) {\n    (void)SSL_shutdown(backend->handle);\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  if(backend->ctx) {\n    SSL_CTX_free(backend->ctx);\n    backend->ctx = NULL;\n  }\n}\n\nstatic ssize_t wolfssl_recv(struct Curl_easy *data,\n                            int num,\n                            char *buf,\n                            size_t buffersize,\n                            CURLcode *curlcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[num];\n  struct ssl_backend_data *backend = connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;\n  int nread = SSL_read(backend->handle, buf, buffsize);\n\n  if(nread < 0) {\n    int err = SSL_get_error(backend->handle, nread);\n\n    switch(err) {\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n      break;\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_read() */\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      failf(data, \"SSL read: %s, errno %d\",\n            ERR_error_string(err, error_buffer), SOCKERRNO);\n      *curlcode = CURLE_RECV_ERROR;\n      return -1;\n    }\n  }\n  return nread;\n}\n\n\nstatic void wolfssl_session_free(void *ptr)\n{\n  (void)ptr;\n  /* wolfSSL reuses sessions on own, no free */\n}\n\n\nstatic size_t wolfssl_version(char *buffer, size_t size)\n{\n#if LIBWOLFSSL_VERSION_HEX >= 0x03006000\n  return msnprintf(buffer, size, \"wolfSSL/%s\", wolfSSL_lib_version());\n#elif defined(WOLFSSL_VERSION)\n  return msnprintf(buffer, size, \"wolfSSL/%s\", WOLFSSL_VERSION);\n#endif\n}\n\n\nstatic int wolfssl_init(void)\n{\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_open();\n#endif\n  return (wolfSSL_Init() == SSL_SUCCESS);\n}\n\n\nstatic void wolfssl_cleanup(void)\n{\n  wolfSSL_Cleanup();\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_close();\n#endif\n}\n\n\nstatic bool wolfssl_data_pending(const struct connectdata *conn,\n                                 int connindex)\n{\n  const struct ssl_connect_data *connssl = &conn->ssl[connindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(backend->handle)   /* SSL is in use */\n    return (0 != SSL_pending(backend->handle)) ? TRUE : FALSE;\n  else\n    return FALSE;\n}\n\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int wolfssl_shutdown(struct Curl_easy *data, struct connectdata *conn,\n                            int sockindex)\n{\n  int retval = 0;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  (void) data;\n\n  if(backend->handle) {\n    SSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  return retval;\n}\n\n\nstatic CURLcode\nwolfssl_connect_common(struct Curl_easy *data,\n                      struct connectdata *conn,\n                      int sockindex,\n                      bool nonblocking,\n                      bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  curl_socket_t sockfd = conn->sock[sockindex];\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = wolfssl_connect_step1(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = wolfssl_connect_step2(data, conn, sockindex);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = wolfssl_connect_step3(data, conn, sockindex);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    conn->recv[sockindex] = wolfssl_recv;\n    conn->send[sockindex] = wolfssl_send;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode wolfssl_connect_nonblocking(struct Curl_easy *data,\n                                            struct connectdata *conn,\n                                            int sockindex, bool *done)\n{\n  return wolfssl_connect_common(data, conn, sockindex, TRUE, done);\n}\n\n\nstatic CURLcode wolfssl_connect(struct Curl_easy *data,\n                                struct connectdata *conn, int sockindex)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = wolfssl_connect_common(data, conn, sockindex, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n  WC_RNG rng;\n  (void)data;\n  if(wc_InitRng(&rng))\n    return CURLE_FAILED_INIT;\n  if(length > UINT_MAX)\n    return CURLE_FAILED_INIT;\n  if(wc_RNG_GenerateBlock(&rng, entropy, (unsigned)length))\n    return CURLE_FAILED_INIT;\n  if(wc_FreeRng(&rng))\n    return CURLE_FAILED_INIT;\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_sha256sum(const unsigned char *tmp, /* input */\n                                  size_t tmplen,\n                                  unsigned char *sha256sum /* output */,\n                                  size_t unused)\n{\n  wc_Sha256 SHA256pw;\n  (void)unused;\n  wc_InitSha256(&SHA256pw);\n  wc_Sha256Update(&SHA256pw, tmp, (word32)tmplen);\n  wc_Sha256Final(&SHA256pw, sha256sum);\n  return CURLE_OK;\n}\n\nstatic void *wolfssl_get_internals(struct ssl_connect_data *connssl,\n                                        CURLINFO info UNUSED_PARAM)\n{\n  struct ssl_backend_data *backend = connssl->backend;\n  (void)info;\n  return backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_wolfssl = {\n  { CURLSSLBACKEND_WOLFSSL, \"WolfSSL\" }, /* info */\n\n#ifdef KEEP_PEER_CERT\n  SSLSUPP_PINNEDPUBKEY |\n#endif\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct ssl_backend_data),\n\n  wolfssl_init,                    /* init */\n  wolfssl_cleanup,                 /* cleanup */\n  wolfssl_version,                 /* version */\n  Curl_none_check_cxn,             /* check_cxn */\n  wolfssl_shutdown,                /* shutdown */\n  wolfssl_data_pending,            /* data_pending */\n  wolfssl_random,                  /* random */\n  Curl_none_cert_status_request,   /* cert_status_request */\n  wolfssl_connect,                 /* connect */\n  wolfssl_connect_nonblocking,     /* connect_nonblocking */\n  Curl_ssl_getsock,                /* getsock */\n  wolfssl_get_internals,           /* get_internals */\n  wolfssl_close,                   /* close_one */\n  Curl_none_close_all,             /* close_all */\n  wolfssl_session_free,            /* session_free */\n  Curl_none_set_engine,            /* set_engine */\n  Curl_none_set_engine_default,    /* set_engine_default */\n  Curl_none_engines_list,          /* engines_list */\n  Curl_none_false_start,           /* false_start */\n  wolfssl_sha256sum,               /* sha256sum */\n  NULL,                            /* associate_connection */\n  NULL                             /* disassociate_connection */\n};\n\n#endif\n"], "filenames": ["lib/multi.c", "lib/vtls/gskit.c", "lib/vtls/gtls.c", "lib/vtls/mbedtls.c", "lib/vtls/mesalink.c", "lib/vtls/nss.c", "lib/vtls/openssl.c", "lib/vtls/rustls.c", "lib/vtls/schannel.c", "lib/vtls/sectransp.c", "lib/vtls/vtls.c", "lib/vtls/vtls.h", "lib/vtls/wolfssl.c"], "buggy_code_start_loc": [881, 1307, 1659, 1096, 669, 2468, 241, 607, 332, 3455, 588, 86, 1128], "buggy_code_end_loc": [900, 1308, 1660, 1097, 670, 2469, 4540, 608, 2437, 3455, 1218, 311, 1129], "fixing_code_start_loc": [881, 1307, 1659, 1096, 669, 2468, 242, 607, 332, 3456, 589, 87, 1128], "fixing_code_end_loc": [904, 1310, 1662, 1099, 672, 2471, 4608, 610, 2439, 3458, 1239, 324, 1131], "type": "CWE-416", "message": "curl 7.75.0 through 7.76.1 suffers from a use-after-free vulnerability resulting in already freed memory being used when a TLS 1.3 session ticket arrives over a connection. A malicious server can use this in rare unfortunate circumstances to potentially reach remote code execution in the client. When libcurl at run-time sets up support for TLS 1.3 session tickets on a connection using OpenSSL, it stores pointers to the transfer in-memory object for later retrieval when a session ticket arrives. If the connection is used by multiple transfers (like with a reused HTTP/1.1 connection or multiplexed HTTP/2 connection) that first transfer object might be freed before the new session is established on that connection and then the function will access a memory buffer that might be freed. When using that memory, libcurl might even call a function pointer in the object, making it possible for a remote code execution if the server could somehow manage to get crafted memory content into the correct place in memory.", "other": {"cve": {"id": "CVE-2021-22901", "sourceIdentifier": "support@hackerone.com", "published": "2021-06-11T16:15:11.120", "lastModified": "2022-05-13T17:30:02.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "curl 7.75.0 through 7.76.1 suffers from a use-after-free vulnerability resulting in already freed memory being used when a TLS 1.3 session ticket arrives over a connection. A malicious server can use this in rare unfortunate circumstances to potentially reach remote code execution in the client. When libcurl at run-time sets up support for TLS 1.3 session tickets on a connection using OpenSSL, it stores pointers to the transfer in-memory object for later retrieval when a session ticket arrives. If the connection is used by multiple transfers (like with a reused HTTP/1.1 connection or multiplexed HTTP/2 connection) that first transfer object might be freed before the new session is established on that connection and then the function will access a memory buffer that might be freed. When using that memory, libcurl might even call a function pointer in the object, making it possible for a remote code execution if the server could somehow manage to get crafted memory content into the correct place in memory."}, {"lang": "es", "value": "curl versiones 7.75.0 hasta 7.76.1 sufre de una vulnerabilidad de uso de la memoria previamente liberada que resulta en el uso de memoria ya liberada cuando un ticket de sesi\u00f3n TLS 1.3 llega a trav\u00e9s de una conexi\u00f3n. Un servidor malicioso puede usar esto en raras circunstancias desafortunadas para alcanzar potencialmente la ejecuci\u00f3n de c\u00f3digo remota en el cliente. Cuando libcurl en tiempo de ejecuci\u00f3n configura el soporte para tickets de sesi\u00f3n TLS 1.3 en una conexi\u00f3n usando OpenSSL, almacena punteros al objeto de transferencia en memoria para su posterior recuperaci\u00f3n cuando llega un ticket de sesi\u00f3n. Si la conexi\u00f3n es usada por m\u00faltiples transferencias (como en el caso de una conexi\u00f3n HTTP/1.1 reutilizada o una conexi\u00f3n HTTP/2 multiplexada) ese primer objeto de transferencia podr\u00eda ser liberado antes de que se establezca la nueva sesi\u00f3n en esa conexi\u00f3n y entonces la funci\u00f3n acceder\u00e1 a un b\u00fafer de memoria que podr\u00eda ser liberado. Al utilizar esa memoria, libcurl podr\u00eda incluso llamar a un puntero de funci\u00f3n en el objeto, haciendo posible una ejecuci\u00f3n de c\u00f3digo remota si el servidor pudiera de alguna manera conseguir el contenido de la memoria dise\u00f1ada en el lugar correcto de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haxx:curl:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.75.0", "versionEndIncluding": "7.76.1", "matchCriteriaId": "220650BF-E1B2-41F9-A9FA-978356E63FB7"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:1.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "10323322-F6C0-4EA7-9344-736F7A80AA5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_function_cloud_native_environment:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2A5B24D-BDF2-423C-98EA-A40778C01A05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "6F60E32F-0CA0-4C2D-9848-CB92765A9ACB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "DF616620-88CE-4A77-B904-C1728A2E6F9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:1.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "3AA09838-BF13-46AC-BB97-A69F48B73A8A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_service_communication_proxy:1.15.0:*:*:*:*:*:*:*", "matchCriteriaId": "175B97A7-0B00-4378-AD9F-C01B6D9FD570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.1.2.4.047", "matchCriteriaId": "6A0BD5BD-E2F8-4B4E-B5CF-9787E6F2E4AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:essbase:*:*:*:*:*:*:*:*", "versionStartIncluding": "21.0", "versionEndExcluding": "21.3", "matchCriteriaId": "3197F464-F0A5-4BD4-9068-65CD448D8F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.7.34", "matchCriteriaId": "10630209-CF90-455D-B70F-DB50BAFC5499"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "8.0.25", "matchCriteriaId": "181677F8-59EE-49BC-91A7-845819742869"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vsphere:*:*", "matchCriteriaId": "E8F29E19-3A64-4426-A2AA-F169440267CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_insight:-:*:*:*:*:*:*:*", "matchCriteriaId": "F1BE6C1F-2565-4E97-92AA-16563E5660A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-732250.pdf", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://curl.se/docs/CVE-2021-22901.html", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/curl/curl/commit/7f4a9a9b2a49547eae24d2e19bc5c346e9026479", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1180380", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210723-0001/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210727-0007/", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/curl/curl/commit/7f4a9a9b2a49547eae24d2e19bc5c346e9026479"}}