{"buggy_code": ["\" Test that the methods used for testing work.\n\nfunc Test_assert_false()\n  call assert_equal(0, assert_false(0))\n  call assert_equal(0, assert_false(v:false))\n  call assert_equal(0, v:false->assert_false())\n\n  call assert_equal(1, assert_false(123))\n  call assert_match(\"Expected 'False' but got 123\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 123->assert_false())\n  call assert_match(\"Expected 'False' but got 123\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_true()\n  call assert_equal(0, assert_true(1))\n  call assert_equal(0, assert_true(123))\n  call assert_equal(0, assert_true(v:true))\n  call assert_equal(0, v:true->assert_true())\n\n  call assert_equal(1, assert_true(0))\n  call assert_match(\"Expected 'True' but got 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 0->assert_true())\n  call assert_match(\"Expected 'True' but got 0\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_equal()\n  let s = 'foo'\n  call assert_equal(0, assert_equal('foo', s))\n  let n = 4\n  call assert_equal(0, assert_equal(4, n))\n  let l = [1, 2, 3]\n  call assert_equal(0, assert_equal([1, 2, 3], l))\n  call assert_equal(test_null_list(), test_null_list())\n  call assert_equal(test_null_list(), [])\n  call assert_equal([], test_null_list())\n\n  let s = 'foo'\n  call assert_equal(1, assert_equal('bar', s))\n  call assert_match(\"Expected 'bar' but got 'foo'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal('XxxxxxxxxxxxxxxxxxxxxxX', 'XyyyyyyyyyyyyyyyyyyyyyyyyyX')\n  call assert_match(\"Expected 'X\\\\\\\\\\\\[x occurs 21 times]X' but got 'X\\\\\\\\\\\\[y occurs 25 times]X'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  \" special characters are escaped\n  call assert_equal(\"\\b\\e\\f\\n\\t\\r\\\\\\x01\\x7f\", 'x')\n  call assert_match('Expected ''\\\\b\\\\e\\\\f\\\\n\\\\t\\\\r\\\\\\\\\\\\x01\\\\x7f'' but got ''x''', v:errors[0])\n  call remove(v:errors, 0)\n\n  \" many composing characters are handled properly\n  call setline(1, ' ')\n  norm 100gr\u0740\n  call assert_equal(1, getline(1))\n  call assert_match(\"Expected 1 but got '.* occurs 100 times]'\", v:errors[0])\n  call remove(v:errors, 0)\n  bwipe!\nendfunc\n\nfunc Test_assert_equal_dict()\n  call assert_equal(0, assert_equal(#{one: 1, two: 2}, #{two: 2, one: 1}))\n\n  call assert_equal(1, assert_equal(#{one: 1, two: 2}, #{two: 2, one: 3}))\n  call assert_match(\"Expected {'one': 1} but got {'one': 3} - 1 equal item omitted\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{one: 1, two: 2}, #{two: 22, one: 11}))\n  call assert_match(\"Expected {'one': 1, 'two': 2} but got {'one': 11, 'two': 22}\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{}, #{two: 2, one: 1}))\n  call assert_match(\"Expected {} but got {'one': 1, 'two': 2}\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{two: 2, one: 1}, #{}))\n  call assert_match(\"Expected {'one': 1, 'two': 2} but got {}\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_equalfile()\n  call assert_equal(1, assert_equalfile('abcabc', 'xyzxyz'))\n  call assert_match(\"E485: Can't read file abcabc\", v:errors[0])\n  call remove(v:errors, 0)\n\n  let goodtext = [\"one\", \"two\", \"three\"]\n  call writefile(goodtext, 'Xone')\n  call assert_equal(1, 'Xone'->assert_equalfile('xyzxyz'))\n  call assert_match(\"E485: Can't read file xyzxyz\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(goodtext, 'Xtwo')\n  call assert_equal(0, assert_equalfile('Xone', 'Xtwo'))\n\n  call writefile([goodtext[0]], 'Xone')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match(\"first file is shorter\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(goodtext, 'Xone')\n  call writefile([goodtext[0]], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match(\"second file is shorter\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(['1234X89'], 'Xone')\n  call writefile(['1234Y89'], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match('difference at byte 4, line 1 after \"1234X\" vs \"1234Y\"', v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile([repeat('x', 234) .. 'X'], 'Xone')\n  call writefile([repeat('x', 234) .. 'Y'], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  let xes = repeat('x', 134)\n  call assert_match('difference at byte 234, line 1 after \"' .. xes .. 'X\" vs \"' .. xes .. 'Y\"', v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo', 'a message'))\n  call assert_match(\"a message: difference at byte 234, line 1 after\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call delete('Xone')\n  call delete('Xtwo')\nendfunc\n\nfunc Test_assert_notequal()\n  let n = 4\n  call assert_equal(0, assert_notequal('foo', n))\n  let s = 'foo'\n  call assert_equal(0, assert_notequal([1, 2, 3], s))\n\n  call assert_equal(1, assert_notequal('foo', s))\n  call assert_match(\"Expected not equal to 'foo'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_report()\n  call assert_equal(1, assert_report('something is wrong'))\n  call assert_match('something is wrong', v:errors[0])\n  call remove(v:errors, 0)\n  call assert_equal(1, 'also wrong'->assert_report())\n  call assert_match('also wrong', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_exception()\n  try\n    nocommand\n  catch\n    call assert_equal(0, assert_exception('E492:'))\n  endtry\n\n  try\n    nocommand\n  catch\n    call assert_equal(1, assert_exception('E12345:'))\n  endtry\n  call assert_match(\"Expected 'E12345:' but got 'Vim:E492: \", v:errors[0])\n  call remove(v:errors, 0)\n\n  try\n    nocommand\n  catch\n    try\n      \" illegal argument, get NULL for error\n      call assert_equal(1, assert_exception([]))\n    catch\n      call assert_equal(0, assert_exception('E730:'))\n    endtry\n  endtry\n\n  call assert_equal(1, assert_exception('E492:'))\n  call assert_match('v:exception is not set', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_wrong_error_type()\n  let save_verrors = v:errors\n  let v:['errors'] = {'foo': 3}\n  call assert_equal('yes', 'no')\n  let verrors = v:errors\n  let v:errors = save_verrors\n  call assert_equal(type([]), type(verrors))\nendfunc\n\nfunc Test_compare_fail()\n  let s:v = {}          \n  let s:x = {\"a\": s:v} \n  let s:v[\"b\"] = s:x   \n  let s:w = {\"c\": s:x, \"d\": ''}\n  try\n    call assert_equal(s:w, '')\n  catch\n    call assert_equal(0, assert_exception('E724:'))\n    call assert_match(\"Expected NULL but got ''\", v:errors[0])\n    call remove(v:errors, 0)\n  endtry\nendfunc\n\nfunc Test_match()\n  call assert_equal(0, assert_match('^f.*b.*r$', 'foobar'))\n\n  call assert_equal(1, assert_match('bar.*foo', 'foobar'))\n  call assert_match(\"Pattern 'bar.*foo' does not match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_match('bar.*foo', 'foobar', 'wrong'))\n  call assert_match('wrong', v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'foobar'->assert_match('bar.*foo', 'wrong'))\n  call assert_match('wrong', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_notmatch()\n  call assert_equal(0, assert_notmatch('foo', 'bar'))\n  call assert_equal(0, assert_notmatch('^foobar$', 'foobars'))\n\n  call assert_equal(1, assert_notmatch('foo', 'foobar'))\n  call assert_match(\"Pattern 'foo' does match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'foobar'->assert_notmatch('foo'))\n  call assert_match(\"Pattern 'foo' does match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_fail_fails()\n  call assert_equal(1, assert_fails('xxx', 'E12345'))\n  call assert_match(\"Expected 'E12345' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', 'E9876', 'stupid'))\n  call assert_match(\"stupid: Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', ['E9876']))\n  call assert_match(\"Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', ['E492:', 'E9876']))\n  call assert_match(\"Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('echo', '', 'echo command'))\n  call assert_match(\"command did not fail: echo command\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'echo'->assert_fails('', 'echo command'))\n  call assert_match(\"command did not fail: echo command\", v:errors[0])\n  call remove(v:errors, 0)\n\n  try\n    call assert_equal(1, assert_fails('xxx', []))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E856: \\\"assert_fails()\\\" second argument\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', ['1', '2', '3']))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E856: \\\"assert_fails()\\\" second argument\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', #{one: 1}))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1222: String or List required for argument 2\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', 'E492', '', 'burp'))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1210: Number required for argument 4\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', 'E492', '', 54, 123))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1174: String required for argument 5\", exp)\nendfunc\n\nfunc Test_assert_fails_in_try_block()\n  try\n    call assert_equal(0, assert_fails('throw \"error\"'))\n  endtry\nendfunc\n\nfunc Test_assert_beeps()\n  new\n  call assert_equal(0, assert_beeps('normal h'))\n\n  call assert_equal(1, assert_beeps('normal 0'))\n  call assert_match(\"command did not beep: normal 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(0, 'normal h'->assert_beeps())\n  call assert_equal(1, 'normal 0'->assert_beeps())\n  call assert_match(\"command did not beep: normal 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  bwipe\nendfunc\n\nfunc Test_assert_inrange()\n  call assert_equal(0, assert_inrange(7, 7, 7))\n  call assert_equal(0, assert_inrange(5, 7, 5))\n  call assert_equal(0, assert_inrange(5, 7, 6))\n  call assert_equal(0, assert_inrange(5, 7, 7))\n\n  call assert_equal(1, assert_inrange(5, 7, 4))\n  call assert_match(\"Expected range 5 - 7, but got 4\", v:errors[0])\n  call remove(v:errors, 0)\n  call assert_equal(1, assert_inrange(5, 7, 8))\n  call assert_match(\"Expected range 5 - 7, but got 8\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(0, 5->assert_inrange(5, 7))\n  call assert_equal(0, 7->assert_inrange(5, 7))\n  call assert_equal(1, 8->assert_inrange(5, 7))\n  call assert_match(\"Expected range 5 - 7, but got 8\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_fails('call assert_inrange(1, 1)', 'E119:')\n\n  if has('float')\n    call assert_equal(0, assert_inrange(7.0, 7, 7))\n    call assert_equal(0, assert_inrange(7, 7.0, 7))\n    call assert_equal(0, assert_inrange(7, 7, 7.0))\n    call assert_equal(0, assert_inrange(5, 7, 5.0))\n    call assert_equal(0, assert_inrange(5, 7, 6.0))\n    call assert_equal(0, assert_inrange(5, 7, 7.0))\n\n    call assert_equal(1, assert_inrange(5, 7, 4.0))\n    call assert_match(\"Expected range 5.0 - 7.0, but got 4.0\", v:errors[0])\n    call remove(v:errors, 0)\n    call assert_equal(1, assert_inrange(5, 7, 8.0))\n    call assert_match(\"Expected range 5.0 - 7.0, but got 8.0\", v:errors[0])\n    call remove(v:errors, 0)\n  endif\nendfunc\n\nfunc Test_assert_with_msg()\n  call assert_equal('foo', 'bar', 'testing')\n  call assert_match(\"testing: Expected 'foo' but got 'bar'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_override()\n  call test_override('char_avail', 1)\n  eval 1->test_override('redraw')\n  call test_override('ALL', 0)\n  call assert_fails(\"call test_override('xxx', 1)\", 'E475:')\n  call assert_fails(\"call test_override('redraw', 'yes')\", 'E474:')\nendfunc\n\nfunc Test_mouse_position()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n  call setline(1, ['line one', 'line two'])\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call test_setmouse(1, 5)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 0], getpos('.'))\n  call test_setmouse(2, 20)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 2, 8, 0], getpos('.'))\n  call test_setmouse(5, 1)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call assert_fails('call test_setmouse(\"\", 2)', 'E474:')\n  call assert_fails('call test_setmouse(1, \"\")', 'E474:')\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_user_is_happy()\n  smile\n  sleep 300m\nendfunc\n\n\" Must be last.\nfunc Test_zz_quit_detected()\n  \" Verify that if a test function ends Vim the test script detects this.\n  quit\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * testing.c: Support for tests.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Prepare \"gap\" for an assert error and add the sourcing position.\n */\n    static void\nprepare_assert_error(garray_T *gap)\n{\n    char    buf[NUMBUFLEN];\n    char_u  *sname = estack_sfile(ESTACK_NONE);\n\n    ga_init2(gap, 1, 100);\n    if (sname != NULL)\n    {\n\tga_concat(gap, sname);\n\tif (SOURCING_LNUM > 0)\n\t    ga_concat(gap, (char_u *)\" \");\n    }\n    if (SOURCING_LNUM > 0)\n    {\n\tsprintf(buf, \"line %ld\", (long)SOURCING_LNUM);\n\tga_concat(gap, (char_u *)buf);\n    }\n    if (sname != NULL || SOURCING_LNUM > 0)\n\tga_concat(gap, (char_u *)\": \");\n    vim_free(sname);\n}\n\n/*\n * Append \"p[clen]\" to \"gap\", escaping unprintable characters.\n * Changes NL to \\n, CR to \\r, etc.\n */\n    static void\nga_concat_esc(garray_T *gap, char_u *p, int clen)\n{\n    char_u  buf[NUMBUFLEN];\n\n    if (clen > 1)\n    {\n\tmch_memmove(buf, p, clen);\n\tbuf[clen] = NUL;\n\tga_concat(gap, buf);\n    }\n    else switch (*p)\n    {\n\tcase BS: ga_concat(gap, (char_u *)\"\\\\b\"); break;\n\tcase ESC: ga_concat(gap, (char_u *)\"\\\\e\"); break;\n\tcase FF: ga_concat(gap, (char_u *)\"\\\\f\"); break;\n\tcase NL: ga_concat(gap, (char_u *)\"\\\\n\"); break;\n\tcase TAB: ga_concat(gap, (char_u *)\"\\\\t\"); break;\n\tcase CAR: ga_concat(gap, (char_u *)\"\\\\r\"); break;\n\tcase '\\\\': ga_concat(gap, (char_u *)\"\\\\\\\\\"); break;\n\tdefault:\n\t\t   if (*p < ' ' || *p == 0x7f)\n\t\t   {\n\t\t       vim_snprintf((char *)buf, NUMBUFLEN, \"\\\\x%02x\", *p);\n\t\t       ga_concat(gap, buf);\n\t\t   }\n\t\t   else\n\t\t       ga_append(gap, *p);\n\t\t   break;\n    }\n}\n\n/*\n * Append \"str\" to \"gap\", escaping unprintable characters.\n * Changes NL to \\n, CR to \\r, etc.\n */\n    static void\nga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_cptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}\n\n/*\n * Fill \"gap\" with information about an assert error.\n */\n    static void\nfill_assert_error(\n    garray_T\t*gap,\n    typval_T\t*opt_msg_tv,\n    char_u      *exp_str,\n    typval_T\t*exp_tv_arg,\n    typval_T\t*got_tv_arg,\n    assert_type_T atype)\n{\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*tofree;\n    typval_T\t*exp_tv = exp_tv_arg;\n    typval_T\t*got_tv = got_tv_arg;\n    int\t\tdid_copy = FALSE;\n    int\t\tomitted = 0;\n\n    if (opt_msg_tv->v_type != VAR_UNKNOWN\n\t    && !(opt_msg_tv->v_type == VAR_STRING\n\t\t&& (opt_msg_tv->vval.v_string == NULL\n\t\t    || *opt_msg_tv->vval.v_string == NUL)))\n    {\n\tga_concat(gap, echo_string(opt_msg_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n\tga_concat(gap, (char_u *)\": \");\n    }\n\n    if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH)\n\tga_concat(gap, (char_u *)\"Pattern \");\n    else if (atype == ASSERT_NOTEQUAL)\n\tga_concat(gap, (char_u *)\"Expected not equal to \");\n    else\n\tga_concat(gap, (char_u *)\"Expected \");\n    if (exp_str == NULL)\n    {\n\t// When comparing dictionaries, drop the items that are equal, so that\n\t// it's a lot easier to see what differs.\n\tif (atype != ASSERT_NOTEQUAL\n\t\t&& exp_tv->v_type == VAR_DICT && got_tv->v_type == VAR_DICT\n\t\t&& exp_tv->vval.v_dict != NULL && got_tv->vval.v_dict != NULL)\n\t{\n\t    dict_T\t*exp_d = exp_tv->vval.v_dict;\n\t    dict_T\t*got_d = got_tv->vval.v_dict;\n\t    hashitem_T\t*hi;\n\t    dictitem_T\t*item2;\n\t    int\t\ttodo;\n\n\t    did_copy = TRUE;\n\t    exp_tv->vval.v_dict = dict_alloc();\n\t    got_tv->vval.v_dict = dict_alloc();\n\t    if (exp_tv->vval.v_dict == NULL || got_tv->vval.v_dict == NULL)\n\t\treturn;\n\n\t    todo = (int)exp_d->dv_hashtab.ht_used;\n\t    for (hi = exp_d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t    {\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    item2 = dict_find(got_d, hi->hi_key, -1);\n\t\t    if (item2 == NULL || !tv_equal(&HI2DI(hi)->di_tv,\n\t\t\t\t\t\t  &item2->di_tv, FALSE, FALSE))\n\t\t    {\n\t\t\t// item of exp_d not present in got_d or values differ.\n\t\t\tdict_add_tv(exp_tv->vval.v_dict,\n\t\t\t\t\t(char *)hi->hi_key, &HI2DI(hi)->di_tv);\n\t\t\tif (item2 != NULL)\n\t\t\t    dict_add_tv(got_tv->vval.v_dict,\n\t\t\t\t\t    (char *)hi->hi_key, &item2->di_tv);\n\t\t    }\n\t\t    else\n\t\t\t++omitted;\n\t\t    --todo;\n\t\t}\n\t    }\n\n\t    // Add items only present in got_d.\n\t    todo = (int)got_d->dv_hashtab.ht_used;\n\t    for (hi = got_d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t    {\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    item2 = dict_find(exp_d, hi->hi_key, -1);\n\t\t    if (item2 == NULL)\n\t\t\t// item of got_d not present in exp_d\n\t\t\tdict_add_tv(got_tv->vval.v_dict,\n\t\t\t\t\t(char *)hi->hi_key, &HI2DI(hi)->di_tv);\n\t\t    --todo;\n\t\t}\n\t    }\n\t}\n\n\tga_concat_shorten_esc(gap, tv2string(exp_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n    }\n    else\n    {\n\tga_concat(gap, (char_u *)\"'\");\n\tga_concat_shorten_esc(gap, exp_str);\n\tga_concat(gap, (char_u *)\"'\");\n    }\n    if (atype != ASSERT_NOTEQUAL)\n    {\n\tif (atype == ASSERT_MATCH)\n\t    ga_concat(gap, (char_u *)\" does not match \");\n\telse if (atype == ASSERT_NOTMATCH)\n\t    ga_concat(gap, (char_u *)\" does match \");\n\telse\n\t    ga_concat(gap, (char_u *)\" but got \");\n\tga_concat_shorten_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n\n\tif (omitted != 0)\n\t{\n\t    char buf[100];\n\n\t    vim_snprintf(buf, 100, \" - %d equal item%s omitted\",\n\t\t\t\t\t     omitted, omitted == 1 ? \"\" : \"s\");\n\t    ga_concat(gap, (char_u *)buf);\n\t}\n    }\n\n    if (did_copy)\n    {\n\tclear_tv(exp_tv);\n\tclear_tv(got_tv);\n    }\n}\n\n    static int\nassert_equal_common(typval_T *argvars, assert_type_T atype)\n{\n    garray_T\tga;\n\n    if (tv_equal(&argvars[0], &argvars[1], FALSE, FALSE)\n\t\t\t\t\t\t   != (atype == ASSERT_EQUAL))\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[2], NULL, &argvars[0], &argvars[1],\n\t\t\t\t\t\t\t\t       atype);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n    static int\nassert_match_common(typval_T *argvars, assert_type_T atype)\n{\n    garray_T\tga;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tcalled_emsg_before = called_emsg;\n    char_u\t*pat;\n    char_u\t*text;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn 1;\n\n    pat = tv_get_string_buf_chk(&argvars[0], buf1);\n    text = tv_get_string_buf_chk(&argvars[1], buf2);\n    if (called_emsg == called_emsg_before\n\t\t && pattern_match(pat, text, FALSE) != (atype == ASSERT_MATCH))\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[2], NULL, &argvars[0], &argvars[1],\n\t\t\t\t\t\t\t\t\tatype);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * Common for assert_true() and assert_false().\n * Return non-zero for failure.\n */\n    static int\nassert_bool(typval_T *argvars, int isTrue)\n{\n    int\t\terror = FALSE;\n    garray_T\tga;\n\n    if (argvars[0].v_type == VAR_BOOL\n\t    && argvars[0].vval.v_number == (isTrue ? VVAL_TRUE : VVAL_FALSE))\n\treturn 0;\n    if (argvars[0].v_type != VAR_NUMBER\n\t    || (tv_get_number_chk(&argvars[0], &error) == 0) == isTrue\n\t    || error)\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[1],\n\t\t(char_u *)(isTrue ? \"True\" : \"False\"),\n\t\tNULL, &argvars[0], ASSERT_OTHER);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n    static void\nassert_append_cmd_or_arg(garray_T *gap, typval_T *argvars, char_u *cmd)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tga_concat(gap, echo_string(&argvars[2], &tofree, numbuf, 0));\n\tvim_free(tofree);\n    }\n    else\n\tga_concat(gap, cmd);\n}\n\n    static int\nassert_beeps(typval_T *argvars, int no_beep)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tret = 0;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn 0;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n    called_vim_beep = FALSE;\n    suppress_errthrow = TRUE;\n    emsg_silent = FALSE;\n    do_cmdline_cmd(cmd);\n    if (no_beep ? called_vim_beep : !called_vim_beep)\n    {\n\tprepare_assert_error(&ga);\n\tif (no_beep)\n\t    ga_concat(&ga, (char_u *)\"command did beep: \");\n\telse\n\t    ga_concat(&ga, (char_u *)\"command did not beep: \");\n\tga_concat(&ga, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\tret = 1;\n    }\n\n    suppress_errthrow = FALSE;\n    emsg_on_display = FALSE;\n    return ret;\n}\n\n/*\n * \"assert_beeps(cmd)\" function\n */\n    void\nf_assert_beeps(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_beeps(argvars, FALSE);\n}\n\n/*\n * \"assert_nobeep(cmd)\" function\n */\n    void\nf_assert_nobeep(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_beeps(argvars, TRUE);\n}\n\n/*\n * \"assert_equal(expected, actual[, msg])\" function\n */\n    void\nf_assert_equal(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);\n}\n\n    static int\nassert_equalfile(typval_T *argvars)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tcalled_emsg_before = called_emsg;\n    char_u\t*fname1 = tv_get_string_buf_chk(&argvars[0], buf1);\n    char_u\t*fname2 = tv_get_string_buf_chk(&argvars[1], buf2);\n    garray_T\tga;\n    FILE\t*fd1;\n    FILE\t*fd2;\n    char\tline1[200];\n    char\tline2[200];\n    int\t\tlineidx = 0;\n\n    if (called_emsg > called_emsg_before)\n\treturn 0;\n\n    IObuff[0] = NUL;\n    fd1 = mch_fopen((char *)fname1, READBIN);\n    if (fd1 == NULL)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)e_cant_read_file_str, fname1);\n    }\n    else\n    {\n\tfd2 = mch_fopen((char *)fname2, READBIN);\n\tif (fd2 == NULL)\n\t{\n\t    fclose(fd1);\n\t    vim_snprintf((char *)IObuff, IOSIZE, (char *)e_cant_read_file_str, fname2);\n\t}\n\telse\n\t{\n\t    int\t    c1, c2;\n\t    long    count = 0;\n\t    long    linecount = 1;\n\n\t    for (;;)\n\t    {\n\t\tc1 = fgetc(fd1);\n\t\tc2 = fgetc(fd2);\n\t\tif (c1 == EOF)\n\t\t{\n\t\t    if (c2 != EOF)\n\t\t\tSTRCPY(IObuff, \"first file is shorter\");\n\t\t    break;\n\t\t}\n\t\telse if (c2 == EOF)\n\t\t{\n\t\t    STRCPY(IObuff, \"second file is shorter\");\n\t\t    break;\n\t\t}\n\t\telse\n\t\t{\n\t\t    line1[lineidx] = c1;\n\t\t    line2[lineidx] = c2;\n\t\t    ++lineidx;\n\t\t    if (c1 != c2)\n\t\t    {\n\t\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t\t    \"difference at byte %ld, line %ld\",\n\t\t\t\t\t\t\t     count, linecount);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t++count;\n\t\tif (c1 == NL)\n\t\t{\n\t\t    ++linecount;\n\t\t    lineidx = 0;\n\t\t}\n\t\telse if (lineidx + 2 == (int)sizeof(line1))\n\t\t{\n\t\t    mch_memmove(line1, line1 + 100, lineidx - 100);\n\t\t    mch_memmove(line2, line2 + 100, lineidx - 100);\n\t\t    lineidx -= 100;\n\t\t}\n\t    }\n\t    fclose(fd1);\n\t    fclose(fd2);\n\t}\n    }\n    if (IObuff[0] != NUL)\n    {\n\tprepare_assert_error(&ga);\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    char_u\tnumbuf[NUMBUFLEN];\n\t    char_u\t*tofree;\n\n\t    ga_concat(&ga, echo_string(&argvars[2], &tofree, numbuf, 0));\n\t    vim_free(tofree);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t}\n\tga_concat(&ga, IObuff);\n\tif (lineidx > 0)\n\t{\n\t    line1[lineidx] = NUL;\n\t    line2[lineidx] = NUL;\n\t    ga_concat(&ga, (char_u *)\" after \\\"\");\n\t    ga_concat(&ga, (char_u *)line1);\n\t    if (STRCMP(line1, line2) != 0)\n\t    {\n\t\tga_concat(&ga, (char_u *)\"\\\" vs \\\"\");\n\t\tga_concat(&ga, (char_u *)line2);\n\t    }\n\t    ga_concat(&ga, (char_u *)\"\\\"\");\n\t}\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * \"assert_equalfile(fname-one, fname-two[, msg])\" function\n */\n    void\nf_assert_equalfile(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    rettv->vval.v_number = assert_equalfile(argvars);\n}\n\n/*\n * \"assert_notequal(expected, actual[, msg])\" function\n */\n    void\nf_assert_notequal(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);\n}\n\n/*\n * \"assert_exception(string[, msg])\" function\n */\n    void\nf_assert_exception(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n    char_u\t*error;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    error = tv_get_string_chk(&argvars[0]);\n    if (*get_vim_var_str(VV_EXCEPTION) == NUL)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"v:exception is not set\");\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (error != NULL\n\t&& strstr((char *)get_vim_var_str(VV_EXCEPTION), (char *)error) == NULL)\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[1], NULL, &argvars[0],\n\t\t\t\t  get_vim_var_tv(VV_EXCEPTION), ASSERT_OTHER);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n}\n\n/*\n * \"assert_fails(cmd [, error[, msg]])\" function\n */\n    void\nf_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\ttv = &list->lv_u.mat.lv_last->li_tv;\n\t\tactual = get_vim_var_str(VV_ERRMSG);\n\t\texpected = tv_get_string_buf_chk(tv, buf);\n\t\tif (!pattern_match(expected, actual, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    expected_str = expected;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}\n\n/*\n * \"assert_false(actual[, msg])\" function\n */\n    void\nf_assert_false(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_bool(argvars, FALSE);\n}\n\n    static int\nassert_inrange(typval_T *argvars)\n{\n    garray_T\tga;\n    int\t\terror = FALSE;\n    char_u\t*tofree;\n    char\tmsg[200];\n    char_u\tnumbuf[NUMBUFLEN];\n\n#ifdef FEAT_FLOAT\n    if (argvars[0].v_type == VAR_FLOAT\n\t    || argvars[1].v_type == VAR_FLOAT\n\t    || argvars[2].v_type == VAR_FLOAT)\n    {\n\tfloat_T flower = tv_get_float(&argvars[0]);\n\tfloat_T fupper = tv_get_float(&argvars[1]);\n\tfloat_T factual = tv_get_float(&argvars[2]);\n\n\tif (factual < flower || factual > fupper)\n\t{\n\t    prepare_assert_error(&ga);\n\t    if (argvars[3].v_type != VAR_UNKNOWN)\n\t    {\n\t\tga_concat(&ga, tv2string(&argvars[3], &tofree, numbuf, 0));\n\t\tvim_free(tofree);\n\t    }\n\t    else\n\t    {\n\t\tvim_snprintf(msg, 200, \"Expected range %g - %g, but got %g\",\n\t\t\t\t\t\t      flower, fupper, factual);\n\t\tga_concat(&ga, (char_u *)msg);\n\t    }\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    return 1;\n\t}\n    }\n    else\n#endif\n    {\n\tvarnumber_T\tlower = tv_get_number_chk(&argvars[0], &error);\n\tvarnumber_T\tupper = tv_get_number_chk(&argvars[1], &error);\n\tvarnumber_T\tactual = tv_get_number_chk(&argvars[2], &error);\n\n\tif (error)\n\t    return 0;\n\tif (actual < lower || actual > upper)\n\t{\n\t    prepare_assert_error(&ga);\n\t    if (argvars[3].v_type != VAR_UNKNOWN)\n\t    {\n\t\tga_concat(&ga, tv2string(&argvars[3], &tofree, numbuf, 0));\n\t\tvim_free(tofree);\n\t    }\n\t    else\n\t    {\n\t\tvim_snprintf(msg, 200, \"Expected range %ld - %ld, but got %ld\",\n\t\t\t\t       (long)lower, (long)upper, (long)actual);\n\t\tga_concat(&ga, (char_u *)msg);\n\t    }\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    return 1;\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"assert_inrange(lower, upper[, msg])\" function\n */\n    void\nf_assert_inrange(typval_T *argvars, typval_T *rettv)\n{\n    if (check_for_float_or_nr_arg(argvars, 0) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 1) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 2) == FAIL\n\t    || check_for_opt_string_arg(argvars, 3) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_inrange(argvars);\n}\n\n/*\n * \"assert_match(pattern, actual[, msg])\" function\n */\n    void\nf_assert_match(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_match_common(argvars, ASSERT_MATCH);\n}\n\n/*\n * \"assert_notmatch(pattern, actual[, msg])\" function\n */\n    void\nf_assert_notmatch(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);\n}\n\n/*\n * \"assert_report(msg)\" function\n */\n    void\nf_assert_report(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    prepare_assert_error(&ga);\n    ga_concat(&ga, tv_get_string(&argvars[0]));\n    assert_error(&ga);\n    ga_clear(&ga);\n    rettv->vval.v_number = 1;\n}\n\n/*\n * \"assert_true(actual[, msg])\" function\n */\n    void\nf_assert_true(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_bool(argvars, TRUE);\n}\n\n/*\n * \"test_alloc_fail(id, countdown, repeat)\" function\n */\n    void\nf_test_alloc_fail(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_NUMBER\n\t    || argvars[0].vval.v_number <= 0\n\t    || argvars[1].v_type != VAR_NUMBER\n\t    || argvars[1].vval.v_number < 0\n\t    || argvars[2].v_type != VAR_NUMBER)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\talloc_fail_id = argvars[0].vval.v_number;\n\tif (alloc_fail_id >= aid_last)\n\t    emsg(_(e_invalid_argument));\n\talloc_fail_countdown = argvars[1].vval.v_number;\n\talloc_fail_repeat = argvars[2].vval.v_number;\n\tdid_outofmem_msg = FALSE;\n    }\n}\n\n/*\n * \"test_autochdir()\"\n */\n    void\nf_test_autochdir(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#if defined(FEAT_AUTOCHDIR)\n    test_autochdir = TRUE;\n#endif\n}\n\n/*\n * \"test_feedinput()\"\n */\n    void\nf_test_feedinput(typval_T *argvars, typval_T *rettv UNUSED)\n{\n#ifdef USE_INPUT_BUF\n    char_u\t*val;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    val = tv_get_string_chk(&argvars[0]);\n# ifdef VIMDLL\n    // this doesn't work in the console\n    if (!gui.in_use)\n\treturn;\n# endif\n\n    if (val != NULL)\n    {\n\ttrash_input_buf();\n\tadd_to_input_buf_csi(val, (int)STRLEN(val));\n    }\n#endif\n}\n\n/*\n * \"test_getvalue({name})\" function\n */\n    void\nf_test_getvalue(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tchar_u *name = tv_get_string(&argvars[0]);\n\n\tif (STRCMP(name, (char_u *)\"need_fileinfo\") == 0)\n\t    rettv->vval.v_number = need_fileinfo;\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_option_not_set({name})\" function\n */\n    void\nf_test_option_not_set(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    char_u *name = (char_u *)\"\";\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tname = tv_get_string(&argvars[0]);\n\tif (reset_option_was_set(name) == FAIL)\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_override({name}, {val})\" function\n */\n    void\nf_test_override(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    char_u *name = (char_u *)\"\";\n    int     val;\n    static int save_starting = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING\n\t    || (argvars[1].v_type) != VAR_NUMBER)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tname = tv_get_string(&argvars[0]);\n\tval = (int)tv_get_number(&argvars[1]);\n\n\tif (STRCMP(name, (char_u *)\"redraw\") == 0)\n\t    disable_redraw_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"redraw_flag\") == 0)\n\t    ignore_redraw_flag_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"char_avail\") == 0)\n\t    disable_char_avail_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"starting\") == 0)\n\t{\n\t    if (val)\n\t    {\n\t\tif (save_starting < 0)\n\t\t    save_starting = starting;\n\t\tstarting = 0;\n\t    }\n\t    else\n\t    {\n\t\tstarting = save_starting;\n\t\tsave_starting = -1;\n\t    }\n\t}\n\telse if (STRCMP(name, (char_u *)\"nfa_fail\") == 0)\n\t    nfa_fail_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"no_query_mouse\") == 0)\n\t    no_query_mouse_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"no_wait_return\") == 0)\n\t    no_wait_return = val;\n\telse if (STRCMP(name, (char_u *)\"ui_delay\") == 0)\n\t    ui_delay_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"term_props\") == 0)\n\t    reset_term_props_on_termresponse = val;\n\telse if (STRCMP(name, (char_u *)\"vterm_title\") == 0)\n\t    disable_vterm_title_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"uptime\") == 0)\n\t    override_sysinfo_uptime = val;\n\telse if (STRCMP(name, (char_u *)\"alloc_lines\") == 0)\n\t    ml_get_alloc_lines = val;\n\telse if (STRCMP(name, (char_u *)\"autoload\") == 0)\n\t    override_autoload = val;\n\telse if (STRCMP(name, (char_u *)\"ALL\") == 0)\n\t{\n\t    disable_char_avail_for_testing = FALSE;\n\t    disable_redraw_for_testing = FALSE;\n\t    ignore_redraw_flag_for_testing = FALSE;\n\t    nfa_fail_for_testing = FALSE;\n\t    no_query_mouse_for_testing = FALSE;\n\t    ui_delay_for_testing = 0;\n\t    reset_term_props_on_termresponse = FALSE;\n\t    override_sysinfo_uptime = -1;\n\t    // ml_get_alloc_lines is not reset by \"ALL\"\n\t    if (save_starting >= 0)\n\t    {\n\t\tstarting = save_starting;\n\t\tsave_starting = -1;\n\t    }\n\t}\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_refcount({expr})\" function\n */\n    void\nf_test_refcount(typval_T *argvars, typval_T *rettv)\n{\n    int retval = -1;\n\n    switch (argvars[0].v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_STRING:\n\tcase VAR_INSTR:\n\t    break;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (argvars[0].vval.v_job != NULL)\n\t\tretval = argvars[0].vval.v_job->jv_refcount - 1;\n#endif\n\t    break;\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (argvars[0].vval.v_channel != NULL)\n\t\tretval = argvars[0].vval.v_channel->ch_refcount - 1;\n#endif\n\t    break;\n\tcase VAR_FUNC:\n\t    if (argvars[0].vval.v_string != NULL)\n\t    {\n\t\tufunc_T *fp;\n\n\t\tfp = find_func(argvars[0].vval.v_string, FALSE);\n\t\tif (fp != NULL)\n\t\t    retval = fp->uf_refcount;\n\t    }\n\t    break;\n\tcase VAR_PARTIAL:\n\t    if (argvars[0].vval.v_partial != NULL)\n\t\tretval = argvars[0].vval.v_partial->pt_refcount - 1;\n\t    break;\n\tcase VAR_BLOB:\n\t    if (argvars[0].vval.v_blob != NULL)\n\t\tretval = argvars[0].vval.v_blob->bv_refcount - 1;\n\t    break;\n\tcase VAR_LIST:\n\t    if (argvars[0].vval.v_list != NULL)\n\t\tretval = argvars[0].vval.v_list->lv_refcount - 1;\n\t    break;\n\tcase VAR_DICT:\n\t    if (argvars[0].vval.v_dict != NULL)\n\t\tretval = argvars[0].vval.v_dict->dv_refcount - 1;\n\t    break;\n    }\n\n    rettv->v_type = VAR_NUMBER;\n    rettv->vval.v_number = retval;\n\n}\n\n/*\n * \"test_garbagecollect_now()\" function\n */\n    void\nf_test_garbagecollect_now(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    // This is dangerous, any Lists and Dicts used internally may be freed\n    // while still in use.\n    if (!get_vim_var_nr(VV_TESTING))\n\temsg(_(e_calling_test_garbagecollect_now_while_v_testing_is_not_set));\n    else\n\tgarbage_collect(TRUE);\n}\n\n/*\n * \"test_garbagecollect_soon()\" function\n */\n    void\nf_test_garbagecollect_soon(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    may_garbage_collect = TRUE;\n}\n\n/*\n * \"test_ignore_error()\" function\n */\n    void\nf_test_ignore_error(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n\tignore_error_for_testing(tv_get_string(&argvars[0]));\n}\n\n    void\nf_test_null_blob(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_BLOB;\n    rettv->vval.v_blob = NULL;\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    void\nf_test_null_channel(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_CHANNEL;\n    rettv->vval.v_channel = NULL;\n}\n#endif\n\n    void\nf_test_null_dict(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv_dict_set(rettv, NULL);\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    void\nf_test_null_job(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_JOB;\n    rettv->vval.v_job = NULL;\n}\n#endif\n\n    void\nf_test_null_list(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv_list_set(rettv, NULL);\n}\n\n    void\nf_test_null_function(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_FUNC;\n    rettv->vval.v_string = NULL;\n}\n\n    void\nf_test_null_partial(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_PARTIAL;\n    rettv->vval.v_partial = NULL;\n}\n\n    void\nf_test_null_string(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n}\n\n    void\nf_test_unknown(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_UNKNOWN;\n}\n\n    void\nf_test_void(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_VOID;\n}\n\n    void\nf_test_setmouse(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type) != VAR_NUMBER)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    mouse_row = (time_t)tv_get_number(&argvars[0]) - 1;\n    mouse_col = (time_t)tv_get_number(&argvars[1]) - 1;\n}\n\n# ifdef FEAT_GUI\n    static int\ntest_gui_drop_files(dict_T *args UNUSED)\n{\n#  if defined(HAVE_DROP_FILE)\n    int\t\trow;\n    int\t\tcol;\n    int_u\tmods;\n    char_u\t**fnames;\n    int\t\tcount = 0;\n    typval_T\tt;\n    list_T\t*l;\n    listitem_T\t*li;\n\n    if (!dict_has_key(args, \"files\")\n\t    || !dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\")\n\t    || !dict_has_key(args, \"modifiers\"))\n\treturn FALSE;\n\n    (void)dict_get_tv(args, \"files\", &t);\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n    mods = (int)dict_get_number(args, \"modifiers\");\n\n    if (t.v_type != VAR_LIST || list_len(t.vval.v_list) == 0)\n\treturn FALSE;\n\n    l = t.vval.v_list;\n    fnames = ALLOC_MULT(char_u *, list_len(l));\n    if (fnames == NULL)\n\treturn FALSE;\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\t// ignore non-string items\n\tif (li->li_tv.v_type != VAR_STRING\n\t\t|| li->li_tv.vval.v_string == NULL)\n\t    continue;\n\n\tfnames[count] = vim_strsave(li->li_tv.vval.v_string);\n\tif (fnames[count] == NULL)\n\t{\n\t    while (--count >= 0)\n\t\tvim_free(fnames[count]);\n\t    vim_free(fnames);\n\t    return FALSE;\n\t}\n\tcount++;\n    }\n\n    if (count > 0)\n\tgui_handle_drop(TEXT_X(col - 1), TEXT_Y(row - 1), mods, fnames, count);\n    else\n\tvim_free(fnames);\n#  endif\n\n    return TRUE;\n}\n\n#if defined(FIND_REPLACE_DIALOG)\n    static int\ntest_gui_find_repl(dict_T *args)\n{\n    int\t\tflags;\n    char_u\t*find_text;\n    char_u\t*repl_text;\n    int\t\tforward;\n    int\t\tretval;\n\n    if (!dict_has_key(args, \"find_text\")\n\t    || !dict_has_key(args, \"repl_text\")\n\t    || !dict_has_key(args, \"flags\")\n\t    || !dict_has_key(args, \"forward\"))\n\treturn FALSE;\n\n    find_text = dict_get_string(args, \"find_text\", TRUE);\n    repl_text = dict_get_string(args, \"repl_text\", TRUE);\n    flags = (int)dict_get_number(args, \"flags\");\n    forward = (int)dict_get_number(args, \"forward\");\n\n    retval = gui_do_findrepl(flags, find_text, repl_text, forward);\n    vim_free(find_text);\n    vim_free(repl_text);\n\n    return retval;\n}\n#endif\n\n    static int\ntest_gui_mouse_event(dict_T *args)\n{\n    int\t\tbutton;\n    int\t\trow;\n    int\t\tcol;\n    int\t\trepeated_click;\n    int_u\tmods;\n    int\t\tmove;\n\n    if (!dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\"))\n\treturn FALSE;\n\n    // Note: \"move\" is optional, requires fewer arguments\n    move = (int)dict_get_bool(args, \"move\", FALSE);\n\n    if (!move && (!dict_has_key(args, \"button\")\n\t    || !dict_has_key(args, \"multiclick\")\n\t    || !dict_has_key(args, \"modifiers\")))\n\treturn FALSE;\n\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n\n    if (move)\n    {\n\tif (dict_get_bool(args, \"cell\", FALSE))\n\t{\n\t    // click in the middle of the character cell\n\t    row = row * gui.char_height + gui.char_height / 2;\n\t    col = col * gui.char_width + gui.char_width / 2;\n\t}\n\tgui_mouse_moved(col, row);\n    }\n    else\n    {\n\tbutton = (int)dict_get_number(args, \"button\");\n\trepeated_click = (int)dict_get_number(args, \"multiclick\");\n\tmods = (int)dict_get_number(args, \"modifiers\");\n\n\t// Reset the scroll values to known values.\n\t// XXX: Remove this when/if the scroll step is made configurable.\n\tmouse_set_hor_scroll_step(6);\n\tmouse_set_vert_scroll_step(3);\n\n\tgui_send_mouse_event(button, TEXT_X(col - 1), TEXT_Y(row - 1),\n\t\t\t\t\t\t\trepeated_click, mods);\n    }\n\n    return TRUE;\n}\n\n    static int\ntest_gui_scrollbar(dict_T *args)\n{\n    char_u\t*which;\n    long\tvalue;\n    int\t\tdragging;\n    scrollbar_T *sb = NULL;\n\n    if (!dict_has_key(args, \"which\")\n\t    || !dict_has_key(args, \"value\")\n\t    || !dict_has_key(args, \"dragging\"))\n\treturn FALSE;\n\n    which = dict_get_string(args, \"which\", FALSE);\n    value = (long)dict_get_number(args, \"value\");\n    dragging = (int)dict_get_number(args, \"dragging\");\n\n    if (STRCMP(which, \"left\") == 0)\n\tsb = &curwin->w_scrollbars[SBAR_LEFT];\n    else if (STRCMP(which, \"right\") == 0)\n\tsb = &curwin->w_scrollbars[SBAR_RIGHT];\n    else if (STRCMP(which, \"hor\") == 0)\n\tsb = &gui.bottom_sbar;\n    if (sb == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), which);\n\treturn FALSE;\n    }\n    gui_drag_scrollbar(sb, value, dragging);\n#  ifndef USE_ON_FLY_SCROLL\n    // need to loop through normal_cmd() to handle the scroll events\n    exec_normal(FALSE, TRUE, FALSE);\n#  endif\n\n    return TRUE;\n}\n\n    static int\ntest_gui_tabline_event(dict_T *args UNUSED)\n{\n#  ifdef FEAT_GUI_TABLINE\n    int\t\ttabnr;\n\n    if (!dict_has_key(args, \"tabnr\"))\n\treturn FALSE;\n\n    tabnr = (int)dict_get_number(args, \"tabnr\");\n\n    return send_tabline_event(tabnr);\n#  else\n    return FALSE;\n#  endif\n}\n\n    static int\ntest_gui_tabmenu_event(dict_T *args UNUSED)\n{\n#  ifdef FEAT_GUI_TABLINE\n    int\ttabnr;\n    int\titem;\n\n    if (!dict_has_key(args, \"tabnr\")\n\t    || !dict_has_key(args, \"item\"))\n\treturn FALSE;\n\n    tabnr = (int)dict_get_number(args, \"tabnr\");\n    item = (int)dict_get_number(args, \"item\");\n\n    send_tabline_menu_event(tabnr, item);\n#  endif\n    return TRUE;\n}\n# endif\n\n    void\nf_test_gui_event(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_GUI\n    char_u\t*event;\n\n    rettv->v_type = VAR_BOOL;\n    rettv->vval.v_number = FALSE;\n\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn;\n    }\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_dict_arg(argvars, 1) == FAIL\n\t    || argvars[1].vval.v_dict == NULL)\n\treturn;\n\n    event = tv_get_string(&argvars[0]);\n    if (STRCMP(event, \"dropfiles\") == 0)\n\trettv->vval.v_number = test_gui_drop_files(argvars[1].vval.v_dict);\n#  if defined(FIND_REPLACE_DIALOG)\n    else if (STRCMP(event, \"findrepl\") == 0)\n\trettv->vval.v_number = test_gui_find_repl(argvars[1].vval.v_dict);\n#  endif\n    else if (STRCMP(event, \"mouse\") == 0)\n\trettv->vval.v_number = test_gui_mouse_event(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"scrollbar\") == 0)\n\trettv->vval.v_number = test_gui_scrollbar(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"tabline\") == 0)\n\trettv->vval.v_number = test_gui_tabline_event(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"tabmenu\") == 0)\n\trettv->vval.v_number = test_gui_tabmenu_event(argvars[1].vval.v_dict);\n#  ifdef FEAT_GUI_MSWIN\n    else if (STRCMP(event, \"sendevent\") == 0)\n\trettv->vval.v_number = test_gui_w32_sendevent(argvars[1].vval.v_dict);\n#  endif\n    else\n    {\n\tsemsg(_(e_invalid_argument_str), event);\n\treturn;\n    }\n# endif\n}\n\n    void\nf_test_settime(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    time_for_testing = (time_t)tv_get_number(&argvars[0]);\n}\n\n#endif // defined(FEAT_EVAL)\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["\" Test that the methods used for testing work.\n\nfunc Test_assert_false()\n  call assert_equal(0, assert_false(0))\n  call assert_equal(0, assert_false(v:false))\n  call assert_equal(0, v:false->assert_false())\n\n  call assert_equal(1, assert_false(123))\n  call assert_match(\"Expected 'False' but got 123\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 123->assert_false())\n  call assert_match(\"Expected 'False' but got 123\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_true()\n  call assert_equal(0, assert_true(1))\n  call assert_equal(0, assert_true(123))\n  call assert_equal(0, assert_true(v:true))\n  call assert_equal(0, v:true->assert_true())\n\n  call assert_equal(1, assert_true(0))\n  call assert_match(\"Expected 'True' but got 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 0->assert_true())\n  call assert_match(\"Expected 'True' but got 0\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_equal()\n  let s = 'foo'\n  call assert_equal(0, assert_equal('foo', s))\n  let n = 4\n  call assert_equal(0, assert_equal(4, n))\n  let l = [1, 2, 3]\n  call assert_equal(0, assert_equal([1, 2, 3], l))\n  call assert_equal(test_null_list(), test_null_list())\n  call assert_equal(test_null_list(), [])\n  call assert_equal([], test_null_list())\n\n  let s = 'foo'\n  call assert_equal(1, assert_equal('bar', s))\n  call assert_match(\"Expected 'bar' but got 'foo'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal('XxxxxxxxxxxxxxxxxxxxxxX', 'XyyyyyyyyyyyyyyyyyyyyyyyyyX')\n  call assert_match(\"Expected 'X\\\\\\\\\\\\[x occurs 21 times]X' but got 'X\\\\\\\\\\\\[y occurs 25 times]X'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  \" special characters are escaped\n  call assert_equal(\"\\b\\e\\f\\n\\t\\r\\\\\\x01\\x7f\", 'x')\n  call assert_match('Expected ''\\\\b\\\\e\\\\f\\\\n\\\\t\\\\r\\\\\\\\\\\\x01\\\\x7f'' but got ''x''', v:errors[0])\n  call remove(v:errors, 0)\n\n  \" many composing characters are handled properly\n  call setline(1, ' ')\n  norm 100gr\u0740\n  call assert_equal(1, getline(1))\n  call assert_match(\"Expected 1 but got '.* occurs 100 times]'\", v:errors[0])\n  call remove(v:errors, 0)\n  bwipe!\nendfunc\n\nfunc Test_assert_equal_dict()\n  call assert_equal(0, assert_equal(#{one: 1, two: 2}, #{two: 2, one: 1}))\n\n  call assert_equal(1, assert_equal(#{one: 1, two: 2}, #{two: 2, one: 3}))\n  call assert_match(\"Expected {'one': 1} but got {'one': 3} - 1 equal item omitted\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{one: 1, two: 2}, #{two: 22, one: 11}))\n  call assert_match(\"Expected {'one': 1, 'two': 2} but got {'one': 11, 'two': 22}\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{}, #{two: 2, one: 1}))\n  call assert_match(\"Expected {} but got {'one': 1, 'two': 2}\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equal(#{two: 2, one: 1}, #{}))\n  call assert_match(\"Expected {'one': 1, 'two': 2} but got {}\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_equalfile()\n  call assert_equal(1, assert_equalfile('abcabc', 'xyzxyz'))\n  call assert_match(\"E485: Can't read file abcabc\", v:errors[0])\n  call remove(v:errors, 0)\n\n  let goodtext = [\"one\", \"two\", \"three\"]\n  call writefile(goodtext, 'Xone')\n  call assert_equal(1, 'Xone'->assert_equalfile('xyzxyz'))\n  call assert_match(\"E485: Can't read file xyzxyz\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(goodtext, 'Xtwo')\n  call assert_equal(0, assert_equalfile('Xone', 'Xtwo'))\n\n  call writefile([goodtext[0]], 'Xone')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match(\"first file is shorter\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(goodtext, 'Xone')\n  call writefile([goodtext[0]], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match(\"second file is shorter\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile(['1234X89'], 'Xone')\n  call writefile(['1234Y89'], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  call assert_match('difference at byte 4, line 1 after \"1234X\" vs \"1234Y\"', v:errors[0])\n  call remove(v:errors, 0)\n\n  call writefile([repeat('x', 234) .. 'X'], 'Xone')\n  call writefile([repeat('x', 234) .. 'Y'], 'Xtwo')\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo'))\n  let xes = repeat('x', 134)\n  call assert_match('difference at byte 234, line 1 after \"' .. xes .. 'X\" vs \"' .. xes .. 'Y\"', v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_equalfile('Xone', 'Xtwo', 'a message'))\n  call assert_match(\"a message: difference at byte 234, line 1 after\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call delete('Xone')\n  call delete('Xtwo')\nendfunc\n\nfunc Test_assert_notequal()\n  let n = 4\n  call assert_equal(0, assert_notequal('foo', n))\n  let s = 'foo'\n  call assert_equal(0, assert_notequal([1, 2, 3], s))\n\n  call assert_equal(1, assert_notequal('foo', s))\n  call assert_match(\"Expected not equal to 'foo'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_report()\n  call assert_equal(1, assert_report('something is wrong'))\n  call assert_match('something is wrong', v:errors[0])\n  call remove(v:errors, 0)\n  call assert_equal(1, 'also wrong'->assert_report())\n  call assert_match('also wrong', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_exception()\n  try\n    nocommand\n  catch\n    call assert_equal(0, assert_exception('E492:'))\n  endtry\n\n  try\n    nocommand\n  catch\n    call assert_equal(1, assert_exception('E12345:'))\n  endtry\n  call assert_match(\"Expected 'E12345:' but got 'Vim:E492: \", v:errors[0])\n  call remove(v:errors, 0)\n\n  try\n    nocommand\n  catch\n    try\n      \" illegal argument, get NULL for error\n      call assert_equal(1, assert_exception([]))\n    catch\n      call assert_equal(0, assert_exception('E730:'))\n    endtry\n  endtry\n\n  call assert_equal(1, assert_exception('E492:'))\n  call assert_match('v:exception is not set', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_wrong_error_type()\n  let save_verrors = v:errors\n  let v:['errors'] = {'foo': 3}\n  call assert_equal('yes', 'no')\n  let verrors = v:errors\n  let v:errors = save_verrors\n  call assert_equal(type([]), type(verrors))\nendfunc\n\nfunc Test_compare_fail()\n  let s:v = {}          \n  let s:x = {\"a\": s:v} \n  let s:v[\"b\"] = s:x   \n  let s:w = {\"c\": s:x, \"d\": ''}\n  try\n    call assert_equal(s:w, '')\n  catch\n    call assert_equal(0, assert_exception('E724:'))\n    call assert_match(\"Expected NULL but got ''\", v:errors[0])\n    call remove(v:errors, 0)\n  endtry\nendfunc\n\nfunc Test_match()\n  call assert_equal(0, assert_match('^f.*b.*r$', 'foobar'))\n\n  call assert_equal(1, assert_match('bar.*foo', 'foobar'))\n  call assert_match(\"Pattern 'bar.*foo' does not match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_match('bar.*foo', 'foobar', 'wrong'))\n  call assert_match('wrong', v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'foobar'->assert_match('bar.*foo', 'wrong'))\n  call assert_match('wrong', v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_notmatch()\n  call assert_equal(0, assert_notmatch('foo', 'bar'))\n  call assert_equal(0, assert_notmatch('^foobar$', 'foobars'))\n\n  call assert_equal(1, assert_notmatch('foo', 'foobar'))\n  call assert_match(\"Pattern 'foo' does match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'foobar'->assert_notmatch('foo'))\n  call assert_match(\"Pattern 'foo' does match 'foobar'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_fail_fails()\n  call assert_equal(1, assert_fails('xxx', 'E12345'))\n  call assert_match(\"Expected 'E12345' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', 'E9876', 'stupid'))\n  call assert_match(\"stupid: Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', ['E9876']))\n  call assert_match(\"Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('xxx', ['E492:', 'E9876']))\n  call assert_match(\"Expected 'E9876' but got 'E492:\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, assert_fails('echo', '', 'echo command'))\n  call assert_match(\"command did not fail: echo command\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(1, 'echo'->assert_fails('', 'echo command'))\n  call assert_match(\"command did not fail: echo command\", v:errors[0])\n  call remove(v:errors, 0)\n\n  try\n    call assert_equal(1, assert_fails('xxx', []))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E856: \\\"assert_fails()\\\" second argument\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', ['1', '2', '3']))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E856: \\\"assert_fails()\\\" second argument\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', #{one: 1}))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1222: String or List required for argument 2\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', 'E492', '', 'burp'))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1210: Number required for argument 4\", exp)\n\n  try\n    call assert_equal(1, assert_fails('xxx', 'E492', '', 54, 123))\n  catch\n    let exp = v:exception\n  endtry\n  call assert_match(\"E1174: String required for argument 5\", exp)\n\n  call assert_equal(1, assert_fails('c0', ['', '\\1']))\n  call assert_match(\"Expected '\\\\\\\\\\\\\\\\1' but got 'E939: Positive count required: c0': c0\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_assert_fails_in_try_block()\n  try\n    call assert_equal(0, assert_fails('throw \"error\"'))\n  endtry\nendfunc\n\nfunc Test_assert_beeps()\n  new\n  call assert_equal(0, assert_beeps('normal h'))\n\n  call assert_equal(1, assert_beeps('normal 0'))\n  call assert_match(\"command did not beep: normal 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(0, 'normal h'->assert_beeps())\n  call assert_equal(1, 'normal 0'->assert_beeps())\n  call assert_match(\"command did not beep: normal 0\", v:errors[0])\n  call remove(v:errors, 0)\n\n  bwipe\nendfunc\n\nfunc Test_assert_inrange()\n  call assert_equal(0, assert_inrange(7, 7, 7))\n  call assert_equal(0, assert_inrange(5, 7, 5))\n  call assert_equal(0, assert_inrange(5, 7, 6))\n  call assert_equal(0, assert_inrange(5, 7, 7))\n\n  call assert_equal(1, assert_inrange(5, 7, 4))\n  call assert_match(\"Expected range 5 - 7, but got 4\", v:errors[0])\n  call remove(v:errors, 0)\n  call assert_equal(1, assert_inrange(5, 7, 8))\n  call assert_match(\"Expected range 5 - 7, but got 8\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_equal(0, 5->assert_inrange(5, 7))\n  call assert_equal(0, 7->assert_inrange(5, 7))\n  call assert_equal(1, 8->assert_inrange(5, 7))\n  call assert_match(\"Expected range 5 - 7, but got 8\", v:errors[0])\n  call remove(v:errors, 0)\n\n  call assert_fails('call assert_inrange(1, 1)', 'E119:')\n\n  if has('float')\n    call assert_equal(0, assert_inrange(7.0, 7, 7))\n    call assert_equal(0, assert_inrange(7, 7.0, 7))\n    call assert_equal(0, assert_inrange(7, 7, 7.0))\n    call assert_equal(0, assert_inrange(5, 7, 5.0))\n    call assert_equal(0, assert_inrange(5, 7, 6.0))\n    call assert_equal(0, assert_inrange(5, 7, 7.0))\n\n    call assert_equal(1, assert_inrange(5, 7, 4.0))\n    call assert_match(\"Expected range 5.0 - 7.0, but got 4.0\", v:errors[0])\n    call remove(v:errors, 0)\n    call assert_equal(1, assert_inrange(5, 7, 8.0))\n    call assert_match(\"Expected range 5.0 - 7.0, but got 8.0\", v:errors[0])\n    call remove(v:errors, 0)\n  endif\nendfunc\n\nfunc Test_assert_with_msg()\n  call assert_equal('foo', 'bar', 'testing')\n  call assert_match(\"testing: Expected 'foo' but got 'bar'\", v:errors[0])\n  call remove(v:errors, 0)\nendfunc\n\nfunc Test_override()\n  call test_override('char_avail', 1)\n  eval 1->test_override('redraw')\n  call test_override('ALL', 0)\n  call assert_fails(\"call test_override('xxx', 1)\", 'E475:')\n  call assert_fails(\"call test_override('redraw', 'yes')\", 'E474:')\nendfunc\n\nfunc Test_mouse_position()\n  let save_mouse = &mouse\n  set mouse=a\n  new\n  call setline(1, ['line one', 'line two'])\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call test_setmouse(1, 5)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 1, 5, 0], getpos('.'))\n  call test_setmouse(2, 20)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 2, 8, 0], getpos('.'))\n  call test_setmouse(5, 1)\n  call feedkeys(\"\\<LeftMouse>\", \"xt\")\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call assert_fails('call test_setmouse(\"\", 2)', 'E474:')\n  call assert_fails('call test_setmouse(1, \"\")', 'E474:')\n  bwipe!\n  let &mouse = save_mouse\nendfunc\n\nfunc Test_user_is_happy()\n  smile\n  sleep 300m\nendfunc\n\n\" Must be last.\nfunc Test_zz_quit_detected()\n  \" Verify that if a test function ends Vim the test script detects this.\n  quit\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * testing.c: Support for tests.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Prepare \"gap\" for an assert error and add the sourcing position.\n */\n    static void\nprepare_assert_error(garray_T *gap)\n{\n    char    buf[NUMBUFLEN];\n    char_u  *sname = estack_sfile(ESTACK_NONE);\n\n    ga_init2(gap, 1, 100);\n    if (sname != NULL)\n    {\n\tga_concat(gap, sname);\n\tif (SOURCING_LNUM > 0)\n\t    ga_concat(gap, (char_u *)\" \");\n    }\n    if (SOURCING_LNUM > 0)\n    {\n\tsprintf(buf, \"line %ld\", (long)SOURCING_LNUM);\n\tga_concat(gap, (char_u *)buf);\n    }\n    if (sname != NULL || SOURCING_LNUM > 0)\n\tga_concat(gap, (char_u *)\": \");\n    vim_free(sname);\n}\n\n/*\n * Append \"p[clen]\" to \"gap\", escaping unprintable characters.\n * Changes NL to \\n, CR to \\r, etc.\n */\n    static void\nga_concat_esc(garray_T *gap, char_u *p, int clen)\n{\n    char_u  buf[NUMBUFLEN];\n\n    if (clen > 1)\n    {\n\tmch_memmove(buf, p, clen);\n\tbuf[clen] = NUL;\n\tga_concat(gap, buf);\n    }\n    else switch (*p)\n    {\n\tcase BS: ga_concat(gap, (char_u *)\"\\\\b\"); break;\n\tcase ESC: ga_concat(gap, (char_u *)\"\\\\e\"); break;\n\tcase FF: ga_concat(gap, (char_u *)\"\\\\f\"); break;\n\tcase NL: ga_concat(gap, (char_u *)\"\\\\n\"); break;\n\tcase TAB: ga_concat(gap, (char_u *)\"\\\\t\"); break;\n\tcase CAR: ga_concat(gap, (char_u *)\"\\\\r\"); break;\n\tcase '\\\\': ga_concat(gap, (char_u *)\"\\\\\\\\\"); break;\n\tdefault:\n\t\t   if (*p < ' ' || *p == 0x7f)\n\t\t   {\n\t\t       vim_snprintf((char *)buf, NUMBUFLEN, \"\\\\x%02x\", *p);\n\t\t       ga_concat(gap, buf);\n\t\t   }\n\t\t   else\n\t\t       ga_append(gap, *p);\n\t\t   break;\n    }\n}\n\n/*\n * Append \"str\" to \"gap\", escaping unprintable characters.\n * Changes NL to \\n, CR to \\r, etc.\n */\n    static void\nga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_cptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}\n\n/*\n * Fill \"gap\" with information about an assert error.\n */\n    static void\nfill_assert_error(\n    garray_T\t*gap,\n    typval_T\t*opt_msg_tv,\n    char_u      *exp_str,\n    typval_T\t*exp_tv_arg,\n    typval_T\t*got_tv_arg,\n    assert_type_T atype)\n{\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*tofree;\n    typval_T\t*exp_tv = exp_tv_arg;\n    typval_T\t*got_tv = got_tv_arg;\n    int\t\tdid_copy = FALSE;\n    int\t\tomitted = 0;\n\n    if (opt_msg_tv->v_type != VAR_UNKNOWN\n\t    && !(opt_msg_tv->v_type == VAR_STRING\n\t\t&& (opt_msg_tv->vval.v_string == NULL\n\t\t    || *opt_msg_tv->vval.v_string == NUL)))\n    {\n\tga_concat(gap, echo_string(opt_msg_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n\tga_concat(gap, (char_u *)\": \");\n    }\n\n    if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH)\n\tga_concat(gap, (char_u *)\"Pattern \");\n    else if (atype == ASSERT_NOTEQUAL)\n\tga_concat(gap, (char_u *)\"Expected not equal to \");\n    else\n\tga_concat(gap, (char_u *)\"Expected \");\n    if (exp_str == NULL)\n    {\n\t// When comparing dictionaries, drop the items that are equal, so that\n\t// it's a lot easier to see what differs.\n\tif (atype != ASSERT_NOTEQUAL\n\t\t&& exp_tv->v_type == VAR_DICT && got_tv->v_type == VAR_DICT\n\t\t&& exp_tv->vval.v_dict != NULL && got_tv->vval.v_dict != NULL)\n\t{\n\t    dict_T\t*exp_d = exp_tv->vval.v_dict;\n\t    dict_T\t*got_d = got_tv->vval.v_dict;\n\t    hashitem_T\t*hi;\n\t    dictitem_T\t*item2;\n\t    int\t\ttodo;\n\n\t    did_copy = TRUE;\n\t    exp_tv->vval.v_dict = dict_alloc();\n\t    got_tv->vval.v_dict = dict_alloc();\n\t    if (exp_tv->vval.v_dict == NULL || got_tv->vval.v_dict == NULL)\n\t\treturn;\n\n\t    todo = (int)exp_d->dv_hashtab.ht_used;\n\t    for (hi = exp_d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t    {\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    item2 = dict_find(got_d, hi->hi_key, -1);\n\t\t    if (item2 == NULL || !tv_equal(&HI2DI(hi)->di_tv,\n\t\t\t\t\t\t  &item2->di_tv, FALSE, FALSE))\n\t\t    {\n\t\t\t// item of exp_d not present in got_d or values differ.\n\t\t\tdict_add_tv(exp_tv->vval.v_dict,\n\t\t\t\t\t(char *)hi->hi_key, &HI2DI(hi)->di_tv);\n\t\t\tif (item2 != NULL)\n\t\t\t    dict_add_tv(got_tv->vval.v_dict,\n\t\t\t\t\t    (char *)hi->hi_key, &item2->di_tv);\n\t\t    }\n\t\t    else\n\t\t\t++omitted;\n\t\t    --todo;\n\t\t}\n\t    }\n\n\t    // Add items only present in got_d.\n\t    todo = (int)got_d->dv_hashtab.ht_used;\n\t    for (hi = got_d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t    {\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    item2 = dict_find(exp_d, hi->hi_key, -1);\n\t\t    if (item2 == NULL)\n\t\t\t// item of got_d not present in exp_d\n\t\t\tdict_add_tv(got_tv->vval.v_dict,\n\t\t\t\t\t(char *)hi->hi_key, &HI2DI(hi)->di_tv);\n\t\t    --todo;\n\t\t}\n\t    }\n\t}\n\n\tga_concat_shorten_esc(gap, tv2string(exp_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n    }\n    else\n    {\n\tga_concat(gap, (char_u *)\"'\");\n\tga_concat_shorten_esc(gap, exp_str);\n\tga_concat(gap, (char_u *)\"'\");\n    }\n    if (atype != ASSERT_NOTEQUAL)\n    {\n\tif (atype == ASSERT_MATCH)\n\t    ga_concat(gap, (char_u *)\" does not match \");\n\telse if (atype == ASSERT_NOTMATCH)\n\t    ga_concat(gap, (char_u *)\" does match \");\n\telse\n\t    ga_concat(gap, (char_u *)\" but got \");\n\tga_concat_shorten_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));\n\tvim_free(tofree);\n\n\tif (omitted != 0)\n\t{\n\t    char buf[100];\n\n\t    vim_snprintf(buf, 100, \" - %d equal item%s omitted\",\n\t\t\t\t\t     omitted, omitted == 1 ? \"\" : \"s\");\n\t    ga_concat(gap, (char_u *)buf);\n\t}\n    }\n\n    if (did_copy)\n    {\n\tclear_tv(exp_tv);\n\tclear_tv(got_tv);\n    }\n}\n\n    static int\nassert_equal_common(typval_T *argvars, assert_type_T atype)\n{\n    garray_T\tga;\n\n    if (tv_equal(&argvars[0], &argvars[1], FALSE, FALSE)\n\t\t\t\t\t\t   != (atype == ASSERT_EQUAL))\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[2], NULL, &argvars[0], &argvars[1],\n\t\t\t\t\t\t\t\t       atype);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n    static int\nassert_match_common(typval_T *argvars, assert_type_T atype)\n{\n    garray_T\tga;\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tcalled_emsg_before = called_emsg;\n    char_u\t*pat;\n    char_u\t*text;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn 1;\n\n    pat = tv_get_string_buf_chk(&argvars[0], buf1);\n    text = tv_get_string_buf_chk(&argvars[1], buf2);\n    if (called_emsg == called_emsg_before\n\t\t && pattern_match(pat, text, FALSE) != (atype == ASSERT_MATCH))\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[2], NULL, &argvars[0], &argvars[1],\n\t\t\t\t\t\t\t\t\tatype);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * Common for assert_true() and assert_false().\n * Return non-zero for failure.\n */\n    static int\nassert_bool(typval_T *argvars, int isTrue)\n{\n    int\t\terror = FALSE;\n    garray_T\tga;\n\n    if (argvars[0].v_type == VAR_BOOL\n\t    && argvars[0].vval.v_number == (isTrue ? VVAL_TRUE : VVAL_FALSE))\n\treturn 0;\n    if (argvars[0].v_type != VAR_NUMBER\n\t    || (tv_get_number_chk(&argvars[0], &error) == 0) == isTrue\n\t    || error)\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[1],\n\t\t(char_u *)(isTrue ? \"True\" : \"False\"),\n\t\tNULL, &argvars[0], ASSERT_OTHER);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n    static void\nassert_append_cmd_or_arg(garray_T *gap, typval_T *argvars, char_u *cmd)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tga_concat(gap, echo_string(&argvars[2], &tofree, numbuf, 0));\n\tvim_free(tofree);\n    }\n    else\n\tga_concat(gap, cmd);\n}\n\n    static int\nassert_beeps(typval_T *argvars, int no_beep)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tret = 0;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn 0;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n    called_vim_beep = FALSE;\n    suppress_errthrow = TRUE;\n    emsg_silent = FALSE;\n    do_cmdline_cmd(cmd);\n    if (no_beep ? called_vim_beep : !called_vim_beep)\n    {\n\tprepare_assert_error(&ga);\n\tif (no_beep)\n\t    ga_concat(&ga, (char_u *)\"command did beep: \");\n\telse\n\t    ga_concat(&ga, (char_u *)\"command did not beep: \");\n\tga_concat(&ga, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\tret = 1;\n    }\n\n    suppress_errthrow = FALSE;\n    emsg_on_display = FALSE;\n    return ret;\n}\n\n/*\n * \"assert_beeps(cmd)\" function\n */\n    void\nf_assert_beeps(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_beeps(argvars, FALSE);\n}\n\n/*\n * \"assert_nobeep(cmd)\" function\n */\n    void\nf_assert_nobeep(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_beeps(argvars, TRUE);\n}\n\n/*\n * \"assert_equal(expected, actual[, msg])\" function\n */\n    void\nf_assert_equal(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);\n}\n\n    static int\nassert_equalfile(typval_T *argvars)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tcalled_emsg_before = called_emsg;\n    char_u\t*fname1 = tv_get_string_buf_chk(&argvars[0], buf1);\n    char_u\t*fname2 = tv_get_string_buf_chk(&argvars[1], buf2);\n    garray_T\tga;\n    FILE\t*fd1;\n    FILE\t*fd2;\n    char\tline1[200];\n    char\tline2[200];\n    int\t\tlineidx = 0;\n\n    if (called_emsg > called_emsg_before)\n\treturn 0;\n\n    IObuff[0] = NUL;\n    fd1 = mch_fopen((char *)fname1, READBIN);\n    if (fd1 == NULL)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)e_cant_read_file_str, fname1);\n    }\n    else\n    {\n\tfd2 = mch_fopen((char *)fname2, READBIN);\n\tif (fd2 == NULL)\n\t{\n\t    fclose(fd1);\n\t    vim_snprintf((char *)IObuff, IOSIZE, (char *)e_cant_read_file_str, fname2);\n\t}\n\telse\n\t{\n\t    int\t    c1, c2;\n\t    long    count = 0;\n\t    long    linecount = 1;\n\n\t    for (;;)\n\t    {\n\t\tc1 = fgetc(fd1);\n\t\tc2 = fgetc(fd2);\n\t\tif (c1 == EOF)\n\t\t{\n\t\t    if (c2 != EOF)\n\t\t\tSTRCPY(IObuff, \"first file is shorter\");\n\t\t    break;\n\t\t}\n\t\telse if (c2 == EOF)\n\t\t{\n\t\t    STRCPY(IObuff, \"second file is shorter\");\n\t\t    break;\n\t\t}\n\t\telse\n\t\t{\n\t\t    line1[lineidx] = c1;\n\t\t    line2[lineidx] = c2;\n\t\t    ++lineidx;\n\t\t    if (c1 != c2)\n\t\t    {\n\t\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t\t\t    \"difference at byte %ld, line %ld\",\n\t\t\t\t\t\t\t     count, linecount);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t++count;\n\t\tif (c1 == NL)\n\t\t{\n\t\t    ++linecount;\n\t\t    lineidx = 0;\n\t\t}\n\t\telse if (lineidx + 2 == (int)sizeof(line1))\n\t\t{\n\t\t    mch_memmove(line1, line1 + 100, lineidx - 100);\n\t\t    mch_memmove(line2, line2 + 100, lineidx - 100);\n\t\t    lineidx -= 100;\n\t\t}\n\t    }\n\t    fclose(fd1);\n\t    fclose(fd2);\n\t}\n    }\n    if (IObuff[0] != NUL)\n    {\n\tprepare_assert_error(&ga);\n\tif (argvars[2].v_type != VAR_UNKNOWN)\n\t{\n\t    char_u\tnumbuf[NUMBUFLEN];\n\t    char_u\t*tofree;\n\n\t    ga_concat(&ga, echo_string(&argvars[2], &tofree, numbuf, 0));\n\t    vim_free(tofree);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t}\n\tga_concat(&ga, IObuff);\n\tif (lineidx > 0)\n\t{\n\t    line1[lineidx] = NUL;\n\t    line2[lineidx] = NUL;\n\t    ga_concat(&ga, (char_u *)\" after \\\"\");\n\t    ga_concat(&ga, (char_u *)line1);\n\t    if (STRCMP(line1, line2) != 0)\n\t    {\n\t\tga_concat(&ga, (char_u *)\"\\\" vs \\\"\");\n\t\tga_concat(&ga, (char_u *)line2);\n\t    }\n\t    ga_concat(&ga, (char_u *)\"\\\"\");\n\t}\n\tassert_error(&ga);\n\tga_clear(&ga);\n\treturn 1;\n    }\n    return 0;\n}\n\n/*\n * \"assert_equalfile(fname-one, fname-two[, msg])\" function\n */\n    void\nf_assert_equalfile(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    rettv->vval.v_number = assert_equalfile(argvars);\n}\n\n/*\n * \"assert_notequal(expected, actual[, msg])\" function\n */\n    void\nf_assert_notequal(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);\n}\n\n/*\n * \"assert_exception(string[, msg])\" function\n */\n    void\nf_assert_exception(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n    char_u\t*error;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    error = tv_get_string_chk(&argvars[0]);\n    if (*get_vim_var_str(VV_EXCEPTION) == NUL)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"v:exception is not set\");\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (error != NULL\n\t&& strstr((char *)get_vim_var_str(VV_EXCEPTION), (char *)error) == NULL)\n    {\n\tprepare_assert_error(&ga);\n\tfill_assert_error(&ga, &argvars[1], NULL, &argvars[0],\n\t\t\t\t  get_vim_var_tv(VV_EXCEPTION), ASSERT_OTHER);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n}\n\n/*\n * \"assert_fails(cmd [, error[, msg]])\" function\n */\n    void\nf_assert_fails(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*cmd;\n    garray_T\tga;\n    int\t\tsave_trylevel = trylevel;\n    int\t\tcalled_emsg_before = called_emsg;\n    char\t*wrong_arg_msg = NULL;\n    char_u\t*tofree = NULL;\n\n    if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n\t    || (argvars[1].v_type != VAR_UNKNOWN\n\t\t&& (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && (check_for_opt_number_arg(argvars, 3) == FAIL\n\t\t\t|| (argvars[3].v_type != VAR_UNKNOWN\n\t\t\t    && check_for_opt_string_arg(argvars, 4) == FAIL)))))\n\treturn;\n\n    cmd = tv_get_string_chk(&argvars[0]);\n\n    // trylevel must be zero for a \":throw\" command to be considered failed\n    trylevel = 0;\n    suppress_errthrow = TRUE;\n    in_assert_fails = TRUE;\n\n    do_cmdline_cmd(cmd);\n    if (called_emsg == called_emsg_before)\n    {\n\tprepare_assert_error(&ga);\n\tga_concat(&ga, (char_u *)\"command did not fail: \");\n\tassert_append_cmd_or_arg(&ga, argvars, cmd);\n\tassert_error(&ga);\n\tga_clear(&ga);\n\trettv->vval.v_number = 1;\n    }\n    else if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tchar_u\tbuf[NUMBUFLEN];\n\tchar_u\t*expected;\n\tchar_u\t*expected_str = NULL;\n\tint\terror_found = FALSE;\n\tint\terror_found_index = 1;\n\tchar_u\t*actual = emsg_assert_fails_msg == NULL ? (char_u *)\"[unknown]\"\n\t\t\t\t\t\t       : emsg_assert_fails_msg;\n\n\tif (argvars[1].v_type == VAR_STRING)\n\t{\n\t    expected = tv_get_string_buf_chk(&argvars[1], buf);\n\t    error_found = expected == NULL\n\t\t\t   || strstr((char *)actual, (char *)expected) == NULL;\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    list_T\t*list = argvars[1].vval.v_list;\n\t    typval_T\t*tv;\n\n\t    if (list == NULL || list->lv_len < 1 || list->lv_len > 2)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_second_arg;\n\t\tgoto theend;\n\t    }\n\t    CHECK_LIST_MATERIALIZE(list);\n\t    tv = &list->lv_first->li_tv;\n\t    expected = tv_get_string_buf_chk(tv, buf);\n\t    if (!pattern_match(expected, actual, FALSE))\n\t    {\n\t\terror_found = TRUE;\n\t\texpected_str = expected;\n\t    }\n\t    else if (list->lv_len == 2)\n\t    {\n\t\t// make a copy, an error in pattern_match() may free it\n\t\ttofree = actual = vim_strsave(get_vim_var_str(VV_ERRMSG));\n\t\tif (actual != NULL)\n\t\t{\n\t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n\t\t    expected = tv_get_string_buf_chk(tv, buf);\n\t\t    if (!pattern_match(expected, actual, FALSE))\n\t\t    {\n\t\t\terror_found = TRUE;\n\t\t\texpected_str = expected;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    wrong_arg_msg = e_assert_fails_second_arg;\n\t    goto theend;\n\t}\n\n\tif (!error_found && argvars[2].v_type != VAR_UNKNOWN\n\t\t&& argvars[3].v_type != VAR_UNKNOWN)\n\t{\n\t    if (argvars[3].v_type != VAR_NUMBER)\n\t    {\n\t\twrong_arg_msg = e_assert_fails_fourth_argument;\n\t\tgoto theend;\n\t    }\n\t    else if (argvars[3].vval.v_number >= 0\n\t\t\t && argvars[3].vval.v_number != emsg_assert_fails_lnum)\n\t    {\n\t\terror_found = TRUE;\n\t\terror_found_index = 3;\n\t    }\n\t    if (!error_found && argvars[4].v_type != VAR_UNKNOWN)\n\t    {\n\t\tif (argvars[4].v_type != VAR_STRING)\n\t\t{\n\t\t    wrong_arg_msg = e_assert_fails_fifth_argument;\n\t\t    goto theend;\n\t\t}\n\t\telse if (argvars[4].vval.v_string != NULL\n\t\t    && !pattern_match(argvars[4].vval.v_string,\n\t\t\t\t\t     emsg_assert_fails_context, FALSE))\n\t\t{\n\t\t    error_found = TRUE;\n\t\t    error_found_index = 4;\n\t\t}\n\t    }\n\t}\n\n\tif (error_found)\n\t{\n\t    typval_T actual_tv;\n\n\t    prepare_assert_error(&ga);\n\t    if (error_found_index == 3)\n\t    {\n\t\tactual_tv.v_type = VAR_NUMBER;\n\t\tactual_tv.vval.v_number = emsg_assert_fails_lnum;\n\t    }\n\t    else if (error_found_index == 4)\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = emsg_assert_fails_context;\n\t    }\n\t    else\n\t    {\n\t\tactual_tv.v_type = VAR_STRING;\n\t\tactual_tv.vval.v_string = actual;\n\t    }\n\t    fill_assert_error(&ga, &argvars[2], expected_str,\n\t\t\t&argvars[error_found_index], &actual_tv, ASSERT_OTHER);\n\t    ga_concat(&ga, (char_u *)\": \");\n\t    assert_append_cmd_or_arg(&ga, argvars, cmd);\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    rettv->vval.v_number = 1;\n\t}\n    }\n\ntheend:\n    trylevel = save_trylevel;\n    suppress_errthrow = FALSE;\n    in_assert_fails = FALSE;\n    did_emsg = FALSE;\n    got_int = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    msg_scrolled = 0;\n    lines_left = Rows;\n    VIM_CLEAR(emsg_assert_fails_msg);\n    vim_free(tofree);\n    set_vim_var_string(VV_ERRMSG, NULL, 0);\n    if (wrong_arg_msg != NULL)\n\temsg(_(wrong_arg_msg));\n}\n\n/*\n * \"assert_false(actual[, msg])\" function\n */\n    void\nf_assert_false(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_bool(argvars, FALSE);\n}\n\n    static int\nassert_inrange(typval_T *argvars)\n{\n    garray_T\tga;\n    int\t\terror = FALSE;\n    char_u\t*tofree;\n    char\tmsg[200];\n    char_u\tnumbuf[NUMBUFLEN];\n\n#ifdef FEAT_FLOAT\n    if (argvars[0].v_type == VAR_FLOAT\n\t    || argvars[1].v_type == VAR_FLOAT\n\t    || argvars[2].v_type == VAR_FLOAT)\n    {\n\tfloat_T flower = tv_get_float(&argvars[0]);\n\tfloat_T fupper = tv_get_float(&argvars[1]);\n\tfloat_T factual = tv_get_float(&argvars[2]);\n\n\tif (factual < flower || factual > fupper)\n\t{\n\t    prepare_assert_error(&ga);\n\t    if (argvars[3].v_type != VAR_UNKNOWN)\n\t    {\n\t\tga_concat(&ga, tv2string(&argvars[3], &tofree, numbuf, 0));\n\t\tvim_free(tofree);\n\t    }\n\t    else\n\t    {\n\t\tvim_snprintf(msg, 200, \"Expected range %g - %g, but got %g\",\n\t\t\t\t\t\t      flower, fupper, factual);\n\t\tga_concat(&ga, (char_u *)msg);\n\t    }\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    return 1;\n\t}\n    }\n    else\n#endif\n    {\n\tvarnumber_T\tlower = tv_get_number_chk(&argvars[0], &error);\n\tvarnumber_T\tupper = tv_get_number_chk(&argvars[1], &error);\n\tvarnumber_T\tactual = tv_get_number_chk(&argvars[2], &error);\n\n\tif (error)\n\t    return 0;\n\tif (actual < lower || actual > upper)\n\t{\n\t    prepare_assert_error(&ga);\n\t    if (argvars[3].v_type != VAR_UNKNOWN)\n\t    {\n\t\tga_concat(&ga, tv2string(&argvars[3], &tofree, numbuf, 0));\n\t\tvim_free(tofree);\n\t    }\n\t    else\n\t    {\n\t\tvim_snprintf(msg, 200, \"Expected range %ld - %ld, but got %ld\",\n\t\t\t\t       (long)lower, (long)upper, (long)actual);\n\t\tga_concat(&ga, (char_u *)msg);\n\t    }\n\t    assert_error(&ga);\n\t    ga_clear(&ga);\n\t    return 1;\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"assert_inrange(lower, upper[, msg])\" function\n */\n    void\nf_assert_inrange(typval_T *argvars, typval_T *rettv)\n{\n    if (check_for_float_or_nr_arg(argvars, 0) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 1) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 2) == FAIL\n\t    || check_for_opt_string_arg(argvars, 3) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_inrange(argvars);\n}\n\n/*\n * \"assert_match(pattern, actual[, msg])\" function\n */\n    void\nf_assert_match(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_match_common(argvars, ASSERT_MATCH);\n}\n\n/*\n * \"assert_notmatch(pattern, actual[, msg])\" function\n */\n    void\nf_assert_notmatch(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);\n}\n\n/*\n * \"assert_report(msg)\" function\n */\n    void\nf_assert_report(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    prepare_assert_error(&ga);\n    ga_concat(&ga, tv_get_string(&argvars[0]));\n    assert_error(&ga);\n    ga_clear(&ga);\n    rettv->vval.v_number = 1;\n}\n\n/*\n * \"assert_true(actual[, msg])\" function\n */\n    void\nf_assert_true(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_bool(argvars, TRUE);\n}\n\n/*\n * \"test_alloc_fail(id, countdown, repeat)\" function\n */\n    void\nf_test_alloc_fail(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_NUMBER\n\t    || argvars[0].vval.v_number <= 0\n\t    || argvars[1].v_type != VAR_NUMBER\n\t    || argvars[1].vval.v_number < 0\n\t    || argvars[2].v_type != VAR_NUMBER)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\talloc_fail_id = argvars[0].vval.v_number;\n\tif (alloc_fail_id >= aid_last)\n\t    emsg(_(e_invalid_argument));\n\talloc_fail_countdown = argvars[1].vval.v_number;\n\talloc_fail_repeat = argvars[2].vval.v_number;\n\tdid_outofmem_msg = FALSE;\n    }\n}\n\n/*\n * \"test_autochdir()\"\n */\n    void\nf_test_autochdir(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#if defined(FEAT_AUTOCHDIR)\n    test_autochdir = TRUE;\n#endif\n}\n\n/*\n * \"test_feedinput()\"\n */\n    void\nf_test_feedinput(typval_T *argvars, typval_T *rettv UNUSED)\n{\n#ifdef USE_INPUT_BUF\n    char_u\t*val;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    val = tv_get_string_chk(&argvars[0]);\n# ifdef VIMDLL\n    // this doesn't work in the console\n    if (!gui.in_use)\n\treturn;\n# endif\n\n    if (val != NULL)\n    {\n\ttrash_input_buf();\n\tadd_to_input_buf_csi(val, (int)STRLEN(val));\n    }\n#endif\n}\n\n/*\n * \"test_getvalue({name})\" function\n */\n    void\nf_test_getvalue(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tchar_u *name = tv_get_string(&argvars[0]);\n\n\tif (STRCMP(name, (char_u *)\"need_fileinfo\") == 0)\n\t    rettv->vval.v_number = need_fileinfo;\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_option_not_set({name})\" function\n */\n    void\nf_test_option_not_set(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    char_u *name = (char_u *)\"\";\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tname = tv_get_string(&argvars[0]);\n\tif (reset_option_was_set(name) == FAIL)\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_override({name}, {val})\" function\n */\n    void\nf_test_override(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    char_u *name = (char_u *)\"\";\n    int     val;\n    static int save_starting = -1;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING\n\t    || (argvars[1].v_type) != VAR_NUMBER)\n\temsg(_(e_invalid_argument));\n    else\n    {\n\tname = tv_get_string(&argvars[0]);\n\tval = (int)tv_get_number(&argvars[1]);\n\n\tif (STRCMP(name, (char_u *)\"redraw\") == 0)\n\t    disable_redraw_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"redraw_flag\") == 0)\n\t    ignore_redraw_flag_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"char_avail\") == 0)\n\t    disable_char_avail_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"starting\") == 0)\n\t{\n\t    if (val)\n\t    {\n\t\tif (save_starting < 0)\n\t\t    save_starting = starting;\n\t\tstarting = 0;\n\t    }\n\t    else\n\t    {\n\t\tstarting = save_starting;\n\t\tsave_starting = -1;\n\t    }\n\t}\n\telse if (STRCMP(name, (char_u *)\"nfa_fail\") == 0)\n\t    nfa_fail_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"no_query_mouse\") == 0)\n\t    no_query_mouse_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"no_wait_return\") == 0)\n\t    no_wait_return = val;\n\telse if (STRCMP(name, (char_u *)\"ui_delay\") == 0)\n\t    ui_delay_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"term_props\") == 0)\n\t    reset_term_props_on_termresponse = val;\n\telse if (STRCMP(name, (char_u *)\"vterm_title\") == 0)\n\t    disable_vterm_title_for_testing = val;\n\telse if (STRCMP(name, (char_u *)\"uptime\") == 0)\n\t    override_sysinfo_uptime = val;\n\telse if (STRCMP(name, (char_u *)\"alloc_lines\") == 0)\n\t    ml_get_alloc_lines = val;\n\telse if (STRCMP(name, (char_u *)\"autoload\") == 0)\n\t    override_autoload = val;\n\telse if (STRCMP(name, (char_u *)\"ALL\") == 0)\n\t{\n\t    disable_char_avail_for_testing = FALSE;\n\t    disable_redraw_for_testing = FALSE;\n\t    ignore_redraw_flag_for_testing = FALSE;\n\t    nfa_fail_for_testing = FALSE;\n\t    no_query_mouse_for_testing = FALSE;\n\t    ui_delay_for_testing = 0;\n\t    reset_term_props_on_termresponse = FALSE;\n\t    override_sysinfo_uptime = -1;\n\t    // ml_get_alloc_lines is not reset by \"ALL\"\n\t    if (save_starting >= 0)\n\t    {\n\t\tstarting = save_starting;\n\t\tsave_starting = -1;\n\t    }\n\t}\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n    }\n}\n\n/*\n * \"test_refcount({expr})\" function\n */\n    void\nf_test_refcount(typval_T *argvars, typval_T *rettv)\n{\n    int retval = -1;\n\n    switch (argvars[0].v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_STRING:\n\tcase VAR_INSTR:\n\t    break;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (argvars[0].vval.v_job != NULL)\n\t\tretval = argvars[0].vval.v_job->jv_refcount - 1;\n#endif\n\t    break;\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    if (argvars[0].vval.v_channel != NULL)\n\t\tretval = argvars[0].vval.v_channel->ch_refcount - 1;\n#endif\n\t    break;\n\tcase VAR_FUNC:\n\t    if (argvars[0].vval.v_string != NULL)\n\t    {\n\t\tufunc_T *fp;\n\n\t\tfp = find_func(argvars[0].vval.v_string, FALSE);\n\t\tif (fp != NULL)\n\t\t    retval = fp->uf_refcount;\n\t    }\n\t    break;\n\tcase VAR_PARTIAL:\n\t    if (argvars[0].vval.v_partial != NULL)\n\t\tretval = argvars[0].vval.v_partial->pt_refcount - 1;\n\t    break;\n\tcase VAR_BLOB:\n\t    if (argvars[0].vval.v_blob != NULL)\n\t\tretval = argvars[0].vval.v_blob->bv_refcount - 1;\n\t    break;\n\tcase VAR_LIST:\n\t    if (argvars[0].vval.v_list != NULL)\n\t\tretval = argvars[0].vval.v_list->lv_refcount - 1;\n\t    break;\n\tcase VAR_DICT:\n\t    if (argvars[0].vval.v_dict != NULL)\n\t\tretval = argvars[0].vval.v_dict->dv_refcount - 1;\n\t    break;\n    }\n\n    rettv->v_type = VAR_NUMBER;\n    rettv->vval.v_number = retval;\n\n}\n\n/*\n * \"test_garbagecollect_now()\" function\n */\n    void\nf_test_garbagecollect_now(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    // This is dangerous, any Lists and Dicts used internally may be freed\n    // while still in use.\n    if (!get_vim_var_nr(VV_TESTING))\n\temsg(_(e_calling_test_garbagecollect_now_while_v_testing_is_not_set));\n    else\n\tgarbage_collect(TRUE);\n}\n\n/*\n * \"test_garbagecollect_soon()\" function\n */\n    void\nf_test_garbagecollect_soon(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n    may_garbage_collect = TRUE;\n}\n\n/*\n * \"test_ignore_error()\" function\n */\n    void\nf_test_ignore_error(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_STRING)\n\temsg(_(e_invalid_argument));\n    else\n\tignore_error_for_testing(tv_get_string(&argvars[0]));\n}\n\n    void\nf_test_null_blob(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_BLOB;\n    rettv->vval.v_blob = NULL;\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    void\nf_test_null_channel(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_CHANNEL;\n    rettv->vval.v_channel = NULL;\n}\n#endif\n\n    void\nf_test_null_dict(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv_dict_set(rettv, NULL);\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    void\nf_test_null_job(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_JOB;\n    rettv->vval.v_job = NULL;\n}\n#endif\n\n    void\nf_test_null_list(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv_list_set(rettv, NULL);\n}\n\n    void\nf_test_null_function(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_FUNC;\n    rettv->vval.v_string = NULL;\n}\n\n    void\nf_test_null_partial(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_PARTIAL;\n    rettv->vval.v_partial = NULL;\n}\n\n    void\nf_test_null_string(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n}\n\n    void\nf_test_unknown(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_UNKNOWN;\n}\n\n    void\nf_test_void(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_VOID;\n}\n\n    void\nf_test_setmouse(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type) != VAR_NUMBER)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    mouse_row = (time_t)tv_get_number(&argvars[0]) - 1;\n    mouse_col = (time_t)tv_get_number(&argvars[1]) - 1;\n}\n\n# ifdef FEAT_GUI\n    static int\ntest_gui_drop_files(dict_T *args UNUSED)\n{\n#  if defined(HAVE_DROP_FILE)\n    int\t\trow;\n    int\t\tcol;\n    int_u\tmods;\n    char_u\t**fnames;\n    int\t\tcount = 0;\n    typval_T\tt;\n    list_T\t*l;\n    listitem_T\t*li;\n\n    if (!dict_has_key(args, \"files\")\n\t    || !dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\")\n\t    || !dict_has_key(args, \"modifiers\"))\n\treturn FALSE;\n\n    (void)dict_get_tv(args, \"files\", &t);\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n    mods = (int)dict_get_number(args, \"modifiers\");\n\n    if (t.v_type != VAR_LIST || list_len(t.vval.v_list) == 0)\n\treturn FALSE;\n\n    l = t.vval.v_list;\n    fnames = ALLOC_MULT(char_u *, list_len(l));\n    if (fnames == NULL)\n\treturn FALSE;\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\t// ignore non-string items\n\tif (li->li_tv.v_type != VAR_STRING\n\t\t|| li->li_tv.vval.v_string == NULL)\n\t    continue;\n\n\tfnames[count] = vim_strsave(li->li_tv.vval.v_string);\n\tif (fnames[count] == NULL)\n\t{\n\t    while (--count >= 0)\n\t\tvim_free(fnames[count]);\n\t    vim_free(fnames);\n\t    return FALSE;\n\t}\n\tcount++;\n    }\n\n    if (count > 0)\n\tgui_handle_drop(TEXT_X(col - 1), TEXT_Y(row - 1), mods, fnames, count);\n    else\n\tvim_free(fnames);\n#  endif\n\n    return TRUE;\n}\n\n#if defined(FIND_REPLACE_DIALOG)\n    static int\ntest_gui_find_repl(dict_T *args)\n{\n    int\t\tflags;\n    char_u\t*find_text;\n    char_u\t*repl_text;\n    int\t\tforward;\n    int\t\tretval;\n\n    if (!dict_has_key(args, \"find_text\")\n\t    || !dict_has_key(args, \"repl_text\")\n\t    || !dict_has_key(args, \"flags\")\n\t    || !dict_has_key(args, \"forward\"))\n\treturn FALSE;\n\n    find_text = dict_get_string(args, \"find_text\", TRUE);\n    repl_text = dict_get_string(args, \"repl_text\", TRUE);\n    flags = (int)dict_get_number(args, \"flags\");\n    forward = (int)dict_get_number(args, \"forward\");\n\n    retval = gui_do_findrepl(flags, find_text, repl_text, forward);\n    vim_free(find_text);\n    vim_free(repl_text);\n\n    return retval;\n}\n#endif\n\n    static int\ntest_gui_mouse_event(dict_T *args)\n{\n    int\t\tbutton;\n    int\t\trow;\n    int\t\tcol;\n    int\t\trepeated_click;\n    int_u\tmods;\n    int\t\tmove;\n\n    if (!dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\"))\n\treturn FALSE;\n\n    // Note: \"move\" is optional, requires fewer arguments\n    move = (int)dict_get_bool(args, \"move\", FALSE);\n\n    if (!move && (!dict_has_key(args, \"button\")\n\t    || !dict_has_key(args, \"multiclick\")\n\t    || !dict_has_key(args, \"modifiers\")))\n\treturn FALSE;\n\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n\n    if (move)\n    {\n\tif (dict_get_bool(args, \"cell\", FALSE))\n\t{\n\t    // click in the middle of the character cell\n\t    row = row * gui.char_height + gui.char_height / 2;\n\t    col = col * gui.char_width + gui.char_width / 2;\n\t}\n\tgui_mouse_moved(col, row);\n    }\n    else\n    {\n\tbutton = (int)dict_get_number(args, \"button\");\n\trepeated_click = (int)dict_get_number(args, \"multiclick\");\n\tmods = (int)dict_get_number(args, \"modifiers\");\n\n\t// Reset the scroll values to known values.\n\t// XXX: Remove this when/if the scroll step is made configurable.\n\tmouse_set_hor_scroll_step(6);\n\tmouse_set_vert_scroll_step(3);\n\n\tgui_send_mouse_event(button, TEXT_X(col - 1), TEXT_Y(row - 1),\n\t\t\t\t\t\t\trepeated_click, mods);\n    }\n\n    return TRUE;\n}\n\n    static int\ntest_gui_scrollbar(dict_T *args)\n{\n    char_u\t*which;\n    long\tvalue;\n    int\t\tdragging;\n    scrollbar_T *sb = NULL;\n\n    if (!dict_has_key(args, \"which\")\n\t    || !dict_has_key(args, \"value\")\n\t    || !dict_has_key(args, \"dragging\"))\n\treturn FALSE;\n\n    which = dict_get_string(args, \"which\", FALSE);\n    value = (long)dict_get_number(args, \"value\");\n    dragging = (int)dict_get_number(args, \"dragging\");\n\n    if (STRCMP(which, \"left\") == 0)\n\tsb = &curwin->w_scrollbars[SBAR_LEFT];\n    else if (STRCMP(which, \"right\") == 0)\n\tsb = &curwin->w_scrollbars[SBAR_RIGHT];\n    else if (STRCMP(which, \"hor\") == 0)\n\tsb = &gui.bottom_sbar;\n    if (sb == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), which);\n\treturn FALSE;\n    }\n    gui_drag_scrollbar(sb, value, dragging);\n#  ifndef USE_ON_FLY_SCROLL\n    // need to loop through normal_cmd() to handle the scroll events\n    exec_normal(FALSE, TRUE, FALSE);\n#  endif\n\n    return TRUE;\n}\n\n    static int\ntest_gui_tabline_event(dict_T *args UNUSED)\n{\n#  ifdef FEAT_GUI_TABLINE\n    int\t\ttabnr;\n\n    if (!dict_has_key(args, \"tabnr\"))\n\treturn FALSE;\n\n    tabnr = (int)dict_get_number(args, \"tabnr\");\n\n    return send_tabline_event(tabnr);\n#  else\n    return FALSE;\n#  endif\n}\n\n    static int\ntest_gui_tabmenu_event(dict_T *args UNUSED)\n{\n#  ifdef FEAT_GUI_TABLINE\n    int\ttabnr;\n    int\titem;\n\n    if (!dict_has_key(args, \"tabnr\")\n\t    || !dict_has_key(args, \"item\"))\n\treturn FALSE;\n\n    tabnr = (int)dict_get_number(args, \"tabnr\");\n    item = (int)dict_get_number(args, \"item\");\n\n    send_tabline_menu_event(tabnr, item);\n#  endif\n    return TRUE;\n}\n# endif\n\n    void\nf_test_gui_event(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_GUI\n    char_u\t*event;\n\n    rettv->v_type = VAR_BOOL;\n    rettv->vval.v_number = FALSE;\n\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn;\n    }\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_dict_arg(argvars, 1) == FAIL\n\t    || argvars[1].vval.v_dict == NULL)\n\treturn;\n\n    event = tv_get_string(&argvars[0]);\n    if (STRCMP(event, \"dropfiles\") == 0)\n\trettv->vval.v_number = test_gui_drop_files(argvars[1].vval.v_dict);\n#  if defined(FIND_REPLACE_DIALOG)\n    else if (STRCMP(event, \"findrepl\") == 0)\n\trettv->vval.v_number = test_gui_find_repl(argvars[1].vval.v_dict);\n#  endif\n    else if (STRCMP(event, \"mouse\") == 0)\n\trettv->vval.v_number = test_gui_mouse_event(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"scrollbar\") == 0)\n\trettv->vval.v_number = test_gui_scrollbar(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"tabline\") == 0)\n\trettv->vval.v_number = test_gui_tabline_event(argvars[1].vval.v_dict);\n    else if (STRCMP(event, \"tabmenu\") == 0)\n\trettv->vval.v_number = test_gui_tabmenu_event(argvars[1].vval.v_dict);\n#  ifdef FEAT_GUI_MSWIN\n    else if (STRCMP(event, \"sendevent\") == 0)\n\trettv->vval.v_number = test_gui_w32_sendevent(argvars[1].vval.v_dict);\n#  endif\n    else\n    {\n\tsemsg(_(e_invalid_argument_str), event);\n\treturn;\n    }\n# endif\n}\n\n    void\nf_test_settime(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    time_for_testing = (time_t)tv_get_number(&argvars[0]);\n}\n\n#endif // defined(FEAT_EVAL)\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/testdir/test_assert.vim", "src/testing.c", "src/version.c"], "buggy_code_start_loc": [293, 599, 737], "buggy_code_end_loc": [293, 751, 737], "fixing_code_start_loc": [294, 600, 738], "fixing_code_end_loc": [298, 758, 740], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0213.", "other": {"cve": {"id": "CVE-2022-2817", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-15T23:15:09.057", "lastModified": "2023-05-03T12:16:02.340", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0213."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0213."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0213", "matchCriteriaId": "29937142-A4A4-4BEE-8180-F7F75AED584E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/249e1b903a9c0460d618f6dcc59aeb8c03b24b20", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a7b7d242-3d88-4bde-a681-6c986aff886f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CHFAR6OY6G77M6GXCJT75A4KITLNR6GO/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/249e1b903a9c0460d618f6dcc59aeb8c03b24b20"}}