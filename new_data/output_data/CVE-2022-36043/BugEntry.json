{"buggy_code": ["// SPDX-FileCopyrightText: 2015-2019 deepakchethan <deepakchethan@outlook.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"qnx/qnx.h\"\n#include \"../i/private.h\"\n\nstatic int lmf_header_load(lmf_header *lmfh, RzBuffer *buf, Sdb *db) {\n\tif (rz_buf_size(buf) < sizeof(lmf_header)) {\n\t\treturn false;\n\t}\n\tif (rz_buf_fread_at(buf, QNX_HEADER_ADDR, (ut8 *)lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tsdb_set(db, \"qnx.version\", sdb_fmt(\"0x%xH\", lmfh->version), 0);\n\tsdb_set(db, \"qnx.cflags\", sdb_fmt(\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set(db, \"qnx.cpu\", sdb_fmt(\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set(db, \"qnx.fpu\", sdb_fmt(\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set(db, \"qnx.code_index\", sdb_fmt(\"0x%x\", lmfh->code_index), 0);\n\tsdb_set(db, \"qnx.stack_index\", sdb_fmt(\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set(db, \"qnx.heap_index\", sdb_fmt(\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set(db, \"qnx.argv_index\", sdb_fmt(\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set(db, \"qnx.code_offset\", sdb_fmt(\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set(db, \"qnx.stack_nbytes\", sdb_fmt(\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set(db, \"qnx.heap_nbytes\", sdb_fmt(\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set(db, \"qnx.image_base\", sdb_fmt(\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}\n\nstatic bool check_buffer(RzBuffer *buf) {\n\tut8 tmp[6];\n\tint r = rz_buf_read_at(buf, 0, tmp, sizeof(tmp));\n\treturn r == sizeof(tmp) && !memcmp(tmp, QNX_MAGIC, sizeof(tmp));\n}\n\n// Frees the bin_obj of the binary file\nstatic void destroy(RzBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\trz_list_free(qo->sections);\n\trz_list_free(qo->maps);\n\trz_list_free(qo->fixups);\n\tbf->o->bin_obj = NULL;\n\tfree(qo);\n}\n\nstatic bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\n\tQnxObj *qo = RZ_NEW0(QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\n\tRzList *sections = rz_list_newf((RzListFree)rz_bin_section_free);\n\tRzList *maps = rz_list_newf((RzListFree)rz_bin_map_free);\n\tRzList *fixups = rz_list_newf(free);\n\tif (!sections || !maps || !fixups) {\n\t\tgoto beach;\n\t}\n\tqo->kv = sdb_new0();\n\tif (!qo->kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (rz_buf_fread_at(bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load(&qo->lmfh, bf->buf, qo->kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof(lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof(lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tRzBinSection *ptr = RZ_NEW0(RzBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup(\"LMF_RESOURCE\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof(lmf_resource);\n\t\t\tptr->size = ptr->vsize;\n\t\t\trz_list_append(sections, ptr);\n\n\t\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\t\tif (!map) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmap->name = ptr->name ? strdup(ptr->name) : NULL;\n\t\t\tmap->paddr = ptr->paddr;\n\t\t\tmap->psize = ptr->size;\n\t\t\tmap->vsize = ptr->vsize;\n\t\t\trz_list_append(maps, map);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRzBinSection *ptr = RZ_NEW0(RzBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup(\"LMF_LOAD\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vaddr = ldata.offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof(lmf_data);\n\t\t\tptr->size = ptr->vsize;\n\t\t\trz_list_append(sections, ptr);\n\n\t\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\t\tif (!map) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmap->name = ptr->name ? strdup(ptr->name) : NULL;\n\t\t\tmap->paddr = ptr->paddr;\n\t\t\tmap->psize = ptr->size;\n\t\t\tmap->vsize = ptr->vsize;\n\t\t\trz_list_append(maps, map);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRzBinReloc *ptr = RZ_NEW0(RzBinReloc);\n\t\t\tif (!ptr || rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'f'; // \"LMF_FIXUP\";\n\t\t\trz_list_append(fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRzBinReloc *ptr = RZ_NEW0(RzBinReloc);\n\t\t\tif (!ptr || rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'F'; // \"LMF_8087_FIXUP\";\n\t\t\trz_list_append(fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\trz_buf_fread_at(bf->buf, offset, (ut8 *)&qo->rwend, \"si\", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set(sdb, \"info\", qo->kv);\n\tqo->sections = sections;\n\tqo->maps = maps;\n\tqo->fixups = fixups;\n\tobj->bin_obj = qo;\n\treturn true;\nbeach:\n\tfree(qo);\n\trz_list_free(fixups);\n\trz_list_free(maps);\n\trz_list_free(sections);\n\treturn false;\n}\n\n/*\n * Provides the info about the binary file\n * @param RzBinFile to extract the data from\n * @return RzBinInfo file with the info\n */\nstatic RzBinInfo *info(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o && bf->o->bin_obj, NULL);\n\tRzBinInfo *ret = RZ_NEW0(RzBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = bf->file ? strdup(bf->file) : NULL;\n\tret->type = strdup(\"QNX Executable\");\n\tret->bclass = strdup(\"qnx\");\n\tret->machine = strdup(\"i386\");\n\tret->rclass = strdup(\"QNX\");\n\tret->arch = strdup(\"x86\");\n\tret->os = strdup(\"any\");\n\tret->subsystem = strdup(\"any\");\n\tret->lang = \"C/C++\";\n\tret->signature = true;\n\treturn ret;\n}\n\nstatic RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->fixups);\n}\n\nstatic void header(RzBinFile *bf) {\n\trz_return_if_fail(bf && bf->o && bf->rbin);\n\tQnxObj *bin = bf->o->bin_obj;\n\tRzBin *rbin = bf->rbin;\n\trbin->cb_printf(\"QNX file header:\\n\");\n\trbin->cb_printf(\"version : 0x%xH\\n\", bin->lmfh.version);\n\trbin->cb_printf(\"cflags : 0x%xH\\n\", bin->lmfh.cflags);\n\trbin->cb_printf(\"cpu : 0x%xH\\n\", bin->lmfh.cpu);\n\trbin->cb_printf(\"fpu : 0x%xH\\n\", bin->lmfh.fpu);\n\trbin->cb_printf(\"code_index : 0x%xH\\n\", bin->lmfh.code_index);\n\trbin->cb_printf(\"stack_index : 0x%xH\\n\", bin->lmfh.stack_index);\n\trbin->cb_printf(\"heap_index : 0x%xH\\n\", bin->lmfh.heap_index);\n\trbin->cb_printf(\"argv_index : 0x%xH\\n\", bin->lmfh.argv_index);\n\trbin->cb_printf(\"spare2[4] : 0x0H\\n\");\n\trbin->cb_printf(\"code_offset : 0x%xH\\n\", bin->lmfh.code_offset);\n\trbin->cb_printf(\"stack_nbytes : 0x%xH\\n\", bin->lmfh.stack_nbytes);\n\trbin->cb_printf(\"heap_nbytes : 0x%xH\\n\", bin->lmfh.heap_nbytes);\n\trbin->cb_printf(\"image_base : 0x%xH\\n\", bin->lmfh.image_base);\n\trbin->cb_printf(\"spare3[2] : 0x0H\\n\");\n}\n\n/*\n * No mention of symbols in the doc\n */\nstatic RzList *symbols(RzBinFile *bf) {\n\treturn NULL;\n}\n\nstatic RzList *maps(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->maps);\n}\n\n// Returns the sections\nstatic RzList *sections(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->sections);\n}\n\n/*\n * Returns the sdb\n * @param RzBinFile\n * @return sdb of the bin_obj\n */\nstatic Sdb *get_sdb(RzBinFile *bf) {\n\tRzBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tQnxObj *qo = o->bin_obj;\n\treturn qo ? qo->kv : NULL;\n}\n\n/*\n * Returns the base address of the image from the binary header\n * @param RzBinFile\n * @return image_base address\n */\nstatic ut64 baddr(RzBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn qo ? qo->lmfh.image_base : 0;\n}\n\n/*\n * Currently both physical and virtual address are set to 0\n * The memory map has different values for entry\n */\nstatic RzList *entries(RzBinFile *bf) {\n\tRzList *ret;\n\tRzBinAddr *ptr = NULL;\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!(ret = rz_list_new())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(ptr = RZ_NEW0(RzBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = qo->lmfh.code_offset;\n\tptr->vaddr = qo->lmfh.code_offset + baddr(bf);\n\trz_list_append(ret, ptr);\n\treturn ret;\n}\n\n/*\n * @param RzBinFile\n * @return signature of the binary\n */\nstatic char *signature(RzBinFile *bf, bool json) {\n\tchar buf[64];\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!qo) {\n\t\treturn NULL;\n\t}\n\tif (json) {\n\t\tPJ *pj = pj_new();\n\t\tpj_n(pj, qo->rwend.signature);\n\t\treturn pj_drain(pj);\n\t} else {\n\t\treturn rz_str_dup(NULL, sdb_itoa(qo->rwend.signature, buf, 10));\n\t}\n}\n\n/*\n * @return: returns the vaddr\n */\nstatic ut64 get_vaddr(RzBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {\n\treturn vaddr;\n}\n\n// Declaration of the plugin\nRzBinPlugin rz_bin_plugin_qnx = {\n\t.name = \"qnx\",\n\t.desc = \"QNX executable file support\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.relocs = &relocs,\n\t.baddr = &baddr,\n\t.author = \"deepakchethan\",\n\t.check_buffer = &check_buffer,\n\t.header = &header,\n\t.get_sdb = &get_sdb,\n\t.entries = &entries,\n\t.maps = &maps,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.signature = &signature,\n\t.get_vaddr = &get_vaddr,\n\t.info = &info\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_BIN,\n\t.data = &rz_bin_plugin_qnx,\n\t.version = RZ_VERSION\n};\n#endif\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2015-2019 deepakchethan <deepakchethan@outlook.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"qnx/qnx.h\"\n#include \"../i/private.h\"\n\nstatic int lmf_header_load(lmf_header *lmfh, RzBuffer *buf, Sdb *db) {\n\tif (rz_buf_size(buf) < sizeof(lmf_header)) {\n\t\treturn false;\n\t}\n\tif (rz_buf_fread_at(buf, QNX_HEADER_ADDR, (ut8 *)lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tsdb_set(db, \"qnx.version\", sdb_fmt(\"0x%xH\", lmfh->version), 0);\n\tsdb_set(db, \"qnx.cflags\", sdb_fmt(\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set(db, \"qnx.cpu\", sdb_fmt(\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set(db, \"qnx.fpu\", sdb_fmt(\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set(db, \"qnx.code_index\", sdb_fmt(\"0x%x\", lmfh->code_index), 0);\n\tsdb_set(db, \"qnx.stack_index\", sdb_fmt(\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set(db, \"qnx.heap_index\", sdb_fmt(\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set(db, \"qnx.argv_index\", sdb_fmt(\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set(db, \"qnx.code_offset\", sdb_fmt(\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set(db, \"qnx.stack_nbytes\", sdb_fmt(\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set(db, \"qnx.heap_nbytes\", sdb_fmt(\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set(db, \"qnx.image_base\", sdb_fmt(\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}\n\nstatic bool check_buffer(RzBuffer *buf) {\n\tut8 tmp[6];\n\tint r = rz_buf_read_at(buf, 0, tmp, sizeof(tmp));\n\treturn r == sizeof(tmp) && !memcmp(tmp, QNX_MAGIC, sizeof(tmp));\n}\n\n// Frees the bin_obj of the binary file\nstatic void destroy(RzBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\trz_list_free(qo->sections);\n\trz_list_free(qo->maps);\n\trz_list_free(qo->fixups);\n\tbf->o->bin_obj = NULL;\n\tfree(qo);\n}\n\nstatic bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {\n\tlmf_record lrec;\n\tlmf_resource lres;\n\tlmf_data ldata;\n\tut64 offset = QNX_RECORD_SIZE;\n\n\tQnxObj *qo = RZ_NEW0(QnxObj);\n\tif (!qo) {\n\t\treturn false;\n\t}\n\n\tRzList *sections = rz_list_newf((RzListFree)rz_bin_section_free);\n\tRzList *maps = rz_list_newf((RzListFree)rz_bin_map_free);\n\tRzList *fixups = rz_list_newf(free);\n\tif (!sections || !maps || !fixups) {\n\t\tgoto beach;\n\t}\n\tqo->kv = sdb_new0();\n\tif (!qo->kv) {\n\t\tgoto beach;\n\t}\n\t// Read the first record\n\tif (rz_buf_fread_at(bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\tgoto beach;\n\t}\n\t// Load the header\n\tlmf_header_load(&qo->lmfh, bf->buf, qo->kv);\n\toffset += lrec.data_nbytes;\n\n\tfor (;;) {\n\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {\n\t\t\tgoto beach;\n\t\t}\n\t\toffset += sizeof(lmf_record);\n\n\t\tif (lrec.rec_type == LMF_IMAGE_END_REC) {\n\t\t\tbreak;\n\t\t} else if (lrec.rec_type == LMF_RESOURCE_REC) {\n\t\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof(lmf_resource)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tRzBinSection *ptr = RZ_NEW0(RzBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup(\"LMF_RESOURCE\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof(lmf_resource);\n\t\t\tptr->size = ptr->vsize;\n\t\t\trz_list_append(sections, ptr);\n\n\t\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\t\tif (!map) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmap->name = ptr->name ? strdup(ptr->name) : NULL;\n\t\t\tmap->paddr = ptr->paddr;\n\t\t\tmap->psize = ptr->size;\n\t\t\tmap->vsize = ptr->vsize;\n\t\t\trz_list_append(maps, map);\n\t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n\t\t\tRzBinSection *ptr = RZ_NEW0(RzBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->name = strdup(\"LMF_LOAD\");\n\t\t\tptr->paddr = offset;\n\t\t\tptr->vaddr = ldata.offset;\n\t\t\tptr->vsize = lrec.data_nbytes - sizeof(lmf_data);\n\t\t\tptr->size = ptr->vsize;\n\t\t\trz_list_append(sections, ptr);\n\n\t\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\t\tif (!map) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmap->name = ptr->name ? strdup(ptr->name) : NULL;\n\t\t\tmap->paddr = ptr->paddr;\n\t\t\tmap->psize = ptr->size;\n\t\t\tmap->vsize = ptr->vsize;\n\t\t\trz_list_append(maps, map);\n\t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n\t\t\tRzBinReloc *ptr = RZ_NEW0(RzBinReloc);\n\t\t\tif (!ptr || rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'f'; // \"LMF_FIXUP\";\n\t\t\trz_list_append(fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n\t\t\tRzBinReloc *ptr = RZ_NEW0(RzBinReloc);\n\t\t\tif (!ptr || rz_buf_fread_at(bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof(lmf_data)) {\n\t\t\t\tfree(ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n\t\t\tptr->type = 'F'; // \"LMF_8087_FIXUP\";\n\t\t\trz_list_append(fixups, ptr);\n\t\t} else if (lrec.rec_type == LMF_RW_END_REC) {\n\t\t\trz_buf_fread_at(bf->buf, offset, (ut8 *)&qo->rwend, \"si\", 1);\n\t\t}\n\t\toffset += lrec.data_nbytes;\n\t}\n\tsdb_ns_set(sdb, \"info\", qo->kv);\n\tqo->sections = sections;\n\tqo->maps = maps;\n\tqo->fixups = fixups;\n\tobj->bin_obj = qo;\n\treturn true;\nbeach:\n\tfree(qo);\n\trz_list_free(fixups);\n\trz_list_free(maps);\n\trz_list_free(sections);\n\treturn false;\n}\n\n/*\n * Provides the info about the binary file\n * @param RzBinFile to extract the data from\n * @return RzBinInfo file with the info\n */\nstatic RzBinInfo *info(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o && bf->o->bin_obj, NULL);\n\tRzBinInfo *ret = RZ_NEW0(RzBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = bf->file ? strdup(bf->file) : NULL;\n\tret->type = strdup(\"QNX Executable\");\n\tret->bclass = strdup(\"qnx\");\n\tret->machine = strdup(\"i386\");\n\tret->rclass = strdup(\"QNX\");\n\tret->arch = strdup(\"x86\");\n\tret->os = strdup(\"any\");\n\tret->subsystem = strdup(\"any\");\n\tret->lang = \"C/C++\";\n\tret->signature = true;\n\treturn ret;\n}\n\nstatic RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\tRzBinReloc *reloc = NULL;\n\tRzListIter *it = NULL;\n\tRzList *relocs = rz_list_newf(free);\n\tif (!relocs) {\n\t\treturn NULL;\n\t}\n\n\trz_list_foreach (qo->fixups, it, reloc) {\n\t\tRzBinReloc *copy = RZ_NEW0(RzBinReloc);\n\t\tcopy->vaddr = reloc->vaddr;\n\t\tcopy->paddr = reloc->paddr;\n\t\tcopy->type = reloc->type;\n\t\trz_list_append(relocs, copy);\n\t}\n\treturn relocs;\n}\n\nstatic void header(RzBinFile *bf) {\n\trz_return_if_fail(bf && bf->o && bf->rbin);\n\tQnxObj *bin = bf->o->bin_obj;\n\tRzBin *rbin = bf->rbin;\n\trbin->cb_printf(\"QNX file header:\\n\");\n\trbin->cb_printf(\"version : 0x%xH\\n\", bin->lmfh.version);\n\trbin->cb_printf(\"cflags : 0x%xH\\n\", bin->lmfh.cflags);\n\trbin->cb_printf(\"cpu : 0x%xH\\n\", bin->lmfh.cpu);\n\trbin->cb_printf(\"fpu : 0x%xH\\n\", bin->lmfh.fpu);\n\trbin->cb_printf(\"code_index : 0x%xH\\n\", bin->lmfh.code_index);\n\trbin->cb_printf(\"stack_index : 0x%xH\\n\", bin->lmfh.stack_index);\n\trbin->cb_printf(\"heap_index : 0x%xH\\n\", bin->lmfh.heap_index);\n\trbin->cb_printf(\"argv_index : 0x%xH\\n\", bin->lmfh.argv_index);\n\trbin->cb_printf(\"spare2[4] : 0x0H\\n\");\n\trbin->cb_printf(\"code_offset : 0x%xH\\n\", bin->lmfh.code_offset);\n\trbin->cb_printf(\"stack_nbytes : 0x%xH\\n\", bin->lmfh.stack_nbytes);\n\trbin->cb_printf(\"heap_nbytes : 0x%xH\\n\", bin->lmfh.heap_nbytes);\n\trbin->cb_printf(\"image_base : 0x%xH\\n\", bin->lmfh.image_base);\n\trbin->cb_printf(\"spare3[2] : 0x0H\\n\");\n}\n\n/*\n * No mention of symbols in the doc\n */\nstatic RzList *symbols(RzBinFile *bf) {\n\treturn NULL;\n}\n\nstatic RzList *maps(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->maps);\n}\n\n// Returns the sections\nstatic RzList *sections(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->sections);\n}\n\n/*\n * Returns the sdb\n * @param RzBinFile\n * @return sdb of the bin_obj\n */\nstatic Sdb *get_sdb(RzBinFile *bf) {\n\tRzBinObject *o = bf->o;\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tQnxObj *qo = o->bin_obj;\n\treturn qo ? qo->kv : NULL;\n}\n\n/*\n * Returns the base address of the image from the binary header\n * @param RzBinFile\n * @return image_base address\n */\nstatic ut64 baddr(RzBinFile *bf) {\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn qo ? qo->lmfh.image_base : 0;\n}\n\n/*\n * Currently both physical and virtual address are set to 0\n * The memory map has different values for entry\n */\nstatic RzList *entries(RzBinFile *bf) {\n\tRzList *ret;\n\tRzBinAddr *ptr = NULL;\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!(ret = rz_list_new())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(ptr = RZ_NEW0(RzBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = qo->lmfh.code_offset;\n\tptr->vaddr = qo->lmfh.code_offset + baddr(bf);\n\trz_list_append(ret, ptr);\n\treturn ret;\n}\n\n/*\n * @param RzBinFile\n * @return signature of the binary\n */\nstatic char *signature(RzBinFile *bf, bool json) {\n\tchar buf[64];\n\tQnxObj *qo = bf->o->bin_obj;\n\tif (!qo) {\n\t\treturn NULL;\n\t}\n\tif (json) {\n\t\tPJ *pj = pj_new();\n\t\tpj_n(pj, qo->rwend.signature);\n\t\treturn pj_drain(pj);\n\t} else {\n\t\treturn rz_str_dup(NULL, sdb_itoa(qo->rwend.signature, buf, 10));\n\t}\n}\n\n/*\n * @return: returns the vaddr\n */\nstatic ut64 get_vaddr(RzBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {\n\treturn vaddr;\n}\n\n// Declaration of the plugin\nRzBinPlugin rz_bin_plugin_qnx = {\n\t.name = \"qnx\",\n\t.desc = \"QNX executable file support\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.relocs = &relocs,\n\t.baddr = &baddr,\n\t.author = \"deepakchethan\",\n\t.check_buffer = &check_buffer,\n\t.header = &header,\n\t.get_sdb = &get_sdb,\n\t.entries = &entries,\n\t.maps = &maps,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.signature = &signature,\n\t.get_vaddr = &get_vaddr,\n\t.info = &info\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_BIN,\n\t.data = &rz_bin_plugin_qnx,\n\t.version = RZ_VERSION\n};\n#endif\n"], "filenames": ["librz/bin/p/bin_qnx.c"], "buggy_code_start_loc": [194], "buggy_code_end_loc": [195], "fixing_code_start_loc": [194], "fixing_code_end_loc": [209], "type": "CWE-415", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-36043", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T20:15:08.740", "lastModified": "2023-03-30T04:15:09.567", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una doble liberaci\u00f3n en el archivo bobj.c:rz_bin_reloc_storage_free() cuando son liberadas reubicaciones generadas desde el plugin binario qnx. Un usuario que abra un binario qnx malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. El commit n\u00famero a3d50c1ea185f3f642f2d8180715f82d98840784 contiene un parche para este problema.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/a3d50c1ea185f3f642f2d8180715f82d98840784", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/issues/2964", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-rjhv-mj4g-j4p5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/a3d50c1ea185f3f642f2d8180715f82d98840784"}}