{"buggy_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Config.h>\n#include <znc/FileUtils.h>\n#include <stack>\n#include <sstream>\n\nstruct ConfigStackEntry {\n    CString sTag;\n    CString sName;\n    CConfig Config;\n\n    ConfigStackEntry(const CString& Tag, const CString Name)\n        : sTag(Tag), sName(Name), Config() {}\n};\n\nCConfigEntry::CConfigEntry() : m_pSubConfig(nullptr) {}\n\nCConfigEntry::CConfigEntry(const CConfig& Config)\n    : m_pSubConfig(new CConfig(Config)) {}\n\nCConfigEntry::CConfigEntry(const CConfigEntry& other) : m_pSubConfig(nullptr) {\n    if (other.m_pSubConfig) m_pSubConfig = new CConfig(*other.m_pSubConfig);\n}\n\nCConfigEntry::~CConfigEntry() { delete m_pSubConfig; }\n\nCConfigEntry& CConfigEntry::operator=(const CConfigEntry& other) {\n    delete m_pSubConfig;\n    if (other.m_pSubConfig)\n        m_pSubConfig = new CConfig(*other.m_pSubConfig);\n    else\n        m_pSubConfig = nullptr;\n    return *this;\n}\n\nbool CConfig::Parse(CFile& file, CString& sErrorMsg) {\n    CString sLine;\n    unsigned int uLineNum = 0;\n    CConfig* pActiveConfig = this;\n    std::stack<ConfigStackEntry> ConfigStack;\n    bool bCommented = false;  // support for /**/ style comments\n\n    if (!file.Seek(0)) {\n        sErrorMsg = \"Could not seek to the beginning of the config.\";\n        return false;\n    }\n\n    while (file.ReadLine(sLine)) {\n        uLineNum++;\n\n#define ERROR(arg)                                             \\\n    do {                                                       \\\n        std::stringstream stream;                              \\\n        stream << \"Error on line \" << uLineNum << \": \" << arg; \\\n        sErrorMsg = stream.str();                              \\\n        m_SubConfigs.clear();                                  \\\n        m_ConfigEntries.clear();                               \\\n        return false;                                          \\\n    } while (0)\n\n        // Remove all leading spaces and trailing line endings\n        sLine.TrimLeft();\n        sLine.TrimRight(\"\\r\\n\");\n\n        if (bCommented || sLine.StartsWith(\"/*\")) {\n            /* Does this comment end on the same line again? */\n            bCommented = (!sLine.EndsWith(\"*/\"));\n\n            continue;\n        }\n\n        if ((sLine.empty()) || (sLine.StartsWith(\"#\")) ||\n            (sLine.StartsWith(\"//\"))) {\n            continue;\n        }\n\n        if ((sLine.StartsWith(\"<\")) && (sLine.EndsWith(\">\"))) {\n            sLine.LeftChomp();\n            sLine.RightChomp();\n            sLine.Trim();\n\n            CString sTag = sLine.Token(0);\n            CString sValue = sLine.Token(1, true);\n\n            sTag.Trim();\n            sValue.Trim();\n\n            if (sTag.TrimPrefix(\"/\")) {\n                if (!sValue.empty())\n                    ERROR(\"Malformated closing tag. Expected \\\"</\" << sTag\n                                                                   << \">\\\".\");\n                if (ConfigStack.empty())\n                    ERROR(\"Closing tag \\\"\" << sTag << \"\\\" which is not open.\");\n\n                const struct ConfigStackEntry& entry = ConfigStack.top();\n                CConfig myConfig(entry.Config);\n                CString sName(entry.sName);\n\n                if (!sTag.Equals(entry.sTag))\n                    ERROR(\"Closing tag \\\"\" << sTag << \"\\\" which is not open.\");\n\n                // This breaks entry\n                ConfigStack.pop();\n\n                if (ConfigStack.empty())\n                    pActiveConfig = this;\n                else\n                    pActiveConfig = &ConfigStack.top().Config;\n\n                SubConfig& conf = pActiveConfig->m_SubConfigs[sTag.AsLower()];\n                SubConfig::const_iterator it = conf.find(sName);\n\n                if (it != conf.end())\n                    ERROR(\"Duplicate entry for tag \\\"\" << sTag << \"\\\" name \\\"\"\n                                                       << sName << \"\\\".\");\n\n                conf[sName] = CConfigEntry(myConfig);\n            } else {\n                if (sValue.empty())\n                    ERROR(\"Empty block name at begin of block.\");\n                ConfigStack.push(ConfigStackEntry(sTag.AsLower(), sValue));\n                pActiveConfig = &ConfigStack.top().Config;\n            }\n\n            continue;\n        }\n\n        // If we have a regular line, figure out where it goes\n        CString sName = sLine.Token(0, false, \"=\");\n        CString sValue = sLine.Token(1, true, \"=\");\n\n        // Only remove the first space, people might want\n        // leading spaces (e.g. in the MOTD).\n        sValue.TrimPrefix(\" \");\n\n        // We don't have any names with spaces, trim all\n        // leading/trailing spaces.\n        sName.Trim();\n\n        if (sName.empty() || sValue.empty()) ERROR(\"Malformed line\");\n\n        CString sNameLower = sName.AsLower();\n        pActiveConfig->m_ConfigEntries[sNameLower].push_back(sValue);\n    }\n\n    if (bCommented) ERROR(\"Comment not closed at end of file.\");\n\n    if (!ConfigStack.empty()) {\n        const CString& sTag = ConfigStack.top().sTag;\n        ERROR(\n            \"Not all tags are closed at the end of the file. Inner-most open \"\n            \"tag is \\\"\"\n            << sTag << \"\\\".\");\n    }\n\n    return true;\n}\n\nvoid CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Config.h>\n#include <znc/FileUtils.h>\n#include <stack>\n#include <sstream>\n\nstruct ConfigStackEntry {\n    CString sTag;\n    CString sName;\n    CConfig Config;\n\n    ConfigStackEntry(const CString& Tag, const CString Name)\n        : sTag(Tag), sName(Name), Config() {}\n};\n\nCConfigEntry::CConfigEntry() : m_pSubConfig(nullptr) {}\n\nCConfigEntry::CConfigEntry(const CConfig& Config)\n    : m_pSubConfig(new CConfig(Config)) {}\n\nCConfigEntry::CConfigEntry(const CConfigEntry& other) : m_pSubConfig(nullptr) {\n    if (other.m_pSubConfig) m_pSubConfig = new CConfig(*other.m_pSubConfig);\n}\n\nCConfigEntry::~CConfigEntry() { delete m_pSubConfig; }\n\nCConfigEntry& CConfigEntry::operator=(const CConfigEntry& other) {\n    delete m_pSubConfig;\n    if (other.m_pSubConfig)\n        m_pSubConfig = new CConfig(*other.m_pSubConfig);\n    else\n        m_pSubConfig = nullptr;\n    return *this;\n}\n\nbool CConfig::Parse(CFile& file, CString& sErrorMsg) {\n    CString sLine;\n    unsigned int uLineNum = 0;\n    CConfig* pActiveConfig = this;\n    std::stack<ConfigStackEntry> ConfigStack;\n    bool bCommented = false;  // support for /**/ style comments\n\n    if (!file.Seek(0)) {\n        sErrorMsg = \"Could not seek to the beginning of the config.\";\n        return false;\n    }\n\n    while (file.ReadLine(sLine)) {\n        uLineNum++;\n\n#define ERROR(arg)                                             \\\n    do {                                                       \\\n        std::stringstream stream;                              \\\n        stream << \"Error on line \" << uLineNum << \": \" << arg; \\\n        sErrorMsg = stream.str();                              \\\n        m_SubConfigs.clear();                                  \\\n        m_ConfigEntries.clear();                               \\\n        return false;                                          \\\n    } while (0)\n\n        // Remove all leading spaces and trailing line endings\n        sLine.TrimLeft();\n        sLine.TrimRight(\"\\r\\n\");\n\n        if (bCommented || sLine.StartsWith(\"/*\")) {\n            /* Does this comment end on the same line again? */\n            bCommented = (!sLine.EndsWith(\"*/\"));\n\n            continue;\n        }\n\n        if ((sLine.empty()) || (sLine.StartsWith(\"#\")) ||\n            (sLine.StartsWith(\"//\"))) {\n            continue;\n        }\n\n        if ((sLine.StartsWith(\"<\")) && (sLine.EndsWith(\">\"))) {\n            sLine.LeftChomp();\n            sLine.RightChomp();\n            sLine.Trim();\n\n            CString sTag = sLine.Token(0);\n            CString sValue = sLine.Token(1, true);\n\n            sTag.Trim();\n            sValue.Trim();\n\n            if (sTag.TrimPrefix(\"/\")) {\n                if (!sValue.empty())\n                    ERROR(\"Malformated closing tag. Expected \\\"</\" << sTag\n                                                                   << \">\\\".\");\n                if (ConfigStack.empty())\n                    ERROR(\"Closing tag \\\"\" << sTag << \"\\\" which is not open.\");\n\n                const struct ConfigStackEntry& entry = ConfigStack.top();\n                CConfig myConfig(entry.Config);\n                CString sName(entry.sName);\n\n                if (!sTag.Equals(entry.sTag))\n                    ERROR(\"Closing tag \\\"\" << sTag << \"\\\" which is not open.\");\n\n                // This breaks entry\n                ConfigStack.pop();\n\n                if (ConfigStack.empty())\n                    pActiveConfig = this;\n                else\n                    pActiveConfig = &ConfigStack.top().Config;\n\n                SubConfig& conf = pActiveConfig->m_SubConfigs[sTag.AsLower()];\n                SubConfig::const_iterator it = conf.find(sName);\n\n                if (it != conf.end())\n                    ERROR(\"Duplicate entry for tag \\\"\" << sTag << \"\\\" name \\\"\"\n                                                       << sName << \"\\\".\");\n\n                conf[sName] = CConfigEntry(myConfig);\n            } else {\n                if (sValue.empty())\n                    ERROR(\"Empty block name at begin of block.\");\n                ConfigStack.push(ConfigStackEntry(sTag.AsLower(), sValue));\n                pActiveConfig = &ConfigStack.top().Config;\n            }\n\n            continue;\n        }\n\n        // If we have a regular line, figure out where it goes\n        CString sName = sLine.Token(0, false, \"=\");\n        CString sValue = sLine.Token(1, true, \"=\");\n\n        // Only remove the first space, people might want\n        // leading spaces (e.g. in the MOTD).\n        sValue.TrimPrefix(\" \");\n\n        // We don't have any names with spaces, trim all\n        // leading/trailing spaces.\n        sName.Trim();\n\n        if (sName.empty() || sValue.empty()) ERROR(\"Malformed line\");\n\n        CString sNameLower = sName.AsLower();\n        pActiveConfig->m_ConfigEntries[sNameLower].push_back(sValue);\n    }\n\n    if (bCommented) ERROR(\"Comment not closed at end of file.\");\n\n    if (!ConfigStack.empty()) {\n        const CString& sTag = ConfigStack.top().sTag;\n        ERROR(\n            \"Not all tags are closed at the end of the file. Inner-most open \"\n            \"tag is \\\"\"\n            << sTag << \"\\\".\");\n    }\n\n    return true;\n}\n\nvoid CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n\n    auto SingleLine = [](const CString& s) {\n        return s.Replace_n(\"\\r\", \"\").Replace_n(\"\\n\", \"\");\n    };\n\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(SingleLine(sIndentation + it.first + \" = \" + sValue) +\n                       \"\\n\");\n        }\n    }\n\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n\n            File.Write(SingleLine(sIndentation + \"<\" + it.first + \" \" +\n                                  it2.first + \">\") +\n                       \"\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(SingleLine(sIndentation + \"</\" + it.first + \">\") + \"\\n\");\n        }\n    }\n}\n"], "filenames": ["src/Config.cpp"], "buggy_code_start_loc": [176], "buggy_code_end_loc": [190], "fixing_code_start_loc": [177], "fixing_code_end_loc": [197], "type": "CWE-20", "message": "ZNC before 1.7.1-rc1 does not properly validate untrusted lines coming from the network, allowing a non-admin user to escalate his privilege and inject rogue values into znc.conf.", "other": {"cve": {"id": "CVE-2018-14055", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-15T01:29:03.587", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ZNC before 1.7.1-rc1 does not properly validate untrusted lines coming from the network, allowing a non-admin user to escalate his privilege and inject rogue values into znc.conf."}, {"lang": "es", "value": "ZNC en versiones anteriores a la 1.7.1-rc1 no valida correctamente las l\u00edneas no fiables provenientes de la red, lo que permite que un usuario que no es administrador escale sus privilegios e inyecte valores no autorizados en znc.conf."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:znc:znc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7.0", "matchCriteriaId": "D5E5C246-94BF-4233-A1A5-7924D253C052"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/znc/znc/commit/a7bfbd93812950b7444841431e8e297e62cb524e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/znc/znc/commit/d22fef8620cdd87490754f607e7153979731c69d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201807-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4252", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/znc/znc/commit/a7bfbd93812950b7444841431e8e297e62cb524e"}}